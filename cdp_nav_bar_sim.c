/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

char __cdecl sub_10001000(int a1);
bool __cdecl sub_100010B0(int a1, int a2);
// int __usercall sub_100010D0@<eax>(int result@<eax>, int a2@<esi>);
int __cdecl sub_10001180(int a1, int a2);
char __cdecl sub_100011B0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
char __cdecl sub_100012F0(int a1, int a2);
int sub_100014D0(void); // weak
unsigned int sub_100014E0();
int __cdecl sub_10001550(int a1, int a2);
int __cdecl sub_10001570(int a1);
int __cdecl sub_100015A0(int a1, int a2);
int __cdecl sub_100015C0(int a1, char *a2, int a3, int a4);
char __cdecl sub_10001650(int a1, int a2, int a3);
char __cdecl sub_100016C0(int a1, int a2, int a3);
int sub_10001730();
_DWORD *__cdecl sub_10001750(int a1);
unsigned int __cdecl sub_10001770(int a1, int a2, int a3);
// void __usercall sub_100017E0(int a1@<esi>);
// char __usercall sub_10001830@<al>(int a1@<esi>);
// void __usercall sub_10001910(int a1@<esi>, int a2);
// void __usercall sub_100019E0(int a1@<esi>, int a2);
// int __usercall sub_10001A80@<eax>(int a1@<edi>, int a2);
char __thiscall sub_10001C50(int this);
signed int __cdecl sub_10001C70(int a1, int a2);
char __cdecl sub_10001DC0(int a1, int a2, __int16 a3);
char __cdecl sub_10001DF0(int a1, int a2, __int16 a3);
char __cdecl sub_10001E20(unsigned int a1);
// int __usercall sub_10002150@<eax>(unsigned int a1@<eax>);
// void __usercall __noreturn sub_100021E0(char *a1@<edi>);
int __cdecl sub_10002420(int a1, int a2);
char __cdecl sub_10002440(int a1, unsigned int a2);
char sub_10002480();
char __thiscall sub_100024A0(int this);
// void *__usercall sub_10002610@<eax>(unsigned int a1@<ecx>, int a2@<ebx>);
char __cdecl sub_100027C0(int a1);
int __cdecl sub_100027E0(int a1, int a2);
int __cdecl sub_10002860(int a1, __int16 a2, __int16 a3);
__int16 __cdecl sub_100028A0(unsigned __int8 a1);
char __cdecl sub_100028C0(int (__cdecl *a1)(int));
char __cdecl sub_10002900(int (__cdecl *a1)(int));
char __cdecl sub_10002920(int a1, __int16 *a2, _BYTE *a3);
// char __usercall sub_100029A0@<al>(int a1@<ecx>, int a2@<edi>, unsigned int a3);
_WORD *__cdecl sub_10002B00(int a1);
// int __usercall sub_10002B70@<eax>(int a1@<esi>);
// char __usercall sub_10002BA0@<al>(int a1@<edi>);
// int __usercall sub_10002CD0@<eax>(int a1@<esi>);
char __cdecl sub_10002D30(int a1);
// char __usercall sub_10002DE0@<al>(int a1@<esi>);
// char __usercall sub_10002E40@<al>(int a1@<esi>);
// char __usercall sub_10002E60@<al>(int a1@<esi>);
// char __usercall sub_10003050@<al>(int a1@<edi>);
// char __usercall sub_10003160@<al>(int a1@<esi>);
int __cdecl sub_100031C0(int a1);
// char __usercall sub_100032F0@<al>(int a1@<ebx>);
bool __thiscall sub_100034B0(int this);
char __cdecl sub_10003660(int a1);
int sub_10003740(void); // weak
char __cdecl sub_10003750(char a1);
char sub_10003770();
void __cdecl sub_10003780(unsigned int a1);
int __cdecl nullsub_1(_DWORD, _DWORD);
char sub_10003840();
// char __usercall sub_10003850@<al>(int a1@<edi>, unsigned int a2);
char __cdecl sub_10003870(int a1);
char sub_100038E0();
void __cdecl sub_100038F0(unsigned int a1);
int sub_10003950(void); // weak
_DWORD sub_10003960(); // weak
int __cdecl j_gdi_pvg_begin(_DWORD); // weak
int __cdecl sub_100039F0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_color_u32(_DWORD); // weak
int __cdecl j_gdi_pvg_disable(_DWORD); // weak
int __cdecl sub_10003A70(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl j_gdi_pvg_enable(_DWORD); // weak
int j_gdi_pvg_end(void); // weak
int j_gdi_pvg_flush(void); // weak
int sub_10003AF0();
int __cdecl sub_10003B00(float); // idb
int __cdecl j_gdi_pvg_load_identity(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_active(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_current(_DWORD); // weak
int __cdecl j_gdi_pvg_matrix_mode(_DWORD); // weak
int __cdecl sub_10003B50(float, float, float, float, float, float); // idb
int j_gdi_pvg_pop_attrib(void); // weak
int __cdecl j_gdi_pvg_push_attrib(_DWORD); // weak
int __cdecl j_gdi_pvg_read_matrix(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_text_out_verts(_DWORD, _DWORD, _DWORD); // weak
int j_gdi_pvg_update_display_wdw(void); // weak
int __cdecl sub_10003BE0(float, float); // idb
int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD); // weak
char *__cdecl sub_10003C10(int a1, char *a2, int a3, char *a4, int a5);
char sub_10003D40();
char __cdecl sub_10003D50(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_10003E50(char *a1, int a2, char a3, char *a4);
int __cdecl sub_10003EC0(int a1, int a2, int a3);
int __cdecl j_gdi_pvg_destroy_window(_DWORD); // weak
int sub_10003F00();
int __cdecl sub_10003F50(int a1);
int __cdecl sub_10003F60(int a1);
int sub_10003F80();
int __cdecl sub_10003FA0(int a1, int a2);
__int16 __cdecl sub_10003FD0(int a1);
int sub_10003FF0();
int __cdecl sub_10004010(int a1, int a2, int a3, int a4);
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_10004050(int a1, int a2, int a3, int a4);
int __cdecl sub_10004080(int a1);
int __cdecl sub_100040A0(int a1);
int __cdecl sub_100040C0(int a1, int a2);
int __cdecl sub_100040F0(int a1, int a2, int a3, int a4);
int __cdecl sub_10004120(int a1, int a2);
int __cdecl sub_10004150(int a1);
int __cdecl sub_10004170(int a1);
char __cdecl sub_10004190(int a1, int a2);
int __cdecl sub_10004200(_BYTE *a1);
int __cdecl sub_10004240(int a1, int a2);
int __cdecl sub_10004270(int a1, int a2);
int __cdecl sub_10004290(int a1);
int __cdecl sub_100042D0(int a1, int a2, int a3);
char __cdecl sub_100042F0(int a1, int a2, int a3);
int __cdecl sub_10004330(int, void *, int, void *); // idb
int __cdecl sub_10004370(int a1, int a2, int a3);
int __cdecl sub_100043A0(int a1, int a2, int a3);
int __cdecl sub_100043C0(int a1, int a2, int a3);
int __cdecl sub_10004420(int a1, int a2, int a3);
char __cdecl sub_10004460(int a1, int a2, int a3);
int __cdecl sub_100044A0(int, void *, int, void *); // idb
void sub_100044F0();
signed int __fastcall sub_10004500(char *a1);
// int __usercall sub_10004550@<eax>(unsigned int a1@<eax>);
double __cdecl sub_10004560(int a1, int a2, float a3, float a4, float a5);
double __cdecl sub_10004700(int a1, int a2, float a3);
int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD); // weak
signed int __cdecl sub_10004770(unsigned int a1);
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl sub_100047D0(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_10004840(unsigned int a1, void *a2, int a3);
signed int __cdecl sub_10004880(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
signed int __cdecl sub_10004910(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_10004960(int a1);
int __cdecl sub_10004980(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_100049B0(int a1, int a2, int a3, char a4);
char __cdecl sub_100049D0(int a1);
signed int __cdecl sub_10004A00(unsigned int a1, int a2, int a3);
int __cdecl sub_10004A20(int a1, int a2, int a3);
void __cdecl sub_10004A40(int a1, _BYTE *a2);
int __cdecl sub_10004A70(int a1, int a2);
int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD); // weak
int j_HWM_pvg_hsdb_get_lrus_online(void); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
int sub_10004AD0(void); // weak
int sub_10004AE0(void); // weak
signed int sub_10004B00();
int __cdecl sub_10004B10(unsigned int a1);
unsigned int __cdecl sub_10004B40(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_10004CF0@<eax>(int a1@<esi>);
int __cdecl sub_10004DA0(int a1, unsigned __int64 a2);
// int __usercall sub_10004E50@<eax>(int a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_10004EE0(int a1, void *a2, int a3, int a4, int a5);
void __cdecl sub_10005030(__int16 a1, _BYTE *a2);
int __cdecl sub_10005060(int a1, int a2);
// int __usercall sub_100050C0@<eax>(const char **a1@<esi>);
// int __usercall sub_100053C0@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_100053E0(int a1);
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
int __cdecl sub_100054C0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
unsigned int __cdecl sub_100055D0(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
int __cdecl sub_100056B0(int a1);
int __cdecl sub_10005A00(int a1);
unsigned int __cdecl sub_10005BE0(int a1);
int __cdecl sub_10006110(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
_WORD *__cdecl sub_10006170(int a1);
int __cdecl sub_100061D0(int a1, int a2, char a3);
void sub_100062C0();
int __cdecl sub_100062D0(int a1, _BYTE *a2, int a3);
char __cdecl sub_10006310(char a1, char a2);
int __cdecl sub_10006330(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7);
bool __cdecl sub_10006B70(_BYTE *a1);
bool __cdecl sub_10006C10(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5);
int __cdecl sub_10006D20(int a1, _BYTE *a2, int a3);
int __cdecl sub_10006E10(int a1);
int __cdecl sub_10006FE0(int a1, signed int a2, signed int a3);
int __cdecl sub_100074B0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
int __cdecl sub_100075A0(int a1, __int16 a2, __int16 a3, char a4);
char __cdecl sub_10007AF0(int a1);
char *__cdecl sub_10007C60(int a1);
int __cdecl sub_10007DB0(int a1, int a2);
unsigned int __cdecl sub_10007ED0(int a1, int a2);
int __cdecl sub_10008070(int a1, int a2, int a3);
int __cdecl sub_100080F0(int a1, int a2, int a3);
char __cdecl sub_10008170(int a1, signed int a2, int a3, int a4);
int __cdecl sub_10008280(int a1, signed int a2, signed int a3);
int __cdecl sub_10008370(int a1, signed int a2, int a3, int a4);
int __cdecl sub_10008470(int a1, int a2);
char *__cdecl sub_100085A0(int a1, signed int a2, int a3, int *a4);
char *__cdecl sub_100086E0(int a1, signed int a2, int a3, int *a4);
int __cdecl sub_10008930(int a1, signed int a2, int a3);
int __cdecl sub_10008A70(int a1, signed int a2, int a3);
char __cdecl sub_10008BB0(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
void *__cdecl sub_10008CE0(int a1, __int16 a2);
char __cdecl sub_10008D10(int a1, int a2, char *a3);
int __cdecl sub_10008D70(int a1, int a2, int a3, signed int a4, int a5);
// char __usercall sub_10008EC0@<al>(char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>);
// char __usercall sub_10008F80@<al>(unsigned __int16 a1@<di>, int a2);
// signed int __usercall sub_10008FE0@<eax>(int a1@<edi>, unsigned __int16 a2@<si>, int a3);
signed int __cdecl sub_10009140(int a1, int a2, signed int a3);
char __cdecl sub_100091A0(int a1, int a2, int a3, char *a4);
char __cdecl sub_10009400(int a1, int a2, int a3, char *a4);
char __cdecl sub_100095F0(int a1, int a2, int a3, char *a4, int a5);
char __cdecl sub_10009850(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_10009A80(int a1, int a2, int a3, _BYTE *a4, _WORD *a5);
int __cdecl sub_10009B60(unsigned int a1, char a2, int a3, int a4);
char __cdecl sub_10009BC0(int a1, int a2, int a3, double *a4);
// char __usercall sub_1000A0C0@<al>(float *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4);
// char __usercall sub_1000A1A0@<al>(int a1@<eax>, int a2, int a3, int a4);
// char __usercall sub_1000AC70@<al>(int a1@<eax>, float *a2@<ecx>, int a3@<ebx>, int a4@<esi>, int a5);
// char __usercall sub_1000AD30@<al>(int a1@<edx>, float *a2@<ecx>, int a3, int a4);
char __cdecl sub_1000AD70(int a1, int a2, int *a3, float *a4, int a5);
// char __usercall sub_1000B660@<al>(int a1@<eax>, int a2@<edx>);
// char __usercall sub_1000B680@<al>(int a1@<edi>, int a2@<esi>);
// int __usercall sub_1000B760@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1000B790@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
// char __usercall sub_1000BD10@<al>(int a1@<ecx>, int a2@<edi>, int a3, int a4);
char __cdecl sub_1000C0A0(int a1, int a2, int a3, int a4, int a5);
// void *__usercall sub_1000C570@<eax>(int a1@<ecx>, int a2@<esi>, unsigned int *a3);
// int __usercall sub_1000C640@<eax>(unsigned int a1@<eax>, int a2@<esi>, char a3, int a4);
// signed int __usercall sub_1000C690@<eax>(int a1@<eax>, void *a2@<ecx>, unsigned int *a3, int a4);
// int __usercall sub_1000C810@<eax>(int a1@<ebx>, int a2, unsigned int *a3);
// char __usercall sub_1000C960@<al>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>);
// char __usercall sub_1000C9C0@<al>(int a1@<ebx>, int a2@<edi>, int a3, unsigned int *a4);
// char __usercall sub_1000CA60@<al>(unsigned int *a1@<edx>, int a2@<ecx>, int a3@<edi>);
// int __usercall sub_1000CAF0@<eax>(int a1@<eax>, void *a2@<ecx>, int a3, int a4);
char __cdecl sub_1000CCB0(int a1, int a2, __int64 a3, int a4);
char __cdecl sub_1000D130(int a1, int a2, int *a3, int a4, int a5);
// int __usercall sub_1000D1A0@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int8 a3);
char __cdecl sub_1000D280(int a1, int a2, int a3, int a4, _WORD *a5);
// unsigned int __usercall sub_1000D830@<eax>(int a1@<ebx>, int a2@<esi>, unsigned __int16 *a3);
char __cdecl sub_1000D8E0(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
signed int __cdecl sub_1000D980(_BYTE *a1, int a2);
signed int __cdecl sub_1000D9F0(int a1, signed int a2, int a3);
int __cdecl sub_1000DA30(int a1, int a2);
// void __usercall sub_1000DA60(int a1@<eax>, int a2);
// int __usercall sub_1000DB50@<eax>(int a1@<edi>, int a2, int a3, float a4, float a5, float a6, float a7);
int __cdecl sub_1000DD20(int, int, int, float, float, float, float); // idb
void __cdecl sub_1000DD60(int a1, int a2);
// void __usercall sub_1000DE30(int a1@<esi>, int a2);
char __cdecl sub_1000DF40(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_1000E000(int a1, int a2, int a3, int a4, _WORD *a5);
__int16 __cdecl sub_1000E640(unsigned int a1);
char __cdecl sub_1000E660(int a1, _WORD *a2, char **a3, int a4, int a5, int a6);
bool __cdecl sub_1000E780(int a1, _WORD *a2, char *a3, int a4, int a5, int a6);
int __cdecl sub_1000E880(unsigned int a1);
char *__cdecl sub_1000E8B0(unsigned int a1);
int __cdecl sub_1000E8D0(unsigned int a1);
signed int __cdecl sub_1000E8F0(__int16 a1);
signed int __cdecl sub_1000E920(int a1);
void *sub_1000E950();
// int __usercall sub_1000E960@<eax>(_BYTE *a1@<eax>);
// char __usercall sub_1000E990@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3);
// char __usercall sub_1000E9E0@<al>(size_t a1@<edx>, signed int a2@<ecx>, int a3@<esi>, const char *a4, int *a5, char a6, char a7);
__int16 __cdecl sub_1000EEE0(_BYTE *a1, unsigned int a2);
int __cdecl sub_1000EF40(unsigned int a1, unsigned int a2, float *a3);
int sub_1000EF70();
int __cdecl sub_1000F010(int a1, int a2, int a3, unsigned __int8 a4);
char __cdecl sub_1000F190(int a1, const char *a2, int *a3);
int __cdecl sub_1000F1D0(unsigned int a1, char a2);
char __cdecl sub_1000F230(int a1, const char *a2, int *a3, int a4);
int __cdecl sub_1000F440(int a1, int a2, unsigned int a3, int a4);
__int16 __cdecl sub_1000F510(char *a1, int a2, int a3, int a4, int a5);
char __cdecl sub_1000F5A0(int a1, char *a2, const char *a3, __int16 a4, __int16 a5, unsigned int a6, __int16 a7);
void __cdecl sub_1000F7C0(int a1, int (__cdecl *a2)(int));
// unsigned int __usercall sub_1000F810@<eax>(unsigned int result@<eax>);
// int __usercall sub_1000F850@<eax>(int result@<eax>);
void __cdecl sub_1000F880(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4, int a5);
void __cdecl sub_1000FC30(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4);
void __cdecl sub_1000FC50(int a1, unsigned __int8 a2);
void __cdecl sub_1000FCB0(float *a1);
char __thiscall sub_1000FD40(void *this);
char __cdecl sub_1000FD90(char a1);
int __cdecl sub_1000FE40(int a1);
int __cdecl sub_1000FED0(unsigned __int16 a1, char a2, int a3);
int sub_1000FFA0();
unsigned int __cdecl sub_10010000(const char *a1, int a2, signed int a3, int a4, int a5, _DWORD *a6);
int __cdecl sub_10010070(int, int, int, int, int, char, char *); // idb
signed int sub_10010600();
char __cdecl sub_10010610(int a1);
char __cdecl sub_10010690(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
char __cdecl sub_100106B0(int a1, int a2, int a3, int a4, _WORD *a5);
_DWORD *__cdecl sub_10010930(_DWORD *a1);
int __cdecl sub_10010940(int *a1, int a2);
_DWORD *__cdecl sub_10010970(_DWORD *a1, int a2);
char __cdecl sub_10010980(int a1, int a2, int a3);
char __cdecl sub_100109B0(int a1, _WORD *a2, int a3);
__int16 __cdecl sub_100109E0(unsigned int a1);
bool __cdecl sub_10010A00(char *a1, int *a2, _DWORD *a3);
char __cdecl sub_10010A50(int a1, char *a2);
int __cdecl sub_10010AB0(int a1, int a2, char *a3, int a4);
char __cdecl sub_10010B20(int a1, char *a2, int a3);
int __cdecl sub_10010BD0(int a1);
char __thiscall sub_10010C50(void *this);
char __thiscall sub_10010C80(void *this);
char __fastcall sub_10010CB0(int a1);
char __thiscall sub_10010D20(void *this);
char __fastcall sub_10010D50(int a1);
char sub_10010DA0();
BOOL __thiscall sub_10010DB0(void *this);
char __thiscall sub_10010DD0(void *this);
char __thiscall sub_10010E00(void *this);
char __fastcall sub_10010E30(int a1);
bool __thiscall sub_10010E80(void *this);
int sub_10010F50();
char __thiscall sub_10010F80(void *this);
char __fastcall sub_10010FB0(int a1);
char __cdecl sub_10011000(int a1);
char sub_10011020();
int __cdecl sub_10011050(int, char *); // idb
char __thiscall sub_100110B0(void *this);
int __thiscall sub_100110D0(void *this);
int __thiscall sub_100110F0(void *this);
char __thiscall sub_10011110(void *this);
int __thiscall sub_10011130(void *this);
char __thiscall sub_10011150(void *this);
char __thiscall sub_10011170(void *this);
char sub_10011190();
char __cdecl sub_100111B0(char a1);
char __cdecl sub_100111F0(char a1);
signed int __cdecl sub_10011260(char a1);
char __cdecl sub_100112E0(char a1);
char __cdecl sub_10011350(char a1);
char __cdecl sub_10011400(int a1);
char __thiscall sub_10011500(void *this);
int __cdecl sub_10011510(int *a1);
// char __usercall sub_10011540@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_100115E0(const char *a1);
char __cdecl sub_10011620(void *a1);
signed int __cdecl sub_10011670(unsigned int a1, int a2);
char **sub_10011A10();
int __cdecl j_nullsub_1(_DWORD); // weak
int __cdecl sub_10011A30(int a1);
int __cdecl sub_10011A40(int a1);
int sub_10011A50(void); // weak
char __cdecl sub_10011A80(char a1, unsigned __int16 a2, char a3);
void __cdecl sub_10011AB0(const char *a1, unsigned int a2, int a3);
void __cdecl sub_10011B00(const char *a1, char a2, char a3);
int __cdecl sub_10011B50(int a1, _BYTE *a2, int a3);
int __cdecl sub_10011BA0(void *, size_t); // idb
int __cdecl sub_10011BD0(int, char *, int); // idb
int __cdecl sub_10011C30(char *, size_t, char *, va_list); // idb
int sub_10011C70(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_10011CA0(const char *a1, _BYTE *a2, int a3);
int __cdecl sub_10011CE0(int a1, int a2);
signed int __cdecl sub_10011D00(int (__cdecl *a1)(int));
char *__cdecl sub_10011D30(unsigned __int8 a1);
int __cdecl sub_10011D60(float); // idb
int __cdecl sub_10011DF0(int a1, _WORD *a2, char *a3, int a4, int a5, int a6, int a7);
int __cdecl sub_10011F30(int a1, _WORD *a2, char *a3, int a4, int a5, int a6);
// void __usercall sub_10011F70(int a1@<eax>, int a2@<edi>, int a3@<esi>, char a4);
void *sub_100120C0();
void __cdecl sub_100120D0(int a1, int a2, int a3);
void __cdecl sub_100120F0(float a1, float a2, float a3, float a4, char a5);
void __cdecl sub_10012340(float a1, float a2, float a3, float a4, float a5, float a6, char a7);
// int __usercall sub_100123C0@<eax>(char a1@<al>, int a2@<ecx>, int a3@<ebx>, int a4);
int __cdecl sub_100124A0(int a1, int a2, int a3);
int __cdecl sub_100124C0(int a1, int a2, int a3);
int __cdecl sub_100124E0(int a1, int a2, int a3);
int __cdecl sub_10012550(char *, char *); // idb
// void *__usercall sub_10012590@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>);
signed int sub_100125E0();
char __thiscall sub_100143E0(void *this);
char __cdecl sub_10014470(int a1, char a2);
char __cdecl sub_10014530(char a1, char a2);
char __cdecl sub_10014580(char a1);
char __cdecl sub_100145B0(char a1);
int __cdecl sub_100145F0(signed int a1, char a2);
char __cdecl sub_100147B0(char a1, char a2, int a3);
char __cdecl sub_10014970(char a1, _DWORD *a2);
char __cdecl sub_100149C0(char a1, char *a2);
char __cdecl sub_10014A80(char a1, bool *a2);
char __cdecl sub_10014AD0(char a1, _WORD *a2);
unsigned __int8 __cdecl sub_10014B40(unsigned __int8 a1, unsigned __int8 a2);
char __cdecl sub_10014B80(char a1);
int __cdecl sub_10014BF0(char a1, _DWORD *a2);
int __cdecl sub_10014C30(float, float); // idb
void __cdecl sub_10014C80(char a1, int a2);
int __thiscall sub_10015220(void *this);
_DWORD sub_10015240(); // weak
int sub_10015250();
int sub_10015270();
char sub_100152A0();
int __cdecl sub_10015340(double, double); // idb
void sub_10015390();
signed int sub_100153A0();
bool __cdecl sub_100153B0(char a1, int a2);
void sub_100155D0();
signed int sub_100155E0();
void sub_100155F0();
int __thiscall sub_10015600(void *this);
// bool __usercall sub_100156D0@<al>(int a1@<esi>);
bool __cdecl sub_10015700(_BYTE *a1);
int __cdecl sub_10015720(char a1);
signed int sub_10015740();
// signed int __usercall sub_10015790@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_10015830@<eax>(char a1@<al>);
// int __usercall sub_10015850@<eax>(char a1@<al>);
// signed __int16 __usercall sub_10015870@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_10015AB0(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_10015C30(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10015D90(int a1, int a2, void *a3, char a4, __int16 a5, char a6);
char __cdecl sub_10015ED0(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10015FB0(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_10016230(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_10016260(char a1, int a2, void *a3);
char __cdecl sub_10016290(char a1, int a2, void *a3, int a4);
int __cdecl sub_100162C0(int a1, int a2);
signed int sub_100162D0();
int sub_10016300();
char __cdecl sub_10016310(char *a1);
unsigned int __cdecl sub_10016340(unsigned int a1);
bool __cdecl sub_10016360(int a1);
int __cdecl sub_10016430(int a1);
int __cdecl sub_10016450(int a1, int a2);
signed int __cdecl sub_10016490(int a1, void *a2, unsigned __int16 a3, __int16 a4);
int __cdecl sub_10016550(int a1);
// int __usercall sub_10016590@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_10016640@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_10016810@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_10016820@<eax>(int result@<eax>);
// char __usercall sub_10016840@<al>(int a1@<eax>);
// int __usercall sub_10016860@<eax>(int a1@<esi>, unsigned __int8 a2);
int __fastcall sub_100168A0(int a1, int a2);
// int __usercall sub_100168C0@<eax>(int a1@<esi>);
// signed int __usercall sub_10016900@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_10016B10(int a1);
signed int __cdecl sub_10016D80(unsigned int a1, int a2, int a3);
// int __usercall sub_10016E20@<eax>(int a1@<eax>);
// int __usercall sub_10016E40@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_10016E70@<eax>(int a1@<eax>, int a2@<ebx>);
// void __cdecl __noreturn exit(int);
// char __usercall sub_10016F60@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_10016F90@<eax>(int a1@<eax>);
signed int __cdecl sub_10016FC0(unsigned int a1);
signed int __cdecl sub_10017010(int a1, int a2);
signed int __cdecl sub_10017200(unsigned int a1, int a2, int a3);
signed int __cdecl sub_10017260(unsigned int a1, int a2, int a3);
signed int __cdecl sub_10017430(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_10017490(unsigned int a1, int a2, int a3);
int __cdecl sub_100174B0(unsigned __int8 *a1, int a2);
int __cdecl sub_100174E0(unsigned __int16 a1);
char *__cdecl sub_10017500(unsigned __int16 a1);
char __thiscall sub_10017540(void *this);
char __cdecl sub_10017570(char a1);
signed int __cdecl sub_100175A0(signed int a1);
signed int __fastcall sub_100175E0(int a1, unsigned __int8 a2);
int __cdecl sub_10017630(char, void *); // idb
unsigned __int8 __cdecl sub_10017670(int a1, unsigned __int8 a2);
bool __cdecl sub_100176F0(char a1);
char *__cdecl sub_10017720(unsigned __int8 a1);
char *__cdecl sub_10017730(unsigned int a1, float *a2);
char __cdecl sub_10017760(unsigned __int16 a1, int a2, char a3);
char __cdecl sub_10017960(char a1);
char __cdecl sub_10017980(unsigned int a1, float *a2);
double __cdecl sub_10017DA0(int a1, unsigned __int16 a2, char a3, char *a4);
double __cdecl sub_10018170(int a1, unsigned int a2);
double __cdecl sub_100187A0(int a1, unsigned int a2);
char __cdecl sub_10018E90(signed int a1, char a2);
int __cdecl sub_10018F20(unsigned __int8 a1);
char __fastcall sub_10018F40(int a1);
char __cdecl sub_10018F80(char a1);
char __cdecl sub_10018FB0(char a1, void *a2);
int __cdecl sub_10019030(char a1, _DWORD *a2);
bool __cdecl sub_10019080(char a1);
bool __cdecl sub_100190F0(char a1);
bool __cdecl sub_10019150(char a1);
void __cdecl sub_100191B0(char a1, char a2);
char __cdecl sub_10019220(signed int a1);
char __cdecl sub_10019250(int a1, int a2, unsigned __int16 a3, int a4, char a5);
void __cdecl sub_10019420(int a1);
// void __usercall sub_10019460(int a1@<ebx>, int a2@<esi>, char a3);
void __cdecl sub_10019500(int a1, int a2);
char __cdecl sub_10019520(float a1, int a2, char a3, int a4);
char __cdecl sub_10019610(char a1, _DWORD *a2, int *a3, char a4, int a5);
char __cdecl sub_100196A0(char a1, _DWORD *a2, int *a3, char a4, int a5);
int __cdecl sub_10019730(int a1);
double __cdecl sub_10019750(float a1, float a2, int a3, float a4);
int __cdecl sub_10019830(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_100199C0(int, float); // idb
int __cdecl sub_100199E0(int, float); // idb
int sub_10019A00();
// int __usercall sub_10019A30@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
signed int __fastcall sub_10019B00(unsigned __int8 a1);
char __cdecl sub_10019B10(unsigned __int8 a1);
__int16 __cdecl sub_10019B30(unsigned __int8 a1);
char *__cdecl sub_10019B50(char **a1);
int sub_10019BA0();
int __cdecl sub_10019BE0(_BYTE *a1, int a2);
signed int __cdecl sub_10019C50(_BYTE *a1, int a2);
// int __usercall sub_10019CF0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_10019D20@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_10019EF0@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// int __usercall sub_10019F50@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_10019FE0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_1001A030@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_1001A090@<eax>(int a1@<eax>);
// int __usercall sub_1001A0B0@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_1001A0F0@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_1001A180@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_1001A2D0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_1001A370@<eax>(int result@<eax>);
char *__cdecl sub_1001A3B0(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_1001A560@<eax>(int a1@<eax>);
// int __usercall sub_1001A590@<eax>(int a1@<esi>);
void __cdecl sub_1001A5C0(int (**a1)(void), char **a2, _DWORD *a3);
int sub_1001AA30();
void *sub_1001AA80();
char *sub_1001AAE0();
char sub_1001AB00();
char __cdecl sub_1001AB10(int a1, int a2, unsigned int a3);
// int *__usercall sub_1001AB50@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_1001ABA0();
int __cdecl sub_1001ABB0(_DWORD *a1, int a2, int a3);
int __cdecl sub_1001AC60(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_1001AE70@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_1001AF30(char a1);
int *__cdecl sub_1001AFD0(_BYTE *a1);
// int __usercall sub_1001B090@<eax>(int a1@<eax>);
// signed int __usercall sub_1001B1F0@<eax>(int a1@<esi>);
int __cdecl sub_1001B260(int, int); // weak
char **sub_1001B540();
// int __usercall sub_1001B550@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_1001B640(char *a1);
int sub_1001B880();
int __cdecl sub_1001B960(int a1, int a2, char a3);
int __cdecl sub_1001B9B0(int a1);
int __cdecl sub_1001B9C0(void *); // idb
int __cdecl sub_1001BA40(int a1, int a2);
signed int __cdecl sub_1001BA70(int a1, int a2, int a3);
char __cdecl sub_1001BA90(_DWORD *a1);
char __cdecl sub_1001BBA0(int a1, unsigned int a2);
bool __cdecl sub_1001BBD0(const void **a1, int a2);
bool __cdecl sub_1001BC00(const void **a1, int a2);
bool __cdecl sub_1001BC30(const void **a1, int a2);
bool __cdecl sub_1001BC60(const void **a1, int a2);
bool __cdecl sub_1001BC90(const void **a1, int a2);
bool __cdecl sub_1001BCC0(int a1, int a2);
bool __cdecl sub_1001BD00(int a1, int a2);
bool __cdecl sub_1001BD40(const void **a1, int a2);
bool __cdecl sub_1001BD70(const void **a1, int a2);
char __cdecl sub_1001BDA0(int a1, unsigned int a2);
bool __cdecl sub_1001BDD0(const void **a1, int a2);
bool __cdecl sub_1001BE00(const void **a1, int a2);
bool __cdecl sub_1001BE30(const void **a1, int a2);
bool __cdecl sub_1001BE60(const void **a1, int a2);
bool __cdecl sub_1001BE90(const void **a1, int a2);
bool __cdecl sub_1001BEC0(const void **a1, int a2);
bool __cdecl sub_1001BEF0(const void **a1, int a2);
bool __cdecl sub_1001BF20(const void **a1, int a2);
bool __cdecl sub_1001BF50(const void **a1, int a2);
bool __cdecl sub_1001BF80(const void **a1, int a2);
int __cdecl sub_1001BFB0(int a1, int a2, int a3);
// void __cdecl __noreturn exit_0(int);
int __cdecl sub_1001C020(int a1, char a2);
int __cdecl sub_1001C040(int a1, int a2, int a3);
int __cdecl sub_1001C070(int a1, int a2, int a3, int a4);
int __cdecl sub_1001C0A0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1001C0E0(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1001C120(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_1001C170(int a1);
char __cdecl sub_1001C1A0(int a1);
char __cdecl sub_1001C1B0(int a1, int a2);
signed int __cdecl sub_1001C330(int a1);
signed int __cdecl sub_1001C370(int a1, int a2, int a3);
char __cdecl sub_1001C410(int a1);
char __cdecl sub_1001C470(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1001C4E0(char *a1);
int __cdecl sub_1001C580(int a1, int a2, int a3);
bool __cdecl sub_1001C5F0(int a1, unsigned int a2, int a3);
char __cdecl sub_1001C680(int a1, int a2, char a3, char a4);
char __cdecl sub_1001C730(int a1);
char __cdecl sub_1001C740(int a1, void (__cdecl *a2)(int));
int (__cdecl *__cdecl sub_1001C7C0(int a1, const char *a2))(const char *);
signed int __cdecl sub_1001C810(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1001C860(int a1, int a2, int a3, size_t a4, char *a5);
int sub_1001C9E0();
const char *__cdecl sub_1001C9F0(unsigned int a1);
int __cdecl sub_1001CA10(int a1, int a2, int a3, int a4);
int __cdecl sub_1001CAC0(int a1);
int __cdecl sub_1001CAE0(int a1);
char *sub_1001CB00(char *a1, ...);
// char *__usercall sub_1001CB40@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_1001CB60@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_1001CD40();
int sub_1001CD60();
int __cdecl sub_1001CD80(int a1, int a2);
int __cdecl sub_1001CDE0(int a1);
int __cdecl sub_1001CDF0(int a1, int a2);
int __cdecl sub_1001CE50(int a1);
bool __cdecl sub_1001CE60(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1001CFA0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1001D350(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_1001D7A0(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_1001DC60(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1001E020(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_1001E420(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1001E7E0(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_1001ED20(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_1001F100(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1001F4C0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1001F860(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_1001FC60(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_10020000(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_100205E0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_100209D0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_10020D70();
// BOOL __usercall sub_10020DA0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_10020F10@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_10021180(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_10021480(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_10021530(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
const char *__cdecl sub_10021570(int a1, int a2);
char __cdecl sub_100215B0(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_10022360(int a1, int a2);
char **__cdecl sub_100223E0(int a1);
int (**sub_10022420())();
int (__cdecl *__cdecl sub_10022430(const char *a1))(const char *);
const char *sub_10022450();
__int64 sub_10022460();
const char *sub_10022470();
// int __usercall sub_10022480@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_100224D0(int a1, int a2);
int sub_10022500(); // weak
// int __usercall sub_10022620@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_100229A0(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_100237C0(int a1);
char __thiscall sub_10023880(void *this);
// char __usercall sub_100238F0@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_10023930@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_100239D0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10023A10(char a1, char a2, void *a3);
char __cdecl sub_10023A70(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10023AB0(char a1, char a2, void *a3);
char __cdecl sub_10023AE0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10023B20(char a1, char a2, void *a3);
char __cdecl sub_10023B60(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10023BA0(char a1, char a2, void *a3);
char __cdecl sub_10023BF0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10023C30(char a1, char a2, void *a3);
char __cdecl sub_10023C70(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10023CB0(char a1, char a2, void *a3);
char __cdecl sub_10023CF0(char a1, void *a2);
char __cdecl sub_10023D20(char a1, void *a2);
char __cdecl sub_10023D50(char a1, void *a2);
char __cdecl sub_10023D80(char a1, void *a2);
char __cdecl sub_10023DB0(char a1, void *a2);
char __cdecl sub_10023DE0(char a1, void *a2);
char __cdecl sub_10023E10(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10023E50(char a1, char a2, void *a3);
char __cdecl sub_10023EA0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10023EE0(char a1, char a2, void *a3);
char __cdecl sub_10023F10(char a1, void *a2);
char __cdecl sub_10023F40(char a1, void *a2);
char __cdecl sub_10023F70(char a1, void *a2);
char __cdecl sub_10023FA0(int a1, char a2, char a3, int a4, void *a5);
bool __cdecl sub_10024340(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_100243B0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10024410(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10024480(char a1, _BYTE *a2);
char __thiscall sub_100244C0(void *this);
char __cdecl sub_10024530(char a1, int a2);
char __cdecl sub_10024560(char a1, int a2);
char __cdecl sub_10024590(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
int __cdecl sub_10024760(int a1);
signed int __cdecl sub_100247A0(char a1, char a2);
int __cdecl sub_10024800(char a1);
signed int __cdecl sub_10024840(char a1, char a2, char a3);
int __cdecl sub_100248B0(char a1);
int __cdecl sub_100248F0(char a1);
char __cdecl sub_10024930(char a1, int a2);
char __cdecl sub_10024950(char a1, int a2);
char __cdecl sub_10024980(char a1, int a2);
char __cdecl sub_100249D0(char a1, int a2);
char __cdecl sub_10024A00(char a1, int a2);
char __cdecl sub_10024A20(int a1);
char __cdecl sub_10024A40(char a1);
char sub_10024A70();
BOOL __cdecl sub_10024B10(int a1, int a2);
char __cdecl sub_10024B30(int a1, char a2, int a3, int a4, int a5);
bool __cdecl sub_10024B70(void *a1);
int __cdecl sub_10024BB0(char a1);
char __cdecl sub_10024C30(int a1);
char __cdecl sub_10024C90(char a1);
char __cdecl sub_10024CC0(char a1, int a2);
char __cdecl sub_10024D00(char a1);
int __cdecl sub_10024D30(int a1);
signed int __cdecl sub_10024E30(int a1, int a2);
char __cdecl sub_10024ED0(char a1);
char __thiscall sub_10024F00(void *this);
char __thiscall sub_10024F10(void *this);
// _DWORD *__usercall sub_10024F30@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4);
int sub_10024F60(); // weak
int sub_10024FC0(); // weak
char __cdecl sub_10025010(int a1, int a2);
_DWORD *sub_10025110();
double __cdecl sub_100251A0(int a1);
signed int __cdecl sub_100251F0(_BYTE *a1, char a2, int a3);
int __cdecl sub_10025240(int, float, float, int, int); // idb
unsigned int __cdecl sub_10025330(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_10025380(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
unsigned int __cdecl sub_10025440(void *a1, size_t a2, int a3);
int __cdecl sub_100254A0(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_100254F0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_10025590(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
int __cdecl sub_10025640(char *a1, char a2);
bool __cdecl sub_100256B0(int a1, void *a2);
char __cdecl sub_10025770(int a1, bool *a2);
unsigned int __cdecl sub_10025830(char *a1);
int __cdecl sub_10025850(unsigned __int8 *a1);
int __cdecl sub_10025870(_BYTE *a1);
int __cdecl sub_10025890(unsigned __int8 *a1);
unsigned int __cdecl sub_100258B0(int a1, int a2);
unsigned int __cdecl sub_10025BE0(int a1, int a2);
int __cdecl sub_10026020(unsigned __int8 *a1);
int __cdecl sub_10026040(unsigned __int8 *a1);
int __cdecl sub_10026060(int a1);
unsigned int __cdecl sub_10026090(_BYTE *a1);
int __cdecl sub_100260B0(unsigned __int8 *a1);
int __cdecl sub_100260D0(unsigned __int8 *a1);
int __cdecl sub_100260F0(_BYTE *a1);
int __cdecl sub_10026110(int a1);
// void __cdecl __noreturn exit_1(int);
int __cdecl sub_10026160(unsigned __int8 *a1);
int __cdecl sub_10026180(int a1);
unsigned int __cdecl sub_10026210(int a1);
signed int __cdecl sub_10026230(int a1);
unsigned int __cdecl sub_10026280(int a1);
int __cdecl sub_100262E0(_BYTE *a1);
unsigned int __cdecl sub_10026300(_BYTE *a1);
int __cdecl sub_10026320(unsigned __int8 *a1);
int __cdecl sub_10026340(_BYTE *a1);
signed int __cdecl sub_10026360(_BYTE *a1, int a2);
int __cdecl sub_10026390(_BYTE *a1, int a2);
int __cdecl sub_100263D0(int a1, int a2);
int __cdecl sub_10026460(int a1);
int __cdecl sub_10026490(unsigned __int8 *a1);
unsigned int __cdecl sub_100264B0(int a1);
int __cdecl sub_100264E0(int a1);
int __cdecl sub_100265D0(int a1);
signed int __cdecl sub_100266E0(_BYTE *a1, int a2);
signed int __cdecl sub_10026710(unsigned __int8 *a1, int a2);
int __cdecl sub_10026740(unsigned __int8 *a1);
int __cdecl sub_100267A0(int a1);
signed int __cdecl sub_100267B0(_BYTE *a1, int a2);
int __cdecl sub_100267E0(int a1, int a2);
unsigned int __cdecl sub_10026860(int a1);
unsigned int __cdecl sub_100268A0(int a1);
int __cdecl sub_100268F0(int a1);
int __cdecl sub_10026920(int a1);
unsigned int __cdecl sub_10026950(int a1);
unsigned int __cdecl sub_10026980(int a1);
unsigned int __cdecl sub_100269A0(int a1);
void __cdecl __noreturn sub_100269E0(int a1);
signed int __cdecl sub_10026B50(int a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// signed int __usercall sub_10026BB0@<eax>(int a1@<eax>, int a2@<edi>);
signed int __cdecl sub_10026C80(int a1);
char __cdecl sub_10026C90(int a1, int a2);
char __cdecl sub_10026DB0(int a1);
int __cdecl sub_10026DC0(int a1, unsigned int a2);
__int16 __cdecl sub_10026EB0(int a1, unsigned int a2);
__int16 __cdecl sub_10026F00(unsigned int *a1, _WORD *a2, _WORD *a3);
// signed int __usercall sub_10026F80@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10028030@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_10028090@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_10028E10@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_10028E30(int a1, unsigned int a2);
// int __usercall sub_10028E90@<eax>(int result@<eax>);
// int __usercall sub_10028ED0@<eax>(int result@<eax>);
// unsigned int __usercall sub_1002A5F0@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_1002A6F0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_1002A770@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_1002A810@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_1002A8D0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_1002A930@<eax>(char *a1@<edi>);
// int __usercall sub_1002A9F0@<eax>(int a1@<ebx>);
char __cdecl sub_1002AAB0(char *a1, size_t a2, int a3);
char __cdecl sub_1002AB00(char *a1, unsigned int a2, int a3);
bool __cdecl sub_1002AB50(int a1, int a2);
// int __usercall sub_1002AB80@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_1002AD90@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_1002ADE0(int a1, int a2);
signed int __cdecl sub_1002AE70(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_1002AFA0(void *a1, int a2);
// BOOL __usercall sub_1002B020@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1002B0C0@<eax>(int result@<eax>);
unsigned int __fastcall sub_1002B150(unsigned int a1, int a2);
// int __usercall sub_1002B170@<eax>(int result@<eax>);
// int __usercall sub_1002B200@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_1002B680@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_1002B730@<eax>(int a1@<edi>);
// int __usercall sub_1002B790@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_1002B960@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_1002B9E0(int a1, int a2);
// unsigned int __usercall sub_1002BA50@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_1002BC00@<eax>(int a1@<esi>, int a2);
// int __usercall sub_1002BCD0@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_1002BD80@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_1002BDC0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_1002BE20@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1002BF00@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1002C4A0@<eax>(int a1@<eax>);
// int __usercall sub_1002C6E0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_1002C780@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_1002C960@<eax>(int a1@<edi>);
// int __usercall sub_1002CAA0@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_1002CD50(int a1, int a2);
// signed int __usercall sub_1002D010@<eax>(int a1@<eax>);
// _WORD *__usercall sub_1002D0E0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_1002D300(int a1, int a2);
signed int __cdecl sub_1002D610(int a1, int a2);
signed int __cdecl sub_1002DA20(int a1, int a2);
int __cdecl sub_1002DB90(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_1002DC90(int a1);
// signed int __usercall sub_1002DCB0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_1002E150@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_1002E1A0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_1002E1C0(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_1002E570@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_1002E6B0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_1002E700@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_1002E7A0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_1002E7C0(int a1);
// int __usercall sub_1002E7D0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1002EE70@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_1002F850@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_1002FB80(int a1, int a2);
bool __cdecl sub_1002FBA0(unsigned int a1);
BOOL __cdecl sub_1002FBD0(unsigned __int8 a1);
// BOOL __usercall sub_1002FBE0@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_1002FC10(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_1002FDC0(unsigned __int8 a1, int a2);
char __cdecl sub_1002FE00(unsigned __int8 a1, char a2);
bool __cdecl sub_1002FE50(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
int __cdecl sub_1002FF40(unsigned __int16 a1);
char __cdecl sub_1002FF50(int a1, int a2, int a3, int a4, __int16 *a5);
char __cdecl sub_100305B0(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_100306C0(char a1);
int __cdecl sub_10030710(unsigned __int8 *a1);
unsigned int __cdecl sub_10030730(void *a1);
unsigned int __cdecl sub_10030750(void *a1);
unsigned int __cdecl sub_10030770(void *a1);
unsigned int __cdecl sub_10030790(void *a1);
unsigned int __cdecl sub_100307B0(void *a1);
unsigned int __cdecl sub_100307D0(void *a1);
int __cdecl sub_10030830(int a1);
char __cdecl sub_10030840(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_10030880(const char *a1, int a2);
// char *__usercall sub_100308F0@<eax>(char *result@<eax>);
void __cdecl sub_10030920(char *a1);
void __cdecl sub_100309E0(char *a1, char *a2);
void *__cdecl sub_10030A40(int a1);
int __cdecl sub_10030BD0(int a1, int a2);
// char __usercall sub_10030D10@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_10030DE0(_DWORD *a1, char *a2);
BOOL __cdecl sub_10030EC0(unsigned int a1);
BOOL __cdecl sub_10030EE0(int a1);
_DWORD __cdecl sub_10030F00(_DWORD); // weak
unsigned int __cdecl sub_10030F10(int a1, char a2);
signed int __cdecl sub_10030F70(void *a1, int a2, unsigned int a3);
int __cdecl sub_10030F90(int a1, int a2, int a3);
char __cdecl sub_10030FB0(const char *a1, const char *a2);
int __cdecl sub_100310F0(int a1, int a2, unsigned int a3);
int sub_10031170();
void __cdecl sub_10031180(int a1);
int __cdecl sub_100311B0(int a1);
bool __cdecl sub_100311D0(int a1);
void *__cdecl sub_10031200(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_10031240@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_10031260@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_10031280(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_100312B0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_10031390(int a1, int a2, int a3);
// void *__usercall sub_10031440@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_100316C0(int a1, int a2);
char __cdecl sub_10031790(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_10031800@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_10031B60@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_10031C70(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_10031E00(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_10031F50@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_100320A0(int a1, int a2);
signed int __cdecl sub_100320E0(int a1, int a2);
bool __cdecl sub_10032140(signed int a1);
int sub_100321B0();
char sub_100324D0();
char sub_100326F0();
char sub_100328F0();
char sub_10032A70();
char sub_10032BF0();
char sub_10032D60();
char sub_10032E60();
char sub_10032FC0();
char sub_10033120();
char sub_10033280();
char sub_100333F0();
char sub_10033550();
char sub_100336B0();
char sub_100338D0();
char sub_10033A30();
char sub_10033B90();
char sub_10033CF0();
char sub_10033E60();
char sub_10033FC0();
char sub_10034120();
char sub_10034340();
char sub_10034540();
char sub_100346C0();
char sub_10034840();
char sub_100349B0();
char sub_10034AA0();
char sub_10034C00();
char sub_10034D60();
char sub_10034EC0();
char sub_10035030();
char sub_10035190();
char sub_100352F0();
char sub_100354F0();
char sub_10035650();
char sub_100357B0();
char sub_10035910();
char sub_10035A80();
char sub_10035BE0();
char sub_10035D40();
char sub_100362E0();
char sub_100364F0();
char sub_100366E0();
char sub_10036850();
char sub_100369C0();
char sub_10036B20();
char sub_10036C10();
char sub_10036D70();
char sub_10036ED0();
char sub_10037030();
char sub_100371A0();
char sub_10037300();
char sub_10037460();
char sub_10037660();
char sub_100377C0();
char sub_10037920();
char sub_10037A80();
char sub_10037BF0();
char sub_10037D50();
char sub_10037EB0();
char sub_100380C0();
char sub_100382B0();
char sub_10038420();
char sub_10038590();
char sub_100386F0();
char sub_100387E0();
char sub_10038940();
char sub_10038AA0();
char sub_10038C00();
char sub_10038D70();
char sub_10038ED0();
char sub_10039030();
char sub_10039230();
char sub_10039390();
char sub_100394F0();
char sub_10039650();
char sub_100397C0();
char sub_10039920();
char **sub_10039A80();
int __cdecl sub_10039A90(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_10039AB0@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_10039AC0@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_10039CF0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10039D40(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10039D90(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_10039DE0(int a1))(int);
int __cdecl sub_10039E60(int a1, int a2);
int (__cdecl *__cdecl sub_10039EE0(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_10039F30(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10039F70(int a1, int a2, int a3))(int);
char sub_10039FD0();
char __cdecl sub_1003A050(char a1);
int __cdecl sub_1003A090(char a1);
bool __cdecl sub_1003A0E0(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_1003A170(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
char __cdecl sub_1003A210(char a1);
char __cdecl sub_1003A290(char a1, int a2);
// int __usercall sub_1003A400@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_1003A440@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_1003A480();
char __cdecl sub_1003A490(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_1003A4F0(char a1, void *a2);
char __cdecl sub_1003A610(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1003A690(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
char sub_1003A840();
int __cdecl sub_1003A850(int a1, int a2);
char __cdecl sub_1003A870(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9);
// unsigned int __usercall sub_1003A940@<eax>(int a1@<eax>);
char __cdecl sub_1003AB80(int a1, int a2, int a3, int a4, __int16 *a5);
int __cdecl sub_1003AC60(char a1, char a2);
// bool __usercall sub_1003AD10@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_1003AD40@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_1003ADE0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1003AE60(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1003AEE0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1003AF60(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1003AFE0(char a1);
int __cdecl sub_1003B080(char a1);
int __cdecl sub_1003B0A0(int, void *); // idb
// int __usercall sub_1003B100@<eax>(char a1@<al>);
BOOL __cdecl sub_1003B130(char a1, int a2);
int __cdecl sub_1003B160(int, char, int, int, void *); // idb
char __cdecl sub_1003B190(void *a1);
BOOL __cdecl sub_1003B1B0(int a1);
char __cdecl sub_1003B1D0(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_1003B200(char a1, void *a2);
// signed int __usercall sub_1003B240@<eax>(char a1@<al>);
bool __cdecl sub_1003B260(char a1, void *a2);
bool __cdecl sub_1003B350(char a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_1003B380(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_1003B420(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1003B4A0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1003B510(char a1, void *a2);
char __cdecl sub_1003B590(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1003B610(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1003B690(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1003B700(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
char __cdecl sub_1003B810(char a1, void *a2);
bool __cdecl sub_1003B830(unsigned __int8 a1, char *a2);
char __cdecl sub_1003B870(int a1, char a2, int a3, int a4, void *a5);
BOOL sub_1003B8B0();
char __cdecl sub_1003B910(int a1, char *a2);
BOOL __cdecl sub_1003BA00(int a1, int a2);
char __cdecl sub_1003BA20(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_1003BA60(int a1, int a2);
BOOL __cdecl sub_1003BB10(int a1, int a2);
char __cdecl sub_1003BB30(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_1003BB70(void *a1);
char __cdecl sub_1003BB90(void *a1);
char __cdecl sub_1003BCE0(int a1, char a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_1003BE80(char a1);
// __int16 __usercall sub_1003BEC0@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_1003BED0(unsigned __int8 a1, char *a2);
char __cdecl sub_1003BFA0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_1003C020(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_1003C150(char a1, int a2);
bool __cdecl sub_1003C1D0(void *a1);
char __cdecl sub_1003C220(char a1, int a2);
// __int16 __usercall sub_1003C300@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_1003C310(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_1003C3A0(unsigned __int8 a1, char a2);
bool __cdecl sub_1003C460(__int16 a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_1003C560(char a1);
char __cdecl sub_1003C5A0(char a1);
// int __cdecl FNT_get_fnt_hdr(_DWORD); weak
// int __cdecl BMP_get_bm_def(_DWORD); weak
// int __cdecl BMP_get_xfrm(_DWORD); weak
// int TXT_get_static_string(void); weak
int __cdecl sub_1003C5D0(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_1003C5F0(unsigned int *a1, signed int a2, unsigned int a3);
double __cdecl sub_1003C720(float a1, float a2);
double __cdecl sub_1003C7C0(float a1, float a2);
double __cdecl sub_1003C860(double a1, double a2);
double __cdecl sub_1003C8C0(float a1, float a2);
int __cdecl sub_1003C940(double); // idb
double __cdecl sub_1003C960(float a1);
int __cdecl sub_1003C9A0(int a1, int a2);
int __cdecl sub_1003C9C0(double); // idb
double __cdecl sub_1003C9F0(float a1, float a2);
int __cdecl sub_1003CA60(float, int, int); // idb
int __cdecl sub_1003CA80(int a1, int a2);
double __cdecl sub_1003CAA0(double a1, double a2);
double __cdecl sub_1003CB10(float a1, float a2);
int __cdecl sub_1003CBA0(int a1, int a2, int a3);
int __cdecl sub_1003CBD0(float, int, int); // idb
// int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int gdi_pvg_init(void); weak
// int __cdecl gdi_pvg_line_width(_DWORD); weak
// int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_vertex2f(_DWORD, _DWORD); weak
// int __cdecl gdi_pvg_create_window(_DWORD); weak
// int SYS_exit_krnl(void); weak
// int SYS_enter_krnl(void); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_set_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_close(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
__int32 __cdecl j__atol(const char *);
// char *__cdecl strstr(const char *, const char *);
// void *__cdecl memset(void *, int, size_t);
// char *__cdecl strncpy(char *, const char *, size_t);
// char *__cdecl strrchr(const char *, int);
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
// int __cdecl strncmp(const char *, const char *, size_t);
// int sprintf(char *, const char *, ...);
// int _snprintf(char *, size_t, const char *, ...);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// double __cdecl atof(const char *);
// char *__cdecl strchr(const char *, int);
// char *__cdecl strncat(char *, const char *, size_t);
// int __cdecl isalpha(int);
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isalnum(int);
// int __cdecl isprint(int);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// double __cdecl floor(double);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_1003F0B9(int a1, int a2, char a3);
// char *__cdecl strpbrk(const char *, const char *);
signed int __cdecl sub_100404C6(_DWORD *a1);
signed int __cdecl sub_100404FD(_DWORD *a1);
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_10041143();
int (*sub_100415F0())(void);
void __cdecl sub_10041614(); // idb
int __cdecl sub_10043328(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_10043452(int, FILE *); // idb
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl isleadbyte(int);
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_1004711B(FILE *, int, struct localeinfo_struct *, int); // idb
int __cdecl sub_10048540(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_100485E6(int, int, struct localeinfo_struct *); // idb
void sub_10048A52();
// int _get_sse2_info(void); weak
int sub_10048BA5();
int sub_100490A2();
int __cdecl sub_1004925F(int a1);
int __cdecl sub_10049269(int a1);
int __cdecl sub_10049273(int a1);
int __cdecl sub_10049352(int a1);
DWORD __cdecl sub_1004A73C(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_1004A8D8(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_1004AEFA(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_1004B01A(signed int a1);
void **sub_1004B078();
signed int sub_1004B07E();
// int __cdecl _fileno(FILE *);
signed int __cdecl sub_1004B999(int a1, int a2);
signed int __cdecl sub_1004BEDB(int a1, int a2);
int sub_1004C81C();
int __cdecl sub_1004D001(FILE *); // idb
int __cdecl sub_1004D121(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
int __cdecl sub_1004E060(int a1, int a2, int a3);
signed int __cdecl sub_1004E533(signed int a1);
signed int __cdecl sub_1004E5B4(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_1004E6C5(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_1004E9C6();
// int __cdecl _read(int, void *, unsigned int);
signed int __cdecl sub_1004F311(signed int a1);
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_1004F4F0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_1004F540(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
int __cdecl sub_1004F5B0(int a1);
int __cdecl sub_1004F5F0(int a1);
int __cdecl sub_1004F630(int a1);
int __cdecl sub_1004F670(int a1);
int __cdecl sub_1004F6B0(int a1, int a2, int a3, int a4);
int __cdecl sub_1004F720(int a1, int a2, int a3);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
void __cdecl sub_1004F7D0(float *a1, float *a2, float *a3, int a4);
int __cdecl sub_1004F830(float, float, int); // idb
void __cdecl sub_1004F9F0(int a1, int a2, float *a3, float *a4, float *a5);
void __cdecl sub_1004FDC0(int a1, int a2, float *a3, float *a4);
char sub_1004FEA0();
void __cdecl sub_1004FEF0(float *a1, float *a2, int a3);
double __cdecl sub_1004FFB0(int a1, int a2);
int __cdecl sub_1004FFD0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();

//-------------------------------------------------------------------------
// Data declarations

int dword_10051DC0[] = { 10 }; // weak
int (__cdecl *off_10051DC4)(int, int, int, int, int) = &sub_1000E000; // weak
int dword_10051DC8[] = { 12 }; // weak
int dword_10051DCC[] = { 129 }; // weak
int (__cdecl *off_10051DD0)(int, int, int, int, int) = &sub_1000DF40; // weak
int dword_10051DD4[] = { 4 }; // weak
_UNKNOWN unk_10052418; // weak
_UNKNOWN unk_10052420; // weak
_UNKNOWN unk_10052440; // weak
_UNKNOWN unk_10053684; // weak
_UNKNOWN unk_10053C40; // weak
_UNKNOWN unk_10053CF4; // weak
_UNKNOWN unk_10053D00; // weak
_UNKNOWN unk_100542E8; // weak
_UNKNOWN unk_10054300; // weak
_UNKNOWN unk_1005431C; // weak
_UNKNOWN unk_10054330; // weak
_UNKNOWN unk_10054350; // weak
_UNKNOWN unk_10054358; // weak
_UNKNOWN unk_10054364; // weak
_UNKNOWN unk_10054450; // weak
void *off_100555BC = &unk_100E4920; // weak
char byte_1005606C[] = { '\0' }; // weak
int (__cdecl *off_10056078)(int) = &sub_10003660; // weak
char byte_1005607C[] = { '\0' }; // weak
char aVloc[5] = "VLOC"; // weak
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
_UNKNOWN unk_10058230; // weak
_UNKNOWN unk_10058CA9; // weak
int dword_1005A988[] = { 6103 }; // weak
int dword_1005A98C[] = { 8000 }; // weak
char *off_1005AFF8 = "/shr_mem/cdp_mngr_intf.shr"; // weak
char byte_1005B618[] = { '\0' }; // weak
int dword_1005B628 = 0; // idb
__int16 word_1005D108 = 48; // weak
char *(*off_1005DD28)[14] = &off_1005DCF0; // weak
char *off_1005DD30 = "1"; // idb
_UNKNOWN unk_1005F404; // weak
_UNKNOWN unk_1005FFC0; // weak
_UNKNOWN unk_1005FFCC; // weak
int dword_10061224 = 9116; // idb
_UNKNOWN unk_1006177D; // weak
_UNKNOWN unk_100617B6; // weak
char byte_100617B8[] = { '\x0E' }; // weak
char *off_10062268 = "/shr_mem/iop_gma_dig_intf.shr"; // weak
__int16 word_10065B64[] = { 81 }; // weak
_UNKNOWN unk_100660E4; // weak
_UNKNOWN unk_100660FC; // weak
_UNKNOWN unk_100661A8; // weak
void *off_100661AC = &unk_1006611C; // weak
_UNKNOWN unk_100668B4; // weak
char byte_100668B5[] = { '\x0E' }; // weak
_UNKNOWN unk_100669B0; // weak
__int16 word_100669B4[] = { 2 }; // weak
char *off_10067368[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_100671D8 }; // weak
_UNKNOWN unk_1006737C; // weak
_BYTE word_10068A90[540] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  128,
  4,
  0,
  45,
  0,
  37,
  0,
  47,
  0,
  45,
  0,
  44,
  0,
  45,
  0,
  45,
  0,
  37,
  0,
  37,
  0,
  47,
  0,
  45,
  0,
  37,
  0,
  60,
  0,
  61,
  0,
  45,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  0,
  37,
  0,
  37,
  0,
  36,
  0,
  44,
  0,
  36,
  0,
  45,
  32,
  44,
  13,
  0,
  5,
  0,
  5,
  0,
  5,
  0,
  13,
  0,
  5,
  0,
  1,
  0,
  1,
  0,
  9,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  9,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  9,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  0,
  36,
  0,
  36,
  0,
  36,
  0,
  44,
  64,
  45,
  0,
  4,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  0,
  44,
  0,
  44,
  0,
  44,
  0,
  44,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  32,
  0,
  32,
  0,
  32,
  0,
  32,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  65,
  66,
  67,
  68,
  69,
  70,
  0,
  0,
  0,
  0,
  87,
  83,
  0,
  0,
  69,
  78,
  0,
  0
}; // idb
_UNKNOWN unk_100697A8; // weak
char a_____1[5] = "____"; // weak
_UNKNOWN unk_1006D6F4; // weak
char *off_1006E248 = "/shr_mem/nav_intf.shr"; // weak
char *off_1006E274 = "/shr_mem/pvt_intf.shr"; // weak
char *off_1006E2C8 = "/shr_mem/prx_intf.shr"; // weak
int dword_1007034C[] = { 88 }; // weak
__int16 word_100707FC[] = { 836 }; // weak
char *off_1007081C = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_10070830 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_10070844 = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_10070858 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_1007086C = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_10070880 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
int (*off_10070E60[4])() = { &sub_100162F0, &sub_100162D0, &sub_100162E0, &sub_100162D0 }; // weak
_UNKNOWN unk_10085EC0; // weak
char byte_10086470[] = { '?' }; // weak
int (__cdecl *off_100864B4[2])(char, int) = { &sub_10019030, &sub_100191B0 }; // weak
int (__cdecl *off_100864B8)(char, int) = &sub_100191B0; // weak
char *off_10086C70[62] =
{
  "A",
  "AMPS",
  "",
  "",
  "",
  "T",
  "",
  "",
  "",
  "C",
  "",
  "",
  "E",
  "E",
  "",
  "",
  "",
  "",
  "W",
  "W",
  "",
  "F",
  "",
  "FPM",
  "",
  "FT",
  "",
  "GAL",
  "",
  "GPH",
  "",
  "HPA",
  "",
  "IG",
  "",
  "IGPH",
  "",
  "IN",
  "",
  "KG",
  "",
  "KGPH",
  "",
  "KM",
  "",
  "KPH",
  "",
  "KT",
  "",
  "LB",
  "",
  "LB/HR",
  "",
  "LT",
  "",
  "LT/HR",
  "",
  "MPM",
  "",
  "MT",
  "",
  "NM"
}; // weak
int dword_100883C0[] = { 9032 }; // weak
_UNKNOWN unk_10089290; // weak
char byte_10089291[] = { '\0' }; // weak
_UNKNOWN unk_10089ED0; // weak
int dword_10089ED4 = 4294967295; // weak
int dword_10089ED8 = 0; // weak
int dword_10089EDC = 4278255615; // weak
int dword_10089EE0 = 0; // weak
int dword_10089EEC = 0; // weak
_UNKNOWN unk_1008A710; // weak
__int16 word_1008C6E0[] = { 43 }; // weak
char byte_1008C6E4[] = { '\x06' }; // weak
_UNKNOWN unk_1008CCE8; // weak
char *off_1008CE8C[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_1008CEA0 }; // weak
char *off_1008D030 = "true"; // weak
char byte_1008D034[] = { '\x01' }; // weak
char *off_1008D098 = "failure listener"; // weak
_UNKNOWN unk_1008D840; // weak
char *off_1008DA48[18] =
{
  "FAIL",
  "PASS",
  "normal",
  "robust",
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1008DA50[16] =
{
  "normal",
  "robust",
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1008DA58[14] =
{
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1008DA74[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1008DA80[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_1008DA88[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_1008DD40; // weak
_UNKNOWN unk_1008DD7C; // weak
char *off_1008E138 = "printf_listener"; // weak
__int16 word_1008ED6C = 2573; // weak
int (*off_1008EE28[2])() = { &sub_10039A80, &sub_10011A10 }; // weak
char *off_1008EED8 = "gate_listener"; // weak
_UNKNOWN unk_1008FFE8; // weak
_UNKNOWN unk_10090000; // weak
_UNKNOWN unk_10090048; // weak
int dword_1009004C[] = { 6767 }; // weak
_UNKNOWN unk_10090058; // weak
_UNKNOWN unk_10090070; // weak
_UNKNOWN unk_10090088; // weak
int dword_1009008C[] = { 6769 }; // weak
_UNKNOWN unk_100900A0; // weak
int dword_100900A4[] = { 6093 }; // weak
_UNKNOWN unk_10093200; // weak
char byte_10093204[] = { '\0' }; // weak
int (__cdecl *off_100952C8[3])(char) = { &sub_100112E0, &sub_100111F0, &sub_100111B0 }; // weak
_UNKNOWN unk_100961C8; // weak
int dword_100961CC[] = { 1312 }; // weak
_BYTE word_1009647A[30] =
{
  0,
  0,
  0,
  0,
  31,
  0,
  59,
  0,
  90,
  0,
  120,
  0,
  151,
  0,
  181,
  0,
  212,
  0,
  243,
  0,
  17,
  1,
  48,
  1,
  78,
  1,
  0,
  0,
  0,
  0
}; // idb
_WORD dword_10096498[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_10096898[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_10096C98[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_10097098[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_10097498[] = { 99 }; // weak
int dword_10097898[] = { 25344 }; // weak
int dword_10097C98[] = { 6488064 }; // weak
int dword_10098098[] = { 1660944384 }; // weak
int dword_100984C0[] = { 128 }; // weak
int dword_100984D0[] = { 0 }; // weak
int dword_100984E0[] = { 0 }; // weak
char byte_10098551[] = { '\0' }; // weak
char byte_10098552[] = { '\0' }; // weak
char byte_10098553[] = { '\0' }; // weak
char byte_10098554[] = { '\x10' }; // weak
int dword_10098568[] = { 0 }; // weak
_UNKNOWN unk_100985E0; // weak
_UNKNOWN unk_10098A60; // weak
char byte_10098AD8[] = { '\0' }; // weak
char byte_10098BD8[] = { '\0' }; // weak
char byte_10098CD8[] = { '\0' }; // weak
int dword_10098DD8[] = { 0 }; // weak
int dword_10098E50[] = { 0 }; // weak
int (__cdecl *off_10098ED0)(int, int) = &sub_1002DA20; // weak
int dword_100990B8[] = { 0 }; // weak
int dword_10099100[] = { 16 }; // weak
_UNKNOWN unk_10099150; // weak
_UNKNOWN unk_100991D0; // weak
_UNKNOWN unk_10099250; // weak
_UNKNOWN unk_100992C8; // weak
_UNKNOWN unk_10099340; // weak
_UNKNOWN unk_1009A340; // weak
__int16 word_1009EC8A[] = { 537 }; // weak
__int16 word_1009EC90[] = { 1565 }; // weak
__int16 word_1009EC94[] = { 534 }; // weak
char byte_1009EC98[] = { '\x04' }; // weak
__int16 word_1009EC9A[] = { 6512 }; // weak
int dword_1009ECB0[] = { 118000 }; // weak
int dword_1009F2B0[] = { 0 }; // weak
_UNKNOWN unk_1009F520; // weak
_UNKNOWN unk_1009F5F0; // weak
_UNKNOWN unk_1009F6C0; // weak
_UNKNOWN unk_1009F790; // weak
_UNKNOWN unk_1009F860; // weak
_UNKNOWN unk_1009F930; // weak
_UNKNOWN unk_1009FA00; // weak
_UNKNOWN unk_1009FAD0; // weak
_UNKNOWN unk_1009FBA0; // weak
_UNKNOWN unk_1009FC70; // weak
_UNKNOWN unk_1009FD40; // weak
_UNKNOWN unk_1009FE10; // weak
_UNKNOWN unk_1009FEE0; // weak
_UNKNOWN unk_1009FFB0; // weak
_UNKNOWN unk_100A0080; // weak
_UNKNOWN unk_100A0150; // weak
_UNKNOWN unk_100A0220; // weak
_UNKNOWN unk_100A02F0; // weak
_UNKNOWN unk_100A03C0; // weak
_UNKNOWN unk_100A0490; // weak
_UNKNOWN unk_100A0560; // weak
_UNKNOWN unk_100A0630; // weak
_UNKNOWN unk_100A0700; // weak
_UNKNOWN unk_100A07D0; // weak
_UNKNOWN unk_100A08A0; // weak
_UNKNOWN unk_100A0970; // weak
_UNKNOWN unk_100A0A40; // weak
_UNKNOWN unk_100A0B10; // weak
_UNKNOWN unk_100A0BE0; // weak
_UNKNOWN unk_100A0CB0; // weak
_UNKNOWN unk_100A0D80; // weak
_UNKNOWN unk_100A0E50; // weak
_UNKNOWN unk_100A0F20; // weak
_UNKNOWN unk_100A0FF0; // weak
_UNKNOWN unk_100A10C0; // weak
_UNKNOWN unk_100A1190; // weak
_UNKNOWN unk_100A1260; // weak
_UNKNOWN unk_100A1330; // weak
_UNKNOWN unk_100A1400; // weak
_UNKNOWN unk_100A14D0; // weak
_UNKNOWN unk_100A15A0; // weak
_UNKNOWN unk_100A1670; // weak
_UNKNOWN unk_100A1740; // weak
_UNKNOWN unk_100A1810; // weak
_UNKNOWN unk_100A18E0; // weak
_UNKNOWN unk_100A19B0; // weak
_UNKNOWN unk_100A1A80; // weak
_UNKNOWN unk_100A1B50; // weak
_UNKNOWN unk_100A1C20; // weak
_UNKNOWN unk_100A1CF0; // weak
_UNKNOWN unk_100A1DC0; // weak
_UNKNOWN unk_100A1E90; // weak
_UNKNOWN unk_100A1F60; // weak
_UNKNOWN unk_100A2030; // weak
_UNKNOWN unk_100A2100; // weak
_UNKNOWN unk_100A21D0; // weak
_UNKNOWN unk_100A22A0; // weak
_UNKNOWN unk_100A2370; // weak
_UNKNOWN unk_100A2440; // weak
_UNKNOWN unk_100A2510; // weak
_UNKNOWN unk_100A25E0; // weak
_UNKNOWN unk_100A26B0; // weak
_UNKNOWN unk_100A2780; // weak
_UNKNOWN unk_100A2850; // weak
_UNKNOWN unk_100A2920; // weak
_UNKNOWN unk_100A29F0; // weak
_UNKNOWN unk_100A2AC0; // weak
_UNKNOWN unk_100A4028; // weak
int dword_100A402C[] = { 6006 }; // weak
_UNKNOWN unk_100A40F0; // weak
_UNKNOWN unk_100A4114; // weak
_UNKNOWN unk_100A42B8; // weak
char off_100A4EE8[] = { '4', '', '\b', '\x10' }; // idb
int dword_100A4F04 = 1; // idb
char byte_100A4F20[] = { '\x01' }; // weak
char *off_100A4F24[3] = { "1", "2", "fail_normal_1" }; // weak
char *off_100A4F28[2] = { "2", "fail_normal_1" }; // weak
char off_100A4F2C[8] = { '', 'N', '\n', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100A4FB0[] = { '\0' }; // weak
char byte_100A4FB1[] = { '\0' }; // weak
int dword_100A4FB4[] = { 0 }; // weak
char *off_100A4FB8 = "0, 0, 0"; // weak
double dbl_100A5220[] = {  0.0 }; // weak
double dbl_100A5228[] = {  0.0 }; // weak
double dbl_100A5230[] = {  0.0 }; // weak
int dword_100A5238[] = { 0 }; // weak
char off_100A523C[32] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100A5E40[] = {  0.0 }; // weak
float flt_100A5E44[] = {  0.0 }; // weak
float flt_100A5E48[] = {  0.0 }; // weak
int dword_100A5E4C[] = { 0 }; // weak
char *off_100A5E50 = "0, 0, 0"; // weak
char *off_100A65D4[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_100BB230
}; // weak
int dword_100A65E8[] = { 0 }; // weak
int dword_100A65EC[] = { 0 }; // weak
int dword_100A65F0[] = { 0 }; // weak
int dword_100A65F4[] = { 0 }; // weak
char off_100A65F8[20] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100A6D80[] = { 0 }; // weak
__int16 word_100A6D82[] = { 0 }; // weak
__int16 word_100A6D84[] = { 0 }; // weak
int dword_100A6D88[] = { 0 }; // weak
char off_100A6D8C[16] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A7390[] = { 0 }; // weak
int dword_100A7394[] = { 0 }; // weak
int dword_100A7398[] = { 0 }; // weak
int dword_100A739C[] = { 0 }; // weak
char *off_100A73A0 = "0, 0, 0"; // weak
int dword_100A7B28[] = { 0 }; // weak
int dword_100A7B2C[] = { 0 }; // weak
int dword_100A7B30[] = { 0 }; // weak
int dword_100A7B34[] = { 0 }; // weak
int dword_100A7B38[] = { 0 }; // weak
int dword_100A7B3C[] = { 0 }; // weak
int dword_100A7B40[] = { 0 }; // weak
char *off_100A7B44 = "0, 0, 0"; // weak
char byte_100A8748[] = { '\0' }; // weak
char byte_100A8749[] = { '\0' }; // weak
char byte_100A874A[] = { '\0' }; // weak
int dword_100A874C[] = { 0 }; // weak
char *off_100A8750 = "0, 0, 0"; // weak
int dword_100A8BD8[] = { 0 }; // weak
int dword_100A8BDC[] = { 0 }; // weak
int dword_100A8BE0[] = { 0 }; // weak
int dword_100A8BE4[] = { 0 }; // weak
char off_100A8BE8[20] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A9370[] = { 0 }; // weak
int dword_100A9374[] = { 0 }; // weak
int dword_100A9378[] = { 0 }; // weak
int dword_100A937C[] = { 0 }; // weak
char *off_100A9380 = "0, 0, 0"; // weak
__int16 word_100A96E0[] = { 0 }; // weak
__int16 word_100A96E2[] = { 0 }; // weak
__int16 word_100A96E4[] = { 0 }; // weak
int dword_100A96E8[] = { 0 }; // weak
char off_100A96EC[16] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A99A0[] = { 0 }; // weak
int dword_100A99A4[] = { 0 }; // weak
int dword_100A99A8[] = { 0 }; // weak
int dword_100A99AC[] = { 0 }; // weak
char *off_100A99B0 = "0, 0, 0"; // weak
int dword_100A9D10[] = { 0 }; // weak
int dword_100A9D14[] = { 0 }; // weak
int dword_100A9D18[] = { 0 }; // weak
int dword_100A9D1C[] = { 0 }; // weak
int dword_100A9D20[] = { 0 }; // weak
int dword_100A9D24[] = { 0 }; // weak
int dword_100A9D28[] = { 0 }; // weak
char off_100A9D2C[32] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100AA290[] = { '\0' }; // weak
char byte_100AA291[] = { '\0' }; // weak
char byte_100AA292[] = { '\0' }; // weak
int dword_100AA294[] = { 0 }; // weak
char *off_100AA298 = "0, 0, 0"; // weak
int dword_100AA4A0[] = { 0 }; // weak
int dword_100AA4A4[] = { 0 }; // weak
int dword_100AA4A8[] = { 0 }; // weak
int dword_100AA4AC[] = { 0 }; // weak
char *off_100AA4B0 = "0, 0, 0"; // weak
char byte_100AA810[] = { '\x01' }; // weak
char *off_100AA814[3] = { "1", "2", "fail_robust_1" }; // weak
char *off_100AA818[2] = { "2", "fail_robust_1" }; // weak
char off_100AA81C[8] = { 'H', 'J', '\n', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100AA8A0[] = { '\0' }; // weak
char byte_100AA8A1[] = { '\0' }; // weak
int dword_100AA8A4[] = { 0 }; // weak
char *off_100AA8A8 = "0, 0, 0"; // weak
double dbl_100AAB10[] = {  0.0 }; // weak
double dbl_100AAB18[] = {  0.0 }; // weak
double dbl_100AAB20[] = {  0.0 }; // weak
int dword_100AAB28[] = { 0 }; // weak
char off_100AAB2C[32] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100AB730[] = {  0.0 }; // weak
float flt_100AB734[] = {  0.0 }; // weak
float flt_100AB738[] = {  0.0 }; // weak
int dword_100AB73C[] = { 0 }; // weak
char *off_100AB740 = "0, 0, 0"; // weak
int dword_100ABEC8[] = { 0 }; // weak
int dword_100ABECC[] = { 0 }; // weak
int dword_100ABED0[] = { 0 }; // weak
int dword_100ABED4[] = { 0 }; // weak
char off_100ABED8[20] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100AC660[] = { 0 }; // weak
__int16 word_100AC662[] = { 0 }; // weak
__int16 word_100AC664[] = { 0 }; // weak
int dword_100AC668[] = { 0 }; // weak
char off_100AC66C[16] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100ACC70[] = { 0 }; // weak
int dword_100ACC74[] = { 0 }; // weak
int dword_100ACC78[] = { 0 }; // weak
int dword_100ACC7C[] = { 0 }; // weak
char *off_100ACC80 = "0, 0, 0"; // weak
int dword_100AD408[] = { 0 }; // weak
int dword_100AD40C[] = { 0 }; // weak
int dword_100AD410[] = { 0 }; // weak
int dword_100AD414[] = { 0 }; // weak
int dword_100AD418[] = { 0 }; // weak
int dword_100AD41C[] = { 0 }; // weak
int dword_100AD420[] = { 0 }; // weak
char *off_100AD424 = "0, 0, 0"; // weak
char byte_100AE028[] = { '\0' }; // weak
char byte_100AE029[] = { '\0' }; // weak
char byte_100AE02A[] = { '\0' }; // weak
int dword_100AE02C[] = { 0 }; // weak
char *off_100AE030 = "0, 0, 0"; // weak
int dword_100AE4B8[] = { 0 }; // weak
int dword_100AE4BC[] = { 0 }; // weak
int dword_100AE4C0[] = { 0 }; // weak
int dword_100AE4C4[] = { 0 }; // weak
char off_100AE4C8[20] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100AEC50[] = { 0 }; // weak
int dword_100AEC54[] = { 0 }; // weak
int dword_100AEC58[] = { 0 }; // weak
int dword_100AEC5C[] = { 0 }; // weak
char *off_100AEC60 = "0, 0, 0"; // weak
__int16 word_100AEFC0[] = { 0 }; // weak
__int16 word_100AEFC2[] = { 0 }; // weak
__int16 word_100AEFC4[] = { 0 }; // weak
int dword_100AEFC8[] = { 0 }; // weak
char off_100AEFCC[16] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100AF280[] = { 0 }; // weak
int dword_100AF284[] = { 0 }; // weak
int dword_100AF288[] = { 0 }; // weak
int dword_100AF28C[] = { 0 }; // weak
char *off_100AF290 = "0, 0, 0"; // weak
int dword_100AF5F0[] = { 0 }; // weak
int dword_100AF5F4[] = { 0 }; // weak
int dword_100AF5F8[] = { 0 }; // weak
int dword_100AF5FC[] = { 0 }; // weak
int dword_100AF600[] = { 0 }; // weak
int dword_100AF604[] = { 0 }; // weak
int dword_100AF608[] = { 0 }; // weak
char off_100AF60C[32] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100AFB70[] = { '\0' }; // weak
char byte_100AFB71[] = { '\0' }; // weak
char byte_100AFB72[] = { '\0' }; // weak
int dword_100AFB74[] = { 0 }; // weak
char *off_100AFB78 = "0, 0, 0"; // weak
int dword_100AFD80[] = { 0 }; // weak
int dword_100AFD84[] = { 0 }; // weak
int dword_100AFD88[] = { 0 }; // weak
int dword_100AFD8C[] = { 0 }; // weak
char *off_100AFD90 = "0, 0, 0"; // weak
char byte_100B00F0[] = { '\x01' }; // weak
char *off_100B00F4[3] = { "1", "1", "pass_normal_1" }; // weak
char *off_100B00F8[2] = { "1", "pass_normal_1" }; // weak
char off_100B00FC[8] = { '', 'I', '\n', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100B0140[] = { '\0' }; // weak
char byte_100B0141[] = { '\0' }; // weak
int dword_100B0144[] = { 0 }; // weak
char *off_100B0148 = "0, 0, 0"; // weak
double dbl_100B03B0[] = {  0.0 }; // weak
double dbl_100B03B8[] = {  0.0 }; // weak
double dbl_100B03C0[] = {  0.0 }; // weak
int dword_100B03C8[] = { 0 }; // weak
char off_100B03CC[32] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100B0FD0[] = {  0.0 }; // weak
float flt_100B0FD4[] = {  0.0 }; // weak
float flt_100B0FD8[] = {  0.0 }; // weak
int dword_100B0FDC[] = { 0 }; // weak
char *off_100B0FE0 = "0, 0, 0"; // weak
int dword_100B1768[] = { 0 }; // weak
int dword_100B176C[] = { 0 }; // weak
int dword_100B1770[] = { 0 }; // weak
int dword_100B1774[] = { 0 }; // weak
char off_100B1778[20] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100B1F00[] = { 0 }; // weak
__int16 word_100B1F02[] = { 0 }; // weak
__int16 word_100B1F04[] = { 0 }; // weak
int dword_100B1F08[] = { 0 }; // weak
char off_100B1F0C[16] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B2510[] = { 0 }; // weak
int dword_100B2514[] = { 0 }; // weak
int dword_100B2518[] = { 0 }; // weak
int dword_100B251C[] = { 0 }; // weak
char *off_100B2520 = "0, 0, 0"; // weak
int dword_100B2CA8[] = { 0 }; // weak
int dword_100B2CAC[] = { 0 }; // weak
int dword_100B2CB0[] = { 0 }; // weak
int dword_100B2CB4[] = { 0 }; // weak
int dword_100B2CB8[] = { 0 }; // weak
int dword_100B2CBC[] = { 0 }; // weak
int dword_100B2CC0[] = { 0 }; // weak
char *off_100B2CC4 = "0, 0, 0"; // weak
char byte_100B38C8[] = { '\0' }; // weak
char byte_100B38C9[] = { '\0' }; // weak
char byte_100B38CA[] = { '\0' }; // weak
int dword_100B38CC[] = { 0 }; // weak
char *off_100B38D0 = "0, 0, 0"; // weak
int dword_100B3D58[] = { 0 }; // weak
int dword_100B3D5C[] = { 0 }; // weak
int dword_100B3D60[] = { 0 }; // weak
int dword_100B3D64[] = { 0 }; // weak
char off_100B3D68[20] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B44F0[] = { 0 }; // weak
int dword_100B44F4[] = { 0 }; // weak
int dword_100B44F8[] = { 0 }; // weak
int dword_100B44FC[] = { 0 }; // weak
char *off_100B4500 = "0, 0, 0"; // weak
__int16 word_100B4860[] = { 0 }; // weak
__int16 word_100B4862[] = { 0 }; // weak
__int16 word_100B4864[] = { 0 }; // weak
int dword_100B4868[] = { 0 }; // weak
char off_100B486C[16] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B4B20[] = { 0 }; // weak
int dword_100B4B24[] = { 0 }; // weak
int dword_100B4B28[] = { 0 }; // weak
int dword_100B4B2C[] = { 0 }; // weak
char *off_100B4B30 = "0, 0, 0"; // weak
int dword_100B4E90[] = { 0 }; // weak
int dword_100B4E94[] = { 0 }; // weak
int dword_100B4E98[] = { 0 }; // weak
int dword_100B4E9C[] = { 0 }; // weak
int dword_100B4EA0[] = { 0 }; // weak
int dword_100B4EA4[] = { 0 }; // weak
int dword_100B4EA8[] = { 0 }; // weak
char off_100B4EAC[32] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100B5410[] = { '\0' }; // weak
char byte_100B5411[] = { '\0' }; // weak
char byte_100B5412[] = { '\0' }; // weak
int dword_100B5414[] = { 0 }; // weak
char *off_100B5418 = "0, 0, 0"; // weak
int dword_100B5620[] = { 0 }; // weak
int dword_100B5624[] = { 0 }; // weak
int dword_100B5628[] = { 0 }; // weak
int dword_100B562C[] = { 0 }; // weak
char *off_100B5630 = "0, 0, 0"; // weak
char byte_100B5990[] = { '\x01' }; // weak
char *off_100B5994[3] = { "1", "1", "pass_robust_1" }; // weak
char *off_100B5998[2] = { "1", "pass_robust_1" }; // weak
char off_100B599C[8] = { 'h', 'I', '\n', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100B59E0[] = { '\0' }; // weak
char byte_100B59E1[] = { '\0' }; // weak
int dword_100B59E4[] = { 0 }; // weak
char *off_100B59E8 = "0, 0, 0"; // weak
double dbl_100B5C50[] = {  0.0 }; // weak
double dbl_100B5C58[] = {  0.0 }; // weak
double dbl_100B5C60[] = {  0.0 }; // weak
int dword_100B5C68[] = { 0 }; // weak
char off_100B5C6C[32] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100B6870[] = {  0.0 }; // weak
float flt_100B6874[] = {  0.0 }; // weak
float flt_100B6878[] = {  0.0 }; // weak
int dword_100B687C[] = { 0 }; // weak
char *off_100B6880 = "0, 0, 0"; // weak
int dword_100B7008[] = { 0 }; // weak
int dword_100B700C[] = { 0 }; // weak
int dword_100B7010[] = { 0 }; // weak
int dword_100B7014[] = { 0 }; // weak
char off_100B7018[20] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100B77A0[] = { 0 }; // weak
__int16 word_100B77A2[] = { 0 }; // weak
__int16 word_100B77A4[] = { 0 }; // weak
int dword_100B77A8[] = { 0 }; // weak
char off_100B77AC[16] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B7DB0[] = { 0 }; // weak
int dword_100B7DB4[] = { 0 }; // weak
int dword_100B7DB8[] = { 0 }; // weak
int dword_100B7DBC[] = { 0 }; // weak
char *off_100B7DC0 = "0, 0, 0"; // weak
int dword_100B8548[] = { 0 }; // weak
int dword_100B854C[] = { 0 }; // weak
int dword_100B8550[] = { 0 }; // weak
int dword_100B8554[] = { 0 }; // weak
int dword_100B8558[] = { 0 }; // weak
int dword_100B855C[] = { 0 }; // weak
int dword_100B8560[] = { 0 }; // weak
char *off_100B8564 = "0, 0, 0"; // weak
char byte_100B9168[] = { '\0' }; // weak
char byte_100B9169[] = { '\0' }; // weak
char byte_100B916A[] = { '\0' }; // weak
int dword_100B916C[] = { 0 }; // weak
char *off_100B9170 = "0, 0, 0"; // weak
int dword_100B95F8[] = { 0 }; // weak
int dword_100B95FC[] = { 0 }; // weak
int dword_100B9600[] = { 0 }; // weak
int dword_100B9604[] = { 0 }; // weak
char off_100B9608[20] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B9D90[] = { 0 }; // weak
int dword_100B9D94[] = { 0 }; // weak
int dword_100B9D98[] = { 0 }; // weak
int dword_100B9D9C[] = { 0 }; // weak
char *off_100B9DA0 = "0, 0, 0"; // weak
__int16 word_100BA100[] = { 0 }; // weak
__int16 word_100BA102[] = { 0 }; // weak
__int16 word_100BA104[] = { 0 }; // weak
int dword_100BA108[] = { 0 }; // weak
char off_100BA10C[16] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100BA3C0[] = { 0 }; // weak
int dword_100BA3C4[] = { 0 }; // weak
int dword_100BA3C8[] = { 0 }; // weak
int dword_100BA3CC[] = { 0 }; // weak
char *off_100BA3D0 = "0, 0, 0"; // weak
int dword_100BA730[] = { 0 }; // weak
int dword_100BA734[] = { 0 }; // weak
int dword_100BA738[] = { 0 }; // weak
int dword_100BA73C[] = { 0 }; // weak
int dword_100BA740[] = { 0 }; // weak
int dword_100BA744[] = { 0 }; // weak
int dword_100BA748[] = { 0 }; // weak
char off_100BA74C[32] =
{
  '8',
  'N',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100BACB0[] = { '\0' }; // weak
char byte_100BACB1[] = { '\0' }; // weak
char byte_100BACB2[] = { '\0' }; // weak
int dword_100BACB4[] = { 0 }; // weak
char *off_100BACB8 = "0, 0, 0"; // weak
int dword_100BAEC0[] = { 0 }; // weak
int dword_100BAEC4[] = { 0 }; // weak
int dword_100BAEC8[] = { 0 }; // weak
int dword_100BAECC[] = { 0 }; // weak
char *off_100BAED0 = "0, 0, 0"; // weak
_UNKNOWN unk_100BBEB0; // weak
int dword_100BF08C[] = { 0 }; // weak
_UNKNOWN off_100BF090; // weak
_UNKNOWN unk_100BF120; // weak
_UNKNOWN unk_100BF124; // weak
_UNKNOWN unk_100BF128; // weak
_UNKNOWN unk_100BF12C; // weak
_UNKNOWN unk_100BF130; // weak
_UNKNOWN unk_100BF134; // weak
_UNKNOWN unk_100BF138; // weak
_UNKNOWN unk_100BF13C; // weak
_UNKNOWN unk_100C1A00; // weak
int dword_100C1A04[] = { 0 }; // weak
int dword_100C2BE8 = 64; // weak
__int16 word_100C2BEC[] = { 6782 }; // weak
__int16 word_100C2BF0[] = { 128 }; // weak
_UNKNOWN unk_100C2C0C; // weak
_DWORD dword_100C2C10[10] = { 64, 24, 62, 18, 65, 27525120, 27394467, 27721729, 27591078, 0 }; // idb
char *off_100C4AB0 = "/shr_mem/iop_gtx_intf.shr"; // weak
_UNKNOWN unk_100C7D98; // weak
int dword_100C7D9C[] = { 0 }; // weak
_UNKNOWN unk_100C7DB0; // weak
int dword_100C7DB4[] = { 0 }; // weak
_UNKNOWN unk_100C7DD8; // weak
int dword_100C7DDC[] = { 0 }; // weak
_UNKNOWN unk_100C7E08; // weak
int dword_100C7E0C[] = { 0 }; // weak
int dword_100C7EC4[] = { 6829 }; // weak
__int16 word_100C8EFA[] = { 233 }; // weak
int dword_100C8F00[] = { 6201 }; // weak
__int16 word_100CBAB0[] = { 114 }; // weak
__int16 word_100CBBC0[] = { 551 }; // weak
char byte_100CC31A[] = { '\x04' }; // weak
char byte_100CC31F[] = { '\a' }; // weak
int dword_100D57B0[] = { 0 }; // weak
_UNKNOWN unk_100DF540; // weak
int dword_100DF544[] = { 3535 }; // weak
_UNKNOWN unk_100DF578; // weak
int dword_100DF57C[] = { 6813 }; // weak
_UNKNOWN unk_100DF5B0; // weak
int dword_100DF5B4[] = { 9036 }; // weak
_UNKNOWN unk_100DF5E8; // weak
int dword_100DF5EC[] = { 6763 }; // weak
char byte_100DFE30[16] =
{
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\xFF',
  '\0',
  '\x01',
  '\0',
  '',
  '\x03',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_100DFEA0; // weak
_UNKNOWN unk_100DFEA8; // weak
int (*off_100E2250[3])() = { &_fptrap, &_fptrap, &_fptrap }; // weak
_UNKNOWN unk_100E2268; // weak
void *off_100E2DB8 = &unk_101D8260; // weak
_UNKNOWN unk_100E2DC8; // weak
_UNKNOWN unk_100E2E28; // weak
wchar_t *off_100E3038 = L"         (((((                  H"; // weak
int dword_100E3140 = 1024; // weak
int dword_100E3144 = 4294966273; // weak
int dword_100E3148 = 53; // weak
int dword_100E314C = 11; // weak
int dword_100E3150 = 64; // weak
int dword_100E3154 = 1023; // weak
int dword_100E3158 = 128; // weak
int dword_100E315C = 4294967169; // weak
int dword_100E3160 = 24; // weak
int dword_100E3164 = 8; // weak
int dword_100E3168 = 32; // weak
int dword_100E316C = 127; // weak
_UNKNOWN unk_100E3780; // weak
char byte_100E3784 = '\0'; // weak
int dword_100E3788 = 0; // weak
_UNKNOWN unk_100E3790; // weak
char byte_100E3860 = '\0'; // weak
char byte_100E3868 = '\0'; // idb
int dword_100E4868; // weak
char byte_100E4870[]; // weak
char byte_100E4872; // weak
__int16 word_100E4874[]; // weak
int dword_100E4878; // weak
int dword_100E487C; // weak
__int16 word_100E4880[]; // weak
_UNKNOWN unk_100E4888; // weak
char byte_100E491E; // weak
char byte_100E491F; // weak
_UNKNOWN unk_100E4920; // weak
_UNKNOWN unk_100EB920; // weak
char byte_100F07C0; // weak
char byte_100F07C1; // weak
int dword_100F07C4; // weak
int dword_100F07C8; // weak
int dword_100F07CC; // weak
int dword_100F07D0; // weak
int dword_100F07D4; // weak
int dword_100F07D8; // weak
int dword_100F6060; // weak
int dword_1010EE74; // weak
_DWORD dword_1010EE78[16]; // idb
int dword_1010EEB8[]; // weak
int dword_1010EEF8; // weak
int dword_1010EF00[]; // weak
char byte_1010EF40; // weak
char byte_1010EF41; // weak
__int16 word_1010F158[]; // weak
char byte_1010F180[]; // weak
int dword_1010F280; // weak
int dword_1010F284[]; // weak
int dword_1010F298; // weak
int dword_1010F29C; // weak
_UNKNOWN unk_1010F2A0; // weak
_UNKNOWN unk_1010F2A1; // weak
_UNKNOWN unk_1010F2B7; // weak
_UNKNOWN unk_1010F2B8; // weak
_UNKNOWN unk_1010F2B9; // weak
_UNKNOWN unk_1010F2BA; // weak
_UNKNOWN unk_1010F2BC; // weak
_UNKNOWN unk_1010F2C0; // weak
_UNKNOWN unk_1010F2C4; // weak
_UNKNOWN unk_1010F2E4; // weak
_UNKNOWN unk_1010F304; // weak
_UNKNOWN unk_1010F324; // weak
_UNKNOWN unk_1010F344; // weak
_UNKNOWN unk_1010F364; // weak
_UNKNOWN unk_1010F384; // weak
_UNKNOWN unk_1010F3A4; // weak
_UNKNOWN unk_1010F3C4; // weak
_UNKNOWN unk_1010F3E4; // weak
_UNKNOWN unk_1010F404; // weak
_UNKNOWN unk_1010F424; // weak
_UNKNOWN unk_1010F444; // weak
_UNKNOWN unk_1010F464; // weak
_UNKNOWN unk_1010F484; // weak
_UNKNOWN unk_1010F4A4; // weak
_UNKNOWN unk_1010F4C4; // weak
_UNKNOWN unk_1010F4E4; // weak
_UNKNOWN unk_1010F504; // weak
_UNKNOWN unk_1010F524; // weak
_UNKNOWN unk_1010F544; // weak
_UNKNOWN unk_1010F564; // weak
_UNKNOWN unk_1010F584; // weak
_UNKNOWN unk_1010F5A4; // weak
_UNKNOWN unk_1010F5C4; // weak
_UNKNOWN unk_1010F5E4; // weak
_UNKNOWN unk_1010F604; // weak
_UNKNOWN unk_1010F624; // weak
_UNKNOWN unk_1010F644; // weak
_UNKNOWN unk_1010F648; // weak
_UNKNOWN unk_1010F64C; // weak
_UNKNOWN unk_1010F650; // weak
_UNKNOWN unk_1010F654; // weak
_UNKNOWN unk_1010F658; // weak
_UNKNOWN unk_1010F65C; // weak
_UNKNOWN unk_1010F67C; // weak
_UNKNOWN unk_1010F69C; // weak
_UNKNOWN unk_1010F6BC; // weak
_UNKNOWN unk_1010F6DC; // weak
_UNKNOWN unk_1010F6FC; // weak
_UNKNOWN unk_1010F71C; // weak
_UNKNOWN unk_1010F73C; // weak
_UNKNOWN unk_1010F75C; // weak
_UNKNOWN unk_1010F75D; // weak
_UNKNOWN unk_1010F75E; // weak
_UNKNOWN unk_1010F7B0; // weak
_UNKNOWN unk_1010F7D0; // weak
_UNKNOWN unk_1010F7F0; // weak
_UNKNOWN unk_1010F7F4; // weak
_UNKNOWN unk_1010F7F8; // weak
_UNKNOWN unk_1010F7FC; // weak
_UNKNOWN unk_1010F81C; // weak
_UNKNOWN unk_1010F83C; // weak
_UNKNOWN unk_1010F85C; // weak
_UNKNOWN unk_1010F87C; // weak
_UNKNOWN unk_1010F89C; // weak
_UNKNOWN unk_1010F8BC; // weak
_UNKNOWN unk_1010F8DC; // weak
_UNKNOWN unk_1010F8FC; // weak
_UNKNOWN unk_1010F91C; // weak
_UNKNOWN unk_1010F964; // weak
_UNKNOWN unk_1010F9AC; // weak
_UNKNOWN unk_1010F9F4; // weak
_UNKNOWN unk_1010FA3C; // weak
_UNKNOWN unk_1010FA84; // weak
_UNKNOWN unk_1010FACC; // weak
_UNKNOWN unk_1010FB14; // weak
_UNKNOWN unk_1010FB5C; // weak
_UNKNOWN unk_1010FBA4; // weak
_UNKNOWN unk_1010FBEC; // weak
_UNKNOWN unk_1010FC34; // weak
_UNKNOWN unk_1010FC7C; // weak
_UNKNOWN unk_1010FCC4; // weak
_UNKNOWN unk_1010FD0C; // weak
_UNKNOWN unk_1010FD54; // weak
_UNKNOWN unk_1010FD9C; // weak
_UNKNOWN unk_1010FDE4; // weak
_UNKNOWN unk_1010FE2C; // weak
_UNKNOWN unk_1010FE74; // weak
_UNKNOWN unk_1010FEBC; // weak
_UNKNOWN unk_1010FF04; // weak
_UNKNOWN unk_1010FF4C; // weak
_UNKNOWN unk_1010FF94; // weak
_UNKNOWN unk_1010FFDC; // weak
_UNKNOWN unk_10110024; // weak
_UNKNOWN unk_1011006C; // weak
_UNKNOWN unk_101100B4; // weak
_UNKNOWN unk_101100FC; // weak
_UNKNOWN unk_10110144; // weak
_UNKNOWN unk_1011018C; // weak
_UNKNOWN unk_101101A4; // weak
_UNKNOWN unk_101101C4; // weak
_UNKNOWN unk_101101E4; // weak
_UNKNOWN unk_101101E8; // weak
_UNKNOWN unk_1011028C; // weak
_UNKNOWN unk_10110330; // weak
_UNKNOWN unk_101103D4; // weak
_UNKNOWN unk_10110478; // weak
_UNKNOWN unk_1011051C; // weak
_UNKNOWN unk_101105C0; // weak
_UNKNOWN unk_10110664; // weak
_UNKNOWN unk_10110708; // weak
_UNKNOWN unk_101107AC; // weak
_UNKNOWN unk_10110850; // weak
_UNKNOWN unk_101108F4; // weak
_UNKNOWN unk_10110998; // weak
_UNKNOWN unk_10110A3C; // weak
_UNKNOWN unk_10110AE0; // weak
_UNKNOWN unk_10110B84; // weak
_UNKNOWN unk_10110C28; // weak
_UNKNOWN unk_10110CCC; // weak
_UNKNOWN unk_10110D70; // weak
_UNKNOWN unk_10110E14; // weak
_UNKNOWN unk_10110EB8; // weak
_UNKNOWN unk_10110F5C; // weak
_UNKNOWN unk_10111000; // weak
_UNKNOWN unk_101110A4; // weak
_UNKNOWN unk_10111148; // weak
_UNKNOWN unk_101111EC; // weak
_UNKNOWN unk_10111290; // weak
_UNKNOWN unk_10111334; // weak
_UNKNOWN unk_101113D8; // weak
_UNKNOWN unk_1011147C; // weak
_UNKNOWN unk_10111520; // weak
_UNKNOWN unk_101115C4; // weak
_UNKNOWN unk_10111668; // weak
_UNKNOWN unk_1011170C; // weak
_UNKNOWN unk_101117B0; // weak
_UNKNOWN unk_10111854; // weak
_UNKNOWN unk_101118F8; // weak
_UNKNOWN unk_1011199C; // weak
_UNKNOWN unk_10111A40; // weak
_UNKNOWN unk_10111AE4; // weak
_UNKNOWN unk_10111B88; // weak
_UNKNOWN unk_10111C2C; // weak
_UNKNOWN unk_10111CD0; // weak
_UNKNOWN unk_10111D74; // weak
_UNKNOWN unk_10111E18; // weak
_UNKNOWN unk_10111EBC; // weak
_UNKNOWN unk_10111F60; // weak
_UNKNOWN unk_10112004; // weak
_UNKNOWN unk_101120A8; // weak
_UNKNOWN unk_1011214C; // weak
_UNKNOWN unk_101121F0; // weak
_UNKNOWN unk_10112294; // weak
_UNKNOWN unk_10112338; // weak
_UNKNOWN unk_101123DC; // weak
_UNKNOWN unk_10112480; // weak
_UNKNOWN unk_10112524; // weak
_UNKNOWN unk_101125C8; // weak
_UNKNOWN unk_1011266C; // weak
_UNKNOWN unk_10112710; // weak
_UNKNOWN unk_101127B4; // weak
_UNKNOWN unk_10112858; // weak
_UNKNOWN unk_101128FC; // weak
_UNKNOWN unk_101129A0; // weak
_UNKNOWN unk_10112A44; // weak
_UNKNOWN unk_10112AE8; // weak
_UNKNOWN unk_10112B8C; // weak
_UNKNOWN unk_10112C30; // weak
_UNKNOWN unk_10112CD4; // weak
_UNKNOWN unk_10112D78; // weak
_UNKNOWN unk_10112E1C; // weak
_UNKNOWN unk_10112EC0; // weak
_UNKNOWN unk_10112F64; // weak
_UNKNOWN unk_10113008; // weak
_UNKNOWN unk_101130AC; // weak
_UNKNOWN unk_10113150; // weak
_UNKNOWN unk_101131F4; // weak
_UNKNOWN unk_10113298; // weak
_UNKNOWN unk_1011333C; // weak
_UNKNOWN unk_101133E0; // weak
_UNKNOWN unk_10113484; // weak
_UNKNOWN unk_10113528; // weak
_UNKNOWN unk_101135CC; // weak
_UNKNOWN unk_10113670; // weak
_UNKNOWN unk_10113714; // weak
_UNKNOWN unk_101137B8; // weak
_UNKNOWN unk_1011385C; // weak
_UNKNOWN unk_10113900; // weak
_UNKNOWN unk_101139A4; // weak
_UNKNOWN unk_10113A48; // weak
_UNKNOWN unk_10113AEC; // weak
_UNKNOWN unk_10113B90; // weak
_UNKNOWN unk_10113C34; // weak
_UNKNOWN unk_10113CD8; // weak
_UNKNOWN unk_10113D7C; // weak
_UNKNOWN unk_10113E20; // weak
_UNKNOWN unk_10113EC4; // weak
_UNKNOWN unk_10113F68; // weak
_UNKNOWN unk_1011400C; // weak
_UNKNOWN unk_101140B0; // weak
_UNKNOWN unk_10114154; // weak
_UNKNOWN unk_101141F8; // weak
_UNKNOWN unk_10114218; // weak
_UNKNOWN unk_10114238; // weak
_UNKNOWN unk_10114258; // weak
_UNKNOWN unk_10114278; // weak
_UNKNOWN unk_101142A0; // weak
_UNKNOWN unk_101142BC; // weak
_UNKNOWN unk_101142D8; // weak
_UNKNOWN unk_101142F4; // weak
_UNKNOWN unk_10114310; // weak
_UNKNOWN unk_1011432C; // weak
_UNKNOWN unk_10114348; // weak
_UNKNOWN unk_10114364; // weak
_UNKNOWN unk_10114380; // weak
_UNKNOWN unk_1011439C; // weak
_UNKNOWN unk_101143B8; // weak
_UNKNOWN unk_101143D4; // weak
_UNKNOWN unk_101143F0; // weak
_UNKNOWN unk_1011440C; // weak
_UNKNOWN unk_10114428; // weak
_UNKNOWN unk_10114444; // weak
_UNKNOWN unk_10114460; // weak
_UNKNOWN unk_1011447C; // weak
_UNKNOWN unk_10114498; // weak
_UNKNOWN unk_101144B4; // weak
_UNKNOWN unk_101144D0; // weak
_UNKNOWN unk_101144EC; // weak
_UNKNOWN unk_10114508; // weak
_UNKNOWN unk_10114524; // weak
_UNKNOWN unk_10114540; // weak
_UNKNOWN unk_1011455C; // weak
_UNKNOWN unk_10114578; // weak
_UNKNOWN unk_10114594; // weak
_UNKNOWN unk_101145B0; // weak
_UNKNOWN unk_101145CC; // weak
_UNKNOWN unk_101145E8; // weak
_UNKNOWN unk_10114604; // weak
_UNKNOWN unk_10114620; // weak
_UNKNOWN unk_1011463C; // weak
_UNKNOWN unk_10114658; // weak
_UNKNOWN unk_10114674; // weak
_UNKNOWN unk_10114690; // weak
_UNKNOWN unk_101146AC; // weak
_UNKNOWN unk_101146C8; // weak
_UNKNOWN unk_101146E4; // weak
_UNKNOWN unk_10114700; // weak
_UNKNOWN unk_1011471C; // weak
_UNKNOWN unk_10114738; // weak
_UNKNOWN unk_10114754; // weak
_UNKNOWN unk_10114770; // weak
_UNKNOWN unk_1011478C; // weak
_UNKNOWN unk_101147A8; // weak
_UNKNOWN unk_101147C4; // weak
_UNKNOWN unk_101147E0; // weak
_UNKNOWN unk_101147FC; // weak
_UNKNOWN unk_10114818; // weak
_UNKNOWN unk_10114834; // weak
_UNKNOWN unk_10114850; // weak
_UNKNOWN unk_1011486C; // weak
_UNKNOWN unk_10114888; // weak
_UNKNOWN unk_101148A4; // weak
_UNKNOWN unk_101148C0; // weak
_UNKNOWN unk_101148DC; // weak
_UNKNOWN unk_101148F8; // weak
_UNKNOWN unk_10114914; // weak
_UNKNOWN unk_10114930; // weak
_UNKNOWN unk_1011494C; // weak
_UNKNOWN unk_10114968; // weak
_UNKNOWN unk_10114984; // weak
_UNKNOWN unk_101149A0; // weak
_UNKNOWN unk_101149BC; // weak
_UNKNOWN unk_101149D8; // weak
_UNKNOWN unk_101149F4; // weak
_UNKNOWN unk_10114A10; // weak
_UNKNOWN unk_10114A2C; // weak
_UNKNOWN unk_10114A48; // weak
_UNKNOWN unk_10114A64; // weak
_UNKNOWN unk_10114A80; // weak
_UNKNOWN unk_10114A9C; // weak
_UNKNOWN unk_10114AB8; // weak
_UNKNOWN unk_10114AD4; // weak
_UNKNOWN unk_10114AF0; // weak
_UNKNOWN unk_10114B0C; // weak
_UNKNOWN unk_10114B28; // weak
_UNKNOWN unk_10114B44; // weak
_UNKNOWN unk_10114B60; // weak
_UNKNOWN unk_10114B7C; // weak
_UNKNOWN unk_10114B98; // weak
_UNKNOWN unk_10114BB4; // weak
_UNKNOWN unk_10114BD0; // weak
_UNKNOWN unk_10114BEC; // weak
_UNKNOWN unk_10114C08; // weak
_UNKNOWN unk_10114C24; // weak
_UNKNOWN unk_10114C40; // weak
_UNKNOWN unk_10114C5C; // weak
_UNKNOWN unk_10114C78; // weak
_UNKNOWN unk_10114C94; // weak
_UNKNOWN unk_10114CB0; // weak
_UNKNOWN unk_10114CCC; // weak
_UNKNOWN unk_10114CE8; // weak
_UNKNOWN unk_10114D04; // weak
_UNKNOWN unk_10114D20; // weak
_UNKNOWN unk_10114D3C; // weak
_UNKNOWN unk_10114D58; // weak
_UNKNOWN unk_10114D74; // weak
_UNKNOWN unk_10114D90; // weak
_UNKNOWN unk_10114D94; // weak
_UNKNOWN unk_10114D98; // weak
_UNKNOWN unk_10114D9C; // weak
_UNKNOWN unk_10114DA0; // weak
_UNKNOWN unk_10114DA4; // weak
_UNKNOWN unk_10114DA8; // weak
_UNKNOWN unk_10114DAC; // weak
_UNKNOWN unk_10114DB0; // weak
_UNKNOWN unk_10114DB4; // weak
_UNKNOWN unk_10114DB8; // weak
_UNKNOWN unk_10114DBC; // weak
_UNKNOWN unk_10114DC0; // weak
_UNKNOWN unk_10114DC4; // weak
_UNKNOWN unk_10114DC8; // weak
_UNKNOWN unk_10114DCC; // weak
_UNKNOWN unk_10114DD0; // weak
_UNKNOWN unk_10114DD4; // weak
_UNKNOWN unk_10114DD8; // weak
_UNKNOWN unk_10114EBC; // weak
_UNKNOWN unk_1011607C; // weak
_UNKNOWN unk_10116080; // weak
_UNKNOWN unk_101160A8; // weak
_UNKNOWN unk_101160D0; // weak
_UNKNOWN unk_10116110; // weak
_UNKNOWN unk_10116190; // weak
_UNKNOWN unk_10116194; // weak
_UNKNOWN unk_10116198; // weak
_UNKNOWN unk_1011619A; // weak
_UNKNOWN unk_1011619C; // weak
_UNKNOWN unk_1011619D; // weak
_UNKNOWN unk_1011619E; // weak
_UNKNOWN unk_101161A0; // weak
_UNKNOWN unk_10116204; // weak
_UNKNOWN unk_1011620C; // weak
_UNKNOWN unk_10116214; // weak
_UNKNOWN unk_1011621C; // weak
_UNKNOWN unk_10116224; // weak
_UNKNOWN unk_1011622C; // weak
_UNKNOWN unk_10116234; // weak
_UNKNOWN unk_1011623C; // weak
_UNKNOWN unk_10116244; // weak
_UNKNOWN unk_1011624C; // weak
_UNKNOWN unk_10116254; // weak
_UNKNOWN unk_1011625C; // weak
_UNKNOWN unk_10116264; // weak
_UNKNOWN unk_1011626C; // weak
_UNKNOWN unk_10116274; // weak
_UNKNOWN unk_1011627C; // weak
_UNKNOWN unk_10116284; // weak
_UNKNOWN unk_1011628C; // weak
_UNKNOWN unk_10116294; // weak
_UNKNOWN unk_1011629C; // weak
_UNKNOWN unk_101162A4; // weak
_UNKNOWN unk_101162AC; // weak
_UNKNOWN unk_101162B4; // weak
_UNKNOWN unk_101162BC; // weak
_UNKNOWN unk_101162C4; // weak
_UNKNOWN unk_101162CC; // weak
_UNKNOWN unk_101162D4; // weak
_UNKNOWN unk_101162DC; // weak
_UNKNOWN unk_101162E4; // weak
_UNKNOWN unk_101162EC; // weak
_UNKNOWN unk_101162F4; // weak
_UNKNOWN unk_101162FC; // weak
_UNKNOWN unk_10116304; // weak
_UNKNOWN unk_1011630C; // weak
_UNKNOWN unk_10116314; // weak
_UNKNOWN unk_1011631C; // weak
_UNKNOWN unk_10116324; // weak
_UNKNOWN unk_1011632C; // weak
_UNKNOWN unk_10116334; // weak
_UNKNOWN unk_1011633C; // weak
_UNKNOWN unk_10116524; // weak
_UNKNOWN unk_10116534; // weak
_UNKNOWN unk_10116544; // weak
_UNKNOWN unk_10116554; // weak
_UNKNOWN unk_10116555; // weak
_UNKNOWN unk_10116556; // weak
_UNKNOWN unk_10116558; // weak
_UNKNOWN unk_1011655C; // weak
_UNKNOWN unk_10116604; // weak
_UNKNOWN unk_10116608; // weak
_UNKNOWN unk_1011660C; // weak
_UNKNOWN unk_1011665C; // weak
_UNKNOWN unk_10116660; // weak
_UNKNOWN unk_10116664; // weak
_UNKNOWN unk_10116754; // weak
_UNKNOWN unk_10116844; // weak
_UNKNOWN unk_10116848; // weak
_UNKNOWN unk_10116850; // weak
_UNKNOWN unk_10116858; // weak
_UNKNOWN unk_10116860; // weak
_UNKNOWN unk_10116868; // weak
_UNKNOWN unk_10116870; // weak
_UNKNOWN unk_10116878; // weak
_UNKNOWN unk_10116880; // weak
_UNKNOWN unk_10116888; // weak
_UNKNOWN unk_10116890; // weak
_UNKNOWN unk_10116898; // weak
_UNKNOWN unk_101168A0; // weak
_UNKNOWN unk_101168A4; // weak
_UNKNOWN unk_101168A8; // weak
_UNKNOWN unk_101168AC; // weak
_UNKNOWN unk_10116900; // weak
_UNKNOWN unk_10116954; // weak
_UNKNOWN unk_1011695C; // weak
_UNKNOWN unk_10116960; // weak
_UNKNOWN unk_10116964; // weak
_UNKNOWN unk_10116968; // weak
_UNKNOWN unk_1011696C; // weak
_UNKNOWN unk_10116B74; // weak
_UNKNOWN unk_10116CD4; // weak
_UNKNOWN unk_10116CEC; // weak
_UNKNOWN unk_10116D04; // weak
_UNKNOWN unk_10116D0E; // weak
_UNKNOWN unk_10116D10; // weak
_UNKNOWN unk_10116D20; // weak
_UNKNOWN unk_10116D24; // weak
_UNKNOWN unk_10116D28; // weak
_UNKNOWN unk_10116D2C; // weak
_UNKNOWN unk_10116D2D; // weak
_UNKNOWN unk_10116D30; // weak
_UNKNOWN unk_10116D80; // weak
_UNKNOWN unk_10116D84; // weak
_UNKNOWN unk_10116D85; // weak
_UNKNOWN unk_10116D86; // weak
_UNKNOWN unk_10116D87; // weak
_UNKNOWN unk_10116D9B; // weak
_UNKNOWN unk_10116D9C; // weak
_UNKNOWN unk_10116D9D; // weak
_UNKNOWN unk_10116D9E; // weak
_UNKNOWN unk_10116DA0; // weak
_UNKNOWN unk_10116E40; // weak
_UNKNOWN unk_10116E90; // weak
_UNKNOWN unk_10116E94; // weak
_UNKNOWN unk_10116E98; // weak
_UNKNOWN unk_10116E9C; // weak
_UNKNOWN unk_10116EA0; // weak
_UNKNOWN unk_10116EA4; // weak
_UNKNOWN unk_10116EA8; // weak
_UNKNOWN unk_10116EAC; // weak
_UNKNOWN unk_10116EB0; // weak
_UNKNOWN unk_10116EB4; // weak
_UNKNOWN unk_10116EB8; // weak
_UNKNOWN unk_10116EBC; // weak
_UNKNOWN unk_10116EC0; // weak
_UNKNOWN unk_10117000; // weak
_UNKNOWN unk_1011700C; // weak
_UNKNOWN unk_10117054; // weak
_UNKNOWN unk_10117055; // weak
_UNKNOWN unk_10117080; // weak
_UNKNOWN unk_101170B0; // weak
_UNKNOWN unk_101170D8; // weak
_UNKNOWN unk_101170DC; // weak
_UNKNOWN unk_101170E0; // weak
_UNKNOWN unk_101170E4; // weak
_UNKNOWN unk_10117114; // weak
_UNKNOWN unk_10117115; // weak
_UNKNOWN unk_10117116; // weak
_UNKNOWN unk_10117118; // weak
_UNKNOWN unk_1011711C; // weak
_UNKNOWN unk_10117120; // weak
_UNKNOWN unk_10117124; // weak
_UNKNOWN unk_10117128; // weak
_UNKNOWN unk_1011712C; // weak
_UNKNOWN unk_10117130; // weak
_UNKNOWN unk_10117134; // weak
_UNKNOWN unk_10117138; // weak
_UNKNOWN unk_1011713C; // weak
_UNKNOWN unk_1011749C; // weak
_UNKNOWN unk_101174A0; // weak
_UNKNOWN unk_101174AA; // weak
_UNKNOWN unk_101174B4; // weak
int dword_10118C70; // weak
_UNKNOWN unk_10118C78; // weak
char byte_10118F50[]; // weak
char byte_10118F51[]; // weak
_UNKNOWN unk_1011A1B8; // weak
int dword_1011BB68; // weak
int dword_1011BB6C; // weak
__int16 word_1011BB70; // weak
int dword_1011BB74; // weak
int dword_1011BB78; // weak
int dword_1011BB7C; // weak
int dword_1011BB80; // weak
int dword_1011BB84; // weak
int dword_1011BB88; // weak
int dword_1011BB8C; // weak
int dword_1011BB90; // weak
int dword_1011BB94; // weak
int dword_1011BB98; // weak
int dword_1011BB9C; // weak
int dword_1011BBA0; // weak
_UNKNOWN unk_101292F4; // weak
_UNKNOWN unk_101292F8; // weak
int dword_101292FC; // weak
int dword_10129300[]; // weak
int dword_10129304; // weak
int dword_10129308; // weak
int dword_1012930C; // weak
int dword_10129310; // weak
int dword_10129314[]; // weak
int dword_10129318; // weak
int dword_1012931C; // weak
int dword_10129320; // weak
int dword_10129324; // weak
_UNKNOWN unk_10129328; // weak
char byte_10129440; // idb
char byte_10129540[254]; // idb
char byte_1012963E[]; // weak
char byte_1012963F[]; // weak
char byte_10129A40[2800]; // idb
char byte_1012A530[1022]; // idb
char byte_1012A92E[]; // weak
char byte_1012A92F[]; // weak
char byte_1012A930[1022]; // idb
char byte_1012AD2E[]; // weak
char byte_1012AD2F[]; // weak
char byte_1012AD30[1022]; // idb
char byte_1012B12E[]; // weak
char byte_1012B12F[]; // weak
int dword_1012E130[]; // weak
int dword_1012E144[]; // weak
char byte_1012E158[2800]; // idb
char byte_1012EC48[2800]; // idb
char byte_1012F738[2800]; // idb
int dword_10130228[]; // weak
int dword_1013023C[]; // weak
char byte_10130250[2796]; // idb
char byte_10130D3C[]; // weak
char byte_10130D40[559]; // idb
char byte_10130F6F[]; // weak
int dword_10131830[]; // weak
int dword_10131844[]; // weak
char byte_10131858[2800]; // idb
int dword_10132348; // weak
_UNKNOWN unk_10132350; // weak
_UNKNOWN unk_10132EA8; // weak
int dword_10135230; // weak
_UNKNOWN unk_10135238; // weak
int dword_10136778; // weak
char byte_10136780[]; // weak
char byte_10136784[]; // weak
char byte_10136785[]; // weak
int dword_1013678C[]; // weak
int dword_10136794[]; // weak
int dword_101367C8; // weak
int dword_101367CC; // weak
int dword_101367D0; // weak
int dword_101367D4; // weak
_UNKNOWN unk_101367D8; // weak
_UNKNOWN unk_101367E0; // weak
_UNKNOWN unk_101367E8; // weak
int dword_101367F8; // weak
char byte_10136800[]; // weak
char byte_10136850[]; // weak
char byte_1013DBA0; // weak
char byte_1013DBA1; // weak
char byte_101A0190[]; // weak
char byte_101A0191[]; // weak
_UNKNOWN unk_101A0230; // weak
int dword_101A0500[]; // weak
int dword_101A0504[]; // weak
_UNKNOWN unk_101A0A20; // weak
_UNKNOWN unk_101A3928; // weak
_UNKNOWN unk_101A3E28; // weak
_UNKNOWN unk_101A3ED0; // weak
char byte_101A3EF0; // weak
char byte_101A3EF1; // weak
char byte_101A3EF2; // weak
char byte_101A3EF3; // weak
_UNKNOWN unk_101A3EF8; // weak
_UNKNOWN unk_101A3F18; // weak
int dword_101A5040; // weak
int dword_101A5370; // weak
int dword_101A537C; // weak
int dword_101A54D8; // weak
int dword_101A59A0; // weak
int dword_101A59AC; // weak
int dword_101A59B8; // weak
int dword_101A59BC; // weak
int dword_101A59C0; // weak
int dword_101A59DC; // weak
int dword_101A59E0; // weak
int dword_101A59E4; // weak
int dword_101A59E8; // weak
int dword_101A59EC; // weak
int dword_101A5AB0; // weak
char byte_101A5AB4; // weak
char byte_101A5AB5; // weak
char byte_101A5AB6; // weak
int dword_101A5AC0; // weak
_UNKNOWN unk_101A5AC4; // weak
char byte_101D7AE0; // weak
char byte_101D7AE1; // weak
char byte_101D7AE2; // weak
char byte_101D7AE4; // weak
char byte_101D7AEB; // weak
__int16 word_101D7AEE; // weak
__int16 word_101D7AF0; // weak
__int16 word_101D7AF4; // weak
int dword_101D7AF8; // weak
int dword_101D7AFC; // weak
int dword_101D7B14; // weak
int dword_101D7B20; // weak
int dword_101D7B28; // weak
char byte_101D7C68; // weak
int dword_101D7CBC; // weak
char byte_101D7CC0; // weak
int dword_101D7CE0[]; // weak
_BYTE dword_101D7CE4[1120]; // idb
int dword_101D8148; // weak
_UNKNOWN unk_101D814C; // weak
_UNKNOWN unk_101D8160; // weak
int dword_101D8164[]; // weak
char byte_101D816F[]; // weak
char byte_101D8171[]; // weak
int dword_101D822C; // weak
int dword_101D8230; // weak
char byte_101D8234[]; // weak
int dword_101D8238; // weak
int dword_101D823C; // weak
int dword_101D8240; // weak
int dword_101D8244; // weak
int dword_101D8248; // weak
int dword_101D824C; // weak
int dword_101D8250; // weak
void *dword_101D8254; // idb
int dword_101D9260; // weak
int dword_101D927C; // weak
UINT uNumber; // idb
int dword_101D92A0[]; // weak
int dword_101D93A0; // weak
int dword_101D93B8; // weak


//----- (10001000) --------------------------------------------------------
char __cdecl sub_10001000(int a1)
{
  int *v1; // ecx@1
  __int16 v2; // bx@1
  __int16 v3; // di@1
  char result; // al@1
  bool v5; // zf@1
  __int16 v6; // bp@1
  int v7; // ecx@3
  __int16 v8; // si@4
  __int16 v9; // dx@5
  char v10; // [sp+13h] [bp-1h]@1
  int v11; // [sp+18h] [bp+4h]@1

  v1 = (int *)a1;
  v2 = *(_WORD *)(a1 + 30);
  v3 = *(_WORD *)(a1 + 28);
  result = 0;
  v5 = a1 == dword_101D8148;
  v10 = 0;
  v6 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 34) - 1;
  v11 = (unsigned __int16)(*(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 32) - 1);
  if ( v5 )
  {
    result = 1;
    v10 = 1;
  }
  v7 = *v1;
  if ( v7 )
  {
    while ( 1 )
    {
      v8 = *(_WORD *)(v7 + 28);
      if ( v3 >= v8 )
      {
        v9 = *(_WORD *)(v7 + 30);
        if ( v2 >= v9 && v6 <= *(_WORD *)(v7 + 34) + v9 - 1 && (signed __int16)v11 <= *(_WORD *)(v7 + 32) + v8 - 1 )
          break;
      }
      v7 = *(_DWORD *)v7;
      if ( !v7 )
        return v10;
    }
    result = 1;
  }
  return result;
}
// 101D8148: using guessed type int dword_101D8148;

//----- (100010B0) --------------------------------------------------------
bool __cdecl sub_100010B0(int a1, int a2)
{
  char v2; // al@1

  v2 = *(_BYTE *)(a2 + 24);
  return v2 == 1 || v2 == 3;
}

//----- (100010D0) --------------------------------------------------------
int __usercall sub_100010D0@<eax>(int result@<eax>, int a2@<esi>)
{
  signed int v2; // ST1C_4@2
  float v3; // ST10_4@2
  float v4; // ST08_4@2

  if ( *(_BYTE *)(result + 11) )
  {
    j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
    j_gdi_pvg_matrix_mode(51);
    ((void (*)(void))j_gdi_pvg_load_identity)();
    v2 = *(_WORD *)(a2 + 32);
    v3 = (double)*(_WORD *)(a2 + 34);
    v4 = (double)v2;
    sub_10003B50(0.0, v4, 0.0, v3, 0.0, 1.0);
    j_gdi_pvg_matrix_mode(52);
    j_gdi_pvg_load_identity(v2);
    if ( (*(_BYTE *)(a2 + 24) & 3) == 2 )
      result = j_gdi_pvg_viewport(0, 0, *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
    else
      result = j_gdi_pvg_viewport(*(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
  }
  return result;
}
// 10003B10: using guessed type int __cdecl j_gdi_pvg_load_identity(_DWORD);
// 10003B30: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 10003B40: using guessed type int __cdecl j_gdi_pvg_matrix_mode(_DWORD);
// 10003C00: using guessed type int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001180) --------------------------------------------------------
int __cdecl sub_10001180(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // edx@2

  v2 = a2;
  if ( a2 )
  {
    v3 = a1;
    do
    {
      if ( sub_100010B0(v3, v2) )
        break;
      v2 = *(_DWORD *)(v2 + 4);
    }
    while ( v2 );
  }
  return v2;
}

//----- (100011B0) --------------------------------------------------------
char __cdecl sub_100011B0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int v6; // eax@2

  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 24) = a6;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) = a5;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) = a4;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 28) = a2;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 30) = a3;
  switch ( a6 & 3 )
  {
    case 0:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = sub_10002860(a1, a4, a5);
      LOBYTE(v6) = -1;
      if ( *(_DWORD *)(a1 + 24) == -1 || *(_BYTE *)(a1 + 11) != 1 )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = -1;
      }
      else
      {
        sub_10003F00();
        sub_10003F50(1);
        v6 = sub_10003EC0(a4, a5, 57);
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      }
      break;
    case 1:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = &unk_100E4920;
      v6 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      break;
    case 2:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      sub_10003F00();
      sub_10003F50(1);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = sub_10003EC0(a4, a5, 59);
      LOBYTE(v6) = sub_100010D0(a1, *(_DWORD *)(a1 + 56));
      break;
    case 3:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      v6 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(v6 + 52) = *(_DWORD *)(a1 + 24);
      break;
    default:
      LOBYTE(v6) = sub_10003E50(".\\cdp_cnvs_utl.c", 250, 1, 0);
      break;
  }
  return v6;
}
// 100555BC: using guessed type void *off_100555BC;

//----- (100012F0) --------------------------------------------------------
char __cdecl sub_100012F0(int a1, int a2)
{
  __int64 v2; // rax@4
  char result; // al@4
  int v4; // eax@5
  int v5; // eax@6
  int v6; // edx@6
  int v7; // eax@7
  int v8; // esi@9

  if ( !a2 )
    sub_10003E50(".\\cdp_cnvs_utl.c", 388, 1, 0);
  switch ( *(_BYTE *)(a2 + 24) & 3 )
  {
    case 0:
      *(_WORD *)(a1 + 270) = *(_WORD *)(a2 + 32);
      *(_WORD *)(a1 + 268) = *(_WORD *)(a2 + 34);
      *(_BYTE *)(a1 + 272) = 8;
      v2 = *(_WORD *)(a2 + 32) + 255;
      *(_WORD *)(a1 + 274) = (unsigned __int16)((BYTE4(v2) + (signed int)v2) >> 8) << 8;
      *(_DWORD *)(a1 + 264) = *(_DWORD *)(a2 + 48);
      *(_BYTE *)(a1 + 273) = 0;
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(a1 + 268);
      *(_WORD *)(a1 + 434) = 0;
      *(_WORD *)(a1 + 432) = 0;
      result = 1;
      break;
    case 1:
      v4 = *(_DWORD *)(a1 + 56);
      if ( *(_DWORD *)(v4 + 8) != *(_DWORD *)(a1 + 44) )
      {
        *(_DWORD *)(v4 + 52) = *(_DWORD *)(a1 + 24);
        sub_100010D0(a1, *(_DWORD *)(a1 + 56));
        v5 = *(_DWORD *)(a1 + 56);
        v6 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 44) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(v5 + 52) = v6;
      }
      *(_DWORD *)(a1 + 264) = &unk_100E4920;
      v7 = a1 + 264;
      *(_DWORD *)(v7 + 4) = *(&off_100555BC + 1);
      *(_DWORD *)(v7 + 8) = *(&off_100555BC + 2);
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(a1 + 268);
      sub_100054C0(a1 + 392, *(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
      *(_WORD *)(a1 + 434) = *(_WORD *)(a2 + 28);
      *(_WORD *)(a1 + 432) = *(_WORD *)(a2 + 30);
      result = 1;
      break;
    case 2:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      result = 1;
      break;
    case 3:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      v8 = *(_DWORD *)(a1 + 56);
      if ( *(_DWORD *)(v8 + 8) == *(_DWORD *)(a1 + 44) )
        goto LABEL_12;
      sub_100010D0(a1, v8);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 8);
      result = 1;
      break;
    default:
      sub_10003E50(".\\cdp_cnvs_utl.c", 473, 1, 0);
LABEL_12:
      result = 1;
      break;
  }
  return result;
}
// 10003B30: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 100555BC: using guessed type void *off_100555BC;

//----- (100014E0) --------------------------------------------------------
unsigned int sub_100014E0()
{
  int *v0; // ecx@1
  unsigned int result; // eax@1
  int v2; // ecx@3
  int v3; // ecx@3
  int v4; // edx@3

  v0 = dword_101D7CE4;
  result = 0;
  do
  {
    *(v0 - 1) = 0;
    *(_BYTE *)v0 = 0;
    v0 += 2;
  }
  while ( (signed int)v0 < (signed int)&unk_101D814C );
  do
  {
    v2 = dword_10051DC0[result];
    dword_101D7CE0[2 * v2] = *(int *)((char *)&off_10051DC4 + result * 4);
    dword_101D7CE4[2 * v2] = dword_10051DC8[result];
    v3 = dword_10051DCC[result];
    dword_101D7CE0[2 * v3] = *(int *)((char *)&off_10051DD0 + result * 4);
    v4 = dword_10051DD4[result];
    result += 6;
    dword_101D7CE4[2 * v3] = v4;
  }
  while ( result < 42 );
  return result * 4;
}
// 10051DC0: using guessed type int dword_10051DC0[];
// 10051DC4: using guessed type int (__cdecl *off_10051DC4)(int, int, int, int, int);
// 10051DC8: using guessed type int dword_10051DC8[];
// 10051DCC: using guessed type int dword_10051DCC[];
// 10051DD0: using guessed type int (__cdecl *off_10051DD0)(int, int, int, int, int);
// 10051DD4: using guessed type int dword_10051DD4[];
// 101D7CE0: using guessed type int dword_101D7CE0[];
// 101D7CE4: using guessed type int dword_101D7CE4[];

//----- (10001550) --------------------------------------------------------
int __cdecl sub_10001550(int a1, int a2)
{
  int result; // eax@1

  for ( result = *(_DWORD *)(a1 + 48); result; result = *(_DWORD *)(result + 4) )
  {
    if ( *(_DWORD *)(result + 8) == a2 )
      break;
  }
  return result;
}

//----- (10001570) --------------------------------------------------------
int __cdecl sub_10001570(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 3) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_BYTE *)(a1 + 5) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 10) = 0;
  *(_BYTE *)(a1 + 7) = 1;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

//----- (100015A0) --------------------------------------------------------
int __cdecl sub_100015A0(int a1, int a2)
{
  byte_101D7CC0 = 0;
  sub_10010930(&unk_100E3780);
  return nullsub_1(a1, a2);
}
// 101D7CC0: using guessed type char byte_101D7CC0;

//----- (100015C0) --------------------------------------------------------
int __cdecl sub_100015C0(int a1, char *a2, int a3, int a4)
{
  if ( !a2 )
    sub_10003E50(".\\cdp_main.c", 890, 1, 0);
  if ( a3 > 0 )
    *((_DWORD *)a2 + 3) = sub_100027E0(a1, a3);
  *((_DWORD *)a2 + 14) = sub_100027E0(a1, 4 * a4 + 4);
  a2[68] = a4;
  a2[231] = 0;
  if ( a4 > 0 )
  {
    *((_DWORD *)a2 + 15) = sub_100027E0(a1, 4 * a4);
    *((_DWORD *)a2 + 16) = sub_100027E0(a1, a4);
  }
  return *((_DWORD *)a2 + 3);
}

//----- (10001650) --------------------------------------------------------
char __cdecl sub_10001650(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 1;
  v9 = 1000;
  v4 = sub_10004120(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_10003E50(".\\cdp_main.c", 1068, 0, 0);
  return v4;
}

//----- (100016C0) --------------------------------------------------------
char __cdecl sub_100016C0(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 2;
  v9 = 1000;
  v4 = sub_10004120(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_10003E50(".\\cdp_main.c", 1136, 0, 0);
  return v4;
}

//----- (10001730) --------------------------------------------------------
int sub_10001730()
{
  int result; // eax@1

  result = sub_10003FF0();
  dword_100E3788 = result;
  byte_100E3784 = 0;
  return result;
}
// 100E3784: using guessed type char byte_100E3784;
// 100E3788: using guessed type int dword_100E3788;

//----- (10001750) --------------------------------------------------------
_DWORD *__cdecl sub_10001750(int a1)
{
  return sub_10010970(&unk_100E3780, a1);
}

//----- (10001770) --------------------------------------------------------
unsigned int __cdecl sub_10001770(int a1, int a2, int a3)
{
  unsigned int result; // eax@1

  result = (a3 * (1000 / *(_WORD *)(a1 + 20)) + 500) / 1000;
  if ( result >= 1 )
  {
    if ( result >= 0xFF )
      result = 255;
    *(_BYTE *)(a2 + 243) = result;
    *(_BYTE *)(a2 + 244) = result;
  }
  else
  {
    result = 1;
    *(_BYTE *)(a2 + 243) = 1;
    *(_BYTE *)(a2 + 244) = 1;
  }
  return result;
}

//----- (100017E0) --------------------------------------------------------
void __usercall sub_100017E0(int a1@<esi>)
{
  if ( *(_BYTE *)(a1 + 11) )
  {
    sub_10003AF0();
    sub_10003F00();
    sub_10003F50(1);
    *(_DWORD *)(a1 + 28) = sub_10003EC0(*(_WORD *)(a1 + 16), *(_WORD *)(a1 + 14), 57);
    sub_10003F00();
    *(_DWORD *)(a1 + 24) = sub_10003EC0(*(_WORD *)(a1 + 16), *(_WORD *)(a1 + 14), 59);
  }
}

//----- (10001830) --------------------------------------------------------
char __usercall sub_10001830@<al>(int a1@<esi>)
{
  _WORD *v1; // eax@1
  int v2; // edi@1
  void *v3; // ecx@1
  int v4; // eax@1
  int v5; // eax@9
  char result; // al@13
  char v7; // [sp+8h] [bp-8h]@1
  int v8; // [sp+Ch] [bp-4h]@1

  v1 = *(_WORD **)(a1 + 52);
  v8 = 2;
  byte_101A5AB6 = *v1 == -32749;
  byte_101D7CC0 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  v2 = *(_DWORD *)(a1 + 56);
  sub_10004330(9129, &v7, 2, &v8);
  v4 = *(_DWORD *)(a1 + 64);
  if ( (v4 == 1 || v4 == 9) && sub_10011500(v3) != 2 && v7 & 0x1C )
  {
    byte_101A5AB6 = 0;
    byte_101D7CC0 = 0;
  }
  if ( *(_DWORD *)(a1 + 64) == 1 && sub_10011190() )
  {
    byte_101A5AB6 = 0;
    byte_101D7CC0 = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 238) = 1;
  }
  v5 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 56) = v5;
  if ( v5 && *(_BYTE *)(v5 + 230) != -1 && !*(_BYTE *)(v5 + 238) )
  {
    sub_10010B20(a1, (char *)v5, (int)&unk_100660FC);
    *(_BYTE *)(a1 + 1) = 1;
  }
  *(_DWORD *)(a1 + 56) = v2;
  result = sub_10003870(a1);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 101A5AB6: using guessed type char byte_101A5AB6;
// 101D7CC0: using guessed type char byte_101D7CC0;

//----- (10001910) --------------------------------------------------------
void __usercall sub_10001910(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  __int64 v3; // rax@8

  v2 = *(_DWORD *)(a1 + 52);
  if ( v2 != -1 )
  {
    if ( *(_BYTE *)(a1 + 24) & 3 )
    {
      if ( (*(_BYTE *)(a1 + 24) & 3) == 2 )
        sub_100039F0(v2, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), 0, 0, *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 34));
    }
    else if ( *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 26) && !sub_10001000(a1) )
    {
      j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 52));
      v3 = *(_WORD *)(a1 + 32) + 255;
      sub_10003A70(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(a1 + 34), 57, 15, *(_DWORD *)(a1 + 48));
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 24));
      sub_100039F0(
        *(_DWORD *)(a1 + 52),
        *(_WORD *)(a1 + 28),
        *(_WORD *)(a1 + 30),
        0,
        0,
        *(_WORD *)(a1 + 32),
        *(_WORD *)(a1 + 34));
    }
  }
}
// 10003B30: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);

//----- (100019E0) --------------------------------------------------------
void __usercall sub_100019E0(int a1@<esi>, int a2)
{
  __int16 v2; // ST1C_2@5
  __int16 v3; // ST14_2@5
  __int16 v4; // ST10_2@5
  int v5; // [sp+0h] [bp-Ch]@5
  __int16 v6; // [sp+4h] [bp-8h]@5
  __int16 v7; // [sp+6h] [bp-6h]@5
  char v8; // [sp+8h] [bp-4h]@5
  char v9; // [sp+9h] [bp-3h]@5
  __int16 v10; // [sp+Ah] [bp-2h]@5

  if ( !(*(_BYTE *)(a1 + 24) & 3) && *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 26) && !sub_10001000(a1) )
  {
    v2 = *(_WORD *)(a1 + 34);
    v7 = *(_WORD *)(a1 + 32);
    v3 = *(_WORD *)(a1 + 30);
    v4 = *(_WORD *)(a1 + 28);
    v10 = (unsigned __int16)((v7 + 255) / 256) << 8;
    v5 = *(_DWORD *)(a1 + 48);
    v6 = v2;
    v8 = 8;
    v9 = 0;
    sub_100055D0(a2 + 392, (int)&v5, 0, 0, v4, v3, v7, v2);
  }
}

//----- (10001A80) --------------------------------------------------------
int __usercall sub_10001A80@<eax>(int a1@<edi>, int a2)
{
  int v2; // esi@1
  __int64 v3; // rax@8
  int result; // eax@11

  v2 = *(_DWORD *)(a1 + 48);
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)(v2 + 4) )
  {
    if ( !*(_DWORD *)(v2 + 4) )
      break;
    if ( sub_100010B0(a1, v2) )
      break;
  }
  if ( *(_DWORD *)(a1 + 24) != -1 )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 24));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
    if ( v2 )
    {
      if ( (*(_BYTE *)(v2 + 24) & 3) == 1 )
      {
        j_gdi_pvg_make_window_current(*(_DWORD *)(v2 + 52));
        v3 = *(_WORD *)(a1 + 16) + 255;
        sub_10003A70(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(v2 + 34), 57, 15, *(_DWORD *)(v2 + 48));
        j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
        sub_100039F0(
          *(_DWORD *)(v2 + 52),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 32),
          *(_WORD *)(v2 + 34));
      }
      nullsub_1(a1, 1);
      do
      {
        sub_10001910(v2, a1);
        v2 = *(_DWORD *)v2;
      }
      while ( v2 );
    }
    result = nullsub_1(a1, 0);
    goto LABEL_21;
  }
  if ( *(_BYTE *)(a1 + 11) )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 28));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 28));
  }
  if ( v2 && *(_BYTE *)(v2 + 26) )
    nullsub_1(a1, 1);
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)v2 )
    sub_100019E0(v2, a1);
  result = nullsub_1(a1, 0);
  if ( *(_BYTE *)(a1 + 11) )
  {
    result = sub_10003A70(
               0,
               0,
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 10),
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 4),
               57,
               15,
               **(_DWORD **)(a1 + 444));
LABEL_21:
    if ( *(_BYTE *)(a1 + 11) )
      result = j_gdi_pvg_update_display_wdw();
  }
  *(_BYTE *)(a1 + 392) = 0;
  return result;
}
// 10003B20: using guessed type int __cdecl j_gdi_pvg_make_window_active(_DWORD);
// 10003B30: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 10003BD0: using guessed type int j_gdi_pvg_update_display_wdw(void);

//----- (10001C50) --------------------------------------------------------
char __thiscall sub_10001C50(int this)
{
  char result; // al@1

  result = 0;
  if ( !*(_BYTE *)(*(_DWORD *)(this + 56) + 26) && **(_WORD **)(this + 52) == -32696 )
  {
    result = 1;
    *(_BYTE *)(this + 6) = 2;
  }
  return result;
}

//----- (10001C70) --------------------------------------------------------
signed int __cdecl sub_10001C70(int a1, int a2)
{
  const void *v2; // edx@1
  int v3; // ebx@1
  char v4; // al@4
  char v6; // al@13
  char v7; // al@14
  int v8; // [sp-Ch] [bp-FCh]@15
  __int16 *v9; // [sp-8h] [bp-F8h]@15
  int v10; // [sp+Ch] [bp-E4h]@1
  __int16 v11; // [sp+18h] [bp-D8h]@7
  int v12; // [sp+1Ch] [bp-D4h]@12

  v2 = (const void *)a2;
  v3 = *(_DWORD *)(a2 + 4);
  v10 = 0;
  if ( !v3 )
  {
    if ( *(_WORD *)a2 > 0x8001u && *(_WORD *)a2 < 0x800Du )
    {
      v3 = *(_DWORD *)(a1 + 48);
      v4 = 1;
      goto LABEL_7;
    }
    v3 = 0;
  }
  v4 = 0;
LABEL_7:
  qmemcpy(&v11, (const void *)a2, 0xCCu);
  if ( !v4 )
  {
    sub_10001650(a1, (int)&v11, 204);
    return 1;
  }
  if ( v3 )
  {
    while ( 1 )
    {
      qmemcpy(&v11, v2, 0xCCu);
      v12 = v3;
      if ( v11 != -32760 )
        break;
      v6 = *(_BYTE *)(v3 + 243);
      if ( v6 )
      {
        v7 = v6 - 1;
        *(_BYTE *)(v3 + 243) = v7;
        if ( !v7 )
        {
          v11 = -32648;
          v9 = &v11;
          *(_BYTE *)(v3 + 243) = *(_BYTE *)(v3 + 244);
          v8 = a1;
LABEL_17:
          sub_10001650(v8, (int)v9, 204);
          ++v10;
          goto LABEL_18;
        }
      }
LABEL_18:
      if ( sub_100010B0(a1, v3) )
        return v10;
      v3 = *(_DWORD *)(v3 + 4);
      if ( !v3 )
        return v10;
      v2 = (const void *)a2;
    }
    v9 = &v11;
    v8 = a1;
    goto LABEL_17;
  }
  return v10;
}

//----- (10001DC0) --------------------------------------------------------
char __cdecl sub_10001DC0(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_10001650(a1, (int)&v4, 8);
}

//----- (10001DF0) --------------------------------------------------------
char __cdecl sub_10001DF0(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_100016C0(a1, (int)&v4, 8);
}

//----- (10001E20) --------------------------------------------------------
char __cdecl sub_10001E20(unsigned int a1)
{
  int v1; // eax@1
  int v2; // ecx@2
  __int16 v3; // dx@2
  unsigned int v4; // ebx@3
  _DWORD *v5; // eax@3
  char v6; // dl@3
  __int16 v7; // ax@10
  unsigned __int16 v8; // cx@14
  int v9; // eax@31
  int v10; // eax@31
  int v11; // eax@41
  __int16 v12; // ax@48
  char v13; // al@52
  _WORD *v14; // edx@55
  int v15; // ebp@58
  int v17; // [sp+0h] [bp-10h]@0
  int v18; // [sp+0h] [bp-10h]@51

  v1 = *(_DWORD *)(a1 + 52);
  if ( *(_WORD *)v1 < 0x8000u )
  {
    v2 = *(_DWORD *)(v1 + 4);
    v3 = *(_WORD *)(v1 + 8);
    *(_WORD *)v1 = -32670;
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 12) = v2;
    *(_WORD *)(*(_DWORD *)(a1 + 52) + 8) = v3;
  }
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
  sub_10010940((int *)&unk_100E3780, a1);
  v5 = *(_DWORD **)(a1 + 32);
  v6 = 0;
  if ( v5 )
  {
    while ( *(_DWORD **)(*(_DWORD *)(a1 + 52) + 4) != v5 )
    {
      v5 = (_DWORD *)*v5;
      if ( !v5 )
        goto LABEL_8;
    }
    v6 = 1;
  }
LABEL_8:
  if ( v4 )
  {
    if ( !v6 )
    {
      v7 = **(_WORD **)(a1 + 52);
      if ( v7 != -32703 )
      {
        if ( v7 == -32744 )
          return v7;
        v4 = 0;
        *(_DWORD *)(a1 + 56) = 0;
      }
    }
  }
  LOBYTE(v7) = sub_10003840();
  if ( !(_BYTE)v7 )
  {
    v8 = **(_WORD **)(a1 + 52);
    switch ( **(_WORD **)(a1 + 52) )
    {
      case 0x8013:
      case 0x8014:
        sub_10001830(a1);
        goto LABEL_40;
      case 0x8018:
        if ( *(_DWORD *)(a1 + 24) != -1 && (!(*(_BYTE *)(v4 + 24) & 3) || (*(_BYTE *)(v4 + 24) & 3) == 2) )
          j_gdi_pvg_destroy_window(*(_DWORD *)(v4 + 52));
        if ( v4 != *(_DWORD *)(a1 + 32) && *(_DWORD *)(v4 + 4) )
        {
          *(_DWORD *)(a1 + 48) = *(_DWORD *)(v4 + 4);
          **(_DWORD **)(v4 + 4) = 0;
        }
        else
        {
          sub_10001570(a1);
        }
        goto LABEL_40;
      case 0x8022:
      case 0x8078:
        if ( *(_BYTE *)(a1 + 4) || v4 && sub_10001000(v4) )
          v4 = 0;
        if ( *(_DWORD *)(a1 + 64) == 1 && sub_10011190() != byte_100E3784 )
        {
          **(_WORD **)(a1 + 52) = -32734;
          byte_100E3784 = sub_10011190();
        }
        goto LABEL_40;
      case 0x8041:
        v9 = sub_100027E0(a1, 332);
        v4 = v9;
        qmemcpy((void *)v9, &unk_10052440, 0x14Cu);
        *(_DWORD *)(v9 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
        v10 = *(_DWORD *)(a1 + 48);
        if ( v10 )
        {
          *(_DWORD *)(v4 + 4) = v10;
          **(_DWORD **)(a1 + 48) = v4;
          *(_BYTE *)(v4 + 243) = *(_BYTE *)(*(_DWORD *)(v4 + 4) + 243);
        }
        if ( !*(_DWORD *)(a1 + 32) )
          *(_DWORD *)(a1 + 32) = v4;
        --*(_BYTE *)(a1 + 4);
        *(_DWORD *)(a1 + 48) = v4;
        goto LABEL_40;
      default:
        if ( !v4 )
        {
          if ( v8 <= 0x800Eu || v8 >= 0xFFFFu )
            goto LABEL_67;
          v4 = *(_DWORD *)(a1 + 48);
LABEL_40:
          if ( !v4 )
            goto LABEL_67;
        }
        v11 = *(_DWORD *)(a1 + 52);
        *(_DWORD *)(a1 + 56) = v4;
        *(_BYTE *)(a1 + 6) = 1;
        *(_DWORD *)(v11 + 4) = v4;
        if ( **(_WORD **)(a1 + 52) == -32665 )
          *(_BYTE *)(*(_DWORD *)(a1 + 56) + 237) = 0;
        sub_10003780(a1);
        if ( *(_BYTE *)(a1 + 6) == 1 && !sub_10001C50(a1) )
          (*(void (__cdecl **)(unsigned int))(v4 + 8))(a1);
        if ( !v4 || v4 > *(_DWORD *)(a1 + 48) && (v12 = **(_WORD **)(a1 + 52), v12 != -32703) && v12 != -32744 )
        {
LABEL_67:
          v4 = 0;
          *(_DWORD *)(a1 + 56) = 0;
        }
        LOBYTE(v7) = nullsub_1(a1, v17);
        if ( v4 )
        {
          v13 = *(_BYTE *)(a1 + 6);
          if ( v13 == 1 || v13 == 3 )
            nullsub_1(a1, v18);
          v14 = *(_WORD **)(a1 + 52);
          if ( *v14 == 32792 )
          {
            LOBYTE(v7) = sub_10002440(0, v4);
            if ( !*(_DWORD *)(a1 + 32) )
              *(_DWORD *)(a1 + 56) = 0;
            *(_BYTE *)(a1 + 1) = 1;
          }
          else if ( *v14 == 32871 )
          {
            LOBYTE(v7) = sub_10001DC0(a1, *(_DWORD *)(a1 + 56), -32734);
          }
          else
          {
            v7 = *v14 + 32648;
            if ( *v14 == 32888 )
            {
              v15 = *(_DWORD *)(a1 + 56);
              if ( v15 )
                *(_BYTE *)(v15 + 26) = 1;
            }
          }
        }
        break;
    }
  }
  return v7;
}
// 10003EF0: using guessed type int __cdecl j_gdi_pvg_destroy_window(_DWORD);
// 100E3784: using guessed type char byte_100E3784;

//----- (10002150) --------------------------------------------------------
int __usercall sub_10002150@<eax>(unsigned int a1@<eax>)
{
  unsigned int v1; // edi@1
  int result; // eax@1
  __int16 v3; // ax@2
  bool v4; // al@4
  char v5; // [sp+4h] [bp-4h]@1

  v1 = a1;
  for ( result = sub_10003FA0(*(_DWORD *)(a1 + 52), (int)&v5);
        result != 1;
        result = sub_10003FA0(*(_DWORD *)(v1 + 52), (int)&v5) )
  {
    v3 = **(_WORD **)(v1 + 52);
    v4 = v3 == -32696 || v3 == -32734;
    *(_BYTE *)(v1 + 10) = v4;
    sub_10001E20(v1);
    if ( *(_BYTE *)(v1 + 6) != 1 && *(_BYTE *)(v1 + 10) && (*(_BYTE *)(v1 + 392) || *(_BYTE *)(v1 + 1)) )
    {
      sub_10001A80(v1, (int)&off_100555BC);
      *(_BYTE *)(v1 + 10) = 0;
    }
  }
  return result;
}
// 100555BC: using guessed type void *off_100555BC;

//----- (100021E0) --------------------------------------------------------
void __usercall __noreturn sub_100021E0(char *a1@<edi>)
{
  void *v1; // ecx@8
  unsigned int v2; // esi@16
  int v3; // eax@19
  int v4; // [sp+10h] [bp-ECh]@1
  char v5; // [sp+14h] [bp-E8h]@9
  char v6; // [sp+18h] [bp-E4h]@5

  dword_101D7CBC = (int)&dword_101A5AC0;
  sub_10004200(&v4);
  if ( !(v4 & 0x10) )
    sub_10003E50(".\\cdp_main.c", 403, 1, 0);
  v4 |= 0x10u;
  if ( !sub_10004190(1, 20000) )
    sub_10003E50(".\\cdp_main.c", 428, 1, 0);
  sub_10011A50();
  sub_10011620(&v6);
  sub_100044F0();
  while ( 1 )
  {
    byte_101D7C68 = 0;
    if ( v4 & 0x10 || v4 & 0x8000 )
    {
      sub_10001570((int)&byte_101D7AE0);
      byte_101D7AE2 = sub_10011110(v1);
      byte_101D7AE4 = 0;
      dword_101D7B14 = (int)&unk_100E3790;
      word_101D7AEE = 56;
      word_101D7AF0 = 264;
      dword_101D7B20 = 10;
      word_101D7AF4 = 500;
      dword_101D7AF8 = -1;
      dword_101D7AFC = -1;
      byte_101D7AEB = 1;
      dword_101D7B28 = 0;
      byte_101D7AE0 = 0;
      while ( sub_10003FA0(dword_101D7B14, (int)&v5) != 1 )
        ;
      sub_100014D0();
      sub_100027C0((int)&byte_101D7AE0);
      sub_10003850((int)a1, (unsigned int)&byte_101D7AE0);
      sub_10011A40((int)&unk_10052418);
      sub_10011A30((int)&unk_10052420);
      sub_100017E0((int)&byte_101D7AE0);
      sub_100038F0((unsigned int)&byte_101D7AE0);
    }
    if ( v4 & 2 )
      sub_10002150((unsigned int)&byte_101D7AE0);
    if ( v4 & 1 )
    {
      v4 |= 0x20000000u;
      if ( (unsigned int)(sub_10003FF0() - dword_100E3788) >= 0x3E8 )
      {
        dword_100E3788 += 1000;
        j_nullsub_1(&byte_101D7AE0);
        sub_10011510((int *)&v6);
      }
    }
    v2 = 0x40000000;
    do
    {
      if ( v2 != 0x8000 && v2 & v4 )
      {
        v3 = sub_10010BD0(v2);
        sub_10001C70((int)&byte_101D7AE0, v3);
        sub_10002150((unsigned int)&byte_101D7AE0);
      }
      v2 >>= 1;
    }
    while ( v2 >= 0x200 );
    if ( byte_101D7C68 || byte_101D7AE1 )
    {
      a1 = &byte_101D7AE0;
      sub_10001A80((int)&byte_101D7AE0, (int)&off_100555BC);
    }
    sub_10004200(&v4);
  }
}
// 100014D0: using guessed type int sub_100014D0(void);
// 10011A20: using guessed type int __cdecl j_nullsub_1(_DWORD);
// 10011A50: using guessed type int sub_10011A50(void);
// 100555BC: using guessed type void *off_100555BC;
// 100E3788: using guessed type int dword_100E3788;
// 101A5AC0: using guessed type int dword_101A5AC0;
// 101D7AE0: using guessed type char byte_101D7AE0;
// 101D7AE1: using guessed type char byte_101D7AE1;
// 101D7AE2: using guessed type char byte_101D7AE2;
// 101D7AE4: using guessed type char byte_101D7AE4;
// 101D7AEB: using guessed type char byte_101D7AEB;
// 101D7AEE: using guessed type __int16 word_101D7AEE;
// 101D7AF0: using guessed type __int16 word_101D7AF0;
// 101D7AF4: using guessed type __int16 word_101D7AF4;
// 101D7AF8: using guessed type int dword_101D7AF8;
// 101D7AFC: using guessed type int dword_101D7AFC;
// 101D7B14: using guessed type int dword_101D7B14;
// 101D7B20: using guessed type int dword_101D7B20;
// 101D7B28: using guessed type int dword_101D7B28;
// 101D7C68: using guessed type char byte_101D7C68;
// 101D7CBC: using guessed type int dword_101D7CBC;

//----- (10002420) --------------------------------------------------------
int __cdecl sub_10002420(int a1, int a2)
{
  return a2 * ((a1 + 255) / 256) << 8;
}

//----- (10002440) --------------------------------------------------------
char __cdecl sub_10002440(int a1, unsigned int a2)
{
  char result; // al@4

  if ( !a2 || a2 < (unsigned int)&unk_101A5AC4 || a2 >= dword_101A5AC0 )
    result = sub_10003E50(".\\cdp_mem.c", 222, 1, 0);
  dword_101A5AC0 = a2;
  return result;
}
// 101A5AC0: using guessed type int dword_101A5AC0;

//----- (10002480) --------------------------------------------------------
char sub_10002480()
{
  char result; // al@1

  byte_100E3860 = 0;
  result = sub_100049D0((int)"/mnt/card0/enable_heap_mntr.txt");
  if ( result )
    byte_100E3860 = 1;
  return result;
}
// 100E3860: using guessed type char byte_100E3860;

//----- (100024A0) --------------------------------------------------------
char __thiscall sub_100024A0(int this)
{
  unsigned int v1; // eax@1
  unsigned int v2; // esi@2
  int v3; // ecx@5
  int v4; // eax@5
  char *v5; // edi@6
  char v7[4]; // [sp+4h] [bp-ACh]@1
  int v8; // [sp+8h] [bp-A8h]@1
  int v9; // [sp+Ch] [bp-A4h]@1
  int v10; // [sp+10h] [bp-A0h]@1
  int v11; // [sp+14h] [bp-9Ch]@1
  char v12; // [sp+18h] [bp-98h]@1
  char v13; // [sp+2Ch] [bp-84h]@1

  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  sub_10004010((int)&v12, 1, *(_DWORD *)(this + 64), 20);
  sub_10011C70(&v13, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v12);
  LOBYTE(v1) = sub_100049D0((int)&v13);
  if ( (_BYTE)v1 )
  {
    v1 = j_FIL_vfs_open(&v13, 4, 0);
    v2 = v1;
    if ( v1 < 0xFFFFFFC2
      && v1
      && (sub_10004840(v1, &byte_100E3868, 4096),
          sub_10004770(v2),
          (v1 = (unsigned int)strstr(&byte_100E3868, "usage:")) != 0) )
    {
      v3 = v1 - (_DWORD)&byte_100E3868;
      v4 = v1 - (_DWORD)&byte_100E3868 + 7;
      if ( v4 < v3 + 27 )
      {
        v5 = &v7[-v4];
        do
        {
          if ( !((word_10068A90[2 * (unsigned __int8)*(&byte_100E3868 + v4)] >> 4) & 1) )
            break;
          v5[v4] = *(&byte_100E3868 + v4);
          ++v4;
        }
        while ( v4 < v3 + 27 );
      }
      v1 = j__atol(v7);
      dword_100E4868 = v1;
    }
    else
    {
      dword_100E4868 = 0;
    }
  }
  else
  {
    dword_100E4868 = 0;
  }
  return v1;
}
// 10004830: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100E4868: using guessed type int dword_100E4868;

//----- (10002610) --------------------------------------------------------
void *__usercall sub_10002610@<eax>(unsigned int a1@<ecx>, int a2@<ebx>)
{
  int v2; // edi@1
  unsigned int v3; // esi@1
  void *result; // eax@1
  int v5; // ecx@3
  unsigned int v6; // ebp@3
  _DWORD *i; // esi@5
  int v8; // esi@9
  int v9; // [sp+8h] [bp-198h]@1
  char v10; // [sp+Ch] [bp-194h]@3
  char v11; // [sp+20h] [bp-180h]@1
  char v12; // [sp+54h] [bp-14Ch]@4
  char v13; // [sp+11Ch] [bp-84h]@3

  v2 = 0;
  v3 = a1;
  result = memset(&v11, 0, 0x32u);
  v9 = 0;
  if ( a2 && dword_100E4868 < v3 )
  {
    v5 = *(_DWORD *)(a2 + 64);
    dword_100E4868 = v3;
    sub_10004010((int)&v10, 1, v5, 20);
    sub_10011C70(&v13, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v10);
    v6 = j_FIL_vfs_open(&v13, 10, 0);
    sub_10011B50((int)&byte_100E3868, "HEAP STATISTICS:\r\n", 4096);
    if ( v3 > 0x32000 )
    {
      sub_10011B50((int)&v12, "\r\n!!!HEAP LIMIT EXCEEDED!!!\r\n", 200);
      sub_10011CA0(&byte_100E3868, &v12, 4096);
    }
    sub_10011C70(&v12, 0xC8u, "%s maximum heap usage: %d bytes out of %d bytes\r\n", &v10, v3, 204800);
    result = (void *)sub_10011CA0(&byte_100E3868, &v12, 4096);
    for ( i = *(_DWORD **)(a2 + 32); i; ++v2 )
    {
      sub_10002920((int)i, (__int16 *)&v9, &v11);
      sub_10011C70(&v12, 0xC8u, "  Page[%d]: %s\r\n", v2, &v11);
      result = (void *)sub_10011CA0(&byte_100E3868, &v12, 4096);
      i = (_DWORD *)*i;
    }
    if ( v6 < 0xFFFFFFC2 )
    {
      if ( v6 )
      {
        v8 = sub_10011BA0(&byte_100E3868, 0x1000u);
        j_FIL_vfs_write(v6, &byte_100E3868, v8);
        sub_10004980(v6, v8, 0);
        result = (void *)sub_10004770(v6);
      }
    }
  }
  return result;
}
// 10004830: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100049A0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 100E4868: using guessed type int dword_100E4868;

//----- (100027C0) --------------------------------------------------------
char __cdecl sub_100027C0(int a1)
{
  char result; // al@2

  dword_101A5AC0 = (int)&unk_101A5AC4;
  if ( byte_100E3860 )
    result = sub_100024A0(a1);
  return result;
}
// 100E3860: using guessed type char byte_100E3860;
// 101A5AC0: using guessed type int dword_101A5AC0;

//----- (100027E0) --------------------------------------------------------
int __cdecl sub_100027E0(int a1, int a2)
{
  unsigned int v2; // esi@1
  int result; // eax@4

  v2 = (unsigned int)(a2 + 3) >> 2;
  if ( byte_100E3860 )
    sub_10002610(dword_101A5AC0 + 4 * v2 - *(_DWORD *)(a1 + 476), a1);
  if ( !a2 || (result = dword_101A5AC0, dword_101A5AC0 + 4 * v2 > *(_DWORD *)(a1 + 476) + 204804) )
  {
    sub_10003E50(".\\cdp_mem.c", 371, 1, 0);
    result = dword_101A5AC0;
  }
  dword_101A5AC0 = result + 4 * v2;
  return result;
}
// 100E3860: using guessed type char byte_100E3860;
// 101A5AC0: using guessed type int dword_101A5AC0;

//----- (10002860) --------------------------------------------------------
int __cdecl sub_10002860(int a1, __int16 a2, __int16 a3)
{
  int v3; // eax@1

  v3 = sub_10002420(a2, a3);
  return sub_100027E0(a1, v3);
}

//----- (100028A0) --------------------------------------------------------
__int16 __cdecl sub_100028A0(unsigned __int8 a1)
{
  return *(_WORD *)(dword_101A5AB0 + 4 * (unsigned __int8)byte_100E4870[a1] + 2);
}
// 101A5AB0: using guessed type int dword_101A5AB0;

//----- (100028C0) --------------------------------------------------------
char __cdecl sub_100028C0(int (__cdecl *a1)(int))
{
  signed int v1; // esi@1

  v1 = sub_10011D00(a1);
  if ( v1 == -1 )
    sub_10003E50(".\\cdp_page_list.c", 705, 1, 0);
  return byte_1005607C[56 * v1];
}

//----- (10002900) --------------------------------------------------------
char __cdecl sub_10002900(int (__cdecl *a1)(int))
{
  return *(_BYTE *)(dword_101A5AB0 + 4 * (unsigned __int8)byte_100E4870[(unsigned __int8)sub_100028C0(a1)] + 1);
}
// 101A5AB0: using guessed type int dword_101A5AB0;

//----- (10002920) --------------------------------------------------------
char __cdecl sub_10002920(int a1, __int16 *a2, _BYTE *a3)
{
  int v3; // esi@1
  _BYTE *v4; // ecx@1
  _BYTE *v5; // edx@1
  char *v6; // eax@2
  char v7; // cl@3

  v3 = 56 * sub_10011D00(*(int (__cdecl **)(int))(a1 + 8));
  *a2 = sub_100028A0(byte_1005607C[v3]);
  v4 = *(_BYTE **)(a1 + 252);
  v5 = a3;
  if ( v4 )
  {
    do
    {
      LOBYTE(v6) = *v4;
      *v5++ = *v4++;
    }
    while ( (_BYTE)v6 );
  }
  else
  {
    v6 = &aVloc[v3];
    do
    {
      v7 = *v6;
      v6[a3 - &aVloc[v3]] = *v6;
      ++v6;
    }
    while ( v7 );
  }
  return (unsigned int)v6;
}

//----- (100029A0) --------------------------------------------------------
char __usercall sub_100029A0@<al>(int a1@<ecx>, int a2@<edi>, unsigned int a3)
{
  signed int v3; // eax@1
  signed int v4; // esi@3
  char *v5; // edi@3
  int v6; // eax@4
  signed int v7; // eax@8
  char *v8; // esi@8
  int v9; // ecx@9
  signed int v10; // edi@13
  int (__cdecl **v11)(int); // ebp@13
  int v12; // ST0C_4@15
  int v14; // [sp-Eh] [bp-10h]@3
  int v15; // [sp-2h] [bp-4h]@1

  v15 = a1;
  dword_101A5AB0 = (int)byte_1005606C;
  dword_100E4878 = 0;
  BYTE3(v15) = 0;
  byte_100E4872 = 1;
  v3 = 0;
  do
  {
    byte_100E4870[(unsigned __int8)byte_1005606C[4 * v3]] = v3;
    ++v3;
  }
  while ( v3 <= 1 );
  v4 = 0;
  v14 = a2;
  v5 = byte_1005607C;
  memset(&unk_100E4888, 1, 2u);
  do
  {
    LOBYTE(v6) = *v5;
    if ( (unsigned __int8)*v5 < 1u )
    {
      v6 = (unsigned __int8)v6;
      if ( !*((_BYTE *)&v15 + (unsigned __int8)v6 + 3) )
      {
        word_100E4874[v6] = v4;
        *((_BYTE *)&v15 + (unsigned __int8)v6 + 3) = 1;
      }
    }
    ++v4;
    v5 += 56;
  }
  while ( v4 < 2 );
  dword_100E487C = (int)*(&off_10056078 + 14 * (unsigned __int16)word_100E4874[0]);
  v7 = 1;
  BYTE3(v15) = 0;
  v8 = &byte_1005607C[56];
  do
  {
    LOBYTE(v9) = *v8;
    if ( (unsigned __int8)*v8 < 1u )
    {
      v9 = (unsigned __int8)v9;
      if ( !*((_BYTE *)&v15 + (unsigned __int8)v9 + 3) )
      {
        word_100E4880[v9] = v7;
        *((_BYTE *)&v15 + (unsigned __int8)v9 + 3) = 1;
      }
    }
    --v7;
    v8 -= 56;
  }
  while ( v7 >= 0 );
  sub_100038E0();
  sub_10002B00(a3);
  sub_10003780(a3);
  v10 = 0;
  v11 = &off_10056078;
  do
  {
    (*v11)(a3);
    ++v10;
    v11 += 14;
  }
  while ( v10 < 2 );
  nullsub_1(a3, v14);
  nullsub_1(a3, v12);
  return sub_10002440(0, *(_DWORD *)(a3 + 56));
}
// 100029A0: could not find valid save-restore pair for edi
// 10056078: using guessed type int (__cdecl *off_10056078)(int);
// 100E4872: using guessed type char byte_100E4872;
// 100E4874: using guessed type __int16 word_100E4874[];
// 100E4878: using guessed type int dword_100E4878;
// 100E487C: using guessed type int dword_100E487C;
// 100E4880: using guessed type __int16 word_100E4880[];
// 101A5AB0: using guessed type int dword_101A5AB0;

//----- (10002B00) --------------------------------------------------------
_WORD *__cdecl sub_10002B00(int a1)
{
  void *v1; // eax@1

  v1 = (void *)sub_100027E0(a1, 332);
  *(_DWORD *)(a1 + 56) = v1;
  qmemcpy(v1, &unk_10052440, 0x14Cu);
  sub_100015C0(a1, *(char **)(a1 + 56), 0, 0);
  **(_WORD **)(a1 + 52) = -32671;
  sub_100061D0(a1 + 392, (int)&off_100555BC, 0);
  *(_WORD *)(a1 + 428) = 0;
  *(_WORD *)(a1 + 430) = 0;
  return sub_10006170(a1 + 392);
}
// 100555BC: using guessed type void *off_100555BC;

//----- (10002B70) --------------------------------------------------------
int __usercall sub_10002B70@<eax>(int a1@<esi>)
{
  int result; // eax@1

  result = sub_10011F30(
             a1,
             *(_WORD **)(a1 + 52),
             (char *)&unk_10053CF4,
             *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 4,
             *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12),
             255);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10002BA0) --------------------------------------------------------
char __usercall sub_10002BA0@<al>(int a1@<edi>)
{
  int v1; // esi@1
  double v2; // st7@1
  char result; // al@1

  v1 = sub_100015C0(a1, *(char **)(a1 + 56), 632, 0);
  sub_100011B0(a1, 0, 0, 264, 56, 3);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  sub_10001770(a1, *(_DWORD *)(a1 + 56), 100);
  *(_DWORD *)(v1 + 4) = v1 + 20;
  *(_BYTE *)v1 = 3;
  sub_1000DD20(v1 + 20, (int)"Power", dword_101D8250 + 4240, 112.0, 38.0, 60.0, 25.0);
  sub_1000DA30(dword_101D8250 + 20536, v1 + 20);
  *(float *)(v1 + 348) = 18.0;
  *(float *)(v1 + 88) = 18.0;
  *(float *)(v1 + 244) = 15.0;
  v2 = *(float *)(v1 + 48);
  *(_WORD *)(v1 + 536) = 8;
  *(float *)(v1 + 48) = v2 - 63.0;
  *(float *)(v1 + 196) = *(float *)(v1 + 196) + 20.0;
  sub_10011B50(v1 + 316, &unk_10053684, 21);
  *(float *)(v1 + 8) = 0.0099999998;
  *(float *)(v1 + 12) = 9.8999998e24;
  *(float *)(v1 + 16) = 9.8999998e24;
  sub_1000D9F0(v1 + 8, 1, v1 + 20);
  result = sub_10001DF0(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 101D8250: using guessed type int dword_101D8250;

//----- (10002CD0) --------------------------------------------------------
int __usercall sub_10002CD0@<eax>(int a1@<esi>)
{
  int v1; // edi@1
  int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_1000FCB0((float *)(v1 + 12));
  sub_1000FC50(v1 + 8, 1u);
  sub_10011F30(a1, *(_WORD **)(a1 + 52), (char *)&unk_10053C40, (int)&unk_10053D00, 0, 255);
  result = sub_10011F30(a1, *(_WORD **)(a1 + 52), (char *)&unk_10053CF4, v1 + 4, v1, 255);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10002D30) --------------------------------------------------------
char __cdecl sub_10002D30(int a1)
{
  int v1; // eax@1

  v1 = **(_WORD **)(a1 + 52);
  switch ( v1 )
  {
    case 32789:
    case 32790:
      LOBYTE(v1) = sub_10002B70(a1);
      break;
    case 32833:
      LOBYTE(v1) = sub_10002BA0(a1);
      break;
    case 32802:
    case 32888:
      LOBYTE(v1) = sub_10002CD0(a1);
      break;
    default:
      return v1;
  }
  return v1;
}

//----- (10002DE0) --------------------------------------------------------
char __usercall sub_10002DE0@<al>(int a1@<esi>)
{
  _WORD *v1; // eax@1
  int v2; // edx@1
  char result; // al@1
  void *v4; // ecx@1
  char v5; // [sp+0h] [bp-8h]@1
  int v6; // [sp+4h] [bp-4h]@1

  v1 = *(_WORD **)(a1 + 52);
  v2 = *(_DWORD *)(a1 + 56);
  v6 = 0;
  **(_BYTE **)(v2 + 12) = *v1 == -32747;
  result = sub_10004330(9129, &v5, 2, &v6);
  if ( v5 & 8 )
  {
    result = sub_10011500(v4);
    if ( result != 2 )
      result = sub_10001DF0(a1, *(_DWORD *)(a1 + 56), -32648);
  }
  return result;
}

//----- (10002E40) --------------------------------------------------------
char __usercall sub_10002E40@<al>(int a1@<esi>)
{
  char result; // al@1

  result = sub_10001DF0(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10002E60) --------------------------------------------------------
char __usercall sub_10002E60@<al>(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // edi@1
  int v3; // ecx@2
  char v4; // al@6
  void *v5; // ecx@6
  bool v6; // zf@10
  char v7; // al@14
  char v8; // al@26
  int v9; // ecx@28

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 12);
  if ( *(_BYTE *)(a1 + 6) != 1 )
    return v1;
  v3 = *(_DWORD *)(a1 + 52);
  v1 = *(_WORD *)(v3 + 10);
  if ( v1 > 59 )
  {
    if ( v1 > 82 )
    {
      if ( v1 != 0x2000 )
        return v1;
    }
    else if ( v1 != 82 && (v1 < 61 || v1 > 62 && v1 != 73) )
    {
      return v1;
    }
LABEL_25:
    if ( *(_BYTE *)(v2 + 82) )
      v8 = sub_10010AB0(a1, v3, (char *)&unk_100542E8, v2 + 72);
    else
      v8 = sub_10010AB0(a1, v3, (char *)&unk_10054300, v2 + 120);
    v9 = *(_DWORD *)(a1 + 52);
    *(_BYTE *)(a1 + 6) = v1;
    LOWORD(v1) = *(_WORD *)(v9 + 10);
    if ( (_WORD)v1 == 27 || (_WORD)v1 == 82 )
    {
      if ( *(_BYTE *)(v2 + 82) )
      {
        v1 = sub_10003FF0();
        *(_DWORD *)(v2 + 68) = v1;
        *(_DWORD *)(v2 + 52) = 0;
        *(_BYTE *)(a1 + 6) = 2;
        return v1;
      }
      v1 = sub_10003FF0();
      *(_DWORD *)(v2 + 116) = v1;
      *(_DWORD *)(v2 + 100) = 0;
    }
LABEL_33:
    *(_BYTE *)(a1 + 6) = 2;
    return v1;
  }
  if ( v1 == 59 )
    goto LABEL_25;
  switch ( v1 )
  {
    case 34:
      if ( *(_BYTE *)(v2 + 82) )
        v4 = sub_10010AB0(a1, v3, (char *)&unk_100542E8, v2 + 72);
      else
        v4 = sub_10010AB0(a1, v3, (char *)&unk_10054300, v2 + 120);
      *(_BYTE *)(a1 + 6) = v4;
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 52) + 16) == 1 )
      {
        LOBYTE(v1) = sub_10010E80(v5);
        if ( (_BYTE)v1 != 1 )
          goto LABEL_33;
      }
      v6 = *(_BYTE *)(v2 + 130) == 0;
      *(_BYTE *)(v2 + 82) = *(_BYTE *)(v2 + 82) == 0;
      *(_BYTE *)(v2 + 130) = v6;
      LOBYTE(v1) = sub_1000FD90(v6);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 56:
    case 57:
      if ( *(_BYTE *)(v3 + 16) != 1 )
        goto LABEL_33;
      if ( !*(_BYTE *)(v2 + 41) )
        goto LABEL_33;
      if ( *(_BYTE *)(v2 + 40) != 1 )
        goto LABEL_33;
      v7 = sub_10011500((void *)v3);
      LOBYTE(v1) = sub_10014530(v7, 6);
      if ( !(_BYTE)v1 )
        goto LABEL_33;
      *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) += 5;
      if ( *(_BYTE *)(v2 + 82) )
      {
        LOBYTE(v1) = sub_10010AB0(a1, *(_DWORD *)(a1 + 52), (char *)&unk_100542E8, v2 + 72);
        *(_BYTE *)(a1 + 6) = v1;
        *(_BYTE *)(a1 + 6) = 2;
      }
      else
      {
        LOBYTE(v1) = sub_10010AB0(a1, *(_DWORD *)(a1 + 52), (char *)&unk_10054300, v2 + 120);
        *(_BYTE *)(a1 + 6) = v1;
        *(_BYTE *)(a1 + 6) = 2;
      }
      break;
    case 27:
    case 32:
    case 33:
    case 41:
      goto LABEL_25;
    default:
      return v1;
  }
  return v1;
}

//----- (10003050) --------------------------------------------------------
char __usercall sub_10003050@<al>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // esi@1
  void *v3; // ecx@1
  unsigned int v4; // eax@2
  int v6; // [sp+8h] [bp-8h]@1
  int v7; // [sp+Ch] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 56);
  v7 = 0;
  v2 = *(_DWORD *)(v1 + 12);
  v6 = 0;
  *(_WORD *)(v2 + 28) = 6543;
  *(_WORD *)(v2 + 26) = 59;
  *(_WORD *)(v2 + 24) = 266;
  *(_WORD *)(v2 + 32) = -2;
  *(_WORD *)(v2 + 34) = -2;
  sub_10004330(9129, &v6, 2, &v7);
  if ( v6 & 8 && (LOBYTE(v4) = sub_10011500(v3), (_BYTE)v4 != 2) )
  {
    if ( !*(_BYTE *)(v2 + 41) )
    {
      v4 = sub_10003FF0();
      *(_DWORD *)(v2 + 4) = v4;
      *(_BYTE *)(v2 + 41) = 1;
    }
    if ( *(_BYTE *)v2 || (v4 = sub_10003FF0() - *(_DWORD *)(v2 + 4), v4 >= 0x1388) )
    {
      *(_WORD *)(v2 + 32) = 0;
      *(_WORD *)(v2 + 34) = 0;
      *(_WORD *)(v2 + 28) = 10630;
      *(_WORD *)(v2 + 26) = 56;
      *(_WORD *)(v2 + 24) = 264;
    }
  }
  else
  {
    *(_BYTE *)(v2 + 41) = 0;
    v4 = *(_DWORD *)(a1 + 56);
    if ( *(_WORD *)(v4 + 240) != -128 )
      *(_WORD *)(v4 + 240) = -128;
  }
  return v4;
}

//----- (10003160) --------------------------------------------------------
char __usercall sub_10003160@<al>(int a1@<esi>)
{
  int v1; // ecx@1
  int v2; // eax@1
  int v3; // ST08_4@4
  int v4; // ST08_4@7

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
  if ( *(_BYTE *)(v1 + 82) )
  {
    if ( v2 != *(_DWORD *)(v1 + 72) && v2 != 0xFFFF )
    {
      v3 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
      *(_DWORD *)(v1 + 76) = v2;
      sub_100147B0(3, 0, v3);
    }
  }
  else if ( v2 != *(_DWORD *)(v1 + 120) && v2 != 0xFFFF )
  {
    v4 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
    *(_DWORD *)(v1 + 124) = v2;
    sub_100147B0(4, 0, v4);
  }
  return sub_10001DF0(a1, *(_DWORD *)(a1 + 56), -32648);
}

//----- (100031C0) --------------------------------------------------------
int __cdecl sub_100031C0(int a1)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // ecx@1
  unsigned int v4; // ecx@4
  int v5; // edi@19
  int v6; // ebp@19
  int result; // eax@19
  int v8; // ecx@19
  char v9; // [sp+12h] [bp-2h]@1
  char v10; // [sp+13h] [bp-1h]@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v9 = 0;
  v10 = 0;
  v2 = sub_10003FF0();
  v3 = *(_DWORD *)(v1 + 84);
  if ( v3 && (unsigned int)(v2 - v3) > 0x3E8 )
    *(_DWORD *)(v1 + 84) = 0;
  v4 = *(_DWORD *)(v1 + 132);
  if ( v4 > 0 && v2 - v4 > 0x3E8 )
    *(_DWORD *)(v1 + 132) = 0;
  if ( *(_DWORD *)(v1 + 84) )
    v9 = 1;
  else
    *(_BYTE *)(v1 + 83) = sub_10014BF0(3, (_DWORD *)(v1 + 72));
  if ( *(_DWORD *)(v1 + 132) )
    v10 = 1;
  else
    *(_BYTE *)(v1 + 131) = sub_10014BF0(4, (_DWORD *)(v1 + 120));
  if ( *(_BYTE *)(v1 + 83) != 1 || v9 == 1 )
    *(_DWORD *)(v1 + 72) = sub_100145F0(3, 1);
  if ( *(_BYTE *)(v1 + 131) != 1 || v10 == 1 )
    *(_DWORD *)(v1 + 120) = sub_100145F0(4, 1);
  v5 = *(_DWORD *)(v1 + 76);
  v6 = *(_DWORD *)(v1 + 124);
  *(_DWORD *)(v1 + 76) = sub_100145F0(3, 0);
  result = sub_100145F0(4, 0);
  *(_DWORD *)(v1 + 124) = result;
  v8 = *(_DWORD *)(a1 + 56);
  if ( *(_WORD *)(v8 + 240) != -128
    && (*(_BYTE *)(v1 + 82) && v5 != *(_DWORD *)(v1 + 76) || *(_BYTE *)(v1 + 130) && v6 != result) )
  {
    *(_WORD *)(v8 + 240) = -128;
  }
  return result;
}

//----- (100032F0) --------------------------------------------------------
char __usercall sub_100032F0@<al>(int a1@<ebx>)
{
  int v1; // eax@1
  int v2; // edx@1
  int v3; // ebp@1
  int v4; // ST54_4@1
  _BYTE *v5; // esi@1
  _BYTE *v6; // edi@1
  bool v7; // zf@1
  char result; // al@6

  v1 = sub_100015C0(a1, *(char **)(a1 + 56), 148, 2);
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60);
  v3 = v1;
  qmemcpy((void *)(v1 + 8), &unk_10054330, 0x20u);
  v4 = v2;
  byte_100E491F = 1;
  byte_100E491E = 0;
  sub_100011B0(a1, 0, 0, 264, 56, 1);
  sub_10010A50(*(_DWORD *)(a1 + 56), (char *)&unk_100542E8);
  *(_BYTE *)v3 = 0;
  *(_DWORD *)(v3 + 4) = 0;
  *(_BYTE *)(v3 + 41) = 0;
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = 0;
  sub_10004A40(93, (_BYTE *)(v3 + 40));
  *(_BYTE *)(v3 + 81) = 1;
  *(_BYTE *)(v3 + 82) = 1;
  *(_DWORD *)(v3 + 84) = 0;
  *(_BYTE *)(v3 + 129) = 0;
  *(_BYTE *)(v3 + 130) = 0;
  *(_DWORD *)(v3 + 132) = 0;
  *(_DWORD *)(v3 + 68) = 0;
  *(_DWORD *)(v3 + 116) = 0;
  sub_100031C0(a1);
  *(_DWORD *)(v3 + 56) = v3 + 60;
  *(_DWORD *)(v3 + 104) = v3 + 108;
  *(_DWORD *)v4 = v3 + 72;
  *(_DWORD *)(v4 + 4) = v3 + 120;
  v5 = (_BYTE *)(v3 + 44);
  v6 = (_BYTE *)(v3 + 92);
  *(_DWORD *)(v3 + 140) = v3 + 44;
  *(_DWORD *)(v3 + 144) = v3 + 92;
  sub_10004A40(71, &byte_100E491E);
  sub_10004A40(74, &byte_100E491F);
  v7 = byte_100E491F == 0;
  *(_BYTE *)(v3 + 45) = 0;
  *(_BYTE *)(v3 + 93) = 0;
  if ( !v7 )
    goto LABEL_5;
  if ( byte_100E491E != 1 )
  {
    *(_WORD *)(v3 + 46) = 250;
LABEL_5:
    *v6 = 0;
    *v5 = 0;
    goto LABEL_6;
  }
  *v5 = 1;
  *v6 = 1;
  *(_WORD *)(v3 + 46) = 206;
  *(_WORD *)(v3 + 48) = 23;
  *(_WORD *)(v3 + 94) = 206;
  *(_WORD *)(v3 + 96) = 49;
LABEL_6:
  *(_DWORD *)(v3 + 52) = &unk_10054364;
  *(_DWORD *)(v3 + 100) = &unk_10054364;
  sub_1000E660(
    a1,
    *(_WORD **)(a1 + 52),
    *(char ***)(*(_DWORD *)(a1 + 56) + 56),
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  sub_1000E780(a1, *(_WORD **)(a1 + 52), (char *)&unk_1005431C, v3 + 140, 0, 255);
  sub_10001770(a1, *(_DWORD *)(a1 + 56), 500);
  result = sub_10001DF0(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 100E491E: using guessed type char byte_100E491E;
// 100E491F: using guessed type char byte_100E491F;

//----- (100034B0) --------------------------------------------------------
bool __thiscall sub_100034B0(int this)
{
  int v1; // edi@1
  int v2; // esi@1
  int v3; // ebp@1
  void *v4; // ecx@1
  unsigned int v5; // eax@6
  bool v6; // zf@9
  unsigned int v7; // eax@11
  int v8; // eax@19
  bool result; // al@22
  char v10; // [sp+13h] [bp-55h]@1
  char v11; // [sp+14h] [bp-54h]@10
  void *v12; // [sp+5Bh] [bp-Dh]@10
  __int16 v13; // [sp+5Fh] [bp-9h]@10
  char v14; // [sp+61h] [bp-7h]@10

  v1 = this;
  v2 = *(_DWORD *)(*(_DWORD *)(this + 56) + 12);
  v10 = *(_BYTE *)(v2 + 130);
  v3 = sub_10003FF0();
  sub_100031C0(v1);
  sub_10003050(v1);
  if ( *(_BYTE *)(v2 + 80) )
  {
    *(_DWORD *)(v2 + 52) = &unk_10054358;
    *(_DWORD *)(v2 + 100) = &unk_10054364;
  }
  else if ( *(_BYTE *)(v2 + 128) )
  {
    *(_DWORD *)(v2 + 52) = &unk_10054364;
    *(_DWORD *)(v2 + 100) = &unk_10054358;
  }
  else
  {
    *(_DWORD *)(v2 + 52) = &unk_10054364;
    *(_DWORD *)(v2 + 100) = &unk_10054364;
  }
  v5 = *(_DWORD *)(v2 + 68);
  if ( v5 > 0 && v3 - v5 > 0x28A )
    *(_DWORD *)(v2 + 68) = 0;
  v6 = *(_DWORD *)(v2 + 68) == 0;
  *(_BYTE *)(v2 + 60) = 0;
  if ( v6 )
  {
    sub_10014C80(3, (int)&v11);
    v4 = v12;
    *(_DWORD *)(v2 + 60) = v12;
    *(_WORD *)(v2 + 64) = v13;
    *(_BYTE *)(v2 + 66) = v14;
  }
  v7 = *(_DWORD *)(v2 + 116);
  if ( v7 > 0 && v3 - v7 > 0x28A )
    *(_DWORD *)(v2 + 116) = 0;
  v6 = *(_DWORD *)(v2 + 116) == 0;
  *(_BYTE *)(v2 + 108) = 0;
  if ( v6 )
  {
    sub_10014C80(4, (int)&v11);
    *(_DWORD *)(v2 + 108) = v12;
    *(_WORD *)(v2 + 112) = v13;
    LOBYTE(v4) = v14;
    *(_BYTE *)(v2 + 114) = v14;
  }
  if ( sub_1000FD40(v4) )
  {
    *(_BYTE *)(v2 + 82) = 0;
    *(_BYTE *)(v2 + 130) = 1;
  }
  else
  {
    *(_BYTE *)(v2 + 82) = 1;
    *(_BYTE *)(v2 + 130) = 0;
  }
  v8 = *(_DWORD *)(v1 + 56);
  if ( *(_WORD *)(v8 + 240) != -128 && v10 != *(_BYTE *)(v2 + 130) )
    *(_WORD *)(v8 + 240) = -128;
  sub_1000E780(v1, *(_WORD **)(v1 + 52), (char *)(v2 + 8), (int)&unk_10054350, 0, 255);
  sub_1000E780(
    v1,
    *(_WORD **)(v1 + 52),
    (char *)&unk_100542E8,
    *(_DWORD *)(*(_DWORD *)(v1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230));
  result = sub_1000E780(v1, *(_WORD **)(v1 + 52), (char *)&unk_1005431C, v2 + 140, 0, 255);
  *(_BYTE *)(v1 + 6) = 2;
  return result;
}

//----- (10003660) --------------------------------------------------------
char __cdecl sub_10003660(int a1)
{
  int v1; // edx@9
  int v2; // ecx@9
  int v3; // eax@1

  v3 = **(_WORD **)(a1 + 52);
  switch ( v3 )
  {
    case 32789:
    case 32790:
      LOBYTE(v3) = sub_10002DE0(a1);
      break;
    default:
      return v3;
    case 32802:
      LOBYTE(v3) = sub_10002E40(a1);
      break;
    case 32833:
      LOBYTE(v3) = sub_100032F0(a1);
      break;
    case 32840:
      LOBYTE(v3) = sub_10002E60(a1);
      break;
    case 32869:
      v1 = *(_DWORD *)(a1 + 52);
      v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
      if ( *(_BYTE *)(v1 + 8) == 3 )
      {
        *(_BYTE *)(v2 + 82) = 1;
        *(_BYTE *)(v2 + 130) = 0;
        LOBYTE(v3) = sub_1000FD90(0);
      }
      else
      {
        LOBYTE(v3) = *(_BYTE *)(v1 + 8) - 4;
        if ( *(_BYTE *)(v1 + 8) == 4 )
        {
          *(_BYTE *)(v2 + 82) = 0;
          *(_BYTE *)(v2 + 130) = 1;
          LOBYTE(v3) = sub_1000FD90(1);
        }
      }
      break;
    case 32876:
      LOBYTE(v3) = sub_10003160(a1);
      break;
    case 32888:
      LOBYTE(v3) = sub_100034B0(a1);
      break;
  }
  return v3;
}

//----- (10003750) --------------------------------------------------------
char __cdecl sub_10003750(char a1)
{
  return sub_10006310(a1, -122);
}

//----- (10003770) --------------------------------------------------------
char sub_10003770()
{
  sub_100062C0();
  return sub_10003750(0);
}

//----- (10003780) --------------------------------------------------------
void __cdecl sub_10003780(unsigned int a1)
{
  __int16 v1; // di@1
  void *v2; // ecx@1
  char v3; // bl@1
  int v4; // ecx@2
  char (__cdecl *v5)(int); // eax@9

  v1 = j_HWM_pvg_read_reg(0);
  v3 = sub_10011170(v2);
  if ( **(_WORD **)(a1 + 52) == -32648 )
  {
    v4 = *(_DWORD *)(a1 + 48);
    if ( *(char (__cdecl **)(int))(v4 + 8) != sub_10002D30
      && v3 != 1
      && sub_10011020()
      && (v1 == 131 || v1 == 19)
      && sub_10015220((void *)v4) == 1 )
    {
      sub_1000FC30(a1, -1, (int (__cdecl *)(int))sub_10002D30, 0);
    }
    else
    {
      v5 = *(char (__cdecl **)(int))(*(_DWORD *)(a1 + 48) + 8);
      if ( v5 != sub_10003660 && (v3 == 1 || v5 != sub_10003660 && v3 == 2 && sub_10015220((void *)v4) == 4) )
        sub_1000FC30(a1, -1, (int (__cdecl *)(int))sub_10003660, 0);
    }
  }
}
// 10004AC0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10003840) --------------------------------------------------------
char sub_10003840()
{
  return 0;
}

//----- (10003850) --------------------------------------------------------
char __usercall sub_10003850@<al>(int a1@<edi>, unsigned int a2)
{
  int v2; // ecx@1
  char result; // al@1

  sub_10002B00(a2);
  result = sub_100029A0(v2, a1, a2);
  dword_101D8148 = 0;
  return result;
}
// 101D8148: using guessed type int dword_101D8148;

//----- (10003870) --------------------------------------------------------
char __cdecl sub_10003870(int a1)
{
  int v1; // eax@1
  bool v2; // zf@1
  __int16 v4; // [sp+4h] [bp-D0h]@1
  int v5; // [sp+8h] [bp-CCh]@1

  v1 = sub_10001550(a1, (int)sub_10003660);
  v2 = **(_WORD **)(a1 + 52) == -32749;
  v5 = v1;
  v4 = !v2 - 32747;
  return sub_100016C0(a1, (int)&v4, 204);
}

//----- (100038E0) --------------------------------------------------------
char sub_100038E0()
{
  char result; // al@1

  result = 0;
  byte_101A5AB4 = 0;
  byte_101A5AB5 = 0;
  return result;
}
// 101A5AB4: using guessed type char byte_101A5AB4;
// 101A5AB5: using guessed type char byte_101A5AB5;

//----- (100038F0) --------------------------------------------------------
void __cdecl sub_100038F0(unsigned int a1)
{
  __int16 v1; // si@1
  void *v2; // ecx@1
  void *v3; // ecx@2
  bool v4; // zf@5
  int (__cdecl *v5)(int); // eax@5

  v1 = j_HWM_pvg_read_reg(0);
  if ( sub_10011170(v2) == 1
    || !sub_10011020()
    || v1 != 131 && v1 != 19
    || (v4 = sub_10015220(v3) == 1, v5 = (int (__cdecl *)(int))sub_10002D30, !v4) )
  {
    v5 = (int (__cdecl *)(int))sub_10003660;
  }
  sub_1000FC30(a1, -1, v5, 0);
}
// 10004AC0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10003960) --------------------------------------------------------
#error "10003979: call analysis failed (funcsize=28)"

//----- (100039F0) --------------------------------------------------------
int __cdecl sub_100039F0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_bitblt(&v8, a2, a3, a7, a1, a4, a5, a6);
}
// 1003CBFC: using guessed type int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10003A70) --------------------------------------------------------
int __cdecl sub_10003A70(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_draw_pixels(&v8, a5, a4, a7, a6, a3, a1, a2);
}
// 1003CC14: using guessed type int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10003AF0) --------------------------------------------------------
int sub_10003AF0()
{
  gdi_pvg_init();
  return sub_10003F00();
}
// 1003CC2C: using guessed type int gdi_pvg_init(void);

//----- (10003B00) --------------------------------------------------------
int __cdecl sub_10003B00(float a1)
{
  return gdi_pvg_line_width(LODWORD(a1));
}
// 1003CC32: using guessed type int __cdecl gdi_pvg_line_width(_DWORD);

//----- (10003B50) --------------------------------------------------------
int __cdecl sub_10003B50(float a1, float a2, float a3, float a4, float a5, float a6)
{
  float v7; // [sp+0h] [bp-18h]@1

  return gdi_pvg_ortho(&v7, LODWORD(a4), LODWORD(a6), LODWORD(a1), LODWORD(a5), LODWORD(a2), LODWORD(a3));
}
// 1003CC50: using guessed type int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10003BE0) --------------------------------------------------------
int __cdecl sub_10003BE0(float a1, float a2)
{
  return gdi_pvg_vertex2f(LODWORD(a1), LODWORD(a2));
}
// 1003CC74: using guessed type int __cdecl gdi_pvg_vertex2f(_DWORD, _DWORD);

//----- (10003C10) --------------------------------------------------------
char *__cdecl sub_10003C10(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_10003F80();
  *(_DWORD *)(a5 + 596) = sub_10003FF0();
  sub_10004010((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_10011B50(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_10016310((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (10003D40) --------------------------------------------------------
char sub_10003D40()
{
  char result; // al@1

  result = 0;
  byte_100F07C0 = 0;
  byte_100F07C1 = 0;
  return result;
}
// 100F07C0: using guessed type char byte_100F07C0;
// 100F07C1: using guessed type char byte_100F07C1;

//----- (10003D50) --------------------------------------------------------
char __cdecl sub_10003D50(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_10003C10(-5, a1, a2, a4, a5);
  else
    sub_10003C10(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_10011CA0((const char *)(a5 + 485), " DBGA", 100);
  sub_10004010((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_100F07C0 )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_100F07C1 )
LABEL_15:
      result = sub_10004050(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 10004AB0: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 100F07C0: using guessed type char byte_100F07C0;
// 100F07C1: using guessed type char byte_100F07C1;

//----- (10003E50) --------------------------------------------------------
char __cdecl sub_10003E50(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_10003D50(a1, a2, a3, a4, (int)&v5);
}

//----- (10003EC0) --------------------------------------------------------
int __cdecl sub_10003EC0(int a1, int a2, int a3)
{
  dword_100F07D8 = a1;
  dword_100F07CC = a2;
  dword_100F07D0 = a3;
  return gdi_pvg_create_window(&dword_100F07C4);
}
// 1003CC80: using guessed type int __cdecl gdi_pvg_create_window(_DWORD);
// 100F07C4: using guessed type int dword_100F07C4;
// 100F07CC: using guessed type int dword_100F07CC;
// 100F07D0: using guessed type int dword_100F07D0;
// 100F07D8: using guessed type int dword_100F07D8;

//----- (10003F00) --------------------------------------------------------
int sub_10003F00()
{
  int result; // eax@1

  result = 0;
  dword_100F07D8 = 0;
  dword_100F07CC = 0;
  dword_100F07D0 = 59;
  dword_100F07C4 = 1;
  dword_100F07C8 = 0;
  dword_100F07D4 = 0;
  return result;
}
// 100F07C4: using guessed type int dword_100F07C4;
// 100F07C8: using guessed type int dword_100F07C8;
// 100F07CC: using guessed type int dword_100F07CC;
// 100F07D0: using guessed type int dword_100F07D0;
// 100F07D4: using guessed type int dword_100F07D4;
// 100F07D8: using guessed type int dword_100F07D8;

//----- (10003F50) --------------------------------------------------------
int __cdecl sub_10003F50(int a1)
{
  int result; // eax@1

  result = a1;
  dword_100F07C4 = a1;
  return result;
}
// 100F07C4: using guessed type int dword_100F07C4;

//----- (10003F60) --------------------------------------------------------
int __cdecl sub_10003F60(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CC98: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (10003F80) --------------------------------------------------------
int sub_10003F80()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CC9E: using guessed type int TSK_pvg_get_id(void);

//----- (10003FA0) --------------------------------------------------------
int __cdecl sub_10003FA0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CCA4: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (10003FD0) --------------------------------------------------------
__int16 __cdecl sub_10003FD0(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CCAA: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (10003FF0) --------------------------------------------------------
int sub_10003FF0()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CCB0: using guessed type int TSK_pvg_get_timer(void);

//----- (10004010) --------------------------------------------------------
int __cdecl sub_10004010(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CCB6: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004050) --------------------------------------------------------
int __cdecl sub_10004050(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CCC2: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004080) --------------------------------------------------------
int __cdecl sub_10004080(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_proc_status(a1);
  SYS_exit_krnl();
  return v1;
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CCC8: using guessed type int __cdecl TSK_pvg_proc_status(_DWORD);

//----- (100040A0) --------------------------------------------------------
int __cdecl sub_100040A0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CCCE: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (100040C0) --------------------------------------------------------
int __cdecl sub_100040C0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CCD4: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (100040F0) --------------------------------------------------------
int __cdecl sub_100040F0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_send_msg(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CCDA: using guessed type int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004120) --------------------------------------------------------
int __cdecl sub_10004120(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CCE0: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (10004150) --------------------------------------------------------
int __cdecl sub_10004150(int a1)
{
  SYS_enter_krnl();
  TSK_pvg_set_proc_status(a1);
  return SYS_exit_krnl();
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CCE6: using guessed type int __cdecl TSK_pvg_set_proc_status(_DWORD);

//----- (10004170) --------------------------------------------------------
int __cdecl sub_10004170(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CCEC: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (10004190) --------------------------------------------------------
char __cdecl sub_10004190(int a1, int a2)
{
  unsigned int v2; // esi@1
  char result; // al@4

  v2 = a2 + sub_10003FF0();
  if ( sub_10004080(a1) == 5 )
    goto LABEL_4;
  while ( sub_10003FF0() < v2 )
  {
    sub_10004170(20);
    if ( sub_10004080(a1) == 5 )
      goto LABEL_4;
  }
  if ( sub_10004080(a1) == 5 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    sub_10003E50("..\\lib\\acl\\tsk\\tsk_usr.c", 1769, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10004200) --------------------------------------------------------
int __cdecl sub_10004200(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_10003F80();
    sub_10004010((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CCF2: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (10004240) --------------------------------------------------------
int __cdecl sub_10004240(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_100040A0(a2);
  return result;
}
// 10057750: using guessed type void *tsk_app_hdr_ptr;

//----- (10004270) --------------------------------------------------------
int __cdecl sub_10004270(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_100040C0(a1, a2);
  return result;
}
// 10057750: using guessed type void *tsk_app_hdr_ptr;

//----- (10004290) --------------------------------------------------------
int __cdecl sub_10004290(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = 0;
  result = 42066;
  while ( dword_1005A988[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xA5 )
      return result;
  }
  return dword_1005A98C[2 * v1];
}
// 1005A988: using guessed type int dword_1005A988[];
// 1005A98C: using guessed type int dword_1005A98C[];

//----- (100042D0) --------------------------------------------------------
int __cdecl sub_100042D0(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 1003CCF8: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100042F0) --------------------------------------------------------
char __cdecl sub_100042F0(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_100042D0(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10003E50("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (10004330) --------------------------------------------------------
int __cdecl sub_10004330(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_100042D0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (10004370) --------------------------------------------------------
int __cdecl sub_10004370(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_100042D0(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (100043A0) --------------------------------------------------------
int __cdecl sub_100043A0(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 1003CCFE: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100043C0) --------------------------------------------------------
int __cdecl sub_100043C0(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@2
  int result; // eax@4
  int v6; // [sp+10h] [bp-4h]@1

  v6 = sub_100043A0(a1, a2, a3);
  v3 = 0;
  if ( (unsigned __int8)sub_10004AE0() )
  {
    v4 = sub_10004290(a1);
    if ( v4 != 42066 )
      v3 = sub_100043A0(v4, a2, a3);
  }
  result = v6;
  if ( !v6 )
    result = v3;
  return result;
}
// 10004AE0: using guessed type int sub_10004AE0(void);

//----- (10004420) --------------------------------------------------------
int __cdecl sub_10004420(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_100043C0(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    sub_10003E50("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1742, 1, 0);
    result = v4;
  }
  return result;
}

//----- (10004460) --------------------------------------------------------
char __cdecl sub_10004460(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_100043A0(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10003E50("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1826, 1, 0);
  return v3;
}

//----- (100044A0) --------------------------------------------------------
int __cdecl sub_100044A0(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_100042D0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    sub_100043A0(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (100044F0) --------------------------------------------------------
void sub_100044F0()
{
  dword_100F6060 = 0;
  dword_1010EE74 = -15;
}
// 100F6060: using guessed type int dword_100F6060;
// 1010EE74: using guessed type int dword_1010EE74;

//----- (10004500) --------------------------------------------------------
signed int __fastcall sub_10004500(char *a1)
{
  unsigned __int8 v1; // al@1
  char v2; // dl@1
  char v3; // bl@1
  signed int result; // eax@13

  v1 = *a1;
  v2 = 0;
  v3 = 0;
  if ( !*a1 )
    goto LABEL_17;
  do
  {
    if ( v1 < 0x30u || v1 > 0x39u )
    {
      if ( v1 >= 0x61u && v1 <= 0x7Au || v1 >= 0x41u && v1 <= 0x5Au )
        v2 = 1;
    }
    else
    {
      v3 = 1;
    }
    v1 = (a1++)[1];
  }
  while ( v1 );
  if ( v2 && v3 )
    result = 1;
  else
LABEL_17:
    result = 0;
  return result;
}

//----- (10004550) --------------------------------------------------------
int __usercall sub_10004550@<eax>(unsigned int a1@<eax>)
{
  return sub_10004B10(a1);
}

//----- (10004560) --------------------------------------------------------
double __cdecl sub_10004560(int a1, int a2, float a3, float a4, float a5)
{
  char *v5; // ebp@1
  int v6; // edi@1
  void *v7; // esi@1
  bool v8; // bl@3
  int v9; // eax@6
  int v10; // edi@6
  double v11; // st7@7
  char v12; // al@7
  double v13; // st7@8
  double v14; // st5@8
  int v15; // eax@13
  double v16; // st4@13
  double v17; // st3@13
  double v18; // rt2@13
  double v19; // st3@13
  bool v20; // zf@13
  float v22; // [sp+0h] [bp-8h]@7
  unsigned int v23; // [sp+4h] [bp-4h]@1

  v5 = (char *)a2;
  a4 = a4 + a5;
  v23 = strlen((const char *)a2);
  v6 = a1;
  v7 = &unk_100EB920;
  if ( a1 & 0xC0000000 )
  {
    if ( (a1 & 0xC0000000) == 0x80000000 )
      v8 = (unsigned __int8)sub_10004500((char *)a2) == 0;
    else
      v8 = 0;
  }
  else
  {
    v8 = 1;
  }
  v9 = sub_10004550(v6 & 0x3FFFFFFF);
  v10 = v9;
  if ( v9 )
  {
    v11 = a4;
    a4 = a4 - *(float *)(v9 + 8200) * a5;
    v22 = v11 + a5 * *(float *)(v9 + 8204);
    sub_100042D0(6610, (int)&a1, 1);
    v12 = *v5;
    if ( *v5 )
    {
      v13 = a4;
      v14 = a5;
      do
      {
        if ( (_BYTE)a1 && v8 && v12 == 48 )
          v12 = -122;
        v15 = v10 + 32 * (unsigned __int8)v12;
        ++v5;
        v7 = (char *)v7 + 64;
        a4 = *(float *)(v15 + 16) * v14;
        a3 = *(float *)(v15 + 24) + a3;
        *((float *)v7 - 14) = *(float *)v15;
        *((float *)v7 - 13) = *(float *)(v15 + 8);
        v16 = a3;
        *((float *)v7 - 16) = a3;
        *((float *)v7 - 15) = v13;
        *((float *)v7 - 10) = *(float *)(v15 + 4);
        *((float *)v7 - 9) = *(float *)(v15 + 8);
        a4 = a4 + v16;
        v17 = a4;
        *((float *)v7 - 12) = a4;
        v18 = v17;
        *((float *)v7 - 11) = v13;
        *((float *)v7 - 6) = *(float *)(v15 + 4);
        *((float *)v7 - 5) = *(float *)(v15 + 12);
        *((float *)v7 - 8) = v17;
        *((float *)v7 - 7) = v22;
        *((float *)v7 - 2) = *(float *)v15;
        *((float *)v7 - 1) = *(float *)(v15 + 12);
        *((float *)v7 - 4) = v16;
        *((float *)v7 - 3) = v22;
        v19 = *(float *)(v15 + 28);
        v12 = *v5;
        v20 = *v5 == 0;
        a3 = v18 + v19;
      }
      while ( !v20 );
    }
    j_gdi_pvg_text_out_verts(&unk_100EB920, v23, *(_DWORD *)(v10 + 8212));
  }
  return a3;
}
// 10003BC0: using guessed type int __cdecl j_gdi_pvg_text_out_verts(_DWORD, _DWORD, _DWORD);

//----- (10004700) --------------------------------------------------------
double __cdecl sub_10004700(int a1, int a2, float a3)
{
  int v3; // eax@1
  double result; // st7@1
  char *v5; // edx@2
  unsigned __int8 i; // cl@2
  int v7; // ecx@3
  float v8; // ST00_4@3
  float v9; // ST00_4@3
  double v10; // st6@3
  float v11; // [sp+0h] [bp-4h]@2

  v3 = sub_10004550(a1);
  result = 0.0;
  if ( v3 )
  {
    v5 = (char *)a2;
    v11 = 0.0;
    for ( i = *(_BYTE *)a2; *v5; v11 = v10 )
    {
      v7 = v3 + 32 * i;
      ++v5;
      v8 = *(float *)(v7 + 16) * a3 + v11;
      v9 = v8 + *(float *)(v7 + 24);
      v10 = v9 + *(float *)(v7 + 28);
      i = *v5;
    }
    result = v11;
  }
  return result;
}

//----- (10004770) --------------------------------------------------------
signed int __cdecl sub_10004770(unsigned int a1)
{
  signed int result; // eax@7
  int v2; // eax@8
  int v3; // edx@9
  unsigned int v4; // [sp+4h] [bp+4h]@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return FIL_vfs_close();
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_10016340(a1);
    if ( v4 && *(_DWORD *)(v4 + 732) )
    {
      --*(_DWORD *)(*(_DWORD *)(v4 + 732) + 124);
      if ( *(_BYTE *)(v4 + 8) )
        exit(v4);
      sub_1002DC90(v4 + 116);
      result = 0;
      *(_DWORD *)v4 = -858993460;
    }
    else
    {
      result = -6;
    }
    return result;
  }
  if ( !a1 || (a1 & 3) != 2 )
    return FIL_vfs_close();
  v2 = 0;
  if ( !dword_1010EEF8 )
    goto LABEL_11;
  while ( 1 )
  {
    v3 = dword_1010EF00[v2];
    if ( *(_DWORD *)v3 == a1 )
      break;
    if ( ++v2 >= (unsigned int)dword_1010EEF8 )
      goto LABEL_11;
  }
  if ( v2 != -1 )
  {
    sub_10004B40(
      v2,
      *(_DWORD *)(dword_1010EF00[v2] + 12),
      *(_DWORD *)(v3 + 16),
      *(_BYTE *)(v3 + 32),
      *(_WORD *)(v3 + 20),
      *(_DWORD *)(v3 + 4));
    result = sub_10004770(a1 & 0xFFFFFFFC);
  }
  else
  {
LABEL_11:
    result = -6;
  }
  return result;
}
// 1003CD0A: using guessed type int FIL_vfs_close(void);
// 1010EEF8: using guessed type int dword_1010EEF8;
// 1010EF00: using guessed type int dword_1010EF00[];

//----- (100047D0) --------------------------------------------------------
int __cdecl sub_100047D0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 1003CD1C: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004840) --------------------------------------------------------
signed int __cdecl sub_10004840(unsigned int a1, void *a2, int a3)
{
  int v3; // eax@7
  unsigned int v4; // eax@4
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_10016340(a1);
    return sub_10017200(v4, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v3 = sub_10004A00(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_10004EE0(a1, a2, a3, v3, (unsigned __int64)v3 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 1003CD2E: using guessed type int FIL_vfs_read(void);

//----- (10004880) --------------------------------------------------------
signed int __cdecl sub_10004880(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_10017430(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_10004EE0(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 1003CD34: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004910) --------------------------------------------------------
signed int __cdecl sub_10004910(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_10017490(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 1003CD40: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004960) --------------------------------------------------------
__int64 __cdecl sub_10004960(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 1003CD46: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (10004980) --------------------------------------------------------
int __cdecl sub_10004980(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 1003CD4C: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (100049B0) --------------------------------------------------------
int __cdecl sub_100049B0(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 1003CD58: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100049D0) --------------------------------------------------------
char __cdecl sub_100049D0(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_10004770(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10004830: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10004A00) --------------------------------------------------------
signed int __cdecl sub_10004A00(unsigned int a1, int a2, int a3)
{
  return sub_10004910(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (10004A20) --------------------------------------------------------
int __cdecl sub_10004A20(int a1, int a2, int a3)
{
  return sub_10004980(a1, a2, a3);
}

//----- (10004A40) --------------------------------------------------------
void __cdecl sub_10004A40(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_10005030(a1, a2);
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CD5E: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (10004A70) --------------------------------------------------------
int __cdecl sub_10004A70(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_set(a1, a2);
  return SYS_exit_krnl();
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CD64: using guessed type int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD);

//----- (10004B00) --------------------------------------------------------
signed int sub_10004B00()
{
  return sub_100053E0((int)&off_1005AFF8);
}
// 1005AFF8: using guessed type char *off_1005AFF8;

//----- (10004B10) --------------------------------------------------------
int __cdecl sub_10004B10(unsigned int a1)
{
  int result; // eax@3

  if ( a1 < 0xC && (unsigned __int8)sub_10004B00() )
    result = 8216 * a1 + dword_1010EE74 + 3312;
  else
    result = 0;
  return result;
}
// 1010EE74: using guessed type int dword_1010EE74;

//----- (10004B40) --------------------------------------------------------
unsigned int __cdecl sub_10004B40(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_1010EF00[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_1010EEB8[a1];
  dword_1010EEB8[a1] = a3 + v9;
  dword_1010EE78[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_1010EE78[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 1010EEB8: using guessed type int dword_1010EEB8[];
// 1010EF00: using guessed type int dword_1010EF00[];

//----- (10004CF0) --------------------------------------------------------
int __usercall sub_10004CF0@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_1010EF00[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_1010EF00[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 1010EF00: using guessed type int dword_1010EF00[];

//----- (10004DA0) --------------------------------------------------------
int __cdecl sub_10004DA0(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_10004CF0(a1);
  v3 = &dword_1010EF00[a1];
  v4 = sub_10004880(
         *(_DWORD *)dword_1010EF00[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_1010EF00[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_1010EEB8[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 1010EEB8: using guessed type int dword_1010EEB8[];
// 1010EF00: using guessed type int dword_1010EF00[];

//----- (10004E50) --------------------------------------------------------
int __usercall sub_10004E50@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_1010EF00[a1];
  v3 = (int *)(dword_1010EEB8[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_1010EF00[a1] + 32)) % *(_WORD *)(dword_1010EF00[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_10004DA0(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 1010EEB8: using guessed type int dword_1010EEB8[];
// 1010EF00: using guessed type int dword_1010EF00[];

//----- (10004EE0) --------------------------------------------------------
unsigned int __cdecl sub_10004EE0(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  unsigned int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_1010EEF8 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_1010EF00[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_1010EEF8 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_100040C0(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_1010EF00[v6] + 28);
        v12 = sub_10004E50(v6, (unsigned int)v7 & *(_DWORD *)(dword_1010EF00[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_1010EF00[v6] + 4) != 138 )
        sub_100040A0(*(_DWORD *)(dword_1010EF00[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_1010EF00[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_100040A0(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 1010EEF8: using guessed type int dword_1010EEF8;
// 1010EF00: using guessed type int dword_1010EF00[];

//----- (10005030) --------------------------------------------------------
void __cdecl sub_10005030(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_10011110(v2) && sub_10011170(v3) != 1 )
    *a2 = 0;
}

//----- (10005060) --------------------------------------------------------
int __cdecl sub_10005060(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_10003E50("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_10003E50("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 100054B0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (100050C0) --------------------------------------------------------
int __usercall sub_100050C0@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  char v3; // ST28_1@2
  unsigned int v4; // eax@5
  char *v5; // edi@9
  char v6; // al@10
  unsigned int v7; // eax@12
  char v8; // ST28_1@12
  signed int v9; // ebx@15
  int v10; // eax@19
  int result; // eax@47
  unsigned int v12; // [sp+Ch] [bp-98h]@1
  int v13; // [sp+14h] [bp-90h]@29
  char v14; // [sp+1Dh] [bp-87h]@30
  char v15; // [sp+1Fh] [bp-85h]@9
  char v16; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v12 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
    v3 = 4;
  }
  else
  {
    strncpy(&v16, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v5 = &v15;
      do
        v6 = (v5++)[1];
      while ( v6 );
      *(_DWORD *)v5 = 7368052;
    }
    v12 = j_FIL_vfs_open(*a1, 6, 1809);
    v7 = j_FIL_vfs_open(&v16, 14, 1809);
    v2 = v7;
    v8 = 6;
    if ( v7 >= 0xFFFFFFC2 || !v7 )
    {
      sub_10003E50("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v9 = sub_10004A00(v7, 0, 2);
    if ( v9 < 0 )
    {
      sub_10003E50("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_10003E50("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v10 = (int)(a1[2] + 12);
    if ( v9 < v10 && sub_10004A20(v2, v10, (unsigned __int64)v10 >> 32) < 0 )
    {
      sub_10003E50("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v4 = ((int (__cdecl *)(unsigned int, _DWORD, const char *, _DWORD))j_FIL_vfs_mmap)(v2, 0, a1[2] + 12, 0);
    v1 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v4 + 9) || *(_BYTE *)(v4 + 8) != 56 )
        {
          sub_10005060((int)a1, v4 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v4 + 4) = sub_10003FF0();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v12 < 0xFFFFFFC2 && v12 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_10004840(v12, &v13, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v13;
          v14 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_100049B0(v12, (int)&v13, 12, 0) != 12 )
          {
            sub_10003E50("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v16, *a1) )
        sub_10003E50("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_10003E50("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_10004770(v2);
LABEL_42:
  if ( v12 < 0xFFFFFFC2 && v12 )
    sub_10004770(v12);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 10004820: using guessed type int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10004830: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10004900: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (100053C0) --------------------------------------------------------
int __usercall sub_100053C0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 100054B0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (100053E0) --------------------------------------------------------
signed int __cdecl sub_100053E0(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_10003E50("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_10004270(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_10004240(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_100053C0(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_100050C0((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_10004240(v6, 81);
  return (unsigned __int8)v2;
}

//----- (100054C0) --------------------------------------------------------
int __cdecl sub_100054C0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@17

  if ( a2 < 0 )
    a2 = 0;
  if ( a3 < 0 )
    a3 = 0;
  if ( a4 < 1 )
    a4 = 1;
  if ( a5 < 1 )
    a5 = 1;
  if ( a2 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a2 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - 1;
  if ( a4 + a2 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a4 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - a2;
  if ( a3 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a3 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - 1;
  if ( a5 + a3 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a5 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - a3;
  *(_WORD *)(a1 + 26) = a2;
  HIWORD(result) = HIWORD(a1);
  *(_WORD *)(a1 + 30) = a4;
  LOWORD(result) = a3;
  *(_WORD *)(a1 + 24) = a3;
  *(_WORD *)(a1 + 28) = a5;
  return result;
}

//----- (100055D0) --------------------------------------------------------
unsigned int __cdecl sub_100055D0(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  unsigned int result; // eax@2
  int v9; // [sp+8h] [bp+8h]@1

  v9 = sub_10006110(a1, a2, a3, a4, a5, a6, a7, a8);
  if ( *(_BYTE *)(*(_DWORD *)(v9 + 52) + 8) == 8 )
  {
    if ( *(_DWORD *)(v9 + 68) )
    {
      if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 1 )
      {
        *(_WORD *)(v9 + 38) = **(_WORD **)(v9 + 68);
        *(_WORD *)(v9 + 36) = *(_WORD *)(*(_DWORD *)(v9 + 68) + 2);
        result = sub_100056B0(v9);
      }
      else
      {
        result = sub_10005BE0(v9);
      }
    }
    else if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 8 )
    {
      result = sub_10005A00(v9);
    }
    else
    {
      result = sub_10005BE0(v9);
    }
  }
  else
  {
    result = sub_10005BE0(v9);
  }
  return result;
}

//----- (100056B0) --------------------------------------------------------
int __cdecl sub_100056B0(int a1)
{
  int result; // eax@1
  int v2; // ST1C_4@10
  int v3; // [sp+0h] [bp-44h]@3
  unsigned int v4; // [sp+4h] [bp-40h]@5
  unsigned int v5; // [sp+4h] [bp-40h]@9
  unsigned __int16 v6; // [sp+8h] [bp-3Ch]@3
  int v7; // [sp+Ch] [bp-38h]@5
  unsigned __int16 v8; // [sp+10h] [bp-34h]@3
  unsigned __int16 v9; // [sp+14h] [bp-30h]@2
  signed int v10; // [sp+1Ch] [bp-28h]@9
  unsigned int *v11; // [sp+20h] [bp-24h]@9
  int v12; // [sp+24h] [bp-20h]@11
  int v13; // [sp+28h] [bp-1Ch]@9
  unsigned int v14; // [sp+2Ch] [bp-18h]@9
  unsigned __int16 v15; // [sp+30h] [bp-14h]@2
  unsigned int *v16; // [sp+34h] [bp-10h]@3
  int v17; // [sp+38h] [bp-Ch]@4
  unsigned int v18; // [sp+3Ch] [bp-8h]@2
  unsigned __int16 v19; // [sp+40h] [bp-4h]@2
  int v20; // [sp+4Ch] [bp+8h]@1

  result = sub_10006E10(a1);
  v20 = result;
  if ( result )
  {
    v19 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v18 = ((unsigned int)*(_WORD *)(result + 14) >> 3)
        + *(_WORD *)(result + 12) * *(_WORD *)(*(_DWORD *)(result + 56) + 10)
        + **(_DWORD **)(result + 56);
    v9 = 8 * (*(_WORD *)(result + 14) >> 3) - *(_WORD *)(result + 14) + 8;
    v15 = *(_WORD *)(*(_DWORD *)(result + 52) + 10);
    if ( !(*(_WORD *)(*(_DWORD *)(result + 52) + 10) << 30) )
    {
      v16 = (unsigned int *)(**(_DWORD **)(result + 52)
                           + *(_WORD *)(result + 8) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                           + 4 * (8 * *(_WORD *)(result + 10) >> 5));
      v8 = 32 * (8 * *(_WORD *)(result + 10) >> 5) - 8 * *(_WORD *)(result + 10) + 32;
      v3 = *(_WORD *)(result + 16);
      v6 = *(_WORD *)(result + 18);
      do
      {
        v17 = v9;
        if ( v18 << 31 )
        {
          v4 = *(_BYTE *)v18;
          v7 = v18 + 1;
        }
        else if ( v18 << 30 )
        {
          v4 = *(_WORD *)v18;
          v7 = v18 + 2;
          v17 = v9 + 8;
        }
        else
        {
          v4 = *(_DWORD *)v18;
          v7 = v18 + 4;
          v17 = v9 + 24;
        }
        v5 = (v4 >> ((-v9 + 8) & 0x1F)) | (v4 << (32 - ((-v9 + 8) & 0x1F)));
        v10 = v8;
        v11 = v16;
        v14 = (*v16 >> ((32 - v8) & 0x1F)) | (*v16 << (32 - ((32 - v8) & 0x1F)));
        v13 = v6;
        do
        {
          v2 = 2 * v5 & 3;
          v5 >>= 1;
          if ( v2 )
            v12 = *(_WORD *)(v20 + 38);
          else
            v12 = *(_WORD *)(v20 + 36);
          if ( (signed __int16)v12 >= 0 )
            v14 = (v14 >> 8) | (v12 << 24);
          else
            v14 = (v14 >> 8) | (v14 << 24);
          if ( --v13 )
          {
            v10 -= 8;
            if ( !v10 )
            {
              *v11 = v14;
              ++v11;
              v10 = 32;
              v14 = *v11;
            }
            if ( !--v17 )
            {
              if ( v7 << 30 )
              {
                v17 = 16;
                v5 = *(_WORD *)v7;
                v7 += 2;
              }
              else
              {
                v17 = 32;
                v5 = *(_DWORD *)v7;
                v7 += 4;
              }
            }
          }
        }
        while ( v13 );
        *v11 = (v14 >> ((v10 - 8) & 0x1F)) | (v14 << (32 - ((v10 - 8) & 0x1F)));
        v18 += v19;
        result = (int)v16 + v15;
        v16 = (unsigned int *)((char *)v16 + v15);
        --v3;
      }
      while ( v3 );
    }
  }
  return result;
}

//----- (10005A00) --------------------------------------------------------
int __cdecl sub_10005A00(int a1)
{
  int result; // eax@1
  signed int v2; // [sp+4h] [bp-30h]@16
  int v3; // [sp+8h] [bp-2Ch]@9
  char *v4; // [sp+Ch] [bp-28h]@4
  _BYTE *v5; // [sp+Ch] [bp-28h]@10
  _BYTE *v6; // [sp+Ch] [bp-28h]@12
  _BYTE *v7; // [sp+Ch] [bp-28h]@14
  char *v8; // [sp+10h] [bp-24h]@4
  _BYTE *v9; // [sp+10h] [bp-24h]@10
  _BYTE *v10; // [sp+10h] [bp-24h]@12
  _BYTE *v11; // [sp+10h] [bp-24h]@14
  unsigned int v12; // [sp+14h] [bp-20h]@4
  int v13; // [sp+14h] [bp-20h]@10
  int v14; // [sp+14h] [bp-20h]@12
  int v15; // [sp+18h] [bp-1Ch]@2
  int v16; // [sp+1Ch] [bp-18h]@2
  int v17; // [sp+20h] [bp-14h]@2
  size_t v18; // [sp+24h] [bp-10h]@2
  char *v19; // [sp+28h] [bp-Ch]@2
  int v20; // [sp+2Ch] [bp-8h]@2
  char *v21; // [sp+30h] [bp-4h]@2
  _BYTE *v22; // [sp+3Ch] [bp+8h]@1

  result = sub_10006E10(a1);
  v22 = (_BYTE *)result;
  if ( result )
  {
    v18 = *(_WORD *)(result + 18);
    v15 = *(_WORD *)(result + 16);
    v17 = *(_WORD *)(*(_DWORD *)(result + 52) + 10);
    v16 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v21 = (char *)(*(_WORD *)(result + 14) + v16 * *(_WORD *)(result + 12) + **(_DWORD **)(result + 56));
    v19 = (char *)(*(_WORD *)(result + 10) + v17 * *(_WORD *)(result + 8) + **(_DWORD **)(result + 52));
    v20 = 0;
    do
    {
      if ( v20 )
        goto LABEL_26;
      v12 = v18;
      v8 = v21;
      v4 = v19;
      while ( v12 >= 4 )
      {
        if ( *(_DWORD *)v4 != *(_DWORD *)v8 )
          goto LABEL_9;
        v12 -= 4;
        v8 += 4;
        v4 += 4;
      }
      if ( !v12 )
      {
LABEL_16:
        v2 = 0;
        goto LABEL_19;
      }
LABEL_9:
      v3 = (unsigned __int8)*v4 - (unsigned __int8)*v8;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v8 )
      {
        v13 = v12 - 1;
        v9 = v8 + 1;
        v5 = v4 + 1;
        if ( !v13 )
          goto LABEL_16;
        v3 = *v5 - *v9;
        if ( *v5 == *v9 )
        {
          v14 = v13 - 1;
          v10 = v9 + 1;
          v6 = v5 + 1;
          if ( !v14 )
            goto LABEL_16;
          v3 = *v6 - *v10;
          if ( *v6 == *v10 )
          {
            v11 = v10 + 1;
            v7 = v6 + 1;
            if ( v14 == 1 )
              goto LABEL_16;
            v3 = *v7 - *v11;
            if ( *v7 == *v11 )
              goto LABEL_16;
          }
        }
      }
      v2 = 1;
      if ( v3 <= 0 )
        v2 = -1;
LABEL_19:
      if ( v2 )
      {
LABEL_26:
        ++v20;
        memcpy(v19, v21, v18);
      }
      v21 += v16;
      v19 += v17;
      result = v15-- - 1;
    }
    while ( v15 );
    if ( !v20 )
      *v22 = 0;
  }
  return result;
}

//----- (10005BE0) --------------------------------------------------------
unsigned int __cdecl sub_10005BE0(int a1)
{
  unsigned int result; // eax@1
  unsigned int v2; // ST08_4@5
  unsigned int v3; // ST28_4@6
  int v4; // ST28_4@13
  int v5; // [sp+0h] [bp-50h]@4
  unsigned int v6; // [sp+4h] [bp-4Ch]@5
  int v7; // [sp+8h] [bp-48h]@4
  unsigned __int16 v8; // [sp+Ch] [bp-44h]@4
  int *v9; // [sp+10h] [bp-40h]@5
  unsigned __int16 v10; // [sp+14h] [bp-3Ch]@4
  int v11; // [sp+18h] [bp-38h]@3
  int v12; // [sp+18h] [bp-38h]@5
  unsigned __int16 v13; // [sp+20h] [bp-30h]@3
  unsigned int *v14; // [sp+2Ch] [bp-24h]@5
  signed int v15; // [sp+30h] [bp-20h]@13
  int v16; // [sp+34h] [bp-1Ch]@5
  unsigned int v17; // [sp+38h] [bp-18h]@5
  unsigned __int16 v18; // [sp+3Ch] [bp-14h]@3
  unsigned int *v19; // [sp+40h] [bp-10h]@4
  int v20; // [sp+48h] [bp-8h]@2
  int v21; // [sp+48h] [bp-8h]@3
  unsigned __int16 v22; // [sp+4Ch] [bp-4h]@2
  unsigned int v23; // [sp+58h] [bp+8h]@1

  result = sub_10006E10(a1);
  v23 = result;
  if ( result )
  {
    v22 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v20 = **(_DWORD **)(result + 56) + *(_WORD *)(result + 12) * *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    result = *(_DWORD *)(result + 56);
    if ( (unsigned int)*(_BYTE *)(result + 8) < 9 )
    {
      v21 = v20 + 4 * ((signed int)*(_WORD *)(v23 + 14) << byte_1005B618[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)] >> 5);
      v13 = 32 - ((*(_WORD *)(v23 + 14) << byte_1005B618[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)]) & 0x1F);
      v18 = *(_WORD *)(*(_DWORD *)(v23 + 52) + 10);
      v11 = *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8) | (*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8) << 8);
      result = *(_BYTE *)(*(_DWORD *)(v23 + 52) + 8);
      if ( result < 9 )
      {
        v19 = (unsigned int *)(**(_DWORD **)(v23 + 52)
                             + *(_WORD *)(v23 + 8) * *(_WORD *)(*(_DWORD *)(v23 + 52) + 10)
                             + 4
                             * ((signed int)*(_WORD *)(v23 + 10) << byte_1005B618[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)] >> 5));
        v10 = 32 - ((*(_WORD *)(v23 + 10) << byte_1005B618[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)]) & 0x1F);
        v8 = *(_WORD *)(v23 + 18);
        v5 = *(_WORD *)(v23 + 16);
        v7 = (1 << *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)) - 1;
        do
        {
          v2 = *(_DWORD *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5));
          v9 = (int *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 4);
          v6 = (v2 >> (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)) | (v2 << (32 - (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)));
          v14 = v19;
          v17 = (*v19 >> (31 * v10 & 0x1F)) | (*v19 << (32 - (31 * v10 & 0x1F)));
          v12 = (unsigned __int16)v11 | (((v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 127) | ((v10 + 127) << 8)) << 16);
          v16 = v8;
          if ( *(_DWORD *)(v23 + 68) )
          {
            do
            {
              v4 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v15 = *(_WORD *)(*(_DWORD *)(v23 + 68) + 2 * v4);
              if ( (signed __int16)v15 >= 0 )
                v17 = (v15 >> (BYTE1(v12) & 0x1F)) | (v15 << (32 - (BYTE1(v12) & 0x1F))) | ((unsigned __int64)v17 >> SBYTE1(v12));
              else
                v17 = (v17 >> (BYTE1(v12) & 0x1F)) | (v17 << (32 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( (signed __int16)v16 > 0 );
          }
          else
          {
            do
            {
              v3 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v17 = ((unsigned __int64)v17 >> SBYTE1(v12)) | (v3 >> (BYTE1(v12) & 0x1F)) | (v3 << (32
                                                                                                 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( v16 );
          }
          v11 = -65535 * v12;
          *v14 = (v17 >> ((BYTE3(v11) - 127) & 0x1F)) | (v17 << (32 - ((BYTE3(v11) - 127) & 0x1F)));
          v21 += v22;
          result = (unsigned int)v19 + v18;
          v19 = (unsigned int *)((char *)v19 + v18);
          --v5;
        }
        while ( v5 );
      }
    }
  }
  return result;
}

//----- (10006110) --------------------------------------------------------
int __cdecl sub_10006110(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  *(_DWORD *)(a1 + 56) = a2;
  *(_WORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 12) = a4;
  *(_WORD *)(a1 + 10) = a5;
  *(_WORD *)(a1 + 8) = a6;
  *(_WORD *)(a1 + 18) = a7;
  *(_WORD *)(a1 + 16) = a8;
  return a1;
}

//----- (10006170) --------------------------------------------------------
_WORD *__cdecl sub_10006170(int a1)
{
  _WORD *result; // eax@1

  result = (_WORD *)a1;
  if ( *(_WORD *)(a1 + 36) != 0xFFFF )
  {
    result = *(_WORD **)(a1 + 52);
    if ( !(result[5] << 30) )
    {
      *(_BYTE *)a1 = 1;
      result = memset(
                 **(void ***)(a1 + 52),
                 *(_WORD *)(a1 + 36),
                 *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 4));
    }
  }
  return result;
}

//----- (100061D0) --------------------------------------------------------
int __cdecl sub_100061D0(int a1, int a2, char a3)
{
  int result; // eax@1

  *(_DWORD *)(a1 + 52) = a2;
  sub_100054C0(a1, 0, 0, *(_WORD *)(a2 + 6), *(_WORD *)(a2 + 4));
  *(_WORD *)(a1 + 42) = 0;
  *(_WORD *)(a1 + 40) = 0;
  *(_WORD *)(a1 + 46) = 0;
  *(_WORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_WORD *)(a1 + 2) = 1;
  *(_WORD *)(a1 + 34) = 1;
  *(_WORD *)(a1 + 32) = 1;
  *(_WORD *)(a1 + 4) = 3;
  *(_WORD *)(a1 + 36) = -1;
  *(_WORD *)(a1 + 38) = -1;
  *(_WORD *)(a1 + 6) = 3;
  *(_WORD *)(a1 + 48) = -1;
  *(_WORD *)(a1 + 50) = -1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  result = a1;
  *(_BYTE *)a1 = a3;
  return result;
}

//----- (100062C0) --------------------------------------------------------
void sub_100062C0()
{
  ;
}

//----- (100062D0) --------------------------------------------------------
int __cdecl sub_100062D0(int a1, _BYTE *a2, int a3)
{
  int result; // eax@2

  if ( *(_BYTE *)(a1 + 2) )
    result = 0;
  else
    result = sub_10006D20(a1, a2, a3);
  return result;
}

//----- (10006310) --------------------------------------------------------
char __cdecl sub_10006310(char a1, char a2)
{
  char result; // al@1

  result = a1;
  byte_1010EF41 = a1;
  byte_1010EF40 = a2;
  return result;
}
// 1010EF40: using guessed type char byte_1010EF40;
// 1010EF41: using guessed type char byte_1010EF41;

//----- (10006330) --------------------------------------------------------
int __cdecl sub_10006330(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7)
{
  int result; // eax@12
  __int16 v8; // ST1C_2@20
  __int16 v9; // ST1E_2@43
  __int16 v10; // ST1C_2@56
  __int16 v11; // [sp+8h] [bp-8Ch]@17
  __int16 v12; // [sp+8h] [bp-8Ch]@43
  __int16 v13; // [sp+Ah] [bp-8Ah]@17
  __int16 v14; // [sp+Ah] [bp-8Ah]@43
  __int16 *v15; // [sp+10h] [bp-84h]@3
  unsigned __int8 v16; // [sp+17h] [bp-7Dh]@1
  int v17; // [sp+18h] [bp-7Ch]@47
  int v18; // [sp+1Ch] [bp-78h]@17
  int v19; // [sp+20h] [bp-74h]@11
  __int16 v20; // [sp+28h] [bp-6Ch]@29
  int v21; // [sp+2Ch] [bp-68h]@50
  int v22; // [sp+30h] [bp-64h]@47
  int i; // [sp+34h] [bp-60h]@13
  signed int v24; // [sp+38h] [bp-5Ch]@15
  unsigned __int8 v25; // [sp+3Eh] [bp-56h]@1
  bool v26; // [sp+3Fh] [bp-55h]@1
  char v27; // [sp+40h] [bp-54h]@45
  __int16 v28; // [sp+44h] [bp-50h]@43
  __int16 v29; // [sp+46h] [bp-4Eh]@56
  char v30; // [sp+48h] [bp-4Ch]@43
  char v31; // [sp+49h] [bp-4Bh]@46
  __int16 v32; // [sp+4Ah] [bp-4Ah]@56
  unsigned __int8 v33; // [sp+4Fh] [bp-45h]@1
  int v34; // [sp+50h] [bp-44h]@15
  __int16 v35; // [sp+54h] [bp-40h]@22
  int v36; // [sp+58h] [bp-3Ch]@45
  int v37; // [sp+5Ch] [bp-38h]@44
  int v38; // [sp+60h] [bp-34h]@28
  __int16 v39; // [sp+64h] [bp-30h]@17
  __int16 v40; // [sp+66h] [bp-2Eh]@17
  __int16 v41; // [sp+68h] [bp-2Ch]@55
  __int16 v42; // [sp+6Ah] [bp-2Ah]@55
  unsigned __int16 v43; // [sp+6Ch] [bp-28h]@24
  int v44; // [sp+70h] [bp-24h]@29
  char v45; // [sp+75h] [bp-1Fh]@43
  unsigned __int8 v46; // [sp+76h] [bp-1Eh]@1
  char v47; // [sp+77h] [bp-1Dh]@43
  int v48; // [sp+78h] [bp-1Ch]@22
  int v49; // [sp+7Ch] [bp-18h]@23
  __int16 v50; // [sp+80h] [bp-14h]@55
  __int16 v51; // [sp+82h] [bp-12h]@55
  __int16 v52; // [sp+84h] [bp-10h]@24
  int v53; // [sp+88h] [bp-Ch]@4
  int v54; // [sp+8Ch] [bp-8h]@19
  __int16 v55; // [sp+90h] [bp-4h]@17

  v16 = (a5 & 0xE000u) >> 13;
  v46 = (unsigned __int8)(a5 & 0x70) >> 4;
  v25 = (a5 & 0x380u) >> 7;
  v33 = (a5 & 0x1C00u) >> 10;
  v26 = 1;
  if ( a5 & 0x40000000 || a5 & 0x80000000 )
  {
    v15 = &a6;
    if ( a5 & 0x40000000 )
    {
      v15 = (__int16 *)&a7;
      v53 = a6;
      v16 = (a6 & 0xFF000000) >> 24;
      v46 = a6;
      v25 = (unsigned __int16)(a6 & 0xFF00) >> 8;
      v33 = (a6 & 0xFF0000u) >> 16;
    }
    if ( a5 & 0x80000000 )
    {
      if ( *(_DWORD *)v15 )
      {
        if ( *(_DWORD *)v15 == 2 )
          v26 = sub_10006B70(a3) == 0;
        else
          v26 = 0;
      }
      else
      {
        v26 = 1;
      }
    }
  }
  v19 = 0;
  if ( *(_BYTE *)(a2 + 3) & 3 )
  {
    result = 0;
  }
  else
  {
    i = sub_100062D0(a2, a3, a5);
    if ( !a4 )
      a4 = i;
    v34 = a4;
    v24 = ((a5 & 0x3F0000u) >> 16) - 1;
    if ( v24 < 0 )
      v24 = *(_WORD *)(a2 + 28);
    v18 = *(_WORD *)(a2 + 22);
    v11 = *(_WORD *)(a1 + 46);
    v55 = *(_WORD *)(a1 + 44);
    v13 = v55 - (*(_WORD *)(a2 + 24) - 1);
    v39 = *(_WORD *)(a1 + 42);
    v40 = *(_WORD *)(a1 + 40);
    if ( a5 & 3 )
    {
      if ( (a5 & 3) == 1 )
      {
        v54 = v11 - v34 / 2;
        v11 -= i / 2;
      }
      else
      {
        v54 = v11;
      }
    }
    else
    {
      v8 = v11 + 1;
      v54 = v8 - v34;
      v11 = v8 - i;
    }
    v35 = v13;
    v48 = v18;
    if ( a5 & 0xC )
    {
      v35 += *(_WORD *)(a2 + 26);
      v48 -= v18 - *(_WORD *)(a2 + 24) + *(_WORD *)(a2 + 26);
      v54 -= v46;
      v49 = v25;
      v34 += v25 + v46;
      if ( (a5 & 0xC) == 4 )
      {
        v52 = *(_WORD *)(a1 + 6);
        v43 = *(_WORD *)(a1 + 50);
        *(_WORD *)(a1 + 6) = 3;
        *(_WORD *)(a1 + 50) = *(_WORD *)(a1 + 36);
        v49 = v33;
        v35 -= v33;
        v48 += v33;
        if ( v33 > (signed int)*(_WORD *)(a2 + 26) )
          sub_100074B0(a1, v54, v35, v34, v49 - *(_WORD *)(a2 + 26));
        v49 = v16;
        v48 += v16;
        if ( v16 > v18 - *(_WORD *)(a2 + 24) )
          sub_100074B0(a1, v54, v18 + v13, v34, v49 - (v18 - *(_WORD *)(a2 + 24)));
        v38 = v11 - v54;
        if ( i > a4 )
        {
          v20 = a4 + v11;
          v44 = v25;
        }
        else
        {
          v20 = i + v11;
          v44 = v34 - (i + v38);
        }
        if ( v38 > 0 )
          sub_100074B0(a1, v54, v35, v38, v48);
        if ( v44 > 0 )
          sub_100074B0(a1, v20, v35, v44, v48);
        *(_WORD *)(a1 + 50) = v43;
        *(_WORD *)(a1 + 6) = v52;
      }
    }
    if ( v35 <= v13 )
      v35 = 0;
    else
      v35 -= v13;
    if ( v48 >= v18 - v35 )
      v48 = v18 - v35;
    if ( i < a4 )
      a4 = i;
    v30 = 1;
    v47 = 0;
    v45 = (*(_BYTE *)(a2 + 3) & 3) << 6;
    v12 = v39 + v11;
    v9 = v40 + v13;
    v52 = *(_WORD *)(a1 + 4);
    *(_WORD *)(a1 + 4) = 2;
    v14 = v35 + v9;
    v28 = v18;
    if ( i )
    {
      v37 = (a5 & 0x3FC00000u) >> 22;
      for ( i = 0; !sub_10006C10(a2, &a3, &v27, &v36, v26); i += v21 + (signed __int16)v36 )
      {
        v31 = v47;
        if ( v37 <= v36 )
        {
          v22 = 0;
          v17 = 0;
        }
        else
        {
          v22 = (v37 - v36) / 2;
          v17 = v37 - v36 - v22;
        }
        v21 = i <= 0 ? v22 : v22 + v24 + v19;
        if ( v36 + v21 + i > a4 )
          break;
        v19 = v17;
        v43 = *(_WORD *)(a1 + 38);
        if ( v21 > 0 && v43 != 0xFFFF )
        {
          *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
          v50 = v14;
          v51 = v12;
          v41 = v48;
          v42 = v21;
          sub_10006FE0(a1, (signed __int16)v21 + (v12 << 16), (signed __int16)v48 + (v14 << 16));
          *(_WORD *)(a1 + 38) = v43;
        }
        v10 = v21 + v12;
        *(_WORD *)(a1 + 8) = v14;
        *(_WORD *)(a1 + 10) = v10;
        *(_WORD *)(a1 + 16) = v48;
        *(_WORD *)(a1 + 18) = v36;
        v29 = v36;
        *(_WORD *)(a1 + 14) = 0;
        *(_WORD *)(a1 + 12) = v35;
        v32 = (v29 + 7) / 8;
        *(_DWORD *)(a1 + 56) = &v27;
        sub_100056B0(a1);
        v12 = v36 + v10;
      }
    }
    v43 = *(_WORD *)(a1 + 38);
    if ( i < a4 && v43 != 0xFFFF )
    {
      *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
      v50 = v14;
      v51 = v12;
      v41 = v48;
      v42 = a4 - i;
      sub_10006FE0(a1, (signed __int16)(a4 - i) + (v12 << 16), (signed __int16)v48 + (v14 << 16));
      *(_WORD *)(a1 + 38) = v43;
    }
    *(_WORD *)(a1 + 4) = v52;
    *(_WORD *)(a1 + 46) = v19 + v12 - v39;
    *(_WORD *)(a1 + 44) = v55;
    result = v19 + i;
  }
  return result;
}

//----- (10006B70) --------------------------------------------------------
bool __cdecl sub_10006B70(_BYTE *a1)
{
  char v3; // [sp+6h] [bp-2h]@1
  char v4; // [sp+7h] [bp-1h]@1

  v3 = 0;
  v4 = 0;
  while ( *a1 )
  {
    if ( (signed int)*a1 < 48 || (signed int)*a1 > 57 )
    {
      if ( (signed int)*a1 >= 97 && (signed int)*a1 <= 122 || (signed int)*a1 >= 65 && (signed int)*a1 <= 90 )
        v3 = 1;
    }
    else
    {
      v4 = 1;
    }
    ++a1;
  }
  return v3 && v4;
}

//----- (10006C10) --------------------------------------------------------
bool __cdecl sub_10006C10(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5)
{
  int v5; // ST18_4@9
  int v7; // [sp+4h] [bp-1Ch]@7
  bool v8; // [sp+Bh] [bp-15h]@1
  unsigned int v9; // [sp+10h] [bp-10h]@7
  int v10; // [sp+14h] [bp-Ch]@1

  v10 = *(_BYTE *)(*a2)++;
  v8 = v10 == 0;
  if ( byte_1010EF41 && a5 && v10 == 48 )
    v10 = (unsigned __int8)byte_1010EF40;
  if ( !v8 )
  {
    if ( *(_BYTE *)(a1 + 2) )
    {
      v8 = 1;
    }
    else
    {
      v7 = *(_DWORD *)(a1 + 8) + a1;
      v9 = v10 - *(_BYTE *)(v7 + 2);
      if ( v9 >= *(_WORD *)v7 )
        v9 = *(_BYTE *)(v7 + 3);
      v5 = *(_DWORD *)(a1 + 12) + a1 + 4 * v9;
      *a3 = ((*(_BYTE *)(v5 + 2) << 16) | *(_WORD *)v5) + *(_DWORD *)(a1 + 16) + a1;
      *a4 = *(_BYTE *)(v5 + 3);
    }
  }
  return v8;
}
// 1010EF40: using guessed type char byte_1010EF40;
// 1010EF41: using guessed type char byte_1010EF41;

//----- (10006D20) --------------------------------------------------------
int __cdecl sub_10006D20(int a1, _BYTE *a2, int a3)
{
  int v3; // ST00_4@5
  unsigned int v5; // [sp+0h] [bp-20h]@5
  int v6; // [sp+4h] [bp-1Ch]@3
  int v7; // [sp+8h] [bp-18h]@3
  int v8; // [sp+Ch] [bp-14h]@3
  signed int v9; // [sp+10h] [bp-10h]@1
  signed int v10; // [sp+14h] [bp-Ch]@8
  signed int v11; // [sp+18h] [bp-8h]@1
  _BYTE *v12; // [sp+1Ch] [bp-4h]@3

  v11 = (a3 & 0x3FC00000u) >> 22;
  v9 = ((a3 & 0x3F0000u) >> 16) - 1;
  if ( v9 < 0 )
    v9 = *(_WORD *)(a1 + 28);
  v12 = a2;
  v6 = *(_DWORD *)(a1 + 12) + a1;
  v7 = *(_DWORD *)(a1 + 8) + a1;
  v8 = 0;
  while ( *v12 )
  {
    v3 = *v12++;
    v5 = v3 - *(_BYTE *)(v7 + 2);
    if ( v8 > 0 )
      v8 += v9;
    if ( v5 < *(_WORD *)v7 )
      v10 = *(_BYTE *)(v6 + 4 * v5 + 3);
    else
      v10 = *(_BYTE *)(v6 + 4 * *(_BYTE *)(v7 + 3) + 3);
    if ( v11 <= v10 )
      v8 += v10;
    else
      v8 += v11;
  }
  return v8;
}

//----- (10006E10) --------------------------------------------------------
int __cdecl sub_10006E10(int a1)
{
  int result; // eax@6
  __int16 v2; // [sp+0h] [bp-8h]@1
  __int16 v3; // [sp+4h] [bp-4h]@1

  v2 = *(_WORD *)(a1 + 10);
  v3 = *(_WORD *)(a1 + 8);
  if ( *(_WORD *)(a1 + 26) > (signed int)*(_WORD *)(a1 + 10) )
  {
    *(_WORD *)(a1 + 18) -= *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 14) += *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > (signed int)*(_WORD *)(a1 + 8) )
  {
    *(_WORD *)(a1 + 16) -= *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 12) += *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 24);
  }
  if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) > v2 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v2 < *(_WORD *)(a1 + 18) )
      *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v2;
    if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) > v3 )
    {
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v3 < *(_WORD *)(a1 + 16) )
        *(_WORD *)(a1 + 16) = *(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 24) - v3;
      if ( (signed int)*(_WORD *)(a1 + 18) > 0 )
      {
        if ( (signed int)*(_WORD *)(a1 + 16) > 0 )
        {
          *(_BYTE *)a1 = 1;
          result = a1;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10006FE0) --------------------------------------------------------
int __cdecl sub_10006FE0(int a1, signed int a2, signed int a3)
{
  int result; // eax@5
  int v4; // edx@10
  unsigned int v5; // ST04_4@15
  unsigned int v6; // ST20_4@16
  int v7; // ST28_4@26
  unsigned int v8; // ST18_4@32
  int v9; // [sp+0h] [bp-44h]@28
  unsigned int v10; // [sp+4h] [bp-40h]@15
  int v11; // [sp+8h] [bp-3Ch]@1
  int v12; // [sp+Ch] [bp-38h]@1
  int v13; // [sp+10h] [bp-34h]@31
  unsigned int v14; // [sp+14h] [bp-30h]@13
  int v15; // [sp+1Ch] [bp-28h]@30
  int v16; // [sp+20h] [bp-24h]@17
  int i; // [sp+20h] [bp-24h]@32
  int v18; // [sp+20h] [bp-24h]@34
  int v19; // [sp+24h] [bp-20h]@1
  unsigned int v20; // [sp+28h] [bp-1Ch]@14
  int v21; // [sp+2Ch] [bp-18h]@15
  unsigned int *v22; // [sp+30h] [bp-14h]@15
  int *v23; // [sp+30h] [bp-14h]@32
  int v24; // [sp+34h] [bp-10h]@15
  unsigned int v25; // [sp+38h] [bp-Ch]@15
  unsigned int *v26; // [sp+3Ch] [bp-8h]@13
  int v27; // [sp+40h] [bp-4h]@1

  v11 = (signed __int16)a3;
  v27 = a3 >> 16;
  v12 = (signed __int16)a2;
  v19 = a2 >> 16;
  if ( *(_WORD *)(a1 + 26) > a2 >> 16 )
  {
    v12 = (signed __int16)a2 - (*(_WORD *)(a1 + 26) - v19);
    v19 = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > v27 )
  {
    v11 = (signed __int16)a3 - (*(_WORD *)(a1 + 24) - v27);
    v27 = *(_WORD *)(a1 + 24);
  }
  result = *(_WORD *)(a1 + 30);
  if ( result + *(_WORD *)(a1 + 26) > v19 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v19 <= v12 )
      v12 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v19;
    result = *(_WORD *)(a1 + 28);
    if ( result + *(_WORD *)(a1 + 24) > v27 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v27 <= v11 )
      {
        v4 = *(_WORD *)(a1 + 28);
        result = v4 + *(_WORD *)(a1 + 24) - v27;
        v11 = v4 + *(_WORD *)(a1 + 24) - v27;
      }
      if ( v11 > 0 && v12 > 0 )
      {
        *(_BYTE *)a1 = 1;
        v14 = 32 - (8 * v19 & 0x1F);
        v26 = (unsigned int *)(v27 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                             + **(_DWORD **)(a1 + 52)
                             + 4 * ((unsigned int)(8 * v19) >> 5));
        if ( *(_WORD *)(a1 + 4) == 2 )
        {
          v9 = v11;
          if ( v14 >= 8 * v12 )
            v14 = 8 * v12;
          v15 = 8 * v12 - v14;
          result = *(_WORD *)(a1 + 38) << 16;
          if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
          {
            v13 = *(&dword_1005B628 + *(_WORD *)(a1 + 38));
            do
            {
              v8 = ~(((unsigned int)(0xFFFFFFFFui64 >> v14) >> ((32 - (8 * v19 & 0x1F) - v14) & 0x1F)) | ((unsigned int)(0xFFFFFFFFui64 >> v14) << (32 - ((32 - (8 * v19 & 0x1F) - v14) & 0x1F))));
              *v26 = *v26 & ~v8 | v13 & v8;
              v23 = (int *)(v26 + 1);
              for ( i = v15 - 32; i >= 0; i -= 32 )
              {
                *v23 = v13;
                ++v23;
              }
              v18 = i + 32;
              if ( v18 )
                *v23 = *v23 & ~((1 << v18) - 1) | v13 & ((1 << v18) - 1);
              result = *(_DWORD *)(a1 + 52);
              v26 = (unsigned int *)((char *)v26 + *(_WORD *)(result + 10));
              --v9;
            }
            while ( v9 );
          }
        }
        else
        {
          v20 = (v19 << 16) & 0x1FFFFF | v11 | (v27 << 27);
          do
          {
            v5 = *(_DWORD *)(*(_DWORD *)(a1 + 60) + (v20 >> 25));
            v10 = (v5 >> ((v20 >> 16) & 0x1F)) | (v5 << (32 - ((v20 >> 16) & 0x1F)));
            v22 = v26;
            v21 = 32 - (8 * v19 & 0x1F);
            v25 = (*v26 >> (31 * v14 & 0x1F)) | (*v26 << (32 - (31 * v14 & 0x1F)));
            v24 = v12;
            do
            {
              v6 = v10 << 31;
              v10 = (v10 << 31) | (v10 >> 1);
              if ( v6 >> 31 )
                v16 = *(_WORD *)(a1 + 38);
              else
                v16 = *(_WORD *)(a1 + 36);
              if ( (signed __int16)v16 >= 0 )
                v25 = (v16 << 24) | (v25 >> 8);
              else
                v25 = (v25 >> 8) | (v25 << 24);
              if ( --v24 )
              {
                v21 -= 8;
                if ( !v21 )
                {
                  *v22 = v25;
                  ++v22;
                  v21 = 32;
                  v25 = *v22;
                }
              }
            }
            while ( v24 );
            *v22 = (v25 >> ((v21 - 8) & 0x1F)) | (v25 << (32 - ((v21 - 8) & 0x1F)));
            v26 = (unsigned int *)((char *)v26 + *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
            v7 = v20 + 0x8000000;
            result = v7 - 1;
            v20 = v7 - 1;
          }
          while ( v20 << 16 );
        }
      }
    }
  }
  return result;
}

//----- (100074B0) --------------------------------------------------------
int __cdecl sub_100074B0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@1
  int v6; // [sp+0h] [bp-8h]@4
  __int16 v7; // [sp+4h] [bp-4h]@6

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v6 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 48);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + a2;
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + a3;
    if ( *(_WORD *)(a1 + 6) == 3 || *(_WORD *)(a1 + 6) == 1 )
    {
      v7 = *(_WORD *)(a1 + 4);
      if ( *(_WORD *)(a1 + 6) == 3 )
        *(_WORD *)(a1 + 4) = 2;
      else
        *(_WORD *)(a1 + 4) = 0;
      sub_10006FE0(a1, a4 + (*(_WORD *)(a1 + 10) << 16), a5 + (*(_WORD *)(a1 + 8) << 16));
      *(_WORD *)(a1 + 4) = v7;
    }
    result = a1;
    *(_DWORD *)(a1 + 36) = v6;
  }
  return result;
}

//----- (100075A0) --------------------------------------------------------
int __cdecl sub_100075A0(int a1, __int16 a2, __int16 a3, char a4)
{
  int result; // eax@25
  signed int v5; // [sp+4h] [bp-30h]@29
  int v6; // [sp+8h] [bp-2Ch]@44
  int v7; // [sp+8h] [bp-2Ch]@54
  __int16 v8; // [sp+Ch] [bp-28h]@31
  char (__cdecl *v9)(int); // [sp+10h] [bp-24h]@2
  char *(__cdecl *v10)(int); // [sp+14h] [bp-20h]@5
  __int16 v11; // [sp+18h] [bp-1Ch]@31
  signed int v12; // [sp+1Ch] [bp-18h]@31
  __int16 v13; // [sp+20h] [bp-14h]@41
  __int16 v14; // [sp+28h] [bp-Ch]@29
  __int16 v15; // [sp+2Ch] [bp-8h]@29
  __int16 v16; // [sp+30h] [bp-4h]@41

  if ( *(_DWORD *)(a1 + 72) )
    v9 = *(char (__cdecl **)(int))(a1 + 72);
  else
    v9 = sub_10007AF0;
  if ( *(_DWORD *)(a1 + 76) )
    v10 = *(char *(__cdecl **)(int))(a1 + 76);
  else
    v10 = sub_10007C60;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + *(_WORD *)(a1 + 46);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + *(_WORD *)(a1 + 44);
  *(_WORD *)(a1 + 14) = *(_WORD *)(a1 + 42) + a2;
  *(_WORD *)(a1 + 12) = *(_WORD *)(a1 + 40) + a3;
  *(_WORD *)(a1 + 46) = a2;
  *(_WORD *)(a1 + 44) = a3;
  if ( a4 & 1 )
  {
    if ( (signed int)*(_WORD *)(a1 + 10) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 10) < -8192 )
        *(_WORD *)(a1 + 10) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 10) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 8) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 8) < -8192 )
        *(_WORD *)(a1 + 8) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 8) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 14) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 14) < -8192 )
        *(_WORD *)(a1 + 14) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 14) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 12) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 12) < -8192 )
        *(_WORD *)(a1 + 12) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 12) = 0x1FFF;
    }
  }
  if ( *(_WORD *)(a1 + 10) != *(_WORD *)(a1 + 14) || (result = *(_WORD *)(a1 + 12), *(_WORD *)(a1 + 8) != result) )
  {
    v14 = *(_WORD *)(a1 + 14) - *(_WORD *)(a1 + 10);
    v15 = v14;
    v5 = 1;
    if ( v14 < 0 )
    {
      v5 = -1;
      v15 = -v14;
    }
    v8 = *(_WORD *)(a1 + 12) - *(_WORD *)(a1 + 8);
    v11 = v8;
    v12 = 1;
    if ( v8 < 0 )
    {
      v12 = -1;
      v11 = -v8;
    }
    if ( v15 )
    {
      if ( v11 )
      {
        v13 = 2 * v15;
        v16 = 2 * v11;
        if ( v15 <= v11 )
        {
          *(_WORD *)(a1 + 16) = 0;
          *(_WORD *)(a1 + 18) = 1;
          if ( v13 >= v11 )
            *(_WORD *)(a1 + 16) -= (v12 ^ v5) + 1;
          v7 = v13 - v11 - (v5 < 0);
          *(_WORD *)(a1 + 12) = 0;
          while ( v11 )
          {
            *(_WORD *)(a1 + 12) += v12;
            if ( v7 >= 0 )
            {
              v10(a1);
              *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
              *(_WORD *)(a1 + 12) = 0;
              *(_WORD *)(a1 + 10) += v5;
              v7 -= v16;
            }
            v7 += v13;
            --v11;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 12) += v12;
          v10(a1);
          result = a1;
          *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
        }
        else
        {
          *(_WORD *)(a1 + 16) = 1;
          *(_WORD *)(a1 + 18) = 0;
          if ( v16 >= v15 )
            *(_WORD *)(a1 + 18) -= (v12 ^ v5) + 1;
          v6 = v16 - v15 - (v12 < 0);
          *(_WORD *)(a1 + 14) = 0;
          while ( v15 )
          {
            *(_WORD *)(a1 + 14) += v5;
            if ( v6 >= 0 )
            {
              v9(a1);
              *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
              *(_WORD *)(a1 + 14) = 0;
              *(_WORD *)(a1 + 8) += v12;
              v6 -= v13;
            }
            v6 += v16;
            --v15;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 14) += v5;
          v9(a1);
          result = a1;
          *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
        }
      }
      else
      {
        *(_WORD *)(a1 + 16) = 1;
        *(_WORD *)(a1 + 18) = 0;
        *(_WORD *)(a1 + 14) = v14;
        if ( a4 & 2 )
          *(_WORD *)(a1 + 14) += v5;
        result = v9(a1);
      }
    }
    else
    {
      *(_WORD *)(a1 + 16) = 0;
      *(_WORD *)(a1 + 18) = 1;
      *(_WORD *)(a1 + 12) = v8;
      if ( a4 & 2 )
        *(_WORD *)(a1 + 12) += v12;
      result = (int)v10(a1);
    }
  }
  else if ( a4 & 2 )
  {
    *(_WORD *)(a1 + 12) = 1;
    result = (int)v10(a1);
  }
  return result;
}

//----- (10007AF0) --------------------------------------------------------
char __cdecl sub_10007AF0(int a1)
{
  __int16 v1; // ax@1
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@8
  int v5; // [sp+18h] [bp-1Ch]@1

  v5 = *(_WORD *)(a1 + 10);
  v1 = *(_WORD *)(a1 + 14);
  v3 = *(_WORD *)(a1 + 14);
  if ( *(_WORD *)(a1 + 14) )
  {
    if ( v3 < 0 )
    {
      v5 += v3 + 1;
      v3 = 0x8000 - v3;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) > 1 )
    {
      LOBYTE(v1) = a1;
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
        case 2:
          LOBYTE(v1) = sub_10008070(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
        case 4:
          LOBYTE(v1) = sub_10008930(a1, v5, (int)&v4);
          break;
        default:
          return v1;
      }
    }
    else
    {
      v1 = *(_WORD *)(a1 + 4);
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
          LOBYTE(v1) = sub_10008070(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 2:
          LOBYTE(v1) = sub_10008070(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
          LOBYTE(v1) = sub_10008170(a1, v5, *(_WORD *)(a1 + 8), (int)&v4);
          break;
        case 4:
          LOBYTE(v1) = (unsigned int)sub_100085A0(a1, v5, *(_WORD *)(a1 + 8), *(int **)(a1 + 64));
          break;
        default:
          return v1;
      }
    }
  }
  return v1;
}

//----- (10007C60) --------------------------------------------------------
char *__cdecl sub_10007C60(int a1)
{
  char *result; // eax@1
  int v2; // ST18_4@3
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@7
  int v5; // [sp+1Ch] [bp-18h]@1

  v5 = *(_WORD *)(a1 + 8);
  result = (char *)*(_WORD *)(a1 + 12);
  v3 = *(_WORD *)(a1 + 12);
  if ( *(_WORD *)(a1 + 12) )
  {
    if ( v3 < 0 )
    {
      v2 = -v3;
      v5 = v5 - v2 + 1;
      v3 = v2 + 0x8000;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) <= 1 )
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_100080F0(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
          result = (char *)sub_10008370(a1, v5, *(_WORD *)(a1 + 10), (int)&v4);
          break;
        case 4u:
          result = sub_100086E0(a1, v5, *(_WORD *)(a1 + 10), *(int **)(a1 + 64));
          break;
        default:
          return result;
      }
    }
    else
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_100080F0(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
        case 4u:
          result = (char *)sub_10008A70(a1, v5, (int)&v4);
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

//----- (10007DB0) --------------------------------------------------------
int __cdecl sub_10007DB0(int a1, int a2)
{
  int result; // eax@2

  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = *(_WORD *)(a1 + 26) - *(_DWORD *)(a2 + 12);
  if ( *(_DWORD *)(a2 + 24) <= 0
    || (*(_DWORD *)(a2 + 12) += *(_DWORD *)(a2 + 24),
        result = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 24),
        *(_DWORD *)(a2 + 20) = result,
        *(_DWORD *)(a2 + 20) > 0) )
  {
    result = *(_WORD *)(a1 + 26);
    if ( result + *(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
    {
      if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12) <= *(_DWORD *)(a2 + 20) )
        *(_DWORD *)(a2 + 20) = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12);
      result = a1;
      if ( (signed int)*(_WORD *)(a1 + 24) <= *(_DWORD *)(a2 + 16) )
      {
        result = *(_WORD *)(a1 + 24);
        if ( result + *(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
        {
          *(_DWORD *)(a2 + 24) &= ~(*(_DWORD *)(a2 + 24) >> 31);
          *(_BYTE *)a1 = 1;
          result = a2;
          *(_DWORD *)a2 = 1;
        }
      }
    }
  }
  return result;
}

//----- (10007ED0) --------------------------------------------------------
unsigned int __cdecl sub_10007ED0(int a1, int a2)
{
  unsigned int v2; // ST04_4@1
  __int16 v3; // ST0C_2@2
  char v4; // ST04_1@9
  unsigned int result; // eax@9
  unsigned int v6; // [sp+0h] [bp-1Ch]@1
  int v7; // [sp+4h] [bp-18h]@1
  int v8; // [sp+8h] [bp-14h]@2
  int v9; // [sp+10h] [bp-Ch]@1
  unsigned int v10; // [sp+14h] [bp-8h]@1
  unsigned int *v11; // [sp+18h] [bp-4h]@1

  v9 = *(_DWORD *)(a2 + 20);
  v2 = 8 * *(_DWORD *)(a2 + 12);
  v11 = (unsigned int *)(**(_DWORD **)(a1 + 52)
                       + *(_DWORD *)(a2 + 16) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                       + 4 * (v2 >> 5));
  v7 = 32 - (v2 & 0x1F);
  v10 = (*v11 >> (31 * v7 & 0x1F)) | (*v11 << (32 - (31 * v7 & 0x1F)));
  v6 = *(_DWORD *)(a2 + 32);
  do
  {
    v8 = 2 * v6 & 3;
    v6 = (v6 >> (*(_BYTE *)(a2 + 36) & 0x1F)) | (v6 << (32 - (*(_BYTE *)(a2 + 36) & 0x1F)));
    v3 = *(_WORD *)(v8 + a1 + 36);
    if ( v3 >= 0 )
      v10 = (v10 >> 8) | (*(_WORD *)(v8 + a1 + 36) << 24);
    else
      v10 = (v10 >> 8) | (v10 << 24);
    if ( --v9 )
    {
      v7 -= 8;
      if ( !v7 )
      {
        *v11 = v10;
        ++v11;
        v7 = 32;
        v10 = *v11;
      }
    }
  }
  while ( v9 );
  v4 = v7 - 8;
  result = v10 >> (v4 & 0x1F);
  *v11 = result | (v10 << (32 - (v4 & 0x1F)));
  return result;
}

//----- (10008070) --------------------------------------------------------
int __cdecl sub_10008070(int a1, int a2, int a3)
{
  return sub_10006FE0(
           a1,
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 34) - 1 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1 << 16),
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1)) << 16) + *(_WORD *)(a1 + 32));
}

//----- (100080F0) --------------------------------------------------------
int __cdecl sub_100080F0(int a1, int a2, int a3)
{
  return sub_10006FE0(
           a1,
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1)) << 16) + *(_WORD *)(a1 + 34),
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 32) - 1 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1 << 16));
}

//----- (10008170) --------------------------------------------------------
char __cdecl sub_10008170(int a1, signed int a2, int a3, int a4)
{
  char result; // al@2
  int v5; // [sp+0h] [bp-Ch]@7
  unsigned int v6; // [sp+4h] [bp-8h]@5
  _BYTE *v7; // [sp+8h] [bp-4h]@5

  *(_DWORD *)(a4 + 20) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 12) = a2 >> 16;
  *(_DWORD *)(a4 + 16) = a3;
  if ( *(_DWORD *)(a4 + 20) == 1 )
  {
    result = sub_10008280(a1, *(_DWORD *)(a4 + 12), *(_DWORD *)(a4 + 16));
  }
  else
  {
    result = sub_10007DB0(a1, a4);
    if ( *(_DWORD *)a4 )
    {
      result = a1;
      if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
      {
        v7 = (_BYTE *)(*(_DWORD *)(a4 + 12) + **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
        v6 = *(_DWORD *)(a4 + 20);
        if ( v6 <= 0x10 )
        {
          v5 = *(&dword_1005B628 + *(_WORD *)(a1 + 38));
          do
          {
            result = v5;
            *v7++ = v5;
            --v6;
          }
          while ( v6 );
        }
        else
        {
          result = (unsigned int)memset(v7, *(&dword_1005B628 + *(_WORD *)(a1 + 38)), v6);
        }
      }
    }
  }
  return result;
}

//----- (10008280) --------------------------------------------------------
int __cdecl sub_10008280(int a1, signed int a2, signed int a3)
{
  int result; // eax@1
  _BYTE *v4; // ST08_4@5
  unsigned int v5; // [sp+18h] [bp+Ch]@5

  result = a1;
  if ( *(_WORD *)(a1 + 26) <= a2 )
  {
    result = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30);
    if ( result > a2 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 24) <= a3 )
      {
        result = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28);
        if ( result > a3 )
        {
          *(_BYTE *)a1 = 1;
          v5 = 8 * a2;
          v4 = (_BYTE *)(**(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3));
          result = **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3);
          *v4 = ((unsigned __int64)*(_WORD *)(a1 + 38) << (v5 & 7)) | ~(unsigned __int8)(255i64 << (v5 & 7)) & *v4;
        }
      }
    }
  }
  return result;
}

//----- (10008370) --------------------------------------------------------
int __cdecl sub_10008370(int a1, signed int a2, int a3, int a4)
{
  int result; // eax@1
  _BYTE *v5; // [sp+Ch] [bp-4h]@2
  int v6; // [sp+18h] [bp+8h]@1

  *(_DWORD *)(a4 + 8) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 16) = a2 >> 16;
  *(_DWORD *)(a4 + 12) = a3;
  result = sub_10008470(a1, a4);
  v6 = result;
  if ( *(_DWORD *)(a4 + 4) )
  {
    v5 = (_BYTE *)((a3 & 0x1FFFFFFF)
                 + *(_DWORD *)(a4 + 16) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                 + **(_DWORD **)(result + 52));
    do
    {
      *v5;
      *v5 = *(_WORD *)(v6 + 38);
      v5 += *(_WORD *)(*(_DWORD *)(v6 + 52) + 10);
      result = *(_DWORD *)(a4 + 8) - 1;
      *(_DWORD *)(a4 + 8) = result;
    }
    while ( *(_DWORD *)(a4 + 8) > 0 );
  }
  return result;
}

//----- (10008470) --------------------------------------------------------
int __cdecl sub_10008470(int a1, int a2)
{
  int result; // eax@3

  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 28) = *(_WORD *)(a1 + 24) - *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 28) <= 0
    || (*(_DWORD *)(a2 + 16) += *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) -= *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) > 0) )
  {
    if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
    {
      if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16) <= *(_DWORD *)(a2 + 8) )
        *(_DWORD *)(a2 + 8) = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16);
      if ( (signed int)*(_WORD *)(a1 + 26) <= *(_DWORD *)(a2 + 12) )
      {
        if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
        {
          *(_DWORD *)(a2 + 28) &= ~(*(_DWORD *)(a2 + 28) >> 31);
          *(_BYTE *)a1 = 1;
          *(_DWORD *)(a2 + 4) = 1;
          result = a1;
        }
        else
        {
          result = a1;
        }
      }
      else
      {
        result = a1;
      }
    }
    else
    {
      result = a1;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (100085A0) --------------------------------------------------------
char *__cdecl sub_100085A0(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-30h]@1
  signed int v6; // [sp+Ch] [bp-24h]@1
  int v7; // [sp+10h] [bp-20h]@1
  int v8; // [sp+14h] [bp-1Ch]@1
  int v9; // [sp+20h] [bp-10h]@1
  int v10; // [sp+24h] [bp-Ch]@1
  char *v11; // [sp+28h] [bp-8h]@1
  int v12; // [sp+2Ch] [bp-4h]@1
  signed int v13; // [sp+3Ch] [bp+Ch]@1
  int v14; // [sp+3Ch] [bp+Ch]@4

  v11 = &v5;
  v8 = a2 & 0x7FFF;
  v6 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v8 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v13 = (a2 - *((_DWORD *)v11 + 5)) << 16;
  if ( v13 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v13 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v13 + 1;
  sub_10007DB0(a1, (int)v11);
  result = v11;
  if ( *(_DWORD *)v11 )
  {
    v14 = *((_DWORD *)v11 + 6) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v14 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v14 & 0x1F)));
    result = (char *)sub_10007ED0(a1, (int)v11);
  }
  return result;
}

//----- (100086E0) --------------------------------------------------------
char *__cdecl sub_100086E0(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-3Ch]@1
  int v6; // [sp+8h] [bp-34h]@1
  int v7; // [sp+Ch] [bp-30h]@1
  signed int v8; // [sp+10h] [bp-2Ch]@1
  int v9; // [sp+20h] [bp-1Ch]@1
  int v10; // [sp+24h] [bp-18h]@1
  char *v11; // [sp+28h] [bp-14h]@1
  int v12; // [sp+2Ch] [bp-10h]@1
  __int16 v13; // [sp+30h] [bp-Ch]@5
  char v14; // [sp+37h] [bp-5h]@6
  char *v15; // [sp+38h] [bp-4h]@4
  int v16; // [sp+44h] [bp+8h]@3
  signed int v17; // [sp+48h] [bp+Ch]@1
  int v18; // [sp+48h] [bp+Ch]@4
  unsigned int v19; // [sp+4Ch] [bp+10h]@4
  int v20; // [sp+4Ch] [bp+10h]@4

  v11 = &v5;
  v6 = a2 & 0x7FFF;
  v8 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v6 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v17 = (a2 - *((_DWORD *)v11 + 2)) << 16;
  if ( v17 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v17 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v17 + 1;
  v16 = sub_10008470(a1, (int)v11);
  result = v11;
  if ( *((_DWORD *)v11 + 1) )
  {
    v18 = *((_DWORD *)v11 + 7) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v18 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v18 & 0x1F)));
    v19 = 8 * a3;
    v15 = (char *)(**(_DWORD **)(v16 + 52) + (v19 >> 3) + *((_DWORD *)v11 + 4) * *(_WORD *)(*(_DWORD *)(v16 + 52) + 10));
    v20 = v19 & 7;
    do
    {
      v12 = 2 * *((_DWORD *)v11 + 8) & 3;
      *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v11[36] & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v11[36] & 0x1F)));
      v12 += v16 + 36;
      v13 = *(_WORD *)v12;
      if ( v13 >= 0 )
      {
        v14 = *v15;
        v13 <<= v20;
        v14 &= ~(unsigned __int8)(255 << v20);
        v14 |= v13;
        *v15 = v14;
      }
      v15 += *(_WORD *)(*(_DWORD *)(v16 + 52) + 10);
      --*((_DWORD *)v11 + 2);
      result = v11;
    }
    while ( *((_DWORD *)v11 + 2) );
  }
  return result;
}

//----- (10008930) --------------------------------------------------------
int __cdecl sub_10008930(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  unsigned int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int *v10; // [sp+10h] [bp-4h]@1

  v7 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 16) = v7 >> 1;
  *(_DWORD *)(a3 + 12) = a2 - (*(_DWORD *)(a3 + 16) * *(_WORD *)(a1 + 18) << 16);
  *(_DWORD *)(a3 + 16) = *(_WORD *)(a1 + 8) - *(_DWORD *)(a3 + 16);
  v9 = *(_WORD *)(a1 + 18) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = -256 * (8 * (*(_DWORD *)(a3 + 12) << 16 >> 31) + 4);
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v10 = *(int **)(a1 + 64);
  if ( v5 )
    v10 = (int *)((char *)v10 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_100085A0(a1, *(_DWORD *)(a3 + 12), *(_DWORD *)(a3 + 16), v10);
    else
      sub_10008170(a1, a2, *(_DWORD *)(a3 + 16), a3);
    ++*(_DWORD *)(a3 + 16);
    *(_DWORD *)(a3 + 12) += v9;
    result = (int)v10 + (v8 >> 8);
    v10 = (int *)((char *)v10 + (v8 >> 8));
    --v7;
  }
  while ( v7 );
  return result;
}

//----- (10008A70) --------------------------------------------------------
int __cdecl sub_10008A70(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int *v9; // [sp+Ch] [bp-8h]@1
  unsigned int v10; // [sp+10h] [bp-4h]@1

  v10 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 12) = v10 >> 1;
  *(_DWORD *)(a3 + 16) = a2 - (*(_DWORD *)(a3 + 12) * *(_WORD *)(a1 + 16) << 16);
  *(_DWORD *)(a3 + 12) = *(_WORD *)(a1 + 10) - *(_DWORD *)(a3 + 12);
  v7 = *(_WORD *)(a1 + 16) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = (8 * (*(_DWORD *)(a3 + 16) << 16 >> 31) + 4) << 8;
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v9 = *(int **)(a1 + 64);
  if ( v5 )
    v9 = (int *)((char *)v9 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_100086E0(a1, *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 12), v9);
    else
      sub_10008370(a1, a2, *(_DWORD *)(a3 + 12), a3);
    ++*(_DWORD *)(a3 + 12);
    *(_DWORD *)(a3 + 16) += v7;
    result = (int)v9 + (v8 >> 8);
    v9 = (int *)((char *)v9 + (v8 >> 8));
    --v10;
  }
  while ( v10 );
  return result;
}

//----- (10008BB0) --------------------------------------------------------
char __cdecl sub_10008BB0(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char result; // al@1
  char *v6; // edi@4
  signed int v7; // eax@4
  unsigned int v8; // ST1C_4@4
  int v9; // eax@4
  unsigned int v10; // ST18_4@4
  char *v11; // eax@4
  __int16 v12; // dx@4
  int v13; // ST10_4@4
  signed int v14; // eax@4
  __int16 v15; // dx@4
  int v16; // edx@4
  int v17; // eax@6
  int v18; // edi@7
  int v19; // ebx@7
  char *v20; // eax@7
  int v21; // [sp+8h] [bp-18h]@4
  int v22; // [sp+Ch] [bp-14h]@4
  int v23; // [sp+10h] [bp-10h]@4
  __int16 v24; // [sp+14h] [bp-Ch]@4
  int v25; // [sp+16h] [bp-Ah]@4
  int v26; // [sp+1Ch] [bp-4h]@4

  result = 1;
  if ( *a5 == 32802 )
  {
LABEL_4:
    v6 = sub_10017500(*a4);
    v7 = sub_1000E8F0(*(_DWORD *)(a2 + 4));
    v8 = *(_DWORD *)(a2 + 4);
    v22 = v7;
    v9 = sub_1000F1D0(v8, 0);
    v10 = *(_DWORD *)(a2 + 4);
    v23 = v9;
    v25 = sub_1000E880(v10);
    v11 = sub_1000E8B0(*(_DWORD *)(a2 + 4));
    v12 = *(_WORD *)(a2 + 8);
    v13 = *(_DWORD *)(a2 + 4);
    v21 = *(_DWORD *)v11;
    v24 = v12;
    v14 = sub_1000E920(v13);
    v15 = *(_WORD *)a3;
    v26 = v14;
    *(_WORD *)(a1 + 438) = v15;
    v16 = v21;
    *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
    sub_1000F230(a1, v6, &v21, *(_WORD *)(v16 + 30));
    return 2;
  }
  if ( *a5 != 32832 )
  {
    if ( *a5 != 32888 )
      return result;
    goto LABEL_4;
  }
  LOWORD(v17) = *(_WORD *)(a2 + 8);
  if ( (_WORD)v17 )
  {
    v17 = (signed __int16)v17;
  }
  else
  {
    v18 = sub_1000E8F0(*(_DWORD *)(a2 + 4));
    v19 = *(_DWORD *)sub_1000E8B0(*(_DWORD *)(a2 + 4));
    v20 = sub_10017500(*a4);
    v17 = sub_100062D0(v19, v20, v18);
  }
  sub_1000F440(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(a2 + 4), v17);
  return 2;
}

//----- (10008CE0) --------------------------------------------------------
void *__cdecl sub_10008CE0(int a1, __int16 a2)
{
  void *result; // eax@1

  result = memset((void *)(*(_DWORD *)(a1 + 56) + 69), 95, a2);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + a2 + 69) = 0;
  return result;
}

//----- (10008D10) --------------------------------------------------------
char __cdecl sub_10008D10(int a1, int a2, char *a3)
{
  char *v3; // edx@1
  _BYTE *v4; // eax@1
  char v5; // cl@2

  v3 = a3;
  v4 = (_BYTE *)(*(_DWORD *)(a1 + 56) + 69);
  do
  {
    v5 = *v3;
    *v4++ = *v3++;
  }
  while ( v5 );
  sub_10011B00((const char *)(*(_DWORD *)(a1 + 56) + 69), 32, 95);
  sub_10011AB0((const char *)(*(_DWORD *)(a1 + 56) + 69), *(_WORD *)(a2 + 10), 95);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = 0;
  return 4;
}

//----- (10008D70) --------------------------------------------------------
int __cdecl sub_10008D70(int a1, int a2, int a3, signed int a4, int a5)
{
  int v5; // edi@1
  unsigned int v6; // ecx@1
  char v7; // al@6
  int v8; // eax@8
  __int16 v9; // dx@8
  __int64 v10; // rax@9
  float v11; // ST10_4@9

  v5 = a1;
  v6 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(a1 + 4) & 0xC000 )
  {
    if ( (*(_DWORD *)(a1 + 4) & 0xC000) == 0x4000 )
      LOWORD(a1) = *(_WORD *)a2 + *(_WORD *)(a1 + 8);
    else
      LOWORD(a1) = *(_WORD *)a2 + *(_WORD *)(a1 + 8) / 2;
  }
  else
  {
    LOWORD(a1) = *(_WORD *)a2;
  }
  v7 = *(_BYTE *)(v5 + 15);
  if ( *(_BYTE *)(v5 + 15) & 6 )
  {
    if ( (*(_BYTE *)(v5 + 15) & 6) == 2 )
    {
      v10 = *(_WORD *)(a3 + 24) - *(_WORD *)(a3 + 26);
      v11 = 0.5 * (double)(a5 + 1);
      HIWORD(a1) = (signed int)((double)(*(_WORD *)(v5 + 12) / 2
                                       + (((signed int)v10 - HIDWORD(v10)) >> 1)
                                       + *(_WORD *)(a2 + 2)
                                       - 1)
                              + 0.5
                              + (1.0 - v11) * (double)a4);
      return a1;
    }
    v8 = sub_1000F1D0(v6, (v7 & 1) == 1);
    v9 = *(_WORD *)(a3 + 24) + *(_WORD *)(v5 + 12) - a4 * a5 - *(_WORD *)(a3 + 26);
  }
  else
  {
    v8 = sub_1000F1D0(v6, (v7 & 1) == 1);
    v9 = *(_WORD *)(a3 + 24) - *(_WORD *)(a3 + 26);
  }
  HIWORD(a1) = BYTE2(v8) + *(_WORD *)(a2 + 2) + v9 - 1;
  return a1;
}

//----- (10008EC0) --------------------------------------------------------
char __usercall sub_10008EC0@<al>(char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>)
{
  int v4; // eax@3
  int v5; // ecx@3
  char result; // al@4
  int v7; // eax@5
  int v8; // eax@7

  if ( *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) == -128 )
  {
    sub_10008D10(a4, a3, a1);
    sub_10008CE0(a4, *(_WORD *)(a3 + 10));
  }
  v4 = *(_DWORD *)(a4 + 56);
  v5 = *(_WORD *)(v4 + 240);
  if ( *(_WORD *)(a2 + 10) == 0x2000 )
  {
    *(_BYTE *)(v5 + v4 + 69) = *(_BYTE *)(a2 + 14);
    v7 = *(_DWORD *)(a4 + 56);
    if ( *(_BYTE *)(*(_WORD *)(v7 + 240) + v7 + 69) == 32 )
      *(_BYTE *)(*(_WORD *)(v7 + 240) + v7 + 69) = 95;
    ++*(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    v8 = *(_WORD *)(a3 + 10) - 1;
    if ( *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) < v8 )
      LOWORD(v8) = *(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) = v8;
    result = 2;
  }
  else
  {
    *(_BYTE *)(v5 + v4 + 69) = 95;
    --*(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) &= ((signed int)*(_WORD *)(*(_DWORD *)(a4 + 56) + 240) <= 0) - 1;
    result = 2;
  }
  return result;
}

//----- (10008F80) --------------------------------------------------------
char __usercall sub_10008F80@<al>(unsigned __int16 a1@<di>, int a2)
{
  char v2; // bl@1
  char v3; // al@1
  int v4; // esi@1
  int v5; // eax@1
  char result; // al@2

  v2 = 0;
  v3 = sub_10011A80(0, a1, 1);
  v4 = (unsigned __int8)v3;
  v5 = (unsigned __int8)sub_10011A80(v3, a1, 1);
  if ( v4 == a2 )
  {
    result = 1;
  }
  else
  {
    if ( v5 != v4 )
    {
      do
      {
        if ( v5 == a2 )
          v2 = 1;
        v5 = (unsigned __int8)sub_10011A80(v5, a1, 1);
      }
      while ( (unsigned __int8)v5 != v4 );
    }
    result = v2;
  }
  return result;
}

//----- (10008FE0) --------------------------------------------------------
signed int __usercall sub_10008FE0@<eax>(int a1@<edi>, unsigned __int16 a2@<si>, int a3)
{
  char v3; // bl@8
  signed int result; // eax@8
  char v5; // [sp+4h] [bp-4h]@0

  if ( (signed int)a2 <= 177 )
  {
    if ( a2 != 177 )
    {
      switch ( a2 )
      {
        case 0x51u:
        case 0x91u:
          goto LABEL_8;
        case 0x10u:
        case 0x14u:
          goto LABEL_9;
        case 0x92u:
          goto LABEL_11;
        default:
          goto LABEL_12;
      }
      goto LABEL_12;
    }
LABEL_8:
    v3 = 65;
    LOBYTE(result) = sub_10011A80(65, a2, -1);
    goto LABEL_13;
  }
  if ( (signed int)a2 > 528 )
  {
    if ( a2 != 1043 )
      goto LABEL_12;
LABEL_11:
    v3 = 97;
    LOBYTE(result) = sub_10011A80(97, a2, -1);
    goto LABEL_13;
  }
  if ( a2 == 528 )
  {
LABEL_9:
    v3 = 48;
    LOBYTE(result) = sub_10011A80(48, a2, -1);
    goto LABEL_13;
  }
  if ( a2 == 178 )
    goto LABEL_11;
  if ( a2 == 273 )
    goto LABEL_8;
LABEL_12:
  v3 = v5;
  LOBYTE(result) = sub_10011A80(v5, a2, -1);
LABEL_13:
  if ( a3 == 95 )
  {
    if ( a1 > 0 )
      return (unsigned __int8)v3;
  }
  else
  {
    if ( a3 == (unsigned __int8)v3 && a1 < 0 || a3 == (unsigned __int8)result && a1 > 0 )
      return 95;
    do
    {
      LOBYTE(result) = sub_10011A80(a3, a2, a1);
      LOBYTE(a3) = result;
    }
    while ( (_BYTE)result == 95 );
  }
  return (unsigned __int8)result;
}

//----- (10009140) --------------------------------------------------------
signed int __cdecl sub_10009140(int a1, int a2, signed int a3)
{
  __int16 v3; // si@1
  signed int result; // eax@1
  int v5; // edi@1
  int v6; // ebx@2
  bool v7; // zf@2

  v3 = sub_100109E0(*(_DWORD *)(a2 + 4));
  result = a3;
  v5 = 2 * (a3 >= 0) - 1;
  if ( a3 )
  {
    do
    {
      v6 = *(_DWORD *)(a1 + 56);
      result = sub_10008FE0(v5, v3, *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69));
      v7 = a3 == v5;
      a3 -= v5;
      *(_BYTE *)(*(_WORD *)(v6 + 240) + v6 + 69) = result;
    }
    while ( !v7 );
  }
  return result;
}

//----- (100091A0) --------------------------------------------------------
char __cdecl sub_100091A0(int a1, int a2, int a3, char *a4)
{
  int v4; // esi@1
  char v5; // bl@1
  bool v6; // zf@1
  signed int v7; // eax@3
  unsigned int v8; // ST24_4@3
  int v9; // eax@3
  int v10; // ST1C_4@3
  __int16 v11; // ax@3
  int v12; // eax@6
  int v13; // eax@6
  char *v14; // ebx@6
  bool v15; // al@9
  int v16; // eax@11
  int v17; // eax@13
  int v18; // eax@13
  int v19; // ST1C_4@18
  int v21; // [sp+10h] [bp-28h]@1
  int v22; // [sp+14h] [bp-24h]@1
  int v23; // [sp+18h] [bp-20h]@1
  int v24; // [sp+1Ch] [bp-1Ch]@6
  int v25; // [sp+20h] [bp-18h]@3
  int v26; // [sp+24h] [bp-14h]@3
  int v27; // [sp+28h] [bp-10h]@3
  __int16 v28; // [sp+2Ch] [bp-Ch]@5
  int v29; // [sp+2Eh] [bp-Ah]@3
  int v30; // [sp+34h] [bp-4h]@3
  int v31; // [sp+40h] [bp+8h]@13

  v4 = a2;
  v5 = 0;
  v6 = *(_BYTE *)a2 == 124;
  LOBYTE(v23) = 0;
  v21 = 0;
  v22 = 0;
  if ( v6 )
  {
    v5 = *(_BYTE *)(a2 + 14);
    LOBYTE(v23) = (*(_BYTE *)(a2 + 15) & 1) == 1;
  }
  v25 = sub_1000E8D0(*(_DWORD *)(a2 + 4));
  v7 = sub_1000E8F0(*(_DWORD *)(a2 + 4));
  v8 = *(_DWORD *)(a2 + 4);
  v26 = v7;
  v27 = sub_1000F1D0(v8, v23);
  v9 = sub_1000E880(*(_DWORD *)(a2 + 4));
  v10 = *(_DWORD *)(a2 + 4);
  v29 = v9;
  v30 = sub_1000E920(v10);
  v11 = *(_WORD *)(a2 + 8);
  if ( !v11 )
    v11 = sub_100062D0(v25, a4, v26);
  v6 = *(_BYTE *)a2 == 124;
  v28 = v11;
  if ( v6 )
  {
    sub_1000F510(a4, *(_DWORD *)(a2 + 4), *(_BYTE *)(a2 + 14), (int)&v24, (int)&v22);
    v23 = v5;
    v12 = sub_10010000(a4, v25, v27, *(_WORD *)(a2 + 12), v5, &v21);
    v13 = sub_100027E0(a1, v12);
    v14 = (char *)v13;
    if ( v21 > 0 )
    {
      v15 = !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128;
      v16 = sub_10010070((int)a4, v25, 0, *(_WORD *)(a2 + 8), v21, v15, v14);
      v22 = v16;
      if ( v16 == -1 )
      {
        v16 = v21;
        v22 = v21;
      }
      v17 = sub_10008D70(a2, a3, v25, v24, v16);
      v6 = *(_BYTE *)(a1 + 3) == 0;
      v31 = v17;
      v18 = v29;
      *(_WORD *)(a1 + 396) = 3;
      if ( !v6 && *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 && (byte_101A5AB6 || byte_101D7CC0) )
      {
        *(_WORD *)(a1 + 428) = HIWORD(v18);
        *(_WORD *)(a1 + 430) = v29;
        v18 = *(_DWORD *)(a1 + 428);
      }
      *(_WORD *)(a1 + 440) = v18;
      *(_WORD *)(a1 + 442) = v18;
      sub_100074B0(a1 + 392, *(_WORD *)a3 - 1, *(_WORD *)(a3 + 2), *(_WORD *)(v4 + 8) + 2, *(_WORD *)(v4 + 12));
      v19 = v23;
      *(_WORD *)(a1 + 438) = v31;
      *(_WORD *)(a1 + 436) = HIWORD(v31);
      LOBYTE(v13) = sub_1000F230(a1, v14, &v25, v19);
    }
    if ( v14 )
      LOBYTE(v13) = sub_10002440(a1, (unsigned int)v14);
  }
  else
  {
    *(_WORD *)(a1 + 438) = *(_WORD *)a3;
    *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
    LOBYTE(v13) = sub_1000F190(a1, a4, &v25);
  }
  return v13;
}
// 101A5AB6: using guessed type char byte_101A5AB6;
// 101D7CC0: using guessed type char byte_101D7CC0;

//----- (10009400) --------------------------------------------------------
char __cdecl sub_10009400(int a1, int a2, int a3, char *a4)
{
  int v4; // ebp@1
  signed __int16 v5; // di@1
  int v6; // ecx@1
  int v7; // eax@1
  int v8; // ecx@4
  char v9; // bl@4
  char result; // al@10
  char v11; // bl@11
  char v12; // al@13
  int v13; // eax@18
  int v14; // eax@19
  int v15; // eax@24
  int v16; // [sp+18h] [bp+8h]@1

  v4 = a2;
  LOWORD(v7) = sub_100109E0(*(_DWORD *)(a2 + 4));
  v5 = *(_WORD *)(a3 + 14);
  v6 = (unsigned __int16)v7;
  LOWORD(v7) = *(_WORD *)(a3 + 10);
  v16 = v6;
  if ( (_WORD)v7 == 0x2000 && v5 == 32 )
    v5 = 95;
  v8 = *(_DWORD *)(a1 + 56);
  v9 = 1;
  if ( *(_WORD *)(v8 + 240) == -128 )
  {
    if ( !(*(_DWORD *)(v4 + 4) & 0x200000) )
    {
      v7 = (unsigned __int16)v7;
      if ( (signed int)(unsigned __int16)v7 <= 73 )
      {
        if ( (unsigned __int16)v7 != 73 )
        {
          if ( v7 == 32 )
          {
            v11 = sub_10008D10(a1, v4, a4);
            sub_10008CE0(a1, *(_WORD *)(v4 + 10));
            return v11;
          }
          if ( v7 == 56 )
            return sub_10008D10(a1, v4, a4);
          return v9;
        }
        return sub_10008EC0(a4, a3, v4, a1);
      }
      if ( v7 == 0x2000 )
      {
        v12 = sub_10008F80(v16, (unsigned __int16)v5);
        goto LABEL_14;
      }
    }
    return v9;
  }
  v7 = (unsigned __int16)v7;
  if ( (signed int)(unsigned __int16)v7 > 57 )
  {
    if ( v7 == 73 )
      return sub_10008EC0(a4, a3, v4, a1);
    if ( v7 == 0x2000 )
    {
      v12 = sub_10008F80(v16, (unsigned __int16)v5);
LABEL_14:
      if ( v12 )
        return sub_10008EC0(a4, a3, v4, a1);
    }
    return v9;
  }
  if ( (unsigned __int16)v7 != 57 )
  {
    v13 = v7 - 32;
    if ( !v13 )
    {
      result = 6;
      *(_WORD *)(v8 + 240) = -128;
      return result;
    }
    v14 = v13 - 1;
    if ( !v14 )
    {
      *(_WORD *)(v8 + 240) = -128;
      sub_10011B00((const char *)(*(_DWORD *)(a1 + 56) + 69), 95, 32);
      sub_10011CE0(*(_DWORD *)(a1 + 56) + 69, 0);
      return 3;
    }
    if ( v14 == 23 )
    {
      sub_10009140(a1, v4, *(_BYTE *)(a3 + 8));
      return 2;
    }
    return v9;
  }
  *(_WORD *)(v8 + 240) += *(_BYTE *)(a3 + 8);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) &= ((signed int)*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) <= 0) - 1;
  v15 = *(_WORD *)(v4 + 10) - 1;
  if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v15 )
    LOWORD(v15) = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = v15;
  return 2;
}

//----- (100095F0) --------------------------------------------------------
char __cdecl sub_100095F0(int a1, int a2, int a3, char *a4, int a5)
{
  int v5; // esi@1
  __int16 v6; // ax@1
  char *v7; // edi@1
  __int16 v8; // bx@3
  int v9; // ebp@3
  __int16 v10; // di@5
  int v11; // eax@5
  char result; // al@5
  char *v13; // eax@10
  char *v14; // edx@10
  char v15; // cl@11
  int v16; // ecx@14
  char v17; // [sp+13h] [bp-5h]@1
  int v18; // [sp+14h] [bp-4h]@5

  v5 = a2;
  v6 = *(_WORD *)(a2 + 8);
  v7 = a4;
  v17 = 1;
  if ( !v6 )
    v6 = sub_1000EEE0(a4, *(_DWORD *)(a2 + 4));
  v8 = v6;
  v9 = *(_DWORD *)sub_1000E8B0(*(_DWORD *)(v5 + 4));
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      if ( *(_BYTE *)v5 == 124 )
      {
        v10 = sub_1000F510(v7, *(_DWORD *)(v5 + 4), *(_BYTE *)(v5 + 14), (int)&v18, (int)&a2);
        v11 = sub_10008D70(v5, a3, v9, v18, a2);
        sub_1000F440(a1 + 276, v11, *(_DWORD *)(v5 + 4), v8);
        *(_WORD *)(a1 + 282) = v10 + *(_WORD *)(a1 + 278);
        result = 2;
      }
      else
      {
        sub_1000F440(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(v5 + 4), v8);
        result = 2;
      }
      break;
    case 0x8048:
      v17 = sub_10009400(a1, v5, a5, v7);
      switch ( v17 )
      {
        case 2:
        case 4:
          sub_100091A0(a1, v5, a3, (char *)(*(_DWORD *)(a1 + 56) + 69));
          result = v17;
          break;
        case 6:
          sub_100091A0(a1, v5, a3, v7);
          result = v17;
          break;
        case 3:
          v13 = (char *)(*(_DWORD *)(a1 + 56) + 69);
          v14 = v7;
          do
          {
            v15 = *v13;
            *v14++ = *v13++;
          }
          while ( v15 );
          sub_100091A0(a1, v5, a3, v7);
          result = v17;
          break;
        default:
          goto LABEL_18;
      }
      break;
    case 0x8022:
    case 0x8078:
      if ( *(_BYTE *)(a1 + 3) && (v16 = *(_DWORD *)(a1 + 56), *(_WORD *)(v16 + 240) != -128) )
        sub_100091A0(a1, v5, a3, (char *)(v16 + 69));
      else
        sub_100091A0(a1, v5, a3, v7);
      v17 = 2;
      goto LABEL_18;
    default:
LABEL_18:
      result = v17;
      break;
  }
  return result;
}

//----- (10009850) --------------------------------------------------------
char __cdecl sub_10009850(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1
  __int16 v6; // cx@4
  unsigned int v7; // eax@4
  __int16 v8; // cx@4
  int v9; // eax@4
  int v10; // ecx@8
  __int16 v11; // bp@8
  __int16 *v12; // ebx@9
  char v13; // dl@10
  __int16 v14; // ax@14
  __int16 v15; // cx@16
  int v16; // [sp+4h] [bp-14h]@9
  __int16 v17; // [sp+8h] [bp-10h]@4
  __int16 v18; // [sp+Ch] [bp-Ch]@4
  __int16 v19; // [sp+Eh] [bp-Ah]@4
  __int16 v20; // [sp+10h] [bp-8h]@4
  __int16 v21; // [sp+12h] [bp-6h]@4
  __int16 v22; // [sp+14h] [bp-4h]@4
  __int16 v23; // [sp+16h] [bp-2h]@4
  int v24; // [sp+2Ch] [bp+14h]@9

  result = 1;
  if ( *a5 != 32802 )
  {
    if ( *a5 == 32832 )
    {
      *(_WORD *)(a1 + 276) = *(_WORD *)a3;
      *(_WORD *)(a1 + 278) = *(_WORD *)(a3 + 2);
      *(_WORD *)(a1 + 280) = *(_WORD *)a3 + *(_WORD *)(a2 + 4) - 1;
      result = 2;
      *(_WORD *)(a1 + 282) = *(_WORD *)(a3 + 2) + *(_WORD *)(a2 + 6) - 1;
      return result;
    }
    if ( *a5 != 32888 )
      return result;
  }
  v18 = word_1010F158[1];
  v19 = word_1010F158[0];
  v20 = word_1010F158[0];
  v21 = word_1010F158[0];
  v22 = word_1010F158[0];
  v6 = word_1010F158[(unsigned __int8)sub_10017570(15)];
  v7 = *(_WORD *)(a2 + 8);
  v23 = v6;
  v8 = v7;
  v9 = ((v7 >> 12) & 3) + 1;
  *(_WORD *)(a1 + 426) = v9;
  *(_WORD *)(a1 + 424) = v9;
  v17 = v8 & 0xC00;
  if ( (*(_WORD *)(a2 + 8) & 0xC000) == -32768 )
  {
    *(_WORD *)(a1 + 398) = 1;
    *(_DWORD *)(a1 + 452) = &unk_10054450;
    *(_WORD *)(a1 + 440) = 0;
    *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
  }
  else
  {
    *(_WORD *)(a1 + 440) = *(_WORD *)(a4 + 2);
    *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
    *(_WORD *)(a1 + 398) = 3;
  }
  v10 = 3 - v9;
  v11 = 0;
  if ( 3 - v9 < 3 )
  {
    v24 = v10 + 1;
    v12 = &v18 + 2 * v10;
    v16 = 3 - v10;
    do
    {
      v13 = 2;
      if ( v24 >= 3 && (*(_WORD *)(a2 + 8) & 0xC000) != 0x4000 )
        v13 = 3;
      if ( v17 == 2048 )
      {
        *(_WORD *)(a1 + 428) = *(_WORD *)a4;
        v14 = *(_WORD *)a4;
      }
      else
      {
        if ( v17 )
        {
          v15 = v12[1];
          v14 = *v12;
        }
        else
        {
          v15 = *v12;
          v14 = v12[1];
        }
        *(_WORD *)(a1 + 428) = v15;
      }
      *(_WORD *)(a1 + 430) = v14;
      sub_1004FFD0(
        a1 + 392,
        v11 + *(_WORD *)a3,
        v11 + *(_WORD *)(a3 + 2),
        *(_WORD *)(a2 + 4) - 2 * v11,
        *(_WORD *)(a2 + 6) - 2 * v11,
        v13);
      ++v24;
      v12 += 2;
      ++v11;
      --v16;
    }
    while ( v16 );
  }
  return 2;
}
// 1010F158: using guessed type __int16 word_1010F158[];

//----- (10009A80) --------------------------------------------------------
char __cdecl sub_10009A80(int a1, int a2, int a3, _BYTE *a4, _WORD *a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  char v7; // ST10_1@2
  __int16 v8; // cx@2
  __int16 v9; // ax@2
  __int16 v11; // [sp+10h] [bp-14h]@4
  __int16 v12; // [sp+12h] [bp-12h]@4
  int v13; // [sp+14h] [bp-10h]@1
  int v14; // [sp+18h] [bp-Ch]@1
  int v15; // [sp+1Ch] [bp-8h]@1

  v5 = *(_DWORD *)(a2 + 8);
  v6 = *(_DWORD *)(a2 + 4);
  v13 = *(_DWORD *)a2;
  v14 = v6;
  v15 = v5;
  if ( (_WORD)v5 == -1 )
  {
    v7 = *a4 & 0x1F;
    LOWORD(v15) = *(_WORD *)a4;
    v8 = word_1010F158[(unsigned __int8)sub_10017570(v7)];
    v9 = word_1010F158[((unsigned int)*(_WORD *)a4 >> 5) & 0x1F];
  }
  else
  {
    v8 = word_1010F158[(unsigned __int8)sub_10017570(v5 & 0x1F)];
    v9 = word_1010F158[((unsigned int)*(_WORD *)(a2 + 8) >> 5) & 0x1F];
  }
  v11 = v8;
  v12 = v9;
  return sub_10009850(a1, (int)&v13, a3, (int)&v11, a5);
}
// 1010F158: using guessed type __int16 word_1010F158[];

//----- (10009B60) --------------------------------------------------------
int __cdecl sub_10009B60(unsigned int a1, char a2, int a3, int a4)
{
  int result; // eax@1

  result = a3 * byte_101D8171[20 * ((a1 >> 10) & 0xF)]
         + (a3 - 1) * *(_WORD *)(dword_101D8164[5 * ((a1 >> 10) & 0xF)] + 28);
  if ( a4 > 0 )
  {
    if ( a2 & 0x80 )
      result += *((_BYTE *)&unk_101D8160 + 20 * ((a1 >> 10) & 0xF) + 15) - byte_101D8171[20 * ((a1 >> 10) & 0xF)];
  }
  return result;
}
// 101D8164: using guessed type int dword_101D8164[];

//----- (10009BC0) --------------------------------------------------------
char __cdecl sub_10009BC0(int a1, int a2, int a3, double *a4)
{
  int v4; // esi@1
  bool v5; // zf@1
  unsigned int v6; // ecx@1
  int v7; // eax@1
  __int16 v8; // bx@1
  double v9; // st7@3
  __int16 v10; // cx@5
  __int16 v11; // cx@5
  int v12; // ebx@8
  size_t v13; // edi@9
  int v14; // eax@9
  int v15; // edx@14
  __int16 v16; // ax@14
  float v17; // ST4C_4@20
  char *v18; // edi@27
  char v19; // al@28
  char *v20; // edi@30
  char v21; // al@31
  char v22; // al@33
  char *v23; // eax@35
  char v24; // cl@36
  signed int v25; // ecx@37
  char v26; // cl@38
  int v27; // ecx@40
  int v28; // edi@43
  int i; // eax@47
  char v30; // dl@50
  signed int v31; // ecx@52
  char v32; // al@53
  int v33; // eax@63
  signed int v34; // ebx@69
  signed int v35; // eax@69
  unsigned int v36; // ST18_4@71
  char *v37; // eax@71
  int v38; // edi@80
  unsigned int v39; // ebx@80
  __int16 v40; // ax@80
  bool v42; // [sp+2Fh] [bp-59h]@21
  int v43; // [sp+30h] [bp-58h]@1
  int v44; // [sp+30h] [bp-58h]@14
  int v45; // [sp+34h] [bp-54h]@1
  char *v46; // [sp+38h] [bp-50h]@14
  char v47; // [sp+3Ch] [bp-4Ch]@71
  char v48; // [sp+3Dh] [bp-4Bh]@71
  char v49; // [sp+3Eh] [bp-4Ah]@71
  int v50; // [sp+40h] [bp-48h]@3
  int v51; // [sp+44h] [bp-44h]@1
  int v52; // [sp+48h] [bp-40h]@1
  int v53; // [sp+4Ch] [bp-3Ch]@1
  double v54; // [sp+50h] [bp-38h]@5
  char v55[2]; // [sp+58h] [bp-30h]@21
  char v56; // [sp+63h] [bp-25h]@12
  char v57; // [sp+64h] [bp-24h]@9
  char v58; // [sp+65h] [bp-23h]@64

  v4 = a2;
  v5 = *(_BYTE *)a2 == 89;
  v45 = *(_BYTE *)(a2 + 10);
  v6 = *(_WORD *)(a2 + 8);
  v53 = a1;
  v7 = *(_BYTE *)(a2 + 11);
  v8 = v6;
  v52 = a2;
  v51 = (unsigned __int16)v6;
  v43 = v7;
  if ( v5 && 9.899999762399947e24 != *a4 )
  {
    *(float *)&v50 = *a4;
    v9 = sub_10018170(v50, v6);
  }
  else
  {
    *(float *)&v50 = 9.8999998e24;
    v9 = *a4;
  }
  v10 = *(_WORD *)(a2 + 8);
  v54 = v9;
  v11 = v10 & 0x3F;
  if ( v11 == 28 )
  {
    if ( v9 > 1.0 || v9 < 0.0 )
    {
LABEL_8:
      v12 = v53;
LABEL_9:
      v13 = *(_BYTE *)(v4 + 10);
      memset(&v57, 95, v13);
      v14 = v43;
      if ( v43 > 0 )
      {
        if ( (signed int)(v13 - v43) <= 1 )
          v14 = v13 - 2;
        *(&v56 + v13 - v14) = 46;
      }
      *(&v57 + v13) = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( v9 >= 1.0e25 )
      goto LABEL_8;
    if ( v9 <= -1.0e25 )
      goto LABEL_8;
    if ( 9.899999762399947e24 == v9 )
      goto LABEL_8;
    v17 = v9;
    if ( v17 == 9.8999998e24 )
      goto LABEL_8;
  }
  v42 = 1;
  strcpy(v55, "%");
  if ( v8 & 0x800 || v8 & 0x40 || v11 == 27 || v11 == 28 )
  {
    ++v45;
    v18 = (char *)&v54 + 7;
    do
      v19 = (v18++)[1];
    while ( v19 );
    *(_WORD *)v18 = 43;
  }
  else if ( v11 == 7 )
  {
    ++v45;
  }
  v20 = (char *)&v54 + 7;
  if ( v8 & 0x100 )
  {
    do
      v21 = (v20++)[1];
    while ( v21 );
    *(_WORD *)v20 = 48;
  }
  else
  {
    do
      v22 = (v20++)[1];
    while ( v22 );
    *(_WORD *)v20 = 45;
  }
  v23 = (char *)&v54 + 7;
  if ( v11 == 7 )
  {
    do
      v24 = (v23++)[1];
    while ( v24 );
    v25 = 1697263146;
  }
  else
  {
    do
      v26 = (v23++)[1];
    while ( v26 );
    v25 = 1714040362;
  }
  *(_DWORD *)v23 = v25;
  v27 = *(_BYTE *)(a2 + 10);
  v23[4] = 0;
  v12 = _snprintf(&v57, 0x1Eu, v55, v27, *(_BYTE *)(a2 + 11), LODWORD(v9), (_DWORD)(*(unsigned __int64 *)&v9 >> 32));
  if ( v12 > v45 )
  {
    v42 = 0;
    if ( !(v51 & 0x80) && v43 > 0 )
    {
      v28 = v43;
      do
      {
        if ( v42 )
          break;
        v12 = sprintf(&v57, v55, *(_BYTE *)(a2 + 10), --v28, v54);
        v42 = v12 <= v45;
      }
      while ( v28 > 0 );
      v43 = v28;
    }
  }
  for ( i = v12 - 1; i >= 0; --i )
  {
    if ( *(&v57 + i) != 32 )
      break;
    *(&v57 + i) = 0;
    --v12;
  }
  v30 = 1;
  if ( v57 == 45 || v57 == 43 )
  {
    v31 = 1;
    if ( v12 <= 1 )
      goto LABEL_89;
    do
    {
      v32 = *(&v57 + v31);
      if ( v32 != 46 && v32 != 48 && v32 != 101 && v32 != 43 )
      {
        v30 = 0;
        v31 = v12;
      }
      ++v31;
    }
    while ( v31 < v12 );
    if ( v30 )
    {
LABEL_89:
      if ( (*(_WORD *)(a2 + 8) & 0x3F) == 17 && *(_WORD *)(a2 + 8) & 0x40 )
      {
        v57 = 43;
      }
      else
      {
        --v12;
        v33 = 0;
        if ( v12 > 0 )
        {
          qmemcpy(&v57, &v58, v12);
          v4 = v52;
          v33 = v12;
        }
        *(&v57 + v33) = 0;
      }
    }
  }
  if ( !v42 )
    goto LABEL_9;
LABEL_14:
  v46 = sub_10017730(*(_WORD *)(v4 + 8), (float *)&v50);
  v15 = (signed __int16)sub_1000EF40(*(_DWORD *)(v4 + 4), *(_WORD *)(v4 + 8), (float *)&v50);
  v16 = *(_WORD *)(v4 + 8) & 0x3F;
  v44 = v15;
  if ( v16 == 27 )
  {
    if ( v57 == 45 )
    {
      v57 = -100;
    }
    else if ( v57 == 43 )
    {
      --v45;
      v34 = v12 - 1;
      v35 = 0;
      if ( v34 > 0 )
      {
        qmemcpy(&v57, &v58, v34);
        v4 = v52;
        v35 = v34;
      }
      *(&v57 + v35) = 0;
      v36 = *(_DWORD *)(v4 + 4);
      v47 = *v46;
      v48 = -99;
      v49 = 0;
      v46 = &v47;
      v37 = sub_1000E8B0(v36);
      v44 += sub_100062D0(*((_DWORD *)v37 + 1), "", 0);
    }
  }
  else if ( v16 == 28 && !strncmp(&v57, "+0.", 3u) )
  {
    strncpy(&v57, "M ", 2u);
  }
  if ( v51 & 0x800 )
  {
    if ( v57 == 45 )
    {
      v57 = -92;
    }
    else if ( v57 == 43 )
    {
      v57 = -93;
    }
  }
  v38 = v53;
  *(_WORD *)(v53 + 438) = *(_WORD *)a3;
  *(_WORD *)(v38 + 436) = *(_WORD *)(a3 + 2);
  v39 = *(_DWORD *)(v4 + 4);
  v40 = *(_WORD *)(v4 + 12);
  if ( (*(_DWORD *)(v4 + 4) & 0xC000) != 0x4000 )
  {
    if ( ~(unsigned __int8)(*(_WORD *)(v4 + 8) >> 9) & 1 )
    {
      v40 -= v44;
      if ( v44 > 0 )
        v40 -= *(_WORD *)(dword_101D8164[5 * ((v39 >> 10) & 0xF)] + 28);
    }
  }
  if ( !*(_WORD *)(v4 + 12) )
    v40 = sub_10009B60(v39, *(_WORD *)(v4 + 8), v45, *(_BYTE *)(v4 + 11));
  return sub_1000F5A0(v38, &v57, v46, v40, v44, v39, v51);
}
// 101D8164: using guessed type int dword_101D8164[];

//----- (1000A0C0) --------------------------------------------------------
char __usercall sub_1000A0C0@<al>(float *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4)
{
  int v4; // ebp@1
  double v5; // st7@4
  double v6; // st7@6
  __int16 v7; // ax@6
  const char *v8; // esi@8
  int v10; // [sp+14h] [bp+4h]@6
  float v11; // [sp+14h] [bp+4h]@12

  v4 = a4;
  if ( *a1 >= 1.0e25 || *a1 <= -1.0e25 || 9.8999998e24 == *a1 )
    v5 = 0.0;
  else
    v5 = *a1;
  *(float *)&v10 = v5;
  v6 = sub_10018170(v10, *(_WORD *)(a2 + 8));
  v7 = *(_WORD *)(a2 + 8);
  if ( v7 & 0x40 )
  {
    if ( (v7 & 0x3F) == 7 )
      v8 = "%+0*.*e";
    else
      v8 = "%+0*.*f";
  }
  else
  {
    v8 = "%0*.*e";
    if ( (v7 & 0x3F) != 7 )
      v8 = "%0*.*f";
  }
  v11 = v6;
  if ( sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v8, a3, *(_BYTE *)(a2 + 11), v11) > a3 )
    sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v8, a3, *(_BYTE *)(a2 + 11), 0.0);
  *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = 0;
  return 4;
}

//----- (1000A1A0) --------------------------------------------------------
char __usercall sub_1000A1A0@<al>(int a1@<eax>, int a2, int a3, int a4)
{
  int v4; // esi@1
  __int16 v5; // ax@1
  int v6; // edi@1
  __int16 v7; // ax@2
  int v8; // ecx@8
  const char *v9; // ecx@11
  char v10; // bl@11
  char *v11; // eax@11
  char v12; // dl@11
  char v13; // cl@12
  const char *v14; // edx@14
  char *v15; // eax@14
  char v16; // di@14
  char v17; // cl@15
  char v18; // bl@16
  char *v19; // eax@16
  char v20; // dl@16
  char v21; // cl@17
  unsigned __int16 v22; // ax@20
  int v23; // ecx@22
  signed __int16 v24; // di@22
  char *v25; // eax@25
  char v26; // dl@26
  char v27; // bl@27
  char *v28; // eax@27
  char v29; // dl@27
  char v30; // cl@28
  int v31; // ecx@32
  unsigned __int8 v32; // al@32
  char *v33; // eax@36
  char v34; // dl@37
  char v35; // bl@38
  char *v36; // eax@38
  char v37; // dl@38
  char v38; // cl@39
  const char *v39; // ecx@42
  char v40; // bl@42
  char *v41; // eax@42
  char v42; // dl@42
  char v43; // cl@43
  int v44; // eax@47
  unsigned __int16 v45; // ax@53
  const char *v46; // ecx@59
  char v47; // bl@59
  char *v48; // eax@59
  char v49; // dl@59
  char v50; // cl@60
  int v51; // edx@62
  char v52; // al@64
  int v53; // ebp@64
  bool v54; // zf@71
  bool v55; // sf@71
  char *v56; // eax@72
  int v57; // edi@72
  char v58; // dl@73
  char v59; // bl@74
  char *v60; // eax@74
  char v61; // dl@74
  char v62; // cl@75
  int v63; // ecx@81
  unsigned __int8 v64; // al@81
  char *v65; // eax@85
  char v66; // dl@86
  char v67; // bl@87
  char *v68; // eax@87
  char v69; // dl@87
  char v70; // cl@88
  const char *v71; // ecx@93
  char v72; // kr00_1@93
  char *v73; // eax@93
  char v74; // dl@93
  char v75; // cl@94
  signed int v76; // eax@96
  char *v77; // eax@104
  int v78; // edi@104
  char v79; // dl@105
  char v80; // bl@106
  char *v81; // eax@106
  char v82; // dl@106
  char v83; // cl@107
  char *v84; // eax@116
  int v85; // edi@116
  char v86; // dl@117
  char v87; // bl@118
  char *v88; // eax@118
  char v89; // dl@118
  char v90; // cl@119
  char *v91; // eax@122
  int v92; // edi@122
  char v93; // dl@123
  char v94; // bl@124
  char *v95; // eax@124
  char v96; // dl@124
  char v97; // cl@125
  int v98; // ecx@126
  const char *v99; // edx@127
  char *v100; // eax@127
  char v101; // di@127
  char v102; // cl@128
  char v103; // bl@129
  char *v104; // eax@129
  char v105; // di@129
  char v106; // cl@130
  char *v107; // eax@131
  int v108; // ecx@131
  char v109; // dl@132
  char v110; // bl@133
  char *v111; // eax@133
  char v112; // dl@133
  char v113; // cl@134
  int v114; // ebp@142
  int v115; // ecx@147
  const char *v116; // edx@152
  char *v117; // eax@152
  char v118; // di@152
  char v119; // cl@153
  char v120; // bl@154
  char *v121; // eax@154
  char v122; // dl@154
  char v123; // cl@155
  int v124; // edx@158
  signed int v125; // eax@158
  char *v126; // eax@165
  int v127; // edi@165
  char v128; // dl@166
  char v129; // bl@167
  char *v130; // eax@167
  char v131; // dl@167
  char v132; // cl@168
  int v133; // eax@170
  char v135; // [sp+1Bh] [bp-Dh]@1
  float v136; // [sp+1Ch] [bp-Ch]@1
  char *v137; // [sp+20h] [bp-8h]@3
  int v138; // [sp+24h] [bp-4h]@1
  __int32 v139; // [sp+2Ch] [bp+4h]@71
  float v140; // [sp+2Ch] [bp+4h]@76

  v4 = a1;
  v136 = 0.0;
  v5 = *(_WORD *)(a2 + 8);
  v6 = a4;
  v135 = 1;
  v138 = 1;
  if ( v5 & 0x40 )
  {
    v7 = v5 & 0x3F;
    if ( v7 == 7 )
      v137 = "%+0*.*e";
    else
      v137 = "%+0*.*f";
  }
  else
  {
    v7 = v5 & 0x3F;
    v137 = "%0*.*e";
    if ( v7 != 7 )
      v137 = "%0*.*f";
  }
  if ( *(_WORD *)(a4 + 10) == 84 )
  {
    v8 = *(_DWORD *)(v4 + 56);
    if ( *(_WORD *)(v8 + 240) == -128 )
    {
      *(_WORD *)(a4 + 14) = 45;
    }
    else
    {
      if ( v7 != 7 )
        goto LABEL_176;
      v9 = (const char *)(v8 + 69);
      v10 = strlen(v9);
      v11 = strchr(v9, 101);
      v12 = (_BYTE)v11 + 1;
      do
        v13 = *v11++;
      while ( v13 );
      v8 = *(_DWORD *)(v4 + 56);
      if ( *(_WORD *)(v8 + 240) <= (signed __int16)(char)(v10 - ((_BYTE)v11 - v12)) )
      {
LABEL_176:
        v6 = a4;
        *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)(v8 + 69) != 45) + 43;
      }
      else
      {
        v14 = (const char *)(v8 + 69);
        v15 = (char *)(v8 + 69);
        v16 = v8 + 70;
        do
          v17 = *v15++;
        while ( v17 );
        v18 = (_BYTE)v15 - v16;
        v19 = strchr(v14, 101);
        v20 = (_BYTE)v19 + 1;
        do
          v21 = *v19++;
        while ( v21 );
        v6 = a4;
        *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)((char)(v18 - ((_BYTE)v19 - v20)) + *(_DWORD *)(v4 + 56) + 70) == 43) + 43;
      }
    }
  }
  v22 = *(_WORD *)(v6 + 14);
  if ( v22 < 0x30u || v22 > 0x39u )
  {
    if ( (*(_WORD *)(a2 + 8) & 0x3F) != 7 || v22 != 69 )
    {
      if ( (v22 == 43 || v22 == 45) && (sub_100176F0(*(_WORD *)(a2 + 8)) || *(_BYTE *)(a2 + 8) & 0x40) )
      {
        if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
        {
          sub_1000A0C0(&v136, a2, a3, v4);
          if ( *(_BYTE *)(a2 + 11) )
          {
            v84 = (char *)(*(_DWORD *)(v4 + 56) + 69);
            v85 = *(_DWORD *)(v4 + 56) + 70;
            do
              v86 = *v84++;
            while ( v86 );
            v87 = (_BYTE)v84 - v85;
            v88 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
            v89 = (_BYTE)v88 + 1;
            do
              v90 = *v88++;
            while ( v90 );
            *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v87 - ((_BYTE)v88 - v89)) - 1;
          }
          else
          {
            *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = a3 - ((*(_WORD *)(a2 + 8) >> 13) & 3) - 1;
          }
        }
        if ( (*(_BYTE *)(a2 + 8) & 0x3F) != 7 )
          goto LABEL_177;
        v91 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        v92 = *(_DWORD *)(v4 + 56) + 70;
        do
          v93 = *v91++;
        while ( v93 );
        v94 = (_BYTE)v91 - v92;
        v95 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
        v96 = (_BYTE)v95 + 1;
        do
          v97 = *v95++;
        while ( v97 );
        v98 = *(_DWORD *)(v4 + 56);
        if ( *(_WORD *)(v98 + 240) <= (signed __int16)(char)(v94 - ((_BYTE)v95 - v96)) )
        {
LABEL_177:
          if ( (*(_WORD *)(a4 + 14) != 45 || atof((const char *)(*(_DWORD *)(v4 + 56) + 69)) < 0.0)
            && (*(_WORD *)(a4 + 14) != 43 || atof((const char *)(*(_DWORD *)(v4 + 56) + 69)) > 0.0) )
          {
            v114 = a2;
          }
          else
          {
            v114 = a2;
            if ( *(_BYTE *)(a2 + 8) & 0x40 || *(_WORD *)(a4 + 14) == 45 )
            {
              *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
              v135 = 2;
            }
            else
            {
              *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = 48;
              v135 = 2;
            }
          }
          v115 = *(_DWORD *)(v4 + 56);
          if ( !*(_WORD *)(v115 + 240)
            && (*(_BYTE *)(*(_WORD *)(v115 + 240) + v115 + 69) == 43
             || *(_BYTE *)(*(_WORD *)(v115 + 240) + v115 + 69) == 45
             || (*(_BYTE *)(v114 + 8) & 0x3F) == 7) )
          {
            if ( (*(_BYTE *)(v114 + 8) & 0x3F) == 7 )
            {
              v116 = (const char *)(v115 + 69);
              v117 = (char *)(v115 + 69);
              v118 = v115 + 70;
              do
                v119 = *v117++;
              while ( v119 );
              v120 = (_BYTE)v117 - v118;
              v121 = strchr(v116, 46);
              v122 = (_BYTE)v121 + 1;
              do
                v123 = *v121++;
              while ( v123 );
              *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v120 - ((_BYTE)v121 - v122)) - 1;
            }
            else
            {
              ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
            }
            v124 = *(_DWORD *)(v4 + 56);
            v125 = a3 - (((unsigned int)*(_WORD *)(v114 + 8) >> 13) & 3) - 1;
            if ( *(_WORD *)(v124 + 240) < v125 )
              LOWORD(v125) = *(_WORD *)(v124 + 240);
            *(_WORD *)(v124 + 240) = (char)v125;
          }
        }
        else
        {
          v99 = (const char *)(v98 + 69);
          v100 = (char *)(v98 + 69);
          v101 = v98 + 70;
          do
            v102 = *v100++;
          while ( v102 );
          v103 = (_BYTE)v100 - v101;
          v104 = strchr(v99, 101);
          v105 = (_BYTE)v104 + 1;
          do
            v106 = *v104++;
          while ( v106 );
          *(_BYTE *)((char)(v103 - ((_BYTE)v104 - v105)) + *(_DWORD *)(v4 + 56) + 70) = *(_BYTE *)(a4 + 14);
          v107 = (char *)(*(_DWORD *)(v4 + 56) + 69);
          v108 = *(_DWORD *)(v4 + 56) + 70;
          do
            v109 = *v107++;
          while ( v109 );
          v110 = (_BYTE)v107 - v108;
          v111 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
          v112 = (_BYTE)v111 + 1;
          do
            v113 = *v111++;
          while ( v113 );
          if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == (char)(v110 - ((_BYTE)v111 - v112)) + 1 )
            ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
          v135 = 2;
        }
      }
      else if ( *(_WORD *)(v6 + 14) == 46 && *(_BYTE *)(a2 + 11) > 0 )
      {
        if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
          sub_1000A0C0(&v136, a2, a3, v4);
        v126 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        v127 = *(_DWORD *)(v4 + 56) + 70;
        do
          v128 = *v126++;
        while ( v128 );
        v129 = (_BYTE)v126 - v127;
        v130 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
        v131 = (_BYTE)v130 + 1;
        do
          v132 = *v130++;
        while ( v132 );
        *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v129 - ((_BYTE)v130 - v131)) + 1;
      }
    }
    else
    {
      if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
        sub_1000A0C0(&v136, a2, a3, v4);
      v77 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      v78 = *(_DWORD *)(v4 + 56) + 70;
      do
        v79 = *v77++;
      while ( v79 );
      v80 = (_BYTE)v77 - v78;
      v81 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
      v82 = (_BYTE)v81 + 1;
      do
        v83 = *v81++;
      while ( v83 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v80 - ((_BYTE)v81 - v82)) + 1;
      v135 = 2;
    }
    goto LABEL_170;
  }
  v23 = *(_DWORD *)(v4 + 56);
  v24 = *(_WORD *)(v23 + 240);
  if ( v24 == -128 )
  {
    sub_1000A0C0(&v136, a2, a3, v4);
    if ( *(_BYTE *)(a2 + 11) )
    {
      v25 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      do
        v26 = *v25++;
      while ( v26 );
      v27 = (_BYTE)v25 - (*(_BYTE *)(v4 + 56) + 70);
      v28 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
      v29 = (_BYTE)v28 + 1;
      do
        v30 = *v28++;
      while ( v30 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v27 - ((_BYTE)v28 - v29)) - 1;
    }
    else
    {
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = a3 - ((*(_WORD *)(a2 + 8) >> 13) & 3) - 1;
    }
    *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
    if ( *(_BYTE *)(a2 + 11) > 0 )
    {
      if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7
        || (v31 = *(_DWORD *)(v4 + 56), v32 = *(_BYTE *)(v31 + 69), v32 > 0x30u)
        || (v32 == 43 || v32 == 45) && *(_BYTE *)(v31 + 70) != 48 )
      {
        v33 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        do
          v34 = *v33++;
        while ( v34 );
        v35 = (_BYTE)v33 - (*(_BYTE *)(v4 + 56) + 70);
        v36 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
        v37 = (_BYTE)v36 + 1;
        do
          v38 = *v36++;
        while ( v38 );
        *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v35 - ((_BYTE)v36 - v37)) + 1;
        v135 = 2;
        goto LABEL_170;
      }
    }
LABEL_99:
    v135 = 2;
    goto LABEL_170;
  }
  if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7 )
  {
    v39 = (const char *)(v23 + 69);
    v40 = strlen(v39);
    v41 = strchr(v39, 101);
    v42 = (_BYTE)v41 + 1;
    do
      v43 = *v41++;
    while ( v43 );
    v23 = *(_DWORD *)(v4 + 56);
    v24 = *(_WORD *)(v23 + 240);
    if ( v24 > (char)(v40 - ((_BYTE)v41 - v42)) )
    {
      if ( a3 - v24 != 2 )
      {
        if ( a3 - v24 != 3 )
        {
          v44 = *(_DWORD *)(v4 + 56);
          if ( a3 - v24 != 4 )
          {
            if ( *(_BYTE *)(*(_WORD *)(v44 + 240) + v44 + 68) < 0x33u || *(_WORD *)(a4 + 14) < 0x38u )
            {
              *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
              v135 = 2;
              goto LABEL_170;
            }
            goto LABEL_99;
          }
          ++*(_WORD *)(v44 + 240);
        }
        ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
      }
      v45 = *(_WORD *)(a4 + 14);
      if ( v45 >= 0x30u
        && v45 <= 0x33u
        && (*(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 70) < 0x38u || v45 < 0x33u) )
      {
        *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v4 + 56) + 240))++ + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
        v135 = 2;
        goto LABEL_170;
      }
      goto LABEL_99;
    }
  }
  if ( *(_BYTE *)(a2 + 11) <= 0 )
    goto LABEL_178;
  v46 = (const char *)(v23 + 69);
  v47 = strlen(v46);
  v48 = strchr(v46, 46);
  v49 = (_BYTE)v48 + 1;
  do
    v50 = *v48++;
  while ( v50 );
  v23 = *(_DWORD *)(v4 + 56);
  v24 = *(_WORD *)(v23 + 240);
  if ( *(_WORD *)(v23 + 240) != (char)(v47 - ((_BYTE)v48 - v49)) - 1 )
  {
LABEL_178:
    v51 = a2;
    if ( !*(_BYTE *)(a2 + 11) )
    {
      if ( v24 == a3 - (((unsigned int)*(_WORD *)(a2 + 8) >> 13) & 3) - 1 )
        goto LABEL_64;
      v51 = a2;
    }
    if ( (*(_BYTE *)(v51 + 8) & 0x3F) == 7 && !v24 )
    {
      v71 = (const char *)(v23 + 69);
      v72 = strlen(v71);
      v73 = strchr(v71, 46);
      v74 = (_BYTE)v73 + 1;
      do
        v75 = *v73++;
      while ( v75 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v72 - ((_BYTE)v73 - v74)) - 1;
      v51 = a2;
    }
    *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v4 + 56) + 240))++ + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
    v76 = a3 - (((unsigned int)*(_WORD *)(v51 + 8) >> 13) & 3) - 1;
    if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) < v76 )
      LOWORD(v76) = *(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)v76;
    goto LABEL_99;
  }
LABEL_64:
  v52 = *(_BYTE *)(v23 + 69);
  v53 = a2;
  if ( v52 == 48 && (*(_BYTE *)(a2 + 8) & 0x3F) != 7 || (v52 == 43 || v52 == 45) && *(_BYTE *)(v23 + 70) == 48 )
  {
    if ( v52 == 45 )
    {
      *(_BYTE *)(v23 + 69) = 48;
      v138 = -1;
    }
    v139 = j__atol((const char *)(*(_DWORD *)(v4 + 56) + 69));
    v54 = *(_BYTE *)(v53 + 11) == 0;
    v55 = *(_BYTE *)(v53 + 11) < 0;
    v136 = (double)v139 * 10.0;
    if ( !v55 && !v54 )
    {
      v56 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      v57 = *(_DWORD *)(v4 + 56) + 70;
      do
        v58 = *v56++;
      while ( v58 );
      v59 = (_BYTE)v56 - v57;
      v60 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
      v61 = (_BYTE)v60 + 1;
      do
        v62 = *v60++;
      while ( v62 );
      v140 = atof((const char *)((char)(v59 - ((_BYTE)v60 - v61)) + *(_DWORD *)(v4 + 56) + 69));
      v136 = v140 + v136;
    }
    sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v137, a3, *(_BYTE *)(v53 + 11), v136);
    if ( v138 == -1 )
      *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = 45;
  }
  *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
  if ( *(_BYTE *)(v53 + 11) <= 0 )
    goto LABEL_99;
  if ( (*(_BYTE *)(v53 + 8) & 0x3F) != 7 )
  {
    v63 = *(_DWORD *)(v4 + 56);
    v64 = *(_BYTE *)(v63 + 69);
    if ( v64 <= 0x30u && (v64 != 43 && v64 != 45 || *(_BYTE *)(v63 + 70) == 48) )
      goto LABEL_99;
  }
  v65 = (char *)(*(_DWORD *)(v4 + 56) + 69);
  do
    v66 = *v65++;
  while ( v66 );
  v67 = (_BYTE)v65 - (*(_BYTE *)(v4 + 56) + 70);
  v68 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
  v69 = (_BYTE)v68 + 1;
  do
    v70 = *v68++;
  while ( v70 );
  *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v67 - ((_BYTE)v68 - v69)) + 1;
  v135 = 2;
LABEL_170:
  v133 = *(_DWORD *)(v4 + 56);
  if ( *(_BYTE *)(*(_WORD *)(v133 + 240) + v133 + 69) == 101 || *(_BYTE *)(*(_WORD *)(v133 + 240) + v133 + 69) == 46 )
    ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
  return v135;
}

//----- (1000AC70) --------------------------------------------------------
char __usercall sub_1000AC70@<al>(int a1@<eax>, float *a2@<ecx>, int a3@<ebx>, int a4@<esi>, int a5)
{
  float *v5; // edi@1
  __int16 v6; // ax@1
  unsigned int v7; // edi@1
  int v8; // ebp@1
  __int16 v9; // ax@1
  char *v11; // [sp+8h] [bp-4h]@1

  v5 = a2;
  *(_WORD *)(a3 + 438) = *(_WORD *)a1;
  *(_WORD *)(a3 + 436) = *(_WORD *)(a1 + 2);
  v11 = sub_10017730(*(_WORD *)(a4 + 8), a2);
  v6 = sub_1000EF40(*(_DWORD *)(a4 + 4), *(_WORD *)(a4 + 8), v5);
  v7 = *(_DWORD *)(a4 + 4);
  v8 = v6;
  v9 = *(_WORD *)(a4 + 12);
  if ( (*(_DWORD *)(a4 + 4) & 0xC000) != 0x4000 )
  {
    v9 -= v8;
    if ( v8 > 0 )
      v9 -= *(_WORD *)(dword_101D8164[5 * ((v7 >> 10) & 0xF)] + 28);
  }
  if ( !*(_WORD *)(a4 + 12) )
    v9 = sub_10009B60(v7, *(_WORD *)(a4 + 8), a5, *(_BYTE *)(a4 + 11));
  return sub_1000F5A0(a3, (char *)(*(_DWORD *)(a3 + 56) + 69), v11, v9, v8, v7, *(_WORD *)(a4 + 8));
}
// 101D8164: using guessed type int dword_101D8164[];

//----- (1000AD30) --------------------------------------------------------
char __usercall sub_1000AD30@<al>(int a1@<edx>, float *a2@<ecx>, int a3, int a4)
{
  double v4; // st7@2
  double v6; // [sp+0h] [bp-8h]@4

  if ( 9.8999998e24 == *a2 )
    v4 = 9.899999762399947e24;
  else
    v4 = *a2;
  v6 = v4;
  return sub_10009BC0(a3, a1, a4, &v6);
}

//----- (1000AD70) --------------------------------------------------------
char __cdecl sub_1000AD70(int a1, int a2, int *a3, float *a4, int a5)
{
  __int16 v5; // cx@2
  __int16 v6; // cx@4
  __int16 v7; // ax@9
  _WORD *v8; // esi@9
  unsigned int v9; // ebp@10
  int v10; // eax@10
  int v11; // edx@12
  __int16 v12; // ax@16
  int v13; // eax@17
  __int16 v14; // cx@17
  int v16; // eax@19
  signed __int16 v17; // si@19
  signed int v18; // eax@20
  char v19; // al@27
  char v20; // al@33
  __int16 v21; // ax@36
  signed int v22; // ecx@40
  int v23; // ecx@42
  int v24; // ecx@43
  int v25; // ecx@45
  int v26; // ecx@47
  int v27; // edi@49
  const char *v28; // eax@50
  char v29; // ST38_1@50
  bool v30; // zf@58
  bool v31; // sf@58
  int v32; // esi@65
  char v33; // dl@68
  bool v34; // zf@73
  bool v35; // sf@73
  bool v36; // zf@80
  bool v37; // sf@80
  char v38; // al@87
  int v39; // esi@94
  double v40; // st7@96
  int v41; // esi@101
  unsigned int v42; // edx@101
  __int16 v43; // bx@101
  unsigned __int8 v44; // cl@103
  int v45; // ecx@109
  _WORD *v46; // eax@109
  char v47; // dl@109
  char *v48; // eax@114
  int v49; // esi@114
  char v50; // dl@115
  char v51; // bl@116
  char *v52; // eax@116
  char v53; // dl@116
  char v54; // cl@117
  char v55; // cl@118
  int v56; // eax@118
  int v57; // edx@118
  char *v58; // eax@120
  int v59; // esi@120
  char v60; // dl@121
  char v61; // bl@122
  char *v62; // eax@122
  char v63; // dl@122
  char v64; // cl@123
  char v65; // cl@124
  int v66; // eax@124
  int v67; // edx@124
  char v68; // [sp-4h] [bp-2Ch]@64
  unsigned __int16 v69; // [sp+0h] [bp-28h]@64
  char v70; // [sp+4h] [bp-24h]@64
  char v71; // [sp+1Bh] [bp-Dh]@1
  size_t v72; // [sp+1Ch] [bp-Ch]@2
  unsigned int v73; // [sp+3Ch] [bp+14h]@50
  int v74; // [sp+3Ch] [bp+14h]@99

  v71 = 1;
  if ( *(_WORD *)a5 == -32703 )
  {
    v72 = 0;
  }
  else
  {
    v72 = *(_BYTE *)(a2 + 10);
    v5 = *(_WORD *)(a2 + 8);
    if ( v5 & 0x40 || *(_WORD *)(a2 + 8) & 0x800 || (v6 = v5 & 0x3F, v6 == 7) || v6 == 28 )
      ++v72;
  }
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v7 = *(_WORD *)(a2 + 12);
      v8 = (_WORD *)(a1 + 276);
      if ( v7 )
      {
        sub_1000F440(a1 + 276, *a3, *(_DWORD *)(a2 + 4), v7);
      }
      else
      {
        v9 = *(_DWORD *)(a2 + 4);
        v10 = sub_10009B60(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 10), *(_BYTE *)(a2 + 11));
        sub_1000F440((int)v8, *a3, v9, v10);
      }
      v11 = (signed __int16)sub_1000EF40(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), a4);
      if ( (!*(_WORD *)(a2 + 12) || (*(_DWORD *)(a2 + 4) & 0xC000) == 0x4000)
        && ~(unsigned __int8)(*(_WORD *)(a2 + 8) >> 9) & 1
        && v11 > 0 )
      {
        v12 = *(_WORD *)(dword_101D8164[5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF)] + 28);
        *(_WORD *)(a1 + 280) += v11 + v12;
        if ( (*(_DWORD *)(a2 + 4) & 0xC000) == 0x8000 )
        {
          v13 = (v12 + v11 + 1) / 2;
          v14 = *(_WORD *)(a1 + 280) - v13;
          *v8 -= v13;
          *(_WORD *)(a1 + 280) = v14;
        }
      }
      return 2;
    case 0x8048:
      v16 = *(_DWORD *)(a1 + 56);
      v17 = *(_WORD *)(v16 + 240);
      if ( v17 == -128 )
      {
        v18 = *(_WORD *)(a5 + 10);
        if ( v18 > 84 )
        {
          if ( v18 != 0x2000 )
            return v71;
        }
        else if ( v18 != 84 )
        {
          if ( v18 == 32 )
          {
            if ( *(_WORD *)(a2 + 8) & 0x400 || (*(_WORD *)(a2 + 8) & 0x3F) == 27 || *(_WORD *)(a2 + 8) & 0x800 )
              return v71;
            v71 = sub_1000A0C0(a4, a2, v72, a1);
            memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, v72);
            if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7 )
            {
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 71) = 46;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + v72 + 64) = 101;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + v72 + 65) = 43;
            }
            else
            {
              v20 = *(_BYTE *)(a2 + 11);
              if ( v20 > 0 )
                *(_BYTE *)(*(_DWORD *)(a1 + 56) - v20 + v72 + 68) = 46;
            }
            goto LABEL_132;
          }
          if ( v18 != 56
            || *(_WORD *)(a2 + 8) & 0x400
            || (*(_WORD *)(a2 + 8) & 0x3F) == 27
            || *(_WORD *)(a2 + 8) & 0x800 )
          {
            return v71;
          }
          v19 = sub_1000A0C0(a4, a2, v72, a1);
LABEL_131:
          v71 = v19;
LABEL_132:
          if ( v71 != 4 && v71 != 2 )
            return v71;
          goto LABEL_134;
        }
        v21 = *(_WORD *)(a2 + 8);
        if ( *(_WORD *)(a2 + 8) & 0x400 || (v21 & 0x3F) == 27 || *(_WORD *)(a2 + 8) & 0x800 )
          return v71;
        v19 = sub_1000A1A0(a1, a2, v72, a5);
        goto LABEL_131;
      }
      v22 = *(_WORD *)(a5 + 10);
      if ( v22 > 57 )
      {
        if ( v22 != 84 && v22 != 0x2000 )
          return v71;
        v19 = sub_1000A1A0(a1, a2, v72, a5);
        goto LABEL_131;
      }
      if ( v22 == 57 )
      {
        *(_WORD *)(v16 + 240) += *(_BYTE *)(a5 + 8);
        v41 = *(_DWORD *)(a1 + 56);
        v42 = *(_WORD *)(a2 + 8);
        v43 = *(_WORD *)(v41 + 240);
        v71 = 2;
        if ( v43 >= 0 )
        {
          v44 = *(_BYTE *)(a2 + 10);
          if ( v43 <= (signed int)(v44 - ((v42 >> 13) & 3) - 1) || v42 & 0x40 || (v42 & 0x3F) == 7 )
          {
            if ( v43 <= (signed int)v44 )
            {
              while ( 1 )
              {
                v45 = *(_DWORD *)(a1 + 56);
                v46 = (_WORD *)(v45 + 240);
                v47 = *(_BYTE *)(*(_WORD *)(v45 + 240) + v45 + 69);
                if ( v47 != 46 && v47 != 101 )
                {
                  if ( (*(_BYTE *)(a2 + 8) & 0x3F) != 7 || *(_WORD *)(v45 + 240) <= 0 )
                    break;
                  if ( !strchr((const char *)(v45 + 69), 46) )
                    goto LABEL_142;
                  v48 = (char *)(*(_DWORD *)(a1 + 56) + 69);
                  v49 = *(_DWORD *)(a1 + 56) + 70;
                  do
                    v50 = *v48++;
                  while ( v50 );
                  v51 = (_BYTE)v48 - v49;
                  v52 = strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 46);
                  v53 = (_BYTE)v52 + 1;
                  do
                    v54 = *v52++;
                  while ( v54 );
                  v55 = (_BYTE)v52 - v53;
                  v56 = *(_DWORD *)(a1 + 56);
                  v57 = *(_WORD *)(v56 + 240);
                  v46 = (_WORD *)(v56 + 240);
                  if ( v57 >= (char)(v51 - v55) - 1 )
                  {
LABEL_142:
                    if ( strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 46) )
                      break;
                    v58 = (char *)(*(_DWORD *)(a1 + 56) + 69);
                    v59 = *(_DWORD *)(a1 + 56) + 70;
                    do
                      v60 = *v58++;
                    while ( v60 );
                    v61 = (_BYTE)v58 - v59;
                    v62 = strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 101);
                    v63 = (_BYTE)v62 + 1;
                    do
                      v64 = *v62++;
                    while ( v64 );
                    v65 = (_BYTE)v62 - v63;
                    v66 = *(_DWORD *)(a1 + 56);
                    v67 = *(_WORD *)(v66 + 240);
                    v46 = (_WORD *)(v66 + 240);
                    if ( v67 >= (char)(v61 - v65) - 1 )
                      break;
                  }
                }
                if ( *(_BYTE *)(a5 + 8) <= 0 )
                  --*v46;
                else
                  ++*v46;
              }
            }
            else
            {
              *(_WORD *)(v41 + 240) = (char)v44;
            }
          }
          else
          {
            *(_WORD *)(v41 + 240) = (char)(v44 - ((v42 >> 13) & 3) - 1);
          }
        }
        else
        {
          *(_WORD *)(v41 + 240) = 0;
        }
        goto LABEL_134;
      }
      v23 = v22 - 32;
      if ( !v23 )
      {
        *(_WORD *)(v16 + 240) = -128;
        sub_1000AD30(a2, a4, a1, (int)a3);
        return 6;
      }
      v24 = v23 - 1;
      if ( v24 )
      {
        if ( v24 != 23 )
          return v71;
        v25 = *(_WORD *)(a2 + 8);
        if ( v25 & 0x40 && !v17 )
        {
          LOBYTE(v25) = *(_BYTE *)(v16 + 69) != 45;
          v26 = 2 * v25 + 43;
LABEL_48:
          *(_BYTE *)(v16 + 69) = v26;
          v71 = 2;
LABEL_134:
          sub_1000AC70((int)a3, a4, a1, a2, v72);
          return v71;
        }
        v27 = 2 * (*(_BYTE *)(a5 + 8) >= 0) - 1;
        if ( (v25 & 0x3F) != 7
          || (v28 = (const char *)(v16 + 69),
              v73 = strlen(v28),
              v29 = strlen(strchr(v28, 101)),
              v16 = *(_DWORD *)(a1 + 56),
              v17 = *(_WORD *)(v16 + 240),
              v17 <= (char)(v73 - v29))
          && v17 )
        {
          v38 = *(_BYTE *)(v17 + v16 + 69);
          if ( (v38 == 48 && v27 < 0 || v38 == 57 && v27 > 0) && !v17 && sub_100176F0(*(_WORD *)(a2 + 8)) )
          {
            *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) = 45;
            v71 = 2;
            goto LABEL_134;
          }
          v39 = *(_DWORD *)(a1 + 56);
          *(_BYTE *)(*(_WORD *)(v39 + 240) + v39 + 69) = sub_10011A80(
                                                           *(_BYTE *)(*(_WORD *)(v39 + 240) + v39 + 69),
                                                           0x10u,
                                                           v27);
        }
        else
        {
          if ( !v17 )
          {
            v71 = 2;
            *(_BYTE *)(v16 + 69) = *(_BYTE *)(v16 + 69) != 45 ? 45 : 48;
            goto LABEL_134;
          }
          if ( v72 - v17 == 2 )
          {
            v16 += v17;
            if ( *(_BYTE *)(v16 + 70) > 0x37u )
            {
              v34 = v27 == 0;
              v35 = v27 < 0;
              if ( v27 < 0 )
              {
                if ( *(_BYTE *)(v16 + 69) == 48 )
                {
                  *(_BYTE *)(v16 + 69) = 50;
                  v71 = 2;
                  goto LABEL_134;
                }
                v34 = v27 == 0;
                v35 = v27 < 0;
              }
              if ( !v35 && !v34 && *(_BYTE *)(v16 + 69) >= 0x32u )
              {
                *(_BYTE *)(v16 + 69) = 48;
                v71 = 2;
                goto LABEL_134;
              }
LABEL_64:
              v70 = v27;
              v69 = 16;
              v68 = *(_BYTE *)(v16 + 69);
LABEL_65:
              v32 = *(_DWORD *)(a1 + 56);
              *(_BYTE *)(*(_WORD *)(v32 + 240) + v32 + 69) = sub_10011A80(v68, v69, v70);
              v71 = 2;
              goto LABEL_134;
            }
            v36 = v27 == 0;
            v37 = v27 < 0;
            if ( v27 < 0 )
            {
              if ( *(_BYTE *)(v16 + 69) == 48 )
              {
                *(_BYTE *)(v16 + 69) = 51;
                v71 = 2;
                goto LABEL_134;
              }
              v36 = v27 == 0;
              v37 = v27 < 0;
            }
            if ( !v37 && !v36 && *(_BYTE *)(v16 + 69) >= 0x33u )
            {
              *(_BYTE *)(v16 + 69) = 48;
              v71 = 2;
              goto LABEL_134;
            }
LABEL_66:
            v70 = v27;
            v69 = 16;
            v68 = *(_BYTE *)(v16 + 69);
            goto LABEL_65;
          }
          if ( v72 - v17 != 3 )
          {
            if ( v72 - v17 == 4 )
            {
              v71 = 2;
              *(_BYTE *)(v17 + v16 + 69) = 2 * (*(_BYTE *)(v17 + v16 + 69) != 45) + 43;
              goto LABEL_134;
            }
            v16 += v17;
            if ( *(_BYTE *)(v16 + 68) >= 0x33u )
            {
              v30 = v27 == 0;
              v31 = v27 < 0;
              LOBYTE(v26) = 48;
              if ( v27 < 0 )
              {
                if ( *(_BYTE *)(v16 + 69) == 48 )
                {
                  *(_BYTE *)(v16 + 69) = 55;
                  v71 = 2;
                  goto LABEL_134;
                }
                v30 = v27 == 0;
                v31 = v27 < 0;
              }
              if ( !v31 && !v30 && *(_BYTE *)(v16 + 69) >= 0x37u )
                goto LABEL_48;
              goto LABEL_64;
            }
            goto LABEL_66;
          }
          v33 = *(_BYTE *)(v17 + v16 + 69);
          if ( v33 == 45 )
          {
            *(_BYTE *)(v17 + v16 + 69) = 43;
            v71 = 2;
            goto LABEL_134;
          }
          if ( v33 == 43 )
          {
            *(_BYTE *)(v17 + v16 + 69) = 45;
            v71 = 2;
            goto LABEL_134;
          }
        }
        v71 = 2;
        goto LABEL_134;
      }
      *(_WORD *)(v16 + 240) = -128;
      v40 = atof((const char *)(*(_DWORD *)(a1 + 56) + 69));
      if ( v40 > 1.0e25 || v40 < -1.0e25 )
        v40 = 9.899999762399947e24;
      *(float *)&v74 = v40;
      *a4 = sub_100187A0(v74, *(_WORD *)(a2 + 8));
      sub_1000AD30(a2, a4, a1, (int)a3);
      return 3;
    case 0x8022:
    case 0x8078:
      if ( !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
      {
        sub_1000AD30(a2, a4, a1, (int)a3);
        return v71;
      }
      sub_1000AC70((int)a3, a4, a1, a2, v72);
      return 1;
    default:
      return v71;
  }
}
// 101D8164: using guessed type int dword_101D8164[];

//----- (1000B660) --------------------------------------------------------
char __usercall sub_1000B660@<al>(int a1@<eax>, int a2@<edx>)
{
  return ((*(_BYTE *)(a1 + 16) & 0x3F) != 44 ? 3 : 0) + (*(_BYTE *)(a2 + 9) == 0);
}

//----- (1000B680) --------------------------------------------------------
char __usercall sub_1000B680@<al>(int a1@<edi>, int a2@<esi>)
{
  char v2; // bl@1
  int v3; // ecx@1
  char v4; // al@3
  bool v5; // zf@9
  char v6; // al@21
  char result; // al@26
  char v8; // [sp+7h] [bp-5h]@1
  int v9; // [sp+8h] [bp-4h]@11

  v8 = 0;
  v2 = 0;
  if ( sub_10015700(&v8) == 1 )
  {
    LOBYTE(v3) = *(_BYTE *)(a1 + 16) & 0x3F;
    if ( (_BYTE)v3 == 44 )
    {
      v4 = *(_BYTE *)(a2 + 9);
      LOBYTE(v3) = v8;
      if ( v4 == 1 )
      {
        if ( v8 == 1 )
          goto LABEL_19;
      }
      else
      {
        if ( v8 == 2 )
          goto LABEL_19;
        if ( v4 != 1 )
        {
LABEL_9:
          v5 = v8 == 4;
          goto LABEL_18;
        }
      }
      if ( v8 != 6 )
        goto LABEL_9;
LABEL_19:
      v2 = 1;
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  if ( (*(_BYTE *)(a1 + 16) & 0x3F) == 44 && sub_10010610((int)&v9) )
  {
    v3 = v9;
    if ( *(_BYTE *)(a2 + 9) != 1 )
    {
      if ( BYTE1(v3) != 1 )
      {
        v5 = BYTE3(v9) == 1;
LABEL_18:
        if ( v5 )
          goto LABEL_19;
        goto LABEL_20;
      }
      goto LABEL_19;
    }
    if ( (_BYTE)v9 == 1 || BYTE2(v9) == 1 )
      goto LABEL_19;
LABEL_20:
    v2 = 0;
  }
LABEL_21:
  v6 = sub_10018F40(v3);
  if ( (*(_BYTE *)(a1 + 16) & 0x3F) == 44 )
    goto LABEL_27;
  if ( *(_BYTE *)(a2 + 9) != 1 )
  {
    if ( v6 == 2 )
      goto LABEL_26;
LABEL_27:
    result = 0;
    goto LABEL_28;
  }
  if ( v6 != 1 )
    goto LABEL_27;
LABEL_26:
  result = 1;
LABEL_28:
  if ( v2 || result )
    result = 1;
  return result;
}

//----- (1000B760) --------------------------------------------------------
int __usercall sub_1000B760@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  __int16 v3; // dx@1
  __int16 v4; // cx@1
  int v6; // [sp+0h] [bp-4h]@1

  v6 = a2;
  v3 = *(_WORD *)a1 + *(_WORD *)(a2 + 4);
  v4 = *(_WORD *)(a1 + 2) + *(_WORD *)(a2 + 6);
  LOWORD(v6) = v3;
  HIWORD(v6) = v4;
  return sub_1000F010(a3, a1, (int)&v6, 0);
}

//----- (1000B790) --------------------------------------------------------
int __usercall sub_1000B790@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  int v11; // ebp@1
  int v12; // edi@1
  int v13; // ebx@1
  int v14; // esi@1
  __int64 v15; // rax@1
  int v16; // ST20_4@1
  char *v17; // eax@1
  char *v18; // ST3C_4@1
  signed int v19; // esi@1
  __int16 v20; // ax@1
  unsigned int v21; // eax@4
  unsigned int v22; // eax@5
  char v23; // cl@5
  int v24; // eax@8
  _WORD *v25; // ecx@11
  __int16 v26; // si@14
  __int16 v27; // ax@14
  __int16 v28; // si@15
  int result; // eax@15
  __int16 v30; // bp@15
  __int16 v31; // cx@16
  __int16 v32; // si@17
  __int16 v33; // ax@18
  __int16 v34; // ax@18
  __int16 v35; // ax@18
  int v36; // eax@19
  int v37; // eax@19
  __int16 v38; // ax@20
  __int16 v39; // ax@20
  int v40; // edx@21
  int v41; // ecx@22
  int v42; // eax@22
  __int16 v43; // bx@22
  __int16 v44; // ax@23
  int v45; // [sp+10h] [bp-10h]@1
  __int16 v46; // [sp+14h] [bp-Ch]@1
  int v47; // [sp+18h] [bp-8h]@1
  int v48; // [sp+1Ch] [bp-4h]@1
  int v49; // [sp+28h] [bp+8h]@19
  int v50; // [sp+38h] [bp+18h]@1

  v11 = a8;
  v12 = a2;
  v13 = a1;
  v50 = *(_DWORD *)(a5 + 16);
  v14 = *(_WORD *)(*((_DWORD *)sub_1000E8B0(*(_DWORD *)(a2 + 8)) + 1) + 26);
  v15 = *(_WORD *)(*((_DWORD *)sub_1000E8B0(*(_DWORD *)(v12 + 8)) + 1) + 24) - v14;
  v46 = *(_WORD *)(a4 + 2) + *(_WORD *)(v12 + 6) / 2 + (((signed int)v15 - HIDWORD(v15)) >> 1);
  v16 = sub_1000E8F0(*(_DWORD *)(v12 + 12));
  v17 = sub_1000E8B0(*(_DWORD *)(v12 + 12));
  v48 = sub_100062D0(*((_DWORD *)v17 + 1), &word_1005D108, v16);
  v18 = sub_1000E8B0(*(_DWORD *)(v12 + 8));
  v19 = sub_1000E8F0(*(_DWORD *)(v12 + 8));
  v45 = sub_100062D0(*((_DWORD *)v18 + 1), &word_1005D108, v19);
  v20 = sub_1000E640(v19);
  *(_DWORD *)a6 = 107;
  *(_DWORD *)(a6 + 4) = *(_DWORD *)(v12 + 12);
  v47 = v20;
  *(_WORD *)(a6 + 8) = 0;
  *(_WORD *)(a6 + 14) = v46;
  *(_DWORD *)v11 = 78;
  *(_WORD *)(v11 + 8) = *(_WORD *)(v12 + 16);
  *(_DWORD *)(v11 + 4) = *(_DWORD *)(v12 + 8) & 0xFFFFFD8F | 0x18F;
  if ( sub_1000B680(v12, a5) == 1 )
  {
    *(_DWORD *)(v11 + 4) = *(_DWORD *)(v11 + 4) & 0xFFFFFFE5 | 0x185;
    *(_BYTE *)(a5 + 8) = (*(_BYTE *)(v12 + 16) & 0x3F) != 44;
  }
  else
  {
    *(_BYTE *)(a5 + 8) = 0;
  }
  *(_WORD *)(v11 + 18) = v46;
  *(_DWORD *)v13 = 78;
  *(_WORD *)(v13 + 8) = *(_WORD *)(v12 + 16);
  v21 = *(_DWORD *)(v12 + 8) & 0xFFFFFD80 | *(_BYTE *)(v50 + 4) & 0x1F | 0x180;
  *(_DWORD *)(v13 + 4) = v21;
  if ( *(_BYTE *)(a5 + 10) == 1 )
  {
    v22 = v21 & 0xFFFFFFE0;
    *(_DWORD *)(v13 + 4) = v22;
    v23 = *(_BYTE *)(v50 + 1);
    if ( v23 && *(_WORD *)(*(_DWORD *)(a3 + 56) + 240) == -128 && v23 )
      v24 = v22 | 0x18F;
    else
      v24 = v22 | 0x186;
    *(_DWORD *)(v13 + 4) = v24;
  }
  v25 = (_WORD *)a4;
  *(_WORD *)(v13 + 18) = v46;
  *(_DWORD *)a10 = 96;
  *(_WORD *)(a10 + 14) = *(_WORD *)(a4 + 2) + 2;
  *(_WORD *)(a10 + 6) = *(_WORD *)(v12 + 6) - 3;
  *(_WORD *)(a10 + 8) = 18822;
  if ( !*(_BYTE *)(v50 + 1) )
    *(_DWORD *)(v13 + 4) = *(_DWORD *)(v13 + 4) & 0xFFFFF7FF | 0x1000;
  if ( (*(_BYTE *)(v12 + 16) & 0x3F) == 44 )
  {
    *(_BYTE *)(v13 + 11) = 3;
    *(_WORD *)(v13 + 12) = 0;
    *(_BYTE *)(v13 + 10) = 7;
    *(_WORD *)(v13 + 14) = 66;
    *(_WORD *)(v11 + 14) = 66;
    *(_BYTE *)(v11 + 10) = 7;
    *(_BYTE *)(v11 + 11) = 3;
    *(_WORD *)(v11 + 12) = 0;
    v26 = 6 * v45;
    *(_WORD *)(a10 + 4) = 6 * v45 + v47 + 6;
    v27 = *(_WORD *)a4 + *(_WORD *)(v12 + 4) - 2;
    *(_WORD *)(a6 + 12) = v27;
    *(_WORD *)(a10 + 12) = v27 - 5 * v48 - *(_WORD *)(a10 + 4) + 5;
    if ( *(_BYTE *)(v50 + 1) )
    {
      *(_WORD *)(v11 + 16) = v26 + 15;
      v28 = *(_WORD *)(a10 + 4) + *(_WORD *)(a10 + 12) - 2;
      *(_WORD *)(v13 + 16) = v28;
      result = a11;
      *(_WORD *)(a11 + 16) = v28 - 6 * v45 / 2;
      *(_DWORD *)(a11 + 4) = 20870;
      v30 = *(_WORD *)(v11 + 16) + 6;
      *(_WORD *)(a9 + 4) = v30;
      *(_WORD *)(a7 + 12) = v30 + 18;
    }
    else
    {
      v31 = v26 + v47 - 13;
      if ( *(_BYTE *)v50 )
      {
        v33 = *(_WORD *)a4 + *(_WORD *)(v12 + 4) - 2;
        *(_WORD *)(v13 + 16) = v33;
        v34 = v33 - v31 - 21;
        *(_WORD *)(a9 + 4) = v34;
        v34 -= 8;
        *(_WORD *)(v11 + 16) = v34;
        v35 = v34 - v31 - 23;
        *(_WORD *)(a7 + 12) = v35;
        *(_WORD *)(a6 + 12) = v35 - 29;
        *(_WORD *)(a11 + 16) = *(_WORD *)(v13 + 16) - 39;
        result = a11;
      }
      else
      {
        *(_WORD *)(v11 + 16) = v26 + 40;
        v32 = *(_WORD *)(a6 + 12) - 5 * v48 - 2;
        *(_WORD *)(v13 + 16) = v32;
        *(_WORD *)(a11 + 16) = v32 - 6 * v45 / 2 + 12;
        *(_WORD *)(a9 + 4) = *(_WORD *)(v11 + 16) + 7;
        *(_WORD *)(a7 + 12) = *(_WORD *)(v11 + 16) - v31 - 20;
        result = a11;
      }
    }
  }
  else
  {
    *(_WORD *)(v11 + 12) = 0;
    *(_BYTE *)(v11 + 10) = 6;
    *(_BYTE *)(v11 + 11) = 2;
    *(_WORD *)(v11 + 14) = 61;
    *(_WORD *)(v13 + 14) = 61;
    *(_WORD *)(v13 + 12) = 0;
    v49 = v47 + 4 * v45 + v45;
    *(_BYTE *)(v13 + 10) = 6;
    *(_BYTE *)(v13 + 11) = 2;
    *(_WORD *)(a10 + 4) = v49 + 5;
    v36 = *v25;
    LOWORD(v36) = v36 + 4;
    *(_WORD *)(a6 + 12) = v36;
    v37 = v36 + 5 * v48 - 8;
    *(_WORD *)(a10 + 12) = v37;
    if ( *(_BYTE *)(v50 + 1) )
    {
      v38 = v37 + *(_WORD *)(a10 + 4) - 2;
      *(_WORD *)(v13 + 16) = v38;
      *(_WORD *)(a11 + 16) = v38;
      *(_DWORD *)(a11 + 4) = 20870;
      v39 = *(_WORD *)(a10 + 4) + *(_WORD *)(a10 + 12) + 4;
      *(_WORD *)(a7 + 12) = v39;
      *(_WORD *)(v11 + 16) = v39 + 95;
      *(_WORD *)(a9 + 4) = *(_WORD *)(a7 + 12);
      result = a11;
    }
    else
    {
      v40 = (signed __int16)(v49 - 11);
      if ( *(_BYTE *)v50 )
      {
        v44 = v40 + *v25 + 1;
        *(_WORD *)(v13 + 16) = v44;
        *(_WORD *)(a9 + 4) = v44 + 8;
        *(_WORD *)(a11 + 16) = *(_WORD *)(v13 + 16) + 23;
        *(_WORD *)(v11 + 16) = v40 + *(_WORD *)(a9 + 4) + 38;
        *(_WORD *)(a7 + 12) = *(_WORD *)(a9 + 4) + 2;
        *(_WORD *)(a6 + 12) = *(_WORD *)(v11 + 16) + 60;
        result = a11;
      }
      else
      {
        v41 = *v25;
        LOWORD(v41) = v41 + 4;
        *(_WORD *)(a6 + 12) = v41;
        v42 = 5 * v48 + v41 + v40 - 6;
        *(_WORD *)(v13 + 16) = v42;
        *(_WORD *)(a11 + 16) = v42 + 11;
        v43 = *(_WORD *)(v13 + 16) + 6;
        *(_WORD *)(a7 + 12) = v43;
        *(_WORD *)(a9 + 4) = v43 + 2;
        *(_WORD *)(v11 + 16) = *(_WORD *)(a7 + 12) + 95;
        result = a11;
      }
    }
  }
  *(_DWORD *)a7 = 107;
  *(_DWORD *)(a7 + 4) = *(_DWORD *)(v12 + 12);
  *(_WORD *)(a7 + 14) = v46;
  *(_WORD *)(a7 + 8) = 0;
  *(_DWORD *)a9 = 63;
  *(_WORD *)(a9 + 6) = v46 - 12;
  if ( !*(_BYTE *)(v50 + 1) )
    *(_DWORD *)(result + 4) = 20870;
  *(_WORD *)(result + 12) = 0;
  *(_DWORD *)result = 89;
  *(_WORD *)(result + 8) = 10;
  *(_BYTE *)(result + 10) = 3;
  *(_WORD *)(result + 18) = v46;
  *(_BYTE *)(result + 11) = 1;
  return result;
}
// 1005D108: using guessed type __int16 word_1005D108;

//----- (1000BD10) --------------------------------------------------------
char __usercall sub_1000BD10@<al>(int a1@<ecx>, int a2@<edi>, int a3, int a4)
{
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // ecx@1
  char v7; // dl@1
  bool v8; // al@3
  bool v9; // bl@5
  bool v10; // al@5
  signed int v11; // ecx@5
  char v12; // cl@15
  bool v13; // zf@15
  __int16 v14; // si@23
  char v15; // dl@23
  bool v16; // al@37
  char result; // al@48
  char v18; // [sp-Ch] [bp-B8h]@3
  bool v19; // [sp+Eh] [bp-9Eh]@3
  bool v20; // [sp+Eh] [bp-9Eh]@19
  char v21; // [sp+Fh] [bp-9Dh]@29
  int v22; // [sp+10h] [bp-9Ch]@5
  int v23; // [sp+14h] [bp-98h]@1
  char v24; // [sp+1Bh] [bp-91h]@15
  int v25; // [sp+1Ch] [bp-90h]@5
  int v26; // [sp+20h] [bp-8Ch]@13
  float v27; // [sp+24h] [bp-88h]@21
  int v28; // [sp+28h] [bp-84h]@1
  int v29; // [sp+2Ch] [bp-80h]@23
  int v30; // [sp+30h] [bp-7Ch]@1
  char v31; // [sp+34h] [bp-78h]@1
  char v32; // [sp+3Ch] [bp-70h]@1
  __int16 v33; // [sp+4Ch] [bp-60h]@24
  char v34; // [sp+50h] [bp-5Ch]@1
  char v35; // [sp+64h] [bp-48h]@1
  __int16 v36; // [sp+70h] [bp-3Ch]@23
  char v37; // [sp+74h] [bp-38h]@1
  char v38; // [sp+84h] [bp-28h]@1
  char v39; // [sp+94h] [bp-18h]@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 16);
  v23 = *(_DWORD *)(a1 + 16);
  sub_1000B790((int)&v32, a3, a2, a4, a1, (int)&v35, (int)&v37, (int)&v34, (int)&v31, (int)&v38, (int)&v39);
  v6 = *(_DWORD *)v4;
  v7 = *(_BYTE *)(a3 + 16) & 0x3F;
  v30 = *(_DWORD *)(v4 + 4);
  v28 = v6;
  if ( v7 == 44 )
  {
    if ( *(_BYTE *)(v4 + 9) == 1 )
    {
      v19 = sub_100190F0(0);
      v8 = sub_10019150(0);
      v18 = 0;
    }
    else
    {
      v19 = sub_100190F0(1);
      v8 = sub_10019150(1);
      v18 = 1;
    }
    v9 = v8;
    v10 = sub_10019080(v18);
    v25 = 1482 - (*(_BYTE *)(v4 + 9) != 0);
    LOWORD(v11) = 6;
    v22 = 6;
    if ( v9 )
    {
      v5 = v23;
      LOWORD(v11) = 6734;
      v22 = 6734;
      goto LABEL_12;
    }
    if ( *(_BYTE *)(v23 + 2) && v10 )
    {
      v11 = 6091;
    }
    else
    {
      if ( !*(_BYTE *)(v23 + 3) || !v19 )
        goto LABEL_11;
      v11 = 5772;
    }
    v22 = v11;
LABEL_11:
    v5 = v23;
    goto LABEL_12;
  }
  if ( *(_BYTE *)(v4 + 9) == 1 )
  {
    v25 = 4689;
    sub_10014A80(3, (bool *)&v21);
  }
  else
  {
    v25 = 4692;
    sub_10014A80(4, (bool *)&v21);
  }
  v11 = v21 != 1 ? 6 : 3744;
  v22 = v21 != 1 ? 6 : 3744;
LABEL_12:
  if ( !*(_BYTE *)(v4 + 10) || (v26 = 53, (_WORD)v11 == 3744) )
    v26 = 54;
  v12 = *(_BYTE *)(a2 + 3);
  *(_BYTE *)(a2 + 3) = 0;
  v13 = *(_BYTE *)(v4 + 10) == 0;
  v24 = v12;
  if ( v13 && *(_BYTE *)(v5 + 7) == *(_BYTE *)(v4 + 9) )
    *(_DWORD *)(v5 + 8) = 0;
  if ( *(_BYTE *)(v4 + 11) == 1 )
  {
    v20 = (unsigned int)sub_10003FF0() < *(_DWORD *)(v5 + 8);
    if ( v20 && *(_BYTE *)(v5 + 7) == *(_BYTE *)(v4 + 9) )
    {
      v23 = *(_BYTE *)(v5 + 6);
      v27 = (double)v23 / 31.0;
      if ( *(_BYTE *)(v5 + 1) || *(_BYTE *)v5 != 1 )
      {
        v25 = 6926;
        sub_10010AB0(a2, (int)&unk_100660E4, &v39, (int)&v27);
      }
      else
      {
        v14 = v36;
        v15 = *(_BYTE *)(a3 + 16) & 0x3F;
        v29 = 6917;
        if ( v15 == 44 )
          v36 = v33;
        else
          v36 = 4;
        sub_10010AB0(a2, (int)&unk_100660E4, &v35, (int)&v29);
        v36 = v14;
        sub_10010AB0(a2, (int)&unk_100660E4, &v39, (int)&v27);
      }
    }
    else
    {
      sub_10010AB0(a2, (int)&unk_100660E4, &v31, (int)&v26);
      v16 = *(_BYTE *)(v4 + 10) && *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) != -128;
      *(_BYTE *)(a2 + 3) = v16;
      sub_10010AB0(a2, (int)&unk_100660E4, &v32, (int)&v30);
      if ( *(_BYTE *)(v5 + 1) && *(_BYTE *)(v4 + 10) )
        sub_10010AB0(a2, (int)&unk_100660E4, &v38, 0);
    }
    *(_BYTE *)(a2 + 3) = 0;
    sub_10010AB0(a2, (int)&unk_100660E4, &v34, (int)&v28);
    if ( (_WORD)v22 != 6
      && (*(_BYTE *)(v5 + 1) || (*(_BYTE *)(a3 + 16) & 0x3F) != 44 && !v20 || (*(_BYTE *)(a3 + 16) & 0x3F) == 44) )
    {
      sub_10010AB0(a2, (int)&unk_100660E4, &v37, (int)&v22);
    }
  }
  sub_10010AB0(a2, (int)&unk_100660E4, &v35, (int)&v25);
  result = v24;
  *(_BYTE *)(a2 + 3) = v24;
  return result;
}

//----- (1000C0A0) --------------------------------------------------------
char __cdecl sub_1000C0A0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // eax@1
  int v6; // edx@2
  int v7; // edi@5
  char v8; // al@5
  __int16 v9; // ax@8
  void *v10; // ecx@8
  __int16 v11; // dx@13
  _BYTE *v12; // edi@18
  char v13; // cl@18
  bool v14; // sf@18
  void *v15; // ecx@29
  int v16; // eax@40
  int v17; // eax@40
  int v18; // ST30_4@40
  unsigned __int8 v19; // ST30_1@43
  int v20; // eax@43
  char v22; // [sp+13h] [bp-85h]@1
  signed int v23; // [sp+14h] [bp-84h]@0
  int v24; // [sp+1Ch] [bp-7Ch]@0
  int v25; // [sp+20h] [bp-78h]@6
  char v26; // [sp+28h] [bp-70h]@6
  char v27; // [sp+3Ch] [bp-5Ch]@6
  char v28; // [sp+50h] [bp-48h]@6
  char v29; // [sp+60h] [bp-38h]@6
  char v30; // [sp+70h] [bp-28h]@6
  char v31; // [sp+80h] [bp-18h]@6

  v5 = a3;
  v22 = 1;
  if ( *(_WORD *)a5 == -32703 )
  {
    v6 = v24;
  }
  else
  {
    v6 = *(_DWORD *)(a4 + 16);
    v24 = *(_DWORD *)(a4 + 16);
  }
  switch ( *(_WORD *)a5 )
  {
    case 0x8041:
      v7 = sub_100027E0(a1, 12);
      *(_DWORD *)(a4 + 16) = v7;
      *(_BYTE *)(v7 + 6) = 0;
      *(_DWORD *)(v7 + 8) = 0;
      *(_BYTE *)(v7 + 5) = 0;
      sub_10004A40(71, (_BYTE *)v7);
      sub_10004A40(74, (_BYTE *)(v7 + 1));
      sub_10004A40(1, (_BYTE *)(v7 + 3));
      sub_10004A40(2, (_BYTE *)(v7 + 4));
      sub_10004A40(51, (_BYTE *)(v7 + 2));
      v8 = sub_1000B660(a2, a4);
      sub_10017630(v8, (void *)(v7 + 6));
      break;
    case 0x8040:
      sub_1000B790((int)&v26, a2, a1, a3, a4, (int)&v29, (int)&v30, (int)&v27, (int)&v25, (int)&v28, (int)&v31);
      v22 = sub_10010AB0(a1, a5, &v26, a4 + 4);
      break;
    case 0x8048:
      if ( *(_BYTE *)(a4 + 11) == 1 )
      {
        *(_DWORD *)(v6 + 8) = 0;
        LOBYTE(v23) = sub_1000B660(a2, a4);
        v9 = *(_WORD *)(a2 + 16) & 0x3F;
        v10 = (void *)*(_WORD *)(a5 + 10);
        if ( (unsigned __int16)v10 == (v9 != 44 ? 27 : 2) || *(_WORD *)(a5 + 10) == 82 )
        {
          if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128 )
          {
            sub_1000B790((int)&v26, a2, a1, a3, a4, (int)&v29, (int)&v30, (int)&v27, (int)&v25, (int)&v28, (int)&v31);
            sub_10010AB0(a1, a5, &v26, a4 + 4);
          }
          if ( !*(_BYTE *)(a5 + 16) || sub_10010E80(v10) == 1 )
          {
            v16 = *(_DWORD *)a4;
            *(_DWORD *)a4 = *(_DWORD *)(a4 + 4);
            *(_DWORD *)(a4 + 4) = v16;
            v17 = sub_10003FF0();
            v18 = *(_DWORD *)a4;
            *(_DWORD *)(a4 + 12) = v17;
            sub_100147B0(v23, 1, v18);
            sub_100147B0(v23, 0, *(_DWORD *)(a4 + 4));
          }
          goto LABEL_46;
        }
        if ( (unsigned __int16)v10 == (v9 != 44 ? 61 : 66)
          || (unsigned __int16)v10 == (v9 != 44 ? 62 : 67)
          || (unsigned __int16)v10 == (v9 != 44 ? 34 : 37)
          || (v11 = *(_WORD *)(a5 + 10), v25 = *(_WORD *)(a5 + 10), v11 == 0x2000)
          || v11 == 73
          || v11 == 33
          || v11 == 32 )
        {
          sub_1000B790((int)&v26, a2, a1, a3, a4, (int)&v29, (int)&v30, (int)&v27, (int)&v25, (int)&v28, (int)&v31);
          v22 = sub_10010AB0(a1, a5, &v26, a4 + 4);
          if ( v22 == 3 )
          {
            if ( !*(_BYTE *)(a5 + 16) || sub_10010E80(v15) == 1 )
              sub_100147B0(v23, 0, *(_DWORD *)(a4 + 4));
            v22 = 2;
          }
          if ( *(_BYTE *)(v24 + 1) )
            sub_10010AB0(a1, (int)&unk_100660E4, &v28, 0);
        }
        else
        {
          if ( (unsigned __int16)v10 == (v9 != 44) + 58 )
          {
            v12 = (_BYTE *)(v24 + 6);
            sub_10017630(v23, (void *)(v24 + 6));
            v13 = *(_BYTE *)(a5 + 8);
            v14 = (char)(v13 + *(_BYTE *)(v24 + 6)) < 0;
            *v12 += v13;
            if ( v14 )
            {
              *v12 = 0;
            }
            else if ( *(_BYTE *)(v24 + 6) > 0x1Fu )
            {
              *v12 = 31;
            }
            *(_BYTE *)(v24 + 5) = 1;
            *(_DWORD *)(v24 + 8) = sub_10003FF0() + 2000;
            *(_BYTE *)(v24 + 7) = *(_BYTE *)(a4 + 9);
            goto LABEL_46;
          }
          if ( v9 == 44 )
          {
            if ( (_WORD)v25 == 42 )
            {
              sub_10019220(v23);
              goto LABEL_46;
            }
          }
          else if ( (_WORD)v25 == 41 )
          {
            sub_10014B80(v23);
            goto LABEL_46;
          }
        }
      }
      else
      {
        v22 = 2;
        sub_1000B760(a3, a2, a1);
      }
      break;
    case 0x8022:
    case 0x8078:
      if ( *(_BYTE *)(v6 + 5) )
      {
        v19 = *(_BYTE *)(v6 + 6);
        LOBYTE(v20) = sub_1000B660(a2, a4);
        sub_10017670(v20, v19);
        v5 = a3;
        *(_BYTE *)(v24 + 5) = 0;
      }
      sub_1000BD10(a4, a1, a2, v5);
      if ( *(_BYTE *)(a4 + 11) != 1 )
        sub_1000B760(a3, a2, a1);
LABEL_46:
      v22 = 2;
      break;
    default:
      return v22;
  }
  return v22;
}

//----- (1000C570) --------------------------------------------------------
void *__usercall sub_1000C570@<eax>(int a1@<ecx>, int a2@<esi>, unsigned int *a3)
{
  unsigned int v3; // eax@1
  int v4; // edi@1
  unsigned int v5; // ebx@2
  void *result; // eax@2
  char v7; // [sp+4h] [bp-44h]@2
  char v8[32]; // [sp+24h] [bp-24h]@2

  v3 = *a3;
  v4 = 3 - ((*(_BYTE *)(a1 + 8) & 0x3F) != 44);
  if ( *a3 == 0xFFFF )
  {
    result = memset((void *)a2, 95, v4 + 4);
    *(_BYTE *)(a2 + 3) = 46;
    *(_BYTE *)(a2 + v4 + 4) = 0;
  }
  else
  {
    v5 = v3 % 0x3E8;
    sprintf(&v7, "%0*i", 3, v3 / 0x3E8);
    sprintf(v8, "%03i", v5);
    v8[v4] = 0;
    strncat(&v7, ".", 0x1Bu);
    strncat(&v7, v8, 0x1Au);
    result = strncpy((char *)a2, &v7, 0x1Eu);
  }
  return result;
}
// 1000C570: using guessed type char var_24[32];

//----- (1000C640) --------------------------------------------------------
int __usercall sub_1000C640@<eax>(unsigned int a1@<eax>, int a2@<esi>, char a3, int a4)
{
  int v4; // edx@1
  char *v5; // ecx@1
  int result; // eax@1

  v4 = byte_101D8171[20 * ((a1 >> 10) & 0xF)];
  v5 = (char *)&unk_101D8160 + 20 * ((a1 >> 10) & 0xF);
  result = a2 * v4 + (a2 - 1) * *(_WORD *)(dword_101D8164[5 * ((a1 >> 10) & 0xF)] + 28);
  if ( a4 > 0 )
  {
    if ( a3 & 0x80 )
      result += v5[15] - v4;
  }
  return result;
}
// 101D8164: using guessed type int dword_101D8164[];

//----- (1000C690) --------------------------------------------------------
signed int __usercall sub_1000C690@<eax>(int a1@<eax>, void *a2@<ecx>, unsigned int *a3, int a4)
{
  unsigned int *v4; // ebp@1
  signed int v5; // edi@1
  unsigned int v6; // ebx@4
  signed int v7; // esi@4
  unsigned int v8; // edx@6
  int v9; // eax@9
  int v10; // edx@9
  unsigned int v11; // edx@10
  int v12; // ebx@17
  signed int result; // eax@17
  signed int v14; // [sp+10h] [bp-4h]@2
  signed int v15; // [sp+18h] [bp+4h]@2

  v4 = a3;
  v5 = (signed int)a2;
  LOWORD(a2) = *(_WORD *)(a1 + 8) & 0x3F;
  if ( (_WORD)a2 == 45 )
  {
    v15 = 108;
    v14 = 117;
  }
  else
  {
    v15 = 118;
    v14 = 136;
  }
  v6 = *v4 / 0x3E8;
  v7 = *v4 % 0x3E8;
  if ( v5 )
  {
    if ( (_WORD)a2 == 45 )
    {
      v8 = (signed int)((unsigned __int64)(1374389535i64 * (50 * v5 + v7)) >> 32) >> 4;
      v7 = 50 * (v8 + (v8 >> 31));
    }
    else if ( sub_10017540(a2) == 1 )
    {
      v7 = 25 * ((25 * v5 + v7) / 25);
    }
    else
    {
      v9 = v5 % 4 + v7 % 25 / 5;
      v10 = 0;
      if ( v5 >= 0 )
      {
        v11 = v9 < 4 ? 0 : 5;
      }
      else
      {
        LOBYTE(v10) = v9 >= 0;
        v11 = (v10 - 1) & 0xFFFFFFFB;
      }
      v7 = 5
         * (((signed int)((unsigned __int64)(1717986919i64 * (signed int)(v5 % 4 + v11 + 4 * (v5 % 4) + v7)) >> 32) >> 1)
          + 5 * (v5 / 4)
          + ((unsigned int)((unsigned __int64)(1717986919i64 * (signed int)(v5 % 4 + v11 + 4 * (v5 % 4) + v7)) >> 32) >> 31));
    }
    if ( v7 >= 0 )
    {
      if ( v7 >= 1000 )
        v7 -= 1000;
    }
    else
    {
      v7 += 1000;
    }
  }
  v12 = a4 + v6;
  result = v14;
  if ( v12 <= v14 )
  {
    if ( v12 < v15 )
      v12 = v14;
    *v4 = v7 + 1000 * v12;
  }
  else
  {
    *v4 = v7 + 1000 * v15;
  }
  return result;
}

//----- (1000C810) --------------------------------------------------------
int __usercall sub_1000C810@<eax>(int a1@<ebx>, int a2, unsigned int *a3)
{
  unsigned int v3; // esi@1
  char v4; // cl@1
  unsigned int v5; // edi@2
  unsigned int v6; // ecx@2
  unsigned int v7; // edx@2
  unsigned int v8; // eax@2
  int result; // eax@10
  float v10; // ST04_4@15
  float v11; // ST00_4@15
  double v12; // st7@15
  unsigned int v13; // ecx@15
  signed int v14; // edx@18

  v3 = *a3;
  v4 = *(_BYTE *)(a1 + 8) & 0x3F;
  if ( v4 == 45 )
  {
    v5 = 50;
    v6 = 117950;
    v7 = 108000;
    v8 = 117000;
  }
  else
  {
    if ( sub_10017540((void *)v4) == 1 )
    {
      v5 = 25;
      v6 = 136975;
    }
    else
    {
      v5 = 5;
      v6 = 136990;
    }
    v8 = 1000 * (v6 / 0x3E8);
    v7 = 118000;
  }
  if ( *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) == 2 )
  {
    if ( v3 < v7 || v3 > v6 )
      return -1;
    goto LABEL_13;
  }
  if ( v3 <= v6 )
  {
LABEL_13:
    if ( v3 < v7 )
      v3 = v7;
    goto LABEL_15;
  }
  v3 = v8;
LABEL_15:
  v10 = (double)v5;
  v11 = (double)v3;
  v12 = sub_1003C9F0(v11, v10);
  v13 = (signed __int64)v12;
  if ( (*(_BYTE *)(a1 + 8) & 0x3F) != 44 || v5 != 5 || v13 % 0x19 / 5 != 4 )
  {
    result = (signed __int64)v12;
  }
  else
  {
    v14 = *a3 % 0xA != 0 ? -1 : 1;
    result = v14 + v13 + 4 * v14;
  }
  return result;
}

//----- (1000C960) --------------------------------------------------------
char __usercall sub_1000C960@<al>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // ax@1

  v3 = *(_WORD *)(a3 + 12);
  *(_WORD *)(a2 + 438) = *(_WORD *)a1;
  *(_WORD *)(a2 + 436) = *(_WORD *)(a1 + 2);
  if ( !*(_WORD *)(a3 + 12) )
    v3 = sub_1000C640(*(_DWORD *)(a3 + 4), *(_BYTE *)(a3 + 10), *(_WORD *)(a3 + 8), *(_BYTE *)(a3 + 11));
  return sub_1000F5A0(
           a2,
           (char *)(*(_DWORD *)(a2 + 56) + 69),
           (const char *)&unk_10058CA9,
           v3,
           0,
           *(_DWORD *)(a3 + 4),
           *(_WORD *)(a3 + 8));
}

//----- (1000C9C0) --------------------------------------------------------
char __usercall sub_1000C9C0@<al>(int a1@<ebx>, int a2@<edi>, int a3, unsigned int *a4)
{
  __int16 v4; // ax@1
  char v6; // [sp+8h] [bp-24h]@1

  sub_1000C570(a2, (int)&v6, a4);
  *(_WORD *)(a1 + 438) = *(_WORD *)a3;
  *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
  v4 = *(_WORD *)(a2 + 12);
  if ( !v4 )
    v4 = sub_1000C640(*(_DWORD *)(a2 + 4), *(_BYTE *)(a2 + 10), *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 11));
  return sub_1000F5A0(a1, &v6, (const char *)&unk_10058CA9, v4, 0, *(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8));
}

//----- (1000CA60) --------------------------------------------------------
char __usercall sub_1000CA60@<al>(unsigned int *a1@<edx>, int a2@<ecx>, int a3@<edi>)
{
  size_t v3; // ebp@1
  char *v4; // eax@1
  int v5; // esi@1
  char v6; // dl@2
  char v7; // bl@3
  char *v8; // eax@3
  char v9; // dl@3
  char v10; // cl@4

  v3 = 3 - ((*(_BYTE *)(a2 + 8) & 0x3F) != 44);
  sub_1000C570(a2, *(_DWORD *)(a3 + 56) + 69, a1);
  v4 = (char *)(*(_DWORD *)(a3 + 56) + 69);
  v5 = *(_DWORD *)(a3 + 56) + 70;
  do
    v6 = *v4++;
  while ( v6 );
  v7 = (_BYTE)v4 - v5;
  v8 = strchr((const char *)(*(_DWORD *)(a3 + 56) + 69), 46);
  v9 = (_BYTE)v8 + 1;
  do
    v10 = *v8++;
  while ( v10 );
  memset((void *)((char)(v7 - ((_BYTE)v8 - v9)) + *(_DWORD *)(a3 + 56) + 70), 48, v3);
  *(_WORD *)(*(_DWORD *)(a3 + 56) + 240) = 0;
  return 4;
}

//----- (1000CAF0) --------------------------------------------------------
int __usercall sub_1000CAF0@<eax>(int a1@<eax>, void *a2@<ecx>, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  double v6; // st7@1
  int v7; // eax@1
  unsigned __int8 v8; // bl@1
  char *v9; // eax@3
  char v10; // dl@4
  double v11; // st7@10
  int v12; // eax@10
  int v13; // esi@10
  int v14; // edx@11
  int v15; // eax@11
  int result; // eax@15
  int v17; // [sp+18h] [bp-4h]@1

  v4 = a1;
  v5 = (unsigned __int8)sub_10017540(a2);
  v6 = atof((const char *)(*(_DWORD *)(v4 + 56) + 69));
  v7 = sub_1003C9C0(v6 * 1000.0);
  v8 = *(_BYTE *)(a4 + 14);
  v17 = v7;
  if ( v8 != 46 || *(_BYTE *)(a3 + 11) <= 0 )
  {
    if ( (*(_BYTE *)(a3 + 8) & 0x3F) == 45 && strchr((&off_1005DD30)[4 * *(_WORD *)(*(_DWORD *)(v4 + 56) + 240)], v8)
      || (*(_BYTE *)(a3 + 8) & 0x3F) == 44
      && strchr((**(&off_1005DD28 + v5))[*(_WORD *)(*(_DWORD *)(v4 + 56) + 240)], v8) )
    {
      *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = v8;
      v11 = atof((const char *)(*(_DWORD *)(v4 + 56) + 69));
      a4 = sub_1003C9C0(v11 * 1000.0);
      v12 = sub_1000C810(a3, v4, (unsigned int *)&a4);
      v13 = *(_DWORD *)(v4 + 56) + 69;
      a4 = v12;
      if ( v12 == -1 )
      {
        sub_1000C570(a3, v13, (unsigned int *)&v17);
      }
      else
      {
        sub_1000C570(a3, v13, (unsigned int *)&a4);
        ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
        v14 = *(_DWORD *)(v4 + 56);
        v15 = *(_BYTE *)(a3 + 10) - 1;
        if ( *(_WORD *)(v14 + 240) < v15 )
          LOWORD(v15) = *(_WORD *)(v14 + 240);
        *(_WORD *)(v14 + 240) = (char)v15;
      }
    }
  }
  else
  {
    v9 = (char *)(*(_DWORD *)(v4 + 56) + 69);
    do
      v10 = *v9++;
    while ( v10 );
    *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)((_BYTE)v9
                                                  - (*(_BYTE *)(v4 + 56)
                                                   + 70)
                                                  - strlen(strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46)))
                                           + 1;
  }
  result = *(_DWORD *)(v4 + 56);
  if ( *(_BYTE *)(*(_WORD *)(result + 240) + result + 69) == 46 )
    ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
  return result;
}
// 1005DD28: using guessed type char *(*off_1005DD28)[14];

//----- (1000CCB0) --------------------------------------------------------
char __cdecl sub_1000CCB0(int a1, int a2, __int64 a3, int a4)
{
  __int16 v4; // cx@2
  unsigned int v5; // edi@3
  int v6; // eax@3
  char result; // al@3
  unsigned __int16 v8; // cx@6
  unsigned __int16 v9; // ax@6
  int v10; // ecx@12
  int v11; // eax@12
  int v12; // eax@14
  void *v13; // ecx@17
  double v14; // st7@28
  unsigned __int16 v15; // ax@36
  void *v16; // ecx@39
  char v17; // [sp+1Bh] [bp-1h]@1

  v17 = 1;
  switch ( *(_WORD *)a4 )
  {
    case 0x8040:
      v4 = *(_WORD *)(a2 + 12);
      if ( v4 )
      {
        sub_1000F440(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(a2 + 4), v4);
        result = 2;
      }
      else
      {
        v5 = *(_DWORD *)(a2 + 4);
        v6 = sub_1000C640(*(_DWORD *)(a2 + 4), *(_BYTE *)(a2 + 10), *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 11));
        sub_1000F440(a1 + 276, *(_DWORD *)a3, v5, v6);
        result = 2;
      }
      return result;
    case 0x8048:
      if ( ~((unsigned int)*(_WORD *)(a2 + 8) >> 10) & 1 )
      {
        v8 = *(_WORD *)(a2 + 14);
        v9 = *(_WORD *)(a4 + 10);
        if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
        {
          if ( v9 == v8 )
          {
            sub_1000C690(a2, (void *)*(_BYTE *)(a4 + 8), (unsigned int *)HIDWORD(a3), 0);
            v17 = 3;
            goto LABEL_44;
          }
          if ( v9 == v8 + 1 )
          {
            sub_1000C690(a2, 0, (unsigned int *)HIDWORD(a3), *(_BYTE *)(a4 + 8));
            v17 = 3;
            goto LABEL_44;
          }
          if ( v9 == 33 )
          {
            sub_1000FE40(*(_DWORD *)HIDWORD(a3));
            return 1;
          }
          if ( v9 != 0x2000 )
            return v17;
          v15 = *(_WORD *)(a4 + 14);
          if ( (v15 < 0x30u || v15 > 0x39u) && v15 != 46 )
            return v17;
          v17 = sub_1000CA60((unsigned int *)HIDWORD(a3), a2, a1);
          sub_1000CAF0(a1, v16, a2, a4);
          if ( v17 != 4 )
          {
            if ( v17 != 3 )
              return v17;
            goto LABEL_44;
          }
        }
        else
        {
          v17 = 4;
          if ( v9 == v8 )
          {
            sub_1000C690(a2, (void *)*(_BYTE *)(a4 + 8), (unsigned int *)HIDWORD(a3), 0);
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = -128;
            v17 = 3;
LABEL_44:
            sub_1000C9C0(a1, a2, a3, (unsigned int *)HIDWORD(a3));
            return v17;
          }
          if ( v9 == v8 + 1 )
          {
            sub_1000C690(a2, 0, (unsigned int *)HIDWORD(a3), *(_BYTE *)(a4 + 8));
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = -128;
            v17 = 3;
            goto LABEL_44;
          }
          if ( v9 == 73 )
          {
            v10 = --*(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = (char)(v10 <= 0 ? 0 : v10);
            v11 = *(_BYTE *)(a2 + 10) - 1;
            if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v11 )
              LOWORD(v11) = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = (char)v11;
            v12 = *(_DWORD *)(a1 + 56);
            if ( *(_BYTE *)(*(_WORD *)(v12 + 240) + v12 + 69) == 46 )
            {
              --*(_WORD *)(v12 + 240);
              sub_1000C960(a3, a1, a2);
              return 4;
            }
            goto LABEL_40;
          }
          if ( v9 == 0x2000 )
          {
            if ( (v13 = (void *)*(_WORD *)(a4 + 14), (unsigned __int16)v13 >= 0x30u) && (unsigned __int16)v13 <= 0x39u
              || (_WORD)v13 == 46 )
            {
              sub_1000CAF0(a1, v13, a2, a4);
              sub_1000C960(a3, a1, a2);
              return 4;
            }
          }
          if ( v9 == 33 || v9 == ((*(_WORD *)(a2 + 8) & 0x3F) != 44 ? 27 : 2) || v9 == 82 )
          {
            v14 = atof((const char *)(*(_DWORD *)(a1 + 56) + 69));
            *(_DWORD *)HIDWORD(a3) = sub_1003C9C0(v14 * 1000.0);
LABEL_27:
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = -128;
            v17 = 3;
            goto LABEL_44;
          }
          if ( v9 == 37 || v9 == 34 || v9 == 32 )
            goto LABEL_27;
        }
LABEL_40:
        sub_1000C960(a3, a1, a2);
        return v17;
      }
      if ( *(_WORD *)(a4 + 10) != 33 )
        return v17;
      sub_1000FE40(*(_DWORD *)HIDWORD(a3));
      return 1;
    case 0x8022:
    case 0x8078:
      if ( !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
      {
        sub_1000C9C0(a1, a2, a3, (unsigned int *)HIDWORD(a3));
        return 2;
      }
      sub_1000C960(a3, a1, a2);
      return 2;
    default:
      return v17;
  }
}

//----- (1000D130) --------------------------------------------------------
char __cdecl sub_1000D130(int a1, int a2, int *a3, int a4, int a5)
{
  int v5; // ecx@1
  char result; // al@1
  bool v7; // zf@2
  __int16 v8; // dx@3

  v5 = a4;
  result = 1;
  if ( *(_DWORD *)(a4 + 8) )
  {
    v7 = *(_BYTE *)a4 == 0;
    a4 = *a3;
    if ( !v7 )
    {
      v8 = *(_WORD *)(v5 + 4);
      if ( *(_BYTE *)(v5 + 1) )
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2) + a4;
        HIWORD(a4) += v8;
      }
      else
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2);
        HIWORD(a4) = v8;
      }
    }
    result = ((int (__cdecl *)(int, _DWORD, int *, _DWORD, int))dword_101D7CE0[2 * (**(_DWORD **)(v5 + 8) & 0xFF)])(
               a1,
               *(_DWORD *)(v5 + 8),
               &a4,
               *(_DWORD *)(v5 + 12),
               a5);
  }
  return result;
}
// 101D7CE0: using guessed type int dword_101D7CE0[];

//----- (1000D1A0) --------------------------------------------------------
int __usercall sub_1000D1A0@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int8 a3)
{
  unsigned __int8 v3; // bl@1
  int v4; // edi@1
  int v5; // esi@1

  v3 = 0;
  v4 = a1;
  v5 = a2;
  if ( a3 )
  {
    do
    {
      sub_1004FFD0(
        v5 + 392,
        v3,
        v3,
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) - 2 * v3,
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) - 2 * v3,
        0);
      ++v3;
    }
    while ( v3 < a3 );
  }
  *(_WORD *)(v5 + 428) = word_1010F158[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 430) = word_1010F158[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 440) = word_1010F158[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 442) = word_1010F158[*(_BYTE *)(v4 + 4) & 0x1F];
  return sub_1004FFD0(
           v5 + 392,
           a3,
           a3,
           *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) - 2 * a3,
           *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) - 2 * a3,
           1);
}
// 1010F158: using guessed type __int16 word_1010F158[];

//----- (1000D280) --------------------------------------------------------
char __cdecl sub_1000D280(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1
  __int16 v6; // bx@5
  int v7; // ecx@5
  int v8; // eax@8
  signed int v9; // ebp@8
  int v10; // eax@10
  int v11; // eax@15
  int v12; // eax@15
  int v13; // eax@15
  int v14; // eax@17
  char v15; // al@19
  bool v16; // zf@19
  int v17; // eax@23
  int v18; // eax@28
  int v19; // esi@28

  result = 1;
  if ( *a5 == 32802 || *a5 == 32888 )
  {
    if ( *(_DWORD *)(a1 + 64) == 9 )
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 248) = 1;
    v6 = word_1010F158[(unsigned __int8)sub_10017570(*(_BYTE *)(a2 + 4) & 0x1F)];
    v7 = *(_BYTE *)(a2 + 4) & 0xE0;
    if ( !(*(_BYTE *)(a2 + 4) & 0xE0) )
    {
      v17 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 428) = v6;
      *(_WORD *)(a1 + 430) = v6;
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      if ( !*(_BYTE *)(v17 + 25)
        && (*(_WORD *)(v17 + 40) || *(_WORD *)(v17 + 42) || *(_WORD *)(v17 + 44) || *(_WORD *)(v17 + 46)) )
      {
        sub_1004FFD0(a1 + 392, 0, 0, *(_WORD *)(v17 + 32), *(_WORD *)(v17 + 42), 1);
        sub_1004FFD0(
          a1 + 392,
          0,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 42),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 40),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 46),
          1);
        v18 = *(_DWORD *)(a1 + 56);
        sub_1004FFD0(
          a1 + 392,
          *(_WORD *)(v18 + 44) + *(_WORD *)(v18 + 40),
          *(_WORD *)(v18 + 42),
          *(_WORD *)(v18 + 32) - *(_WORD *)(v18 + 40) - *(_WORD *)(v18 + 44),
          *(_WORD *)(v18 + 46),
          1);
        v19 = *(_DWORD *)(a1 + 56);
        sub_1004FFD0(
          a1 + 392,
          0,
          *(_WORD *)(v19 + 46) + *(_WORD *)(v19 + 42),
          *(_WORD *)(v19 + 32),
          *(_WORD *)(v19 + 34) - *(_WORD *)(v19 + 42) - *(_WORD *)(v19 + 46),
          1);
        return 2;
      }
      sub_1004FFD0(a1 + 392, 0, 0, *(_WORD *)(v17 + 32), *(_WORD *)(v17 + 34), 1);
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 25) = 0;
      return 2;
    }
    if ( v7 == 32 )
    {
      *(_WORD *)(a1 + 428) = word_1010F158[(unsigned __int8)sub_10017570(15)];
      *(_WORD *)(a1 + 430) = word_1010F158[(unsigned __int8)sub_10017570(15)];
      *(_WORD *)(a1 + 440) = word_1010F158[(unsigned __int8)sub_10017570(15)];
      *(_WORD *)(a1 + 442) = word_1010F158[(unsigned __int8)sub_10017570(15)];
      sub_1000D1A0(a2, a1, 2u);
      return 2;
    }
    if ( v7 != 96 )
    {
      *(_WORD *)(a1 + 428) = word_1010F158[1];
      *(_WORD *)(a1 + 430) = word_1010F158[1];
      *(_WORD *)(a1 + 440) = word_1010F158[1];
      v8 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 442) = word_1010F158[1];
      sub_1004FFD0(a1 + 392, 0, 0, *(_WORD *)(v8 + 32), *(_WORD *)(v8 + 34), 1);
      *(_WORD *)(a1 + 428) = word_1010F158[15];
      *(_WORD *)(a1 + 430) = word_1010F158[14];
      sub_1004FFD0(a1 + 392, 0, 3, *(_WORD *)(*(_DWORD *)(a1 + 56) + 32), *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 6, 2);
      *(_WORD *)(a1 + 428) = word_1010F158[13];
      *(_WORD *)(a1 + 430) = word_1010F158[1];
      sub_1004FFD0(
        a1 + 392,
        1,
        4,
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) - 2,
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 8,
        2);
      *(_WORD *)(a1 + 428) = word_1010F158[14];
      *(_WORD *)(a1 + 430) = word_1010F158[12];
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      v9 = 2;
      do
      {
        sub_1004FFD0(
          a1 + 392,
          v9,
          v9 + 3,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) - 2 * v9,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 2 * (v9 + 3),
          2);
        ++v9;
      }
      while ( v9 < 6 );
      v10 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      if ( !*(_BYTE *)(v10 + 25)
        && (*(_WORD *)(v10 + 40) || *(_WORD *)(v10 + 42) || *(_WORD *)(v10 + 44) || *(_WORD *)(v10 + 46)) )
      {
        sub_1004FFD0(a1 + 392, 6, 9, *(_WORD *)(v10 + 32) - 12, *(_WORD *)(v10 + 34) - 18, 2);
        v11 = *(_DWORD *)(a1 + 56);
        *(_WORD *)(a1 + 428) = v6;
        *(_WORD *)(a1 + 430) = v6;
        sub_1004FFD0(a1 + 392, 6, 9, *(_WORD *)(v11 + 32) - 12, *(_WORD *)(v11 + 42) - 9, 1);
        sub_1004FFD0(
          a1 + 392,
          6,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 42),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 40) - 6,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 46),
          1);
        v12 = *(_DWORD *)(a1 + 56);
        sub_1004FFD0(
          a1 + 392,
          *(_WORD *)(v12 + 44) + *(_WORD *)(v12 + 40),
          *(_WORD *)(v12 + 42),
          *(_WORD *)(v12 + 32) - *(_WORD *)(v12 + 40) - *(_WORD *)(v12 + 44) - 6,
          *(_WORD *)(v12 + 46),
          1);
        v13 = *(_DWORD *)(a1 + 56);
        sub_1004FFD0(
          a1 + 392,
          6,
          *(_WORD *)(v13 + 46) + *(_WORD *)(v13 + 42),
          *(_WORD *)(v13 + 32) - 12,
          *(_WORD *)(v13 + 34) - *(_WORD *)(v13 + 42) - *(_WORD *)(v13 + 46) - 9,
          1);
      }
      else
      {
        sub_1004FFD0(a1 + 392, 6, 9, *(_WORD *)(v10 + 32) - 12, *(_WORD *)(v10 + 34) - 18, 3);
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 25) = 0;
      }
      v14 = *(_DWORD *)(a1 + 56);
      if ( *(_BYTE *)(v14 + 247) )
      {
        *(_WORD *)(a1 + 428) = word_1010F158[15];
        *(_WORD *)(a1 + 430) = word_1010F158[15];
        *(_WORD *)(a1 + 440) = word_1010F158[1];
        *(_WORD *)(a1 + 442) = word_1010F158[1];
        sub_1004FFD0(a1 + 392, 10, 13, *(_WORD *)(v14 + 32) - 20, *(_WORD *)(v14 + 34) - 26, 3);
        return 2;
      }
      return 2;
    }
    *(_WORD *)(a1 + 428) = word_1010F158[(unsigned __int8)sub_10017570(15)];
    *(_WORD *)(a1 + 430) = word_1010F158[(unsigned __int8)sub_10017570(15)];
    *(_WORD *)(a1 + 440) = word_1010F158[(unsigned __int8)sub_10017570(15)];
    v15 = sub_10017570(15);
    v16 = (*(_BYTE *)(a1 + 22) & 0x1E) == 0;
    *(_WORD *)(a1 + 442) = word_1010F158[(unsigned __int8)v15];
    if ( v16 )
    {
      sub_1000D1A0(a2, a1, 2u);
      result = 2;
    }
    else
    {
      sub_1000D1A0(a2, a1, 5u);
      result = 2;
    }
  }
  return result;
}
// 1010F158: using guessed type __int16 word_1010F158[];

//----- (1000D830) --------------------------------------------------------
unsigned int __usercall sub_1000D830@<eax>(int a1@<ebx>, int a2@<esi>, unsigned __int16 *a3)
{
  int v3; // edi@1
  int v4; // ST38_4@1
  int v5; // eax@1
  __int16 v6; // cx@1
  unsigned int result; // eax@1
  char v8; // [sp+Ch] [bp-204h]@1

  v3 = BMP_get_bm_def(*a3);
  v4 = *(_DWORD *)(a2 + 460);
  v5 = sub_1000FED0(*a3, *(_BYTE *)(a2 + 3), (int)&v8);
  v6 = *(_WORD *)(a2 + 432);
  *(_DWORD *)(a2 + 460) = v5;
  result = sub_100055D0(
             a2 + 392,
             v3,
             0,
             0,
             *(_WORD *)a1 + *(_WORD *)(a2 + 434),
             *(_WORD *)(a1 + 2) + v6,
             *(_WORD *)(v3 + 6),
             *(_WORD *)(v3 + 4));
  *(_DWORD *)(a2 + 460) = v4;
  return result;
}
// 1003C5BE: using guessed type int __cdecl BMP_get_bm_def(_DWORD);

//----- (1000D8E0) --------------------------------------------------------
char __cdecl sub_1000D8E0(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char result; // al@1
  int v6; // eax@8
  __int16 v7; // dx@8
  __int16 v8; // si@8

  result = 1;
  if ( *a5 == 32802 )
    goto LABEL_11;
  if ( *a5 == 32832 )
  {
    v6 = BMP_get_bm_def(*a4);
    v7 = *(_WORD *)(v6 + 6);
    v8 = *(_WORD *)(v6 + 4);
    *(_WORD *)(a1 + 276) = *(_WORD *)a3;
    *(_WORD *)(a1 + 278) = *(_WORD *)(a3 + 2);
    *(_WORD *)(a1 + 280) = v7 + *(_WORD *)a3 - 1;
    *(_WORD *)(a1 + 282) = v8 + *(_WORD *)(a3 + 2) - 1;
    return 2;
  }
  if ( *a5 == 32888 )
  {
LABEL_11:
    if ( *a4 != -1 )
      sub_1000D830(a3, a1, a4);
    result = 2;
  }
  return result;
}
// 1003C5BE: using guessed type int __cdecl BMP_get_bm_def(_DWORD);

//----- (1000D980) --------------------------------------------------------
signed int __cdecl sub_1000D980(_BYTE *a1, int a2)
{
  signed int result; // eax@1
  float *v3; // ecx@2
  float *v4; // edi@2
  float *v5; // ecx@6
  int v6; // edx@6

  result = 0;
  if ( *a1 )
  {
    v3 = (float *)(a2 + 440);
    v4 = (float *)(a1 + 12);
    while ( result < 10 )
    {
      ++result;
      *(v3 - 1) = *v4;
      *(_BYTE *)v3 = a1[result + 91];
      ++v4;
      v3 += 2;
      if ( result >= *a1 )
      {
        if ( result >= 10 )
          return result;
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    v5 = (float *)(a2 + 8 * result + 440);
    v6 = 10 - result;
    do
    {
      *(v5 - 1) = 9.8999998e24;
      *(_BYTE *)v5 = 10;
      v5 += 2;
      --v6;
    }
    while ( v6 );
  }
  return result;
}

//----- (1000D9F0) --------------------------------------------------------
signed int __cdecl sub_1000D9F0(int a1, signed int a2, int a3)
{
  signed int result; // eax@1
  int *v4; // edx@2
  int v5; // ecx@2

  result = 0;
  if ( a2 > 0 )
  {
    v4 = (int *)(a3 + 48);
    v5 = a1 + 8;
    do
    {
      if ( result >= 3 )
        break;
      *v4 = v5;
      ++result;
      v5 += 12;
      v4 += 12;
    }
    while ( result < a2 );
  }
  return result;
}

//----- (1000DA30) --------------------------------------------------------
int __cdecl sub_1000DA30(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)(a2 + 52) = *(float *)a1;
  *(float *)(a2 + 56) = *(float *)(a1 + 4);
  *(float *)(a2 + 100) = *(float *)a1;
  *(float *)(a2 + 104) = *(float *)(a1 + 4);
  *(float *)(a2 + 148) = *(float *)a1;
  *(float *)(a2 + 152) = *(float *)(a1 + 4);
  return result;
}

//----- (1000DA60) --------------------------------------------------------
void __usercall sub_1000DA60(int a1@<eax>, int a2)
{
  int v2; // esi@1
  unsigned __int8 v3; // bl@1
  float **v4; // ebp@1
  int v5; // edi@1
  float *v6; // ecx@2
  char v7; // al@4
  unsigned __int8 v8; // [sp+23h] [bp-5h]@1
  char v9; // [sp+24h] [bp-4h]@1

  v2 = a1;
  v9 = 0;
  v8 = 0;
  v3 = 0;
  v4 = (float **)(a1 + 48);
  v5 = a1 + 528;
  do
  {
    v6 = *v4;
    if ( *v4 )
    {
      if ( 9.8999998e24 != *v6 )
      {
        v7 = sub_10019520(*v6, v2 + 436, 10, v5);
        if ( (unsigned __int8)v9 < (unsigned __int8)v7 )
        {
          v9 = v7;
          v8 = v3;
        }
      }
    }
    ++v3;
    v5 += 28;
    v4 += 12;
  }
  while ( v3 < 3u );
  sub_100196A0(v9, (_DWORD *)(v2 + 188), (int *)(v2 + 184), *(_BYTE *)(v2 + 175), *(_DWORD *)(v2 + 28 * v8 + 536));
  sub_100196A0(v9, (_DWORD *)(v2 + 240), (int *)(v2 + 236), *(_BYTE *)(v2 + 175), *(_DWORD *)(v2 + 28 * v8 + 536));
  sub_10019500(a2, v2 + 176);
  sub_10019500(a2, v2 + 228);
}

//----- (1000DB50) --------------------------------------------------------
int __usercall sub_1000DB50@<eax>(int a1@<edi>, int a2, int a3, float a4, float a5, float a6, float a7)
{
  int v7; // eax@1
  double v8; // st6@1
  int v9; // ebp@1
  int v10; // esi@1
  double v11; // st5@1
  char *v12; // eax@4
  char v13; // cl@5
  int v14; // eax@6
  signed int v15; // ecx@6
  double v16; // st6@6
  double v17; // st5@6
  double v18; // st4@6
  double v19; // st3@6
  double v20; // st7@6
  double v21; // rt1@7
  double v22; // st3@7
  double v23; // rtt@7
  double v24; // rt0@8
  double v25; // st3@8
  double v26; // st6@8
  double v27; // rt1@8
  double v28; // st3@8
  double v29; // st5@8
  double v30; // rt2@8
  double v31; // st3@8
  double v32; // st4@8
  double v33; // rtt@8
  double v34; // st3@8
  double v35; // st7@8
  double v36; // rt0@8
  double v37; // st3@8
  double v38; // st6@8
  float v40; // [sp+14h] [bp+14h]@1
  float v41; // [sp+18h] [bp+18h]@3

  v7 = a3;
  *(float *)a1 = a4;
  *(float *)(a1 + 4) = a5;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = a6;
  *(float *)(a1 + 8) = a6;
  v9 = a1 + 528;
  *(float *)(a1 + 12) = a7;
  v10 = a1 + 32;
  LODWORD(v40) = 3;
  *(float *)(a1 + 20) = *(float *)(a3 + 4);
  v11 = *(float *)(a3 + 8);
  *(_BYTE *)(a1 + 172) = 1;
  *(float *)(a1 + 24) = v11;
  while ( 1 )
  {
    *(_DWORD *)(v10 + 4) = 0;
    v41 = a4 + v8;
    *(float *)(v10 - 4) = v41;
    *(_DWORD *)(v10 + 8) = -1;
    *(_DWORD *)(v10 + 12) = -1;
    *(float *)v10 = a5;
    *(_BYTE *)(v10 + 42) = 0;
    *(float *)(v10 + 20) = *(float *)(v7 + 4);
    *(float *)(v10 + 24) = *(float *)(v7 + 8);
    *(_DWORD *)(v10 + 16) = 0;
    *(_BYTE *)(v10 + 41) = 0;
    *(_BYTE *)(v10 + 40) = 0;
    *(float *)(v10 + 28) = 1.0;
    *(float *)(v10 + 32) = 1.0;
    *(float *)(v10 + 36) = 15.0;
    sub_10019730(v9);
    v10 += 48;
    v9 += 28;
    --LODWORD(v40);
    if ( v40 == 0.0 )
      break;
    v7 = a3;
  }
  v12 = (char *)a2;
  *(float *)(a1 + 176) = a4;
  *(float *)(a1 + 180) = a5;
  *(_WORD *)(a1 + 516) = 12;
  *(_DWORD *)(a1 + 520) = &unk_1005F404;
  *(_BYTE *)(a1 + 524) = 1;
  *(_DWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 188) = -1;
  do
  {
    v13 = *v12;
    v12[a1 - a2 + 192] = *v12;
    ++v12;
  }
  while ( v13 );
  *(_DWORD *)(a1 + 236) = 0;
  *(float *)(a1 + 216) = 0.0;
  *(_DWORD *)(a1 + 240) = -1;
  *(_BYTE *)(a1 + 244) = 0;
  *(float *)(a1 + 220) = 1.0;
  v14 = a1 + 284;
  v15 = 3;
  *(float *)(a1 + 224) = 12.0;
  *(float *)(a1 + 228) = a4;
  v16 = a4;
  *(float *)(a1 + 232) = a5;
  v17 = a5;
  *(float *)(a1 + 268) = 0.0;
  v18 = 0.0;
  *(float *)(a1 + 272) = 1.0;
  v19 = 12.0;
  v20 = 1.0;
  *(float *)(a1 + 276) = 12.0;
  while ( 1 )
  {
    v24 = v19;
    v25 = v16;
    v26 = v24;
    *(_DWORD *)(v14 + 4) = 0;
    *(float *)(v14 - 4) = v25;
    *(_DWORD *)(v14 + 8) = -1;
    v27 = v25;
    v28 = v17;
    v29 = v27;
    *(_BYTE *)(v14 + 12) = 0;
    *(float *)v14 = v28;
    v14 += 52;
    --v15;
    v30 = v28;
    v31 = v18;
    v32 = v30;
    *(float *)(v14 - 16) = v31;
    v33 = v31;
    v34 = v20;
    v35 = v33;
    *(float *)(v14 - 12) = v34;
    v36 = v34;
    v37 = v26;
    v38 = v36;
    *(float *)(v14 - 8) = v37;
    if ( !v15 )
      break;
    v21 = v37;
    v22 = v35;
    v20 = v38;
    v23 = v22;
    v16 = v29;
    v17 = v32;
    v19 = v21;
    v18 = v23;
  }
  *(_WORD *)(a1 + 173) = 0;
  *(_BYTE *)(a1 + 175) = 0;
  return sub_1000D980((_BYTE *)a3, a1);
}

//----- (1000DD20) --------------------------------------------------------
int __cdecl sub_1000DD20(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  return sub_1000DB50(a1, a2, a3, a4, a5, a6, a7);
}

//----- (1000DD60) --------------------------------------------------------
void __cdecl sub_1000DD60(int a1, int a2)
{
  int v2; // esi@1
  int *v3; // ebx@1
  int v4; // edi@1
  float *v5; // ecx@3
  char v6; // ST40_1@9
  signed int v7; // [sp+20h] [bp-8h]@1

  v2 = a2 + 288;
  v3 = (int *)(a2 + 536);
  v4 = a2 + 48;
  v7 = 3;
  do
  {
    if ( *(_BYTE *)(v2 + 8) )
    {
      v5 = *(float **)v4;
      if ( *(_DWORD *)v4 )
      {
        if ( *(_BYTE *)(v4 + 26)
          || 9.8999998e24 != *v5
          && (!*(_BYTE *)(v4 + 24) || *(float *)(v4 + 4) <= (double)*v5 && *(float *)(v4 + 8) >= (double)*v5) )
        {
          v6 = sub_10019520(*v5, a2 + 436, 10, (int)(v3 - 2));
          sub_100196A0(v6, (_DWORD *)(v2 + 4), (int *)v2, *(_BYTE *)(a2 + 173), *v3);
          sub_10019500(a1, v2 - 8);
        }
      }
    }
    v4 += 48;
    v3 += 7;
    v2 += 52;
    --v7;
  }
  while ( v7 );
}

//----- (1000DE30) --------------------------------------------------------
void __usercall sub_1000DE30(int a1@<esi>, int a2)
{
  signed int v2; // ebx@1
  int *v3; // ebp@2
  int v4; // edi@2
  float *v5; // ecx@4
  char v6; // ST44_1@11

  v2 = 0;
  if ( *(_BYTE *)(a1 + 172) )
  {
    v3 = (int *)(a1 + 536);
    v4 = a1 + 48;
    do
    {
      if ( v2 >= 3 )
        break;
      v5 = *(float **)v4;
      if ( *(_DWORD *)v4 && *(_BYTE *)(a1 + 174) != 1 )
      {
        if ( !*(_BYTE *)(v4 + 26)
          && (9.8999998e24 == *v5
           || *(_BYTE *)(v4 + 24) && (*(float *)(v4 + 4) > (double)*v5 || *(float *)(v4 + 8) < (double)*v5)) )
        {
          sub_10019420(v4 - 20);
        }
        else
        {
          v6 = sub_10019520(*v5, a1 + 436, 10, (int)(v3 - 2));
          sub_10019610(v6, (_DWORD *)(v4 - 8), (int *)(v4 - 12), *(_BYTE *)(a1 + 174), *v3);
          sub_10019250(a2, v4 - 20, *(_WORD *)(a1 + 516), *(_DWORD *)(a1 + 520), *(_BYTE *)(a1 + 524));
        }
      }
      ++v2;
      v3 += 7;
      v4 += 48;
    }
    while ( v2 < *(_BYTE *)(a1 + 172) );
  }
}

//----- (1000DF40) --------------------------------------------------------
char __cdecl sub_1000DF40(int a1, int a2, int a3, int a4, _WORD *a5)
{
  switch ( *a5 )
  {
    case 0x8015:
    case 0x8016:
    case 0x8022:
    case 0x8078:
      sub_1000DA60(a4, a1);
      sub_1000DD60(a1, a4);
      sub_1000DE30(a4, a1);
      break;
    default:
      return 1;
  }
  return 1;
}

//----- (1000E000) --------------------------------------------------------
char __cdecl sub_1000E000(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v6; // eax@4
  float v7; // ST38_4@5
  float v8; // ST38_4@5
  float v9; // ST24_4@5
  float v10; // ST38_4@5
  float v11; // ST20_4@5
  float v12; // ST38_4@5
  float v13; // ST28_4@5
  float v14; // ST2C_4@5
  float v15; // ST1C_4@5
  float v16; // ST30_4@5
  float v17; // ST24_4@5
  float v18; // ST20_4@5
  float v19; // ST30_4@5
  float v20; // ST2C_4@5
  float v21; // ST38_4@5
  float v22; // ST28_4@5
  float v23; // ST34_4@5
  float v24; // ST38_4@6
  float v25; // ST30_4@6
  float v26; // ST34_4@6
  float v27; // ST38_4@6
  float v28; // ST38_4@6
  float v29; // ST34_4@6
  float v30; // ST38_4@6
  double v31; // st7@6
  float v32; // ST08_4@8
  float v33; // [sp+4h] [bp-30h]@6
  float v34; // [sp+10h] [bp-24h]@4
  float v35; // [sp+48h] [bp+14h]@4
  float v36; // [sp+48h] [bp+14h]@6

  if ( *a5 != 32802 && *a5 != 32888 )
    return 1;
  v6 = *(_DWORD *)(a1 + 56);
  v34 = (double)*(_WORD *)(v6 + 34);
  v35 = (double)*(_WORD *)(v6 + 32);
  if ( !(*(_BYTE *)(a2 + 4) & 1) )
  {
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 8));
    sub_10003BE0(0.0, 0.0);
    sub_10003BE0(v35, 0.0);
    sub_10003BE0(v35, v34);
    v33 = v34;
    v31 = 0.0;
    goto LABEL_8;
  }
  j_gdi_pvg_begin(72);
  j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 8));
  sub_10003BE0(0.0, 0.0);
  sub_10003BE0(v35, 0.0);
  sub_10003BE0(v35, v34);
  sub_10003BE0(0.0, v34);
  j_gdi_pvg_color_u32(-16777216);
  sub_10003BE0(0.0, 0.0);
  sub_10003BE0(v35, 0.0);
  v7 = 0.0 + 3.0;
  sub_10003BE0(v35, v7);
  sub_10003BE0(0.0, v7);
  v8 = v34 - 3.0;
  sub_10003BE0(0.0, v8);
  sub_10003BE0(v35, v8);
  sub_10003BE0(v35, v34);
  sub_10003BE0(0.0, v34);
  j_gdi_pvg_end();
  sub_10003B00(1.0);
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-1);
  v9 = v34 - 3.5;
  v10 = 0.0 + 0.5;
  sub_10003BE0(v10, v9);
  v11 = 0.0 + 3.5;
  sub_10003BE0(v10, v11);
  v12 = v35 - 0.0;
  sub_10003BE0(v12, v11);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-8355712);
  v13 = 0.0 + 1.5;
  sub_10003BE0(v13, v9);
  v14 = v35 - 0.5;
  sub_10003BE0(v14, v9);
  sub_10003BE0(v14, v11);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-4144960);
  v15 = v34 - 4.5;
  sub_10003BE0(v13, v15);
  v16 = 0.0 + 4.5;
  sub_10003BE0(v13, v16);
  sub_10003BE0(v14, v16);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-16777216);
  v17 = 0.0 + 2.5;
  sub_10003BE0(v17, v15);
  v18 = v35 - 1.5;
  sub_10003BE0(v18, v15);
  sub_10003BE0(v18, v16);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(73);
  j_gdi_pvg_color_u32(-14671840);
  sub_10003BE0(v17, v15);
  v19 = v34 - 9.5;
  v20 = 0.0 + 7.5;
  sub_10003BE0(v20, v19);
  sub_10003BE0(v18, v15);
  v21 = v35 - 6.5;
  sub_10003BE0(v21, v19);
  v22 = 0.0 + 5.5;
  sub_10003BE0(v18, v22);
  v23 = 0.0 + 10.5;
  sub_10003BE0(v21, v23);
  j_gdi_pvg_end();
  j_gdi_pvg_begin(73);
  j_gdi_pvg_color_u32(-8355712);
  sub_10003BE0(v17, v15);
  sub_10003BE0(v20, v19);
  sub_10003BE0(v17, v22);
  sub_10003BE0(v20, v23);
  sub_10003BE0(v18, v22);
  sub_10003BE0(v21, v23);
  j_gdi_pvg_end();
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 247) )
  {
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(-1);
    v24 = 0.0 + 14.0;
    v25 = 0.0 + 11.0;
    sub_10003BE0(v25, v24);
    v26 = v35 - 11.0;
    sub_10003BE0(v26, v24);
    v27 = v34 - 14.0;
    sub_10003BE0(v26, v27);
    sub_10003BE0(v25, v27);
    j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 8));
    v28 = 0.0 + 15.0;
    v29 = 0.0 + 12.0;
    sub_10003BE0(v29, v28);
    v36 = v35 - 12.0;
    sub_10003BE0(v36, v28);
    v30 = v34 - 15.0;
    sub_10003BE0(v36, v30);
    v33 = v30;
    v31 = v29;
LABEL_8:
    v32 = v31;
    sub_10003BE0(v32, v33);
    j_gdi_pvg_end();
  }
  return 2;
}
// 100039E0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10003A50: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10003AD0: using guessed type int j_gdi_pvg_end(void);

//----- (1000E640) --------------------------------------------------------
__int16 __cdecl sub_1000E640(unsigned int a1)
{
  return byte_101D816F[20 * ((a1 >> 10) & 0xF)];
}

//----- (1000E660) --------------------------------------------------------
char __cdecl sub_1000E660(int a1, _WORD *a2, char **a3, int a4, int a5, int a6)
{
  int v6; // edi@1
  char result; // al@1
  char **v8; // ebp@1
  int v9; // esi@1
  int v10; // ebx@1
  bool v11; // al@7
  bool v12; // al@11
  int v13; // [sp+10h] [bp-4h]@5
  int v14; // [sp+18h] [bp+4h]@2

  v6 = a1;
  result = sub_100012F0(a1, *(_DWORD *)(a1 + 56));
  v8 = a3;
  v9 = *(_DWORD *)*a3 & 0xFF;
  v10 = 0;
  if ( v9 == 141 )
  {
    *(_BYTE *)(a1 + 3) = 0;
  }
  else
  {
    v14 = 0;
    do
    {
      if ( *v8 )
      {
        result = sub_10010980(v6, a5, v10);
        if ( result )
        {
          sub_10010A00(*v8, &v13, 0);
          v11 = v10 == a6 && sub_100109B0(v6, a2, *(_DWORD *)(v6 + 56));
          *(_BYTE *)(v6 + 3) = v11;
          v12 = v10 == a6 && *(_DWORD *)(v6 + 56) == *(_DWORD *)(*(_DWORD *)(v6 + 48) + 4);
          *(_BYTE *)(v6 + 9) = v12;
          result = ((int (__cdecl *)(int, char *, int, _DWORD, _WORD *))dword_101D7CE0[2 * v9])(
                     v6,
                     *v8,
                     v13,
                     *(_DWORD *)(v14 + a4),
                     a2);
        }
      }
      v14 = 4 * ++v10;
      v8 = &a3[v10];
      v9 = *(_DWORD *)a3[v10] & 0xFF;
    }
    while ( v9 != 141 );
    *(_BYTE *)(v6 + 3) = 0;
  }
  return result;
}
// 101D7CE0: using guessed type int dword_101D7CE0[];

//----- (1000E780) --------------------------------------------------------
bool __cdecl sub_1000E780(int a1, _WORD *a2, char *a3, int a4, int a5, int a6)
{
  int v6; // esi@1
  char *v7; // ebp@1
  int v8; // edi@1
  bool result; // al@1
  _WORD *v10; // ebx@2
  int v11; // eax@4
  bool v12; // al@6
  bool v13; // zf@8
  bool v14; // al@10
  char *v15; // [sp+Ch] [bp-8h]@1
  int v16; // [sp+10h] [bp-4h]@1

  v6 = a1;
  sub_100012F0(a1, *(_DWORD *)(a1 + 56));
  v7 = a3;
  v8 = 0;
  result = sub_10010A00(a3, &v16, &v15);
  if ( result )
  {
    v10 = a2;
    do
    {
      if ( sub_10010980(v6, a5, v8) )
      {
        v11 = *(_DWORD *)(v6 + 56);
        LOWORD(a1) = *(_WORD *)v16 + *(_WORD *)(v11 + 36);
        HIWORD(a1) = *(_WORD *)(v16 + 2) + *(_WORD *)(v11 + 38);
        v12 = v8 == a6 && sub_100109B0(v6, v10, v11);
        v13 = v8 == a6;
        *(_BYTE *)(v6 + 3) = v12;
        v14 = v13 && *(_DWORD *)(v6 + 56) == *(_DWORD *)(*(_DWORD *)(v6 + 48) + 4);
        *(_BYTE *)(v6 + 9) = v14;
        ((void (__cdecl *)(int, char *, int *, _DWORD, _WORD *))dword_101D7CE0[2 * (*(_DWORD *)v7 & 0xFF)])(
          v6,
          v7,
          &a1,
          *(_DWORD *)(a4 + 4 * v8),
          v10);
      }
      v7 = v15;
      ++v8;
      result = sub_10010A00(v15, &v16, &v15);
    }
    while ( result );
  }
  *(_BYTE *)(v6 + 3) = 0;
  return result;
}
// 101D7CE0: using guessed type int dword_101D7CE0[];

//----- (1000E880) --------------------------------------------------------
int __cdecl sub_1000E880(unsigned int a1)
{
  __int16 v1; // ax@1
  int v3; // [sp+4h] [bp+4h]@1

  v1 = word_1010F158[(a1 >> 5) & 0x1F];
  HIWORD(v3) = word_1010F158[a1 & 0x1F];
  LOWORD(v3) = v1;
  return v3;
}
// 1010F158: using guessed type __int16 word_1010F158[];

//----- (1000E8B0) --------------------------------------------------------
char *__cdecl sub_1000E8B0(unsigned int a1)
{
  return (char *)&unk_101D8160 + 20 * ((a1 >> 10) & 0xF);
}

//----- (1000E8D0) --------------------------------------------------------
int __cdecl sub_1000E8D0(unsigned int a1)
{
  char *v1; // eax@1
  char v2; // cl@1
  int result; // eax@2

  v1 = sub_1000E8B0(a1);
  if ( v2 & 1 )
    result = *((_DWORD *)v1 + 2);
  else
    result = *((_DWORD *)v1 + 1);
  return result;
}

//----- (1000E8F0) --------------------------------------------------------
signed int __cdecl sub_1000E8F0(__int16 a1)
{
  signed int result; // eax@1

  result = 1073741828;
  if ( a1 & 0xC000 )
  {
    if ( (a1 & 0xC000) == 0x8000 )
      result = 1073741829;
  }
  else
  {
    result = 1073741830;
  }
  return result;
}

//----- (1000E920) --------------------------------------------------------
signed int __cdecl sub_1000E920(int a1)
{
  int v1; // eax@1
  signed int result; // eax@3

  v1 = a1 & 0xC00000;
  if ( a1 & 0xC00000 )
  {
    if ( v1 == 0x400000 )
      result = 1;
    else
      result = v1 != 0x800000 ? 0 : 2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000E950) --------------------------------------------------------
void *sub_1000E950()
{
  void *result; // eax@1

  result = (void *)dword_1010F29C;
  if ( !dword_1010F29C )
    result = &unk_1005FFC0;
  return result;
}
// 1010F29C: using guessed type int dword_1010F29C;

//----- (1000E960) --------------------------------------------------------
int __usercall sub_1000E960@<eax>(_BYTE *a1@<eax>)
{
  int result; // eax@5

  if ( !*a1 )
    goto LABEL_9;
  do
  {
    if ( *a1 == 10 )
      break;
    ++a1;
  }
  while ( *a1 );
  if ( *a1 )
  {
    *a1 = 0;
    result = (int)(a1 + 1);
  }
  else
  {
LABEL_9:
    result = 0;
  }
  return result;
}

//----- (1000E990) --------------------------------------------------------
char __usercall sub_1000E990@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3)
{
  signed int v3; // ebx@1
  char result; // al@1
  char v5; // al@2
  char v6; // [sp+Bh] [bp-5h]@1
  char v7; // [sp+Ch] [bp-4h]@2
  char v8; // [sp+Dh] [bp-3h]@1

  v3 = a1;
  result = 0;
  v6 = 0;
  v8 = 0;
  if ( a1 <= (signed int)a3 )
  {
    do
    {
      v7 = v3;
      v5 = sub_100062D0(a2, &v7, 0);
      if ( v5 > v6 )
        v6 = v5;
      ++v3;
    }
    while ( v3 <= a3 );
    result = v6;
  }
  return result;
}

//----- (1000E9E0) --------------------------------------------------------
char __usercall sub_1000E9E0@<al>(size_t a1@<edx>, signed int a2@<ecx>, int a3@<esi>, const char *a4, int *a5, char a6, char a7)
{
  unsigned int v7; // ecx@1
  int v8; // edi@1
  int v9; // ebx@1
  int v10; // ecx@1
  char *v11; // eax@4
  char v12; // cl@6
  signed __int16 v13; // dx@9
  int v14; // eax@25
  unsigned int v15; // ebx@29
  unsigned __int8 v16; // al@29
  __int16 v17; // dx@37
  __int16 v18; // cx@37
  unsigned int v19; // edi@42
  signed int v20; // ecx@44
  int v21; // edi@46
  unsigned int v22; // edi@52
  __int16 v23; // ax@52
  __int16 v24; // dx@55
  __int16 v25; // cx@55
  int v26; // eax@58
  char result; // al@63
  int v28; // [sp+0h] [bp-6Ch]@0
  int v29; // [sp+Ch] [bp-60h]@1
  char *v30; // [sp+10h] [bp-5Ch]@6
  signed int v31; // [sp+14h] [bp-58h]@1
  int v32; // [sp+18h] [bp-54h]@1
  int v33; // [sp+1Ch] [bp-50h]@1
  int v34; // [sp+20h] [bp-4Ch]@1
  int v35; // [sp+24h] [bp-48h]@1
  int v36; // [sp+28h] [bp-44h]@1
  int v37; // [sp+2Ch] [bp-40h]@1
  int v38; // [sp+30h] [bp-3Ch]@1
  __int16 v39; // [sp+30h] [bp-3Ch]@29
  __int16 v40; // [sp+32h] [bp-3Ah]@29
  int v41; // [sp+34h] [bp-38h]@1
  size_t v42; // [sp+3Ch] [bp-30h]@1
  signed int v43; // [sp+40h] [bp-2Ch]@9
  int v44; // [sp+44h] [bp-28h]@21
  int v45; // [sp+48h] [bp-24h]@15
  unsigned int v46; // [sp+4Ch] [bp-20h]@29
  signed int v47; // [sp+50h] [bp-1Ch]@1
  char v48; // [sp+54h] [bp-18h]@4

  v31 = a2;
  v42 = a1;
  v7 = strlen(a4);
  v34 = a5[2];
  v8 = a5[1];
  v35 = a5[3];
  v9 = v7;
  v36 = a5[4];
  v47 = v7;
  v32 = *a5;
  v33 = v8;
  v37 = a5[5];
  v29 = 0;
  v41 = *(_WORD *)(*a5 + 28);
  v10 = sub_100062D0(*a5, a4, v8);
  v38 = v10;
  if ( (signed __int16)v35 <= 0 )
    LOWORD(v35) = v10;
  if ( (unsigned int)v9 >= 0x14 )
    v11 = (char *)sub_100027E0(a3, v9 + 1);
  else
    v11 = &v48;
  v12 = *(_BYTE *)(a3 + 3);
  v30 = v11;
  if ( v12 && a6 && v31 > 0 )
  {
    v13 = 1;
    v43 = 1;
  }
  else
  {
    v43 = 0;
    v13 = 1;
  }
  v45 = v12 && (!a6 || v31 >= 0 && v31 + 1 <= v9);
  v44 = *(_BYTE *)(a3 + 3) && a6 && (v31 < 0 || (signed int)(v31 + v42) < v9);
  if ( (v8 & 3) != 2 )
  {
    if ( v8 & 3 )
    {
      *(_WORD *)(a3 + 438) += (signed __int16)v35 / -2;
      v14 = ((signed __int16)v35 - v38) / 2;
    }
    else
    {
      *(_WORD *)(a3 + 438) += v13 - v35;
      v14 = (signed __int16)v35 - v38;
    }
    v8 = v8 & 0xFFFFFFFE | 2;
    v33 = v8;
    if ( v14 > 0 )
      v29 = v14;
  }
  v15 = v8 & 0xFFFFFFF7 | 4;
  v39 = v35 + v41 + *(_WORD *)(a3 + 438);
  v16 = v34;
  v40 = *(_WORD *)(a3 + 436);
  v46 = v8 & 0xFFFFFFF7 | 4;
  if ( !v43 && !v45 && v44 )
    v16 = 0;
  if ( *(_BYTE *)(a3 + 3) && !a6 && (byte_101A5AB6 || byte_101D7CC0) )
  {
    v17 = v36;
    v18 = HIWORD(v35);
  }
  else
  {
    v17 = HIWORD(v35);
    v18 = v36;
  }
  *(_WORD *)(a3 + 428) = v17;
  *(_WORD *)(a3 + 430) = v18;
  sub_10006330(a3 + 392, v32, &unk_10058CA9, v35, v8 & 0xFFFFFFF7 | 4, v16, v28);
  *(_WORD *)(a3 + 438) += v29;
  if ( *(_BYTE *)(a3 + 3) )
  {
    if ( v43 )
    {
      v19 = v8 & 0xFFFFFFF3;
      if ( a7 )
        --*(_WORD *)(a3 + 438);
      strncpy(v30, a4, v31);
      v20 = v31;
      if ( v31 >= v47 )
        v20 = v47;
      v30[v20] = 0;
      *(_WORD *)(a3 + 428) = HIWORD(v35);
      *(_WORD *)(a3 + 430) = v36;
      v21 = sub_10006330(a3 + 392, v32, v30, v35 - v29, v19 | 0x80000000, 0, v37) + v29;
      if ( a7 )
        *(_WORD *)(a3 + 438) += v41 + 1;
      else
        *(_WORD *)(a3 + 438) += v41;
      v15 = v46;
      v29 = v41 + v21;
      v8 = v33;
    }
    if ( v45 )
    {
      if ( a6 )
      {
        v22 = v34 & 0xFFFF0001 | 1;
        strncpy(v30, &a4[v31], v42);
        v30[v42] = 0;
        v23 = 0;
      }
      else
      {
        LOWORD(v22) = (unsigned __int8)v34;
        strcpy(v30, a4);
        v23 = v35 - v29;
      }
      if ( byte_101A5AB6 || byte_101D7CC0 )
      {
        v24 = v36;
        v25 = HIWORD(v35);
      }
      else
      {
        v24 = HIWORD(v35);
        v25 = v36;
      }
      *(_WORD *)(a3 + 428) = v24;
      *(_WORD *)(a3 + 430) = v25;
      v26 = sub_10006330(a3 + 392, v32, v30, v23, v15 | 0x80000000, v22, v37);
      v8 = v33;
      *(_WORD *)(a3 + 438) += v41;
      v29 += v41 + v26;
    }
    if ( v44 )
    {
      if ( a7 )
        ++*(_WORD *)(a3 + 438);
      *(_WORD *)(a3 + 428) = HIWORD(v35);
      *(_WORD *)(a3 + 430) = v36;
      sub_10006330(
        a3 + 392,
        v32,
        &a4[((v42 + v31) & 0x80000000) != 0 ? 0 : v42 + v31],
        v35 - v29,
        v8 & 0xFFFFFFF3 | 0x80000000,
        0,
        v37);
    }
  }
  else
  {
    *(_WORD *)(a3 + 428) = HIWORD(v35);
    *(_WORD *)(a3 + 430) = v36;
    sub_10006330(a3 + 392, v32, a4, v35 - v29, v8 | 0x80000000, v34, v37);
  }
  *(_WORD *)(a3 + 436) = v40;
  result = (char)v30;
  *(_WORD *)(a3 + 438) = v39;
  if ( v30 != &v48 )
    result = sub_10002440(a3, (unsigned int)v30);
  return result;
}
// 101A5AB6: using guessed type char byte_101A5AB6;
// 101D7CC0: using guessed type char byte_101D7CC0;

//----- (1000EEE0) --------------------------------------------------------
__int16 __cdecl sub_1000EEE0(_BYTE *a1, unsigned int a2)
{
  int v2; // edi@1
  __int16 result; // ax@2
  int v4; // ebx@3
  _BYTE *v5; // edx@3
  int v6; // ebp@3
  int v7; // esi@4
  _BYTE *v8; // edx@4
  int v9; // eax@4

  v2 = 0;
  if ( *a1 )
  {
    v4 = sub_1000E8F0(a2);
    v6 = *((_DWORD *)sub_1000E8B0(a2) + 1);
    do
    {
      v7 = sub_1000E960(v5);
      v9 = sub_100062D0(v6, v8, v4);
      if ( v2 <= v9 )
        v2 = v9;
      v5 = (_BYTE *)v7;
    }
    while ( v7 );
    result = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000EF40) --------------------------------------------------------
int __cdecl sub_1000EF40(unsigned int a1, unsigned int a2, float *a3)
{
  int v3; // esi@1
  char *v4; // eax@1

  v3 = *((_DWORD *)sub_1000E8B0(a1) + 1);
  v4 = sub_10017730(a2, a3);
  return sub_100062D0(v3, v4, 0);
}

//----- (1000EF70) --------------------------------------------------------
int sub_1000EF70()
{
  void *v0; // ebx@1
  unsigned __int8 v1; // al@2
  char *v2; // esi@2
  char v3; // al@2
  int v4; // eax@2
  char v5; // al@2
  int v6; // edi@2
  char v7; // al@2
  int v8; // edi@2
  char v9; // al@2
  int result; // eax@2

  v0 = &unk_1005FFCC;
  do
  {
    v1 = *(_BYTE *)v0;
    v2 = (char *)&unk_101D8160 + 20 * ((*((_DWORD *)v0 - 1) >> 10) & 0xF);
    v2[12] = *(_BYTE *)v0;
    *(_DWORD *)v2 = FNT_get_fnt_hdr(v1);
    v3 = *((_BYTE *)v0 + 1);
    v2[13] = v3;
    v4 = FNT_get_fnt_hdr((unsigned __int8)v3);
    *((_DWORD *)v2 + 1) = v4;
    v5 = sub_100062D0(v4, ".", 0);
    v6 = *((_DWORD *)v2 + 1);
    v2[15] = v5;
    v7 = sub_1000E990(0x20u, v6, 0x5Fu);
    v8 = *((_DWORD *)v2 + 1);
    v2[16] = v7;
    v2[17] = sub_1000E990(0x30u, v8, 0x39u);
    v9 = *((_BYTE *)v0 + 2);
    v2[14] = v9;
    result = FNT_get_fnt_hdr((unsigned __int8)v9);
    v0 = (char *)v0 + 8;
    *((_DWORD *)v2 + 2) = result;
  }
  while ( (signed int)v0 < (signed int)"ib\\adl\\cdp_fld_2d_utl.c" );
  return result;
}
// 1003C5B8: using guessed type int __cdecl FNT_get_fnt_hdr(_DWORD);

//----- (1000F010) --------------------------------------------------------
int __cdecl sub_1000F010(int a1, int a2, int a3, unsigned __int8 a4)
{
  _WORD *v4; // eax@1
  int v5; // esi@1
  __int16 v6; // cx@1
  __int16 v7; // dx@1
  _WORD *v8; // edi@1
  int v9; // edx@1
  int result; // eax@3
  int v11; // [sp+10h] [bp-8h]@1
  __int16 v12; // [sp+14h] [bp-4h]@1
  __int16 v13; // [sp+1Ch] [bp+4h]@1
  __int16 v14; // [sp+1Eh] [bp+6h]@1

  v4 = sub_1000E950();
  v5 = a1;
  v6 = *(_WORD *)(a1 + 426);
  v7 = *(_WORD *)(a1 + 424);
  v8 = v4;
  LOWORD(v4) = *(_WORD *)(a1 + 396);
  *(_WORD *)(a1 + 396) = 2;
  v12 = (signed __int16)v4;
  v13 = v6;
  *(_WORD *)(v5 + 426) = v8[3];
  v14 = v7;
  v9 = *(_DWORD *)(v5 + 428);
  *(_WORD *)(v5 + 424) = v8[3];
  v11 = v9;
  if ( a4 >= 2u )
    sub_10003E50("..\\lib\\adl\\cdp_fld_2d_utl.c", 982, 1, 0);
  *(_WORD *)(v5 + 428) = word_1010F158[*((_BYTE *)v8 + a4)];
  *(_WORD *)(v5 + 430) = word_1010F158[*((_BYTE *)v8 + a4 + 2)];
  *(_WORD *)(v5 + 438) = *(_WORD *)a2 + v8[3];
  *(_WORD *)(v5 + 436) = *(_WORD *)(a2 + 2) + v8[3];
  sub_100075A0(v5 + 392, *(_WORD *)a3 - v8[3], *(_WORD *)(a3 + 2) - v8[3], 0);
  *(_WORD *)(v5 + 438) = *(_WORD *)a3 - v8[3];
  *(_WORD *)(v5 + 436) = *(_WORD *)(a2 + 2) + v8[3];
  sub_100075A0(v5 + 392, v8[3] + *(_WORD *)a2, *(_WORD *)(a3 + 2) - v8[3], 0);
  *(_WORD *)(v5 + 426) = v13;
  *(_WORD *)(v5 + 424) = v14;
  result = HIWORD(v11);
  *(_WORD *)(v5 + 396) = v12;
  *(_WORD *)(v5 + 428) = v11;
  *(_WORD *)(v5 + 430) = HIWORD(v11);
  return result;
}
// 1010F158: using guessed type __int16 word_1010F158[];

//----- (1000F190) --------------------------------------------------------
char __cdecl sub_1000F190(int a1, const char *a2, int *a3)
{
  return sub_1000E9E0(
           *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242),
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 240),
           a1,
           a2,
           a3,
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128,
           1);
}

//----- (1000F1D0) --------------------------------------------------------
int __cdecl sub_1000F1D0(unsigned int a1, char a2)
{
  int v2; // eax@1
  int v3; // edx@1
  char v4; // si@1
  signed int v5; // eax@4

  v2 = *((_DWORD *)sub_1000E8B0(a1) + 1);
  v3 = 1;
  v4 = 1;
  if ( !a2 )
  {
    if ( *(_WORD *)(v2 + 22) - *(_WORD *)(v2 + 24) > 1 )
      v3 = *(_WORD *)(v2 + 22) - *(_WORD *)(v2 + 24);
    v5 = *(_WORD *)(v2 + 26);
    if ( v5 > 1 )
      v4 = v5;
  }
  return (((v3 << 8) | (unsigned __int8)v4) << 16) | 0x101;
}

//----- (1000F230) --------------------------------------------------------
char __cdecl sub_1000F230(int a1, const char *a2, int *a3, int a4)
{
  int v4; // eax@1
  unsigned int v5; // edi@1
  int v6; // ebp@1
  int v7; // esi@1
  int v8; // eax@1
  char *v9; // edi@1
  int v10; // ecx@2
  int v11; // ebp@2
  int v12; // ecx@6
  char v14; // [sp+13h] [bp-11h]@1
  char *v15; // [sp+14h] [bp-10h]@1
  unsigned int v16; // [sp+18h] [bp-Ch]@1
  unsigned int v17; // [sp+1Ch] [bp-8h]@1
  __int16 v18; // [sp+20h] [bp-4h]@1
  signed int v19; // [sp+28h] [bp+4h]@1
  __int16 v20; // [sp+2Ch] [bp+8h]@1
  __int16 v21; // [sp+2Eh] [bp+Ah]@1

  v4 = a3[2];
  v5 = (unsigned int)a3[2] >> 24;
  v6 = ((unsigned int)a3[2] >> 16) & 0xFF;
  v16 = v4 & 0xFFFF0001 | 1;
  v14 = 1;
  v17 = (v4 & 0xFFFFFF ^ ((v5 + a4) << 24)) & 0xFFFF0001 | 1;
  v7 = a1;
  v15 = (char *)sub_100027E0(a1, strlen(a2) + 1);
  strcpy(v15, a2);
  v21 = *(_WORD *)(a1 + 436);
  v19 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
  v20 = *(_WORD *)(v7 + 438);
  v8 = v5 + v6 + *(_WORD *)(*a3 + 24) - *(_WORD *)(*a3 + 26);
  v9 = v15;
  v18 = a4 + v8;
  do
  {
    v11 = sub_1000E960(v9);
    *(_WORD *)(v7 + 438) = v20;
    *(_WORD *)(v7 + 436) = v21;
    if ( v11 )
      *(_DWORD *)(v10 + 8) = v17;
    else
      *(_DWORD *)(v10 + 8) = v16;
    if ( *(_BYTE *)(v7 + 3) && (v12 = *(_DWORD *)(v7 + 56), *(_WORD *)(v12 + 240) != -128) )
    {
      if ( v19 >= (signed int)strlen(v9) || v19 < 0 )
      {
        *(_BYTE *)(v7 + 3) = 0;
        sub_1000E9E0(*(_BYTE *)(v12 + 242), -128, v7, v9, a3, 0, 0);
        *(_BYTE *)(v7 + 3) = 1;
      }
      else
      {
        sub_1000E9E0(*(_BYTE *)(v12 + 242), v19, v7, v9, a3, 1, 0);
      }
      v19 -= strlen(v9);
    }
    else
    {
      if ( !v14 )
      {
        LOBYTE(a4) = *(_BYTE *)(v7 + 3);
        *(_BYTE *)(v7 + 3) = 0;
      }
      sub_1000E9E0(
        *(_BYTE *)(*(_DWORD *)(v7 + 56) + 242),
        v19,
        v7,
        v9,
        a3,
        *(_WORD *)(*(_DWORD *)(v7 + 56) + 240) != -128,
        1);
      if ( !v14 )
        *(_BYTE *)(v7 + 3) = a4;
    }
    v21 += v18;
    v9 = (char *)v11;
    v14 = 0;
  }
  while ( v11 );
  return sub_10002440(v7, (unsigned int)v15);
}

//----- (1000F440) --------------------------------------------------------
int __cdecl sub_1000F440(int a1, int a2, unsigned int a3, int a4)
{
  unsigned int v4; // edi@1
  int v5; // eax@1
  unsigned int v6; // ecx@1
  int v7; // edi@1
  int v8; // eax@3
  int result; // eax@3
  int v10; // [sp+18h] [bp+Ch]@1

  v4 = a3;
  v10 = sub_1000F1D0(a3, 0);
  v5 = *((_DWORD *)sub_1000E8B0(v4) + 1);
  *(_WORD *)(a1 + 2) = HIWORD(a2) + *(_WORD *)(v5 + 26) - BYTE2(v10) - *(_WORD *)(v5 + 24) + 1;
  v7 = v4 & 0xC000;
  *(_WORD *)(a1 + 6) = HIWORD(a2) + *(_WORD *)(v5 + 22) + (v6 >> 24) - *(_WORD *)(v5 + 24) - 1;
  if ( v7 )
  {
    if ( v7 == 0x4000 )
    {
      *(_WORD *)(a1 + 4) = a2 + 1;
      result = a2 + 1 - a4 - 1;
      *(_WORD *)a1 = result;
    }
    else
    {
      v8 = a2 - (a4 + 2) / 2 - 1;
      *(_WORD *)a1 = v8;
      result = v8 + a4 + 2 - 1;
      *(_WORD *)(a1 + 4) = result;
    }
  }
  else
  {
    result = a2 - 1;
    *(_WORD *)(a1 + 4) = a2 - 1 + a4 + 1;
    *(_WORD *)a1 = a2 - 1;
  }
  return result;
}

//----- (1000F510) --------------------------------------------------------
__int16 __cdecl sub_1000F510(char *a1, int a2, int a3, int a4, int a5)
{
  unsigned int v5; // eax@1
  unsigned int v6; // edi@1
  int v7; // ebp@1
  int v8; // ebx@1
  char *v9; // eax@1
  int v10; // edx@3

  v5 = sub_1000F1D0(a2, 0);
  v6 = v5 >> 24;
  v7 = (v5 >> 16) & 0xFF;
  v8 = *((_DWORD *)sub_1000E8B0(a2) + 1);
  v9 = strchr(a1, 10);
  for ( *(_DWORD *)a5 = 1; v9; ++*(_DWORD *)a5 )
    v9 = strchr(v9 + 1, 10);
  v10 = a3 + v6 + v7 + *(_WORD *)(v8 + 24) - *(_WORD *)(v8 + 26);
  *(_DWORD *)a4 = v10;
  return *(_WORD *)a5 * v10 - a3;
}

//----- (1000F5A0) --------------------------------------------------------
char __cdecl sub_1000F5A0(int a1, char *a2, const char *a3, __int16 a4, __int16 a5, unsigned int a6, __int16 a7)
{
  char *v7; // eax@1
  int v8; // ebx@1
  signed int v9; // edi@1
  signed int v10; // eax@4
  int v11; // ebp@4
  unsigned int v12; // ebx@4
  int v13; // eax@4
  __int16 v14; // cx@4
  int v15; // edx@4
  int v16; // edi@9
  signed int v17; // ecx@12
  __int64 v18; // rax@12
  __int16 v19; // dx@15
  __int16 v20; // dx@15
  int v21; // eax@17
  signed int v22; // edi@17
  int v24; // [sp+10h] [bp-30h]@1
  unsigned int v25; // [sp+14h] [bp-2Ch]@1
  unsigned int v26; // [sp+18h] [bp-28h]@1
  __int16 v27; // [sp+1Ch] [bp-24h]@2
  int v28; // [sp+1Eh] [bp-22h]@1
  int v29; // [sp+24h] [bp-1Ch]@4
  int v30; // [sp+28h] [bp-18h]@4
  unsigned int v31; // [sp+2Ch] [bp-14h]@4
  int v32; // [sp+30h] [bp-10h]@4
  char v33[6]; // [sp+34h] [bp-Ch]@4
  int v34; // [sp+3Ch] [bp-4h]@4

  v28 = sub_1000E880(a6);
  v7 = sub_1000E8B0(a6);
  v8 = *((_DWORD *)v7 + 1);
  v24 = *((_DWORD *)v7 + 1);
  v26 = sub_1000F1D0(a6, 0) & 0xFFFFFF00;
  v9 = sub_1000E8F0(a6);
  v25 = v9 & 0xFFFFFFFE | 2;
  if ( a7 & 0x200 )
  {
    v27 = 0;
    a3 = (const char *)&unk_10058CA9;
  }
  else
  {
    v27 = a5;
  }
  v10 = sub_1000E920(a6);
  v11 = v10;
  v29 = v10;
  *(_DWORD *)&v33[2] = sub_1000E880(a6);
  v30 = v8;
  v12 = v9 & 0xFFFFFFFC;
  v34 = v11;
  v32 = sub_1000F1D0(a6, 0);
  v31 = v9 & 0xFFFFFFFC;
  *(_WORD *)v33 = a4;
  v13 = sub_100062D0(v30, a2, v9 & 0xFFFFFFFC);
  v14 = v27;
  v15 = 0;
  if ( v27 > 0 && a4 > 0 )
    v15 = *(_WORD *)(v30 + 28);
  if ( a6 & 0xC000 )
  {
    if ( (a6 & 0xC000) == 0x8000 )
    {
      if ( v27 && a4 )
      {
        v17 = v15 + v27 + a4;
        v18 = v13 - *(_WORD *)(v30 + 28) - v27 + 1;
        v16 = (((signed int)v18 - HIDWORD(v18)) >> 1) - 1;
        LODWORD(v18) = v17 / 2 + v16 + 1;
        LOWORD(v17) = v17 - *(_WORD *)(v30 + 28);
        *(_WORD *)v33 = v18;
        v14 = v17 - v18;
        v27 = v14;
      }
      else
      {
        LOWORD(v16) = 0;
        v31 = v12 & 0xFFFFFFFD | 1;
        v25 = v25 & 0xFFFFFFFD | 1;
      }
    }
    else
    {
      v16 = -v27;
    }
  }
  else
  {
    if ( a4 > v13 )
    {
      v19 = v15 - *(_WORD *)(v30 + 28);
      *(_WORD *)v33 = v13;
      v20 = a4 + v19 - v13;
      v14 = v20 + v27;
      v27 += v20;
    }
    LOWORD(v16) = *(_WORD *)v33 - 1;
  }
  *(_WORD *)(a1 + 438) += v16;
  v21 = *(_DWORD *)(a1 + 56);
  v22 = *(_WORD *)(v21 + 240);
  if ( *(_WORD *)v33 > 0 )
  {
    LOBYTE(v21) = sub_1000E9E0(*(_BYTE *)(v21 + 242), v22, a1, a2, &v30, *(_WORD *)(v21 + 240) != -128, 1);
    v14 = v27;
  }
  if ( v14 > 0 )
  {
    if ( v22 != -128 )
      v22 -= strlen(a2);
    LOBYTE(v21) = sub_1000E9E0(
                    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242),
                    v22,
                    a1,
                    a3,
                    &v24,
                    *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128,
                    1);
  }
  return v21;
}

//----- (1000F7C0) --------------------------------------------------------
void __cdecl sub_1000F7C0(int a1, int (__cdecl *a2)(int))
{
  char v2; // bl@2

  if ( !*(_DWORD *)(a1 + 72) )
  {
    v2 = sub_100028C0(*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 32) + 8));
    if ( sub_100028C0(a2) != v2 )
      *(_DWORD *)(a1 + 72) = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 8);
  }
}

//----- (1000F810) --------------------------------------------------------
unsigned int __usercall sub_1000F810@<eax>(unsigned int result@<eax>)
{
  int *v1; // ecx@2
  unsigned int v2; // ecx@3

  if ( !dword_101D8148 )
  {
    dword_101D8148 = *(_DWORD *)(result + 32);
    v1 = *(int **)(result + 32);
    if ( v1 )
    {
      v2 = *v1;
      *(_DWORD *)(result + 32) = v2;
      if ( !v2 || *(_DWORD *)(result + 48) < v2 )
        *(_DWORD *)(result + 48) = v2;
      result = v2;
      if ( v2 )
        *(_DWORD *)(v2 + 4) = 0;
    }
  }
  return result;
}
// 101D8148: using guessed type int dword_101D8148;

//----- (1000F850) --------------------------------------------------------
int __usercall sub_1000F850@<eax>(int result@<eax>)
{
  if ( dword_101D8148 )
  {
    *(_DWORD *)(*(_DWORD *)(result + 32) + 4) = dword_101D8148;
    *(_DWORD *)dword_101D8148 = *(_DWORD *)(result + 32);
    *(_DWORD *)(result + 32) = dword_101D8148;
    dword_101D8148 = 0;
  }
  return result;
}
// 101D8148: using guessed type int dword_101D8148;

//----- (1000F880) --------------------------------------------------------
void __cdecl sub_1000F880(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4, int a5)
{
  void *v5; // ecx@0
  int v6; // ebx@1
  int v7; // esi@1
  int v8; // edi@1
  int v9; // eax@2
  char v10; // bl@13
  int v11; // eax@22
  int v12; // edx@26
  int v13; // ecx@26
  int v14; // edx@26
  int v15; // ecx@26
  int v16; // edx@26
  int v17; // eax@29
  unsigned int v18; // eax@32
  unsigned int v19; // ebx@34
  int v20; // eax@46
  int v21; // eax@59
  bool v22; // al@63
  int v23; // edx@63
  int (__cdecl *v24)(int); // [sp+10h] [bp-D8h]@1
  unsigned int v25; // [sp+14h] [bp-D4h]@32
  __int16 i; // [sp+18h] [bp-D0h]@25
  unsigned int v27; // [sp+1Ch] [bp-CCh]@25
  int v28; // [sp+20h] [bp-C8h]@25
  int v29; // [sp+24h] [bp-C4h]@25
  int v30; // [sp+28h] [bp-C0h]@26
  int v31; // [sp+2Ch] [bp-BCh]@26
  int v32; // [sp+30h] [bp-B8h]@26
  int v33; // [sp+34h] [bp-B4h]@26
  int v34; // [sp+38h] [bp-B0h]@26
  int v35; // [sp+3Ch] [bp-ACh]@26

  v6 = (int)a3;
  v7 = *(_DWORD *)(a1 + 48);
  v8 = 0;
  v24 = a3;
  if ( v7 )
  {
    v9 = a2;
    switch ( a2 )
    {
      case -1:
        sub_1000F850(a1);
        goto LABEL_4;
      case -5:
LABEL_4:
        v8 = *(_DWORD *)(a1 + 32);
        v7 = 0;
        goto LABEL_20;
      case -2:
        v8 = 0;
        do
        {
          if ( sub_10002900(*(int (__cdecl **)(int))(v7 + 8)) != -1 )
            break;
          v8 = v7;
          v7 = *(_DWORD *)(v7 + 4);
        }
        while ( v7 );
        goto LABEL_20;
      case -3:
        do
        {
          if ( sub_10002900(*(int (__cdecl **)(int))(v7 + 8)) != -1 )
            break;
          v7 = *(_DWORD *)(v7 + 4);
        }
        while ( v7 );
        v8 = v7;
        if ( v7 )
          v7 = *(_DWORD *)(v7 + 4);
        goto LABEL_20;
      case -6:
        v8 = *(_DWORD *)(a1 + 48);
        v10 = sub_10002900(a3);
        if ( !v7 )
          goto LABEL_16;
        break;
      case -7:
        if ( (unsigned __int8)sub_10010DB0(v5) )
        {
          sub_1000F810(a1);
          v8 = *(_DWORD *)(a1 + 32);
          v7 = 0;
        }
        else
        {
          sub_1000F7C0(a1, a3);
          v8 = *(_DWORD *)(a1 + 32);
          v7 = 0;
        }
        goto LABEL_20;
      case -8:
        if ( (unsigned __int8)sub_10010DB0(v5) )
        {
          sub_1000F850(a1);
LABEL_45:
          v7 = *(_DWORD *)(a1 + 32);
          v8 = *(_DWORD *)v7;
        }
        else
        {
          v20 = *(_DWORD *)(a1 + 72);
          if ( v20 )
          {
            v8 = *(_DWORD *)(a1 + 32);
            v7 = 0;
            v24 = *(int (__cdecl **)(int))(a1 + 72);
            *(_DWORD *)(a1 + 72) = 0;
            v6 = v20;
          }
        }
        goto LABEL_20;
      case -4:
        goto LABEL_45;
      default:
        if ( a2 > 0 )
        {
          do
          {
            if ( !v7 )
              break;
            --v9;
            v8 = v7;
            v7 = *(_DWORD *)(v7 + 4);
          }
          while ( v9 > 0 );
        }
        goto LABEL_20;
    }
    do
    {
      if ( sub_10002900(*(int (__cdecl **)(int))(v8 + 8)) == v10 )
      {
        if ( *(int (__cdecl **)(int))(v8 + 8) == a3 )
        {
          v8 = *(_DWORD *)v8;
          v24 = 0;
        }
        v7 = *(_DWORD *)(v8 + 4);
        goto LABEL_19;
      }
      v8 = *(_DWORD *)(v8 + 4);
    }
    while ( v8 );
LABEL_16:
    v7 = *(_DWORD *)(a1 + 48);
    v8 = 0;
    if ( v7 )
    {
      while ( sub_10002900(*(int (__cdecl **)(int))(v7 + 8)) == -1 )
      {
        v7 = *(_DWORD *)(v7 + 4);
        if ( !v7 )
          goto LABEL_19;
      }
      v8 = *(_DWORD *)v7;
    }
LABEL_19:
    v6 = (int)v24;
  }
LABEL_20:
  if ( v6 )
  {
    if ( a4 || (v11 = v7) == 0 )
    {
LABEL_25:
      ++*(_BYTE *)(a1 + 4);
      i = -32703;
      v27 = 0;
      v28 = v6;
      LOBYTE(v29) = 0;
      if ( a5 )
      {
        v12 = *(_DWORD *)(a5 + 4);
        v30 = *(_DWORD *)a5;
        v13 = *(_DWORD *)(a5 + 8);
        v31 = v12;
        v14 = *(_DWORD *)(a5 + 12);
        v32 = v13;
        v15 = *(_DWORD *)(a5 + 16);
        v33 = v14;
        v16 = *(_DWORD *)(a5 + 20);
        v34 = v15;
        v35 = v16;
        LOBYTE(v29) = 1;
      }
      sub_100016C0(a1, (int)&i, 204);
    }
    else
    {
      while ( *(_DWORD *)(v11 + 8) != v6 )
      {
        v11 = *(_DWORD *)(v11 + 4);
        if ( !v11 )
          goto LABEL_25;
      }
      v7 = *(_DWORD *)(v11 + 4);
      v8 = v11;
      v24 = 0;
      v6 = 0;
    }
  }
  if ( v8 )
  {
    v17 = sub_10001550(a1, v6);
    if ( !v6 || !v17 || !sub_100010B0(a1, v17) )
    {
      v18 = sub_10001180(a1, v7);
      v25 = v18;
      if ( v18 )
        *(_BYTE *)(v18 + 26) = 0;
      v19 = v7;
      if ( v7 )
      {
        while ( v19 >= v18 )
        {
          i = -32734;
          v27 = v19;
          sub_100016C0(a1, (int)&i, 204);
          v19 = *(_DWORD *)(v19 + 4);
          if ( !v19 )
            break;
          v18 = v25;
        }
      }
      v6 = (int)v24;
    }
  }
  if ( !v6 || v8 )
  {
    if ( v7 && v8 )
    {
      i = -32665;
      v27 = v7;
      v22 = sub_100010B0(a1, *(_DWORD *)v7);
      v23 = *(_DWORD *)(a1 + 56);
      LOBYTE(v28) = v22;
      v29 = *(_DWORD *)(v8 + 8);
      *(_BYTE *)(v23 + 25) = v22;
      sub_100016C0(a1, (int)&i, 204);
    }
  }
  else
  {
    v21 = *(_DWORD *)(a1 + 48);
    if ( v21 )
    {
      i = -32695;
      v27 = v21;
      sub_100016C0(a1, (int)&i, 204);
    }
  }
  for ( i = -32744; v8; v8 = *(_DWORD *)v8 )
  {
    v27 = v8;
    sub_100016C0(a1, (int)&i, 204);
  }
}

//----- (1000FC30) --------------------------------------------------------
void __cdecl sub_1000FC30(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4)
{
  sub_1000F880(a1, a2, a3, a4, 0);
}

//----- (1000FC50) --------------------------------------------------------
void __cdecl sub_1000FC50(int a1, unsigned __int8 a2)
{
  int v2; // edi@1
  double v3; // st7@2
  float *v4; // esi@2

  v2 = a2;
  if ( (signed int)a2 > 0 )
  {
    v3 = 9.8999998e24;
    v4 = (float *)(a1 + 8);
    do
    {
      if ( v3 == *(v4 - 1) )
      {
        *v4 = v3;
      }
      else
      {
        *v4 = sub_10019750(*(v4 - 1), *v4, 40, *(v4 - 2));
        v3 = 9.8999998e24;
      }
      v4 += 3;
      --v2;
    }
    while ( v2 );
  }
}

//----- (1000FCB0) --------------------------------------------------------
void __cdecl sub_1000FCB0(float *a1)
{
  double v1; // st7@3
  float v2; // [sp+0h] [bp-4h]@1

  v2 = 9.8999998e24;
  if ( sub_10016260(1, 184, &v2) )
  {
    if ( *(_BYTE *)dword_101D8250 != 36 )
    {
LABEL_6:
      *a1 = v2;
      return;
    }
    v1 = v2;
    if ( v2 >= -1.0 && v1 <= 120.0 )
    {
      v2 = v1 / 100.0;
      goto LABEL_6;
    }
    v2 = 9.8999998e24;
    *a1 = 9.8999998e24;
  }
  else
  {
    *a1 = 9.8999998e24;
  }
}
// 101D8250: using guessed type int dword_101D8250;

//----- (1000FD40) --------------------------------------------------------
char __thiscall sub_1000FD40(void *this)
{
  void *v1; // ecx@1
  void *v2; // ecx@2
  int v3; // eax@4
  void *v5; // [sp-2h] [bp-4h]@1

  v5 = this;
  BYTE2(v5) = 0;
  v3 = sub_10015220(this) == 2 || !(sub_10011130(v1) & 2) && sub_10015220(v2) == 4;
  sub_100044A0(*(&dword_10061224 + v3), (char *)&v5 + 3, 1, (char *)&v5 + 2);
  return BYTE3(v5);
}

//----- (1000FD90) --------------------------------------------------------
char __cdecl sub_1000FD90(char a1)
{
  void *v1; // ecx@0
  void *v2; // ecx@1
  void *v3; // ecx@2
  bool v4; // bl@4
  void *v5; // ecx@6
  char result; // al@6
  void *v7; // ecx@6
  char v8; // al@7
  void *v9; // ecx@7
  char v10; // al@8
  void *v11; // ecx@8
  char v12; // al@9

  v4 = sub_10015220(v1) == 2 || !(sub_10011130(v2) & 2) && sub_10015220(v3) == 4;
  sub_100043A0(*(&dword_10061224 + v4), (int)&a1, 1);
  result = sub_10011130(v5);
  if ( !(result & 2) )
  {
    v8 = sub_10011500(v7);
    if ( sub_10014530(v8, 4)
      || (v10 = sub_10011500(v9), sub_10014530(v10, 6))
      || (v12 = sub_10011500(v11), (result = sub_10014530(v12, 8)) != 0) )
    {
      result = sub_100043A0(*(&dword_10061224 + (v4 == 0)), (int)&a1, 1);
    }
  }
  return result;
}

//----- (1000FE40) --------------------------------------------------------
int __cdecl sub_1000FE40(int a1)
{
  int result; // eax@1
  int v2; // [sp-10h] [bp-E0h]@2
  __int16 *v3; // [sp-Ch] [bp-DCh]@2
  __int16 v4; // [sp+0h] [bp-D0h]@2
  int v5; // [sp+4h] [bp-CCh]@5
  int v6; // [sp+8h] [bp-C8h]@5

  result = a1;
  if ( (unsigned int)(a1 - 108000) > 0x26DE )
  {
    if ( (unsigned int)(a1 - 118000) > 0x4A2E )
      return result;
    v3 = &v4;
    v4 = -32661;
    v2 = 2;
  }
  else
  {
    v3 = &v4;
    v4 = -32660;
    v2 = 10;
  }
  v5 = 0;
  v6 = a1;
  return sub_100040F0(v2, (int)v3, 60000, 1);
}

//----- (1000FED0) --------------------------------------------------------
int __cdecl sub_1000FED0(unsigned __int16 a1, char a2, int a3)
{
  int result; // eax@1
  int v4; // ebp@1
  char v5; // cl@2
  signed int v6; // edi@2
  unsigned __int16 v7; // si@3
  int v8; // ecx@4
  char v9; // dl@5
  int v10; // esi@10
  int v11; // ecx@11
  __int16 v12; // dx@12
  char v13; // bl@13

  result = BMP_get_xfrm(a1);
  v4 = result;
  if ( a2 )
  {
    v5 = *(_BYTE *)(BMP_get_bm_def(a1) + 8);
    result = a3;
    v6 = 1 << v5;
    if ( v4 )
    {
      v10 = 0;
      if ( v6 > 0 )
      {
        v11 = 0;
        do
        {
          v12 = *(_WORD *)(v4 + 2 * v11);
          if ( (unsigned __int16)v12 < 0x100u )
          {
            v13 = byte_1010F180[(unsigned __int16)v12];
            if ( v13 != 127 )
              v12 = word_1010F158[(unsigned __int8)byte_100617B8[(unsigned __int8)v13]];
          }
          ++v10;
          *(_WORD *)(a3 + 2 * v11) = v12;
          v11 = (unsigned __int16)v10;
        }
        while ( (unsigned __int16)v10 < v6 );
      }
    }
    else
    {
      v7 = 0;
      if ( v6 > 0 )
      {
        v8 = 0;
        do
        {
          v9 = byte_1010F180[v8];
          if ( v9 == 127 )
            *(_WORD *)(a3 + 2 * v8) = v7;
          else
            *(_WORD *)(a3 + 2 * v8) = word_1010F158[(unsigned __int8)byte_100617B8[(unsigned __int8)v9]];
          v8 = ++v7;
        }
        while ( v7 < v6 );
      }
    }
  }
  return result;
}
// 1003C5BE: using guessed type int __cdecl BMP_get_bm_def(_DWORD);
// 1003C5C4: using guessed type int __cdecl BMP_get_xfrm(_DWORD);
// 1010F158: using guessed type __int16 word_1010F158[];

//----- (1000FFA0) --------------------------------------------------------
int sub_1000FFA0()
{
  int v0; // ebx@1
  void *v1; // esi@1
  int result; // eax@2

  memset(byte_1010F180, 127, 0x100u);
  v0 = 0;
  v1 = &unk_1006177D;
  do
  {
    LOBYTE(result) = j_HWM_pvg_get_color(*((char *)v1 - 1), *(_BYTE *)v1, *((_BYTE *)v1 + 1));
    word_1010F158[v0] = (unsigned __int8)result;
    result = (unsigned __int8)result;
    byte_1010F180[(unsigned __int8)result] = v0;
    v1 = (char *)v1 + 3;
    ++v0;
  }
  while ( (signed int)v1 < (signed int)&unk_100617B6 );
  return result;
}
// 10004A90: using guessed type int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD);
// 1010F158: using guessed type __int16 word_1010F158[];

//----- (10010000) --------------------------------------------------------
unsigned int __cdecl sub_10010000(const char *a1, int a2, signed int a3, int a4, int a5, _DWORD *a6)
{
  int v6; // eax@1
  int v7; // ecx@1
  int v8; // esi@2

  v6 = (a3 >> 24) + *(_WORD *)(a2 + 24) + ((a3 >> 16) & 0xFF) - *(_WORD *)(a2 + 26);
  v7 = 0;
  if ( v6 <= a4 )
  {
    v8 = v6 + a5;
    do
    {
      v6 += v8;
      ++v7;
    }
    while ( v6 <= a4 );
  }
  *a6 = v7;
  return strlen(a1) + 2 * (v7 - 1 <= 0 ? 0 : v7 - 1) + 1;
}

//----- (10010070) --------------------------------------------------------
int __cdecl sub_10010070(int a1, int a2, int a3, int a4, int a5, char a6, char *a7)
{
  char *v7; // eax@1
  char *v8; // esi@1
  char *v9; // edx@2
  char v10; // cl@3
  int v11; // ebx@7
  signed int v12; // edi@7
  signed int i; // edx@9
  int v14; // ebp@13
  int v15; // eax@13
  int v16; // ebp@13
  int v17; // edi@13
  char *v18; // eax@14
  char *v19; // ebp@14
  unsigned int v20; // eax@15
  int v21; // ebx@17
  int v22; // eax@17
  int v23; // edi@21
  int j; // ebp@21
  int v25; // ST14_4@22
  int v26; // ST0C_4@22
  char v27; // al@26
  int v28; // edi@29
  char v29; // al@32
  char v30; // al@40
  int v31; // edx@45
  int v32; // ecx@45
  int v33; // edi@55
  char *v34; // eax@58
  char v35; // dl@59
  int v36; // eax@61
  int v37; // edi@61
  int v38; // ecx@67
  char v39; // al@67
  char *v40; // edi@67
  char *v41; // eax@72
  int v42; // edx@72
  char v43; // cl@73
  _BYTE *v44; // ebp@74
  char *v45; // ST2C_4@78
  char v47; // [sp+13h] [bp-25h]@1
  int v48; // [sp+14h] [bp-24h]@14
  char *v49; // [sp+18h] [bp-20h]@26
  int v50; // [sp+1Ch] [bp-1Ch]@1
  signed int v51; // [sp+20h] [bp-18h]@7
  int v52; // [sp+24h] [bp-14h]@21
  int v53; // [sp+24h] [bp-14h]@26
  int v54; // [sp+28h] [bp-10h]@13
  int v55; // [sp+2Ch] [bp-Ch]@1
  signed int v56; // [sp+2Ch] [bp-Ch]@21
  int v57; // [sp+2Ch] [bp-Ch]@26
  int v58; // [sp+30h] [bp-8h]@29
  int v59; // [sp+34h] [bp-4h]@28

  v7 = (char *)a1;
  v8 = a7;
  v47 = 0;
  v55 = 0;
  v50 = 1;
  if ( a7 != (char *)a1 )
  {
    v9 = &a7[-a1];
    do
    {
      v10 = *v7;
      v7[(_DWORD)v9] = *v7;
      ++v7;
    }
    while ( v10 );
  }
  if ( a4 < 1 || a5 < 1 )
  {
    v47 = 1;
    v50 = 0;
    *v8 = 0;
  }
  v11 = a3;
  v12 = (((unsigned int)a3 >> 16) & 0x3F) - 1;
  v51 = v12;
  if ( v12 < 0 )
  {
    v12 = *(_WORD *)(a2 + 28);
    v51 = *(_WORD *)(a2 + 28);
  }
  for ( i = 0; i < (signed int)strlen(v8); ++i )
  {
    if ( v8[i] == 10 )
      ++v55;
  }
  LOWORD(a1) = 10;
  v14 = v12 + sub_100062D0(a2, &a1, a3);
  v15 = sub_100062D0(a2, v8, v11);
  v16 = v55 * v14;
  v17 = a5 * a4 - v16 - v15;
  v54 = a5 * a4 - v16 - v15;
  if ( v47 )
    return -1;
  while ( 1 )
  {
    v18 = strchr(v8, 10);
    v19 = v18;
    v48 = (int)v18;
    if ( v18 )
    {
      LOBYTE(a7) = 1;
      *v18 = 0;
    }
    else
    {
      LOBYTE(a7) = 0;
      v20 = strlen(v8);
      v19 = &v8[v20];
      v48 = (int)&v8[v20];
    }
    v21 = sub_100062D0(a2, v8, a3);
    v22 = a4;
    if ( v21 > a4 )
    {
      if ( v50 >= a5 )
        goto LABEL_79;
      v52 = 0;
      v23 = a4;
      v56 = strlen(v8) - 1;
      for ( j = v56 / 2; ; j = (v56 + j + 1) / 2 )
      {
        while ( 1 )
        {
          v25 = a3;
          LOBYTE(a1) = v8[j + 1];
          v26 = a2;
          v8[j + 1] = 0;
          v21 = sub_100062D0(v26, v8, v25);
          v8[j + 1] = a1;
          if ( v21 <= v23 )
            break;
          v56 = j;
          j = (v52 + j) / 2;
        }
        if ( v51 + v21 + sub_100062D0(a2, &a1, a3) > v23 )
          break;
        v52 = j + 1;
      }
      v57 = v23 - v21;
      v49 = &v8[j];
      v27 = v8[j + 1];
      v53 = j;
      if ( v27 == 32 )
        goto LABEL_67;
      if ( !v27 )
        goto LABEL_67;
      v59 = v54 - v57;
      if ( v54 - v57 <= 0 )
        goto LABEL_67;
      v58 = 0;
      v28 = j;
      if ( j >= 0 )
      {
        while ( 1 )
        {
          if ( !isalnum((unsigned __int8)v8[v28]) || v8[v28] == 45 )
          {
            v29 = v8[v28];
            if ( v29 != 39 && v29 != 40 && v29 != 41 && v29 != 34 )
            {
              if ( v28 <= 0 )
                break;
              if ( v8[v28 - 1] != 32 )
              {
                if ( !isdigit((unsigned __int8)v8[v28 + 1]) || !isdigit((unsigned __int8)v8[v28 - 1]) )
                  break;
                v30 = v8[v28];
                if ( (v30 != 32 || v8[v28 + 2] != 47) && v30 != 47 )
                  break;
              }
            }
          }
          if ( --v28 < 0 )
            goto LABEL_48;
        }
        v31 = a3;
        LOBYTE(a1) = v49[1];
        v32 = a2;
        v49[1] = 0;
        v58 = v51 + sub_100062D0(v32, &v8[v28 + 1], v31);
        v49[1] = a1;
        if ( v8[v28] == 32 && v28 > 0 )
          --v28;
      }
LABEL_48:
      if ( v28 == -1 || v28 == j || v58 > v59 )
      {
        if ( !isalpha((unsigned __int8)*v49) || !isalpha((unsigned __int8)v49[1]) || !a6 )
          goto LABEL_67;
        LOBYTE(a1) = 45;
        v33 = v51 + sub_100062D0(a2, &a1, a3);
        if ( v33 + v21 <= a4 )
        {
          if ( (_BYTE)a7 )
            *(_BYTE *)v48 = 10;
          v34 = v49 + 1;
          do
            v35 = *v34++;
          while ( v35 );
          memcpy_0(v49 + 2, v49 + 1, v34 - (v49 + 2) + 1);
          v21 += v33;
          *(_BYTE *)(v48++ + 1) = 0;
          v49[1] = 45;
          v53 = j + 1;
          goto LABEL_67;
        }
        LOBYTE(a1) = *v49;
        v36 = v51 + sub_100062D0(a2, &a1, a3);
        v37 = v21 + v33 - v36;
        if ( v37 > a4 || v59 < v36 )
        {
LABEL_67:
          v38 = v53;
          v54 -= v57;
          v39 = v8[v53 + 1];
          v40 = &v8[v53 + 1];
          if ( v39 )
          {
            if ( v39 == 32 )
              v38 = v53++ + 1;
            if ( (_BYTE)a7 )
              *(_BYTE *)v48 = 10;
            v40 = &v8[v38 + 1];
            v41 = &v8[v38 + 1];
            v42 = (int)&v8[v38 + 2];
            do
              v43 = *v41++;
            while ( v43 );
            memcpy_0(&v8[v53 + 2], v40, (size_t)&v41[-v42 + 1]);
            v44 = (_BYTE *)(v48 + 1);
            *v40 = 10;
            *(_BYTE *)(v48 + 1) = 0;
          }
          else
          {
            v44 = (_BYTE *)v48;
          }
          if ( (_BYTE)a7 )
          {
            LOBYTE(a7) = 0;
            *v44 = 10;
          }
          v22 = a4;
          v45 = v40;
          v17 = v54;
          v19 = v45;
          goto LABEL_79;
        }
        if ( (_BYTE)a7 )
          *(_BYTE *)v48 = 10;
        memcpy_0(v49 + 1, v49, strlen(v49) + 1);
        *(_BYTE *)(v48++ + 1) = 0;
        *v49 = 45;
        v21 = v37;
      }
      else
      {
        v53 = v28;
        v21 -= v58;
      }
      v57 = a4 - v21;
      goto LABEL_67;
    }
    if ( !(_BYTE)a7 )
      return v50;
    v17 += v21 - a4;
    v54 = v17;
LABEL_79:
    if ( (_BYTE)a7 )
      *v19 = 10;
    if ( v50 >= a5 )
      break;
    if ( !*v19 )
      goto LABEL_85;
    ++v50;
    v8 = v19 + 1;
  }
  if ( *v19 )
  {
LABEL_86:
    *v19 = 0;
    return -1;
  }
LABEL_85:
  if ( v21 > v22 )
    goto LABEL_86;
  return v50;
}

//----- (10010600) --------------------------------------------------------
signed int sub_10010600()
{
  return sub_100053E0((int)&off_10062268);
}
// 10062268: using guessed type char *off_10062268;

//----- (10010610) --------------------------------------------------------
char __cdecl sub_10010610(int a1)
{
  char v1; // bl@1

  v1 = 0;
  if ( (unsigned __int8)sub_10010600() && !sub_100040C0(98, 500) )
  {
    *(_BYTE *)a1 = *(_BYTE *)(dword_1010F280 + 89561);
    *(_BYTE *)(a1 + 1) = *(_BYTE *)(dword_1010F280 + 89562);
    *(_BYTE *)(a1 + 2) = *(_BYTE *)(dword_1010F280 + 90421);
    *(_BYTE *)(a1 + 3) = *(_BYTE *)(dword_1010F280 + 90422);
    v1 = 1;
    sub_100040A0(98);
  }
  return v1;
}
// 1010F280: using guessed type int dword_1010F280;

//----- (10010690) --------------------------------------------------------
char __cdecl sub_10010690(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  int v6; // eax@5
  int v7; // eax@6
  char v8; // [sp+0h] [bp-24h]@5
  char *v9; // [sp+34h] [bp+10h]@1

  v9 = sub_10017500(*a4);
  if ( *a5 != 32802 )
  {
    if ( *a5 == 32832 )
    {
      v6 = sub_10019A30((int)&v8, a3, a2);
      sub_100120D0(a1, (int)v9, v6);
      return 2;
    }
    if ( *a5 != 32888 )
      return 1;
  }
  v7 = sub_10019A30((int)&v8, a3, a2);
  sub_100124E0(a1, (int)v9, v7);
  return 2;
}

//----- (100106B0) --------------------------------------------------------
char __cdecl sub_100106B0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@3
  signed int v6; // ecx@4
  signed int v7; // edx@4
  signed int v8; // eax@4
  float v9; // ST1C_4@5
  float v10; // ST20_4@5
  double v11; // st7@5
  float v12; // ST0C_4@7
  float v13; // [sp+4h] [bp-24h]@5
  float v14; // [sp+Ch] [bp-1Ch]@4
  float v15; // [sp+10h] [bp-18h]@4
  float v16; // [sp+14h] [bp-14h]@4
  float v17; // [sp+18h] [bp-10h]@4
  float v18; // [sp+1Ch] [bp-Ch]@4
  float v19; // [sp+20h] [bp-8h]@4
  float v20; // [sp+24h] [bp-4h]@4
  float v21; // [sp+3Ch] [bp+14h]@4

  if ( *a5 == 32802 || *a5 == 32888 )
  {
    v6 = *(_WORD *)(a3 + 2);
    v7 = *(_WORD *)a3;
    v14 = *(float *)(a2 + 20) + (double)v6;
    v16 = (double)v7;
    v21 = *(float *)(a2 + 16) + (double)v7;
    v15 = (double)v6;
    v20 = v14 - *(float *)(a2 + 24);
    v18 = *(float *)(a2 + 24) + v16;
    v19 = v21 - *(float *)(a2 + 24);
    v17 = *(float *)(a2 + 24) + v15;
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    v8 = sub_100175A0(*(_DWORD *)(a2 + 8));
    j_gdi_pvg_color_u32(v8);
    if ( 1.0 == *(float *)(a2 + 24) )
    {
      j_gdi_pvg_begin(66);
      v9 = v15 + 0.5;
      v10 = v16 + 0.5;
      sub_10003BE0(v10, v9);
      sub_10003BE0(v21, v9);
      sub_10003BE0(v21, v14);
      v13 = v14;
      v11 = v10;
    }
    else
    {
      j_gdi_pvg_begin(73);
      sub_10003BE0(v16, v15);
      sub_10003BE0(v18, v17);
      sub_10003BE0(v21, v15);
      sub_10003BE0(v19, v17);
      sub_10003BE0(v21, v14);
      sub_10003BE0(v19, v20);
      sub_10003BE0(v16, v14);
      sub_10003BE0(v18, v20);
      sub_10003BE0(v16, v15);
      v13 = v17;
      v11 = v18;
    }
    v12 = v11;
    sub_10003BE0(v12, v13);
    j_gdi_pvg_end();
    if ( !(*(_BYTE *)(a2 + 4) & 0x10) )
    {
      j_gdi_pvg_begin(72);
      j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 12));
      sub_10003BE0(v18, v17);
      sub_10003BE0(v19, v17);
      sub_10003BE0(v19, v20);
      sub_10003BE0(v18, v20);
      j_gdi_pvg_end();
    }
    j_gdi_pvg_disable(35);
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100039E0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10003A40: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10003A50: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10003A60: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10003AC0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10003AD0: using guessed type int j_gdi_pvg_end(void);

//----- (10010930) --------------------------------------------------------
_DWORD *__cdecl sub_10010930(_DWORD *a1)
{
  _DWORD *result; // eax@1

  result = a1;
  *a1 = 0;
  return result;
}

//----- (10010940) --------------------------------------------------------
int __cdecl sub_10010940(int *a1, int a2)
{
  int result; // eax@1
  int i; // esi@1

  result = (int)a1;
  for ( i = *a1; i; i = *(_DWORD *)(i + 4) )
    result = (*(int (__cdecl **)(int, int))i)(i, a2);
  return result;
}

//----- (10010970) --------------------------------------------------------
_DWORD *__cdecl sub_10010970(_DWORD *a1, int a2)
{
  _DWORD *result; // eax@1

  result = a1;
  *(_DWORD *)(a2 + 4) = *a1;
  *a1 = a2;
  return result;
}

//----- (10010980) --------------------------------------------------------
char __cdecl sub_10010980(int a1, int a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( **(_WORD **)(a1 + 52) == -32744 || !a2 || *(_BYTE *)(a2 + a3) & 2 )
    result = 1;
  return result;
}

//----- (100109B0) --------------------------------------------------------
char __cdecl sub_100109B0(int a1, _WORD *a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( *a2 == -32665 || !*(_BYTE *)(a1 + 5) && a3 && *(_DWORD *)(a1 + 48) == a3 )
    result = 1;
  return result;
}

//----- (100109E0) --------------------------------------------------------
__int16 __cdecl sub_100109E0(unsigned int a1)
{
  return word_10065B64[(a1 >> 17) & 0xF];
}
// 10065B64: using guessed type __int16 word_10065B64[];

//----- (10010A00) --------------------------------------------------------
bool __cdecl sub_10010A00(char *a1, int *a2, _DWORD *a3)
{
  int v3; // ecx@1
  bool v4; // zf@1
  int v5; // eax@2

  v3 = *(_DWORD *)a1 & 0xFF;
  v4 = v3 == 141;
  if ( v3 != 141 )
  {
    v5 = (int)&a1[dword_101D7CE4[8 * v3]];
    if ( a2 )
      *a2 = v5;
    if ( a3 )
      *a3 = v5 + 4;
    v4 = v3 == 141;
  }
  return !v4;
}

//----- (10010A50) --------------------------------------------------------
char __cdecl sub_10010A50(int a1, char *a2)
{
  char *v2; // edi@1
  int v3; // esi@1
  char **v4; // eax@2

  v2 = a2;
  v3 = 0;
  if ( sub_10010A00(a2, 0, &a2) )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4 * v3) = v2;
      v2 = a2;
      *(_BYTE *)(v3++ + *(_DWORD *)(a1 + 64)) = 3;
      LOBYTE(v4) = sub_10010A00(v2, 0, &a2);
    }
    while ( (_BYTE)v4 );
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4 * v3) = v2;
  }
  else
  {
    v4 = *(char ***)(a1 + 56);
    *v4 = v2;
  }
  return (unsigned int)v4;
}

//----- (10010AB0) --------------------------------------------------------
int __cdecl sub_10010AB0(int a1, int a2, char *a3, int a4)
{
  char *v4; // edi@1
  int v5; // eax@1
  int v6; // ecx@1
  int v8; // [sp+8h] [bp-4h]@1

  v4 = a3;
  sub_10010A00(a3, &v8, 0);
  sub_100012F0(a1, *(_DWORD *)(a1 + 56));
  v5 = *(_DWORD *)(a1 + 56);
  LOWORD(a3) = *(_WORD *)v8 + *(_WORD *)(v5 + 36);
  v6 = *(_DWORD *)v4;
  HIWORD(a3) = *(_WORD *)(v8 + 2) + *(_WORD *)(v5 + 38);
  return ((int (__cdecl *)(int, char *, char **, int, int))dword_101D7CE0[2 * (unsigned __int8)v6])(a1, v4, &a3, a4, a2);
}
// 101D7CE0: using guessed type int dword_101D7CE0[];

//----- (10010B20) --------------------------------------------------------
char __cdecl sub_10010B20(int a1, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // ebp@3
  signed int v5; // ebx@3
  char result; // al@3
  _WORD *v7; // ST2C_4@6

  v3 = a2;
  if ( !a2 )
    sub_10003E50("..\\lib\\adl\\cdp_fld_utl.c", 323, 1, a2);
  v4 = *(_DWORD *)(a1 + 56);
  v5 = (unsigned __int8)v3[230];
  result = 1;
  if ( (*(_BYTE *)(v4 + 26) || v4 != *(_DWORD *)(a1 + 48)) && v5 < (unsigned __int8)v3[68] )
  {
    v7 = (_WORD *)a3;
    *(_DWORD *)(a1 + 56) = v3;
    *(_BYTE *)(a1 + 3) = sub_100109B0(a1, v7, (int)v3);
    sub_10010A00(*(char **)(*((_DWORD *)v3 + 14) + 4 * v5), (int *)&a2, 0);
    sub_100012F0(a1, (int)v3);
    result = ((int (__cdecl *)(int, _DWORD, char *, _DWORD, int))dword_101D7CE0[2
                                                                              * (**(_DWORD **)(*((_DWORD *)v3 + 14)
                                                                                             + 4 * v5) & 0xFF)])(
               a1,
               *(_DWORD *)(*((_DWORD *)v3 + 14) + 4 * v5),
               a2,
               *(_DWORD *)(*((_DWORD *)v3 + 15) + 4 * v5),
               a3);
    *(_DWORD *)(a1 + 56) = v4;
    *(_BYTE *)(a1 + 3) = 0;
  }
  return result;
}
// 101D7CE0: using guessed type int dword_101D7CE0[];

//----- (10010BD0) --------------------------------------------------------
int __cdecl sub_10010BD0(int a1)
{
  int v1; // eax@1
  int v2; // esi@1
  char v4; // [sp+4h] [bp-68h]@3

  v1 = sub_10019830(&a1, 4u, (int)&unk_100661A8, 8, 20, -1);
  v2 = v1;
  if ( v1 < 0 || (unsigned int)v1 >= 0x14 )
  {
    sprintf(&v4, "UNKNOWN EVENT %lu\n", a1);
    sub_10003E50(".\\cdp_evnt_map.c", 328, 1, &v4);
  }
  return (int)*(&off_100661AC + 2 * v2);
}
// 100661AC: using guessed type void *off_100661AC;

//----- (10010C50) --------------------------------------------------------
char __thiscall sub_10010C50(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 12;
  sub_100044A0(3000, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10010C80) --------------------------------------------------------
char __thiscall sub_10010C80(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 30;
  sub_100044A0(3001, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10010CB0) --------------------------------------------------------
char __fastcall sub_10010CB0(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_10004A40(3, (_BYTE *)&v2 + 2);
  BYTE2(v2) = byte_100668B5[2 * sub_10019830((int *)((char *)&v2 + 2), 1u, (int)&unk_100668B4, 2, 5, -1)];
  if ( sub_100042D0(3002, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10004460(3002, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10010D20) --------------------------------------------------------
char __thiscall sub_10010D20(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_100044A0(6077, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10010D50) --------------------------------------------------------
char __fastcall sub_10010D50(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_10004A40(3, (_BYTE *)&v2 + 2);
  if ( sub_100042D0(3003, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10004460(3003, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10010DA0) --------------------------------------------------------
char sub_10010DA0()
{
  return 18;
}

//----- (10010DB0) --------------------------------------------------------
BOOL __thiscall sub_10010DB0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10004A40(97, (_BYTE *)&v2 + 3);
  return BYTE3(v2) == 1;
}

//----- (10010DD0) --------------------------------------------------------
char __thiscall sub_10010DD0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 18;
  sub_100044A0(3005, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10010E00) --------------------------------------------------------
char __thiscall sub_10010E00(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 23;
  sub_100044A0(3006, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10010E30) --------------------------------------------------------
char __fastcall sub_10010E30(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_10004A40(5, (_BYTE *)&v2 + 2);
  if ( sub_100042D0(3007, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10004460(3007, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10010E80) --------------------------------------------------------
bool __thiscall sub_10010E80(void *this)
{
  int v1; // eax@2
  bool result; // al@2
  unsigned __int16 v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@1

  LOBYTE(v4) = sub_10011500(this);
  v5 = 2;
  sub_10004330(9129, &v3, 2, &v5);
  if ( sub_10014530(v4, 4) )
  {
    v1 = sub_10019830(&v4, 1u, (int)&unk_100669B0, 8, 2, 2);
    result = (v3 & (unsigned __int16)word_100669B4[4 * v1]) != 0;
  }
  else
  {
    result = sub_10014530(v4, 2) || sub_100145B0(6) || sub_100145B0(8) || sub_10014530(v4, 12) || sub_10014530(v4, 16);
  }
  return result;
}
// 100669B4: using guessed type __int16 word_100669B4[];

//----- (10010F50) --------------------------------------------------------
int sub_10010F50()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v1 = 0;
  sub_100044A0(3012, &v2, 4, &v1);
  return v2;
}

//----- (10010F80) --------------------------------------------------------
char __thiscall sub_10010F80(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 11;
  sub_100044A0(3009, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10010FB0) --------------------------------------------------------
char __fastcall sub_10010FB0(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_10004A40(42, (_BYTE *)&v2 + 2);
  if ( sub_100042D0(3162, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10004460(3162, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10011000) --------------------------------------------------------
char __cdecl sub_10011000(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CD88: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);

//----- (10011020) --------------------------------------------------------
char sub_10011020()
{
  char v0; // cl@1
  char result; // al@1

  v0 = *(_BYTE *)dword_101D8250;
  result = 0;
  if ( *(_BYTE *)dword_101D8250 == 37 || v0 == 3 || v0 == 35 || v0 == 36 || v0 == 40 || v0 == 47 )
    result = 1;
  return result;
}
// 101D8250: using guessed type int dword_101D8250;

//----- (10011050) --------------------------------------------------------
int __cdecl sub_10011050(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_10003E50("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_10003E50("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 1003CD8E: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (100110B0) --------------------------------------------------------
char __thiscall sub_100110B0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10011050(18, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (100110D0) --------------------------------------------------------
int __thiscall sub_100110D0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10011050(15, (char *)&v2);
  return (int)v2;
}

//----- (100110F0) --------------------------------------------------------
int __thiscall sub_100110F0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10011050(16, (char *)&v2);
  return (int)v2;
}

//----- (10011110) --------------------------------------------------------
char __thiscall sub_10011110(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10011050(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10011130) --------------------------------------------------------
int __thiscall sub_10011130(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10011050(29, (char *)&v2);
  return (int)v2;
}

//----- (10011150) --------------------------------------------------------
char __thiscall sub_10011150(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10011050(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10011170) --------------------------------------------------------
char __thiscall sub_10011170(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10011050(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10011190) --------------------------------------------------------
char sub_10011190()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 0;
  sub_10011050(48, &v1);
  return v1;
}

//----- (100111B0) --------------------------------------------------------
char __cdecl sub_100111B0(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (100111F0) --------------------------------------------------------
char __cdecl sub_100111F0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_10003E50("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10011260) --------------------------------------------------------
signed int __cdecl sub_10011260(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_10003E50("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (100112E0) --------------------------------------------------------
char __cdecl sub_100112E0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_10003E50("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10011350) --------------------------------------------------------
char __cdecl sub_10011350(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_10003E50("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10011400) --------------------------------------------------------
char __cdecl sub_10011400(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_10003E50("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10011500) --------------------------------------------------------
char __thiscall sub_10011500(void *this)
{
  int v1; // eax@1

  v1 = sub_10015220(this);
  return sub_10011400(v1);
}

//----- (10011510) --------------------------------------------------------
int __cdecl sub_10011510(int *a1)
{
  int result; // eax@1

  result = sub_1001BA40((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_10003FF0();
    result = sub_1001B880();
  }
  return result;
}

//----- (10011540) --------------------------------------------------------
char __usercall sub_10011540@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_100040C0(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_1001CB00("%i %i\r\n", 13, v2);
    sub_1001C0A0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"356", (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    v5 = sub_100040A0(*(_DWORD *)(a1 + 4));
    v6 = sub_1001CB00("%i %i\r\n", 14, v5);
    sub_1001C0A0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_1006737C, (int)v6);
    result = 1;
  }
  else
  {
    sub_10003E50(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}

//----- (100115E0) --------------------------------------------------------
int __cdecl sub_100115E0(const char *a1)
{
  int result; // eax@1

  result = sub_10019BA0();
  if ( a1 )
    result = sub_1001BA70(dword_1010F284[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 1010F284: using guessed type int dword_1010F284[];

//----- (10011620) --------------------------------------------------------
char __cdecl sub_10011620(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_1001B9C0((char *)a1 + 4);
  v1 = sub_10022420();
  sub_1001B960((int)v1, 0, 0);
  dword_1010F284[sub_10019BA0()] = (int)a1;
  v2 = sub_100223E0((int)sub_100115E0);
  return sub_1001BA90(v2);
}
// 1010F284: using guessed type int dword_1010F284[];

//----- (10011670) --------------------------------------------------------
signed int __cdecl sub_10011670(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_10003FF0();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_10004170(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_10003FF0() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_10004200(&v23);
          }
          while ( sub_10003FF0() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_10003FD0(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_10004010((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_1001CB00("The %s task is loaded.", &v24);
            sub_1001C0A0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_1001CB00("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_1001C0A0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_1001CB00("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_1001C0A0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_1001CB00(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_1001C0A0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_10003F60(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_1001CB00("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_1001C0A0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_1001CB00("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_1001C0A0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_1001C0A0(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_10004050(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_100223E0((int)sub_100115E0);
        sub_1001C170((int)v15);
        v16 = sub_100237C0((int)sub_100115E0);
        sub_1001C170((int)v16);
        v17 = sub_100237C0((int)sub_100115E0);
        sub_1001BA90(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_100223E0((int)sub_100115E0);
        sub_1001C170((int)v18);
        v19 = sub_100237C0((int)sub_100115E0);
        sub_1001C170((int)v19);
        v20 = sub_100223E0((int)sub_100115E0);
        sub_1001BA90(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_10011540(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (10011A10) --------------------------------------------------------
char **sub_10011A10()
{
  return off_10067368;
}
// 10067368: using guessed type char *off_10067368[3];

//----- (10011A30) --------------------------------------------------------
int __cdecl sub_10011A30(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1010F298 = a1;
  return result;
}
// 1010F298: using guessed type int dword_1010F298;

//----- (10011A40) --------------------------------------------------------
int __cdecl sub_10011A40(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1010F29C = a1;
  return result;
}
// 1010F29C: using guessed type int dword_1010F29C;

//----- (10011A50) --------------------------------------------------------
#error "10011A55: call analysis failed (funcsize=28)"

//----- (10011A80) --------------------------------------------------------
char __cdecl sub_10011A80(char a1, unsigned __int16 a2, char a3)
{
  char result; // al@1

  result = a1;
  do
    result += a3;
  while ( !(a2 & (unsigned __int16)word_10068A90[(unsigned __int8)result]) && result != a1 );
  return result;
}
// 10068A90: using guessed type __int16 word_10068A90[];

//----- (10011AB0) --------------------------------------------------------
void __cdecl sub_10011AB0(const char *a1, unsigned int a2, int a3)
{
  unsigned int v3; // eax@2

  if ( a1 )
  {
    v3 = strlen(a1);
    if ( v3 < a2 )
      memset((void *)&a1[v3], a3, a2 - v3);
    a1[a2] = 0;
  }
}

//----- (10011B00) --------------------------------------------------------
void __cdecl sub_10011B00(const char *a1, char a2, char a3)
{
  unsigned int v3; // esi@4
  unsigned int v4; // ecx@4

  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        v3 = strlen(a1);
        v4 = 0;
        if ( v3 )
        {
          do
          {
            if ( a1[v4] == a2 )
              a1[v4] = a3;
            ++v4;
          }
          while ( v4 < v3 );
        }
      }
    }
  }
}

//----- (10011B50) --------------------------------------------------------
int __cdecl sub_10011B50(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (10011BA0) --------------------------------------------------------
int __cdecl sub_10011BA0(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (10011BD0) --------------------------------------------------------
int __cdecl sub_10011BD0(int a1, char *a2, int a3)
{
  int v3; // eax@3
  int i; // esi@5
  int v5; // esi@8
  int result; // eax@8

  if ( a1 && a2 )
  {
    v3 = a3;
    if ( !a3 )
      v3 = strlen((const char *)a1);
    for ( i = v3 - 1; i >= 0; --i )
    {
      if ( !strchr(a2, *(_BYTE *)(i + a1)) )
        break;
    }
    v5 = i + 1;
    *(_BYTE *)(v5 + a1) = 0;
    result = v5;
  }
  else
  {
    result = a3;
  }
  return result;
}

//----- (10011C30) --------------------------------------------------------
int __cdecl sub_10011C30(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10011C70) --------------------------------------------------------
int sub_10011C70(char *a1, size_t a2, char *a3, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, a3);
  result = sub_10011C30(a1, a2, a3, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (10011CA0) --------------------------------------------------------
int __cdecl sub_10011CA0(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_10011B50((int)&a1[v3], a2, a3 - v3);
}

//----- (10011CE0) --------------------------------------------------------
int __cdecl sub_10011CE0(int a1, int a2)
{
  return sub_10011BD0(a1, "_ ", a2);
}

//----- (10011D00) --------------------------------------------------------
signed int __cdecl sub_10011D00(int (__cdecl *a1)(int))
{
  signed int result; // eax@1
  int (__cdecl **v2)(int); // ecx@1

  result = 0;
  v2 = &off_10056078;
  do
  {
    if ( *v2 == a1 )
      break;
    ++result;
    v2 += 14;
  }
  while ( result < 2 );
  if ( result == 2 )
    result = -1;
  return result;
}
// 10056078: using guessed type int (__cdecl *off_10056078)(int);

//----- (10011D30) --------------------------------------------------------
char *__cdecl sub_10011D30(unsigned __int8 a1)
{
  char *result; // eax@2

  if ( (signed int)a1 >= 2 )
    result = (char *)&unk_10058CA9;
  else
    result = &aVloc[56 * a1];
  return result;
}

//----- (10011D60) --------------------------------------------------------
int __cdecl sub_10011D60(float a1)
{
  double v1; // st7@1
  signed int v2; // ecx@1
  int result; // eax@13

  v1 = a1;
  v2 = 6;
  if ( a1 > 0.0 )
    v2 = 0;
  if ( v1 > 8.0 )
    v2 = 1;
  if ( v1 > 10.0 )
    v2 = 2;
  if ( v1 > 12.5 )
    v2 = 3;
  if ( v1 > 14.0 )
    v2 = 4;
  if ( v1 > 16.0 )
    v2 = 6;
  result = 7;
  if ( v1 <= 20.0 )
    result = v2;
  return result;
}

//----- (10011DF0) --------------------------------------------------------
int __cdecl sub_10011DF0(int a1, _WORD *a2, char *a3, int a4, int a5, int a6, int a7)
{
  int v7; // esi@1
  char *v8; // ebp@1
  int v9; // edi@1
  int v10; // eax@3
  int v11; // ebx@3
  bool v12; // al@5
  bool v13; // al@9
  _WORD *v14; // edx@11
  int result; // eax@13
  char *v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v7 = a1;
  sub_100012F0(a1, *(_DWORD *)(a1 + 56));
  v8 = a3;
  v9 = 0;
  if ( sub_10010A00(a3, &v17, &v16) )
  {
    do
    {
      if ( sub_10010980(v7, a5, v9) )
      {
        v10 = *(_DWORD *)(v7 + 56);
        LOWORD(a1) = *(_WORD *)a6 + *(_WORD *)v17 + *(_WORD *)(v10 + 36);
        HIWORD(a1) = *(_WORD *)(a6 + 2) + *(_WORD *)(v17 + 2) + *(_WORD *)(v10 + 38);
        v11 = a7;
        v12 = v9 == a7 && sub_100109B0(v7, a2, v10);
        *(_BYTE *)(v7 + 3) = v12;
        v13 = v9 == v11 && *(_DWORD *)(v7 + 56) == *(_DWORD *)(*(_DWORD *)(v7 + 48) + 4);
        v14 = a2;
        *(_BYTE *)(v7 + 9) = v13;
        ((void (__cdecl *)(int, char *, int *, _DWORD, _WORD *))dword_101D7CE0[2 * (*(_DWORD *)v8 & 0xFF)])(
          v7,
          v8,
          &a1,
          *(_DWORD *)(a4 + 4 * v9),
          v14);
      }
      v8 = v16;
      ++v9;
    }
    while ( sub_10010A00(v16, &v17, &v16) );
  }
  result = *a2 - 32802;
  if ( *a2 == 32802 )
  {
    *(_BYTE *)(v7 + 1) = 1;
  }
  else
  {
    result = *a2 - 32888;
    if ( *a2 == 32888 )
    {
      *(_BYTE *)(v7 + 1) = 1;
      result = j_gdi_pvg_flush();
      *(_BYTE *)(v7 + 3) = 0;
      return result;
    }
  }
  *(_BYTE *)(v7 + 3) = 0;
  return result;
}
// 10003AE0: using guessed type int j_gdi_pvg_flush(void);
// 101D7CE0: using guessed type int dword_101D7CE0[];

//----- (10011F30) --------------------------------------------------------
int __cdecl sub_10011F30(int a1, _WORD *a2, char *a3, int a4, int a5, int a6)
{
  __int16 v7; // [sp+0h] [bp-4h]@1
  __int16 v8; // [sp+2h] [bp-2h]@1

  v7 = 0;
  v8 = 0;
  return sub_10011DF0(a1, a2, a3, a4, a5, (int)&v7, a6);
}

//----- (10011F70) --------------------------------------------------------
void __usercall sub_10011F70(int a1@<eax>, int a2@<edi>, int a3@<esi>, char a4)
{
  double v4; // st7@1
  double v5; // st6@1
  double v6; // st5@2
  double v7; // st6@6
  float v8; // ST18_4@6
  double v9; // st5@6
  double v10; // st7@6
  float v11; // [sp+8h] [bp-14h]@4
  float v12; // [sp+Ch] [bp-10h]@4
  float v13; // [sp+10h] [bp-Ch]@1
  float v14; // [sp+14h] [bp-8h]@4
  float v15; // [sp+18h] [bp-4h]@1
  float v16; // [sp+20h] [bp+4h]@6
  float v17; // [sp+20h] [bp+4h]@6
  float v18; // [sp+20h] [bp+4h]@6

  v13 = sub_10004700(*(_DWORD *)(a3 + 8), a1, *(float *)(a3 + 12));
  v4 = 4.0;
  v15 = *(float *)(a3 + 12) + 4.0;
  v5 = v13;
  if ( 0.0 == *(float *)(a3 + 32) )
    v6 = v13;
  else
    v6 = *(float *)(a3 + 32);
  v14 = v6 + 4.0;
  v11 = *(float *)a3 - *(float *)(a3 + 24) * v5;
  v12 = *(float *)(a3 + 4) - *(float *)(a3 + 28) * *(float *)(a3 + 12);
  if ( a4 )
  {
    v11 = sub_1003C7C0(v11, 1.0) + 0.5;
    v12 = sub_1003C9F0(v12, 1.0);
    v4 = 4.0;
    v5 = v13;
  }
  v16 = (v4 + v5) * *(float *)(a3 + 24) + v11 - 2.0;
  v7 = v14;
  v8 = v16 - *(float *)(a3 + 24) * v14;
  v17 = *(float *)(a3 + 12) * 0.5 + v12;
  v18 = v17 - 0.5 * v15;
  *(float *)(a2 + 304) = v15 + v18;
  *(float *)(a2 + 292) = v8;
  *(float *)(a2 + 300) = v7 + v8;
  v9 = v18;
  *(float *)(a2 + 296) = *(float *)&v9;
  v10 = v12;
  *(float *)(a2 + 36) = v11;
  *(float *)(a2 + 40) = *(float *)&v10;
}

//----- (100120C0) --------------------------------------------------------
void *sub_100120C0()
{
  void *result; // eax@1

  result = (void *)dword_1010F298;
  if ( !dword_1010F298 )
    result = &unk_100697A8;
  return result;
}
// 1010F298: using guessed type int dword_1010F298;

//----- (100120D0) --------------------------------------------------------
void __cdecl sub_100120D0(int a1, int a2, int a3)
{
  sub_10011F70(a2, a1, a3, 1);
}

//----- (100120F0) --------------------------------------------------------
void __cdecl sub_100120F0(float a1, float a2, float a3, float a4, char a5)
{
  void *v5; // ebp@3
  void *v6; // ecx@5
  void *v7; // ecx@5
  float v8; // ST28_4@5
  float v9; // ST2C_4@5
  double v10; // st7@5
  float v11; // ST28_4@7
  float v12; // ST2C_4@7
  float v13; // ST28_4@7
  float v14; // [sp+1Ch] [bp-44h]@5
  char v15; // [sp+20h] [bp-40h]@5
  float v16; // [sp+30h] [bp-30h]@5
  float v17; // [sp+34h] [bp-2Ch]@5
  float v18; // [sp+38h] [bp-28h]@5

  if ( a3 != a1 && a4 != a2 )
  {
    v5 = sub_100120C0();
    j_gdi_pvg_push_attrib(0x2000);
    j_gdi_pvg_enable(38);
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    if ( (unsigned __int8)a5 >= 2u )
      sub_10003E50("..\\lib\\adl\\cdp_fld_3d_utl.c", 1596, 1, 0);
    j_gdi_pvg_color_u32(*((_DWORD *)v5 + (unsigned __int8)a5));
    j_gdi_pvg_begin(72);
    sub_10003BE0(a1, a2);
    sub_10003BE0(a3, a2);
    sub_10003BE0(a3, a4);
    sub_10003BE0(a1, a4);
    j_gdi_pvg_end();
    j_gdi_pvg_read_matrix(&v15, 4, 4, 0);
    v8 = (double)((unsigned int)sub_100110F0(v6) >> 1);
    v9 = (double)((unsigned int)sub_100110D0(v7) >> 1);
    v14 = sqrt(v9 * (v9 * v16 * v16) + v8 * (v8 * v17 * v17) + v18 * v18 * 0.5);
    v10 = 0.0;
    if ( v14 != 0.0 )
      v10 = *((float *)v5 + 7) * 0.5 / v14;
    v11 = v10;
    sub_10003B00(*((float *)v5 + 7));
    j_gdi_pvg_color_u32(*((_DWORD *)v5 + (unsigned __int8)a5 + 2));
    j_gdi_pvg_begin(64);
    v12 = v11 + a2;
    sub_10003BE0(a1, v12);
    v13 = a4 - v11;
    sub_10003BE0(a3, v13);
    sub_10003BE0(a3, v12);
    sub_10003BE0(a1, v13);
    j_gdi_pvg_end();
    sub_10003B00(1.0);
    j_gdi_pvg_pop_attrib();
  }
}
// 100039E0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10003A40: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10003A50: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10003AC0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10003AD0: using guessed type int j_gdi_pvg_end(void);
// 10003B90: using guessed type int j_gdi_pvg_pop_attrib(void);
// 10003BA0: using guessed type int __cdecl j_gdi_pvg_push_attrib(_DWORD);
// 10003BB0: using guessed type int __cdecl j_gdi_pvg_read_matrix(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10012340) --------------------------------------------------------
void __cdecl sub_10012340(float a1, float a2, float a3, float a4, float a5, float a6, char a7)
{
  double v7; // st6@1
  double v8; // st4@1
  float v9; // ST0C_4@1
  float v10; // ST08_4@1
  float v11; // ST04_4@1
  float v12; // [sp+24h] [bp+10h]@1
  float v13; // [sp+24h] [bp+10h]@1
  float v14; // [sp+24h] [bp+10h]@1
  float v15; // [sp+24h] [bp+10h]@1

  v7 = a4 * a6;
  v8 = a3 * a5;
  v12 = a4 + a2 - v7;
  v9 = v12;
  v13 = a3 + a1 - v8;
  v10 = v13;
  v14 = a2 - v7;
  v11 = v14;
  v15 = a1 - v8;
  sub_100120F0(v15, v11, v10, v9, a7);
}

//----- (100123C0) --------------------------------------------------------
int __usercall sub_100123C0@<eax>(char a1@<al>, int a2@<ecx>, int a3@<ebx>, int a4)
{
  int v4; // edi@1
  int v5; // esi@1

  v4 = a4;
  v5 = a2;
  sub_10011F70(a3, a4, a2, a1);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(*(_DWORD *)(v5 + 16));
  j_gdi_pvg_begin(72);
  sub_10003BE0(*(float *)(v4 + 292), *(float *)(v4 + 296));
  sub_10003BE0(*(float *)(v4 + 300), *(float *)(v4 + 296));
  sub_10003BE0(*(float *)(v4 + 300), *(float *)(v4 + 304));
  sub_10003BE0(*(float *)(v4 + 292), *(float *)(v4 + 304));
  j_gdi_pvg_end();
  j_gdi_pvg_color_u32(*(_DWORD *)(v5 + 20));
  sub_10004560(*(_DWORD *)(v5 + 8), a3, *(float *)(v4 + 36), *(float *)(v4 + 40), *(float *)(v5 + 12));
  return j_gdi_pvg_disable(35);
}
// 100039E0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10003A40: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10003A50: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10003A60: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10003AC0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10003AD0: using guessed type int j_gdi_pvg_end(void);

//----- (100124A0) --------------------------------------------------------
int __cdecl sub_100124A0(int a1, int a2, int a3)
{
  return sub_100123C0(0, a3, a2, a1);
}

//----- (100124C0) --------------------------------------------------------
int __cdecl sub_100124C0(int a1, int a2, int a3)
{
  return sub_100123C0(1, a3, a2, a1);
}

//----- (100124E0) --------------------------------------------------------
int __cdecl sub_100124E0(int a1, int a2, int a3)
{
  int v3; // eax@5
  char v5; // [sp+8h] [bp-24h]@1
  int v6; // [sp+18h] [bp-14h]@5
  int v7; // [sp+1Ch] [bp-10h]@5

  qmemcpy(&v5, (const void *)a3, 0x24u);
  if ( *(_BYTE *)(a1 + 3) && *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 && (byte_101A5AB6 || byte_101D7CC0) )
  {
    v3 = *(_DWORD *)(a3 + 16);
    v6 = *(_DWORD *)(a3 + 20);
    v7 = v3;
  }
  return sub_100124C0(a1, a2, (int)&v5);
}
// 101A5AB6: using guessed type char byte_101A5AB6;
// 101D7CC0: using guessed type char byte_101D7CC0;

//----- (10012550) --------------------------------------------------------
int __cdecl sub_10012550(char *a1, char *a2)
{
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  char v4; // al@2
  int result; // eax@4

  v2 = strstr(a1, a2);
  v3 = strlen(a2);
  result = 0;
  if ( v2 )
  {
    v4 = v2[v3];
    if ( !v4 || v4 == 44 )
      result = 1;
  }
  return result;
}

//----- (10012590) --------------------------------------------------------
void *__usercall sub_10012590@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@0
  int v5; // [sp+4h] [bp-8h]@0
  int v6; // [sp+8h] [bp-4h]@0

  result = (void *)sub_100042D0(v4, v5, v6);
  if ( a2 == 6011 )
  {
    if ( result || *(_BYTE *)a3 > 0x3Fu )
    {
      *(_BYTE *)a3 = 63;
      result = (void *)sub_10004420(6011, (int)a3, a1);
    }
  }
  else if ( result )
  {
    result = memset(a3, 204, a1);
  }
  return result;
}

//----- (100125E0) --------------------------------------------------------
signed int sub_100125E0()
{
  int v0; // edi@5
  void *v1; // esi@5
  signed int v2; // ebp@5
  signed int result; // eax@7
  char v4; // [sp+13h] [bp-1h]@1

  dword_101D8250 = 0;
  v4 = 0;
  sub_10004A40(94, &v4);
  if ( v4 == 3 )
  {
    v4 = 1;
    sub_100043A0(3201, (int)&v4, 1);
    sub_10004A70(94, (int)&v4);
  }
  else if ( v4 == 2 )
  {
    v4 = 0;
    sub_100043A0(3201, (int)&v4, 1);
    sub_10004A70(94, (int)&v4);
  }
  sub_10012590(1u, 6011, &unk_1010F2A0);
  sub_10012590(0x16u, 6194, &unk_1010F2A1);
  sub_10012590(1u, 6012, &unk_1010F2B7);
  sub_10012590(1u, 6013, &unk_1010F2B8);
  sub_10012590(1u, 6014, &unk_1010F2B9);
  sub_10012590(1u, 6015, &unk_1010F2BA);
  sub_10012590(4u, 6078, &unk_1010F2BC);
  sub_10012590(4u, 6104, &unk_1010F2C0);
  sub_10012590(0x20u, 6016, &unk_1010F2C4);
  sub_10012590(0x20u, 6017, &unk_1010F2E4);
  sub_10012590(0x20u, 6018, &unk_1010F304);
  sub_10012590(0x20u, 6019, &unk_1010F324);
  sub_10012590(0x20u, 6020, &unk_1010F344);
  sub_10012590(0x20u, 6021, &unk_1010F364);
  sub_10012590(0x20u, 6022, &unk_1010F384);
  sub_10012590(0x20u, 6023, &unk_1010F3A4);
  sub_10012590(0x20u, 6024, &unk_1010F3C4);
  sub_10012590(0x20u, 6025, &unk_1010F3E4);
  sub_10012590(0x20u, 6026, &unk_1010F404);
  sub_10012590(0x20u, 6027, &unk_1010F424);
  sub_10012590(0x20u, 6028, &unk_1010F444);
  sub_10012590(0x20u, 6029, &unk_1010F464);
  sub_10012590(0x20u, 6030, &unk_1010F484);
  sub_10012590(0x20u, 6031, &unk_1010F4A4);
  sub_10012590(0x20u, 6032, &unk_1010F4C4);
  sub_10012590(0x20u, 6033, &unk_1010F4E4);
  sub_10012590(0x20u, 6034, &unk_1010F504);
  sub_10012590(0x20u, 6035, &unk_1010F524);
  sub_10012590(0x20u, 6036, &unk_1010F544);
  sub_10012590(0x20u, 6037, &unk_1010F564);
  sub_10012590(0x20u, 6038, &unk_1010F584);
  sub_10012590(0x20u, 6039, &unk_1010F5A4);
  sub_10012590(0x20u, 6040, &unk_1010F5C4);
  sub_10012590(0x20u, 6041, &unk_1010F5E4);
  sub_10012590(0x20u, 6042, &unk_1010F604);
  sub_10012590(0x20u, 6043, &unk_1010F624);
  sub_10012590(4u, 6044, &unk_1010F644);
  sub_10012590(4u, 6045, &unk_1010F648);
  sub_10012590(4u, 6046, &unk_1010F64C);
  sub_10012590(4u, 6357, &unk_1010F650);
  sub_10012590(4u, 6358, &unk_1010F654);
  sub_10012590(4u, 6359, &unk_1010F658);
  sub_10012590(0x20u, 6047, &unk_1010F65C);
  sub_10012590(0x20u, 6048, &unk_1010F67C);
  sub_10012590(0x20u, 6049, &unk_1010F69C);
  sub_10012590(0x20u, 6050, &unk_1010F6BC);
  sub_10012590(0x20u, 6051, &unk_1010F6DC);
  sub_10012590(0x20u, 6052, &unk_1010F6FC);
  sub_10012590(0x20u, 6053, &unk_1010F71C);
  sub_10012590(0x20u, 6054, &unk_1010F73C);
  sub_10012590(1u, 6511, &unk_1010F75C);
  sub_10012590(1u, 6522, &unk_1010F75D);
  sub_10012590(1u, 6057, &unk_1010F75E);
  sub_10012590(0x20u, 6075, &unk_1010F7B0);
  sub_10012590(0x20u, 6076, &unk_1010F7D0);
  sub_10012590(1u, 6077, &unk_1010F7F0);
  sub_10012590(4u, 6079, &unk_1010F7F4);
  sub_10012590(4u, 6080, &unk_1010F7F8);
  sub_10012590(0x20u, 6082, &unk_1010F7FC);
  sub_10012590(0x20u, 6083, &unk_1010F81C);
  sub_10012590(0x20u, 6084, &unk_1010F83C);
  sub_10012590(0x20u, 6085, &unk_1010F85C);
  sub_10012590(0x20u, 6086, &unk_1010F87C);
  sub_10012590(0x20u, 6087, &unk_1010F89C);
  sub_10012590(0x20u, 6088, &unk_1010F8BC);
  sub_10012590(0x20u, 6089, &unk_1010F8DC);
  sub_10012590(0x20u, 6123, &unk_1010F8FC);
  sub_10012590(0x48u, 6906, &unk_1010F91C);
  sub_10012590(0x48u, 6907, &unk_1010F964);
  sub_10012590(0x48u, 6908, &unk_1010F9AC);
  sub_10012590(0x48u, 6909, &unk_1010F9F4);
  sub_10012590(0x48u, 6910, &unk_1010FA3C);
  sub_10012590(0x48u, 6911, &unk_1010FA84);
  sub_10012590(0x48u, 6912, &unk_1010FACC);
  sub_10012590(0x48u, 6913, &unk_1010FB14);
  sub_10012590(0x48u, 6914, &unk_1010FB5C);
  sub_10012590(0x48u, 6915, &unk_1010FBA4);
  sub_10012590(0x48u, 6916, &unk_1010FBEC);
  sub_10012590(0x48u, 6917, &unk_1010FC34);
  sub_10012590(0x48u, 6918, &unk_1010FC7C);
  sub_10012590(0x48u, 6919, &unk_1010FCC4);
  sub_10012590(0x48u, 6920, &unk_1010FD0C);
  sub_10012590(0x48u, 6921, &unk_1010FD54);
  sub_10012590(0x48u, 6922, &unk_1010FD9C);
  sub_10012590(0x48u, 6923, &unk_1010FDE4);
  sub_10012590(0x48u, 6924, &unk_1010FE2C);
  sub_10012590(0x48u, 6925, &unk_1010FE74);
  sub_10012590(0x48u, 6926, &unk_1010FEBC);
  sub_10012590(0x48u, 6927, &unk_1010FF04);
  sub_10012590(0x48u, 6928, &unk_1010FF4C);
  sub_10012590(0x48u, 6929, &unk_1010FF94);
  sub_10012590(0x48u, 6930, &unk_1010FFDC);
  sub_10012590(0x48u, 6931, &unk_10110024);
  sub_10012590(0x48u, 6932, &unk_1011006C);
  sub_10012590(0x48u, 6933, &unk_101100B4);
  sub_10012590(0x48u, 6934, &unk_101100FC);
  sub_10012590(0x48u, 6935, &unk_10110144);
  sub_10012590(0x18u, 6163, &unk_1011018C);
  sub_10012590(0x20u, 6164, &unk_101101A4);
  sub_10012590(0x20u, 6165, &unk_101101C4);
  sub_10012590(2u, 6166, &unk_101101E4);
  sub_10012590(0xA4u, 40100, &unk_101101E8);
  sub_10012590(0xA4u, 40101, &unk_1011028C);
  sub_10012590(0xA4u, 40102, &unk_10110330);
  sub_10012590(0xA4u, 40103, &unk_101103D4);
  sub_10012590(0xA4u, 40104, &unk_10110478);
  sub_10012590(0xA4u, 40105, &unk_1011051C);
  sub_10012590(0xA4u, 40106, &unk_101105C0);
  sub_10012590(0xA4u, 40107, &unk_10110664);
  sub_10012590(0xA4u, 40108, &unk_10110708);
  sub_10012590(0xA4u, 40109, &unk_101107AC);
  sub_10012590(0xA4u, 40110, &unk_10110850);
  sub_10012590(0xA4u, 40111, &unk_101108F4);
  sub_10012590(0xA4u, 40112, &unk_10110998);
  sub_10012590(0xA4u, 40113, &unk_10110A3C);
  sub_10012590(0xA4u, 40114, &unk_10110AE0);
  sub_10012590(0xA4u, 40115, &unk_10110B84);
  sub_10012590(0xA4u, 40116, &unk_10110C28);
  sub_10012590(0xA4u, 40117, &unk_10110CCC);
  sub_10012590(0xA4u, 40118, &unk_10110D70);
  sub_10012590(0xA4u, 40119, &unk_10110E14);
  sub_10012590(0xA4u, 40120, &unk_10110EB8);
  sub_10012590(0xA4u, 40121, &unk_10110F5C);
  sub_10012590(0xA4u, 40122, &unk_10111000);
  sub_10012590(0xA4u, 40123, &unk_101110A4);
  sub_10012590(0xA4u, 40124, &unk_10111148);
  sub_10012590(0xA4u, 40125, &unk_101111EC);
  sub_10012590(0xA4u, 40126, &unk_10111290);
  sub_10012590(0xA4u, 40127, &unk_10111334);
  sub_10012590(0xA4u, 40128, &unk_101113D8);
  sub_10012590(0xA4u, 40129, &unk_1011147C);
  sub_10012590(0xA4u, 40130, &unk_10111520);
  sub_10012590(0xA4u, 40131, &unk_101115C4);
  sub_10012590(0xA4u, 40132, &unk_10111668);
  sub_10012590(0xA4u, 40133, &unk_1011170C);
  sub_10012590(0xA4u, 40134, &unk_101117B0);
  sub_10012590(0xA4u, 40135, &unk_10111854);
  sub_10012590(0xA4u, 40136, &unk_101118F8);
  sub_10012590(0xA4u, 40137, &unk_1011199C);
  sub_10012590(0xA4u, 40138, &unk_10111A40);
  sub_10012590(0xA4u, 40139, &unk_10111AE4);
  sub_10012590(0xA4u, 40140, &unk_10111B88);
  sub_10012590(0xA4u, 40141, &unk_10111C2C);
  sub_10012590(0xA4u, 40142, &unk_10111CD0);
  sub_10012590(0xA4u, 40143, &unk_10111D74);
  sub_10012590(0xA4u, 40144, &unk_10111E18);
  sub_10012590(0xA4u, 40145, &unk_10111EBC);
  sub_10012590(0xA4u, 40146, &unk_10111F60);
  sub_10012590(0xA4u, 40147, &unk_10112004);
  sub_10012590(0xA4u, 40148, &unk_101120A8);
  sub_10012590(0xA4u, 40149, &unk_1011214C);
  sub_10012590(0xA4u, 40150, &unk_101121F0);
  sub_10012590(0xA4u, 40151, &unk_10112294);
  sub_10012590(0xA4u, 40152, &unk_10112338);
  sub_10012590(0xA4u, 40153, &unk_101123DC);
  sub_10012590(0xA4u, 40154, &unk_10112480);
  sub_10012590(0xA4u, 40155, &unk_10112524);
  sub_10012590(0xA4u, 40156, &unk_101125C8);
  sub_10012590(0xA4u, 40157, &unk_1011266C);
  sub_10012590(0xA4u, 40158, &unk_10112710);
  sub_10012590(0xA4u, 40159, &unk_101127B4);
  sub_10012590(0xA4u, 40160, &unk_10112858);
  sub_10012590(0xA4u, 40161, &unk_101128FC);
  sub_10012590(0xA4u, 40162, &unk_101129A0);
  sub_10012590(0xA4u, 40163, &unk_10112A44);
  sub_10012590(0xA4u, 40164, &unk_10112AE8);
  sub_10012590(0xA4u, 40165, &unk_10112B8C);
  sub_10012590(0xA4u, 40166, &unk_10112C30);
  sub_10012590(0xA4u, 40167, &unk_10112CD4);
  sub_10012590(0xA4u, 40168, &unk_10112D78);
  sub_10012590(0xA4u, 40169, &unk_10112E1C);
  sub_10012590(0xA4u, 40170, &unk_10112EC0);
  sub_10012590(0xA4u, 40171, &unk_10112F64);
  sub_10012590(0xA4u, 40172, &unk_10113008);
  sub_10012590(0xA4u, 40173, &unk_101130AC);
  sub_10012590(0xA4u, 40174, &unk_10113150);
  sub_10012590(0xA4u, 40175, &unk_101131F4);
  sub_10012590(0xA4u, 40176, &unk_10113298);
  sub_10012590(0xA4u, 40177, &unk_1011333C);
  sub_10012590(0xA4u, 40178, &unk_101133E0);
  sub_10012590(0xA4u, 40179, &unk_10113484);
  sub_10012590(0xA4u, 40180, &unk_10113528);
  sub_10012590(0xA4u, 40181, &unk_101135CC);
  sub_10012590(0xA4u, 40182, &unk_10113670);
  sub_10012590(0xA4u, 40183, &unk_10113714);
  sub_10012590(0xA4u, 40184, &unk_101137B8);
  sub_10012590(0xA4u, 40185, &unk_1011385C);
  sub_10012590(0xA4u, 40186, &unk_10113900);
  sub_10012590(0xA4u, 40187, &unk_101139A4);
  sub_10012590(0xA4u, 40188, &unk_10113A48);
  sub_10012590(0xA4u, 40189, &unk_10113AEC);
  sub_10012590(0xA4u, 40190, &unk_10113B90);
  sub_10012590(0xA4u, 40191, &unk_10113C34);
  sub_10012590(0xA4u, 40192, &unk_10113CD8);
  sub_10012590(0xA4u, 40193, &unk_10113D7C);
  sub_10012590(0xA4u, 40194, &unk_10113E20);
  sub_10012590(0xA4u, 40195, &unk_10113EC4);
  sub_10012590(0xA4u, 40196, &unk_10113F68);
  sub_10012590(0xA4u, 40197, &unk_1011400C);
  sub_10012590(0xA4u, 40198, &unk_101140B0);
  sub_10012590(0xA4u, 40199, &unk_10114154);
  sub_10012590(0x20u, 6190, &unk_101141F8);
  sub_10012590(0x20u, 6191, &unk_10114218);
  sub_10012590(0x20u, 6192, &unk_10114238);
  sub_10012590(0x20u, 6199, &unk_10114258);
  sub_10012590(0x28u, 6207, &unk_10114278);
  sub_10012590(4u, 6231, &unk_10114D90);
  sub_10012590(4u, 6232, &unk_10114D94);
  sub_10012590(4u, 6233, &unk_10114D98);
  sub_10012590(4u, 6234, &unk_10114D9C);
  sub_10012590(0x1Cu, 40000, &unk_101142A0);
  sub_10012590(0x1Cu, 40001, &unk_101142BC);
  sub_10012590(0x1Cu, 40002, &unk_101142D8);
  sub_10012590(0x1Cu, 40003, &unk_101142F4);
  sub_10012590(0x1Cu, 40004, &unk_10114310);
  sub_10012590(0x1Cu, 40005, &unk_1011432C);
  sub_10012590(0x1Cu, 40006, &unk_10114348);
  sub_10012590(0x1Cu, 40007, &unk_10114364);
  sub_10012590(0x1Cu, 40008, &unk_10114380);
  sub_10012590(0x1Cu, 40009, &unk_1011439C);
  sub_10012590(0x1Cu, 40010, &unk_101143B8);
  sub_10012590(0x1Cu, 40011, &unk_101143D4);
  sub_10012590(0x1Cu, 40012, &unk_101143F0);
  sub_10012590(0x1Cu, 40013, &unk_1011440C);
  sub_10012590(0x1Cu, 40014, &unk_10114428);
  sub_10012590(0x1Cu, 40015, &unk_10114444);
  sub_10012590(0x1Cu, 40016, &unk_10114460);
  sub_10012590(0x1Cu, 40017, &unk_1011447C);
  sub_10012590(0x1Cu, 40018, &unk_10114498);
  sub_10012590(0x1Cu, 40019, &unk_101144B4);
  sub_10012590(0x1Cu, 40020, &unk_101144D0);
  sub_10012590(0x1Cu, 40021, &unk_101144EC);
  sub_10012590(0x1Cu, 40022, &unk_10114508);
  sub_10012590(0x1Cu, 40023, &unk_10114524);
  sub_10012590(0x1Cu, 40024, &unk_10114540);
  sub_10012590(0x1Cu, 40025, &unk_1011455C);
  sub_10012590(0x1Cu, 40026, &unk_10114578);
  sub_10012590(0x1Cu, 40027, &unk_10114594);
  sub_10012590(0x1Cu, 40028, &unk_101145B0);
  sub_10012590(0x1Cu, 40029, &unk_101145CC);
  sub_10012590(0x1Cu, 40030, &unk_101145E8);
  sub_10012590(0x1Cu, 40031, &unk_10114604);
  sub_10012590(0x1Cu, 40032, &unk_10114620);
  sub_10012590(0x1Cu, 40033, &unk_1011463C);
  sub_10012590(0x1Cu, 40034, &unk_10114658);
  sub_10012590(0x1Cu, 40035, &unk_10114674);
  sub_10012590(0x1Cu, 40036, &unk_10114690);
  sub_10012590(0x1Cu, 40037, &unk_101146AC);
  sub_10012590(0x1Cu, 40038, &unk_101146C8);
  sub_10012590(0x1Cu, 40039, &unk_101146E4);
  sub_10012590(0x1Cu, 40040, &unk_10114700);
  sub_10012590(0x1Cu, 40041, &unk_1011471C);
  sub_10012590(0x1Cu, 40042, &unk_10114738);
  sub_10012590(0x1Cu, 40043, &unk_10114754);
  sub_10012590(0x1Cu, 40044, &unk_10114770);
  sub_10012590(0x1Cu, 40045, &unk_1011478C);
  sub_10012590(0x1Cu, 40046, &unk_101147A8);
  sub_10012590(0x1Cu, 40047, &unk_101147C4);
  sub_10012590(0x1Cu, 40048, &unk_101147E0);
  sub_10012590(0x1Cu, 40049, &unk_101147FC);
  sub_10012590(0x1Cu, 40050, &unk_10114818);
  sub_10012590(0x1Cu, 40051, &unk_10114834);
  sub_10012590(0x1Cu, 40052, &unk_10114850);
  sub_10012590(0x1Cu, 40053, &unk_1011486C);
  sub_10012590(0x1Cu, 40054, &unk_10114888);
  sub_10012590(0x1Cu, 40055, &unk_101148A4);
  sub_10012590(0x1Cu, 40056, &unk_101148C0);
  sub_10012590(0x1Cu, 40057, &unk_101148DC);
  sub_10012590(0x1Cu, 40058, &unk_101148F8);
  sub_10012590(0x1Cu, 40059, &unk_10114914);
  sub_10012590(0x1Cu, 40060, &unk_10114930);
  sub_10012590(0x1Cu, 40061, &unk_1011494C);
  sub_10012590(0x1Cu, 40062, &unk_10114968);
  sub_10012590(0x1Cu, 40063, &unk_10114984);
  sub_10012590(0x1Cu, 40064, &unk_101149A0);
  sub_10012590(0x1Cu, 40065, &unk_101149BC);
  sub_10012590(0x1Cu, 40066, &unk_101149D8);
  sub_10012590(0x1Cu, 40067, &unk_101149F4);
  sub_10012590(0x1Cu, 40068, &unk_10114A10);
  sub_10012590(0x1Cu, 40069, &unk_10114A2C);
  sub_10012590(0x1Cu, 40070, &unk_10114A48);
  sub_10012590(0x1Cu, 40071, &unk_10114A64);
  sub_10012590(0x1Cu, 40072, &unk_10114A80);
  sub_10012590(0x1Cu, 40073, &unk_10114A9C);
  sub_10012590(0x1Cu, 40074, &unk_10114AB8);
  sub_10012590(0x1Cu, 40075, &unk_10114AD4);
  sub_10012590(0x1Cu, 40076, &unk_10114AF0);
  sub_10012590(0x1Cu, 40077, &unk_10114B0C);
  sub_10012590(0x1Cu, 40078, &unk_10114B28);
  sub_10012590(0x1Cu, 40079, &unk_10114B44);
  sub_10012590(0x1Cu, 40080, &unk_10114B60);
  sub_10012590(0x1Cu, 40081, &unk_10114B7C);
  sub_10012590(0x1Cu, 40082, &unk_10114B98);
  sub_10012590(0x1Cu, 40083, &unk_10114BB4);
  sub_10012590(0x1Cu, 40084, &unk_10114BD0);
  sub_10012590(0x1Cu, 40085, &unk_10114BEC);
  sub_10012590(0x1Cu, 40086, &unk_10114C08);
  sub_10012590(0x1Cu, 40087, &unk_10114C24);
  sub_10012590(0x1Cu, 40088, &unk_10114C40);
  sub_10012590(0x1Cu, 40089, &unk_10114C5C);
  sub_10012590(0x1Cu, 40090, &unk_10114C78);
  sub_10012590(0x1Cu, 40091, &unk_10114C94);
  sub_10012590(0x1Cu, 40092, &unk_10114CB0);
  sub_10012590(0x1Cu, 40093, &unk_10114CCC);
  sub_10012590(0x1Cu, 40094, &unk_10114CE8);
  sub_10012590(0x1Cu, 40095, &unk_10114D04);
  sub_10012590(0x1Cu, 40096, &unk_10114D20);
  sub_10012590(0x1Cu, 40097, &unk_10114D3C);
  sub_10012590(0x1Cu, 40098, &unk_10114D58);
  sub_10012590(0x1Cu, 40099, &unk_10114D74);
  sub_10012590(4u, 6238, &unk_10114DA0);
  sub_10012590(4u, 6239, &unk_10114DA4);
  sub_10012590(4u, 6240, &unk_10114DA8);
  sub_10012590(4u, 6242, &unk_10114DAC);
  sub_10012590(4u, 6244, &unk_10114DB0);
  sub_10012590(4u, 6245, &unk_10114DB4);
  sub_10012590(4u, 6246, &unk_10114DB8);
  sub_10012590(4u, 6251, &unk_10114DBC);
  sub_10012590(4u, 6252, &unk_10114DC0);
  sub_10012590(4u, 6253, &unk_10114DC4);
  sub_10012590(4u, 6254, &unk_10114DC8);
  sub_10012590(1u, 6255, &unk_10114DCC);
  sub_10012590(4u, 6256, &unk_10114DD0);
  sub_10012590(4u, 6257, &unk_10114DD4);
  sub_10012590(0xE2u, 6286, &unk_10114DD8);
  v0 = 18000;
  v1 = &unk_10114EBC;
  v2 = 16;
  do
  {
    sub_10012590(0x11Cu, v0, v1);
    v1 = (char *)v1 + 284;
    ++v0;
    --v2;
  }
  while ( v2 );
  sub_10012590(4u, 6262, &unk_1011607C);
  sub_10012590(0x28u, 6263, &unk_10116080);
  sub_10012590(0x28u, 6264, &unk_101160A8);
  sub_10012590(0x40u, 6268, &unk_101160D0);
  sub_10012590(4u, 6272, &unk_10116190);
  sub_10012590(4u, 6273, &unk_10116194);
  sub_10012590(1u, 6274, &unk_10116198);
  sub_10012590(2u, 6275, &unk_1011619A);
  sub_10012590(1u, 6276, &unk_1011619C);
  sub_10012590(1u, 6277, &unk_1011619D);
  sub_10012590(1u, 6278, &unk_1011619E);
  sub_10012590(0x40u, 6279, &unk_101161A0);
  sub_10012590(0x28u, 6753, &unk_10117055);
  sub_10012590(0x30u, 6754, &unk_10117080);
  sub_10012590(0x28u, 6958, &unk_101170B0);
  sub_10012590(0x80u, 6802, &unk_10116110);
  sub_10012590(1u, 6760, &unk_101170D8);
  sub_10012590(0x10u, 6312, &unk_10116524);
  sub_10012590(0x10u, 6313, &unk_10116534);
  sub_10012590(0x10u, 6314, &unk_10116544);
  sub_10012590(1u, 6307, &unk_10116554);
  sub_10012590(1u, 6308, &unk_10116555);
  sub_10012590(1u, 6309, &unk_10116556);
  sub_10012590(4u, 6285, &unk_10116558);
  sub_10012590(0xA8u, 6318, &unk_1011655C);
  sub_10012590(4u, 6319, &unk_10116604);
  sub_10012590(1u, 6350, &unk_10116608);
  sub_10012590(0x50u, 6351, &unk_1011660C);
  sub_10012590(4u, 6352, &unk_1011665C);
  sub_10012590(4u, 6353, &unk_10116660);
  sub_10012590(0x54u, 6448, &unk_101168AC);
  sub_10012590(0x54u, 6449, &unk_10116900);
  sub_10012590(8u, 6287, &unk_10116204);
  sub_10012590(8u, 6288, &unk_1011620C);
  sub_10012590(8u, 6289, &unk_10116214);
  sub_10012590(8u, 6290, &unk_1011621C);
  sub_10012590(8u, 6291, &unk_10116224);
  sub_10012590(8u, 6292, &unk_1011622C);
  sub_10012590(8u, 6293, &unk_10116234);
  sub_10012590(8u, 6294, &unk_1011623C);
  sub_10012590(8u, 6295, &unk_10116244);
  sub_10012590(8u, 6296, &unk_1011624C);
  sub_10012590(8u, 6297, &unk_10116254);
  sub_10012590(8u, 6298, &unk_1011625C);
  sub_10012590(8u, 6299, &unk_10116264);
  sub_10012590(8u, 6300, &unk_1011626C);
  sub_10012590(8u, 6301, &unk_10116274);
  sub_10012590(8u, 6302, &unk_1011627C);
  sub_10012590(8u, 6303, &unk_10116284);
  sub_10012590(8u, 6304, &unk_1011628C);
  sub_10012590(8u, 6305, &unk_10116294);
  sub_10012590(8u, 6306, &unk_1011629C);
  sub_10012590(8u, 6409, &unk_101162A4);
  sub_10012590(8u, 6410, &unk_101162AC);
  sub_10012590(8u, 6411, &unk_101162B4);
  sub_10012590(8u, 6412, &unk_101162BC);
  sub_10012590(8u, 6413, &unk_101162C4);
  sub_10012590(8u, 6414, &unk_101162CC);
  sub_10012590(8u, 6415, &unk_101162D4);
  sub_10012590(8u, 6416, &unk_101162DC);
  sub_10012590(8u, 6417, &unk_101162E4);
  sub_10012590(8u, 6418, &unk_101162EC);
  sub_10012590(8u, 6419, &unk_101162F4);
  sub_10012590(8u, 6420, &unk_101162FC);
  sub_10012590(8u, 6421, &unk_10116304);
  sub_10012590(8u, 6422, &unk_1011630C);
  sub_10012590(8u, 6423, &unk_10116314);
  sub_10012590(8u, 6424, &unk_1011631C);
  sub_10012590(8u, 6425, &unk_10116324);
  sub_10012590(8u, 6426, &unk_1011632C);
  sub_10012590(8u, 6427, &unk_10116334);
  sub_10012590(8u, 6428, &unk_1011633C);
  sub_10012590(4u, 6429, &unk_10116844);
  sub_10012590(8u, 6430, &unk_10116848);
  sub_10012590(8u, 6431, &unk_10116850);
  sub_10012590(8u, 6432, &unk_10116858);
  sub_10012590(8u, 6433, &unk_10116860);
  sub_10012590(8u, 6434, &unk_10116868);
  sub_10012590(8u, 6435, &unk_10116870);
  sub_10012590(8u, 6436, &unk_10116878);
  sub_10012590(8u, 6437, &unk_10116880);
  sub_10012590(8u, 6438, &unk_10116888);
  sub_10012590(8u, 6439, &unk_10116890);
  sub_10012590(8u, 6440, &unk_10116898);
  sub_10012590(0xAu, 6519, &unk_10116D04);
  sub_10012590(4u, 6442, &unk_101168A0);
  sub_10012590(4u, 6443, &unk_101168A4);
  sub_10012590(0xF0u, 6367, &unk_10116664);
  sub_10012590(0xF0u, 6368, &unk_10116754);
  sub_10012590(1u, 6446, &unk_101168A8);
  sub_10012590(6u, 6452, &unk_10116954);
  sub_10012590(4u, 6457, &unk_1011695C);
  sub_10012590(4u, 6458, &unk_10116960);
  sub_10012590(4u, 6459, &unk_10116964);
  sub_10012590(4u, 6460, &unk_10116968);
  sub_10012590(0x208u, 6515, &unk_1011696C);
  sub_10012590(0x160u, 6516, &unk_10116B74);
  sub_10012590(0x18u, 6517, &unk_10116CD4);
  sub_10012590(0x18u, 6518, &unk_10116CEC);
  sub_10012590(1u, 6520, &unk_10116D0E);
  sub_10012590(0x10u, 6521, &unk_10116D10);
  sub_10012590(4u, 6523, &unk_10116D20);
  sub_10012590(4u, 6524, &unk_10116D24);
  sub_10012590(4u, 6525, &unk_10116D28);
  sub_10012590(1u, 6526, &unk_10116D2C);
  sub_10012590(1u, 6527, &unk_10116D2D);
  sub_10012590(0x50u, 6528, &unk_10116D30);
  sub_10012590(4u, 6529, &unk_10116D80);
  sub_10012590(1u, 6530, &unk_10116D84);
  sub_10012590(1u, 6531, &unk_10116D85);
  sub_10012590(1u, 6532, &unk_10116D86);
  sub_10012590(0x14u, 6533, &unk_10116D87);
  sub_10012590(0xAu, 6883, &unk_101174A0);
  sub_10012590(0xAu, 6884, &unk_101174AA);
  sub_10012590(0xAu, 6885, &unk_101174B4);
  sub_10012590(1u, 6664, &unk_10116D9B);
  sub_10012590(1u, 6666, &unk_10116D9C);
  sub_10012590(1u, 6667, &unk_10116D9D);
  sub_10012590(1u, 6668, &unk_10116D9E);
  sub_10012590(0xA0u, 6669, &unk_10116DA0);
  sub_10012590(2u, 6670, &unk_10116E90);
  sub_10012590(4u, 6671, &unk_10116E94);
  sub_10012590(4u, 6672, &unk_10116E98);
  sub_10012590(4u, 6673, &unk_10116E9C);
  sub_10012590(4u, 6674, &unk_10116EA0);
  sub_10012590(4u, 6675, &unk_10116EA4);
  sub_10012590(4u, 6676, &unk_10116EAC);
  sub_10012590(4u, 6677, &unk_10116EB4);
  sub_10012590(4u, 6678, &unk_10116EB8);
  sub_10012590(1u, 6679, &unk_10116EBC);
  sub_10012590(0x140u, 6680, &unk_10116EC0);
  sub_10012590(4u, 6882, &unk_1011749C);
  sub_10012590(0xCu, 6652, &unk_10117000);
  sub_10012590(0x48u, 6653, &unk_1011700C);
  sub_10012590(1u, 6688, &unk_10117054);
  sub_10012590(4u, 6771, &unk_101170DC);
  sub_10012590(4u, 6772, &unk_101170E0);
  sub_10012590(8u, 6787, &unk_101170E4);
  sub_10012590(1u, 6832, &unk_10117114);
  sub_10012590(1u, 6833, &unk_10117115);
  sub_10012590(1u, 6834, &unk_10117116);
  sub_10012590(4u, 6835, &unk_10117118);
  sub_10012590(4u, 6836, &unk_1011711C);
  sub_10012590(4u, 6837, &unk_10117120);
  sub_10012590(4u, 6838, &unk_10117124);
  sub_10012590(1u, 6839, &unk_10117128);
  sub_10012590(0x50u, 6840, &unk_10116E40);
  sub_10012590(4u, 6841, &unk_1011712C);
  sub_10012590(4u, 6842, &unk_10117130);
  sub_10012590(4u, 6843, &unk_10117134);
  sub_10012590(1u, 6844, &unk_10117138);
  sub_10012590(0x360u, 6845, &unk_1011713C);
  sub_10012590(4u, 6846, &unk_10116EA8);
  sub_10012590(4u, 6847, &unk_10116EB0);
  result = 1;
  dword_101D8250 = (int)&unk_1010F2A0;
  return result;
}
// 101D8250: using guessed type int dword_101D8250;

//----- (100143E0) --------------------------------------------------------
char __thiscall sub_100143E0(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_10118C70 = sub_10011150(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_10118C78, 0, 0x1540u);
  memset(&unk_1011A1B8, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_10118C78;
  do
  {
    sub_10024950(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_1011A1B8 );
  v3 = 0;
  v4 = &unk_1011A1B8;
  do
  {
    result = sub_100249D0(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)&dword_1011BB68 );
  return result;
}
// 10118C70: using guessed type int dword_10118C70;
// 1011BB68: using guessed type int dword_1011BB68;

//----- (10014470) --------------------------------------------------------
char __cdecl sub_10014470(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_10118C70 != 1379255385;
  v7 = 0;
  v8 = dword_10118C70 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10004270(86, 10);
      memset((char *)&unk_10118C78 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10024950(a1, (int)&unk_10118C78 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_10118F50[v6] == a2 || byte_10118F51[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_10004240(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10118C70: using guessed type int dword_10118C70;

//----- (10014530) --------------------------------------------------------
char __cdecl sub_10014530(char a1, char a2)
{
  unsigned __int8 v2; // bl@1
  unsigned __int8 v4; // [sp+8h] [bp-8h]@1
  char v5; // [sp+Ch] [bp-4h]@2

  v2 = 0;
  v4 = 0;
  while ( 1 )
  {
    sub_10024410(a1, v4, (int)&v5);
    if ( v5 == a2 )
      break;
    v4 = ++v2;
    if ( v2 >= 2u )
      return 0;
  }
  return 1;
}

//----- (10014580) --------------------------------------------------------
char __cdecl sub_10014580(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10014470(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (100145B0) --------------------------------------------------------
char __cdecl sub_100145B0(char a1)
{
  char result; // al@1
  unsigned __int8 v2; // bl@1
  char v3; // [sp+8h] [bp-4h]@1

  result = 0;
  v2 = 0;
  v3 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10014530(v3, a1);
    v3 = ++v2;
  }
  while ( v2 < 3u );
  return result;
}

//----- (100145F0) --------------------------------------------------------
int __cdecl sub_100145F0(signed int a1, char a2)
{
  int result; // eax@3
  int v3; // [sp+0h] [bp-4h]@1

  v3 = 0;
  switch ( (unsigned __int8)a1 )
  {
    case 0u:
      if ( a2 == 1 )
      {
        a1 = 136975;
        sub_10004330(10018, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 118000;
        sub_10004330(10022, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 1u:
      if ( a2 == 1 )
      {
        a1 = 136975;
        sub_10004330(10019, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 118000;
        sub_10004330(10023, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 3u:
      if ( a2 == 1 )
      {
        a1 = 117950;
        sub_10004330(10020, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 108000;
        sub_10004330(10024, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 4u:
      if ( a2 == 1 )
      {
        a1 = 117950;
        sub_10004330(10021, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 108000;
        sub_10004330(10025, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 2u:
      result = sub_10024BB0(a2);
      v3 = result;
      break;
    default:
      sub_10003E50("..\\lib\\adl\\iop_freq_intf.c", 180, 1, 0);
      result = v3;
      break;
  }
  return result;
}

//----- (100147B0) --------------------------------------------------------
char __cdecl sub_100147B0(char a1, char a2, int a3)
{
  char result; // al@1
  int v4; // ecx@17
  signed int v5; // eax@17
  int v6; // [sp-Ch] [bp-Ch]@16
  int *v7; // [sp-8h] [bp-8h]@16

  result = a1;
  switch ( a1 )
  {
    case 0:
      result = sub_10019030(a1, &a1);
      if ( result && (unsigned int)(a3 - 118000) <= 0x4A2E )
      {
        if ( a2 == 1 )
          result = sub_100043A0(10018, (int)&a3, 4);
        else
          result = sub_100043A0(10022, (int)&a3, 4);
      }
      break;
    case 1:
      result = sub_10019030(a1, &a1);
      if ( result )
      {
        result = a3 + 16;
        if ( (unsigned int)(a3 - 118000) <= 0x4A2E )
        {
          if ( a2 == 1 )
            result = sub_100043A0(10019, (int)&a3, 4);
          else
            result = sub_100043A0(10023, (int)&a3, 4);
        }
      }
      break;
    case 3:
      result = sub_10014BF0(a1, &a1);
      if ( result && (unsigned int)(a3 - 108000) <= 0x26DE )
      {
        if ( a2 == 1 )
        {
          v7 = &a3;
          v6 = 10020;
          goto LABEL_17;
        }
        result = sub_100043A0(10024, (int)&a3, 4);
      }
      break;
    case 4:
      result = sub_10014BF0(a1, &a1);
      if ( result )
      {
        result = a3 + 32;
        if ( (unsigned int)(a3 - 108000) <= 0x26DE )
        {
          if ( a2 == 1 )
          {
            v7 = &a3;
            v6 = 10021;
LABEL_17:
            sub_100043A0(v6, (int)v7, 4);
            LOBYTE(v5) = sub_10018F40(v4);
            result = sub_10018E90(v5, 1);
          }
          else
          {
            result = sub_100043A0(10025, (int)&a3, 4);
          }
        }
      }
      break;
    case 2:
      result = sub_10019030(a1, &a1);
      if ( result )
        result = sub_10024CC0(a2, a3);
      break;
    default:
      return result;
  }
  return result;
}

//----- (10014970) --------------------------------------------------------
char __cdecl sub_10014970(char a1, _DWORD *a2)
{
  char result; // al@1

  result = 0;
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  a2[4] = 0;
  if ( a1 == 3 )
  {
    result = sub_10016260(0, 176, a2);
  }
  else if ( a1 == 4 )
  {
    result = sub_10016260(0, 183, a2);
  }
  return result;
}

//----- (100149C0) --------------------------------------------------------
char __cdecl sub_100149C0(char a1, char *a2)
{
  char result; // al@4
  int v3; // [sp+4h] [bp-18h]@1
  char v4; // [sp+10h] [bp-Ch]@2

  if ( sub_10014970(a1, &v3) != 1 || !v4 || v3 & 0x100 )
  {
    result = 0;
    if ( v3 & 0x200 )
      strcpy(a2, "___");
    else
      strcpy(a2, "____");
  }
  else
  {
    sub_10011B50((int)a2, &v4, 7);
    result = 1;
  }
  return result;
}

//----- (10014A80) --------------------------------------------------------
char __cdecl sub_10014A80(char a1, bool *a2)
{
  char result; // al@1
  char v3; // [sp+4h] [bp-18h]@1

  result = sub_10014970(a1, &v3);
  *a2 = (v3 & 0x10) == 16;
  return result;
}

//----- (10014AD0) --------------------------------------------------------
char __cdecl sub_10014AD0(char a1, _WORD *a2)
{
  char result; // al@4
  int v3; // [sp+4h] [bp-18h]@1
  __int16 v4; // [sp+Eh] [bp-Eh]@4

  if ( sub_10014970(a1, &v3) && !(v3 & 0x100) && v3 & 0x200 )
  {
    *a2 = v4;
    result = 1;
  }
  else
  {
    *a2 = v4;
    result = 0;
  }
  return result;
}

//----- (10014B40) --------------------------------------------------------
unsigned __int8 __cdecl sub_10014B40(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int8 result; // al@1

  result = a2;
  if ( a2 + 1 >= 1 && a2 <= 0x3Fu )
  {
    result = a1;
    if ( (unsigned __int8)(a1 - 3) <= 1u )
      result = sub_100043A0(*(_DWORD *)&a_____1[4 * a1], (int)&a2, 1);
  }
  return result;
}

//----- (10014B80) --------------------------------------------------------
char __cdecl sub_10014B80(char a1)
{
  int v1; // ecx@0
  char result; // al@2
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  BYTE3(v3) = 34;
  if ( a1 == 3 )
  {
    sub_10015D90(0, 175, (char *)&v3 + 3, 0, 1, 1);
    result = sub_10015ED0(0, 0xAFu, 0xFFFFFFF);
  }
  else
  {
    result = a1 - 4;
    if ( a1 == 4 )
    {
      sub_10015D90(0, 182, (char *)&v3 + 3, 0, 1, 1);
      result = sub_10015ED0(0, 0xB6u, 0xFFFFFFF);
    }
  }
  return result;
}

//----- (10014BF0) --------------------------------------------------------
int __cdecl sub_10014BF0(char a1, _DWORD *a2)
{
  int result; // eax@1
  char v3; // [sp+4h] [bp-18h]@1
  int v4; // [sp+8h] [bp-14h]@1

  LOBYTE(result) = sub_10014970(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (10014C30) --------------------------------------------------------
int __cdecl sub_10014C30(float a1, float a2)
{
  float *v2; // ecx@0
  double v3; // st7@1
  double v4; // st7@3
  bool v5; // c0@3
  bool v6; // c3@3
  int result; // eax@4

  v3 = a1;
  if ( (COERCE_UNSIGNED_INT(*v2) & 0x7F800000) != 2139095040
    && *v2 <= v3
    && (v4 = *v2, v5 = a2 < v4, v6 = a2 == v4, v3 = a2, v5 || v6) )
  {
    result = 1;
  }
  else
  {
    *v2 = v3;
    result = 0;
  }
  return result;
}

//----- (10014C80) --------------------------------------------------------
void __cdecl sub_10014C80(char a1, int a2)
{
  int v2; // edi@4
  int v3; // eax@4
  int v4; // ecx@4
  int v5; // ecx@4
  char v6; // al@4
  signed int v7; // ST2C_4@5
  double v8; // st4@22
  double v9; // st6@22
  double v10; // st3@22
  double v11; // st2@27
  bool v12; // c0@27
  bool v13; // c3@27
  double v14; // st6@27
  float v15; // ST2C_4@48
  double v16; // st7@48
  bool v17; // zf@50
  bool v18; // [sp+1Fh] [bp-55h]@4
  float v19; // [sp+20h] [bp-54h]@48
  int v20; // [sp+24h] [bp-50h]@4
  int v21; // [sp+28h] [bp-4Ch]@4
  int v22; // [sp+2Ch] [bp-48h]@4
  int v23; // [sp+30h] [bp-44h]@4
  int v24; // [sp+34h] [bp-40h]@4
  char v25; // [sp+38h] [bp-3Ch]@4
  char v26; // [sp+48h] [bp-2Ch]@51
  char v27; // [sp+58h] [bp-1Ch]@47
  char v28; // [sp+68h] [bp-Ch]@6

  if ( !(unsigned __int8)sub_100155E0() || a1 != 3 && a1 != 4 )
  {
    *(float *)(a2 + 16) = 9.9999996e24;
    *(_DWORD *)(a2 + 60) = 0x3FFFF;
    *(_BYTE *)(a2 + 64) = 0;
    *(float *)(a2 + 12) = 6.2831855;
    *(_BYTE *)(a2 + 71) = 0;
    *(float *)(a2 + 32) = 6.2831855;
    *(_BYTE *)(a2 + 2) = -1;
    *(float *)(a2 + 36) = 6.2831855;
    *(_BYTE *)a2 = -1;
    *(float *)(a2 + 24) = 6.2831855;
    *(_BYTE *)(a2 + 1) = 0;
    *(_BYTE *)(a2 + 3) = 0;
    *(float *)(a2 + 28) = 9.9999996e24;
    *(_BYTE *)(a2 + 4) = 0;
    *(float *)(a2 + 40) = 0.0;
    *(float *)(a2 + 20) = 9.9999996e24;
    *(float *)(a2 + 44) = 9.9999996e24;
    *(float *)(a2 + 48) = 9.9999996e24;
    *(float *)(a2 + 52) = 9.9999996e24;
    *(float *)(a2 + 56) = 6.2831855;
    return;
  }
  v18 = sub_100153B0(0, (int)&v25);
  sub_100040C0(100, 10000);
  v2 = a2 + 71;
  v3 = 88 * (a1 == 4);
  *(_BYTE *)a2 = *(_BYTE *)(v3 + dword_101D8238 + 68);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + dword_101D8238 + 84);
  *(float *)(a2 + 20) = *(float *)(v3 + dword_101D8238 + 92);
  *(float *)(a2 + 24) = *(float *)(v3 + dword_101D8238 + 96);
  *(_BYTE *)(a2 + 1) = *(_BYTE *)(v3 + dword_101D8238 + 69);
  *(_BYTE *)(a2 + 2) = *(_BYTE *)(v3 + dword_101D8238 + 70);
  *(float *)(a2 + 32) = *(float *)(v3 + dword_101D8238 + 100);
  *(float *)(a2 + 36) = *(float *)(v3 + dword_101D8238 + 104);
  *(float *)(a2 + 40) = *(float *)(v3 + dword_101D8238 + 108);
  *(float *)(a2 + 44) = *(float *)(v3 + dword_101D8238 + 112);
  *(float *)(a2 + 48) = *(float *)(v3 + dword_101D8238 + 116);
  *(float *)(a2 + 52) = *(float *)(v3 + dword_101D8238 + 120);
  *(_BYTE *)(a2 + 3) = *(_BYTE *)(v3 + dword_101D8238 + 74);
  *(_DWORD *)(a2 + 60) = *(_DWORD *)(v3 + dword_101D8238 + 88);
  v4 = dword_101D8238;
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(v3 + dword_101D8238 + 147);
  *(_WORD *)(a2 + 68) = *(_WORD *)(v3 + v4 + 151);
  *(_BYTE *)(a2 + 70) = *(_BYTE *)(v3 + v4 + 153);
  v5 = v3 + dword_101D8238 + 147;
  *(_DWORD *)v2 = *(_DWORD *)v5;
  *(_WORD *)(v2 + 4) = *(_WORD *)(v5 + 4);
  *(_BYTE *)(v2 + 6) = *(_BYTE *)(v5 + 6);
  v21 = *(_DWORD *)(v3 + dword_101D8238 + 132);
  v22 = *(_DWORD *)(v3 + dword_101D8238 + 136);
  v23 = *(_DWORD *)(v3 + dword_101D8238 + 124);
  v24 = *(_DWORD *)(v3 + dword_101D8238 + 128);
  sub_100040A0(100);
  *(float *)(a2 + 56) = 6.2831855;
  v6 = sub_10014AD0(a1, &v20);
  *(_BYTE *)(a2 + 4) = v6;
  if ( v6 )
  {
    v7 = (signed __int16)(v20 + -32768);
    v20 -= 0x8000;
    *(float *)(a2 + 56) = (double)v7 * 0.00009587379924285279;
  }
  if ( !sub_100149C0(a1, &v28) )
    v28 = 0;
  if ( strcmp(&v28, (const char *)(a2 + 71)) || *(_BYTE *)v2 == 95 )
    *(_BYTE *)v2 = 0;
  *(_BYTE *)(a2 + 75) = 0;
  if ( !v18 && !*(_BYTE *)v2 )
    *(_DWORD *)(a2 + 60) = 0x3FFFF;
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 20)) & 0x7F800000) == 2139095040 || *(float *)(a2 + 20) > 9.9999996e24 )
  {
    *(float *)(a2 + 20) = 9.9999996e24;
  }
  else if ( *(float *)(a2 + 20) < -1000.0 )
  {
    *(float *)(a2 + 20) = -1000.0;
  }
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 32)) & 0x7F800000) == 2139095040 || *(float *)(a2 + 32) > 6.283185482025146 )
  {
    v10 = 6.2831855;
    *(float *)(a2 + 32) = 6.2831855;
  }
  else
  {
    if ( *(float *)(a2 + 32) < -6.283185482025146 )
    {
      v8 = -6.2831855;
      v9 = 6.283185482025146;
      *(float *)(a2 + 32) = -6.2831855;
      v10 = 6.2831855;
      goto LABEL_26;
    }
    v10 = 6.2831855;
  }
  v9 = 6.283185482025146;
  v8 = -6.2831855;
LABEL_26:
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 40)) & 0x7F800000) == 2139095040 )
  {
    v14 = v10;
  }
  else
  {
    v11 = *(float *)(a2 + 40);
    v12 = v11 < v9;
    v13 = v11 == v9;
    v14 = v10;
    if ( v12 || v13 )
    {
      if ( *(float *)(a2 + 40) < -6.283185482025146 )
        *(float *)(a2 + 40) = v8;
      goto LABEL_32;
    }
  }
  *(float *)(a2 + 40) = v14;
LABEL_32:
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 44)) & 0x7F800000) == 2139095040 || *(float *)(a2 + 44) > 9.9999996e24 )
  {
    *(float *)(a2 + 44) = 9.9999996e24;
  }
  else if ( *(float *)(a2 + 44) < 0.0 )
  {
    *(float *)(a2 + 44) = 0.0;
  }
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 48)) & 0x7F800000) == 2139095040 || *(float *)(a2 + 48) > 9.9999996e24 )
  {
    *(float *)(a2 + 48) = 9.9999996e24;
  }
  else if ( *(float *)(a2 + 48) < 0.0 )
  {
    *(float *)(a2 + 48) = 0.0;
  }
  if ( (COERCE_UNSIGNED_INT(*(float *)(a2 + 36)) & 0x7F800000) == 2139095040
    || *(float *)(a2 + 36) > 0.17453292
    || *(float *)(a2 + 36) < 0.0 )
  {
    *(float *)(a2 + 36) = 0.0;
  }
  if ( *(_DWORD *)(a2 + 60) == 0x3FFFF )
  {
    *(float *)(a2 + 32) = v14;
    *(float *)(a2 + 36) = v14;
    *(_BYTE *)(a2 + 2) = -1;
    *(_BYTE *)a2 = -1;
    *(float *)(a2 + 20) = 9.9999996e24;
    *(_BYTE *)(a2 + 1) = 0;
    *(float *)(a2 + 16) = 9.9999996e24;
    *(float *)(a2 + 28) = 9.9999996e24;
    *(float *)(a2 + 44) = 9.9999996e24;
    *(float *)(a2 + 12) = v14;
    *(float *)(a2 + 24) = v14;
  }
  else
  {
    sub_10024E30((int)&v21, (int)&unk_1006D6F4);
    sub_1003CA80((int)&v21, (int)&v27);
    if ( v18 )
    {
      sub_1004FDC0((int)&v27, (int)&v25, (float *)(a2 + 16), &v19);
      v15 = v19 + 3.141592741012573;
      v16 = sub_1003C960(v15);
    }
    else
    {
      *(float *)(a2 + 16) = 9.9999996e24;
      v16 = 6.2831855;
    }
    v17 = *(_BYTE *)(a2 + 1) == 0;
    *(float *)(a2 + 12) = v16;
    if ( v17
      || (sub_10014C30(6.2831855, -6.2831855),
          sub_10024E30((int)&v23, (int)&unk_1006D6F4),
          sub_1003CA80((int)&v23, (int)&v26),
          !v18) )
    {
      *(float *)(a2 + 28) = 9.9999996e24;
    }
    else
    {
      sub_1004FDC0((int)&v25, (int)&v26, (float *)(a2 + 28), &v19);
    }
  }
}
// 101D8238: using guessed type int dword_101D8238;

//----- (10015220) --------------------------------------------------------
int __thiscall sub_10015220(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10011050(46, (char *)&v2);
  return (int)v2;
}

//----- (10015240) --------------------------------------------------------
#error "10015240: call analysis failed (funcsize=2)"

//----- (10015250) --------------------------------------------------------
#error "1001525F: call analysis failed (funcsize=5)"

//----- (10015270) --------------------------------------------------------
int sub_10015270()
{
  int result; // eax@1

  result = 0;
  dword_1011BB68 = -15;
  dword_101D824C = 0;
  dword_101D8240 = 0;
  dword_101D8244 = 0;
  dword_101D8248 = 0;
  return result;
}
// 1011BB68: using guessed type int dword_1011BB68;
// 101D8240: using guessed type int dword_101D8240;
// 101D8244: using guessed type int dword_101D8244;
// 101D8248: using guessed type int dword_101D8248;
// 101D824C: using guessed type int dword_101D824C;

//----- (100152A0) --------------------------------------------------------
char sub_100152A0()
{
  char v0; // bl@1
  signed int v1; // esi@2
  char result; // al@4

  v0 = sub_100053E0((int)&off_1006E248);
  if ( v0 )
  {
    dword_101D824C = dword_1011BB68;
    v1 = *(_BYTE *)(dword_1011BB68 + 667) != 0 ? 1100 : 2000;
    if ( v1 + *(_DWORD *)(dword_101D824C + 36) < (unsigned int)sub_10003FF0() )
      v0 = 0;
    dword_101D8248 = dword_1011BB68 + 56116;
    result = v0;
    dword_101D8240 = dword_1011BB68 + 1516;
    dword_101D8244 = dword_1011BB68 + 20484;
  }
  else
  {
    dword_101D824C = 0;
    dword_101D8240 = 0;
    dword_101D8244 = 0;
    dword_101D8248 = 0;
    result = 0;
  }
  return result;
}
// 1006E248: using guessed type char *off_1006E248;
// 1011BB68: using guessed type int dword_1011BB68;
// 101D8240: using guessed type int dword_101D8240;
// 101D8244: using guessed type int dword_101D8244;
// 101D8248: using guessed type int dword_101D8248;
// 101D824C: using guessed type int dword_101D824C;

//----- (10015340) --------------------------------------------------------
int __cdecl sub_10015340(double a1, double a2)
{
  double *v2; // ecx@0
  double v3; // ST00_8@1
  double v4; // st7@1
  int result; // eax@4

  v3 = *v2;
  v4 = a1;
  if ( (HIDWORD(v3) & 0x7FF00000) == 2146435072 || a1 < *v2 || (v4 = a2, a2 > *v2) )
  {
    *v2 = v4;
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10015390) --------------------------------------------------------
void sub_10015390()
{
  dword_101D823C = -15;
}
// 101D823C: using guessed type int dword_101D823C;

//----- (100153A0) --------------------------------------------------------
signed int sub_100153A0()
{
  return sub_100053E0((int)&off_1006E274);
}
// 1006E274: using guessed type char *off_1006E274;

//----- (100153B0) --------------------------------------------------------
bool __cdecl sub_100153B0(char a1, int a2)
{
  bool v2; // bl@1
  double v3; // st7@4
  int v4; // eax@4
  int v5; // ecx@8
  int v6; // eax@8
  double v7; // st5@14
  double v8; // st6@14
  float v9; // ST40_4@15
  double v10; // st5@16
  double v11; // st7@19
  float v13; // ST40_4@23
  float v14; // [sp+40h] [bp-10h]@5
  float v15; // [sp+40h] [bp-10h]@12
  float v16; // [sp+40h] [bp-10h]@16
  int v17; // [sp+44h] [bp-Ch]@8
  float v18; // [sp+48h] [bp-8h]@9
  float v19; // [sp+4Ch] [bp-4h]@9

  v2 = 0;
  if ( sub_100042D0(2047, a2, 16) )
  {
    *(double *)a2 = 0.68067840827779;
    *(double *)(a2 + 8) = -1.658062789394617;
  }
  if ( (unsigned __int8)sub_100153A0() )
  {
    sub_100040C0(101, 10000);
    v3 = 0.0;
    v4 = dword_101D823C;
    v2 = *(_WORD *)(dword_101D823C + 1456) > 1u;
    if ( *(_BYTE *)(dword_101D823C + 1296) )
    {
      v14 = sub_100251A0(*(_DWORD *)(dword_101D823C + 1292));
      v4 = dword_101D823C;
      v3 = 0.0;
    }
    else
    {
      v14 = 0.0;
    }
    if ( v2 )
    {
      v5 = *(_DWORD *)(v4 + 1524);
      v6 = v4 + 1524;
      *(_DWORD *)a2 = v5;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(v6 + 12);
      sub_10015340(6.2831853071796, -6.2831853071796);
      sub_10015340(6.2831853071796, -6.2831853071796);
      sub_1003CBD0(v14, dword_101D823C + 1512, (int)&v17);
      v4 = dword_101D823C;
      v3 = 0.0;
    }
    else
    {
      *(float *)&v17 = v3;
      v18 = v3;
      v19 = v3;
    }
    if ( a1 == 1 )
    {
      sub_1003CBA0((int)&v17, v4 + 1432, (int)&v17);
      v3 = 0.0;
      v4 = dword_101D823C;
    }
    v15 = *(float *)(v4 + 1280);
    if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v15 > 0.0053898906 )
    {
      v8 = 0.0053898906;
    }
    else
    {
      v7 = v15;
      v8 = 0.0053898906;
      if ( v15 >= v3 )
        goto LABEL_16;
    }
    v9 = v3;
    v7 = v9;
LABEL_16:
    *(double *)a2 = v7 * v18 + *(double *)a2;
    v16 = *(float *)(dword_101D823C + 1284);
    v10 = v16;
    if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || v10 > v8 || v10 < v3 )
    {
      v13 = v3;
      v11 = v13;
    }
    else
    {
      v11 = v16;
    }
    *(double *)(a2 + 8) = v11 * *(float *)&v17 + *(double *)(a2 + 8);
    sub_100040A0(101);
    sub_10024D30(a2);
  }
  return v2;
}
// 101D823C: using guessed type int dword_101D823C;

//----- (100155D0) --------------------------------------------------------
void sub_100155D0()
{
  dword_101D8238 = -15;
}
// 101D8238: using guessed type int dword_101D8238;

//----- (100155E0) --------------------------------------------------------
signed int sub_100155E0()
{
  return sub_100053E0((int)&off_1006E2C8);
}
// 1006E2C8: using guessed type char *off_1006E2C8;

//----- (100155F0) --------------------------------------------------------
void sub_100155F0()
{
  dword_1011BB6C = -15;
}
// 1011BB6C: using guessed type int dword_1011BB6C;

//----- (10015600) --------------------------------------------------------
int __thiscall sub_10015600(void *this)
{
  char v1; // si@1
  void *v2; // ecx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // ebx@1
  char v6; // al@1
  int result; // eax@1

  v1 = sub_10011130(this) & 7;
  v3 = sub_10015220(v2);
  v4 = ((v1 & 1) == 1) + ((v1 & 2) == 2) + ((v1 & 4) == 4);
  v5 = sub_10014580(15) == 1;
  v6 = sub_10014580(8);
  word_1011BB70 = 552;
  result = v5 + (v6 == 1);
  if ( v4 != 2 )
  {
    if ( v4 != 3 )
      return result;
    if ( result == 2 )
    {
      if ( v3 == 2 )
      {
        word_1011BB70 = 557;
        return result;
      }
    }
    else if ( result != 1 )
    {
      return result;
    }
    goto LABEL_10;
  }
  if ( result == 1 )
  {
LABEL_10:
    word_1011BB70 = 552;
    return result;
  }
  if ( result == 2 )
    word_1011BB70 = v3 != 4 ? 552 : 557;
  return result;
}
// 1011BB70: using guessed type __int16 word_1011BB70;

//----- (100156D0) --------------------------------------------------------
bool __usercall sub_100156D0@<al>(int a1@<esi>)
{
  void *v2; // [sp+0h] [bp-4h]@0

  return sub_10016260(1, (unsigned __int16)word_1011BB70, v2) && !sub_10026060(a1);
}
// 1011BB70: using guessed type __int16 word_1011BB70;

//----- (10015700) --------------------------------------------------------
bool __cdecl sub_10015700(_BYTE *a1)
{
  bool result; // al@1
  char v2; // [sp+4h] [bp-4h]@1

  result = sub_100156D0((int)&v2);
  if ( result )
    *a1 = v2;
  return result;
}

//----- (10015720) --------------------------------------------------------
int __cdecl sub_10015720(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_100707FC[a1];
  return result;
}
// 100707FC: using guessed type __int16 word_100707FC[];

//----- (10015740) --------------------------------------------------------
signed int sub_10015740()
{
  signed int result; // eax@1

  result = -15;
  dword_1011BB90 = -15;
  dword_1011BB9C = -15;
  dword_1011BB78 = -15;
  dword_1011BBA0 = -15;
  dword_1011BB8C = -15;
  dword_1011BB7C = -15;
  dword_1011BB74 = -15;
  dword_1011BB88 = -15;
  dword_1011BB98 = -15;
  dword_1011BB94 = -15;
  dword_1011BB84 = -15;
  dword_1011BB80 = -15;
  return result;
}
// 1011BB74: using guessed type int dword_1011BB74;
// 1011BB78: using guessed type int dword_1011BB78;
// 1011BB7C: using guessed type int dword_1011BB7C;
// 1011BB80: using guessed type int dword_1011BB80;
// 1011BB84: using guessed type int dword_1011BB84;
// 1011BB88: using guessed type int dword_1011BB88;
// 1011BB8C: using guessed type int dword_1011BB8C;
// 1011BB90: using guessed type int dword_1011BB90;
// 1011BB94: using guessed type int dword_1011BB94;
// 1011BB98: using guessed type int dword_1011BB98;
// 1011BB9C: using guessed type int dword_1011BB9C;
// 1011BBA0: using guessed type int dword_1011BBA0;

//----- (10015790) --------------------------------------------------------
signed int __usercall sub_10015790@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_100053E0((int)&off_1007081C);
      break;
    case 0:
      result = sub_100053E0((int)&off_10070830);
      break;
    case 1:
      result = sub_100053E0((int)&off_10070844);
      break;
    case 2:
      result = sub_100053E0((int)&off_1007086C);
      break;
    case 3:
      result = sub_100053E0((int)&off_10070858);
      break;
    case 5:
      result = sub_100053E0((int)&off_10070880);
      break;
    default:
      result = sub_100053E0(a2);
      break;
  }
  return result;
}
// 1007081C: using guessed type char *off_1007081C;
// 10070830: using guessed type char *off_10070830;
// 10070844: using guessed type char *off_10070844;
// 10070858: using guessed type char *off_10070858;
// 1007086C: using guessed type char *off_1007086C;
// 10070880: using guessed type char *off_10070880;

//----- (10015830) --------------------------------------------------------
int __usercall sub_10015830@<eax>(char a1@<al>)
{
  return sub_100040A0(dword_1007034C[a1]);
}
// 1007034C: using guessed type int dword_1007034C[];

//----- (10015850) --------------------------------------------------------
int __usercall sub_10015850@<eax>(char a1@<al>)
{
  return sub_100040C0(dword_1007034C[a1], 10);
}
// 1007034C: using guessed type int dword_1007034C[];

//----- (10015870) --------------------------------------------------------
signed __int16 __usercall sub_10015870@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  signed __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_10015790(a1, a1) )
        {
          sub_10003E50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_1011BB90 + 2 * a2 + 241212);
        v3 = (unsigned __int16)result < 0x256u;
        goto LABEL_32;
      }
      sub_10003E50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_10003E50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      if ( (unsigned __int8)sub_10015790(a1, a1) )
      {
        result = *(_WORD *)(dword_1011BB9C + 2 * a2 + 284664);
        v3 = (unsigned __int16)result < 0x211u;
        goto LABEL_32;
      }
      if ( sub_10011000(15000) )
        goto LABEL_6;
      sub_10003E50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
      return 0;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_10003E50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10015790(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_1011BB78 + 2 * a2 + 447808);
      v3 = (unsigned __int16)result < 0x979u;
      goto LABEL_32;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_10003E50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10015790(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_1011BBA0 + 2 * a2 + 356016);
      v3 = (unsigned __int16)result < 0x23Du;
      goto LABEL_32;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_10003E50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10015790(a1, a1) )
      {
        sub_10003E50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_1011BB8C + 2 * a2 + 23096);
      v3 = (unsigned __int16)result < 0x52u;
      goto LABEL_32;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_10015790(a1, a1) )
        {
          result = *(_WORD *)(dword_1011BB7C + 2 * a2 + 1804);
          v3 = (unsigned __int16)result < 4u;
LABEL_32:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_10003E50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 1011BB78: using guessed type int dword_1011BB78;
// 1011BB7C: using guessed type int dword_1011BB7C;
// 1011BB8C: using guessed type int dword_1011BB8C;
// 1011BB90: using guessed type int dword_1011BB90;
// 1011BB9C: using guessed type int dword_1011BB9C;
// 1011BBA0: using guessed type int dword_1011BBA0;

//----- (10015AB0) --------------------------------------------------------
char __cdecl sub_10015AB0(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  signed __int16 v4; // si@1
  char result; // al@2

  v4 = sub_10015870(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10015790(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1011BB90 + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_10015790(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1011BB9C + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        result = sub_10015790(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1011BB78 + 321708), 0x34u);
        break;
      case 2:
        if ( (unsigned __int8)sub_10015790(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1011BBA0 + 326220), 0x34u);
        result = 1;
        break;
      case 3:
        if ( (unsigned __int8)sub_10015790(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1011BB8C + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        result = sub_10015790(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1011BB7C + 1596), 0x34u);
        break;
      default:
LABEL_16:
        result = 0;
        break;
    }
  }
  return result;
}
// 1011BB78: using guessed type int dword_1011BB78;
// 1011BB7C: using guessed type int dword_1011BB7C;
// 1011BB8C: using guessed type int dword_1011BB8C;
// 1011BB90: using guessed type int dword_1011BB90;
// 1011BB9C: using guessed type int dword_1011BB9C;
// 1011BBA0: using guessed type int dword_1011BBA0;

//----- (10015C30) --------------------------------------------------------
char __cdecl sub_10015C30(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_10015870(a1, a2);
  if ( v3 != -1 && !sub_10015850(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10015790(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1011BB90 + 24 * ((unsigned __int16)v3 + 25);
        goto LABEL_16;
      case 0:
        if ( (unsigned __int8)sub_10015790(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1011BB9C + 24 * (unsigned __int16)v3 + 532;
        goto LABEL_16;
      case 1:
        if ( (unsigned __int8)sub_10015790(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1011BB78 + 24 * (unsigned __int16)v3 + 2428;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_10015790(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1011BBA0 + 24 * ((unsigned __int16)v3 + 24);
        goto LABEL_16;
      case 3:
        if ( (unsigned __int8)sub_10015790(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1011BB8C + 24 * (unsigned __int16)v3 + 84;
        goto LABEL_16;
      case 5:
        if ( (unsigned __int8)sub_10015790(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1011BB7C + 24 * (unsigned __int16)v3 + 4;
LABEL_16:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_10015830(a1);
        return 1;
      default:
LABEL_17:
        sub_10015830(a1);
        break;
    }
  }
  return 0;
}
// 1011BB78: using guessed type int dword_1011BB78;
// 1011BB7C: using guessed type int dword_1011BB7C;
// 1011BB8C: using guessed type int dword_1011BB8C;
// 1011BB90: using guessed type int dword_1011BB90;
// 1011BB9C: using guessed type int dword_1011BB9C;
// 1011BBA0: using guessed type int dword_1011BBA0;

//----- (10015D90) --------------------------------------------------------
char __cdecl sub_10015D90(int a1, int a2, void *a3, char a4, __int16 a5, char a6)
{
  int v6; // ecx@0
  signed __int16 v7; // ax@1
  int v8; // edi@2
  __int16 v9; // si@11
  __int16 v11; // [sp+8h] [bp-560h]@13
  __int16 v12; // [sp+3Ch] [bp-52Ch]@10
  char v13; // [sp+40h] [bp-528h]@16
  char v14; // [sp+41h] [bp-527h]@10
  __int16 v15; // [sp+42h] [bp-526h]@10
  char v16; // [sp+44h] [bp-524h]@10
  __int16 v17; // [sp+46h] [bp-522h]@15
  int v18; // [sp+48h] [bp-520h]@16
  char v19; // [sp+4Ch] [bp-51Ch]@15

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_8;
    case 0:
      v8 = 29;
      goto LABEL_8;
    case 1:
      v8 = 30;
      goto LABEL_8;
    case 2:
      v8 = 31;
      goto LABEL_8;
    case 3:
      v8 = 32;
      goto LABEL_8;
    case 5:
      v8 = 33;
LABEL_8:
      LOBYTE(v7) = sub_10015790(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_10015870(a1, a2);
      if ( v7 == -1 )
        return v7;
      v14 = a6;
      LOBYTE(v7) = a4;
      v12 = -32768;
      v15 = a2;
      v16 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_10015AB0(a1, a2, &v11) != 1 )
          goto LABEL_16;
        v9 = v11;
      }
      memcpy(&v19, a3, (unsigned __int16)v9);
      v17 = v9;
LABEL_16:
      v18 = sub_10003FF0();
      v13 = 0;
      LOBYTE(v7) = sub_10026C90(v8, (int)&v12);
      return v7;
    default:
      return v7;
  }
}

//----- (10015ED0) --------------------------------------------------------
char __cdecl sub_10015ED0(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  unsigned __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_10015870(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_10026C90(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (10015FB0) --------------------------------------------------------
char __cdecl sub_10015FB0(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  signed __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@9
  int v15; // eax@11
  int v16; // eax@13
  int v17; // eax@15
  int v18; // eax@17
  int v19; // eax@25
  char v20; // [sp+7h] [bp-9h]@19
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_10003FF0();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_10015870(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_10015790(a1, v7) )
            goto LABEL_30;
          v9 = 3 * (unsigned __int16)v8 + 75;
          v10 = dword_1011BB90 + 14952;
          v11 = 52 * (unsigned __int16)v8 + dword_1011BB90 + 210116;
          v12 = dword_1011BB90 + 8 * v9;
          v13 = 195164;
          goto LABEL_18;
        case 0:
          if ( !(unsigned __int8)sub_10015790(a1, v7) )
            goto LABEL_30;
          v14 = 3 * (unsigned __int16)v8;
          v10 = dword_1011BB9C + 13228;
          v11 = 52 * (unsigned __int16)v8 + dword_1011BB9C + 257156;
          v12 = dword_1011BB9C + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_18;
        case 1:
          if ( !(unsigned __int8)sub_10015790(a1, v7) )
            goto LABEL_30;
          v15 = 3 * (unsigned __int16)v8;
          v10 = dword_1011BB78 + 60628;
          v11 = 52 * (unsigned __int16)v8 + dword_1011BB78 + 321708;
          v12 = dword_1011BB78 + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_18;
        case 2:
          if ( !(unsigned __int8)sub_10015790(a1, v7) )
            goto LABEL_30;
          v16 = 3 * (unsigned __int16)v8 + 72;
          v10 = dword_1011BBA0 + 14328;
          v11 = 52 * (unsigned __int16)v8 + dword_1011BBA0 + 326220;
          v12 = dword_1011BBA0 + 8 * v16;
          v13 = 311892;
          goto LABEL_18;
        case 3:
          if ( !(unsigned __int8)sub_10015790(a1, v7) )
            goto LABEL_30;
          v17 = 3 * (unsigned __int16)v8;
          v10 = dword_1011BB8C + 2052;
          v11 = 52 * (unsigned __int16)v8 + dword_1011BB8C + 18832;
          v12 = dword_1011BB8C + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_18;
        case 5:
          if ( !(unsigned __int8)sub_10015790(a1, v7) )
            goto LABEL_30;
          v18 = 3 * (unsigned __int16)v8;
          v10 = dword_1011BB7C + 100;
          v11 = 52 * (unsigned __int16)v8 + dword_1011BB7C + 1596;
          v12 = dword_1011BB7C + 8 * v18 + 4;
          v13 = 1496;
LABEL_18:
          if ( sub_10015850(a1) )
            goto LABEL_30;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_33;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_33:
              v20 = 0;
            else
              memcpy(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_10015830(a1);
          result = v20;
          break;
        default:
LABEL_30:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1011BB74: using guessed type int dword_1011BB74;
// 1011BB78: using guessed type int dword_1011BB78;
// 1011BB7C: using guessed type int dword_1011BB7C;
// 1011BB88: using guessed type int dword_1011BB88;
// 1011BB8C: using guessed type int dword_1011BB8C;
// 1011BB90: using guessed type int dword_1011BB90;
// 1011BB98: using guessed type int dword_1011BB98;
// 1011BB9C: using guessed type int dword_1011BB9C;
// 1011BBA0: using guessed type int dword_1011BBA0;

//----- (10016230) --------------------------------------------------------
char __cdecl sub_10016230(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_10015FB0(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (10016260) --------------------------------------------------------
char __cdecl sub_10016260(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_10015FB0(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (10016290) --------------------------------------------------------
char __cdecl sub_10016290(char a1, int a2, void *a3, int a4)
{
  return sub_10015FB0(a1, a2, 0, 0, a3, a4);
}

//----- (100162C0) --------------------------------------------------------
int __cdecl sub_100162C0(int a1, int a2)
{
  byte_101D8234[0] = 0;
  return nullsub_1(a1, a2);
}

//----- (100162D0) --------------------------------------------------------
signed int sub_100162D0()
{
  return 1000;
}

//----- (10016300) --------------------------------------------------------
int sub_10016300()
{
  return sub_10024760((int)off_10070E60);
}
// 10070E60: using guessed type int (*off_10070E60[4])();

//----- (10016310) --------------------------------------------------------
char __cdecl sub_10016310(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_10011050(13, (char *)&v3 + 3);
  sub_10011050(12, a1);
  return BYTE3(v3);
}

//----- (10016340) --------------------------------------------------------
unsigned int __cdecl sub_10016340(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (10016360) --------------------------------------------------------
bool __cdecl sub_10016360(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (10016430) --------------------------------------------------------
int __cdecl sub_10016430(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (10016450) --------------------------------------------------------
int __cdecl sub_10016450(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_10016430(a1 + 20);
  return result;
}

//----- (10016490) --------------------------------------------------------
signed int __cdecl sub_10016490(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_10004880(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_10004880(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (10016550) --------------------------------------------------------
int __cdecl sub_10016550(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10016590) --------------------------------------------------------
int __usercall sub_10016590@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_1002AB50(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_10004960(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_10004980(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 100049A0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10016640) --------------------------------------------------------
signed int __usercall sub_10016640@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_100049B0(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_1002AFA0((void *)(v2 + 555), v7);
  }
  else
  {
    sub_10016490(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_10004880(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_10004880(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_1002AE70(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_100049B0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_100049B0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (10016810) --------------------------------------------------------
char __usercall sub_10016810@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_1002AB00(a2, a3, a1 + 212);
}

//----- (10016820) --------------------------------------------------------
int __usercall sub_10016820@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_10016590(result + 148, result);
  return result;
}

//----- (10016840) --------------------------------------------------------
char __usercall sub_10016840@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (10016860) --------------------------------------------------------
int __usercall sub_10016860@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  int result; // eax@1

  v2 = sub_1003C5D0(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_1003C5D0(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (100168A0) --------------------------------------------------------
int __fastcall sub_100168A0(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (100168C0) --------------------------------------------------------
int __usercall sub_100168C0@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_10004A00(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_10004980(v4, v3, 0);
}
// 100049A0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10016900) --------------------------------------------------------
signed int __usercall sub_10016900@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_100168A0(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_1003C5F0(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_10016810(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_1002CD50(a2 + 28, 4);
      else
        v22 = sub_1002CD50(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_10016810(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 100049A0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10016B10) --------------------------------------------------------
int __cdecl sub_10016B10(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_10016820(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_10016310(&v23);
    sub_10026F00((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_10016450(v1, (int)&v24);
  v13 = sub_10004960(v31);
  if ( v3 == v31 )
  {
    result = sub_100047D0(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_10004A00(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_100047D0(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_10004A00(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_10016430(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_100168C0(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_10004960(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 100049A0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10016D80) --------------------------------------------------------
signed int __cdecl sub_10016D80(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_10004A00(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_10016900(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10016E20) --------------------------------------------------------
int __usercall sub_10016E20@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_10016840(a1);
  *v3 ^= v2;
  return sub_10016860(v1, *v3);
}

//----- (10016E40) --------------------------------------------------------
int __usercall sub_10016E40@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_10016E20(a2);
  return result;
}

//----- (10016E70) --------------------------------------------------------
signed int __usercall sub_10016E70@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_10016860(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_10004880(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (10016F60) --------------------------------------------------------
char __usercall sub_10016F60@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_1002AAB0(a1, a2, a3 + 212);
  else
    result = sub_10016E40(a2, a3 + 148);
  return result;
}

//----- (10016F90) --------------------------------------------------------
signed int __usercall sub_10016F90@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_10016640(v3, v1);
  else
    result = sub_10016E70(v3, v1);
  return result;
}

//----- (10016FC0) --------------------------------------------------------
signed int __cdecl sub_10016FC0(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_10016550(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_1002E7C0(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_10016F90(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10017010) --------------------------------------------------------
signed int __cdecl sub_10017010(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_10004880(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_10016F60(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_10004880(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_1002AB50(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_100168A0(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_1002FB80(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_1003C5F0(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_1003C5F0(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (10017200) --------------------------------------------------------
signed int __cdecl sub_10017200(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_10017010(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_10016360(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10017260) --------------------------------------------------------
signed int __cdecl sub_10017260(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_10016FC0(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_10016550(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_10016FC0(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_10017200(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (10017430) --------------------------------------------------------
signed int __cdecl sub_10017430(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_10016340(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_10017260(v4, a4, 0) == a4 )
      result = sub_10017200(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10017490) --------------------------------------------------------
signed int __cdecl sub_10017490(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_10016340(a1);
  return sub_10017260(v3, a2, a3);
}

//----- (100174B0) --------------------------------------------------------
int __cdecl sub_100174B0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_100254A0(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100174E0) --------------------------------------------------------
int __cdecl sub_100174E0(unsigned __int16 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 > 0x1C8Au && a1 < 0x1C8Bu )
    result = (unsigned __int16)(a1 - 7307);
  return result;
}

//----- (10017500) --------------------------------------------------------
char *__cdecl sub_10017500(unsigned __int16 a1)
{
  bool v1; // cf@1
  bool v2; // zf@1
  char *result; // eax@1

  v1 = a1 < 0x1C8Au;
  v2 = a1 == 7306;
  result = (char *)&unk_10085EC0;
  if ( a1 < 0x1C8Au )
  {
    if ( a1 != -1 )
      return (char *)TXT_get_static_string();
    v1 = 0;
    v2 = 0;
  }
  if ( !v1 && !v2 && a1 < 0x1C8Bu )
    result = &byte_101D8234[(unsigned __int16)sub_100174E0(a1)];
  return result;
}
// 1003C5CA: using guessed type int TXT_get_static_string(void);

//----- (10017540) --------------------------------------------------------
char __thiscall sub_10017540(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 1;
  sub_10004330(3024, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10017570) --------------------------------------------------------
char __cdecl sub_10017570(char a1)
{
  char v1; // bl@1
  char result; // al@4

  v1 = a1;
  sub_10004A40(69, &a1);
  if ( a1 && (v1 == 15 || v1 == 13) )
    result = 17;
  else
    result = v1;
  return result;
}

//----- (100175A0) --------------------------------------------------------
signed int __cdecl sub_100175A0(signed int a1)
{
  signed int v1; // esi@1
  signed int result; // eax@4

  v1 = a1;
  sub_10004A40(69, &a1);
  if ( (_BYTE)a1 && (v1 == -1 || v1 == -4144960) )
    result = -11250604;
  else
    result = v1;
  return result;
}

//----- (100175E0) --------------------------------------------------------
signed int __fastcall sub_100175E0(int a1, unsigned __int8 a2)
{
  signed int result; // eax@1

  result = 42066;
  switch ( a2 )
  {
    case 3u:
    case 4u:
      result = (unsigned __int16)(a2 + 9997);
      break;
    case 0u:
    case 1u:
      result = (unsigned __int16)(a2 + 2008);
      break;
    default:
      return result;
  }
  return result;
}

//----- (10017630) --------------------------------------------------------
int __cdecl sub_10017630(char a1, void *a2)
{
  int v2; // ecx@0
  int result; // eax@1
  int v4; // [sp-2h] [bp-4h]@1

  v4 = v2;
  BYTE3(v4) = 2;
  result = (unsigned __int16)sub_100175E0(v2, a1);
  if ( (_WORD)result == -23470 )
    *(_BYTE *)a2 = 2;
  else
    result = sub_100044A0((unsigned __int16)result, a2, 1, (char *)&v4 + 3);
  return result;
}

//----- (10017670) --------------------------------------------------------
unsigned __int8 __cdecl sub_10017670(int a1, unsigned __int8 a2)
{
  int v2; // ecx@0
  int v3; // ebx@1
  unsigned __int16 v4; // di@1
  unsigned __int8 result; // al@1
  int v6; // esi@3

  v3 = a1;
  v4 = sub_100175E0(v2, a1);
  result = (unsigned __int8)(v3 - 3) <= 1u;
  if ( v4 != -23470 && a2 < 0x20u )
  {
    v6 = 8 * result;
    if ( (unsigned __int8)off_100864B4[2 * result](v3, (int)&a1) )
      (*(int (__cdecl **)(char, int))((char *)&off_100864B8 + v6))(v3, (unsigned __int8)byte_10086470[a2]);
    result = sub_100043A0(v4, (int)&a2, 1);
  }
  return result;
}
// 100864B4: using guessed type int (__cdecl *off_100864B4[2])(char, int);
// 100864B8: using guessed type int (__cdecl *off_100864B8)(char, int);

//----- (100176F0) --------------------------------------------------------
bool __cdecl sub_100176F0(char a1)
{
  int v1; // eax@1

  v1 = a1 & 0x3F;
  return !(a1 & 0x3F) || v1 == 6 || v1 == 7 || v1 == 21 || v1 == 9 || v1 == 16 || v1 == 20;
}

//----- (10017720) --------------------------------------------------------
char *__cdecl sub_10017720(unsigned __int8 a1)
{
  return off_10086C70[2 * a1];
}
// 10086C70: using guessed type char *off_10086C70[62];

//----- (10017730) --------------------------------------------------------
char *__cdecl sub_10017730(unsigned int a1, float *a2)
{
  unsigned __int8 v2; // ST0C_1@1

  v2 = sub_10017980(a1, a2);
  return sub_10017720(v2);
}

//----- (10017760) --------------------------------------------------------
char __cdecl sub_10017760(unsigned __int16 a1, int a2, char a3)
{
  int v3; // ecx@0
  char result; // al@1
  int v5; // [sp-2h] [bp-4h]@1

  v5 = v3;
  result = 31;
  BYTE3(v5) = 31;
  switch ( a1 )
  {
    case 0x1Au:
      if ( a3 )
      {
        sub_10004A40(44, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10010C50((void *)a1);
      }
      break;
    case 0u:
    case 0x26u:
    case 0x2Bu:
      if ( a3 )
      {
        sub_10004A40(77, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10010C80((void *)a1);
      }
      break;
    case 0x30u:
    case 0x31u:
      result = 18;
      break;
    case 8u:
    case 9u:
      result = 32;
      break;
    case 0xEu:
    case 0xFu:
    case 0x10u:
      if ( a3 )
      {
        sub_10004A40(17, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = 33;
      }
      break;
    case 4u:
    case 5u:
      result = sub_10010DA0();
      break;
    case 0x11u:
    case 0x12u:
    case 0x13u:
      if ( a3 )
      {
        sub_10004A40(14, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10010E30(a1);
      }
      break;
    case 0x14u:
    case 0x15u:
      result = 39;
      break;
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
      if ( a3 )
      {
        sub_10004A40(45, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10010F80((void *)a1);
      }
      break;
    case 0x1Eu:
    case 0x1Fu:
      if ( a3 )
      {
        sub_10004A40(15, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10010D50(a1);
      }
      break;
    case 0x20u:
    case 0x21u:
      if ( a3 )
      {
        sub_10004A40(16, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10010CB0(a1);
      }
      break;
    case 0x22u:
    case 0x23u:
      sub_10004A40(67, (_BYTE *)&v5 + 3);
      result = BYTE3(v5);
      break;
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
      result = 0;
      break;
    case 6u:
    case 7u:
      result = 34;
      break;
    case 0x24u:
    case 0x25u:
      result = 41;
      break;
    case 0x29u:
      result = 23;
      break;
    case 1u:
    case 2u:
    case 3u:
    case 0x2Du:
    case 0x2Eu:
      result = 5;
      break;
    case 0x2Fu:
      result = 51;
      break;
    case 0x32u:
      if ( a3 )
      {
        sub_10004A40(136, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10010FB0(a1);
      }
      break;
    default:
      return result;
  }
  return result;
}

//----- (10017960) --------------------------------------------------------
char __cdecl sub_10017960(char a1)
{
  char result; // al@3

  if ( a1 == 1 )
  {
    result = 2;
  }
  else if ( a1 == 3 )
  {
    result = 3;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10017980) --------------------------------------------------------
char __cdecl sub_10017980(unsigned int a1, float *a2)
{
  __int16 v2; // si@1
  int v3; // edx@1
  char v4; // al@1
  char v5; // cl@1
  char result; // al@3
  float *v7; // edi@37
  int v8; // esi@37
  char v9; // al@51

  v2 = a1;
  v3 = a1 & 0x3F;
  v4 = (a1 >> 12) & 1;
  v5 = 31;
  LOBYTE(a1) = 31;
  switch ( v3 )
  {
    case 0:
    case 1:
      if ( v4 )
      {
        sub_10004A40(44, &a1);
        result = a1;
      }
      else
      {
        result = sub_10010C50((void *)31);
      }
      break;
    case 2:
    case 27:
      if ( v4 )
      {
        sub_10004A40(77, &a1);
        result = a1;
      }
      else
      {
        result = sub_10010C80((void *)31);
      }
      break;
    case 3:
      result = sub_10010C80((void *)31) != 30 ? 29 : 12;
      break;
    case 4:
      v5 = sub_10010C80((void *)31);
      if ( v5 == 21 )
      {
        if ( !a2 || *a2 >= 1000.0 )
          goto LABEL_60;
        result = 29;
      }
      else
      {
        if ( !a2 || *a2 >= 185.2 )
          goto LABEL_60;
        result = 12;
      }
      break;
    case 5:
      result = 18;
      break;
    case 10:
      result = 32;
      break;
    case 11:
      result = sub_10010DD0((void *)31);
      break;
    case 12:
      if ( v4 )
      {
        sub_10004A40(17, &a1);
        result = a1;
      }
      else
      {
        result = 33;
      }
      break;
    case 13:
    case 14:
      result = sub_10010DA0();
      break;
    case 15:
      if ( v4 )
      {
        sub_10004A40(49, &a1);
        result = a1;
      }
      else
      {
        result = sub_10010E00((void *)31);
      }
      break;
    case 16:
    case 17:
      if ( v4 )
      {
        sub_10004A40(14, &a1);
        result = a1;
      }
      else
      {
        result = sub_10010E30(31);
      }
      break;
    case 18:
      result = 49;
      break;
    case 19:
      result = 39;
      break;
    case 20:
      if ( v4 )
      {
        sub_10004A40(45, &a1);
        result = a1;
      }
      else
      {
        result = sub_10010F80((void *)31);
      }
      break;
    case 21:
      if ( v4 )
      {
        sub_10004A40(15, &a1);
        result = a1;
      }
      else
      {
        result = sub_10010D50(31);
      }
      break;
    case 36:
      v7 = a2;
      v8 = v2 & 0x1000;
      switch ( (unsigned __int8)sub_10017980(v8 | 0x15, a2) )
      {
        case 0xDu:
          result = (unsigned __int8)sub_10017980(v8 | 2, v7) != 21 ? 45 : 57;
          break;
        case 0x18u:
          result = (unsigned __int8)sub_10017980(v8 | 2, v7) != 21 ? 54 : 59;
          break;
        case 0x10u:
          result = (unsigned __int8)sub_10017980(v8 | 2, v7) != 21 ? 53 : 58;
          break;
        case 0x13u:
          result = (unsigned __int8)sub_10017980(v8 | 2, v7) != 21 ? 55 : 60;
          break;
        default:
          result = 4 * ((unsigned __int8)sub_10017980(v8 | 2, v7) == 21) + 52;
          break;
      }
      break;
    case 22:
      if ( v4 )
      {
        sub_10004A40(16, &a1);
        result = a1;
      }
      else
      {
        result = sub_10010CB0(31);
      }
      break;
    case 23:
      result = 50;
      break;
    case 24:
      result = 0;
      break;
    case 25:
      result = 34;
      break;
    case 26:
      result = 1;
      break;
    case 38:
    case 39:
    case 42:
    case 43:
      result = 5;
      break;
    case 40:
    case 41:
      v9 = sub_1004FEA0();
      result = sub_10017960(v9);
      break;
    case 29:
      result = 41;
      break;
    case 30:
      result = 42;
      break;
    case 31:
      result = 43;
      break;
    case 32:
      result = sub_10010FB0(31);
      break;
    case 33:
      result = 46;
      break;
    case 34:
      result = 47;
      break;
    case 35:
      result = 48;
      break;
    case 37:
      v5 = (sub_10010FB0(31) != 19) + 61;
      goto LABEL_60;
    default:
LABEL_60:
      result = v5;
      break;
  }
  return result;
}

//----- (10017DA0) --------------------------------------------------------
double __cdecl sub_10017DA0(int a1, unsigned __int16 a2, char a3, char *a4)
{
  unsigned __int16 v4; // si@1
  char v5; // al@1
  double v6; // st7@3
  double result; // st7@16
  int v8; // eax@22
  int v9; // eax@23
  int v10; // eax@29
  int v11; // eax@30
  int v12; // eax@39
  int v13; // eax@40
  int v14; // eax@46
  int v15; // eax@47
  float v16; // [sp+4h] [bp-4h]@1

  v16 = 1.0;
  v4 = a2;
  v5 = sub_10017760(a2, 0, a3);
  *a4 = v5;
  switch ( v4 )
  {
    case 0u:
    case 0x1Au:
    case 0x26u:
    case 0x2Bu:
    case 0x30u:
    case 0x31u:
      switch ( v5 )
      {
        case 0x12:
          v6 = 39.370079;
          goto LABEL_64;
        case 0xC:
          v6 = 3.2808399;
          goto LABEL_64;
        case 0x1E:
          v6 = 0.00053995679;
          goto LABEL_64;
        case 0x15:
          goto LABEL_63;
        default:
          goto LABEL_67;
      }
      goto LABEL_67;
    case 8u:
    case 9u:
      v6 = 100.0;
      goto LABEL_64;
    case 0xEu:
    case 0xFu:
    case 0x10u:
      if ( v5 == 40 )
        v6 = 0.0000099999997;
      else
        v6 = 0.0001450377;
      goto LABEL_64;
    case 4u:
    case 5u:
      v6 = 0.00029530001;
      goto LABEL_64;
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
      if ( v5 == 28 )
        v6 = 60.0;
      else
        v6 = 196.85039;
      goto LABEL_64;
    case 0x11u:
    case 0x12u:
      if ( v5 != 10 || *(float *)&a1 == 9.8999998e24 )
        goto LABEL_67;
      sub_100199C0((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 0x13u:
      if ( v5 != 10 )
        goto LABEL_65;
      v6 = 1.8;
      goto LABEL_64;
    case 0x1Eu:
    case 0x1Fu:
      switch ( v5 )
      {
        case 0xD:
          v6 = 0.26417205;
          goto LABEL_64;
        case 0x10:
          v6 = 0.21997361;
          goto LABEL_64;
        case 0x13:
          v8 = (unsigned __int8)sub_10010D20((void *)v4);
          if ( (_BYTE)v8 )
          {
            v9 = v8 - 1;
            if ( v9 )
            {
              if ( v9 == 1 )
                v6 = 0.77890778;
              else
                v6 = 0.84999973;
            }
            else
            {
              v6 = 0.80407244;
            }
          }
          else
          {
            v6 = 0.71895844;
          }
          goto LABEL_64;
        case 0x18:
          v10 = (unsigned __int8)sub_10010D20((void *)v4);
          if ( (_BYTE)v10 )
          {
            v11 = v10 - 1;
            if ( v11 )
            {
              if ( v11 == 1 )
                v6 = 1.7171981;
              else
                v6 = 1.8756201;
            }
            else
            {
              v6 = 1.7726756;
            }
          }
          else
          {
            v6 = 1.5850322;
          }
          goto LABEL_64;
        default:
          goto LABEL_67;
      }
      goto LABEL_67;
    case 0x20u:
    case 0x21u:
      switch ( v5 )
      {
        case 0xE:
          v6 = 951.01935;
          break;
        case 0x11:
          v6 = 791.90497;
          break;
        case 0x14:
          v12 = (unsigned __int8)sub_10010D20((void *)v4);
          if ( (_BYTE)v12 )
          {
            v13 = v12 - 1;
            if ( v13 )
            {
              if ( v13 == 1 )
                v6 = 2804.0679;
              else
                v6 = 3059.999;
            }
            else
            {
              v6 = 2894.6609;
            }
          }
          else
          {
            v6 = 2588.2505;
          }
          break;
        case 0x19:
          v14 = (unsigned __int8)sub_10010D20((void *)v4);
          if ( (_BYTE)v14 )
          {
            v15 = v14 - 1;
            if ( v15 )
            {
              if ( v15 == 1 )
                v6 = 6181.9131;
              else
                v6 = 6752.2324;
            }
            else
            {
              v6 = 6381.6323;
            }
          }
          else
          {
            v6 = 5706.1162;
          }
          break;
        default:
          v6 = 3600.0;
          break;
      }
      goto LABEL_64;
    case 0x22u:
    case 0x23u:
      if ( v5 == 45 )
        v6 = 0.0020439588;
      else
        v6 = 0.0023521457;
      goto LABEL_64;
    case 0x28u:
      v6 = 0.73756248;
      goto LABEL_64;
    case 0x29u:
      v6 = 1.9438444;
      goto LABEL_64;
    case 0x2Du:
    case 0x2Eu:
      v6 = 57.29578;
      goto LABEL_64;
    case 0x2Fu:
      v6 = 61.023743;
      goto LABEL_64;
    case 0x32u:
      if ( v5 == 19 )
LABEL_63:
        v6 = 0.001;
      else
        v6 = 0.0022046;
LABEL_64:
      v16 = v6;
LABEL_65:
      if ( *(float *)&a1 == 9.8999998e24 )
        goto LABEL_67;
      *(float *)&a1 = *(float *)&a1 * v16;
      result = *(float *)&a1;
      break;
    default:
LABEL_67:
      result = *(float *)&a1;
      break;
  }
  return result;
}

//----- (10018170) --------------------------------------------------------
double __cdecl sub_10018170(int a1, unsigned int a2)
{
  __int16 v2; // si@1
  char v3; // al@1
  void *v4; // ecx@1
  double result; // st7@3
  int v6; // eax@26
  int v7; // eax@27
  int v8; // eax@33
  int v9; // eax@34
  double v10; // st7@42
  float v11; // ST0C_4@44
  int v12; // eax@48
  int v13; // eax@49
  int v14; // eax@55
  int v15; // eax@56
  float v16; // [sp+Ch] [bp-4h]@1

  v2 = a2;
  v16 = 1.0;
  v3 = sub_10017980(a2, (float *)&a1);
  v4 = (void *)(v2 & 0x3F);
  switch ( v4 )
  {
    case 0u:
    case 1u:
    case 2u:
    case 3u:
    case 4u:
    case 0x1Bu:
      switch ( v3 )
      {
        case 0xC:
          *(float *)&a1 = (float)3.2808399 * *(float *)&a1;
          return *(float *)&a1;
        case 0x1E:
          *(float *)&a1 = (float)0.00053995679 * *(float *)&a1;
          return *(float *)&a1;
        case 0x12:
          *(float *)&a1 = (float)39.370079 * *(float *)&a1;
          return *(float *)&a1;
        case 0x15:
          goto LABEL_67;
        default:
          goto LABEL_69;
      }
      goto LABEL_69;
    case 0xAu:
      *(float *)&a1 = (float)100.0 * *(float *)&a1;
      return *(float *)&a1;
    case 0xBu:
      if ( v3 != 15 )
        goto LABEL_8;
      *(float *)&a1 = (float)0.0099999998 * *(float *)&a1;
      return *(float *)&a1;
    case 0xDu:
    case 0xEu:
LABEL_8:
      *(float *)&a1 = (float)0.00029530001 * *(float *)&a1;
      return *(float *)&a1;
    case 0xCu:
      if ( v3 == 40 )
      {
        *(float *)&a1 = (float)0.0000099999997 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.0001450377 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0xFu:
      if ( v3 == 22 )
      {
        *(float *)&a1 = (float)3.5999999 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)1.9438444 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x14u:
      if ( v3 == 28 )
      {
        *(float *)&a1 = (float)60.0 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)196.85039 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x10u:
      if ( v3 != 10 )
        goto LABEL_69;
      sub_100199C0((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 0x11u:
      if ( v3 != 10 )
        goto LABEL_68;
      *(float *)&a1 = (float)1.8 * *(float *)&a1;
      return *(float *)&a1;
    case 0x15u:
      switch ( v3 )
      {
        case 0xD:
          *(float *)&a1 = (float)0.26417205 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x10:
          *(float *)&a1 = (float)0.21997361 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x13:
          v6 = (unsigned __int8)sub_10010D20(v4);
          if ( (_BYTE)v6 )
          {
            v7 = v6 - 1;
            if ( v7 )
            {
              if ( v7 == 1 )
              {
                *(float *)&a1 = (float)0.77890778 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.84999973 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.80407244 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.71895844 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x18:
          v8 = (unsigned __int8)sub_10010D20(v4);
          if ( (_BYTE)v8 )
          {
            v9 = v8 - 1;
            if ( v9 )
            {
              if ( v9 == 1 )
              {
                *(float *)&a1 = (float)1.7171981 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)1.8756201 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)1.7726756 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)1.5850322 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          goto LABEL_69;
      }
      return result;
    case 0x24u:
      if ( (unsigned __int8)v3 < 0x38u || (unsigned __int8)v3 > 0x3Cu )
        v10 = 0.00053995679;
      else
        v10 = 0.001;
      v11 = v10;
      *(float *)&a1 = v11 * *(float *)&a1;
      *(float *)&a1 = sub_100187A0(a1, v2 & 0x1000 | 0x15u);
      return *(float *)&a1;
    case 0x16u:
      switch ( v3 )
      {
        case 0xE:
          *(float *)&a1 = (float)951.01935 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x11:
          *(float *)&a1 = (float)791.90497 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x14:
          v12 = (unsigned __int8)sub_10010D20(v4);
          if ( (_BYTE)v12 )
          {
            v13 = v12 - 1;
            if ( v13 )
            {
              if ( v13 == 1 )
              {
                *(float *)&a1 = (float)2804.0679 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)3059.999 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)2894.6609 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)2588.2505 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x19:
          v14 = (unsigned __int8)sub_10010D20(v4);
          if ( (_BYTE)v14 )
          {
            v15 = v14 - 1;
            if ( v15 )
            {
              if ( v15 == 1 )
              {
                *(float *)&a1 = (float)6181.9131 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)6752.2324 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)6381.6323 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)5706.1162 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          *(float *)&a1 = (float)3600.0 * *(float *)&a1;
          result = *(float *)&a1;
          break;
      }
      return result;
    case 0x20u:
      if ( v3 == 19 )
        goto LABEL_67;
      *(float *)&a1 = (float)0.0022046 * *(float *)&a1;
      return *(float *)&a1;
    case 0x25u:
      if ( v3 == 61 )
      {
LABEL_67:
        v16 = 0.001;
LABEL_68:
        *(float *)&a1 = v16 * *(float *)&a1;
LABEL_69:
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.0022046 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    default:
      goto LABEL_69;
  }
}

//----- (100187A0) --------------------------------------------------------
double __cdecl sub_100187A0(int a1, unsigned int a2)
{
  __int16 v2; // di@1
  unsigned int v3; // esi@1
  void *v4; // ecx@1
  char v5; // bl@1
  double result; // st7@5
  int v7; // eax@28
  int v8; // eax@29
  int v9; // eax@35
  int v10; // eax@36
  double v11; // st7@44
  float v12; // ST1C_4@46
  int v13; // eax@50
  int v14; // eax@51
  int v15; // eax@57
  int v16; // eax@58
  float v17; // [sp+14h] [bp-4h]@1

  v17 = 1.0;
  v2 = a2;
  v3 = a2 & 0x3F;
  v5 = sub_10017980(a2, 0);
  if ( v3 == 4 )
    sub_10003E50("..\\lib\\adl\\cdp_cnvt.c", 1174, 1, 0);
  switch ( v3 )
  {
    case 0u:
    case 1u:
    case 2u:
    case 3u:
    case 0x1Bu:
      switch ( v5 )
      {
        case 0xC:
          *(float *)&a1 = (float)0.3048 * *(float *)&a1;
          return *(float *)&a1;
        case 0x1E:
          *(float *)&a1 = (float)1852.0 * *(float *)&a1;
          return *(float *)&a1;
        case 0x12:
          *(float *)&a1 = (float)0.0254 * *(float *)&a1;
          return *(float *)&a1;
        case 0x15:
          goto LABEL_69;
        default:
          goto LABEL_71;
      }
      goto LABEL_71;
    case 0xAu:
      *(float *)&a1 = (float)0.0099999998 * *(float *)&a1;
      return *(float *)&a1;
    case 0xBu:
      if ( v5 != 15 )
        goto LABEL_10;
      *(float *)&a1 = (float)100.0 * *(float *)&a1;
      return *(float *)&a1;
    case 0xDu:
    case 0xEu:
LABEL_10:
      *(float *)&a1 = (float)3386.3867 * *(float *)&a1;
      return *(float *)&a1;
    case 0xCu:
      if ( v5 == 40 )
      {
        *(float *)&a1 = (float)100000.0 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)6894.7593 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0xFu:
      if ( v5 == 22 )
      {
        *(float *)&a1 = (float)0.27777779 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.51444447 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x14u:
      if ( v5 == 11 )
      {
        *(float *)&a1 = (float)0.00508 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.016666668 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x10u:
      if ( v5 != 10 )
        goto LABEL_71;
      sub_100199E0((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 0x11u:
      if ( v5 != 10 )
        goto LABEL_70;
      *(float *)&a1 = (float)0.55555558 * *(float *)&a1;
      return *(float *)&a1;
    case 0x15u:
      switch ( v5 )
      {
        case 0xD:
          *(float *)&a1 = (float)3.7854118 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x10:
          *(float *)&a1 = (float)4.546 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x13:
          v7 = (unsigned __int8)sub_10010D20(v4);
          if ( (_BYTE)v7 )
          {
            v8 = v7 - 1;
            if ( v8 )
            {
              if ( v8 == 1 )
              {
                *(float *)&a1 = (float)1.283849 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)1.176471 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)1.243669 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)1.390901 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x18:
          v9 = (unsigned __int8)sub_10010D20(v4);
          if ( (_BYTE)v9 )
          {
            v10 = v9 - 1;
            if ( v10 )
            {
              if ( v10 == 1 )
              {
                *(float *)&a1 = (float)0.582344 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.53315699 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.56411898 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.63090199 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          goto LABEL_71;
      }
      return result;
    case 0x24u:
      if ( (unsigned __int8)v5 < 0x38u || (unsigned __int8)v5 > 0x3Cu )
        v11 = 1852.0;
      else
        v11 = 1000.0;
      v12 = v11;
      *(float *)&a1 = v12 * *(float *)&a1;
      *(float *)&a1 = sub_10018170(a1, v2 & 0x1000 | 0x15u);
      return *(float *)&a1;
    case 0x16u:
      switch ( v5 )
      {
        case 0xE:
          *(float *)&a1 = (float)0.0010515032 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x11:
          *(float *)&a1 = (float)0.0012627778 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x14:
          v13 = (unsigned __int8)sub_10010D20(v4);
          if ( (_BYTE)v13 )
          {
            v14 = v13 - 1;
            if ( v14 )
            {
              if ( v14 == 1 )
              {
                *(float *)&a1 = (float)0.00035662472 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.00032679751 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.00034546363 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.00038636138 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x19:
          v15 = (unsigned __int8)sub_10010D20(v4);
          if ( (_BYTE)v15 )
          {
            v16 = v15 - 1;
            if ( v16 )
            {
              if ( v16 == 1 )
              {
                *(float *)&a1 = (float)0.00016176222 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.00014809916 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.00015669972 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.00017525055 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          *(float *)&a1 = (float)0.00027777778 * *(float *)&a1;
          result = *(float *)&a1;
          break;
      }
      return result;
    case 0x20u:
      if ( v5 == 19 )
        goto LABEL_69;
      *(float *)&a1 = (float)453.59241 * *(float *)&a1;
      return *(float *)&a1;
    case 0x25u:
      if ( v5 == 61 )
      {
LABEL_69:
        v17 = 1000.0;
LABEL_70:
        *(float *)&a1 = v17 * *(float *)&a1;
LABEL_71:
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)453.59241 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    default:
      goto LABEL_71;
  }
}

//----- (10018E90) --------------------------------------------------------
char __cdecl sub_10018E90(signed int a1, char a2)
{
  void *v2; // ecx@0
  char result; // al@1
  char v4; // bl@2
  int v5; // eax@2
  int v6; // eax@6
  unsigned __int16 v7; // si@6
  void *v8; // [sp-2h] [bp-4h]@1

  v8 = v2;
  result = a1;
  BYTE3(v8) = 5;
  if ( (_BYTE)a1 )
  {
    v4 = ((_BYTE)a1 == 2) + 3;
    LOBYTE(a1) = ((_BYTE)a1 == 2) + 3;
    v5 = sub_100145F0(a1, 1);
    if ( sub_1002FBA0(v5) == 1 )
      result = (v4 != 3) + 3;
    else
      result = (v4 != 3) + 1;
  }
  BYTE3(v8) = result;
  if ( a2 )
  {
    v6 = sub_10015220(v2);
    v7 = 27 - (v6 != 2);
    sub_10015D90(1, 27 - (v6 != 2), (char *)&v8 + 3, 0, 1, 1);
    sub_10015ED0(1, v7, 0xFFFFFFF);
    result = BYTE3(v8);
  }
  return result;
}

//----- (10018F20) --------------------------------------------------------
int __cdecl sub_10018F20(unsigned __int8 a1)
{
  void *v1; // ecx@0

  return dword_100883C0[(unsigned __int8)sub_10024F00(v1) + 2 * a1];
}
// 100883C0: using guessed type int dword_100883C0[];

//----- (10018F40) --------------------------------------------------------
char __fastcall sub_10018F40(int a1)
{
  int v1; // eax@1
  char result; // al@1
  int v3; // [sp-2h] [bp-4h]@1

  v3 = a1;
  HIWORD(v3) = 0;
  v1 = sub_10018F20(0);
  sub_10004330(v1, (char *)&v3 + 2, 1, (char *)&v3 + 3);
  result = BYTE2(v3);
  if ( BYTE2(v3) >= 3u )
    result = 0;
  return result;
}

//----- (10018F80) --------------------------------------------------------
char __cdecl sub_10018F80(char a1)
{
  return byte_10089291[2 * (unsigned __int8)sub_10019830(&a1, 1u, (int)&unk_10089290, 2, 4, 3)];
}

//----- (10018FB0) --------------------------------------------------------
char __cdecl sub_10018FB0(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_10016260(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_10003E50("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_10024B70(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_10016260(1, 538, a2);
  }
  if ( !v4 || sub_100268F0((int)v3) )
    return 0;
  return 1;
}

//----- (10019030) --------------------------------------------------------
int __cdecl sub_10019030(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_10018FB0(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (10019080) --------------------------------------------------------
bool __cdecl sub_10019080(char a1)
{
  bool result; // al@2
  int v2; // [sp+4h] [bp-Ch]@1
  int v3; // [sp+8h] [bp-8h]@1

  v2 = 0;
  v3 = 0;
  if ( sub_10018FB0(a1, &v2) == 1 )
    result = (v2 & 0x200) == 512;
  else
    result = 0;
  return result;
}

//----- (100190F0) --------------------------------------------------------
bool __cdecl sub_100190F0(char a1)
{
  bool result; // al@2
  int v2; // [sp+4h] [bp-Ch]@1
  int v3; // [sp+8h] [bp-8h]@1

  v2 = 0;
  v3 = 0;
  if ( sub_10018FB0(a1, &v2) == 1 )
    result = (v2 & 8) == 8;
  else
    result = 0;
  return result;
}

//----- (10019150) --------------------------------------------------------
bool __cdecl sub_10019150(char a1)
{
  bool result; // al@2
  int v2; // [sp+4h] [bp-Ch]@1
  int v3; // [sp+8h] [bp-8h]@1

  v2 = 0;
  v3 = 0;
  if ( sub_10018FB0(a1, &v2) == 1 )
    result = (v2 & 0x10) == 16;
  else
    result = 0;
  return result;
}

//----- (100191B0) --------------------------------------------------------
void __cdecl sub_100191B0(char a1, char a2)
{
  if ( (unsigned __int8)a2 <= 0x3Fu )
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sub_100043A0(2011, (int)&a2, 1);
      }
      else
      {
        if ( a1 == 2 )
          sub_10024D00(a2);
        sub_10003E50("..\\lib\\acl\\iop\\iop_com_intf.c", 658, 0, 0);
      }
    }
    else
    {
      sub_100043A0(2010, (int)&a2, 1);
    }
  }
}

//----- (10019220) --------------------------------------------------------
char __cdecl sub_10019220(signed int a1)
{
  char result; // al@1

  result = a1;
  if ( (unsigned __int8)a1 <= 1u )
  {
    result = sub_1002FE00(a1, 39);
  }
  else if ( (_BYTE)a1 == 2 )
  {
    a1 = 2;
    sub_10015D90(1, 1670, &a1, 0, 1, 1);
    result = sub_10015ED0(1, 0x686u, 0xFFFFFFF);
  }
  return result;
}

//----- (10019250) --------------------------------------------------------
char __cdecl sub_10019250(int a1, int a2, unsigned __int16 a3, int a4, char a5)
{
  int v5; // edx@1
  double v6; // st7@1
  int v7; // eax@1
  float v8; // ST10_4@1
  int v9; // eax@1
  const char *v10; // edi@1
  double v11; // st7@2
  char v12; // al@2
  int v13; // edx@3
  char *v14; // ecx@3
  double v15; // st7@11
  float *v16; // ecx@13
  int v17; // eax@16
  double v18; // st6@17
  bool v19; // zf@17
  char v21; // [sp+1Fh] [bp-65h]@1
  __int16 v22; // [sp+20h] [bp-64h]@17
  __int16 v23; // [sp+22h] [bp-62h]@17
  float v24; // [sp+24h] [bp-60h]@11
  float v25; // [sp+28h] [bp-5Ch]@13
  int v26; // [sp+2Ch] [bp-58h]@1
  float v27; // [sp+30h] [bp-54h]@15
  int v28; // [sp+34h] [bp-50h]@1
  int v29; // [sp+38h] [bp-4Ch]@1
  float v30; // [sp+3Ch] [bp-48h]@1
  float v31; // [sp+40h] [bp-44h]@1
  int v32; // [sp+44h] [bp-40h]@1
  float v33; // [sp+48h] [bp-3Ch]@1
  float v34; // [sp+4Ch] [bp-38h]@1
  int v35; // [sp+50h] [bp-34h]@1
  int v36; // [sp+54h] [bp-30h]@1
  int v37; // [sp+68h] [bp-1Ch]@1
  char v38; // [sp+6Ch] [bp-18h]@2

  v5 = *(_DWORD *)(a2 + 12);
  v30 = *(float *)(a2 + 40);
  v35 = a4;
  v31 = 0.0;
  v6 = *(float *)(a2 + 40);
  LOBYTE(v36) = a5;
  v7 = *(_DWORD *)(a2 + 8);
  v8 = v6;
  v21 = 31;
  LOWORD(v26) = a3;
  v37 = 0;
  v28 = v5;
  v29 = v7;
  v9 = sub_10011D60(v8);
  v33 = *(float *)(a2 + 32);
  v34 = *(float *)(a2 + 36);
  v32 = v9;
  v10 = (const char *)sub_1002FF40(a3);
  if ( v10 )
  {
    v11 = sub_10017DA0(COERCE_INT(*(float *)(a2 + 28)), v26, v36, &v21);
    sprintf(&v38, v10, LODWORD(v11), (_DWORD)(*(unsigned __int64 *)&v11 >> 32));
    v12 = v38;
    if ( v38 )
    {
      v13 = v37;
      v14 = &v38;
      do
      {
        if ( (unsigned __int8)v12 >= 0x30u && (unsigned __int8)v12 <= 0x39u )
          ++v13;
        v12 = (v14++)[1];
      }
      while ( v12 );
      v37 = v13;
    }
  }
  else
  {
    v37 = 0;
  }
  if ( *(float *)(a2 + 28) >= (double)*(float *)(a2 + 24) )
  {
    v24 = *(float *)(a2 + 24);
    v15 = *(float *)(a2 + 28);
  }
  else
  {
    v24 = *(float *)(a2 + 28);
    v15 = *(float *)(a2 + 24);
  }
  v16 = *(float **)(a2 + 20);
  v25 = v15;
  if ( v24 > (double)*v16 || v25 < (double)*v16 )
  {
    v17 = *(_DWORD *)(a2 + 16);
    v27 = 9.8999998e24;
    v29 = 0;
    v28 = v17;
  }
  else
  {
    v27 = *v16;
  }
  v18 = *(float *)(a2 + 4);
  v22 = (signed int)*(float *)a2;
  v19 = *(_BYTE *)(a2 + 46) == 0;
  v23 = (signed int)v18;
  if ( !v19 && 9.8999998e24 == v27 )
    v23 += (signed int)(*(float *)(a2 + 40) * -0.5);
  return sub_1002FF50(a1, 0, (int)&v22, (int)&v26, (__int16 *)&unk_100660FC);
}

//----- (10019420) --------------------------------------------------------
void __cdecl sub_10019420(int a1)
{
  sub_10012340(
    *(float *)a1,
    *(float *)(a1 + 4),
    25.0,
    *(float *)(a1 + 40),
    *(float *)(a1 + 32),
    *(float *)(a1 + 36),
    *(_BYTE *)(a1 + 45));
}

//----- (10019460) --------------------------------------------------------
void __usercall sub_10019460(int a1@<ebx>, int a2@<esi>, char a3)
{
  int v3; // eax@2
  int v4; // ecx@2
  int v5; // edx@2
  float v6; // [sp+8h] [bp-24h]@2
  float v7; // [sp+Ch] [bp-20h]@2
  int v8; // [sp+10h] [bp-1Ch]@2
  float v9; // [sp+14h] [bp-18h]@2
  int v10; // [sp+18h] [bp-14h]@2
  int v11; // [sp+1Ch] [bp-10h]@2
  float v12; // [sp+20h] [bp-Ch]@2
  float v13; // [sp+24h] [bp-8h]@2
  float v14; // [sp+28h] [bp-4h]@2

  if ( *(_BYTE *)(a2 + 16) )
  {
    v12 = *(float *)(a2 + 40);
    v13 = *(float *)(a2 + 44);
    v6 = *(float *)a2;
    v7 = *(float *)(a2 + 4);
    v3 = sub_10011D60(*(float *)(a2 + 48));
    v4 = *(_DWORD *)(a2 + 8);
    v5 = *(_DWORD *)(a2 + 12);
    v9 = *(float *)(a2 + 48);
    v8 = v3;
    v10 = v4;
    v11 = v5;
    v14 = sub_10004700(v3, a2 + 16, v9);
    if ( a3 )
      sub_100124C0(a1, a2 + 16, (int)&v6);
    else
      sub_100124A0(a1, a2 + 16, (int)&v6);
  }
}

//----- (10019500) --------------------------------------------------------
void __cdecl sub_10019500(int a1, int a2)
{
  sub_10019460(a1, a2, 1);
}

//----- (10019520) --------------------------------------------------------
char __cdecl sub_10019520(float a1, int a2, char a3, int a4)
{
  char v4; // bl@1
  int v5; // ebp@1
  double v6; // st6@1
  unsigned __int8 v7; // dl@4
  int v8; // ecx@5
  int v9; // ecx@17
  bool v10; // zf@17
  int v11; // ebp@19
  char v13; // [sp+13h] [bp-1h]@1

  v4 = *(_BYTE *)(a2 + 4);
  v13 = 0;
  v5 = sub_10003FF0();
  v6 = a1;
  if ( a1 == 9.8999998e24 )
  {
    v4 = 10;
    v13 = 10;
  }
  else if ( *(_BYTE *)(a4 + 24) )
  {
    v4 = *(_BYTE *)a4;
    v13 = *(_BYTE *)(a4 + 12);
  }
  else
  {
    v7 = 1;
    if ( (unsigned __int8)a3 > 1u )
    {
      v8 = a2;
      do
      {
        if ( 9.8999998e24 != *(float *)(v8 + 8)
          && (*(float *)v8 < (double)*(float *)(v8 + 8) && *(float *)v8 < v6
           || *(float *)v8 > (double)*(float *)(v8 + 8) && *(float *)v8 > v6) )
        {
          v4 = *(_BYTE *)(v8 + 12);
          v13 = v7;
        }
        ++v7;
        v8 += 8;
      }
      while ( v7 < (unsigned __int8)a3 );
    }
  }
  if ( v4 != *(_BYTE *)a4 )
  {
    *(_DWORD *)(a4 + 8) = 0;
    *(_DWORD *)(a4 + 4) = v5;
  }
  v9 = v5 - *(_DWORD *)(a4 + 4);
  v10 = v13 == *(_BYTE *)(a4 + 12);
  *(_BYTE *)a4 = v4;
  *(_DWORD *)(a4 + 8) = v9;
  if ( !v10 )
  {
    *(_DWORD *)(a4 + 20) = 0;
    *(_DWORD *)(a4 + 16) = v5;
  }
  v11 = v5 - *(_DWORD *)(a4 + 16);
  *(_BYTE *)(a4 + 12) = v13;
  *(_DWORD *)(a4 + 20) = v11;
  return v4;
}

//----- (10019610) --------------------------------------------------------
char __cdecl sub_10019610(char a1, _DWORD *a2, int *a3, char a4, int a5)
{
  int v5; // eax@1
  int *v6; // ecx@2
  int v7; // ecx@4
  int v8; // edx@8

  LOBYTE(v5) = a4;
  if ( a4 == 1 )
  {
    LOBYTE(v5) = (_BYTE)a2;
    v6 = a3;
    *a2 = 0;
    *v6 = 0;
  }
  else if ( !a4 )
  {
    v5 = 32 * sub_10019830(&a1, 1u, (int)&unk_10089ED0, 32, 20, 0);
    v7 = *(int *)((char *)&dword_10089EEC + v5);
    if ( !v7 || v7 != -1 && a5 > v7 || byte_101A5AB6 )
    {
      *a2 = *(int *)((char *)&dword_10089EDC + v5);
      v5 = *(int *)((char *)&dword_10089EE0 + v5);
      *a3 = v5;
    }
    else
    {
      *a2 = *(int *)((char *)&dword_10089EE0 + v5);
      v8 = *(int *)((char *)&dword_10089EDC + v5);
      LOBYTE(v5) = (_BYTE)a3;
      *a3 = v8;
    }
  }
  return v5;
}
// 10089EDC: using guessed type int dword_10089EDC;
// 10089EE0: using guessed type int dword_10089EE0;
// 10089EEC: using guessed type int dword_10089EEC;
// 101A5AB6: using guessed type char byte_101A5AB6;

//----- (100196A0) --------------------------------------------------------
char __cdecl sub_100196A0(char a1, _DWORD *a2, int *a3, char a4, int a5)
{
  int v5; // eax@1
  int *v6; // ecx@2
  int v7; // ecx@4
  int v8; // edx@8

  LOBYTE(v5) = a4;
  if ( a4 == 1 )
  {
    LOBYTE(v5) = (_BYTE)a2;
    v6 = a3;
    *a2 = 0;
    *v6 = 0;
  }
  else if ( !a4 )
  {
    v5 = 32 * sub_10019830(&a1, 1u, (int)&unk_10089ED0, 32, 20, 0);
    v7 = *(int *)((char *)&dword_10089EEC + v5);
    if ( !v7 || v7 != -1 && a5 > v7 || byte_101A5AB6 )
    {
      *a2 = *(int *)((char *)&dword_10089ED4 + v5);
      v5 = *(int *)((char *)&dword_10089ED8 + v5);
      *a3 = v5;
    }
    else
    {
      *a2 = *(int *)((char *)&dword_10089ED8 + v5);
      v8 = *(int *)((char *)&dword_10089ED4 + v5);
      LOBYTE(v5) = (_BYTE)a3;
      *a3 = v8;
    }
  }
  return v5;
}
// 10089ED4: using guessed type int dword_10089ED4;
// 10089ED8: using guessed type int dword_10089ED8;
// 10089EEC: using guessed type int dword_10089EEC;
// 101A5AB6: using guessed type char byte_101A5AB6;

//----- (10019730) --------------------------------------------------------
int __cdecl sub_10019730(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + 12) = 10;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_BYTE *)a1 = 10;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  return result;
}

//----- (10019750) --------------------------------------------------------
double __cdecl sub_10019750(float a1, float a2, int a3, float a4)
{
  double v4; // st7@2
  double v5; // st7@4
  bool v6; // c0@5
  double v7; // st7@5
  double v9; // st5@7
  bool v10; // c0@7
  bool v11; // c3@7
  float v12; // [sp+8h] [bp-8h]@4
  float v13; // [sp+Ch] [bp-4h]@4
  int v14; // [sp+1Ch] [bp+Ch]@4
  int v15; // [sp+1Ch] [bp+Ch]@4
  int v16; // [sp+1Ch] [bp+Ch]@4
  int v17; // [sp+1Ch] [bp+Ch]@9

  if ( (unsigned __int8)a3 <= 0x64u )
    v4 = (double)(unsigned __int8)a3;
  else
    v4 = 100.0;
  *(float *)&v14 = v4;
  *(float *)&v15 = *(float *)&v14 / 100.0 * a4;
  v12 = (*(float *)&v15 + a4) * 0.5;
  v13 = sub_1003C7C0(a1, a4);
  *(float *)&v16 = sub_1003C720(a1, a4);
  v5 = a1;
  if ( a1 < (double)a2 )
  {
    v9 = *(float *)&v16 - v12;
    v10 = v9 < v5;
    v11 = v9 == v5;
    v7 = *(float *)&v16;
    if ( !v10 && !v11 )
      v7 = v13;
  }
  else
  {
    v6 = v13 + v12 < v5;
    v7 = v13;
    if ( v6 )
      return *(float *)&v16;
  }
  *(float *)&v17 = v7;
  return *(float *)&v17;
}

//----- (10019830) --------------------------------------------------------
int __cdecl sub_10019830(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (100199C0) --------------------------------------------------------
int __cdecl sub_100199C0(int a1, float a2)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    *(float *)a1 = a2 * 1.799999952316284 + 32.0;
  return result;
}

//----- (100199E0) --------------------------------------------------------
int __cdecl sub_100199E0(int a1, float a2)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    *(float *)a1 = (a2 - 32.0) * 0.5555555820465088;
  return result;
}

//----- (10019A00) --------------------------------------------------------
int sub_10019A00()
{
  int result; // eax@1

  sub_10004370(6361, (int)&unk_101292F4, 4);
  result = sub_10004370(6362, (int)&unk_101292F8, 4);
  dword_101292FC = 1379255385;
  return result;
}
// 101292FC: using guessed type int dword_101292FC;

//----- (10019A30) --------------------------------------------------------
int __usercall sub_10019A30@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  *(_DWORD *)(result + 16) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a3 + 4);
  *(float *)(result + 12) = *(float *)(a3 + 12);
  *(_DWORD *)(result + 8) = *(_DWORD *)(a3 + 20);
  *(float *)(result + 24) = *(float *)(a3 + 24);
  *(float *)(result + 28) = *(float *)(a3 + 28);
  *(float *)(result + 32) = *(float *)(a3 + 16);
  *(float *)result = (double)*(_WORD *)a2;
  *(float *)(result + 4) = (double)*(_WORD *)(a2 + 2);
  return result;
}

//----- (10019B00) --------------------------------------------------------
signed int __fastcall sub_10019B00(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (10019B10) --------------------------------------------------------
char __cdecl sub_10019B10(unsigned __int8 a1)
{
  return byte_1008C6E4[6 * sub_10019B00(a1)];
}

//----- (10019B30) --------------------------------------------------------
__int16 __cdecl sub_10019B30(unsigned __int8 a1)
{
  return word_1008C6E0[3 * sub_10019B00(a1)];
}
// 1008C6E0: using guessed type __int16 word_1008C6E0[];

//----- (10019B50) --------------------------------------------------------
char *__cdecl sub_10019B50(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = (char *)&unk_10058CA9;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (10019BA0) --------------------------------------------------------
int sub_10019BA0()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_10003F80();
  result = 0;
  while ( 1 )
  {
    v3 = dword_10129314[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_10129314[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 10129314: using guessed type int dword_10129314[];

//----- (10019BE0) --------------------------------------------------------
int __cdecl sub_10019BE0(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10019C50) --------------------------------------------------------
signed int __cdecl sub_10019C50(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10019CF0) --------------------------------------------------------
int __usercall sub_10019CF0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_10019C50(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10019D20) --------------------------------------------------------
signed int __usercall sub_10019D20@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_10019C50((_BYTE *)a3, (int)(&off_1008D030)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_1008D034[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_1003F0B9(a3, (int)"%ld", (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_1003F0B9(a3, (int)"%lu", (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_1003F0B9(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 1008D030: using guessed type char *off_1008D030;

//----- (10019EF0) --------------------------------------------------------
char *__usercall sub_10019EF0@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, " ", 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (10019F50) --------------------------------------------------------
int __usercall sub_10019F50@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_10019C50((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10019FE0) --------------------------------------------------------
int __usercall sub_10019FE0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_10019CF0(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (1001A030) --------------------------------------------------------
char **__usercall sub_1001A030@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_10019B50(v6);
      if ( !sub_10019C50((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (1001A090) --------------------------------------------------------
const char *__usercall sub_1001A090@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (1001A0B0) --------------------------------------------------------
int __usercall sub_1001A0B0@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_10129300[sub_10019BA0()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10129300: using guessed type int dword_10129300[];

//----- (1001A0F0) --------------------------------------------------------
int __usercall sub_1001A0F0@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_10019D20(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (1001A180) --------------------------------------------------------
int __usercall sub_1001A180@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (1001A2D0) --------------------------------------------------------
int __usercall sub_1001A2D0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_1001C020(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_1001ABB0(v3, v6, 0);
        v7 = -*v3;
        sub_1001C020(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_1001C020(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_1008CCE8);
      sub_10030830(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_1008CCE8);
      sub_1001C020(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (1001A370) --------------------------------------------------------
int __usercall sub_1001A370@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (1001A3B0) --------------------------------------------------------
char *__cdecl sub_1001A3B0(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_10019EF0(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_10019EF0(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_10019EF0(result, v5, (int)&v20);
      v10 = (const char *)&unk_10058CA9;
    }
    LOBYTE(v9) = 0;
    sub_10019EF0(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_10019EF0(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_10019EF0(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_10019EF0(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_1001BFB0(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 1001A3B0: using guessed type int var_61C[6];

//----- (1001A560) --------------------------------------------------------
int __usercall sub_1001A560@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_10019B50((char **)a1);
  result = sub_1001C040(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_1008CCE8);
  return result;
}

//----- (1001A590) --------------------------------------------------------
int __usercall sub_1001A590@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_1008CCE8);
  v2 = (unsigned int)sub_10019B50((char **)a1);
  return sub_1001C020(10, v2);
}

//----- (1001A5C0) --------------------------------------------------------
void __cdecl sub_1001A5C0(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_10019B50(v5);
            v7 = sub_10019B50((char **)v3);
            if ( !sub_10019BE0(v7, (int)v6) )
            {
              v8 = sub_10019B50((char **)v3);
              sub_1001C0E0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_10019B50((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_10019B50((char **)v3);
        sub_1001C0E0(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_1001A090(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_1001CB00("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_10019B50((char **)v3);
            sub_1001C120(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_10019BE0(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_1001A090(v18);
                  v25 = sub_1001CB00("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_10019B50((char **)v3);
                  sub_1001C120(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_10019B50((char **)v3);
                  sub_1001C120(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_10019B50((char **)v3);
              sub_1001C120(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_10019B50((char **)v3);
              sub_1001C120(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_10019B50((char **)v3);
              sub_1001C120(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_1001A5C0(*(_DWORD *)(v3 + 8) + v11 + 8, v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_10019B50((char **)v3);
            sub_1001C120(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_10019B50((char **)v3);
            sub_1001C120(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_10019B50((char **)v3);
          sub_1001C120(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_10019B50((char **)v3);
        sub_1001C120(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_10019B50(a2);
      sub_1001C0E0(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (1001AA30) --------------------------------------------------------
int sub_1001AA30()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_10129300[sub_10019BA0()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_1001A5C0(i, 0, &v2);
  }
  return v2;
}
// 10129300: using guessed type int dword_10129300[];

//----- (1001AA80) --------------------------------------------------------
void *sub_1001AA80()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_10129300[0] = 0;
  dword_10129304 = 0;
  dword_10129308 = 0;
  dword_1012930C = 0;
  dword_10129310 = 0;
  result = &unk_10129328;
  dword_10129314[0] = -1;
  dword_10129318 = -1;
  dword_1012931C = -1;
  dword_10129320 = -1;
  dword_10129324 = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_1001A370((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 10129300: using guessed type int dword_10129300[];
// 10129304: using guessed type int dword_10129304;
// 10129308: using guessed type int dword_10129308;
// 1012930C: using guessed type int dword_1012930C;
// 10129310: using guessed type int dword_10129310;
// 10129314: using guessed type int dword_10129314[];
// 10129318: using guessed type int dword_10129318;
// 1012931C: using guessed type int dword_1012931C;
// 10129320: using guessed type int dword_10129320;
// 10129324: using guessed type int dword_10129324;

//----- (1001AAE0) --------------------------------------------------------
char *sub_1001AAE0()
{
  return (char *)&unk_10129328 + 56 * sub_10019BA0();
}

//----- (1001AB00) --------------------------------------------------------
char sub_1001AB00()
{
  return sub_1001AAE0()[33];
}

//----- (1001AB10) --------------------------------------------------------
char __cdecl sub_1001AB10(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_1001AAE0();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_1001BBA0(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (1001AB50) --------------------------------------------------------
int *__usercall sub_1001AB50@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_1001AAE0() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_10019C50((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (1001ABA0) --------------------------------------------------------
char **sub_1001ABA0()
{
  return &off_1008D098;
}
// 1008D098: using guessed type char *off_1008D098;

//----- (1001ABB0) --------------------------------------------------------
int __cdecl sub_1001ABB0(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_10020D70();
  v3 = sub_1001AAE0();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_1001AA30();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_1001A560(a2);
    if ( a3 )
    {
      v7 = sub_1001A2D0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_1001A2D0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_1001A590(a2);
        return v7;
      }
    }
    sub_1001A590(a2);
    result = v7;
  }
  return result;
}

//----- (1001AC60) --------------------------------------------------------
int __cdecl sub_1001AC60(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_10019EF0(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_10019EF0(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_10019EF0(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_1001BFB0(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_10019EF0(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_10019EF0(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_10019EF0(v14, "group-begin", (int)&v29);
          sub_1001BFB0(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_10019B50(v15);
          sub_1001AC60(v16[2], v16[3], v16[4], v17, a4);
          sub_10019B50(v16);
          v18 = sub_1001A3B0((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_10019EF0(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_10019EF0(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_10019EF0(v20, "group-end", (int)&v29);
          result = sub_1001BFB0(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_10019EF0(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_10019EF0(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_10019EF0(v21, a4, (int)&v28);
          v23 = (const char *)&unk_10058CA9;
        }
        LOBYTE(v22) = 0;
        v24 = sub_10019EF0(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_10019EF0(v24, *(const char **)v5, (int)&v30);
        result = sub_1001BFB0(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 1001AC60: using guessed type int var_414[4];

//----- (1001AE70) --------------------------------------------------------
char *__usercall sub_1001AE70@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_10019EF0(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_10019EF0(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_1001BFB0(2, (int)v11, 2);
  if ( a6 )
  {
    sub_1001AC60(a3, (int)a4, a5, a2, 0);
    result = sub_1001A3B0(a3, a4, a5, 0);
  }
  return result;
}
// 1001AE70: using guessed type int var_20C[2];

//----- (1001AF30) --------------------------------------------------------
char *__cdecl sub_1001AF30(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_10129300[sub_10019BA0()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_10019B50((char **)v2);
    sub_1001AE70("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_1001AAE0() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_1001AE70(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 10129300: using guessed type int dword_10129300[];

//----- (1001AFD0) --------------------------------------------------------
int *__cdecl sub_1001AFD0(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_10129300[sub_10019BA0()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_10019B50(v2);
      if ( !sub_10019C50(a1, (int)v4) )
      {
        v5 = sub_10019B50(v3);
        sub_1001AE70("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_1001AAE0();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_10019C50(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_1001AE70(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 10129300: using guessed type int dword_10129300[];

//----- (1001B090) --------------------------------------------------------
int __usercall sub_1001B090@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_1001A0B0(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_1001ABB0((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_1001A0B0(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_1001ABB0((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_1001A560(v5);
        sub_1001A2D0(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_1001A590(v8);
          v10 = sub_1001A0B0(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (1001B1F0) --------------------------------------------------------
signed int __usercall sub_1001B1F0@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_10129300[sub_10019BA0()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_1001ABB0((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 10129300: using guessed type int dword_10129300[];

//----- (1001B260) --------------------------------------------------------
int __cdecl sub_1001B260(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_1001AAE0();
  switch ( a1 )
  {
    case 9:
      sub_1001C020(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_10019C50((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_10019C50(v6, (int)"-q") )
            {
              sub_1001AFD0(v6);
              v9 = sub_1001AA30();
              sub_1001C020(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_1001AF30(0);
              v8 = sub_1001AA30();
              sub_1001C020(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_1001AF30(1);
            v7 = sub_1001AA30();
            sub_1001C020(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_1001C0A0(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_1001C020(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_1001AF30(0);
        v4 = sub_1001AA30();
        sub_1001C020(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_1001C020(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_10129300[sub_10019BA0()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_1001B260 )
              v12(2, (int)&unk_1008CCE8);
          }
        }
      }
      sub_10020D70();
      v3[34] = 0;
      return 0;
    case 3:
      sub_1001C020(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_10129300[sub_10019BA0()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_1001C0A0(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_1001B090((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_1001C0A0(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_1001B1F0((int)v3);
    case 14:
      exit_0(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_1001C0A0(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_1001B260 )
          v15(3, (int)&unk_1008CCE8);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 1001B260: using guessed type int __cdecl sub_1001B260(int, int);
// 10129300: using guessed type int dword_10129300[];

//----- (1001B540) --------------------------------------------------------
char **sub_1001B540()
{
  return off_1008CE8C;
}
// 1008CE8C: using guessed type char *off_1008CE8C[3];

//----- (1001B550) --------------------------------------------------------
int __usercall sub_1001B550@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_10019FE0(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_1001A0F0(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_1001B540();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (1001B640) --------------------------------------------------------
int __cdecl sub_1001B640(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_1001AAE0();
  *a1 = 0;
  v4 = sub_1001CB00("Processing command '%s'", v2);
  sub_1001C0A0(3, (int)&unk_1008D840, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_1001A180(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_1001B090((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_1001B1F0((int)v3);
    v11 = 0;
    v6 = sub_10019BA0();
    v7 = sub_1001A030((int (**)(void))dword_10129300[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_10019F50((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_10019F50((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_1001ABB0(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_1001ABB0(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_1001B550(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_1001AB50(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_1001B550(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_1001B540();
        result = sub_1001B550(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 10129300: using guessed type int dword_10129300[];
// 1001B640: using guessed type char var_2D4[720];

//----- (1001B880) --------------------------------------------------------
int sub_1001B880()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_1001B640(&v4);
  if ( !sub_1001AAE0()[32] )
    sub_1001C020(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_1001CB00("%s %i, %s", "Command status:", v0, &v4);
    sub_1001C0A0(3, (int)&unk_1008D840, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_1001CB00("%s %i", "Command status:", v0);
    sub_1001C0A0(3, (int)&unk_1008D840, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (1001B960) --------------------------------------------------------
int __cdecl sub_1001B960(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_10129300[sub_10019BA0()] = a1;
  sub_1001AAE0()[32] = a3;
  sub_10020D70();
  sub_10030A40(a2);
  v3 = sub_1001ABA0();
  sub_1001BA90(v3);
  return sub_1001B880();
}
// 10129300: using guessed type int dword_10129300[];

//----- (1001B9B0) --------------------------------------------------------
int __cdecl sub_1001B9B0(int a1)
{
  return a1 + 9;
}

//----- (1001B9C0) --------------------------------------------------------
int __cdecl sub_1001B9C0(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_10003F80();
  memset(a1, 0, 0xDCu);
  sub_10011C70((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_1001B9B0(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_10030BD0((int)a1, (int)v3);
}

//----- (1001BA40) --------------------------------------------------------
int __cdecl sub_1001BA40(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_10030DE0(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (1001BA70) --------------------------------------------------------
signed int __cdecl sub_1001BA70(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_1004F540(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_10003FF0();
    }
    else if ( v6 != -57 || (unsigned int)(sub_10003FF0() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_10030BD0(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (1001BA90) --------------------------------------------------------
char __cdecl sub_1001BA90(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_1001AAE0() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_10030880("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_1001B880() )
          v7 = 0;
      }
      v5 = sub_10030880("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_1001B880() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (1001BBA0) --------------------------------------------------------
char __cdecl sub_1001BBA0(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (1001BBD0) --------------------------------------------------------
bool __cdecl sub_1001BBD0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (1001BC00) --------------------------------------------------------
bool __cdecl sub_1001BC00(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (1001BC30) --------------------------------------------------------
bool __cdecl sub_1001BC30(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (1001BC60) --------------------------------------------------------
bool __cdecl sub_1001BC60(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (1001BC90) --------------------------------------------------------
bool __cdecl sub_1001BC90(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (1001BCC0) --------------------------------------------------------
bool __cdecl sub_1001BCC0(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (1001BD00) --------------------------------------------------------
bool __cdecl sub_1001BD00(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (1001BD40) --------------------------------------------------------
bool __cdecl sub_1001BD40(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (1001BD70) --------------------------------------------------------
bool __cdecl sub_1001BD70(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (1001BDA0) --------------------------------------------------------
char __cdecl sub_1001BDA0(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (1001BDD0) --------------------------------------------------------
bool __cdecl sub_1001BDD0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (1001BE00) --------------------------------------------------------
bool __cdecl sub_1001BE00(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (1001BE30) --------------------------------------------------------
bool __cdecl sub_1001BE30(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (1001BE60) --------------------------------------------------------
bool __cdecl sub_1001BE60(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (1001BE90) --------------------------------------------------------
bool __cdecl sub_1001BE90(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_1008D840, 9u);
}

//----- (1001BEC0) --------------------------------------------------------
bool __cdecl sub_1001BEC0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (1001BEF0) --------------------------------------------------------
bool __cdecl sub_1001BEF0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (1001BF20) --------------------------------------------------------
bool __cdecl sub_1001BF20(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (1001BF50) --------------------------------------------------------
bool __cdecl sub_1001BF50(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (1001BF80) --------------------------------------------------------
bool __cdecl sub_1001BF80(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (1001BFB0) --------------------------------------------------------
int __cdecl sub_1001BFB0(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_1001AAE0() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (1001C020) --------------------------------------------------------
int __cdecl sub_1001C020(int a1, char a2)
{
  return sub_1001BFB0(a1, (int)&a2, 1);
}

//----- (1001C040) --------------------------------------------------------
int __cdecl sub_1001C040(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_1001BFB0(a1, (int)&v4, 2);
}

//----- (1001C070) --------------------------------------------------------
int __cdecl sub_1001C070(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_1001BFB0(a1, (int)&v5, 3);
}

//----- (1001C0A0) --------------------------------------------------------
int __cdecl sub_1001C0A0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_1001BFB0(a1, (int)&v6, 4);
}

//----- (1001C0E0) --------------------------------------------------------
int __cdecl sub_1001C0E0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_1001BFB0(a1, (int)&v7, 5);
}

//----- (1001C120) --------------------------------------------------------
int __cdecl sub_1001C120(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_1001BFB0(a1, (int)&v8, 6);
}

//----- (1001C170) --------------------------------------------------------
char __cdecl sub_1001C170(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_1001AAE0();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (1001C1A0) --------------------------------------------------------
char __cdecl sub_1001C1A0(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (1001C1B0) --------------------------------------------------------
char __cdecl sub_1001C1B0(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  void *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = &unk_10058230, v3) )
          v11 = &unk_10058CA9;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_10030F00(v16) )
        sub_10030EE0((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_10030F10((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 10030F00: using guessed type _DWORD __cdecl sub_10030F00(_DWORD);
// 1001C1B0: using guessed type char var_104[255];

//----- (1001C330) --------------------------------------------------------
signed int __cdecl sub_1001C330(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (1001C370) --------------------------------------------------------
signed int __cdecl sub_1001C370(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (1001C410) --------------------------------------------------------
char __cdecl sub_1001C410(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (1001C470) --------------------------------------------------------
char __cdecl sub_1001C470(int a1, void (__cdecl *a2)(int))
{
  char result; // al@6

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( a2 )
      a2(a1);
    sub_10030EC0(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return result;
}

//----- (1001C4E0) --------------------------------------------------------
char *__cdecl sub_1001C4E0(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_10129440, v1, v2);
  *(&byte_10129440 + v2) = 0;
  return &byte_10129440;
}

//----- (1001C580) --------------------------------------------------------
int __cdecl sub_1001C580(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1001C5F0) --------------------------------------------------------
bool __cdecl sub_1001C5F0(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_1003F0B9(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_1003F0B9(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (1001C680) --------------------------------------------------------
char __cdecl sub_1001C680(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (1001C730) --------------------------------------------------------
char __cdecl sub_1001C730(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (1001C740) --------------------------------------------------------
char __cdecl sub_1001C740(int a1, void (__cdecl *a2)(int))
{
  char v2; // bl@1

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 324) > 0 || *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    v2 = 1;
    if ( a2 )
      a2(a1);
  }
  if ( *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    sub_10030EC0(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    v2 = 1;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return v2;
}

//----- (1001C7C0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1001C7C0(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_10030F90((int)a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}

//----- (1001C810) --------------------------------------------------------
signed int __cdecl sub_1001C810(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@1

  sub_1001C740(a1, a2);
  result = 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1001C860) --------------------------------------------------------
char *__cdecl sub_1001C860(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  void *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_10030880("CFG_ActDir", (int)&unk_10058CA9);
      v10 = sub_10030880("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_10030880("CFG_ExpDir", (int)&unk_10058CA9);
      v10 = sub_10030880("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_10030880("CFG_ActDir", (int)&unk_10058CA9);
      break;
    case 4:
      v10 = sub_10030880("CFG_ExpDir", (int)&unk_10058CA9);
      break;
    default:
      v10 = (char *)&unk_10058CA9;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = &unk_10058230, v14) )
    v15 = &unk_10058CA9;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 1001C860: using guessed type char var_104[256];

//----- (1001C9E0) --------------------------------------------------------
int sub_1001C9E0()
{
  return dword_1012E130[sub_10019BA0()];
}
// 1012E130: using guessed type int dword_1012E130[];

//----- (1001C9F0) --------------------------------------------------------
const char *__cdecl sub_1001C9F0(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_1008DA74[a1];
  return result;
}
// 1008DA74: using guessed type char *off_1008DA74[7];

//----- (1001CA10) --------------------------------------------------------
int __cdecl sub_1001CA10(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_1001C0E0(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (1001CAC0) --------------------------------------------------------
int __cdecl sub_1001CAC0(int a1)
{
  int result; // eax@1

  result = sub_10019BA0();
  dword_1013023C[result] = a1;
  return result;
}
// 1013023C: using guessed type int dword_1013023C[];

//----- (1001CAE0) --------------------------------------------------------
int __cdecl sub_1001CAE0(int a1)
{
  int result; // eax@1

  result = sub_10019BA0();
  dword_1012E130[result] = a1;
  return result;
}
// 1012E130: using guessed type int dword_1012E130[];

//----- (1001CB00) --------------------------------------------------------
char *sub_1001CB00(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_10019BA0() << 8;
  _vsnprintf(&byte_10129540[v1], 0x100u, a1, va);
  result = &byte_10129540[v1];
  byte_1012963E[v1] = 42;
  byte_1012963F[v1] = 0;
  return result;
}

//----- (1001CB40) --------------------------------------------------------
char *__usercall sub_1001CB40@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_1008DA88[a1 & 1];
  else
    result = off_1008DA80[a2];
  return result;
}
// 1008DA80: using guessed type char *off_1008DA80[4];
// 1008DA88: using guessed type char *off_1008DA88[2];

//----- (1001CB60) --------------------------------------------------------
char __usercall sub_1001CB60@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  const char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_10019BA0();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_1001C9E0() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_10131830[v6];
      v12 = dword_10131844[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_1012E144[v6];
      v12 = dword_10130228[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 1012E144: using guessed type int dword_1012E144[];
// 10130228: using guessed type int dword_10130228[];
// 10131830: using guessed type int dword_10131830[];
// 10131844: using guessed type int dword_10131844[];

//----- (1001CD40) --------------------------------------------------------
int sub_1001CD40()
{
  nullsub_1("..\\lib\\utf\\utf_verify.c", "2370");
  return 0;
}

//----- (1001CD60) --------------------------------------------------------
int sub_1001CD60()
{
  return nullsub_1("..\\lib\\utf\\utf_verify.c", "2396");
}

//----- (1001CD80) --------------------------------------------------------
int __cdecl sub_1001CD80(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10019BA0();
  dword_10130228[result] = a1;
  if ( a2 >= 0 )
  {
    dword_1012E144[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_1001CB00(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_1001C0A0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_1012E144[result] = 8;
  }
  return result;
}
// 1012E144: using guessed type int dword_1012E144[];
// 10130228: using guessed type int dword_10130228[];

//----- (1001CDE0) --------------------------------------------------------
int __cdecl sub_1001CDE0(int a1)
{
  return sub_1001CD80(0, a1);
}

//----- (1001CDF0) --------------------------------------------------------
int __cdecl sub_1001CDF0(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10019BA0();
  dword_10131844[result] = a1;
  if ( a2 >= 0 )
  {
    dword_10131830[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_1001CB00(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_1001C0A0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_10131830[result] = 8;
  }
  return result;
}
// 10131830: using guessed type int dword_10131830[];
// 10131844: using guessed type int dword_10131844[];

//----- (1001CE50) --------------------------------------------------------
int __cdecl sub_1001CE50(int a1)
{
  return sub_1001CDF0(0, a1);
}

//----- (1001CE60) --------------------------------------------------------
bool __cdecl sub_1001CE60(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_1001AB00() )
    v8 = v8 == 0;
  v9 = off_1008DA58[a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_1008DA48[v8 != 0];
  v19 = off_1008DA50[a1];
  v18 = v10;
  v21 = sub_1001CB40(0, a6);
  v22 = sub_1001CB40(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_10031170();
  sub_1001BFB0(7, (int)&v14, v11);
  sub_10031180(v12);
  return v8;
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];

//----- (1001CFA0) --------------------------------------------------------
bool __cdecl sub_1001CFA0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  unsigned __int8 v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  bool v16; // [sp+1Bh] [bp-5Dh]@2
  char v17; // [sp+1Fh] [bp-59h]@25
  unsigned int v18; // [sp+20h] [bp-58h]@1
  char *v19; // [sp+3Ch] [bp-3Ch]@28
  int v20; // [sp+40h] [bp-38h]@28
  int v21; // [sp+44h] [bp-34h]@28
  int v22; // [sp+48h] [bp-30h]@28
  char *v23; // [sp+4Ch] [bp-2Ch]@28
  char *v24; // [sp+50h] [bp-28h]@28
  const char *v25; // [sp+54h] [bp-24h]@28
  const char *v26; // [sp+58h] [bp-20h]@28
  const char *v27; // [sp+5Ch] [bp-1Ch]@28
  char *v28; // [sp+60h] [bp-18h]@28
  int v29; // [sp+64h] [bp-14h]@29
  char v30; // [sp+68h] [bp-10h]@25

  v8 = sub_10019BA0();
  v18 = 9;
  switch ( a2 )
  {
    case 0:
      v16 = a6 == a7;
      break;
    case 1:
      v16 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 4:
      v16 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_38;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v16 = 1;
      if ( a6 > v10 )
LABEL_38:
        v16 = 0;
      v18 = 10;
      break;
    default:
LABEL_22:
      v16 = 0;
      break;
  }
  if ( sub_1001AB00() )
    v16 = v16 == 0;
  sub_1001CB60((int)&v30, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_1012A530[v11], 0x400u, &v30, a6);
  byte_1012A92E[v11] = 42;
  byte_1012A92F[v11] = 0;
  v17 = sub_1001CB60((int)&v30, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_1012A930[v11], 0x400u, &v30, a7);
  byte_1012AD2E[v11] = 42;
  byte_1012AD2F[v11] = 0;
  if ( v18 <= 9 )
  {
    v12 = &byte_1012AD30[v11];
    byte_1012AD30[v11] = 0;
  }
  else
  {
    v17 = sub_1001CB60((int)&v30, "%c", 3, 0xCu, 0.0);
    v12 = &byte_1012AD30[v11];
    _snprintf(&byte_1012AD30[v11], 0x400u, &v30, 0);
    byte_1012B12E[v11] = 42;
    byte_1012B12F[v11] = 0;
  }
  v19 = off_1008DA58[a2];
  v21 = a4;
  v22 = a5;
  v20 = a3;
  v25 = "char";
  v26 = &byte_1012A530[v11];
  v27 = &byte_1012A930[v11];
  v13 = off_1008DA50[a1];
  v23 = off_1008DA48[v16 != 0];
  v24 = v13;
  v28 = v12;
  if ( a8 )
  {
    v29 = a8;
    v18 = 11;
  }
  v14 = sub_10031170();
  sub_1001BFB0(7, (int)&v19, v18);
  if ( v17 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 && !strcmp(v26, v27) )
  {
    nullsub_1(a3, a4);
    sub_1001C0A0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10031180(v14);
  return v16;
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];

//----- (1001D350) --------------------------------------------------------
bool __cdecl sub_1001D350(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  bool v20; // [sp+27h] [bp-61h]@10
  char v21; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v22; // [sp+2Ch] [bp-5Ch]@8
  char *v23; // [sp+4Ch] [bp-3Ch]@37
  int v24; // [sp+50h] [bp-38h]@37
  int v25; // [sp+54h] [bp-34h]@37
  int v26; // [sp+58h] [bp-30h]@37
  char *v27; // [sp+5Ch] [bp-2Ch]@37
  char *v28; // [sp+60h] [bp-28h]@37
  const char *v29; // [sp+64h] [bp-24h]@37
  const char *v30; // [sp+68h] [bp-20h]@37
  const char *v31; // [sp+6Ch] [bp-1Ch]@37
  char *v32; // [sp+70h] [bp-18h]@37
  int v33; // [sp+74h] [bp-14h]@38
  char v34; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_10019BA0();
  v22 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 1:
      v20 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v20 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_47;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_47:
        v20 = 0;
        v22 = 10;
      }
      else
      {
        v20 = 1;
        v22 = 10;
      }
      break;
    default:
LABEL_18:
      v20 = 0;
      break;
  }
  if ( sub_1001AB00() )
    v20 = v20 == 0;
  sub_1001CB60((int)&v34, (char *)&unk_1008DD40, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_1012A530[v12], 0x400u, &v34);
  byte_1012A92E[v12] = 42;
  byte_1012A92F[v12] = 0;
  v21 = sub_1001CB60((int)&v34, (char *)&unk_1008DD40, 3, 0xCu, a7);
  _snprintf(&byte_1012A930[v12], 0x400u, &v34, a7);
  byte_1012AD2E[v12] = 42;
  byte_1012AD2F[v12] = 0;
  if ( v22 <= 9 )
  {
    v13 = &byte_1012AD30[v12];
    byte_1012AD30[v12] = 0;
  }
  else
  {
    v13 = &byte_1012AD30[v12];
    v21 = sub_1001CB60((int)&v34, (char *)&unk_1008DD40, 3, 0xCu, v10);
    _snprintf(&byte_1012AD30[v12], 0x400u, &v34, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_1012B12E[v12] = 42;
    byte_1012B12F[v12] = 0;
  }
  v23 = off_1008DA58[a2];
  v26 = a5;
  v25 = a4;
  v24 = a3;
  v29 = "double";
  v30 = &byte_1012A530[v12];
  v32 = v13;
  v17 = off_1008DA50[a1];
  v27 = off_1008DA48[v20 != 0];
  v28 = v17;
  v31 = &byte_1012A930[v12];
  if ( a9 )
  {
    v33 = a9;
    v22 = 11;
  }
  v18 = sub_10031170();
  sub_1001BFB0(7, (int)&v23, v22);
  if ( v21 && a6 != a7 && fabs(a6 - a7) > v10 && !strcmp(v30, v31) )
  {
    nullsub_1(a3, a4);
    sub_1001C0A0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10031180(v18);
  return v20;
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];

//----- (1001D7A0) --------------------------------------------------------
bool __cdecl sub_1001D7A0(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  bool v25; // [sp+1Bh] [bp-59h]@10
  char v26; // [sp+1Fh] [bp-55h]@35
  unsigned int v27; // [sp+20h] [bp-54h]@8
  float v28; // [sp+24h] [bp-50h]@8
  char *v29; // [sp+38h] [bp-3Ch]@38
  int v30; // [sp+3Ch] [bp-38h]@38
  int v31; // [sp+40h] [bp-34h]@38
  int v32; // [sp+44h] [bp-30h]@38
  char *v33; // [sp+48h] [bp-2Ch]@38
  char *v34; // [sp+4Ch] [bp-28h]@38
  const char *v35; // [sp+50h] [bp-24h]@38
  const char *v36; // [sp+54h] [bp-20h]@38
  const char *v37; // [sp+58h] [bp-1Ch]@38
  char *v38; // [sp+5Ch] [bp-18h]@38
  int v39; // [sp+60h] [bp-14h]@39
  char v40; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v28 = v13;
  v14 = v28;
  v15 = a6;
  v16 = sub_10019BA0();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_48;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_48:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_32:
      v25 = 0;
      break;
  }
  if ( sub_1001AB00() )
    v25 = v25 == 0;
  sub_1001CB60((int)&v40, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_1012A530[v20], 0x400u, &v40);
  byte_1012A92E[v20] = 42;
  byte_1012A92F[v20] = 0;
  v26 = sub_1001CB60((int)&v40, "%f", 3, 0xCu, a7);
  _snprintf(&byte_1012A930[v20], 0x400u, &v40, a7);
  byte_1012AD2E[v20] = 42;
  byte_1012AD2F[v20] = 0;
  if ( v27 <= 9 )
  {
    v21 = &byte_1012AD30[v20];
    byte_1012AD30[v20] = 0;
  }
  else
  {
    v21 = &byte_1012AD30[v20];
    v26 = sub_1001CB60((int)&v40, "%f", 3, 0xCu, v28);
    _snprintf(&byte_1012AD30[v20], 0x400u, &v40, v28);
    byte_1012B12E[v20] = 42;
    byte_1012B12F[v20] = 0;
  }
  v29 = off_1008DA58[a2];
  v32 = a5;
  v31 = a4;
  v30 = a3;
  v35 = "float";
  v36 = &byte_1012A530[v20];
  v37 = &byte_1012A930[v20];
  v38 = v21;
  v22 = off_1008DA48[v25 != 0];
  v34 = off_1008DA50[a1];
  v33 = v22;
  if ( a9 )
  {
    v39 = a9;
    v27 = 11;
  }
  v23 = sub_10031170();
  sub_1001BFB0(7, (int)&v29, v27);
  if ( v26 && a7 != a6 && v28 < fabs(a6 - a7) && !strcmp(v36, v37) )
  {
    nullsub_1(a3, a4);
    sub_1001C0A0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10031180(v23);
  return v25;
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];

//----- (1001DC60) --------------------------------------------------------
bool __cdecl sub_1001DC60(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  void *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10019BA0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1001AB00() )
    v17 = v17 == 0;
  sub_1001CB60((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_1012A530[v12], 0x400u, &v31, a6);
  byte_1012A92E[v12] = 42;
  byte_1012A92F[v12] = 0;
  v18 = sub_1001CB60((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_1012A930[v12], 0x400u, &v31, a7);
  byte_1012AD2E[v12] = 42;
  byte_1012AD2F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1012AD30[v12];
    byte_1012AD30[v12] = 0;
  }
  else
  {
    v18 = sub_1001CB60((int)&v31, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_1012AD30[v12];
    _snprintf(&byte_1012AD30[v12], 0x400u, &v31, a8);
    byte_1012B12E[v12] = 42;
    byte_1012B12F[v12] = 0;
  }
  v20 = off_1008DA58[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = &unk_1008DD7C;
  v27 = &byte_1012A530[v12];
  v28 = &byte_1012A930[v12];
  v29 = v13;
  v14 = off_1008DA48[v17 != 0];
  v25 = off_1008DA50[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10031170();
  sub_1001BFB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001C0A0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10031180(v15);
  return v17;
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];

//----- (1001E020) --------------------------------------------------------
bool __cdecl sub_1001E020(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10019BA0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_37;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v17 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1001AB00() )
    v17 = v17 == 0;
  sub_1001CB60((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_1012A530[v12], 0x400u, &v31, a6);
  byte_1012A92E[v12] = 42;
  byte_1012A92F[v12] = 0;
  v18 = sub_1001CB60((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_1012A930[v12], 0x400u, &v31, a7);
  byte_1012AD2E[v12] = 42;
  byte_1012AD2F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1012AD30[v12];
    byte_1012AD30[v12] = 0;
  }
  else
  {
    v13 = &byte_1012AD30[v12];
    v18 = sub_1001CB60((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_1012AD30[v12], 0x400u, &v31, a8);
    byte_1012B12E[v12] = 42;
    byte_1012B12F[v12] = 0;
  }
  v20 = off_1008DA58[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_1012A530[v12];
  v21 = a3;
  v26 = "sint16";
  v28 = &byte_1012A930[v12];
  v29 = v13;
  v14 = off_1008DA50[a1];
  v24 = off_1008DA48[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10031170();
  sub_1001BFB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001C0A0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10031180(v15);
  return v17;
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];

//----- (1001E420) --------------------------------------------------------
bool __cdecl sub_1001E420(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10019BA0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1001AB00() )
    v17 = v17 == 0;
  sub_1001CB60((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_1012A530[v12], 0x400u, &v31, a6);
  byte_1012A92E[v12] = 42;
  byte_1012A92F[v12] = 0;
  v18 = sub_1001CB60((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_1012A930[v12], 0x400u, &v31, a7);
  byte_1012AD2E[v12] = 42;
  byte_1012AD2F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1012AD30[v12];
    byte_1012AD30[v12] = 0;
  }
  else
  {
    v18 = sub_1001CB60((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_1012AD30[v12];
    _snprintf(&byte_1012AD30[v12], 0x400u, &v31, a8);
    byte_1012B12E[v12] = 42;
    byte_1012B12F[v12] = 0;
  }
  v20 = off_1008DA58[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "sint32";
  v27 = &byte_1012A530[v12];
  v28 = &byte_1012A930[v12];
  v29 = v13;
  v14 = off_1008DA48[v17 != 0];
  v25 = off_1008DA50[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10031170();
  sub_1001BFB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001C0A0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10031180(v15);
  return v17;
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];

//----- (1001E7E0) --------------------------------------------------------
bool __cdecl sub_1001E7E0(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  bool v18; // [sp+1Bh] [bp-5Dh]@3
  char v19; // [sp+1Fh] [bp-59h]@37
  unsigned int v20; // [sp+20h] [bp-58h]@1
  int v21; // [sp+30h] [bp-48h]@1
  char *v22; // [sp+3Ch] [bp-3Ch]@40
  int v23; // [sp+40h] [bp-38h]@40
  int v24; // [sp+44h] [bp-34h]@40
  int v25; // [sp+48h] [bp-30h]@40
  char *v26; // [sp+4Ch] [bp-2Ch]@40
  char *v27; // [sp+50h] [bp-28h]@40
  const char *v28; // [sp+54h] [bp-24h]@40
  const char *v29; // [sp+58h] [bp-20h]@40
  const char *v30; // [sp+5Ch] [bp-1Ch]@40
  char *v31; // [sp+60h] [bp-18h]@40
  int v32; // [sp+64h] [bp-14h]@41
  char v33; // [sp+68h] [bp-10h]@37

  v21 = sub_10019BA0();
  v20 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 1:
      v18 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v18 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v18 = 0;
      }
      else
      {
        v18 = 1;
      }
LABEL_35:
      if ( sub_1001AB00() )
        v18 = v18 == 0;
      sub_1001CB60((int)&v33, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v21;
      _snprintf(&byte_1012A530[3072 * v21], 0x400u, &v33, a6);
      byte_1012A92E[v13] = 42;
      byte_1012A92F[v13] = 0;
      v19 = sub_1001CB60((int)&v33, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_1012A930[3072 * v21], 0x400u, &v33, a7);
      byte_1012AD2E[v13] = 42;
      byte_1012AD2F[v13] = 0;
      if ( v20 <= 9 )
      {
        v14 = &byte_1012AD30[v13];
        byte_1012AD30[v13] = 0;
      }
      else
      {
        v19 = sub_1001CB60((int)&v33, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_1012AD30[v13];
        _snprintf(&byte_1012AD30[v13], 0x400u, &v33, a8);
        byte_1012B12E[v13] = 42;
        byte_1012B12F[v13] = 0;
      }
      v22 = off_1008DA58[a2];
      v24 = a4;
      v25 = a5;
      v23 = a3;
      v28 = "sint64";
      v29 = &byte_1012A530[3072 * v21];
      v30 = &byte_1012A930[3072 * v21];
      v15 = off_1008DA50[a1];
      v26 = off_1008DA48[v18 != 0];
      v27 = v15;
      v31 = v14;
      if ( a9 )
      {
        v32 = a9;
        v20 = 11;
      }
      v16 = sub_10031170();
      sub_1001BFB0(7, (int)&v22, v20);
      if ( v19 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v29, v30) )
      {
        nullsub_1(a3, a4);
        sub_1001C0A0(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_10031180(v16);
      return v18;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v18 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_50;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_50:
        v18 = 0;
        v20 = 10;
      }
      else
      {
        v18 = 1;
        v20 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];

//----- (1001ED20) --------------------------------------------------------
bool __cdecl sub_1001ED20(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10019BA0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_37;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v17 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1001AB00() )
    v17 = v17 == 0;
  sub_1001CB60((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_1012A530[v12], 0x400u, &v31, a6);
  byte_1012A92E[v12] = 42;
  byte_1012A92F[v12] = 0;
  v18 = sub_1001CB60((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_1012A930[v12], 0x400u, &v31, a7);
  byte_1012AD2E[v12] = 42;
  byte_1012AD2F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1012AD30[v12];
    byte_1012AD30[v12] = 0;
  }
  else
  {
    v13 = &byte_1012AD30[v12];
    v18 = sub_1001CB60((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_1012AD30[v12], 0x400u, &v31, a8);
    byte_1012B12E[v12] = 42;
    byte_1012B12F[v12] = 0;
  }
  v20 = off_1008DA58[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_1012A530[v12];
  v21 = a3;
  v26 = "sint8";
  v28 = &byte_1012A930[v12];
  v29 = v13;
  v14 = off_1008DA50[a1];
  v24 = off_1008DA48[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10031170();
  sub_1001BFB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001C0A0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10031180(v15);
  return v17;
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];

//----- (1001F100) --------------------------------------------------------
bool __cdecl sub_1001F100(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10019BA0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1001AB00() )
    v17 = v17 == 0;
  sub_1001CB60((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_1012A530[v12], 0x400u, &v31, a6);
  byte_1012A92E[v12] = 42;
  byte_1012A92F[v12] = 0;
  v18 = sub_1001CB60((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_1012A930[v12], 0x400u, &v31, a7);
  byte_1012AD2E[v12] = 42;
  byte_1012AD2F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1012AD30[v12];
    byte_1012AD30[v12] = 0;
  }
  else
  {
    v18 = sub_1001CB60((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_1012AD30[v12];
    _snprintf(&byte_1012AD30[v12], 0x400u, &v31, a8);
    byte_1012B12E[v12] = 42;
    byte_1012B12F[v12] = 0;
  }
  v20 = off_1008DA58[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "long int";
  v27 = &byte_1012A530[v12];
  v28 = &byte_1012A930[v12];
  v29 = v13;
  v14 = off_1008DA48[v17 != 0];
  v25 = off_1008DA50[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10031170();
  sub_1001BFB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001C0A0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10031180(v15);
  return v17;
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];

//----- (1001F4C0) --------------------------------------------------------
bool __cdecl sub_1001F4C0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10019BA0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1001AB00() )
    v17 = v17 == 0;
  sub_1001CB60((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_1012A530[v12], 0x400u, &v31, a6);
  byte_1012A92E[v12] = 42;
  byte_1012A92F[v12] = 0;
  v18 = sub_1001CB60((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_1012A930[v12], 0x400u, &v31, a7);
  byte_1012AD2E[v12] = 42;
  byte_1012AD2F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1012AD30[v12];
    byte_1012AD30[v12] = 0;
  }
  else
  {
    v18 = sub_1001CB60((int)&v31, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_1012AD30[v12];
    _snprintf(&byte_1012AD30[v12], 0x400u, &v31, a8);
    byte_1012B12E[v12] = 42;
    byte_1012B12F[v12] = 0;
  }
  v20 = off_1008DA58[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned int";
  v29 = v13;
  v14 = off_1008DA48[v17 != 0];
  v25 = off_1008DA50[a1];
  v24 = v14;
  v27 = &byte_1012A530[v12];
  v28 = &byte_1012A930[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10031170();
  sub_1001BFB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001C0A0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10031180(v15);
  return v17;
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];

//----- (1001F860) --------------------------------------------------------
bool __cdecl sub_1001F860(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10019BA0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_37;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1001AB00() )
    v17 = v17 == 0;
  sub_1001CB60((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_1012A530[v12], 0x400u, &v31, a6);
  byte_1012A92E[v12] = 42;
  byte_1012A92F[v12] = 0;
  v18 = sub_1001CB60((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_1012A930[v12], 0x400u, &v31, a7);
  byte_1012AD2E[v12] = 42;
  byte_1012AD2F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1012AD30[v12];
    byte_1012AD30[v12] = 0;
  }
  else
  {
    v13 = &byte_1012AD30[v12];
    v18 = sub_1001CB60((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_1012AD30[v12], 0x400u, &v31, a8);
    byte_1012B12E[v12] = 42;
    byte_1012B12F[v12] = 0;
  }
  v20 = off_1008DA58[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_1012A530[v12];
  v21 = a3;
  v26 = "uint16";
  v28 = &byte_1012A930[v12];
  v29 = v13;
  v14 = off_1008DA50[a1];
  v24 = off_1008DA48[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10031170();
  sub_1001BFB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001C0A0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10031180(v15);
  return v17;
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];

//----- (1001FC60) --------------------------------------------------------
bool __cdecl sub_1001FC60(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10019BA0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1001AB00() )
    v17 = v17 == 0;
  sub_1001CB60((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_1012A530[v12], 0x400u, &v31, a6);
  byte_1012A92E[v12] = 42;
  byte_1012A92F[v12] = 0;
  v18 = sub_1001CB60((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_1012A930[v12], 0x400u, &v31, a7);
  byte_1012AD2E[v12] = 42;
  byte_1012AD2F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1012AD30[v12];
    byte_1012AD30[v12] = 0;
  }
  else
  {
    v18 = sub_1001CB60((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_1012AD30[v12];
    _snprintf(&byte_1012AD30[v12], 0x400u, &v31, a8);
    byte_1012B12E[v12] = 42;
    byte_1012B12F[v12] = 0;
  }
  v20 = off_1008DA58[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "uint32";
  v29 = v13;
  v14 = off_1008DA48[v17 != 0];
  v25 = off_1008DA50[a1];
  v24 = v14;
  v27 = &byte_1012A530[v12];
  v28 = &byte_1012A930[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10031170();
  sub_1001BFB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001C0A0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10031180(v15);
  return v17;
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];

//----- (10020000) --------------------------------------------------------
bool __cdecl sub_10020000(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  bool v19; // [sp+18h] [bp-64h]@3
  char v20; // [sp+27h] [bp-55h]@36
  unsigned int v21; // [sp+28h] [bp-54h]@1
  int v22; // [sp+2Ch] [bp-50h]@1
  char *v23; // [sp+2Ch] [bp-50h]@36
  char *v24; // [sp+40h] [bp-3Ch]@39
  int v25; // [sp+44h] [bp-38h]@39
  int v26; // [sp+48h] [bp-34h]@39
  int v27; // [sp+4Ch] [bp-30h]@39
  char *v28; // [sp+50h] [bp-2Ch]@39
  char *v29; // [sp+54h] [bp-28h]@39
  const char *v30; // [sp+58h] [bp-24h]@39
  const char *v31; // [sp+5Ch] [bp-20h]@39
  const char *v32; // [sp+60h] [bp-1Ch]@39
  char *v33; // [sp+64h] [bp-18h]@39
  int v34; // [sp+68h] [bp-14h]@40
  char v35; // [sp+6Ch] [bp-10h]@36

  v22 = sub_10019BA0();
  v21 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 1:
      v19 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v19 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
LABEL_34:
      if ( sub_1001AB00() )
        v19 = v19 == 0;
      sub_1001CB60((int)&v35, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v22;
      v14 = &byte_1012A530[3072 * v22];
      _snprintf(&byte_1012A530[3072 * v22], 0x400u, &v35, a6);
      byte_1012A92E[v13] = 42;
      byte_1012A92F[v13] = 0;
      v20 = sub_1001CB60((int)&v35, "%I64u", 6, 0xCu, (double)a7);
      v23 = &byte_1012A930[3072 * v22];
      _snprintf(&byte_1012A930[v13], 0x400u, &v35, a7);
      byte_1012AD2E[v13] = 42;
      byte_1012AD2F[v13] = 0;
      if ( v21 <= 9 )
      {
        v15 = &byte_1012AD30[v13];
        byte_1012AD30[v13] = 0;
      }
      else
      {
        v20 = sub_1001CB60((int)&v35, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_1012AD30[v13];
        _snprintf(&byte_1012AD30[v13], 0x400u, &v35, a8);
        byte_1012B12E[v13] = 42;
        byte_1012B12F[v13] = 0;
      }
      v24 = off_1008DA58[a2];
      v27 = a5;
      v26 = a4;
      v33 = v15;
      v25 = a3;
      v30 = "uint64";
      v31 = v14;
      v16 = off_1008DA50[a1];
      v28 = off_1008DA48[v19 != 0];
      v29 = v16;
      v32 = v23;
      if ( a9 )
      {
        v34 = a9;
        v21 = 11;
      }
      v17 = sub_10031170();
      sub_1001BFB0(7, (int)&v24, v21);
      if ( v20 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v31, v32) )
      {
        nullsub_1(a3, a4);
        sub_1001C0A0(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_10031180(v17);
      return v19;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_49;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_49:
        v19 = 0;
        v21 = 10;
      }
      else
      {
        v19 = 1;
        v21 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];

//----- (100205E0) --------------------------------------------------------
bool __cdecl sub_100205E0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10019BA0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_37;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1001AB00() )
    v17 = v17 == 0;
  sub_1001CB60((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_1012A530[v12], 0x400u, &v31, a6);
  byte_1012A92E[v12] = 42;
  byte_1012A92F[v12] = 0;
  v18 = sub_1001CB60((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_1012A930[v12], 0x400u, &v31, a7);
  byte_1012AD2E[v12] = 42;
  byte_1012AD2F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1012AD30[v12];
    byte_1012AD30[v12] = 0;
  }
  else
  {
    v13 = &byte_1012AD30[v12];
    v18 = sub_1001CB60((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_1012AD30[v12], 0x400u, &v31, a8);
    byte_1012B12E[v12] = 42;
    byte_1012B12F[v12] = 0;
  }
  v20 = off_1008DA58[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_1012A530[v12];
  v21 = a3;
  v26 = "uint8";
  v28 = &byte_1012A930[v12];
  v29 = v13;
  v14 = off_1008DA50[a1];
  v24 = off_1008DA48[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10031170();
  sub_1001BFB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001C0A0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10031180(v15);
  return v17;
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];

//----- (100209D0) --------------------------------------------------------
bool __cdecl sub_100209D0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10019BA0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1001AB00() )
    v17 = v17 == 0;
  sub_1001CB60((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_1012A530[v12], 0x400u, &v31, a6);
  byte_1012A92E[v12] = 42;
  byte_1012A92F[v12] = 0;
  v18 = sub_1001CB60((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_1012A930[v12], 0x400u, &v31, a7);
  byte_1012AD2E[v12] = 42;
  byte_1012AD2F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_1012AD30[v12];
    byte_1012AD30[v12] = 0;
  }
  else
  {
    v18 = sub_1001CB60((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_1012AD30[v12];
    _snprintf(&byte_1012AD30[v12], 0x400u, &v31, a8);
    byte_1012B12E[v12] = 42;
    byte_1012B12F[v12] = 0;
  }
  v20 = off_1008DA58[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned long int";
  v29 = v13;
  v14 = off_1008DA48[v17 != 0];
  v25 = off_1008DA50[a1];
  v24 = v14;
  v27 = &byte_1012A530[v12];
  v28 = &byte_1012A930[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10031170();
  sub_1001BFB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1001C0A0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10031180(v15);
  return v17;
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];

//----- (10020D70) --------------------------------------------------------
int sub_10020D70()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_10019BA0();
  sub_1001CAC0(1);
  sub_1001CE50(-1);
  result = sub_1001CDE0(-1);
  dword_1012E130[v0] = 0;
  return result;
}
// 1012E130: using guessed type int dword_1012E130[];

//----- (10020DA0) --------------------------------------------------------
BOOL __usercall sub_10020DA0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_10019BA0();
  sub_100311B0((int)&v13);
  sub_100311B0((int)&v14);
  sub_100311B0((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_10031E00((int (__cdecl *)(unsigned int))sub_1001CD40, v7, (int)&v13) )
  {
    if ( sub_10031E00((int (__cdecl *)(unsigned int))sub_1001CD40, a2, (int)&v14) )
    {
      v9 = sub_10031C70(
             dword_1013023C[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_1001CD40,
             (void (__cdecl *)(_DWORD))sub_1001CD60,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_100320A0((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_10031280((void (__cdecl *)(_DWORD))sub_1001CD60, (int)&v12);
  sub_10031280((void (__cdecl *)(_DWORD))sub_1001CD60, (int)&v13);
  sub_10031280((void (__cdecl *)(_DWORD))sub_1001CD60, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 1013023C: using guessed type int dword_1013023C[];

//----- (10020F10) --------------------------------------------------------
bool __usercall sub_10020F10@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_10019BA0();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_1001AB00() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_1001F4C0(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_1001AB00() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_1012A530[3072 * v24], 0x400u, "%s", v9);
  byte_1012A92E[v15] = 42;
  byte_1012A92F[v15] = 0;
  _snprintf(&byte_1012A930[3072 * v24], 0x400u, "%s", v22);
  v16 = off_1008DA58[a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_1012AD2E[v15] = 42;
  v17 = off_1008DA48[v14 != 0];
  v18 = off_1008DA50[a3];
  byte_1012AD2F[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_1012A530[3072 * v24];
  v34 = &byte_1012A930[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_10031170();
  sub_1001BFB0(7, (int)&v26, v19);
  sub_10031180(v20);
  return v14;
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];

//----- (10021180) --------------------------------------------------------
char __cdecl sub_10021180(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  unsigned int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_10019BA0();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_1013023C[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_10131858[v10];
  sub_1001C860(a3, 1, a6, 0x230u, &byte_10131858[v10]);
  v27 = &byte_1012E158[v10];
  sub_1001C860(a3, 2, a7, 0x230u, &byte_1012E158[v10]);
  v24 = &byte_1012F738[v10];
  sub_1001C860(a3, 3, a6, 0x230u, &byte_1012F738[v10]);
  v26 = &byte_10130250[v10];
  sub_1001C860(a3, 4, a7, 0x230u, &byte_10130250[v10]);
  _snprintf(&byte_10130D40[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_10130D40[v10];
  byte_10130F6F[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_1001C860(a3, 0, v25, 560 - (v11 - &byte_10130D40[v10 + 1]), &byte_10130D40[v10] + v11 - &byte_10130D40[v10 + 1]);
  v13 = &byte_10130D40[v10];
  byte_10130F6F[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_10130D3C[v10] + v13 - &byte_10130D40[v10 + 1]) = 0;
  sub_1001C860(a3, 1, (int)&byte_10130D40[v10], 0x230u, &byte_10129A40[v10]);
  sub_1001C860(a3, 1, (int)&byte_10130D40[v10], 0x230u, &byte_1012EC48[v10]);
  v15 = sub_10020DA0(v22, v27, v21, a2 == 1, (int)&byte_10129A40[v10], (const char **)&v22);
  if ( sub_1001AB00() )
    v15 = v15 == 0;
  v30 = off_1008DA58[a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_1008DA50[a1];
  v34 = off_1008DA48[v15 != 0];
  v17 = dword_1013023C[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_10031170();
  sub_1001BFB0(7, (int)&v30, v18);
  sub_10031180(v19);
  return v15;
}
// 1008DA48: using guessed type char *off_1008DA48[18];
// 1008DA50: using guessed type char *off_1008DA50[16];
// 1008DA58: using guessed type char *off_1008DA58[14];
// 1013023C: using guessed type int dword_1013023C[];

//----- (10021480) --------------------------------------------------------
bool __cdecl sub_10021480(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_1001DC60(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (10021530) --------------------------------------------------------
bool __cdecl sub_10021530(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_10020F10(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (10021570) --------------------------------------------------------
const char *__cdecl sub_10021570(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (100215B0) --------------------------------------------------------
char __cdecl sub_100215B0(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  char *v7; // eax@11
  int v8; // ecx@12
  int v9; // ST44_4@13
  bool v10; // zf@18
  signed int v11; // edx@24
  const char *v12; // eax@32
  _BYTE *v13; // eax@39
  int v14; // eax@44
  bool v15; // sf@44
  char v16; // cl@45
  char *v17; // eax@50
  int v18; // edx@52
  int v19; // edi@53
  unsigned int v20; // eax@53
  const char *v21; // ecx@53
  _DWORD *v22; // edx@53
  int v23; // esi@57
  int v24; // eax@58
  _BYTE *v25; // ecx@58
  _BYTE *v26; // edx@58
  int v27; // eax@60
  _BYTE *v28; // ecx@60
  _BYTE *v29; // edx@60
  _BYTE *v30; // ecx@62
  _BYTE *v31; // edx@62
  signed int v32; // eax@64
  signed int v33; // edi@73
  int v34; // esi@74
  int v35; // ecx@76
  int v36; // edx@82
  int v37; // eax@83
  int *v38; // eax@106
  void *v39; // ebx@106
  void *v40; // edi@109
  void *v41; // esi@112
  const char *v42; // eax@114
  int v43; // ST30_4@123
  const char *v44; // eax@142
  const char *v45; // eax@148
  char *v47; // [sp-14h] [bp-340h]@69
  char v48; // [sp+12h] [bp-31Ah]@24
  char v49; // [sp+13h] [bp-319h]@21
  signed int v50; // [sp+18h] [bp-314h]@52
  void *v51; // [sp+18h] [bp-314h]@94
  void *v52; // [sp+1Ch] [bp-310h]@97
  void *v53; // [sp+20h] [bp-30Ch]@103
  void *v54; // [sp+24h] [bp-308h]@45
  char v55[508]; // [sp+28h] [bp-304h]@11
  char v56; // [sp+224h] [bp-108h]@44
  char v57; // [sp+227h] [bp-105h]@11
  char v58; // [sp+228h] [bp-104h]@123
  char v59; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v4 = sub_10019BA0();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_10132350 + 580 * v4;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v5) = sub_1001C810((int)v6, 0);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1001C7C0((int)v6, "Resetting test status\r\n");
      return v5;
    case 1:
      LOBYTE(v5) = sub_1001C330((int)v6);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1001C7C0((int)v6, "Clearing test status\r\n");
      return v5;
    case 11:
      LOBYTE(v5) = sub_1001C810((int)v6, 0);
      return v5;
    case 4:
      sub_1001C1B0((int)v6, *a2);
      if ( v6[577] && !v6[578] )
      {
        v7 = sub_1001C4E0((char *)a2[1]);
        _snprintf(v55, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v7);
        v57 = 0;
        sub_1001C7C0((int)v6, v55);
      }
      LOBYTE(v5) = 0;
      v8 = (int)&v6[16 * *(_DWORD *)v6 + 4];
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      return v5;
    case 5:
      v9 = *a2;
      LOBYTE(v5) = sub_1001C1A0((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 6:
      LOBYTE(v5) = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8] = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4] = 0;
      v10 = v6[577] == 0;
      *((_DWORD *)v6 + 143) = 0;
      if ( !v10 && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1001C7C0((int)v6, v55);
      }
      return v5;
    case 7:
      v49 = sub_1001BBA0((int)a2, a3);
      if ( !v49 && !v6[577] )
        goto LABEL_83;
      if ( v6[578] )
        goto LABEL_81;
      v11 = 0;
      v48 = 0;
      if ( a3 > 7 )
        v11 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v11 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v11 += strlen((const char *)a2[3]);
      if ( v11 > 100 )
        v48 = 1;
      v12 = sub_10021570((int)v6, (unsigned __int8)v49);
      _snprintf(v55, 0x200u, "%s ", v12);
      v57 = 0;
      sub_1001C7C0((int)v6, v55);
      if ( a3 > 7 )
      {
        _snprintf(v55, 0x200u, " ACT: %-17s", a2[7]);
        v57 = 0;
        sub_1001C7C0((int)v6, v55);
        if ( v48 )
          sub_1001C7C0((int)v6, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v55, 0x200u, " EXP: %-17s", a2[8]);
        v57 = 0;
        sub_1001C7C0((int)v6, v55);
        if ( v48 )
          sub_1001C7C0((int)v6, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v13 = (_BYTE *)a2[9];
        if ( v13 )
        {
          if ( *v13 )
          {
            if ( memcmp((const void *)a2[9], &word_1005D108, 2u) )
            {
              _snprintf(v55, 0x200u, " TOL: %-17s", a2[9]);
              v57 = 0;
              sub_1001C7C0((int)v6, v55);
              if ( v48 )
                sub_1001C7C0((int)v6, "\r\n     ");
            }
          }
        }
      }
      v14 = _snprintf(v55, 0x1FCu, " %s", a2[3]);
      v15 = v14 < 0;
      v56 = 0;
      if ( v14 > 0 )
      {
        do
        {
          v16 = *((_BYTE *)&v54 + v14 + 3);
          if ( v16 != 10 && v16 != 13 )
            break;
          *((_BYTE *)&v54 + --v14 + 4) = 0;
        }
        while ( v14 > 0 );
        v15 = v14 < 0;
      }
      if ( !v15 )
      {
        v17 = &v55[v14];
        *(_WORD *)v17 = 2573;
        v17[2] = 0;
      }
      sub_1001C7C0((int)v6, v55);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v18 = 10;
      v50 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v19 = v3[v18];
        v20 = 6;
        v21 = "Info: ";
        v22 = (_DWORD *)v3[v18];
        do
        {
          if ( *v22 != *(_DWORD *)v21 )
            goto LABEL_57;
          v20 -= 4;
          v21 += 4;
          ++v22;
        }
        while ( v20 >= 4 );
        if ( !v20 )
          goto LABEL_67;
LABEL_57:
        v23 = *(_BYTE *)v22 - *v21;
        if ( *(_BYTE *)v22 == *v21 )
        {
          v24 = v20 - 1;
          v25 = v21 + 1;
          v26 = (char *)v22 + 1;
          if ( !v24
            || (v23 = *v26 - *v25, *v26 == *v25)
            && ((v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, !v27)
             || (v23 = *v29 - *v28, *v29 == *v28)
             && ((v30 = v28 + 1, v31 = v29 + 1, v27 == 1) || (v23 = *v31 - *v30, *v31 == *v30))) )
          {
            v3 = a2;
LABEL_67:
            v32 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v32 = 1;
        if ( v23 <= 0 )
          v32 = -1;
LABEL_68:
        if ( v32 )
        {
          _snprintf(v55, 0x200u, "      Post Analysis: %s\r\n", v19);
          v47 = v55;
        }
        else
        {
          _snprintf(v55, 0x200u, "      Compare Info: %s\r\n", v19 + 6);
          v47 = v55;
        }
        v57 = 0;
        sub_1001C7C0((int)v6, v47);
        v18 = v50++ + 1;
      }
      while ( v50 < (signed int)a3 );
LABEL_72:
      if ( v6[309] )
      {
        v33 = 0;
        if ( *((_DWORD *)v6 + 143) > 0 )
        {
          v34 = (int)(v6 + 336);
          do
          {
            if ( v33 >= 20 )
              break;
            v35 = *(_DWORD *)(v34 - 4);
            if ( *(_DWORD *)(v34 + 4) )
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v33, v35, *(_DWORD *)v34, *(_DWORD *)(v34 + 4));
            else
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s\r\n", v33, v35, *(_DWORD *)v34);
            v57 = 0;
            sub_1001C7C0((int)v6, v55);
            ++v33;
            v34 += 12;
          }
          while ( v33 < *((_DWORD *)v6 + 143) );
        }
        _snprintf(v55, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v57 = 0;
        sub_1001C7C0((int)v6, v55);
      }
LABEL_81:
      if ( v49 )
      {
        v36 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v36 + 4];
        v5 = (int)&v6[v36 + 4];
      }
      else
      {
LABEL_83:
        v37 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v37 + 8];
        v5 = (int)&v6[v37 + 8];
      }
      return v5;
    case 9:
      LOBYTE(v5) = sub_1001C410((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 3:
      LOBYTE(v5) = sub_1001BEC0((const void **)a2, a3);
      if ( !(_BYTE)v5 && !v6[578] )
      {
        if ( v6[577]
          || sub_1001BF80((const void **)a2, a3)
          || (LOBYTE(v5) = sub_1001BDD0((const void **)a2, a3), (_BYTE)v5) )
        {
          if ( a3 <= 8 )
            v51 = &unk_10058CA9;
          else
            v51 = (void *)a2[8];
          if ( a3 <= 7 )
            v52 = &unk_10058CA9;
          else
            v52 = (void *)a2[7];
          if ( a3 <= 6 )
            v54 = &unk_10058CA9;
          else
            v54 = (void *)a2[6];
          if ( a3 <= 5 )
            v53 = &unk_10058CA9;
          else
            v53 = (void *)a2[5];
          if ( a3 <= 4 )
          {
            v38 = a2;
            v39 = &unk_10058CA9;
          }
          else
          {
            v38 = a2;
            v39 = (void *)a2[4];
          }
          if ( a3 <= 3 )
            v40 = &unk_10058CA9;
          else
            v40 = (void *)v38[3];
          if ( a3 )
            v41 = (void *)*v38;
          else
            v41 = &unk_10058CA9;
          v10 = sub_1001BE90((const void **)a2, a3) == 0;
          v42 = (const char *)&unk_10058CA9;
          if ( v10 )
            v42 = "   ";
          _snprintf(v55, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v42, v41, v40, v39, v53, v54, v52, v51);
          v57 = 0;
          LOBYTE(v5) = (unsigned int)sub_1001C7C0((int)v6, v55);
        }
      }
      return v5;
    case 2:
      if ( v6[578] )
        return v5;
      if ( sub_1001BBD0((const void **)a2, a3) )
      {
        dword_10132348 = 2;
        sub_1001C7C0((int)v6, (const char *)&word_1008ED6C);
        sub_1001C7C0((int)v6, "   Command Format:\r\n");
        sub_1001C7C0(
          (int)v6,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_1001C7C0(
          (int)v6,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_1001C7C0(
          (int)v6,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_1001C7C0(
          (int)v6,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_1001C7C0((int)v6, "                                         strings depending upon the command\r\n");
        sub_1001C7C0((int)v6, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_1001C7C0(
          (int)v6,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_1001C7C0(
          (int)v6,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_1001C7C0((int)v6, (const char *)&word_1008ED6C);
        sub_1001C7C0((int)v6, "   Notes:\r\n");
        sub_1001C7C0((int)v6, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_1001C7C0((int)v6, (const char *)&word_1008ED6C);
        sub_1001C7C0(
          (int)v6,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_1001C7C0(
          (int)v6,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_1001C7C0(
          (int)v6,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_1001C7C0((int)v6, "       the suite name and the test case or test suite command.\r\n");
        sub_1001C7C0((int)v6, (const char *)&word_1008ED6C);
        sub_1001C7C0(
          (int)v6,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_1001C7C0(
          (int)v6,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_1001C7C0((int)v6, "       without a test suite name.\r\n");
        sub_1001C7C0((int)v6, (const char *)&word_1008ED6C);
        sub_1001C7C0((int)v6, "   Examples:\r\n");
        sub_1001C7C0(
          (int)v6,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_1001C7C0((int)v6, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_1001C7C0(
          (int)v6,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_1001C7C0(
          (int)v6,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_1001C7C0(
          (int)v6,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_1001C7C0(
          (int)v6,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_1001C7C0(
          (int)v6,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_1001C7C0(
          (int)v6,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_1001C7C0((int)v6, (const char *)&word_1008ED6C);
        sub_1001C7C0((int)v6, "   Command                                 Description\r\n");
        LOBYTE(v5) = (unsigned int)sub_1001C7C0(
                                     (int)v6,
                                     "   --------------------------------        --------------------------------\r\n");
        return v5;
      }
      if ( sub_1001BC60((const void **)a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_1001C7C0((int)v6, (const char *)&word_1008ED6C);
        return v5;
      }
      if ( sub_1001BC30((const void **)a2, a3) )
      {
        _snprintf(&v58, 0x100u, "%s %s", a2[3], a2[4]);
        v43 = a2[5];
        v59 = 0;
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_10132348,
          &unk_10058CA9,
          &v58,
          6 - dword_10132348,
          " ",
          v43);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1001C7C0((int)v6, v55);
        return v5;
      }
      if ( sub_1001BC90((const void **)a2, a3) )
      {
        LOBYTE(v5) = sub_1001BCC0((int)a2, a3);
        if ( (_BYTE)v5 )
        {
          dword_10132348 += 2;
          return v5;
        }
        if ( sub_1001BD00((int)a2, a3) )
        {
          LOBYTE(v5) = 2;
          if ( dword_10132348 < 2 )
            dword_10132348 = 0;
          else
            dword_10132348 -= 2;
          return v5;
        }
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_10132348,
          &unk_10058CA9,
          a2[2],
          6 - dword_10132348,
          " ",
          a2[2]);
LABEL_134:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1001C7C0((int)v6, v55);
        return v5;
      }
      if ( sub_1001BC00((const void **)a2, a3) )
      {
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_10132348,
          &unk_10058CA9,
          a2[3],
          6 - dword_10132348,
          " ",
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_1001BD70((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1001C7C0((int)v6, v55);
      }
      else if ( sub_1001BD40((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1001C7C0((int)v6, v55);
      }
      else
      {
        LOBYTE(v5) = (unsigned int)sub_1001C7C0((int)v6, "Unknown test help event\r\n");
      }
      return v5;
    case 8:
      if ( v6[577] && !v6[578] )
      {
        v44 = sub_10021570((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        _snprintf(v55, 0x200u, "\r\n   Test Case Results: %s\r\n", v44);
        v57 = 0;
        sub_1001C7C0((int)v6, v55);
        _snprintf(v55, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8]);
        v57 = 0;
        sub_1001C7C0((int)v6, v55);
        _snprintf(v55, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        v57 = 0;
        sub_1001C7C0((int)v6, v55);
      }
      v5 = (int)&v6[16 * *(_DWORD *)v6];
      if ( *(_DWORD *)(v5 + 4) )
        ++*(_DWORD *)(v5 + 12);
      else
        ++*(_DWORD *)(v5 + 16);
      return v5;
    case 10:
      if ( v6[577] && !v6[578] )
      {
        v45 = sub_10021570((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        _snprintf(v55, 0x200u, "\r\nTest Suite Results: %s\r\n", v45);
        v57 = 0;
        sub_1001C7C0((int)v6, v55);
        _snprintf(v55, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v6[16 * (*(_DWORD *)v6 + 1)]);
        v57 = 0;
        sub_1001C7C0((int)v6, v55);
        _snprintf(v55, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        v57 = 0;
        sub_1001C7C0((int)v6, v55);
      }
      LOBYTE(v5) = sub_1001C470((int)v6, 0);
      return v5;
    case 12:
      LOBYTE(v5) = sub_1001C740((int)v6, 0);
      return v5;
    case 13:
      if ( a3 >= 2 )
      {
        v5 = *((_DWORD *)v6 + 143);
        if ( v5 < 20 )
        {
          *(_DWORD *)&v6[12 * v5 + 332] = *a2;
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143) + 28)] = a2[1];
          v5 = 3 * *((_DWORD *)v6 + 143);
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143))++ + 340] = a2[2];
        }
      }
      return v5;
    case 14:
      --*((_DWORD *)v6 + 143);
      return v5;
    default:
      if ( !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1001C7C0((int)v6, "Unknown test event\r\n");
      return v5;
  }
}
// 1005D108: using guessed type __int16 word_1005D108;
// 1008ED6C: using guessed type __int16 word_1008ED6C;
// 10132348: using guessed type int dword_10132348;
// 100215B0: using guessed type char var_304[508];

//----- (10022360) --------------------------------------------------------
signed int __cdecl sub_10022360(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_10132350 + 580 * sub_10019BA0();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_1001C370(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (100223E0) --------------------------------------------------------
char **__cdecl sub_100223E0(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_10132350 + 580 * sub_10019BA0();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_1001C580((int)v1, a1, (int)".txt");
  return &off_1008E138;
}
// 1008E138: using guessed type char *off_1008E138;

//----- (10022420) --------------------------------------------------------
int (**sub_10022420())()
{
  return off_1008EE28;
}
// 1008EE28: using guessed type int (*off_1008EE28[2])();

//----- (10022430) --------------------------------------------------------
int (__cdecl *__cdecl sub_10022430(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_10019BA0();
  return sub_1001C7C0((int)&unk_10132EA8 + 1812 * v1, a1);
}

//----- (10022450) --------------------------------------------------------
const char *sub_10022450()
{
  return "See version control for test execution date";
}

//----- (10022460) --------------------------------------------------------
__int64 sub_10022460()
{
  return 0i64;
}

//----- (10022470) --------------------------------------------------------
const char *sub_10022470()
{
  return "Not Available";
}

//----- (10022480) --------------------------------------------------------
int __usercall sub_10022480@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (100224D0) --------------------------------------------------------
signed int __cdecl sub_100224D0(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10019BA0();
  return sub_1001C370(a1, a2, (int)&unk_10132EA8 + 1812 * v2);
}

//----- (10022620) --------------------------------------------------------
int __usercall sub_10022620@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  int v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_10039A90((int)&a2[151 * (*a2 + 1)], (int)sub_10022430, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_10022460();
  v4 = sub_10030880("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_10039EE0((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_10030880("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_10039EE0((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_10039EE0((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_10039E60((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_10039CF0((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_10030880("CFG_OutputTestRevision", (int)"False");
  if ( !sub_10019C50(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_10039F30((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_10039F30((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_10039E60((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_10039E60((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_10039F30((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_1001C4E0(v3);
  sub_10039F30((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_10039DE0((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_10030840(i, &v15, &v16); ++i )
  {
    sub_10039E60((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_10039F30((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_10039F30((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_10039DE0((int)&a2[151 * (*a2 + 1)]);
  }
  sub_10039DE0((int)&a2[151 * (*a2 + 1)]);
  sub_10039E60((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_10039CF0((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = (int)&a2[4 * *a2 + 1];
  *(_DWORD *)v14 = 0;
  *(_DWORD *)(v14 + 4) = 0;
  *(_DWORD *)(v14 + 8) = 0;
  *(_DWORD *)(v14 + 12) = 0;
  return result;
}
// 10022620: using guessed type char var_103[253];

//----- (100229A0) --------------------------------------------------------
char __cdecl sub_100229A0(int a1, const void **a2, unsigned int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  char *v5; // ebp@1
  const char *v6; // ebx@3
  int v7; // esi@4
  int v8; // ST14_4@5
  int v9; // eax@12
  const char *v10; // eax@13
  const char *v11; // eax@15
  int v12; // ST14_4@17
  int v13; // ecx@29
  const void *v14; // ST24_4@43
  int v15; // ST04_4@44
  _BYTE *v16; // eax@87
  _BYTE *v17; // eax@94
  _BYTE *v18; // eax@100
  int v19; // ST20_4@104
  unsigned int v20; // esi@105
  _DWORD *v21; // edx@106
  unsigned int v22; // eax@106
  const char *v23; // ecx@106
  int v24; // esi@110
  int v25; // eax@111
  _BYTE *v26; // ecx@111
  _BYTE *v27; // edx@111
  int v28; // eax@113
  _BYTE *v29; // ecx@113
  _BYTE *v30; // edx@113
  _BYTE *v31; // ecx@115
  _BYTE *v32; // edx@115
  bool v33; // zf@117
  bool v34; // sf@117
  signed int v35; // eax@117
  const char *v36; // eax@129
  const char *v37; // eax@131
  const char *v39; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v40; // [sp-Ch] [bp-120h]@73
  char v41; // [sp+9h] [bp-10Bh]@46
  char v42; // [sp+Ah] [bp-10Ah]@46
  char v43; // [sp+Bh] [bp-109h]@46
  const char *v44; // [sp+Ch] [bp-108h]@91
  signed int v45; // [sp+Ch] [bp-108h]@105
  char v46[255]; // [sp+10h] [bp-104h]@5
  char v47; // [sp+10Fh] [bp-5h]@44

  v3 = sub_10019BA0();
  LOBYTE(v4) = a1;
  v5 = (char *)&unk_10132EA8 + 1812 * v3;
  switch ( a1 )
  {
    case 3:
      if ( sub_1001BF20(a2, a3) )
      {
        v6 = (const char *)a2[3];
        do
        {
          v4 = sub_10022480(", \t", (int)v6);
          v7 = v4;
          if ( v4 )
          {
            strncpy(v46, v6, v4);
            v8 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
            v46[v7] = 0;
            sub_10039E60(v8, (int)"Req");
            sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"id", (unsigned __int8 *)v46);
            LOBYTE(v4) = (unsigned int)sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
            v6 += v7;
          }
          else
          {
            ++v6;
          }
        }
        while ( *v6 );
      }
      else if ( sub_1001BEF0(a2, a3) )
      {
        if ( sub_1001C680((int)v5, 3, 1, 0) )
          sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        v9 = *((_DWORD *)v5 + 146);
        if ( v9 > 0 )
        {
          *((_DWORD *)v5 + 146) = v9 - 1;
          sub_10039E60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
          v10 = "true";
          if ( *((_DWORD *)v5 + 144) <= 0 )
            v10 = "false";
          sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v10);
          v11 = "true";
          if ( *((_DWORD *)v5 + 145) <= 0 )
            v11 = "false";
          sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v11);
          sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          v12 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          *((_DWORD *)v5 + 144) = 0;
          *((_DWORD *)v5 + 145) = 0;
          sub_10039DE0(v12);
          sub_10039E60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        }
        LOBYTE(v4) = (unsigned int)sub_10039CF0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_1001BE30(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_10039F30(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 146);
      }
      else if ( sub_1001BF50(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_10039F30(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_1001BEC0(a2, a3) )
      {
        if ( sub_1001C680((int)v5, 3, 1, 0) )
          sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1001C5F0((int)a2, a3, (int)v5);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_10039E60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      }
      else if ( sub_1001BE60(a2, a3) )
      {
        sub_10039E60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Results");
        v13 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_10039CF0(v13, (int)"success", (unsigned __int8 *)&word_1005D108);
          sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_10039CF0(v13, (int)"success", (unsigned __int8 *)"1");
        }
        if ( v5[309] )
        {
          sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1001C680((int)v5, 3, 0, 0);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = (unsigned int)sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      else
      {
        LOBYTE(v4) = sub_1001BE00(a2, a3);
        if ( (_BYTE)v4 )
        {
          if ( !sub_1001C730((int)v5) )
            sub_10039E60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
          sub_10039F30((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v4) = sub_1001C680((int)v5, 3, 0, 1);
          if ( (_BYTE)v4 )
            LOBYTE(v4) = (unsigned int)sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      return v4;
    case 4:
      LOBYTE(v4) = sub_1001C1B0((int)v5, (int)*a2);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_10022620((char *)a2[1], v5, (int)*a2);
      return v4;
    case 5:
      v14 = *a2;
      LOBYTE(v4) = sub_1001C1A0((int)v5);
      if ( !(_BYTE)v4 )
      {
        sub_10039E60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        _snprintf(v46, 0x100u, "Test Group: %s", *a2);
        v15 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        v47 = 0;
        sub_10039F30(v15, (int)"Method", (unsigned __int8 *)v46);
        LOBYTE(v4) = (unsigned int)sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      return v4;
    case 6:
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      LOBYTE(v4) = sub_10039E60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
      return v4;
    case 7:
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v42 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v43 = 1;
LABEL_55:
        v41 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v5 + 146) )
      {
        sub_10039F30(
          (int)&v5[604 * (*(_DWORD *)v5 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_10039F30((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v5 + 146);
      }
      if ( !sub_1001C730((int)v5) )
        sub_10039E60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      if ( sub_1001BDA0((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_10039E60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction");
          sub_10039D90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (unsigned __int8 *)a2[3]);
          sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
        ++*((_DWORD *)v5 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_10039F30((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 144);
      }
      sub_10039E60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Compare");
      if ( sub_1001BBA0((int)a2, a3) )
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 4];
        sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 8];
        sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v41 )
      {
        sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v43 )
        {
          sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v40 = (unsigned __int8 *)"true";
        v39 = "strict";
      }
      else
      {
        v40 = (unsigned __int8 *)a2[6];
        v39 = "datatype";
      }
      sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)v39, v40);
LABEL_77:
      if ( v5[309] )
      {
        sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_10039E60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Actual");
        if ( v42 )
          sub_10039D40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v42 )
        {
          sub_10039E60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Expected");
          sub_10039D40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          if ( a3 > 9 )
          {
            v16 = a2[9];
            if ( v16 )
            {
              if ( *v16 )
              {
                sub_10039E60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Tolerance");
                sub_10039D40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v41 )
          {
            v44 = "!";
            if ( memcmp(*a2, "NE", 3u) )
              v44 = (const char *)&unk_10058CA9;
            if ( a3 > 9 && (v17 = a2[9]) != 0 && *v17 && memcmp(a2[9], &word_1005D108, 2u) )
              _snprintf(v46, 0x100u, "%s%s+/-%s", v44, a2[8], a2[9]);
            else
              _snprintf(v46, 0x100u, "%s%s", v44, a2[8]);
          }
          else if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 )
          {
            _snprintf(v46, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v46, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v19 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          v47 = 0;
          sub_10039E60(v19, (int)"Expected");
          sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)v46);
          sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      v20 = 10;
      v45 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_1001C680((int)v5, 8, 1, 0) )
        sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      sub_10039E60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
      v36 = "true";
      if ( *((_DWORD *)v5 + 144) <= 0 )
        v36 = "false";
      sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v36);
      v37 = "true";
      if ( *((_DWORD *)v5 + 145) <= 0 )
        v37 = "false";
      sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v37);
      sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      LOBYTE(v4) = (unsigned int)sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      return v4;
    case 9:
      LOBYTE(v4) = sub_1001C410((int)v5);
      return v4;
    case 10:
      LOBYTE(v4) = sub_1001C470((int)v5, (void (__cdecl *)(int))sub_10022500);
      return v4;
    case 0:
    case 11:
      sub_1001C810((int)v5, (void (__cdecl *)(int))sub_10022500);
      goto LABEL_139;
    case 1:
      sub_1001C330((int)v5);
      goto LABEL_139;
    case 12:
      sub_1001C740((int)v5, (void (__cdecl *)(int))sub_10022500);
LABEL_139:
      LOBYTE(v4) = 0;
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      return v4;
    default:
      return v4;
  }
  do
  {
    v21 = a2[v20];
    v22 = 6;
    v23 = "Info: ";
    do
    {
      if ( *v21 != *(_DWORD *)v23 )
        goto LABEL_110;
      v22 -= 4;
      v23 += 4;
      ++v21;
    }
    while ( v22 >= 4 );
    if ( !v22 )
      goto LABEL_120;
LABEL_110:
    v24 = *(_BYTE *)v21 - *v23;
    if ( *(_BYTE *)v21 == *v23 )
    {
      v25 = v22 - 1;
      v26 = v23 + 1;
      v27 = (char *)v21 + 1;
      if ( !v25
        || (v24 = *v27 - *v26, *v27 == *v26)
        && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
         || (v24 = *v30 - *v29, *v30 == *v29)
         && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
      {
        v20 = v45;
LABEL_120:
        v35 = 0;
        goto LABEL_121;
      }
    }
    v33 = v24 == 0;
    v34 = v24 < 0;
    v20 = v45;
    v35 = 1;
    if ( v34 || v33 )
      v35 = -1;
LABEL_121:
    if ( v35 )
    {
      sub_10039E60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"PostAnalysis");
      sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"note", (unsigned __int8 *)a2[v20]);
      sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    else
    {
      sub_10039E60((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"CompareInfo");
      sub_10039CF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v20] + 6);
      sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    v45 = ++v20;
  }
  while ( v20 < a3 );
LABEL_125:
  sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  LOBYTE(v4) = sub_1001C680((int)v5, 7, 0, 1);
  if ( (_BYTE)v4 )
    LOBYTE(v4) = (unsigned int)sub_10039DE0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  return v4;
}
// 10022500: using guessed type int sub_10022500();
// 1005D108: using guessed type __int16 word_1005D108;
// 100229A0: using guessed type char var_104[255];

//----- (100237C0) --------------------------------------------------------
char **__cdecl sub_100237C0(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_10132EA8 + 1812 * sub_10019BA0();
  *((_DWORD *)v1 + 146) = 0;
  sub_1001C580((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_10039A90(v2, (int)sub_10022430, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_1008EED8;
}
// 1008EED8: using guessed type char *off_1008EED8;

//----- (10023880) --------------------------------------------------------
char __thiscall sub_10023880(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_10135230 = sub_10011150(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_10135238, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_10135238;
  do
  {
    result = sub_10024950(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 10135230: using guessed type int dword_10135230;

//----- (100238F0) --------------------------------------------------------
char __usercall sub_100238F0@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_10016230(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_10016230(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (10023930) --------------------------------------------------------
void *__usercall sub_10023930@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_10135230 == 1379255385 )
    goto LABEL_4;
  v4 = sub_10004270(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_10135238 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_10024950(a1, (int)&unk_10135238 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy(a4, (char *)&unk_10135238 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2, (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_10135230 != 1379255385 )
    result = (void *)sub_10004240(v4, 86);
  return result;
}
// 10135230: using guessed type int dword_10135230;

//----- (100239D0) --------------------------------------------------------
char __cdecl sub_100239D0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_100238F0(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (10023A10) --------------------------------------------------------
bool __cdecl sub_10023A10(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_10023930(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (10023A70) --------------------------------------------------------
char __cdecl sub_10023A70(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_100238F0(a2, 1, a3, a1);
  return result;
}

//----- (10023AB0) --------------------------------------------------------
char __cdecl sub_10023AB0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_10023930(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10023AE0) --------------------------------------------------------
char __cdecl sub_10023AE0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_100238F0(a2 + 10, 1, a3, a1);
  return result;
}

//----- (10023B20) --------------------------------------------------------
char __cdecl sub_10023B20(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_10023930(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10023B60) --------------------------------------------------------
char __cdecl sub_10023B60(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_100238F0(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (10023BA0) --------------------------------------------------------
bool __cdecl sub_10023BA0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_10023930(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (10023BF0) --------------------------------------------------------
char __cdecl sub_10023BF0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_100238F0(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (10023C30) --------------------------------------------------------
bool __cdecl sub_10023C30(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_10023930(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (10023C70) --------------------------------------------------------
char __cdecl sub_10023C70(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_100238F0(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (10023CB0) --------------------------------------------------------
bool __cdecl sub_10023CB0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_10023930(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (10023CF0) --------------------------------------------------------
char __cdecl sub_10023CF0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_100238F0(1229, 1, a2, a1);
  return result;
}

//----- (10023D20) --------------------------------------------------------
char __cdecl sub_10023D20(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10023930(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (10023D50) --------------------------------------------------------
char __cdecl sub_10023D50(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_100238F0(1212, 16, a2, a1);
  return result;
}

//----- (10023D80) --------------------------------------------------------
char __cdecl sub_10023D80(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10023930(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10023DB0) --------------------------------------------------------
char __cdecl sub_10023DB0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_100238F0(2400, 65, a2, a1);
  return result;
}

//----- (10023DE0) --------------------------------------------------------
char __cdecl sub_10023DE0(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10023930(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10023E10) --------------------------------------------------------
char __cdecl sub_10023E10(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_100238F0(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (10023E50) --------------------------------------------------------
char __cdecl sub_10023E50(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_10003E50("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_10023930(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (10023EA0) --------------------------------------------------------
char __cdecl sub_10023EA0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_100238F0(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (10023EE0) --------------------------------------------------------
char __cdecl sub_10023EE0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_10023930(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (10023F10) --------------------------------------------------------
char __cdecl sub_10023F10(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_100238F0(22, 1, a2, a1);
  return result;
}

//----- (10023F40) --------------------------------------------------------
char __cdecl sub_10023F40(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_100238F0(832, 4, a2, a1);
  return result;
}

//----- (10023F70) --------------------------------------------------------
char __cdecl sub_10023F70(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10023930(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (10023FA0) --------------------------------------------------------
char __cdecl sub_10023FA0(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1003A050(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_10023E50(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10023E10(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_10023EE0(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10023EA0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_10023A10(v6, *(_BYTE *)a4, a5);
        else
          result = sub_100239D0(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_10023C30(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10023BF0(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_10023CB0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10023C70(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_10023AB0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10023A70(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_10023B20(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10023AE0(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_10023F10(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_10023D80(v6, a5);
        else
          result = sub_10023D50(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_10023BA0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10023B60(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10023DE0(v6, a5);
        else
          result = sub_10023DB0(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10023D20(v6, a5);
        else
          result = sub_10023CF0(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10023F70(v6, a5);
        else
          result = sub_10023F40(v6, a5);
        break;
      default:
        sub_10003E50("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 10004AC0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10024340) --------------------------------------------------------
bool __cdecl sub_10024340(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_10136778 != 1379255385 )
    {
      sub_10024930(a1, (int)&byte_10136780[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_10136785[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_10136784[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 10136778: using guessed type int dword_10136778;

//----- (100243B0) --------------------------------------------------------
bool __cdecl sub_100243B0(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_10136778 != 1379255385 )
      sub_10024930(a1, (int)&byte_10136780[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_10136794[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10136778: using guessed type int dword_10136778;
// 10136794: using guessed type int dword_10136794[];

//----- (10024410) --------------------------------------------------------
bool __cdecl sub_10024410(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_10136778 != 1379255385 )
    {
      sub_10024930(a1, (int)&byte_10136780[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_1013678C[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 10136778: using guessed type int dword_10136778;
// 1013678C: using guessed type int dword_1013678C[];

//----- (10024480) --------------------------------------------------------
char __cdecl sub_10024480(char a1, _BYTE *a2)
{
  if ( dword_10136778 != 1379255385 )
    sub_10024930(a1, (int)&byte_10136780[24 * (unsigned __int8)a1]);
  *a2 = byte_10136780[24 * (unsigned __int8)a1];
  return 1;
}
// 10136778: using guessed type int dword_10136778;

//----- (100244C0) --------------------------------------------------------
char __thiscall sub_100244C0(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_10136778 = sub_10011150(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_10136780, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_10136780;
  do
  {
    result = sub_10024930(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 10136778: using guessed type int dword_10136778;

//----- (10024530) --------------------------------------------------------
char __cdecl sub_10024530(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10011260(a1);
  v3 = sub_1004F6B0(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10024560) --------------------------------------------------------
char __cdecl sub_10024560(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10011260(a1);
  v3 = sub_1004F720(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10024590) --------------------------------------------------------
char __cdecl sub_10024590(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_10011350(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_10024410(v7, *a4, (int)a5);
      }
      else
      {
        sub_10003E50("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_10024340(v7, *a4, (int)a5);
      }
      else
      {
        sub_10003E50("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_100243B0(v7, *a4, (int)a5);
      }
      else
      {
        sub_10003E50("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_10024480(v7, a5);
      }
      else
      {
        sub_10003E50("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_10024560(v7, (int)a5);
      }
      else
      {
        sub_10003E50("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_10024530(v7, (int)a5);
      }
      else
      {
        sub_10003E50("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10003E50("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10024760) --------------------------------------------------------
int __cdecl sub_10024760(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101367C8 = *(_DWORD *)a1;
  dword_101367CC = *(_DWORD *)(a1 + 4);
  dword_101367D0 = *(_DWORD *)(a1 + 8);
  dword_101367D4 = *(_DWORD *)(a1 + 12);
  dword_101D8230 = (int)&dword_101367C8;
  return result;
}
// 101367C8: using guessed type int dword_101367C8;
// 101367CC: using guessed type int dword_101367CC;
// 101367D0: using guessed type int dword_101367D0;
// 101367D4: using guessed type int dword_101367D4;
// 101D8230: using guessed type int dword_101D8230;

//----- (100247A0) --------------------------------------------------------
signed int __cdecl sub_100247A0(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_1008FFE8;
    v6 = &unk_1008FFE8;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_10090000;
    v6 = &unk_10090000;
    v5 = &a1;
  }
  v3 = sub_10019830(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (10024800) --------------------------------------------------------
int __cdecl sub_10024800(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10019830(&a1, 1u, (int)&unk_10090048, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_1009004C[2 * v1];
  return result;
}
// 1009004C: using guessed type int dword_1009004C[];

//----- (10024840) --------------------------------------------------------
signed int __cdecl sub_10024840(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_10090058;
    v7 = &unk_10090058;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_10090070;
    v7 = &unk_10090070;
    v6 = &a1;
  }
  v4 = sub_10019830(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (100248B0) --------------------------------------------------------
int __cdecl sub_100248B0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10019830(&a1, 1u, (int)&unk_10090088, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_1009008C[2 * v1];
  return result;
}
// 1009008C: using guessed type int dword_1009008C[];

//----- (100248F0) --------------------------------------------------------
int __cdecl sub_100248F0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10019830(&a1, 1u, (int)&unk_100900A0, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100900A4[2 * v1];
  return result;
}
// 100900A4: using guessed type int dword_100900A4[];

//----- (10024930) --------------------------------------------------------
char __cdecl sub_10024930(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100247A0(a1, 11);
  return sub_100042F0(v2, a2, 24);
}

//----- (10024950) --------------------------------------------------------
char __cdecl sub_10024950(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10024800(a1);
  return sub_100042F0(v2, a2, 2720);
}

//----- (10024980) --------------------------------------------------------
char __cdecl sub_10024980(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_10024840(a1, 11, 1);
  sub_100042F0(v2, a2, 36);
  v3 = sub_10024840(a1, 11, 0);
  return sub_100042F0(v3, a2 + 36, 32);
}

//----- (100249D0) --------------------------------------------------------
char __cdecl sub_100249D0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100248B0(a1);
  return sub_100042F0(v2, a2, 2192);
}

//----- (10024A00) --------------------------------------------------------
char __cdecl sub_10024A00(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100248F0(a1);
  return sub_100042F0(v2, a2, 60);
}

//----- (10024A20) --------------------------------------------------------
char __cdecl sub_10024A20(int a1)
{
  return sub_100042F0(6453, a1, 5);
}

//----- (10024A40) --------------------------------------------------------
char __cdecl sub_10024A40(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_10014580(11);
  }
  else
  {
    result = sub_10014580(5);
  }
  return result;
}

//----- (10024A70) --------------------------------------------------------
char sub_10024A70()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_10016260(1, 1309, &v1) )
    sub_100269E0((int)&v1);
  return 0;
}

//----- (10024B10) --------------------------------------------------------
BOOL __cdecl sub_10024B10(int a1, int a2)
{
  return sub_100042D0(6455, a2, 252) == 0;
}

//----- (10024B30) --------------------------------------------------------
char __cdecl sub_10024B30(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10024B10(a1, a5);
  }
  else
  {
    result = sub_10024A70();
  }
  return result;
}

//----- (10024B70) --------------------------------------------------------
bool __cdecl sub_10024B70(void *a1)
{
  char v1; // cl@1

  v1 = sub_10016260(1, 1946, a1);
  *((_DWORD *)a1 + 1) /= 0x3E8u;
  return v1 && !sub_100268F0((int)a1);
}

//----- (10024BB0) --------------------------------------------------------
int __cdecl sub_10024BB0(char a1)
{
  int result; // eax@2
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 0;
  if ( a1 == 1 )
  {
    sub_10004370(10026, (int)&v2, 4);
    result = v2;
  }
  else
  {
    sub_10004370(10027, (int)&v2, 4);
    result = v2;
  }
  return result;
}

//----- (10024C30) --------------------------------------------------------
char __cdecl sub_10024C30(int a1)
{
  int v2; // [sp+0h] [bp-Ch]@1
  char v3; // [sp+4h] [bp-8h]@1

  v2 = 1000 * a1;
  v3 = 2;
  sub_10015D90(1, 1671, &v2, 0, 8, 1);
  return sub_10015ED0(1, 0x687u, 0xFFFFFFF);
}

//----- (10024C90) --------------------------------------------------------
char __cdecl sub_10024C90(char a1)
{
  sub_10015D90(1, 1672, &a1, 0, 1, 1);
  return sub_10015ED0(1, 0x688u, 0xFFFFFFF);
}

//----- (10024CC0) --------------------------------------------------------
char __cdecl sub_10024CC0(char a1, int a2)
{
  int v2; // eax@2

  if ( a1 == 1 )
  {
    v2 = sub_100043A0(10026, (int)&a2, 4);
    if ( !v2 )
      LOBYTE(v2) = sub_10024C30(a2);
  }
  else
  {
    LOBYTE(v2) = sub_100043A0(10027, (int)&a2, 4);
  }
  return v2;
}

//----- (10024D00) --------------------------------------------------------
char __cdecl sub_10024D00(char a1)
{
  int v1; // eax@1

  v1 = sub_100043A0(10028, (int)&a1, 1);
  if ( !v1 )
    LOBYTE(v1) = sub_10024C90(a1);
  return v1;
}

//----- (10024D30) --------------------------------------------------------
int __cdecl sub_10024D30(int a1)
{
  double v1; // ST0C_8@2
  double v2; // st6@4
  double v3; // st7@4
  double v4; // ST0C_8@7
  double v5; // rt2@8
  double v6; // st6@8
  double v7; // st7@8
  double v8; // st7@14
  double v9; // st7@18
  int result; // eax@18

  if ( a1 )
  {
    v1 = *(double *)a1;
    if ( (HIDWORD(v1) & 0x7FF00000) == 2146435072 || *(double *)a1 > 6.2831853071796 )
    {
      *(double *)a1 = 6.2831853071796;
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
    }
    else
    {
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
      if ( *(double *)a1 < -6.2831853071796 )
        *(double *)a1 = -6.2831853071796;
    }
    v4 = *(double *)(a1 + 8);
    if ( (HIDWORD(v4) & 0x7FF00000) == 2146435072 )
    {
      *(double *)(a1 + 8) = v3;
    }
    else
    {
      v5 = v2;
      v6 = v3;
      v7 = v5;
      if ( v6 < *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v6;
      }
      else if ( v7 > *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v7;
      }
    }
    if ( *(double *)a1 <= 1.5707963267949 )
    {
      if ( *(double *)a1 >= -1.5707963267949 )
      {
LABEL_18:
        v9 = *(double *)(a1 + 8);
        result = sub_1003C940(v9);
        *(double *)(a1 + 8) = v9;
        return result;
      }
      *(double *)a1 = -3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    else
    {
      *(double *)a1 = 3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    *(double *)(a1 + 8) = v8;
    goto LABEL_18;
  }
  return result;
}

//----- (10024E30) --------------------------------------------------------
signed int __cdecl sub_10024E30(int a1, int a2)
{
  signed int result; // eax@2

  if ( a1 )
  {
    if ( (COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
      || (COERCE_UNSIGNED_INT(*(float *)(a1 + 4)) & 0x7F800000) == 2139095040
      || *(float *)a1 >= 1.570796370506287
      || *(float *)a1 < -1.570796370506287
      || *(float *)(a1 + 4) >= 3.141592741012573
      || *(float *)(a1 + 4) < -3.141592741012573 )
    {
      if ( a2 )
      {
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
      }
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10024ED0) --------------------------------------------------------
char __cdecl sub_10024ED0(char a1)
{
  char result; // al@1

  result = sub_1003A840();
  if ( result == 2 )
    result = byte_10093204[8 * sub_10019830(&a1, 4u, (int)&unk_10093200, 8, 7, 7)];
  return result;
}

//----- (10024F00) --------------------------------------------------------
char __thiscall sub_10024F00(void *this)
{
  char v1; // al@1

  v1 = sub_10015220(this);
  return sub_10024ED0(v1);
}

//----- (10024F10) --------------------------------------------------------
char __thiscall sub_10024F10(void *this)
{
  int v1; // eax@1
  char result; // al@3

  v1 = sub_10015220(this) - 2;
  if ( v1 )
  {
    if ( v1 == 2 )
      result = 2;
    else
      result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10024F30) --------------------------------------------------------
_DWORD *__usercall sub_10024F30@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4)
{
  _DWORD *result; // eax@1

  sub_1003A850(a2, a1);
  result = (_DWORD *)sub_10012550(a3, a4);
  if ( (_BYTE)result )
    result = sub_10001750(a2);
  return result;
}

//----- (10025010) --------------------------------------------------------
char __cdecl sub_10025010(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  void *v4; // ecx@2
  int v5; // eax@3
  int v6; // eax@5
  char v7; // al@4
  int v8; // ecx@14
  char v9; // al@17
  char *v10; // eax@22
  char v12; // [sp+4h] [bp-10h]@20
  char v13; // [sp+8h] [bp-Ch]@11
  char v14; // [sp+Ch] [bp-8h]@18
  char v15; // [sp+10h] [bp-4h]@15
  char v16; // [sp+1Ch] [bp+8h]@3

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 52);
  if ( *(_WORD *)v3 != -32696 )
    return v3;
  v4 = (void *)*(_WORD *)(v3 + 10);
  if ( (unsigned __int16)v4 & 0xC000 )
    return v3;
  v5 = *(_DWORD *)(v3 + 4);
  v16 = -1;
  if ( v5 )
  {
    v7 = sub_10011D00(*(int (__cdecl **)(int))(v5 + 8));
LABEL_7:
    v16 = v7;
    goto LABEL_8;
  }
  v6 = *(_DWORD *)(v2 + 48);
  if ( v6 )
  {
    v7 = sub_10011D00(*(int (__cdecl **)(int))(v6 + 8));
    goto LABEL_7;
  }
LABEL_8:
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 1 )
    goto LABEL_26;
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 2 )
  {
    v13 = 8;
    goto LABEL_14;
  }
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 4 )
  {
LABEL_26:
    v13 = 7;
    goto LABEL_14;
  }
  v13 = sub_10024F10(v4);
LABEL_14:
  v8 = *(_DWORD *)(v2 + 52);
  if ( *(_WORD *)(v8 + 10) == 0x2000 )
    v15 = *(_BYTE *)(v8 + 14) - 92;
  else
    v15 = *(_BYTE *)(v8 + 10);
  v9 = *(_BYTE *)(v8 + 8);
  if ( v9 >= 0 )
  {
    v14 = 0;
  }
  else
  {
    v14 = 1;
    v9 = -v9;
  }
  v12 = v9;
  if ( *(_WORD *)(v8 + 12) )
    v12 = v9 * *(_BYTE *)(v8 + 12);
  v10 = sub_10011D30(v16);
  LOBYTE(v3) = sub_1003A870(v13, v16, v15, v12, v14, *(_DWORD *)(v2 + 64), 0, 0, v10);
  return v3;
}

//----- (10025110) --------------------------------------------------------
_DWORD *sub_10025110()
{
  char v1; // [sp+4h] [bp-104h]@1

  sub_10004370(6463, (int)&v1, 256);
  sub_10024F30((int)sub_10024FC0, (int)&unk_101367E8, &v1, "PAGE_INIT");
  sub_10024F30((int)sub_10024F60, (int)&unk_101367D8, &v1, "PAGE_SET_FOCUS");
  return sub_10024F30((int)sub_10025010, (int)&unk_101367E0, &v1, "KEY_PRESS");
}
// 10024F60: using guessed type int sub_10024F60();
// 10024FC0: using guessed type int sub_10024FC0();

//----- (100251A0) --------------------------------------------------------
double __cdecl sub_100251A0(int a1)
{
  double v1; // st6@1

  v1 = (double)(unsigned int)((*(int (**)(void))(dword_101D8230 + 8))() - a1);
  return (float)(1.0 / (double)(*(int (**)(void))(dword_101D8230 + 12))() * v1);
}
// 101D8230: using guessed type int dword_101D8230;

//----- (100251F0) --------------------------------------------------------
signed int __cdecl sub_100251F0(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (10025240) --------------------------------------------------------
int __cdecl sub_10025240(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10025330) --------------------------------------------------------
unsigned int __cdecl sub_10025330(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10025380) --------------------------------------------------------
unsigned int __cdecl sub_10025380(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (10025440) --------------------------------------------------------
unsigned int __cdecl sub_10025440(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_10011BA0(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (100254A0) --------------------------------------------------------
int __cdecl sub_100254A0(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (100254F0) --------------------------------------------------------
int __cdecl sub_100254F0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10025590) --------------------------------------------------------
int __cdecl sub_10025590(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (10025640) --------------------------------------------------------
int __cdecl sub_10025640(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 1004F7C0: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (100256B0) --------------------------------------------------------
bool __cdecl sub_100256B0(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_10011500(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_100952C8[(unsigned __int8)v4](v3) )
    {
      sub_10025640((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_10019B30(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_10015720(2) )
    result = 0;
  else
    result = sub_10016260(2, v5, a2) == 1 && !sub_100307D0(a2);
  return result;
}
// 100952C8: using guessed type int (__cdecl *off_100952C8[3])(char);

//----- (10025770) --------------------------------------------------------
char __cdecl sub_10025770(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_100256B0(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_10019B10(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (10025830) --------------------------------------------------------
unsigned int __cdecl sub_10025830(char *a1)
{
  return sub_10025330(a1, -100, 100, 0, 0);
}

//----- (10025850) --------------------------------------------------------
int __cdecl sub_10025850(unsigned __int8 *a1)
{
  return sub_100254A0(a1, 0, 2u, 0, 0);
}

//----- (10025870) --------------------------------------------------------
int __cdecl sub_10025870(_BYTE *a1)
{
  return sub_10025590(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (10025890) --------------------------------------------------------
int __cdecl sub_10025890(unsigned __int8 *a1)
{
  return sub_100254A0(a1, 0, 1u, 1u, 0);
}

//----- (100258B0) --------------------------------------------------------
unsigned int __cdecl sub_100258B0(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_100251F0((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_100254A0((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_100251F0((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025330((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100254A0((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100254A0((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025330((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10025BE0) --------------------------------------------------------
unsigned int __cdecl sub_10025BE0(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_100251F0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025330((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025330((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025330((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025330((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025330((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025330((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025330((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025330((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025330((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025330((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025330((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025330((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100251F0((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10025330((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10026020) --------------------------------------------------------
int __cdecl sub_10026020(unsigned __int8 *a1)
{
  return sub_100254A0(a1, 0, 7u, 7u, 0);
}

//----- (10026040) --------------------------------------------------------
int __cdecl sub_10026040(unsigned __int8 *a1)
{
  return sub_100254A0(a1, 0, 0x7Fu, 0x7Fu, 0);
}

//----- (10026060) --------------------------------------------------------
int __cdecl sub_10026060(int a1)
{
  int result; // eax@1

  result = sub_10026020((unsigned __int8 *)a1);
  if ( !result )
  {
    result = sub_10026020((unsigned __int8 *)(a1 + 1));
    if ( !result )
      result = sub_10026040((unsigned __int8 *)(a1 + 2));
  }
  return result;
}

//----- (10026090) --------------------------------------------------------
unsigned int __cdecl sub_10026090(_BYTE *a1)
{
  return sub_10025380(a1, -1, 5, -1, 0);
}

//----- (100260B0) --------------------------------------------------------
int __cdecl sub_100260B0(unsigned __int8 *a1)
{
  return sub_100254A0(a1, 0, 5u, 0, 0);
}

//----- (100260D0) --------------------------------------------------------
int __cdecl sub_100260D0(unsigned __int8 *a1)
{
  return sub_100254A0(a1, 0, 4u, 2u, 0);
}

//----- (100260F0) --------------------------------------------------------
int __cdecl sub_100260F0(_BYTE *a1)
{
  return sub_10025590(a1, 0, 2u, 0, 0);
}

//----- (10026110) --------------------------------------------------------
int __cdecl sub_10026110(int a1)
{
  return sub_10025240(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (10026160) --------------------------------------------------------
int __cdecl sub_10026160(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_10026110((int)(a1 + 4));
  if ( !result )
    result = sub_100260D0(a1);
  return result;
}

//----- (10026180) --------------------------------------------------------
int __cdecl sub_10026180(int a1)
{
  int result; // eax@1

  result = sub_100260B0((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_100260B0((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_100260B0((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_10030710((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_100251F0((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_100251F0((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_100251F0((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_100251F0((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10026210) --------------------------------------------------------
unsigned int __cdecl sub_10026210(int a1)
{
  unsigned int result; // eax@1

  result = sub_10026090((_BYTE *)a1);
  if ( !result )
    result = sub_10026090((_BYTE *)(a1 + 4));
  return result;
}

//----- (10026230) --------------------------------------------------------
signed int __cdecl sub_10026230(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_100251F0((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_100251F0((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (10026280) --------------------------------------------------------
unsigned int __cdecl sub_10026280(int a1)
{
  unsigned int result; // eax@1

  result = sub_10026090((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10026090((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_10026090((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_10026090((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_100251F0((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (100262E0) --------------------------------------------------------
int __cdecl sub_100262E0(_BYTE *a1)
{
  return sub_10025590(a1, 0, 0x20u, 2u, 0);
}

//----- (10026300) --------------------------------------------------------
unsigned int __cdecl sub_10026300(_BYTE *a1)
{
  return sub_10025380(a1, -1, 4, -1, 0);
}

//----- (10026320) --------------------------------------------------------
int __cdecl sub_10026320(unsigned __int8 *a1)
{
  return sub_100254A0(a1, 0, 9u, 0, 0);
}

//----- (10026340) --------------------------------------------------------
int __cdecl sub_10026340(_BYTE *a1)
{
  return sub_10025590(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (10026360) --------------------------------------------------------
signed int __cdecl sub_10026360(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10025590(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10026390) --------------------------------------------------------
int __cdecl sub_10026390(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_100254F0(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100263D0) --------------------------------------------------------
int __cdecl sub_100263D0(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_10026360((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_10026390((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10026390((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100174B0((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10026390((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10026460) --------------------------------------------------------
int __cdecl sub_10026460(int a1)
{
  int result; // eax@1

  result = sub_100254A0((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_100254A0((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (10026490) --------------------------------------------------------
int __cdecl sub_10026490(unsigned __int8 *a1)
{
  return sub_100254A0(a1, 0, 3u, 1u, 0);
}

//----- (100264B0) --------------------------------------------------------
unsigned int __cdecl sub_100264B0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10025380((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_10025380((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (100264E0) --------------------------------------------------------
int __cdecl sub_100264E0(int a1)
{
  int result; // eax@1

  result = sub_10025240(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_10025240(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_10025240(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_10025240(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_10025240(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (100265D0) --------------------------------------------------------
int __cdecl sub_100265D0(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_100251F0((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_100254A0((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_100264B0(a1 + 36);
        if ( !result )
        {
          result = sub_10025240(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_100264E0(a1 + 8);
            if ( !result )
            {
              result = sub_100264B0(a1 + 28);
              if ( !result )
              {
                result = sub_100254F0((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_10025850((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_10026460(a1 + 57);
                    if ( !result )
                    {
                      result = sub_100251F0((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_10026490((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (100266E0) --------------------------------------------------------
signed int __cdecl sub_100266E0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_100254F0(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10026710) --------------------------------------------------------
signed int __cdecl sub_10026710(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_100254A0(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10026740) --------------------------------------------------------
int __cdecl sub_10026740(unsigned __int8 *a1)
{
  return sub_100254A0(a1, 0, 0x64u, 0x64u, 0);
}

//----- (100267A0) --------------------------------------------------------
int __cdecl sub_100267A0(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_100251F0((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_10026740((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (100267B0) --------------------------------------------------------
signed int __cdecl sub_100267B0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10025590(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100267E0) --------------------------------------------------------
int __cdecl sub_100267E0(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_100254A0((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_100254A0((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (10026860) --------------------------------------------------------
unsigned int __cdecl sub_10026860(int a1)
{
  unsigned int result; // eax@1

  result = sub_10025830((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_10025830((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_10025830((char *)a1);
      if ( !result )
        result = sub_10025830((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (100268A0) --------------------------------------------------------
unsigned int __cdecl sub_100268A0(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_10026860(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_10025850((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_10025890((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (100268F0) --------------------------------------------------------
int __cdecl sub_100268F0(int a1)
{
  int result; // eax@1

  result = sub_10025870((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_100254F0((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (10026920) --------------------------------------------------------
int __cdecl sub_10026920(int a1)
{
  int result; // eax@1

  result = sub_100260F0((_BYTE *)a1);
  if ( !result )
    result = sub_10026340((_BYTE *)(a1 + 4));
  return result;
}

//----- (10026950) --------------------------------------------------------
unsigned int __cdecl sub_10026950(int a1)
{
  unsigned int result; // eax@1

  result = sub_10026090((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10026090((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_10026300((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (10026980) --------------------------------------------------------
unsigned int __cdecl sub_10026980(int a1)
{
  unsigned int result; // eax@1

  result = sub_10026090((_BYTE *)a1);
  if ( !result )
    result = sub_10026320((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (100269A0) --------------------------------------------------------
unsigned int __cdecl sub_100269A0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10026090((_BYTE *)a1);
  if ( !result )
  {
    result = sub_100254A0((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_10026300((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (100269E0) --------------------------------------------------------
void __cdecl __noreturn sub_100269E0(int a1)
{
  exit_1(a1 + 4);
}

//----- (10026B50) --------------------------------------------------------
signed int __cdecl sub_10026B50(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_10026710((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_100266E0((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_10026710((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (10026BB0) --------------------------------------------------------
signed int __usercall sub_10026BB0@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_10026B50(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_100254A0((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_100251F0((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_10025BE0(v2 + 5, a2);
    else
      result = sub_100258B0(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_100267B0((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (10026C80) --------------------------------------------------------
signed int __cdecl sub_10026C80(int a1)
{
  return sub_10026BB0(a1, 0);
}

//----- (10026C90) --------------------------------------------------------
char __cdecl sub_10026C90(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_10019830((_DWORD *)a2, 2u, (int)&unk_100961C8, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_100961CC[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_10004120(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_10003F80();
        sub_10011C70(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_10003E50("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 100961CC: using guessed type int dword_100961CC[];

//----- (10026DB0) --------------------------------------------------------
char __cdecl sub_10026DB0(int a1)
{
  return sub_10026C90(31, a1);
}

//----- (10026DC0) --------------------------------------------------------
int __cdecl sub_10026DC0(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= *(_WORD *)&word_1009647A[2 * *(_BYTE *)a1] );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - word_1009647A[2 * *(_BYTE *)a1];
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}

//----- (10026EB0) --------------------------------------------------------
__int16 __cdecl sub_10026EB0(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (10026F00) --------------------------------------------------------
__int16 __cdecl sub_10026F00(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_10026EB0((int)&v5, *a1);
  sub_10026DC0((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (10026F80) --------------------------------------------------------
signed int __usercall sub_10026F80@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_10097098[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_10096498[2 * (unsigned __int8)v68] ^ dword_10096898[2 * BYTE1(v65)] ^ dword_10096C98[2 * (unsigned __int8)(v66 >> 16)] ^ dword_10097098[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_10097098[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_10097098[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_10097098[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_10097098[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_10097098[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_10097098[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_10097098[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_10097098[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_10097498[(unsigned __int8)v57] ^ dword_10098098[v58 >> 24] ^ dword_10097898[BYTE1(v59)] ^ dword_10097C98[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_10097498[(unsigned __int8)v59] ^ dword_10097C98[(unsigned __int8)(v58 >> 16)] ^ dword_10098098[v57 >> 24] ^ dword_10097898[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_10097498[(unsigned __int8)v60] ^ dword_10097898[BYTE1(v58)] ^ dword_10097C98[(unsigned __int8)(v57 >> 16)] ^ dword_10098098[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_10097498[(unsigned __int8)v58] ^ dword_10097898[BYTE1(v57)] ^ dword_10097C98[(unsigned __int8)(v59 >> 16)] ^ dword_10098098[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_10097098[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_10097098[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_10097098[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_10097098[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_10097098[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_10096498[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_10096898[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_10096C98[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_10097098[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 10097498: using guessed type int dword_10097498[];
// 10097898: using guessed type int dword_10097898[];
// 10097C98: using guessed type int dword_10097C98[];
// 10098098: using guessed type int dword_10098098[];

//----- (10028030) --------------------------------------------------------
int __usercall sub_10028030@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_10026F80(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (10028090) --------------------------------------------------------
signed int __usercall sub_10028090@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_10098098[(unsigned __int8)v9] ^ dword_10097498[BYTE1(v9)] ^ dword_10097898[(unsigned __int8)(v9 >> 16)] ^ dword_10097C98[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_10098098[(unsigned __int8)v129] ^ dword_10097498[BYTE1(v129)] ^ dword_10097898[(unsigned __int8)(v129 >> 16)] ^ dword_10097C98[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_10098098[(unsigned __int8)v133] ^ dword_10097498[BYTE1(v133)] ^ dword_10097898[(unsigned __int8)(v133 >> 16)] ^ dword_10097C98[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_10098098[(unsigned __int8)v137] ^ dword_10097498[BYTE1(v137)] ^ dword_10097898[(unsigned __int8)(v137 >> 16)] ^ dword_10097C98[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_10098098[(unsigned __int8)v141] ^ dword_10097498[BYTE1(v141)] ^ dword_10097898[(unsigned __int8)(v141 >> 16)] ^ dword_10097C98[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_10098098[(unsigned __int8)v145] ^ dword_10097498[BYTE1(v145)] ^ dword_10097898[(unsigned __int8)(v145 >> 16)] ^ dword_10097C98[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_10098098[(unsigned __int8)v149] ^ dword_10097498[BYTE1(v149)] ^ dword_10097898[(unsigned __int8)(v149 >> 16)] ^ dword_10097C98[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_10098098[(unsigned __int8)v153] ^ dword_10097498[BYTE1(v153)] ^ dword_10097898[(unsigned __int8)(v153 >> 16)] ^ dword_10097C98[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_10098098[(unsigned __int8)v157] ^ dword_10097498[BYTE1(v157)] ^ dword_10097898[(unsigned __int8)(v157 >> 16)] ^ dword_10097C98[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_10098098[(unsigned __int8)v161] ^ dword_10097498[BYTE1(v161)] ^ dword_10097898[(unsigned __int8)(v161 >> 16)] ^ dword_10097C98[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_10098098[(unsigned __int8)v77] ^ dword_10097498[BYTE1(v77)] ^ dword_10097898[(unsigned __int8)(v77 >> 16)] ^ dword_10097C98[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_10098098[(unsigned __int8)v82] ^ dword_10097498[BYTE1(v82)] ^ dword_10097898[(unsigned __int8)(v82 >> 16)] ^ dword_10097C98[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_10098098[(unsigned __int8)v89] ^ dword_10097498[BYTE1(v89)] ^ dword_10097898[(unsigned __int8)(v89 >> 16)] ^ dword_10097C98[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_10098098[(unsigned __int8)v94] ^ dword_10097498[BYTE1(v94)] ^ dword_10097898[(unsigned __int8)(v94 >> 16)] ^ dword_10097C98[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_10098098[(unsigned __int8)v100] ^ dword_10097498[BYTE1(v100)] ^ dword_10097898[(unsigned __int8)(v100 >> 16)] ^ dword_10097C98[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_10098098[(unsigned __int8)v100] ^ dword_10097498[BYTE1(v100)] ^ dword_10097898[(unsigned __int8)(v100 >> 16)] ^ dword_10097C98[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_10098098[(unsigned __int8)v108] ^ dword_10097498[BYTE1(v108)] ^ dword_10097898[(unsigned __int8)(v108 >> 16)] ^ dword_10097C98[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_10098098[(unsigned __int8)v114] ^ dword_10097498[BYTE1(v114)] ^ dword_10097898[(unsigned __int8)(v114 >> 16)] ^ dword_10097C98[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_10098098[(unsigned __int8)v120] ^ dword_10097498[BYTE1(v120)] ^ dword_10097898[(unsigned __int8)(v120 >> 16)] ^ dword_10097C98[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_10098098[(unsigned __int8)v19] ^ dword_10097498[BYTE1(v19)] ^ dword_10097898[(unsigned __int8)(v19 >> 16)] ^ dword_10097C98[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_10097498[(unsigned __int8)v23] ^ dword_10097898[BYTE1(v23)] ^ dword_10097C98[(unsigned __int8)(v23 >> 16)] ^ dword_10098098[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_10098098[(unsigned __int8)v26] ^ dword_10097498[BYTE1(v26)] ^ dword_10097898[(unsigned __int8)(v26 >> 16)] ^ dword_10097C98[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_10097498[(unsigned __int8)v31] ^ dword_10097898[BYTE1(v31)] ^ dword_10097C98[(unsigned __int8)(v31 >> 16)] ^ dword_10098098[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_10098098[(unsigned __int8)v35] ^ dword_10097498[BYTE1(v35)] ^ dword_10097898[(unsigned __int8)(v35 >> 16)] ^ dword_10097C98[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_10097498[(unsigned __int8)v41] ^ dword_10097898[BYTE1(v41)] ^ dword_10097C98[(unsigned __int8)(v41 >> 16)] ^ dword_10098098[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_10098098[(unsigned __int8)v43] ^ dword_10097498[BYTE1(v43)] ^ dword_10097898[(unsigned __int8)(v43 >> 16)] ^ dword_10097C98[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_10097498[(unsigned __int8)v47] ^ dword_10097898[BYTE1(v47)] ^ dword_10097C98[(unsigned __int8)(v47 >> 16)] ^ dword_10098098[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_10098098[(unsigned __int8)v52] ^ dword_10097498[BYTE1(v52)] ^ dword_10097898[(unsigned __int8)(v52 >> 16)] ^ dword_10097C98[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_10097498[(unsigned __int8)v58] ^ dword_10097898[BYTE1(v58)] ^ dword_10097C98[(unsigned __int8)(v58 >> 16)] ^ dword_10098098[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_10098098[(unsigned __int8)v60] ^ dword_10097498[BYTE1(v60)] ^ dword_10097898[(unsigned __int8)(v60 >> 16)] ^ dword_10097C98[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_10097498[(unsigned __int8)v66] ^ dword_10097898[BYTE1(v66)] ^ dword_10097C98[(unsigned __int8)(v66 >> 16)] ^ dword_10098098[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_10098098[(unsigned __int8)v69] ^ dword_10097498[BYTE1(v69)] ^ dword_10097898[(unsigned __int8)(v69 >> 16)] ^ dword_10097C98[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 10097498: using guessed type int dword_10097498[];
// 10097898: using guessed type int dword_10097898[];
// 10097C98: using guessed type int dword_10097C98[];
// 10098098: using guessed type int dword_10098098[];

//----- (10028E10) --------------------------------------------------------
void *__usercall sub_10028E10@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (10028E30) --------------------------------------------------------
unsigned int __cdecl sub_10028E30(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_10003FF0();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 10004040: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (10028E90) --------------------------------------------------------
int __usercall sub_10028E90@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = 271733878;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (10028ED0) --------------------------------------------------------
int __usercall sub_10028ED0@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (1002A5F0) --------------------------------------------------------
unsigned int __usercall sub_1002A5F0@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_100984C0[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_100984D0[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_10028ED0(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_10028ED0(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 100984C0: using guessed type int dword_100984C0[];
// 100984D0: using guessed type int dword_100984D0[];

//----- (1002A6F0) --------------------------------------------------------
void *__usercall sub_1002A6F0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  int v3; // ebp@1
  size_t v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (int)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*(_DWORD *)(v3 + 4);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy((void *)(v5 + v3 + 28), v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_10028ED0(v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy((void *)(v5 + v3 + 28), v9, v4);
}

//----- (1002A770) --------------------------------------------------------
void *__usercall sub_1002A770@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_1002A5F0(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_10028E90(v3 + 64);
    result = sub_1002A6F0(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_1002A6F0(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (1002A810) --------------------------------------------------------
int __usercall sub_1002A810@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_1002A770(a1, 0, 0);
  sub_1002A5F0(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_10028E90(a1 + 64);
  sub_1002A6F0(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_1002A6F0(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_1002A5F0(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy((void *)a2, &v5, a3);
  return result;
}

//----- (1002A8D0) --------------------------------------------------------
int __usercall sub_1002A8D0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_10028E90(a2 + 64);
    sub_1002A6F0(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_1002A6F0(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (1002A930) --------------------------------------------------------
int __usercall sub_1002A930@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  int v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = (int)&a1[v1];
    memcpy(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy(&v19[v6], a1, 64 - v6);
    sub_10028ED0((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *(_DWORD *)(v8 + 4) = v9;
    v12 = v18;
    *(_DWORD *)(v8 + 8) = result;
    v1 += 20;
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(v8 + 16) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 1002A930: using guessed type char var_40[64];

//----- (1002A9F0) --------------------------------------------------------
int __usercall sub_1002A9F0@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_1002A930((char *)a1);
  return sub_1002A930(v8);
}

//----- (1002AAB0) --------------------------------------------------------
char __cdecl sub_1002AAB0(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_1002A770(a3 + 296, a2, a1);
    sub_10028030(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002AB00) --------------------------------------------------------
char __cdecl sub_1002AB00(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10028030(a3, (int)a1, a2);
    sub_1002A770(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002AB50) --------------------------------------------------------
bool __cdecl sub_1002AB50(int a1, int a2)
{
  if ( a2 )
    sub_1002A810(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (1002AB80) --------------------------------------------------------
int __usercall sub_1002AB80@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_10028E10(&v24);
  sub_1002A8D0(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_1002A770((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_1002A770((int)&v23, v12, (char *)&v31);
          sub_1002A810((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 1002AB80: using guessed type char var_14[16];

//----- (1002AD90) --------------------------------------------------------
int __usercall sub_1002AD90@<eax>(void *a1@<eax>, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1

  v2 = (int)a1;
  memset(a1, 0, 0x210u);
  *(_DWORD *)(v2 + 524) = a2;
  sub_1002A9F0(v2);
  v3 = 20;
  do
  {
    sub_1002A930((char *)v2);
    --v3;
  }
  while ( v3 );
  return sub_1002A9F0(v2);
}

//----- (1002ADE0) --------------------------------------------------------
char *__cdecl sub_1002ADE0(int a1, int a2)
{
  void *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = (char *)v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_1002A9F0(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (1002AE70) --------------------------------------------------------
signed int __cdecl sub_1002AE70(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_1002AB80(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_10028090(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_10028E10((void *)(a6 + 296));
      sub_1002A8D0(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 1002AE70: using guessed type char var_40[8];
// 1002AE70: using guessed type __int16 var_38[26];

//----- (1002AFA0) --------------------------------------------------------
bool __cdecl sub_1002AFA0(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_1002AD90(&v4, (int)sub_10028E30);
  if ( v2 )
    sub_1002ADE0(a2, (int)&v4);
  return v2;
}

//----- (1002B020) --------------------------------------------------------
BOOL __usercall sub_1002B020@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_10098CD8[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_10098BD8[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_10098AD8[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (1002B0C0) --------------------------------------------------------
int __usercall sub_1002B0C0@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (1002B150) --------------------------------------------------------
unsigned int __fastcall sub_1002B150(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (1002B170) --------------------------------------------------------
int __usercall sub_1002B170@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (1002B200) --------------------------------------------------------
int __usercall sub_1002B200@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_10098CD8[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_10098CD8[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_100984E0[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_10098DD8[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_10098BD8[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_10098AD8[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_10098568[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_10098E50[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 100984E0: using guessed type int dword_100984E0[];
// 10098568: using guessed type int dword_10098568[];
// 10098DD8: using guessed type int dword_10098DD8[];
// 10098E50: using guessed type int dword_10098E50[];

//----- (1002B680) --------------------------------------------------------
int __usercall sub_1002B680@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_1002B170(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (1002B730) --------------------------------------------------------
void *__usercall sub_1002B730@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (1002B790) --------------------------------------------------------
int __usercall sub_1002B790@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (1002B960) --------------------------------------------------------
signed int __usercall sub_1002B960@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_1002B150(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (1002B9E0) --------------------------------------------------------
_WORD *__fastcall sub_1002B9E0(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (1002BA50) --------------------------------------------------------
unsigned int __usercall sub_1002BA50@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (1002BC00) --------------------------------------------------------
unsigned int __usercall sub_1002BC00@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (1002BCD0) --------------------------------------------------------
int __usercall sub_1002BCD0@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (1002BD80) --------------------------------------------------------
int __usercall sub_1002BD80@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (1002BDC0) --------------------------------------------------------
unsigned int __usercall sub_1002BDC0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_1002DB90(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002BE20) --------------------------------------------------------
signed int __usercall sub_1002BE20@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (1002BF00) --------------------------------------------------------
int __usercall sub_1002BF00@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (1002C4A0) --------------------------------------------------------
int __usercall sub_1002C4A0@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_1002B0C0(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_1002B0C0(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_1002B0C0(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (1002C6E0) --------------------------------------------------------
int __usercall sub_1002C6E0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_1002B680(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_1002B680(a1, a3, a4);
  }
  return result;
}

//----- (1002C780) --------------------------------------------------------
signed int __usercall sub_1002C780@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_1002BCD0(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_1002BCD0(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_1002BCD0(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_1002B790(a1, a2);
  return sub_1002B960(a1, v16, v5);
}

//----- (1002C960) --------------------------------------------------------
unsigned int __usercall sub_1002C960@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_1002BDC0(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (1002CAA0) --------------------------------------------------------
int __usercall sub_1002CAA0@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_10098554[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_1002BF00(a1, a1 + 2936, a2 - 1);
  return sub_1002BF00(v24, v24 + 5228, a3 - 1);
}

//----- (1002CD50) --------------------------------------------------------
signed int __cdecl sub_1002CD50(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_1002BD80(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_1002BD80(v9, *(_WORD *)(a1 + 30));
      sub_1002BD80(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_1002DB90(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_1002B730(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_10098ED0 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_1002C4A0(v2);
    }
    else
    {
      sub_1002C6E0(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_1002B730(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_1002BD80(v2, *(_WORD *)(a1 + 30));
    sub_1002BD80(v13, *(_WORD *)(a1 + 28));
    sub_1002B730(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 10098ED0: using guessed type int (__cdecl *off_10098ED0)(int, int);

//----- (1002D010) --------------------------------------------------------
signed int __usercall sub_1002D010@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_1002BE20(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_1002BE20(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_1002C780(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_10098554[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_10098553[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_10098552[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_10098551[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (1002D0E0) --------------------------------------------------------
_WORD *__usercall sub_1002D0E0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_1002C780(a2, a2 + 5628);
  sub_1002C780(v4, v4 + 5640);
  v8 = sub_1002D010(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_1002C6E0(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_1002B200(v4, (int)&unk_100985E0, (int)&unk_10098A60);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_1002CAA0(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_1002B200(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_1002B9E0(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_1002B170(v4);
  return result;
}

//----- (1002D300) --------------------------------------------------------
signed int __cdecl sub_1002D300(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_1002C960(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_1002BA50(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_1002BC00(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_1002B020(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_1002B020(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_1002D0E0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_1002B730(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_1002D0E0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1002B730(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1002D610) --------------------------------------------------------
signed int __cdecl sub_1002D610(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_1002C960(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_1002BA50(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_1002BC00(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_1002B020(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_1002D0E0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_1002B730(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_1002B020(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_1002D0E0(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_1002B730(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_1002B020(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_1002D0E0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1002B730(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (1002DA20) --------------------------------------------------------
signed int __cdecl sub_1002DA20(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_1002C960(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_1002D0E0(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_1002B730(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_1002D0E0(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_1002B730(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_1002D0E0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1002B730(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1002DB90) --------------------------------------------------------
int __cdecl sub_1002DB90(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  int result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = v4 | (v5 << 16);
  }
  else
  {
    result = (int)(a2 + 1);
  }
  return result;
}

//----- (1002DC90) --------------------------------------------------------
signed int __cdecl sub_1002DC90(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1002DCB0) --------------------------------------------------------
signed int __usercall sub_1002DCB0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 1002DCB0: using guessed type int var_78[14];
// 1002DCB0: using guessed type int var_3C[15];

//----- (1002E150) --------------------------------------------------------
int (__cdecl *__usercall sub_1002E150@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (1002E1A0) --------------------------------------------------------
int __usercall sub_1002E1A0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (1002E1C0) --------------------------------------------------------
signed int __cdecl sub_1002E1C0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_100990B8[a1];
  v51 = dword_100990B8[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_100990B8[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_100990B8[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_100990B8[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_100990B8[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 100990B8: using guessed type int dword_100990B8[];

//----- (1002E570) --------------------------------------------------------
int __usercall sub_1002E570@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (1002E6B0) --------------------------------------------------------
signed int __usercall sub_1002E6B0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_1002DCB0(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (1002E700) --------------------------------------------------------
signed int __usercall sub_1002E700@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_1002DCB0(a7, a6, a4, 257, (int)&unk_10099150, (int)&unk_100991D0, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_1002DCB0(a8, &a6[a4], a5, 0, (int)&unk_10099250, (int)&unk_100992C8, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002E7A0) --------------------------------------------------------
int __usercall sub_1002E7A0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_10099340;
  *a4 = &unk_1009A340;
  return 0;
}

//----- (1002E7C0) --------------------------------------------------------
signed int __cdecl sub_1002E7C0(int a1)
{
  signed int result; // eax@2
  int v2; // ecx@3
  int v3; // esi@3

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    v3 = *(_DWORD *)(v2 + 20);
    *(_BYTE *)v2 = *(_DWORD *)(v2 + 12) != 0 ? 7 : 0;
    sub_1002E150(0, v3, a1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1002E7D0) --------------------------------------------------------
int __usercall sub_1002E7D0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_1002E1C0(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100990B8[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_100990B8[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100990B8[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_100990B8[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_1002E570(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_1002E570(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_1002E570(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_1002E570(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 100990B8: using guessed type int dword_100990B8[];

//----- (1002EE70) --------------------------------------------------------
int __usercall sub_1002EE70@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_1002E7A0(&v67, &v69, &v66, &v68);
          sub_1002E1A0(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_1002E570(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_10099100[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_10099100[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_1002E6B0(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_1002E700(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_1002E1A0(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_1002E7D0(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_1002E570(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_1002E570(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_1002E570(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_100990B8[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_100990B8[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_1002E570(v7, v3, v58);
}
// 100990B8: using guessed type int dword_100990B8[];
// 10099100: using guessed type int dword_10099100[];

//----- (1002F850) --------------------------------------------------------
signed int __usercall sub_1002F850@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_1002EE70(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_1002E150((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (1002FB80) --------------------------------------------------------
signed int __cdecl sub_1002FB80(int a1, int a2)
{
  return sub_1002F850(a1, a2);
}

//----- (1002FBA0) --------------------------------------------------------
bool __cdecl sub_1002FBA0(unsigned int a1)
{
  return a1 - 108100 <= 0xF0A && a1 / 0x64 & 1;
}

//----- (1002FBD0) --------------------------------------------------------
BOOL __cdecl sub_1002FBD0(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (1002FBE0) --------------------------------------------------------
BOOL __usercall sub_1002FBE0@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_1002FBD0(a1) && *v2 < 3u && a2 == 24;
}

//----- (1002FC10) --------------------------------------------------------
bool __cdecl sub_1002FC10(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_1002FBD0(a1) )
    {
      v6 = 10 * v5;
      if ( sub_10025770((unsigned __int8)byte_1009EC98[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_10016260(1, (unsigned __int16)word_1009EC90[v6], &Tm.tm_mon) || sub_100268A0((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_10019030(a1, &v15) || v15 != dword_1009ECB0[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_10016260(1, (unsigned __int16)word_1009EC94[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 1009EC90: using guessed type __int16 word_1009EC90[];
// 1009EC94: using guessed type __int16 word_1009EC94[];
// 1009ECB0: using guessed type int dword_1009ECB0[];

//----- (1002FDC0) --------------------------------------------------------
bool __cdecl sub_1002FDC0(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_1002FBD0(a1) )
    result = sub_100042D0((unsigned __int16)word_1009EC9A[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 1009EC9A: using guessed type __int16 word_1009EC9A[];

//----- (1002FE00) --------------------------------------------------------
char __cdecl sub_1002FE00(unsigned __int8 a1, char a2)
{
  char result; // al@1
  unsigned __int8 v3; // cl@1
  int v4; // esi@2

  result = sub_1002FBD0(a1);
  if ( result )
  {
    v4 = 5 * v3;
    sub_10015D90(1, (unsigned __int16)word_1009EC8A[10 * v3], &a2, 0, 1, 1);
    result = sub_10015ED0(1, word_1009EC8A[2 * v4], 0xFFFFFFF);
  }
  return result;
}
// 1009EC8A: using guessed type __int16 word_1009EC8A[];

//----- (1002FE50) --------------------------------------------------------
bool __cdecl sub_1002FE50(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_10018F80(a1);
  if ( !(unsigned __int8)sub_1002FBE0(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_1002FC10(v9, a3, *a4, (int)a5);
  if ( sub_10025770((unsigned __int8)byte_1009EC98[20 * v6], (bool *)&v8) && v8 && sub_1002FDC0(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 1002FE50: using guessed type int var_20[7];

//----- (1002FF40) --------------------------------------------------------
int __cdecl sub_1002FF40(unsigned __int16 a1)
{
  return dword_1009F2B0[a1];
}
// 1009F2B0: using guessed type int dword_1009F2B0[];

//----- (1002FF50) --------------------------------------------------------
char __cdecl sub_1002FF50(int a1, int a2, int a3, int a4, __int16 *a5)
{
  __int16 v5; // ax@1
  unsigned __int16 v6; // dx@4
  double v7; // st7@4
  int v8; // ST04_4@4
  double v9; // st7@4
  int v10; // eax@4
  char *v11; // edi@5
  const char *v12; // esi@6
  bool v13; // zf@97
  const char *v14; // ebx@98
  __int16 v15; // cx@98
  __int16 v16; // dx@98
  char v18; // [sp+1Eh] [bp-11Ah]@1
  char v19; // [sp+1Fh] [bp-119h]@1
  __int16 v20; // [sp+20h] [bp-118h]@98
  __int16 v21; // [sp+22h] [bp-116h]@98
  __int16 *v22; // [sp+24h] [bp-114h]@1
  int v23; // [sp+28h] [bp-110h]@1
  int v24; // [sp+2Ch] [bp-10Ch]@1
  int v25; // [sp+30h] [bp-108h]@98
  float v26; // [sp+34h] [bp-104h]@4
  char v27; // [sp+38h] [bp-100h]@4
  char *v28; // [sp+54h] [bp-E4h]@1
  int v29; // [sp+58h] [bp-E0h]@98
  int v30; // [sp+5Ch] [bp-DCh]@98
  char v31; // [sp+60h] [bp-D8h]@1
  char v32; // [sp+6Bh] [bp-CDh]@99

  v23 = a1;
  v22 = a5;
  v5 = *a5;
  v24 = a3;
  v19 = 1;
  v18 = 31;
  v28 = &v31;
  if ( v5 == -32648 || v5 == -32734 || v5 == -32704 )
  {
    v6 = *(_WORD *)a4;
    v7 = *(float *)(a4 + 4);
    qmemcpy(&v27, (const void *)(a4 + 8), 0x1Cu);
    *(float *)&v8 = v7;
    v9 = sub_10017DA0(v8, v6, *(_BYTE *)(a4 + 40), &v18);
    v10 = *(_WORD *)a4;
    v26 = v9;
    switch ( v10 )
    {
      case 0:
        v11 = &v31;
        if ( v18 == 21 )
          v12 = "\a_.__";
        else
          v12 = "\a_.__";
        goto LABEL_97;
      case 42:
      case 46:
        v12 = (const char *)&unk_1009F520;
        goto LABEL_96;
      case 1:
      case 45:
        v12 = (const char *)&unk_1009F5F0;
        goto LABEL_96;
      case 4:
        v12 = (const char *)&unk_1009F6C0;
        goto LABEL_96;
      case 5:
        v12 = (const char *)&unk_1009F790;
        goto LABEL_96;
      case 6:
      case 10:
      case 37:
        v12 = (const char *)&unk_1009F860;
        goto LABEL_96;
      case 11:
        v12 = (const char *)&unk_1009F930;
        goto LABEL_96;
      case 7:
      case 12:
      case 36:
        v12 = (const char *)&unk_1009FA00;
        goto LABEL_96;
      case 13:
        v12 = (const char *)&unk_1009FAD0;
        goto LABEL_96;
      case 8:
        v12 = (const char *)&unk_1009FBA0;
        goto LABEL_96;
      case 9:
        v12 = (const char *)&unk_1009FC70;
        goto LABEL_96;
      case 14:
        v11 = &v31;
        if ( v18 == 40 )
          v12 = (const char *)&unk_1009F860;
        else
          v12 = (const char *)&unk_1009FE10;
        goto LABEL_97;
      case 15:
        v11 = &v31;
        if ( v18 == 40 )
          v12 = (const char *)&unk_1009FA00;
        else
          v12 = (const char *)&unk_1009FEE0;
        goto LABEL_97;
      case 16:
        v11 = &v31;
        if ( v18 == 40 )
          v12 = (const char *)&unk_1009FD40;
        else
          v12 = (const char *)&unk_1009FFB0;
        goto LABEL_97;
      case 17:
        v11 = &v31;
        if ( v18 == 10 )
          v12 = (const char *)&unk_100A0080;
        else
          v12 = (const char *)&unk_100A02F0;
        goto LABEL_97;
      case 19:
        v11 = &v31;
        if ( v18 == 10 )
          v12 = (const char *)&unk_100A0150;
        else
          v12 = (const char *)&unk_100A03C0;
        goto LABEL_97;
      case 18:
        v11 = &v31;
        if ( v18 == 10 )
          v12 = (const char *)&unk_100A0220;
        else
          v12 = (const char *)&unk_100A0490;
        goto LABEL_97;
      case 20:
        v12 = (const char *)&unk_100A0560;
        goto LABEL_96;
      case 21:
        v12 = (const char *)&unk_100A0630;
        goto LABEL_96;
      case 22:
        v12 = (const char *)&unk_100A0700;
        goto LABEL_96;
      case 23:
        v12 = (const char *)&unk_100A07D0;
        goto LABEL_96;
      case 24:
        v12 = (const char *)&unk_100A08A0;
        goto LABEL_96;
      case 25:
        v12 = (const char *)&unk_100A0970;
        goto LABEL_96;
      case 43:
        v11 = &v31;
        switch ( v18 )
        {
          case 12:
            v12 = (const char *)&unk_100A0E50;
            break;
          case 21:
            v12 = (const char *)&unk_100A0FF0;
            break;
          case 30:
            v12 = (const char *)&unk_100A0B10;
            break;
          default:
            v12 = (const char *)&unk_100A1190;
            break;
        }
        goto LABEL_97;
      case 26:
      case 38:
        v11 = &v31;
        switch ( v18 )
        {
          case 12:
            v12 = (const char *)&unk_100A0BE0;
            break;
          case 21:
            v12 = (const char *)&unk_100A0F20;
            break;
          case 30:
            v12 = (const char *)&unk_100A0A40;
            break;
          default:
            v12 = (const char *)&unk_100A10C0;
            break;
        }
        goto LABEL_97;
      case 48:
        v12 = (const char *)&unk_100A0CB0;
        goto LABEL_96;
      case 49:
        v12 = (const char *)&unk_100A0D80;
        goto LABEL_96;
      case 27:
        v11 = &v31;
        if ( v18 == 28 )
          v12 = (const char *)&unk_100A1260;
        else
          v12 = (const char *)&unk_100A1400;
        goto LABEL_97;
      case 29:
        v11 = &v31;
        if ( v18 == 28 )
          v12 = (const char *)&unk_100A1330;
        else
          v12 = (const char *)&unk_100A14D0;
        goto LABEL_97;
      case 30:
        switch ( v18 )
        {
          case 0xD:
            v12 = (const char *)&unk_100A15A0;
            break;
          case 0x10:
            v12 = (const char *)&unk_100A1740;
            break;
          case 0x18:
            v12 = (const char *)&unk_100A1A80;
            break;
          default:
            v12 = (const char *)&unk_100A1C20;
            break;
          case 0x13:
            goto LABEL_95;
        }
        goto LABEL_96;
      case 31:
        switch ( v18 )
        {
          case 0xD:
            v12 = (const char *)&unk_100A1670;
            break;
          case 0x10:
            v12 = (const char *)&unk_100A1810;
            break;
          case 0x13:
            v12 = (const char *)&unk_100A19B0;
            break;
          case 0x18:
            v12 = (const char *)&unk_100A1B50;
            break;
          default:
            v12 = (const char *)&unk_100A1CF0;
            break;
        }
        goto LABEL_96;
      case 32:
        switch ( v18 )
        {
          case 0xE:
            v12 = (const char *)&unk_100A1DC0;
            break;
          case 0x11:
            v12 = (const char *)&unk_100A1F60;
            break;
          case 0x14:
            v12 = (const char *)&unk_100A2100;
            break;
          case 0x19:
            v12 = (const char *)&unk_100A22A0;
            break;
          default:
            v12 = (const char *)&unk_100A2440;
            break;
        }
        goto LABEL_96;
      case 33:
        switch ( v18 )
        {
          case 0xE:
            v12 = (const char *)&unk_100A1E90;
            break;
          case 0x11:
            v12 = (const char *)&unk_100A2030;
            break;
          case 0x14:
            v12 = (const char *)&unk_100A21D0;
            break;
          case 0x19:
            v12 = (const char *)&unk_100A2370;
            break;
          default:
            v12 = (const char *)&unk_100A2510;
            break;
        }
        goto LABEL_96;
      case 35:
        v12 = (const char *)&unk_100A25E0;
        goto LABEL_96;
      case 34:
        v12 = (const char *)&unk_100A26B0;
        goto LABEL_96;
      case 39:
        v12 = (const char *)&unk_100A2780;
        goto LABEL_96;
      case 40:
        v12 = (const char *)&unk_100A2850;
        goto LABEL_96;
      case 41:
        v12 = (const char *)&unk_100A2920;
        goto LABEL_96;
      case 44:
        v12 = (const char *)&unk_100A29F0;
        goto LABEL_96;
      case 47:
        v12 = (const char *)&unk_100A2AC0;
        goto LABEL_96;
      case 50:
        v12 = (const char *)&unk_100A1A80;
        if ( v18 == 19 )
LABEL_95:
          v12 = (const char *)&unk_100A18E0;
LABEL_96:
        v11 = &v31;
LABEL_97:
        v13 = v28 == 0;
        qmemcpy(v11, v12, 0xCCu);
        if ( !v13 )
        {
          v14 = *(const char **)(a4 + 36);
          v30 = *(_DWORD *)(a4 + 60);
          v15 = *(_WORD *)v24;
          v29 = a4 + 41;
          v16 = *(_WORD *)(v24 + 2);
          v25 = 27;
          v20 = v15;
          v21 = v16;
          if ( v14 )
            strcpy(&v32, v14);
          v19 = sub_1003AB80(v23, (int)&v25, (int)&v20, (int)&v26, v22);
        }
        break;
      default:
        return v19;
    }
  }
  return v19;
}

//----- (100305B0) --------------------------------------------------------
char __cdecl sub_100305B0(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1003AFE0(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1003ADE0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1003AE60(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1003AEE0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_1003AF60(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (100306C0) --------------------------------------------------------
int __cdecl sub_100306C0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10019830(&a1, 1u, (int)&unk_100A4028, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_10003E50("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_100A402C[2 * v1];
  }
  return result;
}
// 100A402C: using guessed type int dword_100A402C[];

//----- (10030710) --------------------------------------------------------
int __cdecl sub_10030710(unsigned __int8 *a1)
{
  return sub_100254A0(a1, 0, 0, 0, 0);
}

//----- (10030730) --------------------------------------------------------
unsigned int __cdecl sub_10030730(void *a1)
{
  return sub_10025440(a1, 0x20u, 0);
}

//----- (10030750) --------------------------------------------------------
unsigned int __cdecl sub_10030750(void *a1)
{
  return sub_10025440(a1, 0x1Cu, 0);
}

//----- (10030770) --------------------------------------------------------
unsigned int __cdecl sub_10030770(void *a1)
{
  return sub_10025440(a1, 0x10u, 0);
}

//----- (10030790) --------------------------------------------------------
unsigned int __cdecl sub_10030790(void *a1)
{
  return sub_10025440(a1, 0xCu, 0);
}

//----- (100307B0) --------------------------------------------------------
unsigned int __cdecl sub_100307B0(void *a1)
{
  return sub_10025440(a1, 8u, 0);
}

//----- (100307D0) --------------------------------------------------------
unsigned int __cdecl sub_100307D0(void *a1)
{
  unsigned int result; // eax@1

  result = sub_10030730((char *)a1 + 64);
  if ( !result )
  {
    result = sub_10030750((char *)a1 + 36);
    if ( !result )
    {
      result = sub_10030770(a1);
      if ( !result )
      {
        result = sub_10030790((char *)a1 + 96);
        if ( !result )
        {
          result = sub_10030790((char *)a1 + 24);
          if ( !result )
            result = sub_100307B0((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (10030830) --------------------------------------------------------
int __cdecl sub_10030830(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (10030840) --------------------------------------------------------
char __cdecl sub_10030840(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_10136800[592 * a1]) || byte_10136850[v3]) )
  {
    *a2 = &byte_10136800[v3];
    *a3 = &byte_10136850[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10030880) --------------------------------------------------------
char *__cdecl sub_10030880(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_10136800;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_10136850[592 * v2];
}

//----- (100308F0) --------------------------------------------------------
char *__usercall sub_100308F0@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (10030920) --------------------------------------------------------
void __cdecl sub_10030920(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_10030880(v2 + 3, (int)&unk_10058CA9);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_10030920(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (100309E0) --------------------------------------------------------
void __cdecl sub_100309E0(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  char *v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  char *v8; // edx@4
  char v9; // cl@5

  if ( dword_101367F8 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_101367F8;
    v4 = (char *)(&byte_10136800[592 * dword_101367F8] - a1);
    do
    {
      v5 = *v2;
      v2[(_DWORD)v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_10136850[v3];
    v8 = (char *)(&byte_10136850[v3] - a2);
    do
    {
      v9 = *v6;
      v6[(_DWORD)v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_10030920(v7);
    ++dword_101367F8;
  }
}
// 101367F8: using guessed type int dword_101367F8;

//----- (10030A40) --------------------------------------------------------
void *__cdecl sub_10030A40(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  char *v4; // edi@4
  char *v5; // esi@4
  char *v6; // eax@4
  const char *v7; // esi@6
  const char *v8; // ebx@6
  char *v9; // edi@6
  char *v10; // eax@6
  char v11; // [sp+4h] [bp-204h]@3

  result = memset(byte_10136800, 0, 0x73A0u);
  dword_101367F8 = 0;
  if ( a1 )
  {
    v2 = sub_10030F10(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_100310F0((int)&v11, 512, v2) )
      {
        do
        {
          sub_100308F0(&v11);
          v4 = strstr(&v11, "=");
          v5 = strstr(&v11, "<Var name=\"");
          v6 = strstr(&v11, " value=\"");
          if ( v5 && v6 )
          {
            v7 = v5 + 11;
            v8 = v6 + 8;
            v9 = strchr(v7, 34);
            v10 = strchr(v8, 34);
            if ( v9 )
            {
              if ( v10 )
              {
                *v9 = 0;
                *v10 = 0;
                sub_100309E0((char *)v7, (char *)v8);
              }
            }
          }
          else if ( v4 && !strpbrk(&v11, "<>") )
          {
            *v4 = 0;
            sub_100309E0(&v11, v4 + 1);
          }
        }
        while ( sub_100310F0((int)&v11, 512, v3) );
      }
      result = (void *)sub_10030EC0(v3);
    }
    else
    {
      result = (void *)sub_1001C120(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 101367F8: using guessed type int dword_101367F8;

//----- (10030BD0) --------------------------------------------------------
int __cdecl sub_10030BD0(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 1004F4B0: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 1004F4C0: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 1004F4D0: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 1004F4E0: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 1004F590: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (10030D10) --------------------------------------------------------
char __usercall sub_10030D10@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy_0((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy_0((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (10030DE0) --------------------------------------------------------
signed int __cdecl sub_10030DE0(_DWORD *a1, char *a2)
{
  int v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = (int)a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *(_DWORD *)v2;
    v10 = *(_DWORD *)v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_1004F4F0(*(_DWORD *)(v2 + 4), (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_10030D10(v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)(v2 + 30), (char)a1);
          v3 = v10;
          *a2 = v8;
          *(_DWORD *)(v2 + 24) += v6;
        }
        else
        {
          v7 = *(_DWORD *)(v2 + 4);
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_10030BD0(v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 1004F5A0: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (10030EC0) --------------------------------------------------------
BOOL __cdecl sub_10030EC0(unsigned int a1)
{
  j_FIL_vfs_clean_invalidate_cache(a1);
  return sub_10004770(a1) == 0;
}
// 10004760: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);

//----- (10030EE0) --------------------------------------------------------
BOOL __cdecl sub_10030EE0(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 100047B0: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (10030F10) --------------------------------------------------------
unsigned int __cdecl sub_10030F10(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 10004830: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10030F70) --------------------------------------------------------
signed int __cdecl sub_10030F70(void *a1, int a2, unsigned int a3)
{
  return sub_10004840(a3, a1, a2);
}

//----- (10030F90) --------------------------------------------------------
int __cdecl sub_10030F90(int a1, int a2, int a3)
{
  return j_FIL_vfs_write(a3, a1, a2);
}
// 100049A0: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10030FB0) --------------------------------------------------------
char __cdecl sub_10030FB0(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  unsigned int v4; // ebp@7
  int v5; // esi@8
  bool i; // zf@8
  char v8; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_10030F10((int)a1, 0);
    if ( v3 )
    {
      v4 = sub_10030F10((int)a2, 1);
      if ( v4 )
      {
        v5 = sub_10030F70(&v8, 512, v3);
        for ( i = v5 == 0; v5 > 0; i = v5 == 0 )
        {
          v5 -= sub_10030F90((int)&v8, v5, v4);
          if ( !v5 )
            v5 = sub_10030F70(&v8, 512, v3);
        }
        v2 = i;
        sub_10030EC0(v4);
      }
      sub_10030EC0(v3);
    }
    return v2;
  }
  return 1;
}

//----- (100310F0) --------------------------------------------------------
int __cdecl sub_100310F0(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_10030F70(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (10031170) --------------------------------------------------------
int sub_10031170()
{
  return 0;
}

//----- (10031180) --------------------------------------------------------
void __cdecl sub_10031180(int a1)
{
  if ( a1 > 0 )
    exit_0(14);
}

//----- (100311B0) --------------------------------------------------------
int __cdecl sub_100311B0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (100311D0) --------------------------------------------------------
bool __cdecl sub_100311D0(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (10031200) --------------------------------------------------------
void *__cdecl sub_10031200(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (10031240) --------------------------------------------------------
unsigned int __usercall sub_10031240@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (10031260) --------------------------------------------------------
int __usercall sub_10031260@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (10031280) --------------------------------------------------------
char __cdecl sub_10031280(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_100311D0(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_100311B0(a2);
  }
  return result;
}

//----- (100312B0) --------------------------------------------------------
signed int __cdecl sub_100312B0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  int v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = (int)a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( *(_DWORD *)(v5 + 4) )
      {
        do
        {
          v10 = sub_10031240(v5, v7, v9);
          v11 = (_BYTE *)sub_10031240(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_10031240(a4, v7, v9);
            sub_10031260(v16, (int)&unk_100A4114);
          }
          ++v9;
        }
        while ( v9 < *(_DWORD *)(v5 + 4) );
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (10031390) --------------------------------------------------------
void __cdecl sub_10031390(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_10031240((int)v3, v4, v6);
          v8 = sub_10031240(a2, v4, v6);
          v9 = sub_10031240(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (10031440) --------------------------------------------------------
void *__usercall sub_10031440@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  int v34; // [sp+14h] [bp-Ch]@1
  int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_10031240(a1, v31, v4);
      v6 = sub_10031240(a2, 0, 0);
      sub_10031260(v5, v6);
      v7 = sub_10031240(a1, v33, v4);
      v8 = sub_10031240(a2, *(_DWORD *)a2 - 1, 0);
      sub_10031260(v7, v8);
      v9 = sub_10031240(a1, v31, v34 - v4 - 1);
      v10 = sub_10031240(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_10031260(v9, v10);
      v11 = sub_10031240(a1, v33, v34 - v4 - 1);
      v12 = sub_10031240(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_10031260(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_10031240(a2, 0, 1);
    v16 = (void *)sub_10031240(a1, v13, a3 + 1);
    memcpy(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_10031240(a1, a3 + i, v18);
      v20 = sub_10031240(a2, i, 0);
      sub_10031260(v19, v20);
      v21 = sub_10031240(a1, i + a3, v34 - v18 - 1);
      v22 = sub_10031240(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_10031260(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_10031240(a2, i, 1);
    v25 = (void *)sub_10031240(a1, a3 + i, a3 + 1);
    memcpy(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_10031240(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_10031240(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (100316C0) --------------------------------------------------------
void __cdecl sub_100316C0(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_10031240(a1, v2, v4);
          v6 = sub_10031240(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (10031790) --------------------------------------------------------
char __cdecl sub_10031790(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_100311D0(a1);
  if ( result )
  {
    result = sub_100311D0(a4);
    if ( result )
    {
      sub_10031280(a3, a4);
      sub_10031200(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (10031800) --------------------------------------------------------
int __usercall sub_10031800@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_10031200(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_10031440((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_10031240((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_10031240(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_10031280((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_10031790(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (10031B60) --------------------------------------------------------
int __usercall sub_10031B60@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_10031200(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_10031390(v8, a3, (int)&v16);
  sub_10031200(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_10031800(9u, v7, (int)&v16, (int)&unk_100A40F0, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_10031240((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_10031240(a6, v9, v11);
            sub_10031260(v13, (int)&unk_100A4114);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_10031280(a5, (int)&v15);
  sub_10031280(a5, (int)&v16);
  return v10;
}

//----- (10031C70) --------------------------------------------------------
int __cdecl sub_10031C70(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_10031200(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_100316C0(a3, a8);
  if ( a1 )
    result = sub_10031B60(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_100312B0((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (10031E00) --------------------------------------------------------
char __cdecl sub_10031E00(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  char *v6; // ebp@11
  int v7; // esi@11
  unsigned int v8; // ebx@11
  int v9; // edi@11
  char result; // al@20
  char v11; // [sp+8h] [bp-40h]@14
  unsigned int v12; // [sp+Ch] [bp-3Ch]@5
  __int16 v13; // [sp+10h] [bp-38h]@6
  int v14; // [sp+1Ah] [bp-2Eh]@8
  char v15; // [sp+20h] [bp-28h]@9
  int v16; // [sp+24h] [bp-24h]@11
  unsigned int v17; // [sp+28h] [bp-20h]@11
  unsigned __int16 v18; // [sp+2Eh] [bp-1Ah]@10
  char v19; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_10030F10((int)a2, 0);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        if ( sub_10030F70(&v13, 14, v4) == 14
          && v13 == 19778
          && v14 == 54
          && sub_10030F70(&v15, 40, v5) == 40
          && v18 == 24 )
        {
          sub_10031200(v17, v16, 24, a1, a3);
          v6 = *(char **)(a3 + 12);
          v7 = v16 * (((unsigned int)v18 + 7) >> 3);
          v8 = 0;
          v9 = -(v16 * (((unsigned int)v18 + 7) >> 3)) & 3;
          v19 = 1;
          if ( v17 )
          {
            while ( sub_10030F70(v6, v7, v12) == v7 && (!v9 || sub_10030F70(&v11, v9, v12) == v9) )
            {
              ++v8;
              v6 += v7;
              if ( v8 >= v17 )
                goto LABEL_18;
            }
            v19 = 0;
          }
LABEL_18:
          v3 = v19;
          v5 = v12;
        }
        sub_10030EC0(v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10031F50) --------------------------------------------------------
char __usercall sub_10031F50@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@1
  unsigned int v10; // ebx@1
  int v12; // [sp+10h] [bp-40h]@4
  int v13; // [sp+14h] [bp-3Ch]@4
  __int16 v14; // [sp+18h] [bp-38h]@1
  int v15; // [sp+1Ah] [bp-36h]@1
  __int16 v16; // [sp+1Eh] [bp-32h]@1
  __int16 v17; // [sp+20h] [bp-30h]@1
  int v18; // [sp+22h] [bp-2Eh]@1
  int v19; // [sp+28h] [bp-28h]@1
  int v20; // [sp+2Ch] [bp-24h]@1
  unsigned int v21; // [sp+30h] [bp-20h]@1
  __int16 v22; // [sp+34h] [bp-1Ch]@1
  __int16 v23; // [sp+36h] [bp-1Ah]@1
  int v24; // [sp+38h] [bp-18h]@1
  int v25; // [sp+3Ch] [bp-14h]@1
  int v26; // [sp+40h] [bp-10h]@1
  int v27; // [sp+44h] [bp-Ch]@1
  int v28; // [sp+48h] [bp-8h]@1
  int v29; // [sp+4Ch] [bp-4h]@1
  char v30; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v25 = v8;
  v15 = v8 + 54;
  v16 = 0;
  v17 = 0;
  v29 = 0;
  v28 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v14 = 19778;
  v18 = 54;
  v19 = 40;
  v23 = a2;
  v21 = v5;
  v20 = a1;
  v22 = 1;
  v9 = sub_10030F10(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_10030F90((int)&v14, 14, v9) == 14 && sub_10030F90((int)&v19, 40, v10) == 40 )
    {
      v30 = 1;
      v12 = a4;
      v13 = 0;
      if ( v5 )
      {
        while ( sub_10030F90(v12, v6, v10) == v6 && (!v7 || sub_10030F90((int)&unk_100A42B8, v7, v10) == v7) )
        {
          v12 += v6;
          if ( ++v13 >= v5 )
          {
            sub_10030EC0(v10);
            return 1;
          }
        }
        v30 = 0;
      }
    }
    sub_10030EC0(v10);
  }
  return v30;
}

//----- (100320A0) --------------------------------------------------------
char __cdecl sub_100320A0(int a1, int a2)
{
  char result; // al@2

  if ( sub_100311D0(a1) )
    result = sub_10031F50(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (100320E0) --------------------------------------------------------
signed int __cdecl sub_100320E0(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_1013DBA1 = 1;
    byte_1013DBA0 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_1013DBA0 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_1013DBA1 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 1013DBA0: using guessed type char byte_1013DBA0;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10032140) --------------------------------------------------------
bool __cdecl sub_10032140(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_1001C070(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_100BBEB0, (int)"failing_subroutine( depth-1 )");
    sub_10032140(a1 - 1);
    exit_0(14);
  }
  return sub_10021530(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (100321B0) --------------------------------------------------------
int sub_100321B0()
{
  const char *v0; // eax@1

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_1013DBA0 )
  {
    sub_10021530(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_1001C070(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_10032140(1);
    exit_0(14);
  }
  return sub_1001C0A0(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (100324D0) --------------------------------------------------------
char sub_100324D0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1013DBA0 )
  {
    v2 = 0;
    do
    {
      if ( off_100A4F24[v2] )
      {
        sub_1001C860((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100A4F2C[v2 * 4], 0x100u, &v11);
        sub_1001C860((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100A4F24[v2], 0x100u, &v12);
        sub_10030FB0(&v12, &v11);
      }
      if ( byte_100A4F20[v2 * 4] )
      {
        sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = off_100A4F28[v2];
        v4 = *(char **)&off_100A4F2C[v2 * 4];
        v5 = sub_1001CB00(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100A4F2C[v2 * 4],
               off_100A4F28[v2]);
        v6 = sub_10021180(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1001CE60(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"731",
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = off_100A4F28[v2];
        v8 = *(char **)&off_100A4F2C[v2 * 4];
        v9 = sub_1001CB00(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100A4F2C[v2 * 4],
               off_100A4F28[v2]);
        v10 = sub_10021180(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1001CE60(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"741",
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"704",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100A4F24: using guessed type char *off_100A4F24[3];
// 100A4F28: using guessed type char *off_100A4F28[2];
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (100326F0) --------------------------------------------------------
char sub_100326F0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_1013DBA0 )
  {
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_1001CE60(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"777",
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1001CE60(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_1001CE60(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1001CE60(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"782",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"784", 2, 2);
    v4 = sub_1001CE60(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1001CE60(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"788", 2, 2);
    v5 = sub_1001CE60(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1001CE60(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"790",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (100328F0) --------------------------------------------------------
char sub_100328F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100A4FB4[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_100A4FB1[v2 * 4];
        v4 = byte_100A4FB0[v2 * 4];
        v5 = sub_1001CB00(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + dword_100A4FB4[v2])],
               (&off_100A4FB8)[v2 * 4]);
        v6 = sub_1001CFA0(
               0,
               *(&dword_100A4F04 + dword_100A4FB4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1001CB00(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100A4FB4[v2]],
               (&off_100A4FB8)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A4FB4: using guessed type int dword_100A4FB4[];
// 100A4FB8: using guessed type char *off_100A4FB8;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10032A70) --------------------------------------------------------
char sub_10032A70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100A5238[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100A5230[v2 / 8];
        v4 = dbl_100A5228[v2 / 8];
        v5 = dbl_100A5220[v2 / 8];
        v6 = sub_1001CB00(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               *(_DWORD *)&off_100A523C[v2]);
        v7 = sub_1001D350(
               0,
               *(&dword_100A4F04 + dword_100A5238[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100A5238[v2 / 4]],
               *(_DWORD *)&off_100A523C[v2]);
        LOBYTE(v0) = sub_1001CE60(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A5220: using guessed type double dbl_100A5220[];
// 100A5228: using guessed type double dbl_100A5228[];
// 100A5230: using guessed type double dbl_100A5230[];
// 100A5238: using guessed type int dword_100A5238[];
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10032BF0) --------------------------------------------------------
char sub_10032BF0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100A5E4C[v2];
      if ( v0 != 6 )
      {
        v3 = flt_100A5E48[v2];
        v4 = flt_100A5E44[v2];
        v5 = flt_100A5E40[v2];
        v6 = sub_1001CB00(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               (&off_100A5E50)[v2 * 4]);
        v7 = sub_1001D7A0(
               0,
               *(&dword_100A4F04 + dword_100A5E4C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100A5E4C[v2]],
               (&off_100A5E50)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A5E40: using guessed type float flt_100A5E40[];
// 100A5E44: using guessed type float flt_100A5E44[];
// 100A5E48: using guessed type float flt_100A5E48[];
// 100A5E4C: using guessed type int dword_100A5E4C[];
// 100A5E50: using guessed type char *off_100A5E50;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10032D60) --------------------------------------------------------
char sub_10032D60()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1013DBA0 )
  {
    sub_10021480(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_10032D60,
      (int)sub_10032D60,
      (int)"This test is expected to fail");
    sub_10021480(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_10032D60,
      0,
      (int)"This test is expected to fail");
    result = sub_10021480(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10032D60,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10032E60) --------------------------------------------------------
char sub_10032E60()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100A65F4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A65F0[v2];
        v4 = dword_100A65EC[v2];
        v5 = dword_100A65E8[v2];
        v6 = sub_1001CB00(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               *(_DWORD *)&off_100A65F8[v2 * 4]);
        v7 = sub_1001DC60(
               0,
               *(&dword_100A4F04 + dword_100A65F4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100A65F4[v2]],
               *(_DWORD *)&off_100A65F8[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A65E8: using guessed type int dword_100A65E8[];
// 100A65EC: using guessed type int dword_100A65EC[];
// 100A65F0: using guessed type int dword_100A65F0[];
// 100A65F4: using guessed type int dword_100A65F4[];
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10032FC0) --------------------------------------------------------
char sub_10032FC0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100A6D88[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100A6D84[v2 / 2];
        v4 = word_100A6D82[v2 / 2];
        v5 = word_100A6D80[v2 / 2];
        v6 = sub_1001CB00(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               *(_DWORD *)&off_100A6D8C[v2]);
        v7 = sub_1001E020(
               0,
               *(&dword_100A4F04 + dword_100A6D88[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100A6D88[v2 / 4]],
               *(_DWORD *)&off_100A6D8C[v2]);
        LOBYTE(v0) = sub_1001CE60(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A6D80: using guessed type __int16 word_100A6D80[];
// 100A6D82: using guessed type __int16 word_100A6D82[];
// 100A6D84: using guessed type __int16 word_100A6D84[];
// 100A6D88: using guessed type int dword_100A6D88[];
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10033120) --------------------------------------------------------
char sub_10033120()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100A739C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A7398[v2];
        v4 = dword_100A7394[v2];
        v5 = dword_100A7390[v2];
        v6 = sub_1001CB00(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               (&off_100A73A0)[v2 * 4]);
        v7 = sub_1001E420(
               0,
               *(&dword_100A4F04 + dword_100A739C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100A739C[v2]],
               (&off_100A73A0)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A7390: using guessed type int dword_100A7390[];
// 100A7394: using guessed type int dword_100A7394[];
// 100A7398: using guessed type int dword_100A7398[];
// 100A739C: using guessed type int dword_100A739C[];
// 100A73A0: using guessed type char *off_100A73A0;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10033280) --------------------------------------------------------
char sub_10033280()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100A7B40[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100A7B3C[v2];
        LODWORD(v3) = dword_100A7B38[v2];
        HIDWORD(v4) = dword_100A7B34[v2];
        LODWORD(v4) = dword_100A7B30[v2];
        HIDWORD(v5) = dword_100A7B2C[v2];
        LODWORD(v5) = dword_100A7B28[v2];
        v6 = sub_1001CB00(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               (&off_100A7B44)[v2 * 4]);
        v7 = sub_1001E7E0(
               0,
               *(&dword_100A4F04 + dword_100A7B40[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100A7B40[v2]],
               (&off_100A7B44)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A7B28: using guessed type int dword_100A7B28[];
// 100A7B2C: using guessed type int dword_100A7B2C[];
// 100A7B30: using guessed type int dword_100A7B30[];
// 100A7B34: using guessed type int dword_100A7B34[];
// 100A7B38: using guessed type int dword_100A7B38[];
// 100A7B3C: using guessed type int dword_100A7B3C[];
// 100A7B40: using guessed type int dword_100A7B40[];
// 100A7B44: using guessed type char *off_100A7B44;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (100333F0) --------------------------------------------------------
char sub_100333F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100A874C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100A874A[v2 * 4];
        v4 = byte_100A8749[v2 * 4];
        v5 = byte_100A8748[v2 * 4];
        v6 = sub_1001CB00(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               (&off_100A8750)[v2 * 4]);
        v7 = sub_1001ED20(
               0,
               *(&dword_100A4F04 + dword_100A874C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100A874C[v2]],
               (&off_100A8750)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A874C: using guessed type int dword_100A874C[];
// 100A8750: using guessed type char *off_100A8750;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10033550) --------------------------------------------------------
char sub_10033550()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100A8BE4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A8BE0[v2];
        v4 = dword_100A8BDC[v2];
        v5 = dword_100A8BD8[v2];
        v6 = sub_1001CB00(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               *(_DWORD *)&off_100A8BE8[v2 * 4]);
        v7 = sub_1001F100(
               0,
               *(&dword_100A4F04 + dword_100A8BE4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100A8BE4[v2]],
               *(_DWORD *)&off_100A8BE8[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A8BD8: using guessed type int dword_100A8BD8[];
// 100A8BDC: using guessed type int dword_100A8BDC[];
// 100A8BE0: using guessed type int dword_100A8BE0[];
// 100A8BE4: using guessed type int dword_100A8BE4[];
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (100336B0) --------------------------------------------------------
char sub_100336B0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1013DBA0 )
  {
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_10021530(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10058CA9,
           (int)"This test is expected to fail");
    sub_1001CE60(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_10021530(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_10058CA9,
           "a",
           (int)"This test is expected to fail");
    sub_1001CE60(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_10021530(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10058CA9,
           (const char *)&unk_10058CA9,
           (int)"This test is expected to fail");
    sub_1001CE60(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_10021530(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_1001CE60(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (100338D0) --------------------------------------------------------
char sub_100338D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100A937C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A9378[v2];
        v4 = dword_100A9374[v2];
        v5 = dword_100A9370[v2];
        v6 = sub_1001CB00(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               (&off_100A9380)[v2 * 4]);
        v7 = sub_1001F4C0(
               0,
               *(&dword_100A4F04 + dword_100A937C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100A937C[v2]],
               (&off_100A9380)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A9370: using guessed type int dword_100A9370[];
// 100A9374: using guessed type int dword_100A9374[];
// 100A9378: using guessed type int dword_100A9378[];
// 100A937C: using guessed type int dword_100A937C[];
// 100A9380: using guessed type char *off_100A9380;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10033A30) --------------------------------------------------------
char sub_10033A30()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100A96E8[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100A96E4[v2 / 2];
        v4 = word_100A96E2[v2 / 2];
        v5 = word_100A96E0[v2 / 2];
        v6 = sub_1001CB00(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               *(_DWORD *)&off_100A96EC[v2]);
        v7 = sub_1001F860(
               0,
               *(&dword_100A4F04 + dword_100A96E8[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100A96E8[v2 / 4]],
               *(_DWORD *)&off_100A96EC[v2]);
        LOBYTE(v0) = sub_1001CE60(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A96E0: using guessed type __int16 word_100A96E0[];
// 100A96E2: using guessed type __int16 word_100A96E2[];
// 100A96E4: using guessed type __int16 word_100A96E4[];
// 100A96E8: using guessed type int dword_100A96E8[];
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10033B90) --------------------------------------------------------
char sub_10033B90()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100A99AC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A99A8[v2];
        v4 = dword_100A99A4[v2];
        v5 = dword_100A99A0[v2];
        v6 = sub_1001CB00(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               (&off_100A99B0)[v2 * 4]);
        v7 = sub_1001FC60(
               0,
               *(&dword_100A4F04 + dword_100A99AC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100A99AC[v2]],
               (&off_100A99B0)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A99A0: using guessed type int dword_100A99A0[];
// 100A99A4: using guessed type int dword_100A99A4[];
// 100A99A8: using guessed type int dword_100A99A8[];
// 100A99AC: using guessed type int dword_100A99AC[];
// 100A99B0: using guessed type char *off_100A99B0;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10033CF0) --------------------------------------------------------
char sub_10033CF0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100A9D28[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100A9D24[v2];
        LODWORD(v3) = dword_100A9D20[v2];
        HIDWORD(v4) = dword_100A9D1C[v2];
        LODWORD(v4) = dword_100A9D18[v2];
        HIDWORD(v5) = dword_100A9D14[v2];
        LODWORD(v5) = dword_100A9D10[v2];
        v6 = sub_1001CB00(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               *(_DWORD *)&off_100A9D2C[v2 * 4]);
        v7 = sub_10020000(
               0,
               *(&dword_100A4F04 + dword_100A9D28[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100A9D28[v2]],
               *(_DWORD *)&off_100A9D2C[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A9D10: using guessed type int dword_100A9D10[];
// 100A9D14: using guessed type int dword_100A9D14[];
// 100A9D18: using guessed type int dword_100A9D18[];
// 100A9D1C: using guessed type int dword_100A9D1C[];
// 100A9D20: using guessed type int dword_100A9D20[];
// 100A9D24: using guessed type int dword_100A9D24[];
// 100A9D28: using guessed type int dword_100A9D28[];
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10033E60) --------------------------------------------------------
char sub_10033E60()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AA294[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100AA292[v2 * 4];
        v4 = byte_100AA291[v2 * 4];
        v5 = byte_100AA290[v2 * 4];
        v6 = sub_1001CB00(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               (&off_100AA298)[v2 * 4]);
        v7 = sub_100205E0(
               0,
               *(&dword_100A4F04 + dword_100AA294[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100AA294[v2]],
               (&off_100AA298)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AA294: using guessed type int dword_100AA294[];
// 100AA298: using guessed type char *off_100AA298;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10033FC0) --------------------------------------------------------
char sub_10033FC0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AA4AC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100AA4A8[v2];
        v4 = dword_100AA4A4[v2];
        v5 = dword_100AA4A0[v2];
        v6 = sub_1001CB00(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               (&off_100AA4B0)[v2 * 4]);
        v7 = sub_100209D0(
               0,
               *(&dword_100A4F04 + dword_100AA4AC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100AA4AC[v2]],
               (&off_100AA4B0)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AA4A0: using guessed type int dword_100AA4A0[];
// 100AA4A4: using guessed type int dword_100AA4A4[];
// 100AA4A8: using guessed type int dword_100AA4A8[];
// 100AA4AC: using guessed type int dword_100AA4AC[];
// 100AA4B0: using guessed type char *off_100AA4B0;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10034120) --------------------------------------------------------
char sub_10034120()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1013DBA0 )
  {
    v2 = 0;
    do
    {
      if ( off_100AA814[v2] )
      {
        sub_1001C860((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100AA81C[v2 * 4], 0x100u, &v11);
        sub_1001C860((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100AA814[v2], 0x100u, &v12);
        sub_10030FB0(&v12, &v11);
      }
      if ( byte_100AA810[v2 * 4] )
      {
        sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = off_100AA818[v2];
        v4 = *(char **)&off_100AA81C[v2 * 4];
        v5 = sub_1001CB00(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100AA81C[v2 * 4],
               off_100AA818[v2]);
        v6 = sub_10021180(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1001CE60(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = off_100AA818[v2];
        v8 = *(char **)&off_100AA81C[v2 * 4];
        v9 = sub_1001CB00(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100AA81C[v2 * 4],
               off_100AA818[v2]);
        v10 = sub_10021180(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1001CE60(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100AA814: using guessed type char *off_100AA814[3];
// 100AA818: using guessed type char *off_100AA818[2];
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10034340) --------------------------------------------------------
char sub_10034340()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_1013DBA0 )
  {
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_1001CE60(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1001CE60(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_1001CE60(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1001CE60(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_1001CE60(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1001CE60(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_1001CE60(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1001CE60(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10034540) --------------------------------------------------------
char sub_10034540()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AA8A4[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_100AA8A1[v2 * 4];
        v4 = byte_100AA8A0[v2 * 4];
        v5 = sub_1001CB00(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + dword_100AA8A4[v2])],
               (&off_100AA8A8)[v2 * 4]);
        v6 = sub_1001CFA0(
               1,
               *(&dword_100A4F04 + dword_100AA8A4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1001CB00(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100AA8A4[v2]],
               (&off_100AA8A8)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AA8A4: using guessed type int dword_100AA8A4[];
// 100AA8A8: using guessed type char *off_100AA8A8;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (100346C0) --------------------------------------------------------
char sub_100346C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AAB28[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100AAB20[v2 / 8];
        v4 = dbl_100AAB18[v2 / 8];
        v5 = dbl_100AAB10[v2 / 8];
        v6 = sub_1001CB00(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               *(_DWORD *)&off_100AAB2C[v2]);
        v7 = sub_1001D350(
               1,
               *(&dword_100A4F04 + dword_100AAB28[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100AAB28[v2 / 4]],
               *(_DWORD *)&off_100AAB2C[v2]);
        LOBYTE(v0) = sub_1001CE60(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AAB10: using guessed type double dbl_100AAB10[];
// 100AAB18: using guessed type double dbl_100AAB18[];
// 100AAB20: using guessed type double dbl_100AAB20[];
// 100AAB28: using guessed type int dword_100AAB28[];
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10034840) --------------------------------------------------------
char sub_10034840()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AB73C[v2];
      if ( v0 != 6 )
      {
        v3 = flt_100AB738[v2];
        v4 = flt_100AB734[v2];
        v5 = flt_100AB730[v2];
        v6 = sub_1001CB00(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               (&off_100AB740)[v2 * 4]);
        v7 = sub_1001D7A0(
               1,
               *(&dword_100A4F04 + dword_100AB73C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100AB73C[v2]],
               (&off_100AB740)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AB730: using guessed type float flt_100AB730[];
// 100AB734: using guessed type float flt_100AB734[];
// 100AB738: using guessed type float flt_100AB738[];
// 100AB73C: using guessed type int dword_100AB73C[];
// 100AB740: using guessed type char *off_100AB740;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (100349B0) --------------------------------------------------------
char sub_100349B0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1013DBA0 )
  {
    sub_10021480(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_100349B0,
      (int)sub_100349B0,
      0);
    sub_10021480(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_100349B0,
      0,
      0);
    result = sub_10021480(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_100349B0,
               0);
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10034AA0) --------------------------------------------------------
char sub_10034AA0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100ABED4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100ABED0[v2];
        v4 = dword_100ABECC[v2];
        v5 = dword_100ABEC8[v2];
        v6 = sub_1001CB00(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               *(_DWORD *)&off_100ABED8[v2 * 4]);
        v7 = sub_1001DC60(
               1,
               *(&dword_100A4F04 + dword_100ABED4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100ABED4[v2]],
               *(_DWORD *)&off_100ABED8[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100ABEC8: using guessed type int dword_100ABEC8[];
// 100ABECC: using guessed type int dword_100ABECC[];
// 100ABED0: using guessed type int dword_100ABED0[];
// 100ABED4: using guessed type int dword_100ABED4[];
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10034C00) --------------------------------------------------------
char sub_10034C00()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AC668[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100AC664[v2 / 2];
        v4 = word_100AC662[v2 / 2];
        v5 = word_100AC660[v2 / 2];
        v6 = sub_1001CB00(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               *(_DWORD *)&off_100AC66C[v2]);
        v7 = sub_1001E020(
               1,
               *(&dword_100A4F04 + dword_100AC668[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100AC668[v2 / 4]],
               *(_DWORD *)&off_100AC66C[v2]);
        LOBYTE(v0) = sub_1001CE60(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AC660: using guessed type __int16 word_100AC660[];
// 100AC662: using guessed type __int16 word_100AC662[];
// 100AC664: using guessed type __int16 word_100AC664[];
// 100AC668: using guessed type int dword_100AC668[];
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10034D60) --------------------------------------------------------
char sub_10034D60()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100ACC7C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100ACC78[v2];
        v4 = dword_100ACC74[v2];
        v5 = dword_100ACC70[v2];
        v6 = sub_1001CB00(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               (&off_100ACC80)[v2 * 4]);
        v7 = sub_1001E420(
               1,
               *(&dword_100A4F04 + dword_100ACC7C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100ACC7C[v2]],
               (&off_100ACC80)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100ACC70: using guessed type int dword_100ACC70[];
// 100ACC74: using guessed type int dword_100ACC74[];
// 100ACC78: using guessed type int dword_100ACC78[];
// 100ACC7C: using guessed type int dword_100ACC7C[];
// 100ACC80: using guessed type char *off_100ACC80;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10034EC0) --------------------------------------------------------
char sub_10034EC0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AD420[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100AD41C[v2];
        LODWORD(v3) = dword_100AD418[v2];
        HIDWORD(v4) = dword_100AD414[v2];
        LODWORD(v4) = dword_100AD410[v2];
        HIDWORD(v5) = dword_100AD40C[v2];
        LODWORD(v5) = dword_100AD408[v2];
        v6 = sub_1001CB00(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               (&off_100AD424)[v2 * 4]);
        v7 = sub_1001E7E0(
               1,
               *(&dword_100A4F04 + dword_100AD420[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100AD420[v2]],
               (&off_100AD424)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AD408: using guessed type int dword_100AD408[];
// 100AD40C: using guessed type int dword_100AD40C[];
// 100AD410: using guessed type int dword_100AD410[];
// 100AD414: using guessed type int dword_100AD414[];
// 100AD418: using guessed type int dword_100AD418[];
// 100AD41C: using guessed type int dword_100AD41C[];
// 100AD420: using guessed type int dword_100AD420[];
// 100AD424: using guessed type char *off_100AD424;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10035030) --------------------------------------------------------
char sub_10035030()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AE02C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100AE02A[v2 * 4];
        v4 = byte_100AE029[v2 * 4];
        v5 = byte_100AE028[v2 * 4];
        v6 = sub_1001CB00(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               (&off_100AE030)[v2 * 4]);
        v7 = sub_1001ED20(
               1,
               *(&dword_100A4F04 + dword_100AE02C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100AE02C[v2]],
               (&off_100AE030)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AE02C: using guessed type int dword_100AE02C[];
// 100AE030: using guessed type char *off_100AE030;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10035190) --------------------------------------------------------
char sub_10035190()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AE4C4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100AE4C0[v2];
        v4 = dword_100AE4BC[v2];
        v5 = dword_100AE4B8[v2];
        v6 = sub_1001CB00(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               *(_DWORD *)&off_100AE4C8[v2 * 4]);
        v7 = sub_1001F100(
               1,
               *(&dword_100A4F04 + dword_100AE4C4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100AE4C4[v2]],
               *(_DWORD *)&off_100AE4C8[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AE4B8: using guessed type int dword_100AE4B8[];
// 100AE4BC: using guessed type int dword_100AE4BC[];
// 100AE4C0: using guessed type int dword_100AE4C0[];
// 100AE4C4: using guessed type int dword_100AE4C4[];
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (100352F0) --------------------------------------------------------
char sub_100352F0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1013DBA0 )
  {
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_10021530(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10058CA9,
           0);
    sub_1001CE60(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_10021530(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_10058CA9,
           "a",
           0);
    sub_1001CE60(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_10021530(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10058CA9,
           (const char *)&unk_10058CA9,
           0);
    sub_1001CE60(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_10021530(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_1001CE60(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (100354F0) --------------------------------------------------------
char sub_100354F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AEC5C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100AEC58[v2];
        v4 = dword_100AEC54[v2];
        v5 = dword_100AEC50[v2];
        v6 = sub_1001CB00(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               (&off_100AEC60)[v2 * 4]);
        v7 = sub_1001F4C0(
               1,
               *(&dword_100A4F04 + dword_100AEC5C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100AEC5C[v2]],
               (&off_100AEC60)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AEC50: using guessed type int dword_100AEC50[];
// 100AEC54: using guessed type int dword_100AEC54[];
// 100AEC58: using guessed type int dword_100AEC58[];
// 100AEC5C: using guessed type int dword_100AEC5C[];
// 100AEC60: using guessed type char *off_100AEC60;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10035650) --------------------------------------------------------
char sub_10035650()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AEFC8[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100AEFC4[v2 / 2];
        v4 = word_100AEFC2[v2 / 2];
        v5 = word_100AEFC0[v2 / 2];
        v6 = sub_1001CB00(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               *(_DWORD *)&off_100AEFCC[v2]);
        v7 = sub_1001F860(
               1,
               *(&dword_100A4F04 + dword_100AEFC8[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100AEFC8[v2 / 4]],
               *(_DWORD *)&off_100AEFCC[v2]);
        LOBYTE(v0) = sub_1001CE60(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AEFC0: using guessed type __int16 word_100AEFC0[];
// 100AEFC2: using guessed type __int16 word_100AEFC2[];
// 100AEFC4: using guessed type __int16 word_100AEFC4[];
// 100AEFC8: using guessed type int dword_100AEFC8[];
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (100357B0) --------------------------------------------------------
char sub_100357B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AF28C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100AF288[v2];
        v4 = dword_100AF284[v2];
        v5 = dword_100AF280[v2];
        v6 = sub_1001CB00(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               (&off_100AF290)[v2 * 4]);
        v7 = sub_1001FC60(
               1,
               *(&dword_100A4F04 + dword_100AF28C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100AF28C[v2]],
               (&off_100AF290)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AF280: using guessed type int dword_100AF280[];
// 100AF284: using guessed type int dword_100AF284[];
// 100AF288: using guessed type int dword_100AF288[];
// 100AF28C: using guessed type int dword_100AF28C[];
// 100AF290: using guessed type char *off_100AF290;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10035910) --------------------------------------------------------
char sub_10035910()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AF608[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100AF604[v2];
        LODWORD(v3) = dword_100AF600[v2];
        HIDWORD(v4) = dword_100AF5FC[v2];
        LODWORD(v4) = dword_100AF5F8[v2];
        HIDWORD(v5) = dword_100AF5F4[v2];
        LODWORD(v5) = dword_100AF5F0[v2];
        v6 = sub_1001CB00(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               *(_DWORD *)&off_100AF60C[v2 * 4]);
        v7 = sub_10020000(
               1,
               *(&dword_100A4F04 + dword_100AF608[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100AF608[v2]],
               *(_DWORD *)&off_100AF60C[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AF5F0: using guessed type int dword_100AF5F0[];
// 100AF5F4: using guessed type int dword_100AF5F4[];
// 100AF5F8: using guessed type int dword_100AF5F8[];
// 100AF5FC: using guessed type int dword_100AF5FC[];
// 100AF600: using guessed type int dword_100AF600[];
// 100AF604: using guessed type int dword_100AF604[];
// 100AF608: using guessed type int dword_100AF608[];
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10035A80) --------------------------------------------------------
char sub_10035A80()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AFB74[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100AFB72[v2 * 4];
        v4 = byte_100AFB71[v2 * 4];
        v5 = byte_100AFB70[v2 * 4];
        v6 = sub_1001CB00(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               (&off_100AFB78)[v2 * 4]);
        v7 = sub_100205E0(
               1,
               *(&dword_100A4F04 + dword_100AFB74[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100AFB74[v2]],
               (&off_100AFB78)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AFB74: using guessed type int dword_100AFB74[];
// 100AFB78: using guessed type char *off_100AFB78;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10035BE0) --------------------------------------------------------
char sub_10035BE0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1013DBA0 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100AFD8C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100AFD88[v2];
        v4 = dword_100AFD84[v2];
        v5 = dword_100AFD80[v2];
        v6 = sub_1001CB00(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * *(&dword_100A4F04 + v0)],
               (&off_100AFD90)[v2 * 4]);
        v7 = sub_100209D0(
               1,
               *(&dword_100A4F04 + dword_100AFD8C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001CB00(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100AFD8C[v2]],
               (&off_100AFD90)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AFD80: using guessed type int dword_100AFD80[];
// 100AFD84: using guessed type int dword_100AFD84[];
// 100AFD88: using guessed type int dword_100AFD88[];
// 100AFD8C: using guessed type int dword_100AFD8C[];
// 100AFD90: using guessed type char *off_100AFD90;
// 1013DBA0: using guessed type char byte_1013DBA0;

//----- (10035D40) --------------------------------------------------------
char sub_10035D40()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_1013DBA1 )
  {
    sub_10021530(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_1001DC60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_1001DC60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_1001DC60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_1001DC60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_1001DC60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_1001DC60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_1001DC60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_1001DC60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_1001DC60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_1001DC60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_1001C0A0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_1001DC60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_1001AB00() )
      v1 = 3;
    sub_1001DC60(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_1001AB00();
    sub_1001DC60(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_1001C0A0(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_1001DC60(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (100362E0) --------------------------------------------------------
char sub_100362E0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1013DBA1 )
  {
    v2 = 0;
    do
    {
      if ( off_100B00F4[v2] )
      {
        sub_1001C860((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100B00FC[v2 * 4], 0x100u, &v13);
        sub_1001C860((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100B00F4[v2], 0x100u, &v14);
        sub_10030FB0(&v14, &v13);
      }
      if ( byte_100B00F0[v2 * 4] )
      {
        sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = off_100B00F8[v2];
        v4 = *(char **)&off_100B00FC[v2 * 4];
        v5 = sub_1001CB00(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100B00FC[v2 * 4],
               off_100B00F8[v2]);
        v12 = 1;
        v11 = sub_10021180(
                0,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2114",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = off_100B00F8[v2];
        v7 = *(char **)&off_100B00FC[v2 * 4];
        v8 = sub_1001CB00(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100B00FC[v2 * 4],
               off_100B00F8[v2]);
        v12 = 1;
        v11 = sub_10021180(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2123",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_1001CE60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B00F4: using guessed type char *off_100B00F4[3];
// 100B00F8: using guessed type char *off_100B00F8[2];
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (100364F0) --------------------------------------------------------
char sub_100364F0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_1013DBA1 )
  {
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_1001CE60(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1001CE60(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_1001CE60(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1001CE60(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_1001CE60(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1001CE60(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_1001CE60(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1001CE60(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (100366E0) --------------------------------------------------------
char sub_100366E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B0144[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_100B0141[v2 * 4];
        v4 = byte_100B0140[v2 * 4];
        v5 = sub_1001CB00(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * dword_100B0144[v2]],
               (&off_100B0148)[v2 * 4]);
        v6 = sub_1001CFA0(0, dword_100B0144[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_1001CB00(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100B0144[v2]],
               (&off_100B0148)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100B0144: using guessed type int dword_100B0144[];
// 100B0148: using guessed type char *off_100B0148;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10036850) --------------------------------------------------------
char sub_10036850()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_100B03C0[v2 / 2];
      v4 = dbl_100B03B8[v2 / 2];
      v5 = dbl_100B03B0[v2 / 2];
      v6 = sub_1001CB00(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B03C8[v2]],
             *(_DWORD *)&off_100B03CC[v2 * 4]);
      v7 = sub_1001D350(0, dword_100B03C8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B03C8[v2]],
             *(_DWORD *)&off_100B03CC[v2 * 4]);
      result = sub_1001CE60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B03B0: using guessed type double dbl_100B03B0[];
// 100B03B8: using guessed type double dbl_100B03B8[];
// 100B03C0: using guessed type double dbl_100B03C0[];
// 100B03C8: using guessed type int dword_100B03C8[];
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (100369C0) --------------------------------------------------------
char sub_100369C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_100B0FD8[v2];
      v4 = flt_100B0FD4[v2];
      v5 = flt_100B0FD0[v2];
      v6 = sub_1001CB00(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B0FDC[v2]],
             (&off_100B0FE0)[v2 * 4]);
      v7 = sub_1001D7A0(0, dword_100B0FDC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B0FDC[v2]],
             (&off_100B0FE0)[v2 * 4]);
      result = sub_1001CE60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B0FD0: using guessed type float flt_100B0FD0[];
// 100B0FD4: using guessed type float flt_100B0FD4[];
// 100B0FD8: using guessed type float flt_100B0FD8[];
// 100B0FDC: using guessed type int dword_100B0FDC[];
// 100B0FE0: using guessed type char *off_100B0FE0;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10036B20) --------------------------------------------------------
char sub_10036B20()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1013DBA1 )
  {
    sub_10021480(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_10036B20,
      (int)sub_10036B20,
      0);
    sub_10021480(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_10036B20,
      0,
      0);
    result = sub_10021480(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10036B20,
               0);
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10036C10) --------------------------------------------------------
char sub_10036C10()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_100B1770[v2];
      v4 = dword_100B176C[v2];
      v5 = dword_100B1768[v2];
      v6 = sub_1001CB00(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B1774[v2]],
             *(_DWORD *)&off_100B1778[v2 * 4]);
      v7 = sub_1001DC60(0, dword_100B1774[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B1774[v2]],
             *(_DWORD *)&off_100B1778[v2 * 4]);
      result = sub_1001CE60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B1768: using guessed type int dword_100B1768[];
// 100B176C: using guessed type int dword_100B176C[];
// 100B1770: using guessed type int dword_100B1770[];
// 100B1774: using guessed type int dword_100B1774[];
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10036D70) --------------------------------------------------------
char sub_10036D70()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_100B1F04[v2 / 2];
      v4 = word_100B1F02[v2 / 2];
      v5 = word_100B1F00[v2 / 2];
      v6 = sub_1001CB00(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B1F08[v2 / 4]],
             *(_DWORD *)&off_100B1F0C[v2]);
      v7 = sub_1001E020(
             0,
             dword_100B1F08[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B1F08[v2 / 4]],
             *(_DWORD *)&off_100B1F0C[v2]);
      result = sub_1001CE60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B1F00: using guessed type __int16 word_100B1F00[];
// 100B1F02: using guessed type __int16 word_100B1F02[];
// 100B1F04: using guessed type __int16 word_100B1F04[];
// 100B1F08: using guessed type int dword_100B1F08[];
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10036ED0) --------------------------------------------------------
char sub_10036ED0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_100B2518[v2];
      v4 = dword_100B2514[v2];
      v5 = dword_100B2510[v2];
      v6 = sub_1001CB00(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B251C[v2]],
             (&off_100B2520)[v2 * 4]);
      v7 = sub_1001E420(0, dword_100B251C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B251C[v2]],
             (&off_100B2520)[v2 * 4]);
      result = sub_1001CE60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B2510: using guessed type int dword_100B2510[];
// 100B2514: using guessed type int dword_100B2514[];
// 100B2518: using guessed type int dword_100B2518[];
// 100B251C: using guessed type int dword_100B251C[];
// 100B2520: using guessed type char *off_100B2520;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10037030) --------------------------------------------------------
char sub_10037030()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_100B2CBC[v2];
      LODWORD(v3) = dword_100B2CB8[v2];
      HIDWORD(v4) = dword_100B2CB4[v2];
      LODWORD(v4) = dword_100B2CB0[v2];
      HIDWORD(v5) = dword_100B2CAC[v2];
      LODWORD(v5) = dword_100B2CA8[v2];
      v6 = sub_1001CB00(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B2CC0[v2]],
             (&off_100B2CC4)[v2 * 4]);
      v7 = sub_1001E7E0(0, dword_100B2CC0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B2CC0[v2]],
             (&off_100B2CC4)[v2 * 4]);
      result = sub_1001CE60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B2CA8: using guessed type int dword_100B2CA8[];
// 100B2CAC: using guessed type int dword_100B2CAC[];
// 100B2CB0: using guessed type int dword_100B2CB0[];
// 100B2CB4: using guessed type int dword_100B2CB4[];
// 100B2CB8: using guessed type int dword_100B2CB8[];
// 100B2CBC: using guessed type int dword_100B2CBC[];
// 100B2CC0: using guessed type int dword_100B2CC0[];
// 100B2CC4: using guessed type char *off_100B2CC4;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (100371A0) --------------------------------------------------------
char sub_100371A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_100B38CA[v2 * 4];
      v4 = byte_100B38C9[v2 * 4];
      v5 = byte_100B38C8[v2 * 4];
      v6 = sub_1001CB00(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B38CC[v2]],
             (&off_100B38D0)[v2 * 4]);
      v7 = sub_1001ED20(0, dword_100B38CC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B38CC[v2]],
             (&off_100B38D0)[v2 * 4]);
      result = sub_1001CE60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B38CC: using guessed type int dword_100B38CC[];
// 100B38D0: using guessed type char *off_100B38D0;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10037300) --------------------------------------------------------
char sub_10037300()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_100B3D60[v2];
      v4 = dword_100B3D5C[v2];
      v5 = dword_100B3D58[v2];
      v6 = sub_1001CB00(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B3D64[v2]],
             *(_DWORD *)&off_100B3D68[v2 * 4]);
      v7 = sub_1001F100(0, dword_100B3D64[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B3D64[v2]],
             *(_DWORD *)&off_100B3D68[v2 * 4]);
      result = sub_1001CE60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B3D58: using guessed type int dword_100B3D58[];
// 100B3D5C: using guessed type int dword_100B3D5C[];
// 100B3D60: using guessed type int dword_100B3D60[];
// 100B3D64: using guessed type int dword_100B3D64[];
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10037460) --------------------------------------------------------
char sub_10037460()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1013DBA1 )
  {
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_10021530(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10058CA9,
           (const char *)&unk_10058CA9,
           0);
    sub_1001CE60(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_10021530(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1001CE60(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_10021530(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10058CA9,
           0);
    sub_1001CE60(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_10021530(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1001CE60(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10037660) --------------------------------------------------------
char sub_10037660()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_100B44F8[v2];
      v4 = dword_100B44F4[v2];
      v5 = dword_100B44F0[v2];
      v6 = sub_1001CB00(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B44FC[v2]],
             (&off_100B4500)[v2 * 4]);
      v7 = sub_1001F4C0(0, dword_100B44FC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B44FC[v2]],
             (&off_100B4500)[v2 * 4]);
      result = sub_1001CE60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B44F0: using guessed type int dword_100B44F0[];
// 100B44F4: using guessed type int dword_100B44F4[];
// 100B44F8: using guessed type int dword_100B44F8[];
// 100B44FC: using guessed type int dword_100B44FC[];
// 100B4500: using guessed type char *off_100B4500;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (100377C0) --------------------------------------------------------
char sub_100377C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_100B4864[v2 / 2];
      v4 = word_100B4862[v2 / 2];
      v5 = word_100B4860[v2 / 2];
      v6 = sub_1001CB00(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B4868[v2 / 4]],
             *(_DWORD *)&off_100B486C[v2]);
      v7 = sub_1001F860(
             0,
             dword_100B4868[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B4868[v2 / 4]],
             *(_DWORD *)&off_100B486C[v2]);
      result = sub_1001CE60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B4860: using guessed type __int16 word_100B4860[];
// 100B4862: using guessed type __int16 word_100B4862[];
// 100B4864: using guessed type __int16 word_100B4864[];
// 100B4868: using guessed type int dword_100B4868[];
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10037920) --------------------------------------------------------
char sub_10037920()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_100B4B28[v2];
      v4 = dword_100B4B24[v2];
      v5 = dword_100B4B20[v2];
      v6 = sub_1001CB00(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B4B2C[v2]],
             (&off_100B4B30)[v2 * 4]);
      v7 = sub_1001FC60(0, dword_100B4B2C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B4B2C[v2]],
             (&off_100B4B30)[v2 * 4]);
      result = sub_1001CE60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B4B20: using guessed type int dword_100B4B20[];
// 100B4B24: using guessed type int dword_100B4B24[];
// 100B4B28: using guessed type int dword_100B4B28[];
// 100B4B2C: using guessed type int dword_100B4B2C[];
// 100B4B30: using guessed type char *off_100B4B30;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10037A80) --------------------------------------------------------
char sub_10037A80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_100B4EA4[v2];
      LODWORD(v3) = dword_100B4EA0[v2];
      HIDWORD(v4) = dword_100B4E9C[v2];
      LODWORD(v4) = dword_100B4E98[v2];
      HIDWORD(v5) = dword_100B4E94[v2];
      LODWORD(v5) = dword_100B4E90[v2];
      v6 = sub_1001CB00(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B4EA8[v2]],
             *(_DWORD *)&off_100B4EAC[v2 * 4]);
      v7 = sub_10020000(0, dword_100B4EA8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B4EA8[v2]],
             *(_DWORD *)&off_100B4EAC[v2 * 4]);
      result = sub_1001CE60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B4E90: using guessed type int dword_100B4E90[];
// 100B4E94: using guessed type int dword_100B4E94[];
// 100B4E98: using guessed type int dword_100B4E98[];
// 100B4E9C: using guessed type int dword_100B4E9C[];
// 100B4EA0: using guessed type int dword_100B4EA0[];
// 100B4EA4: using guessed type int dword_100B4EA4[];
// 100B4EA8: using guessed type int dword_100B4EA8[];
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10037BF0) --------------------------------------------------------
char sub_10037BF0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_100B5412[v2 * 4];
      v4 = byte_100B5411[v2 * 4];
      v5 = byte_100B5410[v2 * 4];
      v6 = sub_1001CB00(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B5414[v2]],
             (&off_100B5418)[v2 * 4]);
      v7 = sub_100205E0(0, dword_100B5414[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B5414[v2]],
             (&off_100B5418)[v2 * 4]);
      result = sub_1001CE60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B5414: using guessed type int dword_100B5414[];
// 100B5418: using guessed type char *off_100B5418;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10037D50) --------------------------------------------------------
char sub_10037D50()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_100B5628[v2];
      v4 = dword_100B5624[v2];
      v5 = dword_100B5620[v2];
      v6 = sub_1001CB00(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B562C[v2]],
             (&off_100B5630)[v2 * 4]);
      v7 = sub_100209D0(0, dword_100B562C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B562C[v2]],
             (&off_100B5630)[v2 * 4]);
      result = sub_1001CE60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B5620: using guessed type int dword_100B5620[];
// 100B5624: using guessed type int dword_100B5624[];
// 100B5628: using guessed type int dword_100B5628[];
// 100B562C: using guessed type int dword_100B562C[];
// 100B5630: using guessed type char *off_100B5630;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10037EB0) --------------------------------------------------------
char sub_10037EB0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1013DBA1 )
  {
    v2 = 0;
    do
    {
      if ( off_100B5994[v2] )
      {
        sub_1001C860((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100B599C[v2 * 4], 0x100u, &v13);
        sub_1001C860((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100B5994[v2], 0x100u, &v14);
        sub_10030FB0(&v14, &v13);
      }
      if ( byte_100B5990[v2 * 4] )
      {
        sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = off_100B5998[v2];
        v4 = *(char **)&off_100B599C[v2 * 4];
        v5 = sub_1001CB00(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100B599C[v2 * 4],
               off_100B5998[v2]);
        v12 = 1;
        v11 = sub_10021180(
                1,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2745",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = off_100B5998[v2];
        v7 = *(char **)&off_100B599C[v2 * 4];
        v8 = sub_1001CB00(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100B599C[v2 * 4],
               off_100B5998[v2]);
        v12 = 1;
        v11 = sub_10021180(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2754",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_1001CE60(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B5994: using guessed type char *off_100B5994[3];
// 100B5998: using guessed type char *off_100B5998[2];
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (100380C0) --------------------------------------------------------
char sub_100380C0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_1013DBA1 )
  {
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_1001CE60(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1001CE60(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_1001CE60(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1001CE60(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_1001CE60(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1001CE60(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_1001CE60(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1001CE60(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (100382B0) --------------------------------------------------------
char sub_100382B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B59E4[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_100B59E1[v2 * 4];
        v4 = byte_100B59E0[v2 * 4];
        v5 = sub_1001CB00(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100A4EE8[4 * dword_100B59E4[v2]],
               (&off_100B59E8)[v2 * 4]);
        v6 = sub_1001CFA0(1, dword_100B59E4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_1001CB00(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100A4EE8[4 * dword_100B59E4[v2]],
               (&off_100B59E8)[v2 * 4]);
        LOBYTE(v0) = sub_1001CE60(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1001C0A0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100B59E4: using guessed type int dword_100B59E4[];
// 100B59E8: using guessed type char *off_100B59E8;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10038420) --------------------------------------------------------
char sub_10038420()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_100B5C60[v2 / 2];
      v4 = dbl_100B5C58[v2 / 2];
      v5 = dbl_100B5C50[v2 / 2];
      v6 = sub_1001CB00(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B5C68[v2]],
             *(_DWORD *)&off_100B5C6C[v2 * 4]);
      v7 = sub_1001D350(1, dword_100B5C68[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B5C68[v2]],
             *(_DWORD *)&off_100B5C6C[v2 * 4]);
      result = sub_1001CE60(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B5C50: using guessed type double dbl_100B5C50[];
// 100B5C58: using guessed type double dbl_100B5C58[];
// 100B5C60: using guessed type double dbl_100B5C60[];
// 100B5C68: using guessed type int dword_100B5C68[];
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10038590) --------------------------------------------------------
char sub_10038590()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_100B6878[v2];
      v4 = flt_100B6874[v2];
      v5 = flt_100B6870[v2];
      v6 = sub_1001CB00(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B687C[v2]],
             (&off_100B6880)[v2 * 4]);
      v7 = sub_1001D7A0(1, dword_100B687C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B687C[v2]],
             (&off_100B6880)[v2 * 4]);
      result = sub_1001CE60(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B6870: using guessed type float flt_100B6870[];
// 100B6874: using guessed type float flt_100B6874[];
// 100B6878: using guessed type float flt_100B6878[];
// 100B687C: using guessed type int dword_100B687C[];
// 100B6880: using guessed type char *off_100B6880;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (100386F0) --------------------------------------------------------
char sub_100386F0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1013DBA1 )
  {
    sub_10021480(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_100386F0,
      (int)sub_100386F0,
      0);
    sub_10021480(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_100386F0,
      0,
      0);
    result = sub_10021480(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_100386F0,
               0);
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (100387E0) --------------------------------------------------------
char sub_100387E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_100B7010[v2];
      v4 = dword_100B700C[v2];
      v5 = dword_100B7008[v2];
      v6 = sub_1001CB00(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B7014[v2]],
             *(_DWORD *)&off_100B7018[v2 * 4]);
      v7 = sub_1001DC60(1, dword_100B7014[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B7014[v2]],
             *(_DWORD *)&off_100B7018[v2 * 4]);
      result = sub_1001CE60(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B7008: using guessed type int dword_100B7008[];
// 100B700C: using guessed type int dword_100B700C[];
// 100B7010: using guessed type int dword_100B7010[];
// 100B7014: using guessed type int dword_100B7014[];
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10038940) --------------------------------------------------------
char sub_10038940()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_100B77A4[v2 / 2];
      v4 = word_100B77A2[v2 / 2];
      v5 = word_100B77A0[v2 / 2];
      v6 = sub_1001CB00(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B77A8[v2 / 4]],
             *(_DWORD *)&off_100B77AC[v2]);
      v7 = sub_1001E020(
             1,
             dword_100B77A8[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B77A8[v2 / 4]],
             *(_DWORD *)&off_100B77AC[v2]);
      result = sub_1001CE60(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B77A0: using guessed type __int16 word_100B77A0[];
// 100B77A2: using guessed type __int16 word_100B77A2[];
// 100B77A4: using guessed type __int16 word_100B77A4[];
// 100B77A8: using guessed type int dword_100B77A8[];
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10038AA0) --------------------------------------------------------
char sub_10038AA0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_100B7DB8[v2];
      v4 = dword_100B7DB4[v2];
      v5 = dword_100B7DB0[v2];
      v6 = sub_1001CB00(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B7DBC[v2]],
             (&off_100B7DC0)[v2 * 4]);
      v7 = sub_1001E420(1, dword_100B7DBC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B7DBC[v2]],
             (&off_100B7DC0)[v2 * 4]);
      result = sub_1001CE60(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B7DB0: using guessed type int dword_100B7DB0[];
// 100B7DB4: using guessed type int dword_100B7DB4[];
// 100B7DB8: using guessed type int dword_100B7DB8[];
// 100B7DBC: using guessed type int dword_100B7DBC[];
// 100B7DC0: using guessed type char *off_100B7DC0;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10038C00) --------------------------------------------------------
char sub_10038C00()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_100B855C[v2];
      LODWORD(v3) = dword_100B8558[v2];
      HIDWORD(v4) = dword_100B8554[v2];
      LODWORD(v4) = dword_100B8550[v2];
      HIDWORD(v5) = dword_100B854C[v2];
      LODWORD(v5) = dword_100B8548[v2];
      v6 = sub_1001CB00(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B8560[v2]],
             (&off_100B8564)[v2 * 4]);
      v7 = sub_1001E7E0(1, dword_100B8560[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B8560[v2]],
             (&off_100B8564)[v2 * 4]);
      result = sub_1001CE60(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B8548: using guessed type int dword_100B8548[];
// 100B854C: using guessed type int dword_100B854C[];
// 100B8550: using guessed type int dword_100B8550[];
// 100B8554: using guessed type int dword_100B8554[];
// 100B8558: using guessed type int dword_100B8558[];
// 100B855C: using guessed type int dword_100B855C[];
// 100B8560: using guessed type int dword_100B8560[];
// 100B8564: using guessed type char *off_100B8564;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10038D70) --------------------------------------------------------
char sub_10038D70()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_100B916A[v2 * 4];
      v4 = byte_100B9169[v2 * 4];
      v5 = byte_100B9168[v2 * 4];
      v6 = sub_1001CB00(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B916C[v2]],
             (&off_100B9170)[v2 * 4]);
      v7 = sub_1001ED20(1, dword_100B916C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B916C[v2]],
             (&off_100B9170)[v2 * 4]);
      result = sub_1001CE60(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B916C: using guessed type int dword_100B916C[];
// 100B9170: using guessed type char *off_100B9170;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10038ED0) --------------------------------------------------------
char sub_10038ED0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_100B9600[v2];
      v4 = dword_100B95FC[v2];
      v5 = dword_100B95F8[v2];
      v6 = sub_1001CB00(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B9604[v2]],
             *(_DWORD *)&off_100B9608[v2 * 4]);
      v7 = sub_1001F100(1, dword_100B9604[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B9604[v2]],
             *(_DWORD *)&off_100B9608[v2 * 4]);
      result = sub_1001CE60(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B95F8: using guessed type int dword_100B95F8[];
// 100B95FC: using guessed type int dword_100B95FC[];
// 100B9600: using guessed type int dword_100B9600[];
// 100B9604: using guessed type int dword_100B9604[];
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10039030) --------------------------------------------------------
char sub_10039030()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1001C0A0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1001C9F0(0);
  sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_1001C0A0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1013DBA1 )
  {
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_10021530(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10058CA9,
           (const char *)&unk_10058CA9,
           0);
    sub_1001CE60(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_10021530(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1001CE60(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_10021530(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10058CA9,
           0);
    sub_1001CE60(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_10021530(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1001CE60(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10039230) --------------------------------------------------------
char sub_10039230()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_100B9D98[v2];
      v4 = dword_100B9D94[v2];
      v5 = dword_100B9D90[v2];
      v6 = sub_1001CB00(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B9D9C[v2]],
             (&off_100B9DA0)[v2 * 4]);
      v7 = sub_1001F4C0(1, dword_100B9D9C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100B9D9C[v2]],
             (&off_100B9DA0)[v2 * 4]);
      result = sub_1001CE60(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100B9D90: using guessed type int dword_100B9D90[];
// 100B9D94: using guessed type int dword_100B9D94[];
// 100B9D98: using guessed type int dword_100B9D98[];
// 100B9D9C: using guessed type int dword_100B9D9C[];
// 100B9DA0: using guessed type char *off_100B9DA0;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10039390) --------------------------------------------------------
char sub_10039390()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_100BA104[v2 / 2];
      v4 = word_100BA102[v2 / 2];
      v5 = word_100BA100[v2 / 2];
      v6 = sub_1001CB00(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100BA108[v2 / 4]],
             *(_DWORD *)&off_100BA10C[v2]);
      v7 = sub_1001F860(
             1,
             dword_100BA108[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100BA108[v2 / 4]],
             *(_DWORD *)&off_100BA10C[v2]);
      result = sub_1001CE60(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BA100: using guessed type __int16 word_100BA100[];
// 100BA102: using guessed type __int16 word_100BA102[];
// 100BA104: using guessed type __int16 word_100BA104[];
// 100BA108: using guessed type int dword_100BA108[];
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (100394F0) --------------------------------------------------------
char sub_100394F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_100BA3C8[v2];
      v4 = dword_100BA3C4[v2];
      v5 = dword_100BA3C0[v2];
      v6 = sub_1001CB00(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100BA3CC[v2]],
             (&off_100BA3D0)[v2 * 4]);
      v7 = sub_1001FC60(1, dword_100BA3CC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100BA3CC[v2]],
             (&off_100BA3D0)[v2 * 4]);
      result = sub_1001CE60(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BA3C0: using guessed type int dword_100BA3C0[];
// 100BA3C4: using guessed type int dword_100BA3C4[];
// 100BA3C8: using guessed type int dword_100BA3C8[];
// 100BA3CC: using guessed type int dword_100BA3CC[];
// 100BA3D0: using guessed type char *off_100BA3D0;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10039650) --------------------------------------------------------
char sub_10039650()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_100BA744[v2];
      LODWORD(v3) = dword_100BA740[v2];
      HIDWORD(v4) = dword_100BA73C[v2];
      LODWORD(v4) = dword_100BA738[v2];
      HIDWORD(v5) = dword_100BA734[v2];
      LODWORD(v5) = dword_100BA730[v2];
      v6 = sub_1001CB00(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100BA748[v2]],
             *(_DWORD *)&off_100BA74C[v2 * 4]);
      v7 = sub_10020000(1, dword_100BA748[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100BA748[v2]],
             *(_DWORD *)&off_100BA74C[v2 * 4]);
      result = sub_1001CE60(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BA730: using guessed type int dword_100BA730[];
// 100BA734: using guessed type int dword_100BA734[];
// 100BA738: using guessed type int dword_100BA738[];
// 100BA73C: using guessed type int dword_100BA73C[];
// 100BA740: using guessed type int dword_100BA740[];
// 100BA744: using guessed type int dword_100BA744[];
// 100BA748: using guessed type int dword_100BA748[];
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (100397C0) --------------------------------------------------------
char sub_100397C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_100BACB2[v2 * 4];
      v4 = byte_100BACB1[v2 * 4];
      v5 = byte_100BACB0[v2 * 4];
      v6 = sub_1001CB00(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100BACB4[v2]],
             (&off_100BACB8)[v2 * 4]);
      v7 = sub_100205E0(1, dword_100BACB4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100BACB4[v2]],
             (&off_100BACB8)[v2 * 4]);
      result = sub_1001CE60(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BACB4: using guessed type int dword_100BACB4[];
// 100BACB8: using guessed type char *off_100BACB8;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10039920) --------------------------------------------------------
char sub_10039920()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1013DBA1 )
  {
    sub_1001C0A0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1001C9F0(0);
    sub_1001C0A0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_1001C0A0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1001CAE0(0);
    v2 = 0;
    do
    {
      sub_1001CA10((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_100BAEC8[v2];
      v4 = dword_100BAEC4[v2];
      v5 = dword_100BAEC0[v2];
      v6 = sub_1001CB00(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100A4EE8[4 * dword_100BAECC[v2]],
             (&off_100BAED0)[v2 * 4]);
      v7 = sub_100209D0(1, dword_100BAECC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001CB00(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100A4EE8[4 * dword_100BAECC[v2]],
             (&off_100BAED0)[v2 * 4]);
      result = sub_1001CE60(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1001C0A0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BAEC0: using guessed type int dword_100BAEC0[];
// 100BAEC4: using guessed type int dword_100BAEC4[];
// 100BAEC8: using guessed type int dword_100BAEC8[];
// 100BAECC: using guessed type int dword_100BAECC[];
// 100BAED0: using guessed type char *off_100BAED0;
// 1013DBA1: using guessed type char byte_1013DBA1;

//----- (10039A80) --------------------------------------------------------
char **sub_10039A80()
{
  return off_100A65D4;
}
// 100A65D4: using guessed type char *off_100A65D4[3];

//----- (10039A90) --------------------------------------------------------
int __cdecl sub_10039A90(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (10039AB0) --------------------------------------------------------
int (__cdecl *__usercall sub_10039AB0@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (10039AC0) --------------------------------------------------------
int __usercall sub_10039AC0@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (10039CF0) --------------------------------------------------------
int (__cdecl *__cdecl sub_10039CF0(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_10039AB0(a1, (int)" ");
  sub_10039AB0(a1, a2);
  sub_10039AB0(a1, (int)&unk_100BF124);
  v3 = sub_10039AC0(a3, a1);
  sub_10039AB0(a1, v3);
  return sub_10039AB0(a1, (int)&unk_100BF120);
}

//----- (10039D40) --------------------------------------------------------
int (__cdecl *__cdecl sub_10039D40(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_10039AB0(a1, (int)" ");
  sub_10039AB0(a1, a2);
  sub_10039AB0(a1, (int)&unk_100BF12C);
  v3 = sub_10039AC0(a3, a1);
  sub_10039AB0(a1, v3);
  return sub_10039AB0(a1, (int)&unk_100BF128);
}

//----- (10039D90) --------------------------------------------------------
int (__cdecl *__cdecl sub_10039D90(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_10039AB0(a1, (int)&unk_100BF130);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_10039AC0(a2, a1);
    result = sub_10039AB0(a1, v3);
  }
  return result;
}

//----- (10039DE0) --------------------------------------------------------
int (__cdecl *__cdecl sub_10039DE0(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_100BF138;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_10039AB0(a1, dword_100BF08C[(signed int)result]);
      sub_10039AB0(a1, (int)&unk_100BF134);
      sub_10039AB0(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_100BF130;
    }
    result = sub_10039AB0(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_10039AB0(a1, (int)&word_1008ED6C);
  }
  return result;
}
// 1008ED6C: using guessed type __int16 word_1008ED6C;
// 100BF08C: using guessed type int dword_100BF08C[];

//----- (10039E60) --------------------------------------------------------
int __cdecl sub_10039E60(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_10039AB0(a1, (int)&unk_100BF130);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_10039AB0(a1, *((_DWORD *)&off_100BF090 + *(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84)));
  sub_10039AB0(a1, (int)&unk_100BF13C);
  sub_10039AB0(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}

//----- (10039EE0) --------------------------------------------------------
int (__cdecl *__cdecl sub_10039EE0(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_10039AC0(a2, a1);
    sub_10039AB0(a1, v3);
    result = sub_10039AB0(a1, (int)&word_1008ED6C);
  }
  else
  {
    sub_10039AB0(a1, (int)a2);
    result = sub_10039AB0(a1, (int)&word_1008ED6C);
  }
  return result;
}
// 1008ED6C: using guessed type __int16 word_1008ED6C;

//----- (10039F30) --------------------------------------------------------
int (__cdecl *__cdecl sub_10039F30(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_10039E60(a1, a2);
  if ( a3 && *a3 )
    sub_10039D90(a1, a3);
  return sub_10039DE0(a1);
}

//----- (10039F70) --------------------------------------------------------
int (__cdecl *__cdecl sub_10039F70(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_10039F30(a1, a2, (unsigned __int8 *)&v4);
}

//----- (10039FD0) --------------------------------------------------------
char sub_10039FD0()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_10004370(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 10039FD0: using guessed type int var_1C[7];

//----- (1003A050) --------------------------------------------------------
char __cdecl sub_1003A050(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_10003E50("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (1003A090) --------------------------------------------------------
int __cdecl sub_1003A090(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10019830(&a1, 1u, (int)&unk_100C1A00, 8, 67, 0);
  if ( v1 )
  {
    result = dword_100C1A04[2 * v1];
  }
  else
  {
    sub_10003E50("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 100C1A04: using guessed type int dword_100C1A04[];

//----- (1003A0E0) --------------------------------------------------------
bool __cdecl sub_1003A0E0(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_10019830(&a2, 4u, (int)&dword_100C2BE8, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_100042D0((unsigned __int16)word_100C2BEC[a1 + 6 * v3], a3, (unsigned __int16)word_100C2BF0[6 * v3]) == 0;
  }
  else
  {
    sub_10003E50("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 100C2BE8: using guessed type int dword_100C2BE8;
// 100C2BEC: using guessed type __int16 word_100C2BEC[];
// 100C2BF0: using guessed type __int16 word_100C2BF0[];

//----- (1003A170) --------------------------------------------------------
bool __cdecl sub_1003A170(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_1003A210(a1);
  v6 = sub_10019830(&a3, 1u, (int)&unk_100C2C0C, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_10019830(&dword_100C2C10[2 * v6], 4u, (int)&dword_100C2BE8, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_100C2BF0[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_1003A0E0(v11, *(int *)((char *)&dword_100C2BE8 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100C2BE8: using guessed type int dword_100C2BE8;
// 100C2BF0: using guessed type __int16 word_100C2BF0[];

//----- (1003A210) --------------------------------------------------------
char __cdecl sub_1003A210(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_10003E50("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (1003A290) --------------------------------------------------------
char __cdecl sub_1003A290(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_10024A00(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_100042D0(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_10024A20((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (1003A400) --------------------------------------------------------
int __usercall sub_1003A400@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_1003A290(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 1003A400: using guessed type int var_2C[10];

//----- (1003A440) --------------------------------------------------------
int __usercall sub_1003A440@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_1003A290(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 1003A440: using guessed type int var_14[4];

//----- (1003A480) --------------------------------------------------------
signed int sub_1003A480()
{
  return sub_100053E0((int)&off_100C4AB0);
}
// 100C4AB0: using guessed type char *off_100C4AB0;

//----- (1003A490) --------------------------------------------------------
char __cdecl sub_1003A490(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_1003A480() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_101D822C + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_101D822C + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_101D822C);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101D822C: using guessed type int dword_101D822C;

//----- (1003A4F0) --------------------------------------------------------
char __cdecl sub_1003A4F0(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_1003A480() )
  {
    if ( (sub_10024A40(a1)
       || *(_BYTE *)(dword_101D822C + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_101D822C + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_101D822C + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101D822C + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101D822C + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101D822C + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101D822C + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101D822C + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101D822C + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101D822C + 176))
      && *(_BYTE *)(dword_101D822C + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_101D822C + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_101D822C + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_101D822C + 162) )
    {
      qmemcpy(a2, (const void *)(dword_101D822C + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101D822C: using guessed type int dword_101D822C;

//----- (1003A610) --------------------------------------------------------
char __cdecl sub_1003A610(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_1003A480() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_101D822C + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_101D822C + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_101D822C + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_101D822C + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_101D822C);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101D822C: using guessed type int dword_101D822C;

//----- (1003A690) --------------------------------------------------------
char __cdecl sub_1003A690(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_10003E50("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_1003A440(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_1003A610(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_10003E50("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_1003A400(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_1003A490(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_10003E50("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_1003A290(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_1003A4F0(v6, a5);
        }
      }
      else
      {
        sub_10003E50("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10003E50("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1003A840) --------------------------------------------------------
char sub_1003A840()
{
  return 2;
}

//----- (1003A850) --------------------------------------------------------
int __cdecl sub_1003A850(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (1003A870) --------------------------------------------------------
char __cdecl sub_1003A870(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9)
{
  char *v9; // eax@1
  char v10; // cl@2
  __int16 v12; // [sp+0h] [bp-52Ch]@1
  char v13; // [sp+4h] [bp-528h]@1
  char v14; // [sp+5h] [bp-527h]@1
  char v15; // [sp+6h] [bp-526h]@1
  char v16; // [sp+7h] [bp-525h]@1
  char v17; // [sp+8h] [bp-524h]@1
  char v18; // [sp+9h] [bp-523h]@1
  __int16 v19; // [sp+Ah] [bp-522h]@1
  int v20; // [sp+Ch] [bp-520h]@1
  char v21[1300]; // [sp+14h] [bp-518h]@2

  memset(&v12, 0, 0x528u);
  v15 = a4;
  v20 = a6;
  v16 = a3;
  v13 = a1;
  v9 = a9;
  v17 = a5;
  v14 = a2;
  v12 = -32708;
  v18 = a7;
  v19 = a8;
  if ( a9 )
  {
    do
    {
      v10 = *v9;
      v9[v21 - a9] = *v9;
      ++v9;
    }
    while ( v10 );
  }
  return sub_10026DB0((int)&v12);
}
// 1003A870: using guessed type char var_518[1300];

//----- (1003A940) --------------------------------------------------------
unsigned int __usercall sub_1003A940@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  int v2; // ebp@1
  char v3; // dl@1
  int v4; // ecx@5
  int v5; // esi@5
  float *v6; // edx@6
  _BYTE *v7; // edx@11
  char *v8; // ecx@11
  char v9; // al@12
  int v10; // eax@14
  int v11; // edi@16
  char *v12; // eax@16
  long double v13; // ST28_8@19
  long double v14; // st6@19
  int v15; // edi@19
  char *v16; // eax@21
  _BYTE *v17; // esi@21
  char v18; // cl@22
  unsigned int result; // eax@23
  _BYTE *v20; // edi@23
  char v21; // cl@24
  const void *v22; // ebx@25
  char *v23; // eax@28
  char v24; // cl@29
  char v25; // cl@31
  char *v26; // eax@34
  _BYTE *v27; // edx@34
  char v28; // cl@35
  _BYTE *v29; // edi@36
  char v30; // cl@37
  __int32 v31; // [sp+18h] [bp-8h]@17

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 32);
  v3 = 0;
  if ( *(_BYTE *)v2 <= 1u )
    v3 = 1;
  if ( 9.8999998e24 == *(float *)a1 )
    goto LABEL_10;
  if ( !v3 )
  {
    v4 = *(_BYTE *)v2 - 1;
    v5 = 0;
    if ( v4 > 0 )
    {
      v6 = (float *)(v2 + 44);
      while ( *(v6 - 5) > (double)*(float *)a1 || *v6 <= (double)*(float *)a1 )
      {
        ++v5;
        v6 += 5;
        if ( v5 >= v4 )
          goto LABEL_10;
      }
      v10 = v5 + 1;
      if ( *(float *)v1 >= 0.0 )
        v10 = v5;
      v11 = 20 * v10;
      sprintf(*(char **)(v1 + 36), (const char *)(20 * v10 + v2 + 28), *(float *)v1);
      v12 = strrchr((const char *)(v11 + *(_DWORD *)(v1 + 32) + 28), 46);
      if ( v12 )
        v31 = j__atol(v12 + 1);
      else
        v31 = 0;
      v13 = pow(10.0, (double)v31);
      v14 = atof((const char *)*(_DWORD *)(v1 + 36)) * v13;
      v15 = *(_DWORD *)(v1 + 32);
      if ( (signed int)v14 != (signed int)(v13 * *(float *)(v15 + 20 * v5 + 24)) )
        ++v5;
      sprintf(*(char **)(v1 + 36), (const char *)(v15 + 20 * v5 + 28), *(float *)v1);
      v16 = (char *)(*(_DWORD *)(v1 + 32) + 11);
      v17 = (_BYTE *)(*(_DWORD *)(v1 + 32) + 11);
      do
        v18 = *v16++;
      while ( v18 );
      result = v16 - v17;
      v20 = (_BYTE *)(*(_DWORD *)(v1 + 36) - 1);
      do
        v21 = (v20++)[1];
      while ( v21 );
      goto LABEL_25;
    }
LABEL_10:
    if ( *(_DWORD *)(a1 + 40) )
    {
      memset(*(void **)(a1 + 36), 95, *(_DWORD *)(a1 + 40));
      *(_BYTE *)(*(_DWORD *)(v1 + 40) + *(_DWORD *)(v1 + 36)) = 0;
    }
    else
    {
      v7 = *(_BYTE **)(a1 + 36);
      v8 = (char *)(v2 + 1);
      do
      {
        v9 = *v8;
        *v7++ = *v8++;
      }
      while ( v9 );
    }
    v26 = (char *)(*(_DWORD *)(v1 + 32) + 11);
    v27 = (_BYTE *)(*(_DWORD *)(v1 + 32) + 11);
    do
      v28 = *v26++;
    while ( v28 );
    result = v26 - v27;
    v29 = (_BYTE *)(*(_DWORD *)(v1 + 36) - 1);
    do
      v30 = (v29++)[1];
    while ( v30 );
    qmemcpy(v29, v27, result);
    return result;
  }
  sprintf(*(char **)(a1 + 36), (const char *)(v2 + 28), *(float *)a1);
  v23 = (char *)(*(_DWORD *)(v1 + 32) + 11);
  v17 = (_BYTE *)(*(_DWORD *)(v1 + 32) + 11);
  do
    v24 = *v23++;
  while ( v24 );
  result = v23 - v17;
  v20 = (_BYTE *)(*(_DWORD *)(v1 + 36) - 1);
  do
    v25 = (v20++)[1];
  while ( v25 );
LABEL_25:
  qmemcpy(v20, v17, result);
  v22 = *(const void **)(v1 + 36);
  if ( !memcmp(v22, &unk_1008A710, 3u) )
    *(_WORD *)v22 = 48;
  return result;
}

//----- (1003AB80) --------------------------------------------------------
char __cdecl sub_1003AB80(int a1, int a2, int a3, int a4, __int16 *a5)
{
  int v5; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  signed int v8; // ecx@1
  signed int v9; // edx@1
  __int16 v10; // ax@1
  float v12; // [sp+4h] [bp-24h]@1
  float v13; // [sp+8h] [bp-20h]@1
  int v14; // [sp+Ch] [bp-1Ch]@1
  float v15; // [sp+10h] [bp-18h]@1
  int v16; // [sp+14h] [bp-14h]@1
  int v17; // [sp+18h] [bp-10h]@1
  float v18; // [sp+1Ch] [bp-Ch]@1
  float v19; // [sp+20h] [bp-8h]@1
  float v20; // [sp+24h] [bp-4h]@1

  v5 = *(_DWORD *)(a4 + 8);
  v6 = *(_DWORD *)(a4 + 4);
  v15 = *(float *)(a4 + 12);
  v7 = *(_DWORD *)(a4 + 20);
  v18 = *(float *)(a4 + 24);
  v16 = v5;
  v19 = *(float *)(a4 + 28);
  v17 = v6;
  v8 = *(_WORD *)a3;
  v20 = *(float *)(a4 + 16);
  v14 = v7;
  v9 = *(_WORD *)(a3 + 2);
  v12 = (double)v8;
  v10 = *a5;
  v13 = (double)v9;
  if ( v10 == -32648 || v10 == -32734 || v10 == -32704 )
    sub_1003A940(a4);
  if ( (unsigned __int16)*a5 != 32802 )
  {
    if ( (unsigned __int16)*a5 == 32832 )
    {
      sub_100120D0(a1, *(_DWORD *)(a4 + 36), (int)&v12);
      return 2;
    }
    if ( (unsigned __int16)*a5 != 32888 )
      return 1;
  }
  sub_100124E0(a1, *(_DWORD *)(a4 + 36), (int)&v12);
  return 2;
}

//----- (1003AC60) --------------------------------------------------------
int __cdecl sub_1003AC60(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_100C7D9C[2 * sub_10019830(&a1, 1u, (int)&unk_100C7D98, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_100C7DDC[2 * sub_10019830(&a2, 1u, (int)&unk_100C7DD8, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_100C7E0C[2 * sub_10019830(&a2, 1u, (int)&unk_100C7E08, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_100C7DB4[2 * sub_10019830(&a2, 1u, (int)&unk_100C7DB0, 8, 5, 5)];
  }
  return result;
}
// 100C7D9C: using guessed type int dword_100C7D9C[];
// 100C7DB4: using guessed type int dword_100C7DB4[];
// 100C7DDC: using guessed type int dword_100C7DDC[];
// 100C7E0C: using guessed type int dword_100C7E0C[];

//----- (1003AD10) --------------------------------------------------------
bool __usercall sub_1003AD10@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_100CC31F[44 * a1] - (unsigned __int8)byte_100CC31A[44 * a1];
}

//----- (1003AD40) --------------------------------------------------------
char __usercall sub_1003AD40@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_1003AD10(a1, a4, a5) )
  {
    v6 = a3
       + sub_1003AC60(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_100CC31A[44 * a1] - (unsigned __int8)byte_100CC31F[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_1003AC60(a1, a4);
    memcpy(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (1003ADE0) --------------------------------------------------------
char __cdecl sub_1003ADE0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_100306C0(a1);
  sub_100042F0(v5, (int)&v7, 3684);
  return sub_1003AD40(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (1003AE60) --------------------------------------------------------
char __cdecl sub_1003AE60(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_100306C0(a1);
  sub_100042F0(v5, (int)&v7, 3684);
  return sub_1003AD40(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (1003AEE0) --------------------------------------------------------
char __cdecl sub_1003AEE0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_100306C0(a1);
  sub_100042F0(v5, (int)&v7, 3684);
  return sub_1003AD40(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (1003AF60) --------------------------------------------------------
char __cdecl sub_1003AF60(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_100306C0(a1);
  sub_100042F0(v5, (int)&v7, 3684);
  return sub_1003AD40(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (1003AFE0) --------------------------------------------------------
char __cdecl sub_1003AFE0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_10003E50("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1003B080) --------------------------------------------------------
int __cdecl sub_1003B080(char a1)
{
  return sub_10019830(&a1, 1u, (int)"7", 8, 2, 2);
}

//----- (1003B0A0) --------------------------------------------------------
BOOL __cdecl sub_1003B0A0(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_1003A090(a1);
  return sub_10016260(0, 604, a2) && sub_10015C30(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (1003B100) --------------------------------------------------------
int __usercall sub_1003B100@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_1003B080(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_100C7EC4[2 * v1];
  return result;
}
// 100C7EC4: using guessed type int dword_100C7EC4[];

//----- (1003B130) --------------------------------------------------------
BOOL __cdecl sub_1003B130(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1003B100(a1);
  return sub_100042D0(v2, a2, 16) == 0;
}

//----- (1003B160) --------------------------------------------------------
int __cdecl sub_1003B160(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_1003B130(a1, (int)a5);
  else
    result = sub_1003B0A0(a1, a5);
  return result;
}

//----- (1003B190) --------------------------------------------------------
char __cdecl sub_1003B190(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_10016290(1, 1947, a1, (int)&v3);
}

//----- (1003B1B0) --------------------------------------------------------
BOOL __cdecl sub_1003B1B0(int a1)
{
  return sub_100042D0(6792, a1, 284) == 0;
}

//----- (1003B1D0) --------------------------------------------------------
char __cdecl sub_1003B1D0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_1003B1B0((int)a5);
  else
    result = sub_1003B190(a5);
  return result;
}

//----- (1003B200) --------------------------------------------------------
bool __cdecl sub_1003B200(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_100042D0((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (1003B240) --------------------------------------------------------
signed int __usercall sub_1003B240@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (1003B260) --------------------------------------------------------
bool __cdecl sub_1003B260(char a1, void *a2)
{
  int v2; // esi@1
  bool result; // al@5
  void *v4; // ecx@6
  int v5; // [sp+Ch] [bp-28h]@4
  char v6; // [sp+10h] [bp-24h]@2
  int v7; // [sp+24h] [bp-10h]@3
  __int16 v8; // [sp+28h] [bp-Ch]@8
  int v9; // [sp+2Ch] [bp-8h]@8

  v2 = sub_1003B240(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2
    && sub_10015C30(1, 0x6ACu, (int)&v6)
    && v7 == v2
    && sub_10016290(1, 1708, a2, (int)&v5) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_1003B200(a1, a2);
  }
  else
  {
    v9 = sub_10015220(v4);
    v8 = 1708;
    sub_10015D90(1, 0, &v8, 0, 8, 1);
    sub_10015ED0(1, 0, v2);
    result = 0;
  }
  return result;
}
// 10004AA0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 10004AC0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1003B350) --------------------------------------------------------
bool __cdecl sub_1003B350(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_1003B200(a1, a5);
  else
    result = sub_1003B260(a1, a5);
  return result;
}

//----- (1003B380) --------------------------------------------------------
char __cdecl sub_1003B380(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_101A0190, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10003E50("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_100249D0(a1, (int)byte_101A0190);
    v3 = 4 * a2 - 64;
    v4 = byte_101A0191[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_101A0190[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (1003B420) --------------------------------------------------------
bool __cdecl sub_1003B420(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_101A0190, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10003E50("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_100249D0(a1, (int)byte_101A0190);
    v3 = (char *)&unk_101A0230 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (1003B4A0) --------------------------------------------------------
char __cdecl sub_1003B4A0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_101A0190, 0, 0x890u);
  sub_100249D0(a1, (int)byte_101A0190);
  if ( a2 > 0x10u )
  {
    sub_10003E50("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_101A0500[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_101A0504[2 * a2];
    result = 1;
  }
  return result;
}
// 101A0500: using guessed type int dword_101A0500[];
// 101A0504: using guessed type int dword_101A0504[];

//----- (1003B510) --------------------------------------------------------
char __cdecl sub_1003B510(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_10016260(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_10016260(0, 572, a2);
    }
    else
    {
      sub_10003E50("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_10016260(0, 226, a2);
  }
  return result;
}

//----- (1003B590) --------------------------------------------------------
char __cdecl sub_1003B590(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_101A0190, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10003E50("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1003B510(a1, byte_101A0190);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_101A0191[v4];
    *(_BYTE *)a3 = byte_101A0190[v4];
  }
  return result;
}

//----- (1003B610) --------------------------------------------------------
char __cdecl sub_1003B610(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_101A0190, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10003E50("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1003B510(a1, byte_101A0190);
    v4 = (char *)&unk_101A0230 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (1003B690) --------------------------------------------------------
char __cdecl sub_1003B690(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_101A0190, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_1003B510(a1, byte_101A0190);
    *(_DWORD *)a3 = dword_101A0500[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_101A0504[2 * a2];
  }
  else
  {
    sub_10003E50("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 101A0500: using guessed type int dword_101A0500[];
// 101A0504: using guessed type int dword_101A0504[];

//----- (1003B700) --------------------------------------------------------
char __cdecl sub_1003B700(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1003C560(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_1003B4A0(v6, *a4, a5);
    else
      result = sub_1003B690(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_1003B380(v6, *a4, a5);
    else
      result = sub_1003B590(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_10003E50("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_1003B420(v6, *a4, a5);
    else
      result = sub_1003B610(v6, *a4, a5);
  }
  return result;
}

//----- (1003B810) --------------------------------------------------------
char __cdecl sub_1003B810(char a1, void *a2)
{
  return sub_10016260(6, (unsigned __int16)word_100C8EFA[8 * (unsigned __int8)a1], a2);
}
// 100C8EFA: using guessed type __int16 word_100C8EFA[];

//----- (1003B830) --------------------------------------------------------
bool __cdecl sub_1003B830(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_100042D0(dword_100C8F00[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 100C8F00: using guessed type int dword_100C8F00[];

//----- (1003B870) --------------------------------------------------------
char __cdecl sub_1003B870(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1003C5A0(a1);
  if ( a2 )
    result = sub_1003B830(v6, (char *)a5);
  else
    result = sub_1003B810(v6, a5);
  return result;
}

//----- (1003B8B0) --------------------------------------------------------
BOOL sub_1003B8B0()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_100256B0(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (1003B910) --------------------------------------------------------
char __cdecl sub_1003B910(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_10016260(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_1003B8B0() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_100265D0((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (1003BA00) --------------------------------------------------------
BOOL __cdecl sub_1003BA00(int a1, int a2)
{
  return sub_100042D0(6200, a2, 60) == 0;
}

//----- (1003BA20) --------------------------------------------------------
char __cdecl sub_1003BA20(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1003BA00(a1, (int)a5);
  }
  else
  {
    result = sub_1003B910(a1, a5);
  }
  return result;
}

//----- (1003BA60) --------------------------------------------------------
char __cdecl sub_1003BA60(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_10016260(2, 284, &v6) || sub_100267A0((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (1003BB10) --------------------------------------------------------
BOOL __cdecl sub_1003BB10(int a1, int a2)
{
  return sub_100042D0(6169, a2, 40) == 0;
}

//----- (1003BB30) --------------------------------------------------------
char __cdecl sub_1003BB30(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1003BB10(a1, a5);
  }
  else
  {
    result = sub_1003BA60(a1, a5);
  }
  return result;
}

//----- (1003BB70) --------------------------------------------------------
char __cdecl sub_1003BB70(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_10016260(2, 363, a1);
}

//----- (1003BB90) --------------------------------------------------------
char __cdecl sub_1003BB90(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_100042D0(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (1003BCE0) --------------------------------------------------------
char __cdecl sub_1003BCE0(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_1003BB90(a5);
      else
        result = sub_1003BB70(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_1003BB90(&unk_101A0A20);
      else
        v7 = sub_1003BB70(&unk_101A0A20);
      v8 = v7;
      memcpy(a5, (char *)&unk_101A0A20 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_1003BB90(&unk_101A0A20);
      else
        v9 = sub_1003BB70(&unk_101A0A20);
      v10 = v9;
      memcpy(a5, (char *)&unk_101A3928 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_1003BB90(&unk_101A0A20);
      else
        v11 = sub_1003BB70(&unk_101A0A20);
      v12 = v11;
      memcpy(a5, (char *)&unk_101A3E28 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_1003BB90(&unk_101A0A20);
      else
        v13 = sub_1003BB70(&unk_101A0A20);
      v14 = v13;
      memcpy(a5, &unk_101A3ED0, a6);
      result = v14;
      break;
    default:
      sub_10003E50("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1003BE80) --------------------------------------------------------
char __cdecl sub_1003BE80(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_10003E50("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1003BEC0) --------------------------------------------------------
__int16 __usercall sub_1003BEC0@<ax>(unsigned __int8 a1@<al>)
{
  return word_100CBAB0[a1];
}
// 100CBAB0: using guessed type __int16 word_100CBAB0[];

//----- (1003BED0) --------------------------------------------------------
char __cdecl sub_1003BED0(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_1003BEC0(a1);
    if ( sub_10016290(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (1003BFA0) --------------------------------------------------------
char __cdecl sub_1003BFA0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_1003BE80(a1);
  if ( a3 != 11 )
  {
    sub_10003E50("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_1003BED0(v7, a5);
  }
  else
  {
    sub_10003E50("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1003C020) --------------------------------------------------------
char __cdecl sub_1003C020(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_10003E50("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_10016290(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_10016290(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_10026C80((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_101A3EF8, (char *)&v6 + 1, 0x20u);
      byte_101A3EF0 = 1;
      byte_101A3EF1 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_101A3F18, (char *)&v6 + 1, 0x20u);
    byte_101A3EF1 = 1;
    byte_101A3EF2 = 1;
    return result;
  }
  return 0;
}
// 101A3EF0: using guessed type char byte_101A3EF0;
// 101A3EF1: using guessed type char byte_101A3EF1;
// 101A3EF2: using guessed type char byte_101A3EF2;

//----- (1003C150) --------------------------------------------------------
char __cdecl sub_1003C150(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_10024980(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_10003E50("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (1003C1D0) --------------------------------------------------------
bool __cdecl sub_1003C1D0(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_101A3EF0 == 0;
    qmemcpy(a1, &unk_101A3EF8, 0x40u);
    result = !v1 && byte_101A3EF2;
  }
  else
  {
    sub_10003E50("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 101A3EF0: using guessed type char byte_101A3EF0;
// 101A3EF2: using guessed type char byte_101A3EF2;

//----- (1003C220) --------------------------------------------------------
char __cdecl sub_1003C220(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_10003E50("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_10014580(15);
    v3 = 555;
  }
  else
  {
    result = sub_10014580(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_101A3EF1 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_10015D90(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 10004AC0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 101A3EF1: using guessed type char byte_101A3EF1;

//----- (1003C300) --------------------------------------------------------
__int16 __usercall sub_1003C300@<ax>(unsigned __int8 a1@<al>)
{
  return word_100CBBC0[a1];
}
// 100CBBC0: using guessed type __int16 word_100CBBC0[];

//----- (1003C310) --------------------------------------------------------
char __cdecl sub_1003C310(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_1003C300(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_10015D90(1, v3, &v5, 1, HIWORD(v5) + 4, 1);
  return sub_10015ED0(1, v3, 0xFFFFFFF);
}

//----- (1003C3A0) --------------------------------------------------------
char __cdecl sub_1003C3A0(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_10003E50("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_101A3EF1 != 0 ? 25 : 11;
      sub_1003C310(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_1003C310(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 101A3EF1: using guessed type char byte_101A3EF1;

//----- (1003C460) --------------------------------------------------------
bool __cdecl sub_1003C460(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_1003C150(a1, (int)a5);
    return 1;
  }
  if ( byte_101A3EF1 )
  {
    if ( sub_1003C020(a1, &v6, 1) )
    {
LABEL_14:
      byte_101A3EF3 = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_101A3EF3 >= 5u )
    {
      byte_101A3EF0 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_1003C020(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_101A3EF3 >= 5u )
    {
      byte_101A3EF2 = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_1003C150(a1, (int)&v6);
    sub_1003C220(a1, (int)&v6);
  }
  sub_1003C3A0(a1, 11);
  return sub_1003C1D0(a5);
}
// 10004AC0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 101A3EF0: using guessed type char byte_101A3EF0;
// 101A3EF1: using guessed type char byte_101A3EF1;
// 101A3EF2: using guessed type char byte_101A3EF2;
// 101A3EF3: using guessed type char byte_101A3EF3;

//----- (1003C560) --------------------------------------------------------
char __cdecl sub_1003C560(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_10003E50("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (1003C5A0) --------------------------------------------------------
char __cdecl sub_1003C5A0(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1003C5D0) --------------------------------------------------------
int __cdecl sub_1003C5D0(unsigned __int8 a1, unsigned int a2)
{
  return dword_100D57B0[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 100D57B0: using guessed type int dword_100D57B0[];

//----- (1003C5F0) --------------------------------------------------------
unsigned int __cdecl sub_1003C5F0(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_100D57B0[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_100D57B0[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_100D57B0[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_100D57B0[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_100D57B0[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_100D57B0[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_100D57B0[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_100D57B0[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_100D57B0[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_100D57B0[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 100D57B0: using guessed type int dword_100D57B0[];

//----- (1003C720) --------------------------------------------------------
double __cdecl sub_1003C720(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 != v4 && (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v11 = v2 + v9;
        result = v11;
      }
      else
      {
        v10 = v4;
        result = v10;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (1003C7C0) --------------------------------------------------------
double __cdecl sub_1003C7C0(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 == v4 || (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v10 = v4;
        result = v10;
      }
      else
      {
        v11 = v9 - v2;
        result = v11;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (1003C860) --------------------------------------------------------
double __cdecl sub_1003C860(double a1, double a2)
{
  double result; // st7@1
  double v3; // [sp+0h] [bp-8h]@2

  result = 0.0;
  if ( a2 > 0.0 )
  {
    v3 = a2 + a2;
    result = fmod(a1, v3);
    if ( a2 > result )
    {
      if ( -a2 > result )
        result = result + v3;
    }
    else
    {
      result = result - v3;
    }
  }
  return result;
}

//----- (1003C8C0) --------------------------------------------------------
double __cdecl sub_1003C8C0(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@5
  float v6; // [sp+8h] [bp+8h]@3
  float v7; // [sp+8h] [bp+8h]@3
  float v8; // [sp+8h] [bp+8h]@4
  float v9; // [sp+8h] [bp+8h]@6

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v6 = v2 + v2;
    v4 = v6;
    v7 = a1 - (double)(signed int)(a1 / v6) * v6;
    if ( v7 < v2 )
    {
      v5 = v2;
      result = v7;
      if ( -v5 > v7 )
      {
        v9 = result + v4;
        result = v9;
      }
    }
    else
    {
      v8 = v7 - v4;
      result = v8;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (1003C940) --------------------------------------------------------
void __cdecl sub_1003C940(double a1)
{
  sub_1003C860(a1, 3.1415926535898);
}

//----- (1003C960) --------------------------------------------------------
double __cdecl sub_1003C960(float a1)
{
  double result; // st7@3

  if ( a1 == -3.141592741012573 || a1 == 3.141592741012573 )
    result = -3.1415925;
  else
    result = sub_1003C8C0(a1, 3.1415927);
  return result;
}

//----- (1003C9A0) --------------------------------------------------------
int __cdecl sub_1003C9A0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)a2 = *(double *)a1;
  *(float *)(a2 + 4) = *(double *)(a1 + 8);
  return result;
}

//----- (1003C9C0) --------------------------------------------------------
int __cdecl sub_1003C9C0(double a1)
{
  int result; // eax@2

  if ( a1 >= 0.0 )
    result = (signed int)(a1 + 0.5);
  else
    result = (signed int)(a1 - 0.5);
  return result;
}

//----- (1003C9F0) --------------------------------------------------------
double __cdecl sub_1003C9F0(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  float v4; // [sp+8h] [bp+8h]@5

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    if ( a1 < 0.0 )
      a2 = -v2;
    v4 = v2 * (double)(signed int)((a1 + a2 * 0.5) / v2);
    result = v4;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (1003CA60) --------------------------------------------------------
int __cdecl sub_1003CA60(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a3;
  *(float *)a3 = cos(a1);
  *(float *)a2 = sin(a1);
  return result;
}

//----- (1003CA80) --------------------------------------------------------
int __cdecl sub_1003CA80(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(double *)a2 = *(float *)a1;
  *(double *)(a2 + 8) = *(float *)(a1 + 4);
  return result;
}

//----- (1003CAA0) --------------------------------------------------------
double __cdecl sub_1003CAA0(double a1, double a2)
{
  double result; // st7@1

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707963267949;
      else
        result = 1.5707963267949;
    }
  }
  else
  {
    result = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      result = result + 3.1415926535898;
      sub_1003C940(result);
    }
  }
  return result;
}

//----- (1003CB10) --------------------------------------------------------
double __cdecl sub_1003CB10(float a1, float a2)
{
  double result; // st7@1
  float v3; // [sp+4h] [bp-4h]@6
  float v4; // [sp+10h] [bp+8h]@7

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707964;
      else
        result = 1.5707964;
    }
  }
  else
  {
    v3 = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      v4 = v3 + 3.141592741012573;
      v3 = sub_1003C960(v4);
    }
    result = v3;
  }
  return result;
}

//----- (1003CBA0) --------------------------------------------------------
int __cdecl sub_1003CBA0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(float *)a3 = *(float *)a1 + *(float *)a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) + *(float *)(a2 + 4);
  *(float *)(a3 + 8) = *(float *)(a1 + 8) + *(float *)(a2 + 8);
  return result;
}

//----- (1003CBD0) --------------------------------------------------------
int __cdecl sub_1003CBD0(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(float *)a3 = *(float *)a2 * a1;
  *(float *)(a3 + 4) = *(float *)(a2 + 4) * a1;
  *(float *)(a3 + 8) = a1 * *(float *)(a2 + 8);
  return result;
}

//----- (1003F0B9) --------------------------------------------------------
int __cdecl sub_1003F0B9(int a1, int a2, char a3)
{
  return vscan_fn(sub_1004711B, a2, 0, &a3);
}
// 1003F051: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100404C6) --------------------------------------------------------
signed int __cdecl sub_100404C6(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_101A5370 )
  {
    *a1 = dword_101A5370;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1004342E: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101A5370: using guessed type int dword_101A5370;

//----- (100404FD) --------------------------------------------------------
signed int __cdecl sub_100404FD(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_101A5370 )
  {
    *a1 = dword_101A537C;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1004342E: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101A5370: using guessed type int dword_101A5370;
// 101A537C: using guessed type int dword_101A537C;

//----- (10041143) --------------------------------------------------------
void sub_10041143()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_101D92A0;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_101D93A0 );
}
// 101D92A0: using guessed type int dword_101D92A0[];
// 101D93A0: using guessed type int dword_101D93A0;

//----- (100415F0) --------------------------------------------------------
int (*sub_100415F0())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_100DFEA0;
  v1 = (int (**)(void))&unk_100DFEA0;
  if ( &unk_100DFEA0 < &unk_100DFEA0 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_100DFEA0 );
  }
  return result;
}

//----- (10041614) --------------------------------------------------------
void __cdecl sub_10041614()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_100DFEA8;
  if ( &unk_100DFEA8 < &unk_100DFEA8 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_100DFEA8 );
  }
}

//----- (10043328) --------------------------------------------------------
int __cdecl sub_10043328(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101A54D8 = a1;
  return result;
}
// 101A54D8: using guessed type int dword_101A54D8;

//----- (10043452) --------------------------------------------------------
int __cdecl sub_10043452(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_1004B078() + 8 && (void **)v2 != sub_1004B078() + 16 || !sub_1004B01A((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_100E2268;
      else
        v9 = (_BYTE *)(dword_101D92A0[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_1004AEFA((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_1004AEFA((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 1004AFD6: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 101D92A0: using guessed type int dword_101D92A0[];

//----- (100460A4) --------------------------------------------------------
#error "100460A9: positive sp value has been found (funcsize=0)"

//----- (100460AF) --------------------------------------------------------
#error "100460B4: positive sp value has been found (funcsize=0)"

//----- (100460BA) --------------------------------------------------------
#error "100460BF: positive sp value has been found (funcsize=0)"

//----- (100460C0) --------------------------------------------------------
#error "100460C5: positive sp value has been found (funcsize=0)"

//----- (100460C6) --------------------------------------------------------
#error "100460CB: positive sp value has been found (funcsize=0)"

//----- (100460CC) --------------------------------------------------------
#error "100460D1: positive sp value has been found (funcsize=0)"

//----- (100460D2) --------------------------------------------------------
#error "100460ED: positive sp value has been found (funcsize=0)"

//----- (100460F3) --------------------------------------------------------
#error "10046108: positive sp value has been found (funcsize=0)"

//----- (1004610E) --------------------------------------------------------
#error "10046129: positive sp value has been found (funcsize=0)"

//----- (1004612A) --------------------------------------------------------
#error "10046139: positive sp value has been found (funcsize=0)"

//----- (1004613A) --------------------------------------------------------
#error "1004614D: positive sp value has been found (funcsize=0)"

//----- (1004614E) --------------------------------------------------------
#error "1004615D: positive sp value has been found (funcsize=0)"

//----- (1004615E) --------------------------------------------------------
#error "1004617D: positive sp value has been found (funcsize=0)"

//----- (10046183) --------------------------------------------------------
#error "1004619C: positive sp value has been found (funcsize=0)"

//----- (100461A2) --------------------------------------------------------
#error "100461C1: positive sp value has been found (funcsize=0)"

//----- (100461C2) --------------------------------------------------------
#error "100461D5: positive sp value has been found (funcsize=0)"

//----- (100461D6) --------------------------------------------------------
#error "100461ED: positive sp value has been found (funcsize=0)"

//----- (100461EE) --------------------------------------------------------
#error "10046201: positive sp value has been found (funcsize=0)"

//----- (10046202) --------------------------------------------------------
#error "10046221: positive sp value has been found (funcsize=0)"

//----- (10046227) --------------------------------------------------------
#error "10046240: positive sp value has been found (funcsize=0)"

//----- (10046246) --------------------------------------------------------
#error "10046265: positive sp value has been found (funcsize=0)"

//----- (10046266) --------------------------------------------------------
#error "10046279: positive sp value has been found (funcsize=0)"

//----- (1004627A) --------------------------------------------------------
#error "10046291: positive sp value has been found (funcsize=0)"

//----- (10046292) --------------------------------------------------------
#error "100462A5: positive sp value has been found (funcsize=0)"

//----- (100462A6) --------------------------------------------------------
#error "100462C5: positive sp value has been found (funcsize=0)"

//----- (100462CB) --------------------------------------------------------
#error "100462E4: positive sp value has been found (funcsize=0)"

//----- (100462EA) --------------------------------------------------------
#error "10046309: positive sp value has been found (funcsize=0)"

//----- (1004630A) --------------------------------------------------------
#error "1004631D: positive sp value has been found (funcsize=0)"

//----- (1004631E) --------------------------------------------------------
#error "10046335: positive sp value has been found (funcsize=0)"

//----- (10046336) --------------------------------------------------------
#error "10046349: positive sp value has been found (funcsize=0)"

//----- (1004634A) --------------------------------------------------------
#error "10046369: positive sp value has been found (funcsize=0)"

//----- (1004636F) --------------------------------------------------------
#error "10046388: positive sp value has been found (funcsize=0)"

//----- (1004638E) --------------------------------------------------------
#error "100463AD: positive sp value has been found (funcsize=0)"

//----- (100463AE) --------------------------------------------------------
#error "100463C1: positive sp value has been found (funcsize=0)"

//----- (100463C2) --------------------------------------------------------
#error "100463D9: positive sp value has been found (funcsize=0)"

//----- (100463DA) --------------------------------------------------------
#error "100463ED: positive sp value has been found (funcsize=0)"

//----- (100463EE) --------------------------------------------------------
#error "1004640D: positive sp value has been found (funcsize=0)"

//----- (10046413) --------------------------------------------------------
#error "1004642C: positive sp value has been found (funcsize=0)"

//----- (10046432) --------------------------------------------------------
#error "10046451: positive sp value has been found (funcsize=0)"

//----- (10046452) --------------------------------------------------------
#error "10046465: positive sp value has been found (funcsize=0)"

//----- (10046466) --------------------------------------------------------
#error "1004647D: positive sp value has been found (funcsize=0)"

//----- (1004647E) --------------------------------------------------------
#error "10046491: positive sp value has been found (funcsize=0)"

//----- (10046492) --------------------------------------------------------
#error "100464B1: positive sp value has been found (funcsize=0)"

//----- (100464B7) --------------------------------------------------------
#error "100464D0: positive sp value has been found (funcsize=0)"

//----- (100464D6) --------------------------------------------------------
#error "100464F5: positive sp value has been found (funcsize=0)"

//----- (100464F6) --------------------------------------------------------
#error "10046509: positive sp value has been found (funcsize=0)"

//----- (1004650A) --------------------------------------------------------
#error "10046521: positive sp value has been found (funcsize=0)"

//----- (10046522) --------------------------------------------------------
#error "10046535: positive sp value has been found (funcsize=0)"

//----- (1004711B) --------------------------------------------------------
int __cdecl sub_1004711B(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
  {
    v7 = &unk_100E2268;
  }
  else
  {
    v6 = &dword_101D92A0[_fileno(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno(a1) == -1 || _fileno(a1) == -2 ? (v9 = &unk_100E2268) : (v8 = &dword_101D92A0[_fileno(a1) >> 5],
                                                                         v9 = (_BYTE *)(*v8 + ((_fileno(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_1004D121(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_1004D121(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_1004D121(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_1004D121(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_1004D121(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_100E2250[0]);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_1004D121(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_1004D121(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_1004D121(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_1004D121(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 100407FC: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1004342E: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100470E0: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 100470F6: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 100E2250: using guessed type int (*off_100E2250[3])();
// 101D92A0: using guessed type int dword_101D92A0[];
// 1004711B: using guessed type char var_24[11];

//----- (10048540) --------------------------------------------------------
int __cdecl sub_10048540(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1004B999((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 10044B91: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100485E6) --------------------------------------------------------
int __cdecl sub_100485E6(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1004BEDB((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 10044B91: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10048A52) --------------------------------------------------------
void sub_10048A52()
{
  dword_101D927C = 0;
}
// 101D927C: using guessed type int dword_101D927C;

//----- (10048BA5) --------------------------------------------------------
int sub_10048BA5()
{
  dword_101D93B8 = _get_sse2_info();
  return 0;
}
// 10048B45: using guessed type int _get_sse2_info(void);
// 101D93B8: using guessed type int dword_101D93B8;

//----- (100490A2) --------------------------------------------------------
int sub_100490A2()
{
  return _decode_pointer(dword_101A59A0);
}
// 100407FC: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 101A59A0: using guessed type int dword_101A59A0;

//----- (1004925F) --------------------------------------------------------
int __cdecl sub_1004925F(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101A59AC = a1;
  return result;
}
// 101A59AC: using guessed type int dword_101A59AC;

//----- (10049269) --------------------------------------------------------
int __cdecl sub_10049269(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101A59B8 = a1;
  return result;
}
// 101A59B8: using guessed type int dword_101A59B8;

//----- (10049273) --------------------------------------------------------
int __cdecl sub_10049273(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101A59BC = a1;
  return result;
}
// 101A59BC: using guessed type int dword_101A59BC;

//----- (10049352) --------------------------------------------------------
int __cdecl sub_10049352(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101A59C0 = a1;
  return result;
}
// 101A59C0: using guessed type int dword_101A59C0;

//----- (1004A73C) --------------------------------------------------------
DWORD __cdecl sub_1004A73C(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_1004E5B4(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_101D92A0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 1003E086: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 101D92A0: using guessed type int dword_101D92A0[];

//----- (1004A8D8) --------------------------------------------------------
_WORD *__cdecl sub_1004A8D8(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  CHAR v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_101D92A0[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_101D92A0[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_1004A73C(a1, 0, 0, 2u);
  if ( sub_1004B01A(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 1003E086: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 10040A18: using guessed type int _getptd(void);
// 1004342E: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101D92A0: using guessed type int dword_101D92A0[];
// 1004A8D8: using guessed type CHAR var_410[688];

//----- (1004AEFA) --------------------------------------------------------
_WORD *__cdecl sub_1004AEFA(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_101D92A0[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_1004A8D8(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_1004E6C5(a1);
  return v6;
}
// 1004342E: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1004E625: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 101D92A0: using guessed type int dword_101D92A0[];

//----- (1004B01A) --------------------------------------------------------
int __cdecl sub_1004B01A(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_101D92A0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 1004342E: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101D92A0: using guessed type int dword_101D92A0[];

//----- (1004B078) --------------------------------------------------------
void **sub_1004B078()
{
  return &off_100E2DB8;
}
// 100E2DB8: using guessed type void *off_100E2DB8;

//----- (1004B07E) --------------------------------------------------------
signed int sub_1004B07E()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_101D9260;
  if ( !dword_101D9260 )
  {
    v0 = 512;
LABEL_5:
    dword_101D9260 = v0;
    goto LABEL_6;
  }
  if ( dword_101D9260 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_101D8254 = v1;
  if ( v1 || (dword_101D9260 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_101D8254 = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_100E2DB8;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&off_100E3038 )
        break;
      v1 = dword_101D8254;
    }
    v5 = 0;
    v6 = &unk_100E2DC8;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_101D92A0[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_100E2E28 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 10040E0C: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 100E2DB8: using guessed type void *off_100E2DB8;
// 100E3038: using guessed type wchar_t *off_100E3038;
// 101D9260: using guessed type int dword_101D9260;
// 101D92A0: using guessed type int dword_101D92A0[];

//----- (1004B999) --------------------------------------------------------
signed int __cdecl sub_1004B999(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100E3148 - 1;
    v64 = v3;
    v65 = dword_100E3148 / 32;
    v9 = dword_100E3148 % 32;
    v10 = (int *)(&v60 + dword_100E3148 / 32);
    v66 = 31 - dword_100E3148 % 32;
    if ( (1 << (31 - dword_100E3148 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100E3144 - dword_100E3148 )
    {
      if ( v3 > dword_100E3144 )
      {
        if ( v3 < dword_100E3140 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100E3154 + v3;
          v50 = dword_100E314C / 32;
          v51 = dword_100E314C % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100E314C % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100E314C / 32;
          v44 = dword_100E314C % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100E314C % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100E3154 + dword_100E3140;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100E3144 - v64) / 32;
      v62 = v59;
      v18 = (dword_100E3144 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100E3148 - 1;
      v25 = dword_100E3148 / 32;
      v65 = dword_100E3148 / 32;
      v26 = (int *)(&v60 + dword_100E3148 / 32);
      v64 = 31 - dword_100E3148 % 32;
      if ( (1 << (31 - dword_100E3148 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100E3148 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100E314C + 1) / 32;
      v37 = (dword_100E314C + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100E314C));
  if ( dword_100E3150 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100E3150 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100E3140: using guessed type int dword_100E3140;
// 100E3144: using guessed type int dword_100E3144;
// 100E3148: using guessed type int dword_100E3148;
// 100E314C: using guessed type int dword_100E314C;
// 100E3150: using guessed type int dword_100E3150;
// 100E3154: using guessed type int dword_100E3154;

//----- (1004BEDB) --------------------------------------------------------
signed int __cdecl sub_1004BEDB(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100E3160 - 1;
    v64 = v3;
    v65 = dword_100E3160 / 32;
    v9 = dword_100E3160 % 32;
    v10 = (int *)(&v60 + dword_100E3160 / 32);
    v66 = 31 - dword_100E3160 % 32;
    if ( (1 << (31 - dword_100E3160 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100E315C - dword_100E3160 )
    {
      if ( v3 > dword_100E315C )
      {
        if ( v3 < dword_100E3158 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100E316C + v3;
          v50 = dword_100E3164 / 32;
          v51 = dword_100E3164 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100E3164 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100E3164 / 32;
          v44 = dword_100E3164 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100E3164 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100E316C + dword_100E3158;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100E315C - v64) / 32;
      v62 = v59;
      v18 = (dword_100E315C - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100E3160 - 1;
      v25 = dword_100E3160 / 32;
      v65 = dword_100E3160 / 32;
      v26 = (int *)(&v60 + dword_100E3160 / 32);
      v64 = 31 - dword_100E3160 % 32;
      if ( (1 << (31 - dword_100E3160 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100E3160 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100E3164 + 1) / 32;
      v37 = (dword_100E3164 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100E3164));
  if ( dword_100E3168 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100E3168 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100E3158: using guessed type int dword_100E3158;
// 100E315C: using guessed type int dword_100E315C;
// 100E3160: using guessed type int dword_100E3160;
// 100E3164: using guessed type int dword_100E3164;
// 100E3168: using guessed type int dword_100E3168;
// 100E316C: using guessed type int dword_100E316C;

//----- (1004C81C) --------------------------------------------------------
int sub_1004C81C()
{
  return 0;
}

//----- (1004D001) --------------------------------------------------------
int __cdecl sub_1004D001(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
    {
      v8 = &unk_100E2268;
    }
    else
    {
      v7 = &dword_101D92A0[_fileno(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 1004342E: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1004AFD6: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 101D92A0: using guessed type int dword_101D92A0[];

//----- (1004D121) --------------------------------------------------------
int __cdecl sub_1004D121(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno(a2) == -1 || _fileno(a2) == -2 )
    {
      v3 = &unk_100E2268;
    }
    else
    {
      v2 = &dword_101D92A0[_fileno(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno(a2) == -1 || _fileno(a2) == -2 ? (v5 = &unk_100E2268) : (v4 = &dword_101D92A0[_fileno(a2) >> 5],
                                                                           v5 = (_BYTE *)(*v4
                                                                                        + ((_fileno(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 1004342E: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1004AFD6: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 101D92A0: using guessed type int dword_101D92A0[];

//----- (1004E060) --------------------------------------------------------
int __cdecl sub_1004E060(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_101A59DC )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_101A59DC = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_101A59E0 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_101A59E4 = _encode_pointer(v7);
    if ( sub_100404C6(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_101A59EC = _encode_pointer(v8);
      if ( dword_101A59EC )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_101A59E8 = _encode_pointer(v9);
      }
    }
  }
  if ( dword_101A59E8 == v23
    || dword_101A59EC == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_101A59E8),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_101A59EC),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_101A59E0 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_101A59E0);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_101A59E4 != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_101A59E4);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_100404FD(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_101A59DC);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 10040785: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 100407F3: using guessed type int _encoded_null(void);
// 100407FC: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10043332: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101A59DC: using guessed type int dword_101A59DC;
// 101A59E0: using guessed type int dword_101A59E0;
// 101A59E4: using guessed type int dword_101A59E4;
// 101A59E8: using guessed type int dword_101A59E8;
// 101A59EC: using guessed type int dword_101A59EC;

//----- (1004E533) --------------------------------------------------------
signed int __cdecl sub_1004E533(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_101D92A0[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_101A5040 == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 101A5040: using guessed type int dword_101A5040;
// 101D92A0: using guessed type int dword_101D92A0[];

//----- (1004E5B4) --------------------------------------------------------
signed int __cdecl sub_1004E5B4(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_101D92A0[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 1004342E: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101D92A0: using guessed type int dword_101D92A0[];

//----- (1004E6C5) --------------------------------------------------------
void __cdecl sub_1004E6C5(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_101D92A0[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 101D92A0: using guessed type int dword_101D92A0[];

//----- (1004E9C6) --------------------------------------------------------
int sub_1004E9C6()
{
  return flsall(1);
}
// 1004E8EC: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (1004F311) --------------------------------------------------------
signed int __cdecl sub_1004F311(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_1004E5B4(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_101D92A0[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_101D92A0[0] + 68) & 1)
    && (v1 = sub_1004E5B4(2), sub_1004E5B4(1) == v1)
    || (v2 = (void *)sub_1004E5B4(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_1004E533(a1);
  *(_BYTE *)(dword_101D92A0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1003E086: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 101D92A0: using guessed type int dword_101D92A0[];

//----- (1004F4F0) --------------------------------------------------------
int __cdecl sub_1004F4F0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 10050242: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (1004F540) --------------------------------------------------------
int __cdecl sub_1004F540(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 1003CC8C: using guessed type int SYS_exit_krnl(void);
// 1003CC92: using guessed type int SYS_enter_krnl(void);
// 10050248: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (1004F5B0) --------------------------------------------------------
int __cdecl sub_1004F5B0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10015220(v1);
  a1 = v2;
  v3 = sub_10019830(&a1, 4u, (int)&unk_100DF540, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100DF544[2 * v3];
}
// 100DF544: using guessed type int dword_100DF544[];

//----- (1004F5F0) --------------------------------------------------------
int __cdecl sub_1004F5F0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10015220(v1);
  a1 = v2;
  v3 = sub_10019830(&a1, 4u, (int)&unk_100DF578, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100DF57C[2 * v3];
}
// 100DF57C: using guessed type int dword_100DF57C[];

//----- (1004F630) --------------------------------------------------------
int __cdecl sub_1004F630(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10015220(v1);
  a1 = v2;
  v3 = sub_10019830(&a1, 4u, (int)&unk_100DF5B0, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100DF5B4[2 * v3];
}
// 100DF5B4: using guessed type int dword_100DF5B4[];

//----- (1004F670) --------------------------------------------------------
int __cdecl sub_1004F670(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10015220(v1);
  a1 = v2;
  v3 = sub_10019830(&a1, 4u, (int)&unk_100DF5E8, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100DF5EC[2 * v3];
}
// 100DF5EC: using guessed type int dword_100DF5EC[];

//----- (1004F6B0) --------------------------------------------------------
int __cdecl sub_1004F6B0(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_1004F5F0(a4);
    result = sub_100042D0(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_100042D0(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_1004F5B0(a4);
      result = sub_100042D0(v6, a3, 6);
    }
  }
  return result;
}

//----- (1004F720) --------------------------------------------------------
int __cdecl sub_1004F720(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_1004F670(a3);
    result = sub_100042D0(v4, a1, 64);
    if ( result == -7 )
    {
      sub_10004170(100);
      v5 = sub_1004F670(a3);
      result = sub_100042D0(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_1004F630(a3);
    result = sub_100042D0(v6, a2, 8);
    if ( result == -7 )
    {
      sub_10004170(100);
      v7 = sub_1004F630(a3);
      result = sub_100042D0(v7, a2, 8);
    }
  }
  return result;
}

//----- (1004F7D0) --------------------------------------------------------
void __cdecl sub_1004F7D0(float *a1, float *a2, float *a3, int a4)
{
  float v4; // [sp+0h] [bp-4h]@1

  sub_1004FEF0(a1, a2, a4);
  v4 = sqrt(sub_1004FFB0(a4, a4));
  *a3 = v4;
  if ( v4 >= 0.1000000014901161 )
  {
    *(float *)a4 = *(float *)a4 / v4;
    *(float *)(a4 + 4) = *(float *)(a4 + 4) / *a3;
  }
  else
  {
    *(float *)(a4 + 4) = 1.0;
    *(float *)a4 = 0.0;
  }
}

//----- (1004F830) --------------------------------------------------------
int __cdecl sub_1004F830(float a1, float a2, int a3)
{
  float v3; // ST00_4@1
  float v4; // ST04_4@1
  float v5; // ST00_4@1
  float v6; // ST04_4@1
  double v7; // ST08_8@1
  float v8; // ST04_4@1
  float v9; // ST00_4@1
  float v10; // ST04_4@1
  float v11; // ST04_4@1
  double v12; // ST08_8@1
  float v13; // ST04_4@1
  float v14; // ST00_4@1
  float v15; // ST04_4@1
  float v16; // ST04_4@1
  double v17; // ST08_8@1
  float v18; // ST04_4@1
  float v19; // ST00_4@1
  float v20; // ST04_4@1
  float v21; // ST04_4@1
  double v22; // ST08_8@1
  float v23; // ST04_4@1
  float v24; // ST00_4@1
  float v25; // ST04_4@1
  int result; // eax@1
  float v27; // ST04_4@1
  float v28; // ST04_4@1
  float v29; // [sp+18h] [bp+8h]@1
  float v30; // [sp+18h] [bp+8h]@1

  v3 = sin(a2 * 4.0);
  v4 = v3;
  v5 = sin(a1 * 4.0);
  v6 = v4 - v5;
  v7 = v6 * 0.00001062759019987425 * 0.25;
  v8 = sin(a2 + a2);
  v9 = v8;
  v10 = sin(a1 + a1);
  v11 = v9 - v10;
  v12 = v7 - v11 * 0.00506310909986496 * 0.5;
  v13 = sin(a2 * 6.0);
  v14 = v13;
  v15 = sin(a1 * 6.0);
  v16 = v14 - v15;
  v17 = v12 - v16 * 0.00000002082037831030448 / 6.0;
  v18 = sin(a2 * 8.0);
  v19 = v18;
  v20 = sin(a1 * 8.0);
  v21 = v19 - v20;
  v22 = v21 * 3.932370748471747e-11 * 0.125 + v17;
  v23 = sin(a2 * 10.0);
  v24 = v23;
  v25 = sin(a1 * 10.0);
  result = a3;
  v27 = v24 - v25;
  v28 = v22 - v27 * 7.108452959288594e-14 / 10.0;
  v29 = a2 - a1;
  v30 = v29 * 1.005052447319031;
  *(float *)a3 = fabs((v28 + v30) * 6335439.327292892);
  return result;
}

//----- (1004F9F0) --------------------------------------------------------
void __cdecl sub_1004F9F0(int a1, int a2, float *a3, float *a4, float *a5)
{
  float v5; // ST38_4@1
  float v6; // ST38_4@1
  long double v7; // ST38_8@5
  long double v8; // ST48_8@5
  long double v9; // st7@5
  signed int v10; // ebx@5
  long double v11; // st5@5
  long double v12; // st7@5
  long double v13; // st7@6
  double v14; // st7@6
  double v15; // st4@6
  double v16; // st3@6
  double v17; // st2@8
  double v18; // STB8_8@8
  double v19; // ST60_8@10
  double v20; // ST50_8@10
  long double v21; // st7@10
  long double v22; // st7@10
  double v23; // [sp+40h] [bp-90h]@6
  double v24; // [sp+48h] [bp-88h]@6
  double v25; // [sp+50h] [bp-80h]@5
  double v26; // [sp+58h] [bp-78h]@5
  double v27; // [sp+60h] [bp-70h]@5
  double v28; // [sp+68h] [bp-68h]@6
  double v29; // [sp+70h] [bp-60h]@6
  double v30; // [sp+78h] [bp-58h]@5
  double v31; // [sp+80h] [bp-50h]@6
  double v32; // [sp+88h] [bp-48h]@6
  double v33; // [sp+90h] [bp-40h]@5
  double v34; // [sp+98h] [bp-38h]@5
  double v35; // [sp+A0h] [bp-30h]@8
  double v36; // [sp+A8h] [bp-28h]@6
  double v37; // [sp+B0h] [bp-20h]@5
  double v38; // [sp+C0h] [bp-10h]@5

  v5 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
  v6 = fabs(sub_1003C960(v5));
  if ( v6 >= 0.000001 )
  {
    v7 = sin(*(float *)a1) * 0.9966471893352525 / cos(*(float *)a1);
    v8 = sin(*(float *)a2) * 0.9966471893352525 / cos(*(float *)a2);
    v33 = 1.0 / sqrt(v7 * v7 + 1.0);
    v9 = 1.0 / sqrt(v8 * v8 + 1.0);
    v10 = 0;
    v37 = v9;
    v34 = v33 * v9;
    v25 = v34 * v8;
    v27 = v25 * v7;
    v26 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
    v11 = v9;
    v12 = v26;
    v30 = v11 * (v33 * v7);
    v38 = v27 + v27;
    do
    {
      v29 = sin(v12);
      v13 = cos(v26);
      v32 = v13;
      v24 = v25 - v13 * v30;
      v36 = sqrt(v29 * v37 * (v29 * v37) + v24 * v24);
      v28 = v13 * v34 + v27;
      v23 = sub_1003CAA0(v36, v28);
      v14 = v29 * v34 / v36;
      v15 = 1.0 - v14 * v14;
      v16 = v38;
      v31 = v38;
      if ( v15 > 0.0 )
      {
        v16 = v28 - v38 / v15;
        v31 = v16;
      }
      ++v10;
      v35 = v16 * v16 + v16 * v16 - 1.0;
      v17 = v15 * ((4.0 - v15 * 3.0) * 0.00335281066474748 + 4.0) * 0.00335281066474748 * 0.0625;
      v18 = v26;
      v12 = 0.00335281066474748 * ((1.0 - v17) * (v14 * (v36 * (v16 + v35 * v28 * v17) * v17 + v23)))
          + *(float *)(a2 + 4)
          - *(float *)(a1 + 4);
      v26 = v12;
    }
    while ( fabs(v18 - v12) > 0.00000005 && v10 < 20 );
    v19 = sub_1003CAA0(v29 * v37, v24);
    v20 = sub_1003CAA0(v29 * v33, v32 * v25 - v30);
    v21 = sqrt(v15 * 0.006739496742276252 + 1.0);
    v22 = (v21 + 1.0 - 2.0) / (v21 + 1.0);
    *a3 = (0.25 * (v22 * v22) + 1.0)
        / (1.0 - v22)
        * ((v22 * 0.375 * v22 - 1.0)
         * v22
         * (v36
          * (v31
           + ((1.0 - v35 - v35) * (v36 * v36 * 4.0 - 3.0) * v31 * ((v22 * 0.375 * v22 - 1.0) * v22) / 6.0 - v35 * v28)
           * ((v22 * 0.375 * v22 - 1.0)
            * v22)
           * 0.25))
         + v23)
        * 6378137.0
        * 0.9966471893352525;
    *a4 = v19;
    *a5 = v20;
  }
  else
  {
    sub_1004F830(*(float *)a1, *(float *)a2, (int)a3);
    if ( *(float *)a1 >= (double)*(float *)a2 )
    {
      *a4 = 3.1415925;
      *a5 = 3.1415925;
    }
    else
    {
      *a4 = 0.0;
      *a5 = 0.0;
    }
  }
}

//----- (1004FDC0) --------------------------------------------------------
void __cdecl sub_1004FDC0(int a1, int a2, float *a3, float *a4)
{
  float v4; // ST14_4@1
  float v5; // ST14_4@1
  float v6; // [sp+Ch] [bp-1Ch]@1
  float v7; // [sp+10h] [bp-18h]@1
  float v8; // [sp+14h] [bp-14h]@1
  float v9; // [sp+18h] [bp-10h]@1
  float v10; // [sp+1Ch] [bp-Ch]@1
  float v11; // [sp+20h] [bp-8h]@3
  float v12; // [sp+24h] [bp-4h]@3

  sub_1003C9A0(a1, (int)&v9);
  sub_1003C9A0(a2, (int)&v7);
  v4 = v10 - v8;
  v6 = sub_1003C960(v4);
  v5 = v9 - v7;
  if ( COERCE_FLOAT(LODWORD(v5) & 0x7FFFFFFF) >= 0.0014486233 || COERCE_FLOAT(LODWORD(v6) & 0x7FFFFFFF) >= 0.0014486233 )
  {
    sub_1004F9F0((int)&v9, (int)&v7, a3, a4, &v6);
  }
  else
  {
    sub_1004F7D0(&v9, &v7, a3, (int)&v11);
    *a4 = sub_1003CB10(v11, v12);
  }
}

//----- (1004FEA0) --------------------------------------------------------
char sub_1004FEA0()
{
  unsigned __int8 v0; // cl@2
  signed int v1; // eax@4

  if ( !sub_100152A0() )
  {
    LOBYTE(v1) = 0;
    return v1;
  }
  v0 = *(_BYTE *)(dword_101D824C + 1200);
  if ( v0 || (v0 = *(_BYTE *)(dword_101D824C + 814)) != 0 )
  {
    LOBYTE(v1) = v0;
    if ( v0 < 4u )
      return v1;
    v1 = 4;
  }
  else
  {
    v1 = *(_BYTE *)(dword_101D824C + 122) == 0;
  }
  if ( v1 == 4 )
    LOBYTE(v1) = 0;
  return v1;
}
// 101D824C: using guessed type int dword_101D824C;

//----- (1004FEF0) --------------------------------------------------------
void __cdecl sub_1004FEF0(float *a1, float *a2, int a3)
{
  float *v3; // esi@1
  float *v4; // edi@1
  int v5; // [sp+18h] [bp-8h]@1
  int v6; // [sp+1Ch] [bp-4h]@1
  float v7; // [sp+24h] [bp+4h]@1
  float v8; // [sp+24h] [bp+4h]@1
  float v9; // [sp+24h] [bp+4h]@1
  float v10; // [sp+24h] [bp+4h]@1
  float v11; // [sp+28h] [bp+8h]@1
  float v12; // [sp+28h] [bp+8h]@1

  v3 = a1;
  v4 = a2;
  v7 = (*a1 + *a2) * 0.5;
  sub_1003CA60(v7, (int)&v5, (int)&v6);
  v8 = 1.0 / (1.0 - *(float *)&v5 * (0.00669437999013 * *(float *)&v5));
  v11 = sqrt(v8) * 6378137.0;
  v9 = 0.99330562000987 * v11 * v8;
  v12 = v11 * *(float *)&v6;
  *(float *)(a3 + 4) = (*v4 - *v3) * v9;
  v10 = v4[1] - v3[1];
  *(float *)a3 = v10;
  *(float *)a3 = sub_1003C960(v10) * v12;
}

//----- (1004FFB0) --------------------------------------------------------
double __cdecl sub_1004FFB0(int a1, int a2)
{
  return (float)(*(float *)(a1 + 4) * *(float *)(a2 + 4) + *(float *)a1 * *(float *)a2);
}

//----- (1004FFD0) --------------------------------------------------------
int __cdecl sub_1004FFD0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int result; // eax@1
  __int16 v7; // ST1C_2@8
  int v8; // [sp+0h] [bp-14h]@4
  int v9; // [sp+Ch] [bp-8h]@4
  __int16 v10; // [sp+10h] [bp-4h]@8
  __int16 v11; // [sp+28h] [bp+14h]@8
  __int16 v12; // [sp+2Ch] [bp+18h]@8

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v8 = *(_DWORD *)(a1 + 36);
    v9 = *(_DWORD *)(a1 + 36);
    if ( a6 & 1 )
      sub_100074B0(a1, a2, a3, a4, a5);
    if ( !(a6 & 2) )
      LOWORD(v9) = HIWORD(v9);
    v12 = a5 - 1;
    v11 = a4 - 1;
    v10 = a2;
    v10 = *(_WORD *)(a1 + 42) + a2;
    v7 = *(_WORD *)(a1 + 40) + a3;
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100DFE30[0]);
    *(_WORD *)(a1 + 10) = byte_100DFE30[1] + v10;
    *(_WORD *)(a1 + 8) = v7;
    *(_WORD *)(a1 + 14) = byte_100DFE30[2] + v11 - byte_100DFE30[1] + 1;
    sub_10007AF0(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100DFE30[3]);
    *(_WORD *)(a1 + 8) = byte_100DFE30[4] + v7;
    *(_WORD *)(a1 + 10) = v11 + v10;
    *(_WORD *)(a1 + 12) = byte_100DFE30[5] + v12 - byte_100DFE30[4] + 1;
    sub_10007C60(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100DFE30[6]);
    *(_WORD *)(a1 + 10) = byte_100DFE30[8] + v11 + v10;
    *(_WORD *)(a1 + 8) = v12 + v7;
    *(_WORD *)(a1 + 14) = byte_100DFE30[7] - (byte_100DFE30[8] + v11) - 1;
    sub_10007AF0(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100DFE30[9]);
    *(_WORD *)(a1 + 8) = byte_100DFE30[11] + v12 + v7;
    *(_WORD *)(a1 + 10) = v10;
    *(_WORD *)(a1 + 12) = byte_100DFE30[10] - (byte_100DFE30[11] + v12) - 1;
    sub_10007C60(a1);
    result = v8;
    *(_DWORD *)(a1 + 36) = v8;
  }
  return result;
}

#error "There were 52 decompilation failure(s) on 1132 function(s)"
