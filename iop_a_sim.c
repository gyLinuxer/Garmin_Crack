/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int sub_10001000();
// char __usercall sub_10001030@<al>(char a1@<al>, int a2@<ecx>);
void sub_10001080();
char __thiscall sub_10001200(void *this);
char __thiscall sub_10001290(void *this);
void __fastcall sub_10001390(char a1);
void __noreturn sub_10001420();
_DWORD sub_10001500(); // weak
char __cdecl sub_10001560(_DWORD *a1);
char __cdecl sub_100015A0(int a1);
char __cdecl sub_100015C0(int a1);
char __cdecl sub_100015E0(int a1);
int __cdecl sub_10001600(int a1, int a2, int a3);
int __cdecl sub_10001630(int a1);
int __cdecl sub_10001670(int a1, int a2);
int sub_10001780();
int __cdecl sub_10001860(int a1, int a2, int a3);
int __cdecl sub_100018B0(int a1);
int __cdecl sub_100018F0(int a1, char a2);
char **sub_10001940();
char **sub_10001950();
char __cdecl sub_10001960(int a1, int a2, int a3, int a4, char a5, char *a6);
char __cdecl sub_100019C0(char a1);
char sub_10001A00();
int __cdecl sub_10001A30(char a1);
// char __usercall sub_10001B50@<al>(char a1@<bl>);
// char __usercall sub_10001C50@<al>(const void *a1@<eax>, char a2);
// void *__usercall sub_10001D20@<eax>(char a1@<bl>, char a2);
// char __usercall sub_10001D80@<al>(void *a1@<ecx>, int a2@<eax>);
// char __usercall sub_10001DD0@<al>(int a1@<eax>, char a2);
// int __usercall sub_10001E30@<eax>(int a1@<eax>, const void *a2@<ecx>, char a3@<bl>);
char __cdecl sub_10001EA0(char a1, char a2);
char __cdecl sub_10001FB0(char a1, int a2, int a3, int a4, const void *a5, int a6);
char __cdecl sub_10002080(char a1, char a2, char a3);
char __cdecl sub_10002150(int a1);
int __cdecl sub_10002250(unsigned __int8 a1);
int __cdecl sub_10002260(int a1, char a2);
char __cdecl sub_10002390(int a1);
char __cdecl sub_10002420(int a1, char a2);
// int __usercall sub_10002520@<eax>(char *a1@<eax>, int a2@<edx>);
char __cdecl sub_10002560(int a1, char a2);
// char __usercall sub_100025B0@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>);
int __cdecl sub_10002650(unsigned __int8 a1, char a2);
char __cdecl sub_100026E0(char a1, char a2, char *a3, int a4, int a5);
// char __usercall sub_100028F0@<al>(char a1@<dl>, int a2@<ecx>, char a3);
char __cdecl sub_10002A90(unsigned __int8 a1, char a2);
// int __usercall sub_10002C30@<eax>(int a1@<ecx>, unsigned __int8 a2@<bl>, char a3);
// char __usercall sub_10002CF0@<al>(_BYTE *a1@<eax>, unsigned int a2@<ecx>, char a3);
char __cdecl sub_10003010(int a1, char a2);
char __cdecl sub_10003310(int a1, char a2, int a3);
char __cdecl sub_100033A0(int a1, int a2, int a3);
int sub_10003430();
char __cdecl sub_10003470(int a1, int a2);
char __cdecl sub_100034A0(float a1, int a2);
bool __cdecl sub_10003520(float a1, int a2);
char __cdecl sub_10003590(int a1, int a2);
char __cdecl sub_10003600(int a1, int a2);
bool __cdecl sub_10003630(char a1);
// char __usercall sub_10003660@<al>(int a1@<edi>);
int sub_100036B0(void); // weak
char __cdecl sub_100036C0(char a1);
void sub_10003830();
char __cdecl sub_10003A70(int a1);
char __thiscall sub_10003BC0(void *this);
char __cdecl sub_10003C60(char a1);
// char __usercall sub_10003CA0@<al>(int a1@<eax>);
char sub_10003CE0();
char __fastcall sub_10003D50(void *a1);
// char __usercall sub_10003E10@<al>(int a1@<eax>);
int sub_10003E70();
void __thiscall sub_10004580(void *this);
// void __usercall __noreturn sub_10004600(const void *a1@<esi>);
void *sub_10004700();
bool sub_100047A0();
bool sub_100048B0();
bool sub_100049F0();
bool sub_10004A60();
char **sub_10004AD0();
char __cdecl sub_10004B00(int a1);
char __cdecl sub_10004B80(int a1, int a2);
char sub_10004BF0();
char __cdecl sub_10004C20(int a1, int a2);
char __cdecl sub_10004C80(int a1, int a2);
// int __usercall sub_10004CE0@<eax>(unsigned __int16 a1@<ax>);
signed int __cdecl sub_10004CF0(unsigned __int16 a1, signed int a2, int a3);
void __cdecl sub_10004D50(int a1);
char __cdecl sub_10004D90(int a1, char a2, int a3, int a4, char a5);
int __cdecl sub_10005060(int a1);
char __cdecl sub_100050A0(char a1, int a2);
char __cdecl sub_10005170(int a1, int a2);
char __cdecl sub_10005220(int a1, int a2);
char __cdecl sub_100052B0(int a1, int a2);
char __cdecl sub_100053D0(__int16 a1);
int __cdecl sub_10005440(int a1);
bool __cdecl sub_10005450(unsigned __int16 a1, int a2, int a3, _DWORD *a4);
int __fastcall sub_100054D0(int a1, unsigned int a2);
// _BYTE *__usercall sub_10005500@<eax>(int a1@<esi>, int a2);
int __fastcall sub_10005560(unsigned int a1);
bool __cdecl sub_10005590(unsigned __int16 a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_100057F0(int a1);
int __cdecl sub_10005880(int a1);
char __cdecl sub_10005C90(char a1);
char __cdecl sub_10006480(char a1);
signed int sub_10006810();
char __cdecl sub_10006B40(char a1);
signed int sub_10007180();
char __cdecl sub_10007190(int a1, int a2, int a3, int a4, char a5, char *a6);
void *sub_10007210();
char __fastcall sub_10007230(int a1);
char sub_10007260();
char sub_100072D0();
char sub_10007350();
char sub_10007380();
char __cdecl sub_100073F0(int a1, int a2, int a3);
char __cdecl sub_10007500(char a1, unsigned __int8 a2, _DWORD *a3);
_DWORD __cdecl sub_100075A0(_DWORD, _DWORD); // weak
char __cdecl sub_100075B0(int a1, unsigned __int8 a2, int *a3);
char __cdecl sub_10007650(int a1, int a2, int a3);
int __cdecl sub_10007920(int a1, _BYTE *a2);
int sub_10007990();
// char __usercall sub_100079E0@<al>(int a1@<edx>, char a2);
// char __usercall sub_10007A70@<al>(int a1@<eax>, char a2);
char __fastcall sub_10007AF0(int a1, int a2);
char __cdecl sub_10007B10(int a1, unsigned __int8 a2, int a3);
char __cdecl sub_10007BE0(char a1, int a2);
char __cdecl sub_10007C70(char a1, int a2);
char __cdecl sub_10007D20(char a1, int a2, char a3, unsigned __int8 *a4, int *a5);
char __cdecl sub_10007E70(int a1, int a2, char a3);
void __cdecl sub_10007ED0(int a1, int a2);
_DWORD __cdecl sub_10007F60(_DWORD, _DWORD, char); // weak
char __cdecl sub_10007F70(int a1, int a2);
char __cdecl sub_10007FE0(int a1, int a2, int a3, int a4, int a5, int a6, unsigned __int16 a7, char a8);
int sub_10008080();
// char __usercall sub_100080E0@<al>(int a1@<edi>, unsigned __int8 *a2);
signed int sub_10008120();
void __cdecl sub_10008190(int a1, unsigned int a2, unsigned __int8 a3);
int sub_10008270(void); // weak
int __cdecl sub_10008280(char a1, int a2);
int __cdecl sub_100082A0(char a1, int a2);
int __cdecl sub_100082D0(int a1);
char sub_100082F0();
char __cdecl sub_10008300(_DWORD *a1);
int sub_10008320();
char sub_10008330();
char __cdecl sub_10008340(unsigned __int8 a1, _BYTE *a2);
void sub_10008360();
int (__cdecl *sub_10008370())(_DWORD);
char __cdecl sub_100083A0(unsigned __int8 a1, char a2);
int __cdecl sub_100083C0(char, char, char, char, int, void *, size_t); // idb
void *__cdecl sub_10008470(int a1);
char __cdecl sub_10008530(int a1, int a2, char a3);
// char __usercall sub_10008580@<al>(char a1@<bl>, int a2@<edi>, const void *a3@<esi>, char a4, char a5, char a6, unsigned int a7);
// signed int __usercall sub_10008790@<eax>(unsigned int a1@<eax>, int a2, char *a3, unsigned __int16 a4);
signed int sub_10008970();
signed int sub_100089C0();
void *sub_10008A60();
void *sub_10008A80();
void *sub_10008AA0();
char sub_10008AC0();
char __cdecl sub_10008BD0(char a1, int a2, int a3, int a4, int a5, void *a6, size_t a7);
void *sub_10008DB0();
// char __usercall sub_10008E10@<al>(char *a1@<eax>, int a2@<edi>, char a3, unsigned int a4, int a5);
char __cdecl sub_10009010(int a1);
char sub_10009470();
int __cdecl sub_10009740(char a1);
char __cdecl sub_10009790(int a1, int a2, int a3, int a4, int a5, int a6);
_DWORD __cdecl sub_10009800(char, _DWORD); // weak
int __cdecl sub_10009810(char a1, _WORD *a2);
char __cdecl sub_10009850(unsigned int a1);
signed int sub_100098B0();
char sub_100098D0();
// signed int __usercall sub_100098E0@<eax>(int a1@<eax>, int a2@<ecx>);
// char __usercall sub_10009930@<al>(char a1@<bl>, int a2@<edi>, const void *a3@<esi>, char a4, char a5, char a6, unsigned int a7);
char __cdecl sub_10009A90(char a1, char a2);
char __cdecl sub_10009B50(_BYTE *a1);
char __cdecl sub_10009B80(char a1, char a2, char a3, int a4, const void *a5, unsigned int a6);
char __cdecl sub_10009BB0(int a1, _DWORD *a2);
void sub_10009C10();
char __cdecl sub_10009C30(unsigned __int8 a1);
char __cdecl sub_10009C90(unsigned __int8 a1, unsigned __int8 a2, float *a3);
char __cdecl sub_10009D10(unsigned __int8 a1, float *a2);
int __cdecl sub_10009D30(char a1);
_DWORD __cdecl sub_10009D60(char); // weak
char __cdecl sub_10009D70(char a1);
char __cdecl sub_1000A030(unsigned __int8 a1, unsigned __int8 a2, float *a3);
int __cdecl sub_1000A0C0(float); // idb
char sub_1000A9E0();
signed int sub_1000AA20();
char __cdecl sub_1000AC70(int a1, char a2);
char __cdecl sub_1000ACF0(signed int a1);
char __cdecl sub_1000AD70(int a1);
char __cdecl sub_1000ADF0(char a1, void *a2);
char __cdecl sub_1000AE50(char a1, _BYTE *a2);
unsigned int __cdecl sub_1000AEC0(char a1);
char __cdecl sub_1000AF00(char a1, int a2, int a3, int a4, char a5, int a6);
char sub_1000AF60();
char __cdecl sub_1000AF90(__int16 a1);
char __cdecl sub_1000B110(int a1);
char __cdecl sub_1000B1E0(char a1);
char __cdecl sub_1000B250(char a1, const void *a2);
char __cdecl sub_1000B2B0(unsigned __int8 a1, char a2);
char __cdecl sub_1000B2D0(char a1, char a2);
// int __usercall sub_1000B3B0@<eax>(int a1@<esi>);
// void __usercall sub_1000B430(char a1@<bl>);
// char __usercall sub_1000B4A0@<al>(int a1@<eax>, void *a2@<ecx>, char a3);
// int __usercall sub_1000B510@<eax>(char a1@<bl>, const void *a2@<edi>);
// void __usercall sub_1000B560(int a1@<ecx>, char a2@<bl>);
// char __usercall sub_1000B5D0@<al>(char a1@<bl>);
unsigned __int8 __cdecl sub_1000B690(char a1);
char __cdecl sub_1000B800(char a1);
char __cdecl sub_1000B8A0(char a1, char a2);
char __cdecl sub_1000B940(char a1);
char sub_1000BA60();
char __cdecl sub_1000BAD0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1000BBB0(char a1, unsigned __int8 a2, _BYTE *a3);
char __cdecl sub_1000BC10(char a1, unsigned __int8 a2, _BYTE *a3);
char __cdecl sub_1000BC70(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1000BCF0(char a1, char *a2);
char __cdecl sub_1000BD50(unsigned __int8 a1, void *a2);
char __cdecl sub_1000BD80(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1000BE00(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1000BE70(char a1, char *a2);
char __cdecl sub_1000BEC0(char a1, int a2);
char __cdecl sub_1000BF60(char a1, char *a2);
char __cdecl sub_1000BFC0(char a1, int a2);
char __cdecl sub_1000C020(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1000C1E0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1000C380(char a1, char *a2);
char __cdecl sub_1000C3F0(char a1, int a2, char a3, unsigned __int8 *a4, char *a5, int a6);
// char __usercall sub_1000C670@<al>(int a1@<ecx>, _BYTE *a2@<edi>, _BYTE *a3@<esi>);
// char __usercall sub_1000C710@<al>(unsigned __int8 a1@<al>, int a2);
char __cdecl sub_1000C790(int a1, int a2, int a3, __int16 a4);
char __cdecl sub_1000C830(int a1, char a2, int a3, __int16 a4);
char __cdecl sub_1000C910(int a1, int a2, int a3, int a4, char a5, int a6);
char sub_1000C990();
char sub_1000CA10();
char __cdecl sub_1000CA50(char a1, _DWORD *a2);
char __cdecl sub_1000CAB0(unsigned __int8 a1, unsigned int *a2);
// char __usercall sub_1000CB20@<al>(unsigned __int8 a1@<bl>, char a2);
// char __usercall sub_1000CBD0@<al>(unsigned __int8 a1@<bl>, void *a2);
unsigned __int8 __cdecl sub_1000CC70(char a1);
char __cdecl sub_1000CE60(char a1, char a2);
bool __cdecl sub_1000CFD0(int a1, int a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_1000D0E0(char a1, char a2, char a3);
bool __cdecl sub_1000D1A0(char a1, char a2);
char __cdecl sub_1000D3C0(int a1);
// int __usercall sub_1000D5B0@<eax>(unsigned __int8 a1@<bl>, char a2, _DWORD *a3, _DWORD *a4);
char __cdecl sub_1000D640(char a1);
signed int sub_1000D680();
char __cdecl sub_1000D6C0(char a1, int a2, void *a3);
_DWORD sub_1000D750(); // weak
char __cdecl sub_1000D760(char a1, int a2, void *a3, int a4, char a5);
char __cdecl sub_1000D800(int a1, int a2);
// signed __int16 __usercall sub_1000D900@<ax>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_1000D920@<eax>(int a1@<esi>, signed int a2);
// int __usercall sub_1000DB20@<eax>(int a1@<eax>, int a2@<esi>, int a3);
char __cdecl sub_1000DC40(int a1, int a2);
signed __int16 __cdecl sub_1000DCC0(int a1, int a2);
char __cdecl sub_1000DCD0(int a1, int a2, void *a3, unsigned __int16 a4);
int __cdecl sub_1000DEC0(int a1, int a2);
char __cdecl sub_1000DF10(int a1, int a2, void *a3, unsigned __int16 *a4, unsigned __int16 a5);
int __cdecl sub_1000E120(int a1);
int __cdecl sub_1000E1D0(int a1);
char __cdecl sub_1000E280(int a1);
int __cdecl sub_1000E680(int a1);
char __cdecl sub_1000EA10(int a1, char a2, int a3, const void *a4, int a5);
char __cdecl sub_1000ED20(int a1, unsigned __int16 a2, char a3, int a4, const void *a5, int a6);
char __cdecl sub_1000F010(int a1, int a2, int a3);
char __cdecl sub_1000F2D0(int a1, int a2, void *a3, char a4, int a5);
int __cdecl sub_1000F560(int a1);
char __cdecl sub_1000F620(int a1, int a2, void *a3);
char __cdecl sub_1000F640(int a1, int a2, void *a3, unsigned __int16 *a4);
int __cdecl sub_1000F670(int a1);
char __cdecl sub_1000F7C0(int a1, int a2);
int sub_1000F840();
_DWORD __cdecl sub_1000F860(_DWORD); // weak
char sub_1000F870();
char __cdecl sub_1000F8B0(char a1, int a2, int a3, int a4, int a5);
char sub_1000F8E0();
int __cdecl sub_1000F8F0(int a1, int a2, unsigned __int16 a3, char a4, char a5);
char __cdecl sub_1000F9A0(int a1, int a2);
char sub_1000FB40();
signed int sub_1000FCC0();
int sub_1000FE00();
int sub_1000FE20();
int __cdecl sub_1000FF80(char a1);
signed int sub_1000FFA0();
// signed int __usercall sub_1000FFF0@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_10010090@<eax>(char a1@<al>);
// int __usercall sub_100100B0@<eax>(char a1@<al>);
// signed __int16 __usercall sub_100100D0@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_100102E0(char a1, unsigned __int16 a2, _BYTE *a3);
char __cdecl sub_10010430(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_100105A0(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_100106F0(int a1, int a2, void *a3, char a4, int a5, int a6);
char __cdecl sub_100108A0(char a1, int a2, int a3);
char __cdecl sub_100109B0(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_10010C20(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_10010C50(char a1, int a2, void *a3);
char __cdecl sub_10010C80(char a1, int a2, void *a3, int a4);
const char *__cdecl sub_10010CB0(int a1, unsigned __int16 a2);
char __cdecl sub_10010CE0(int a1, int a2);
// char __usercall sub_10010D30@<al>(__int16 a1@<bx>, int a2);
char __cdecl sub_10010E80(int a1, int a2);
char __cdecl sub_10010EE0(int a1, int a2);
char __cdecl sub_10010F40(int a1, int a2);
int __cdecl sub_10010FE0(char a1, int a2);
char __cdecl sub_10011100(int a1, int a2);
int __cdecl sub_100114D0(int a1, int a2, char a3);
char __cdecl sub_10011500(int a1, int a2, char a3);
char __cdecl sub_10011530(int a1);
char __cdecl sub_100116A0(char a1);
int sub_10011710();
char __cdecl sub_10011720(_DWORD *a1);
void __cdecl sub_10011740(unsigned __int8 a1, char *a2);
// char __usercall sub_100117F0@<al>(__int16 *a1@<esi>, unsigned __int8 a2, __int16 a3, int a4, char a5, char a6);
// BOOL __usercall sub_10011A70@<eax>(unsigned __int16 a1@<ax>, unsigned __int8 a2);
// char __usercall sub_10011A90@<al>(unsigned __int8 a1@<al>, _WORD *a2@<edx>, __int16 a3@<di>);
signed int sub_10011B10();
void __cdecl sub_10011B50(unsigned __int16 a1);
// unsigned int __usercall sub_10011D30@<eax>(__int16 a1@<dx>, int a2@<ecx>, char a3@<bl>, unsigned __int16 a4);
// char __usercall sub_10011D80@<al>(int a1@<ebx>, unsigned __int16 a2, unsigned __int8 a3, int a4, char a5, char a6);
char sub_10011F60();
// char __usercall sub_10012090@<al>(__int16 a1@<ax>, unsigned __int8 a2@<cl>, int a3, int a4, char a5, char a6);
// char __usercall sub_100120E0@<al>(unsigned __int16 a1@<di>);
// unsigned __int8 __usercall sub_10012140@<al>(char a1@<bl>, __int16 a2@<si>, int a3);
char __cdecl sub_100121A0(_BYTE *a1, unsigned __int16 a2, char a3);
int __cdecl sub_100122A0(char a1, __int16 a2, int a3);
unsigned int sub_100123B0();
void sub_100125E0();
int __cdecl sub_100125F0(char a1, __int16 a2, int a3);
char sub_10012660();
char __cdecl sub_10012670(unsigned __int8 a1, __int16 a2, _DWORD *a3);
char __cdecl sub_10012730(unsigned __int8 a1);
char __cdecl sub_10012760(unsigned __int8 a1);
char sub_10012780();
bool __cdecl sub_100127F0(char a1);
char __cdecl sub_10012850(char a1, char a2, char a3);
char sub_10012930();
char sub_10012A80();
int sub_10012AB0();
char __cdecl sub_10012AD0(_DWORD *a1);
// _BYTE *__usercall sub_10012AF0@<eax>(char a1@<bl>, int a2@<esi>);
// char __usercall sub_10012B90@<al>(int a1@<edi>, const char *a2@<esi>, char a3, char a4, int a5, int a6, int a7, __int16 a8, int a9);
// _DWORD *__usercall sub_10012D90@<eax>(int a1@<ecx>, int a2@<esi>);
// signed int __usercall sub_10012DB0@<eax>(int a1@<eax>, int a2@<edx>, void *a3@<ecx>);
signed int sub_10012DD0();
signed int sub_10012E20();
// _BYTE *__usercall sub_10012E60@<eax>(_DWORD *a1@<eax>);
// char __usercall sub_10012E90@<al>(int a1@<esi>, char a2, int a3, char a4, int a5, int a6, int a7, int a8, __int16 a9, int a10);
// char __usercall sub_100132D0@<al>(const void *a1@<eax>, int a2@<ebx>, char a3, unsigned __int16 a4);
char __cdecl sub_100133D0(char a1);
int sub_10013500();
_BYTE *__cdecl sub_100135A0(char a1);
// _BYTE *__usercall sub_10013660@<eax>(_BYTE *result@<eax>, int a2@<edx>, int a3@<ecx>);
// unsigned int __usercall sub_10013710@<eax>(unsigned int result@<eax>);
// __int16 __usercall sub_10013980@<ax>(unsigned __int64 a1@<edx:eax>);
char __thiscall sub_10013B90(void *this);
// _BYTE *__usercall sub_10013EB0@<eax>(int a1@<esi>);
// void __usercall sub_10014050(int a1@<eax>);
char __thiscall sub_10014130(int this);
char __cdecl sub_100142A0(int a1, int a2);
// void __usercall sub_100143A0(const void *a1@<ecx>, const void *a2@<esi>);
char __cdecl sub_10014450(char a1, int a2, char a3, int a4, const char *a5, int a6, int a7, __int16 a8, int a9);
char sub_10014510();
void sub_10014530();
signed int sub_10014540();
char sub_10014560();
// signed int __usercall sub_10014570@<eax>(int a1@<eax>, int a2@<ecx>);
// char __usercall sub_100145C0@<al>(const char *a1@<esi>, int a2, int a3, char a4, int a5, int a6, __int16 a7, char a8, int a9);
char __cdecl sub_100146C0(_BYTE *a1);
char __cdecl sub_100146F0(const char *a1, int a2, int a3, char a4, __int16 a5, int a6);
char __cdecl sub_10014750(int a1, _DWORD *a2);
char sub_100147B0();
char __cdecl sub_10014840(int a1, int a2);
char __cdecl sub_100148A0(int a1, int a2, __int16 a3);
int __cdecl sub_100148F0(int a1, int a2);
char __cdecl sub_10014940(int a1);
__int16 __thiscall sub_10014A00(void *this);
char __cdecl sub_10014A30(int a1, int a2, unsigned __int16 a3);
char __cdecl sub_10014B90(const void *a1, unsigned __int16 a2, int a3);
char __cdecl sub_10014BD0(int a1, int a2);
int __cdecl sub_10014C60(int a1, __int16 a2, int a3);
char __cdecl sub_10014D10(int a1, int a2);
int sub_10014D60();
int __cdecl sub_10014DB0(char a1);
char __cdecl sub_10014DE0(char a1, unsigned __int8 a2);
// void *__usercall sub_100155E0@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>);
signed int sub_10015630();
char **sub_10017430();
char **sub_10017440();
bool sub_10017450();
bool sub_100174C0();
bool sub_10017510();
bool sub_10017580();
bool sub_10017D00();
bool sub_10017D80();
bool sub_10017E00();
bool sub_10017F00();
bool sub_100183E0();
bool sub_100184A0();
bool sub_100189F0();
bool sub_10018A70();
bool sub_10018B00();
char sub_10018BC0();
bool sub_10018C20();
bool sub_10018C70();
char sub_10018CC0();
char sub_10018CD0();
int (**sub_10018CF0())();
int __cdecl sub_10018D00(float, float); // idb
bool __cdecl sub_10018D50(float *a1);
int sub_10018DF0();
char __cdecl sub_10018E20(float *a1);
char __cdecl sub_10018F20(bool *a1);
bool __thiscall sub_10019060(void *this);
signed int __cdecl sub_10019090(char a1, char a2);
int __cdecl sub_100190F0(char a1);
signed int __cdecl sub_10019130(char a1, char a2, char a3);
int __cdecl sub_100191A0(char a1);
int __cdecl sub_100191E0(char a1);
char __cdecl sub_10019220(int a1);
char __cdecl sub_10019240(int a1, int a2);
char __cdecl sub_10019260(char a1, int a2);
char __cdecl sub_10019280(char a1, int a2);
char __cdecl sub_100192B0(char a1, int a2);
char __cdecl sub_10019300(char a1, int a2);
char __cdecl sub_10019330(int a1);
char __cdecl sub_10019350(char a1, int a2);
char __cdecl sub_10019370(int a1);
char __cdecl sub_10019390(char a1);
char __cdecl sub_100193D0(char a1);
char __cdecl sub_10019440(char a1);
signed int __cdecl sub_100194B0(char a1);
char __cdecl sub_10019530(char a1);
char __cdecl sub_100195A0(char a1);
char __cdecl sub_10019650(int a1);
char __cdecl sub_10019760(char a1, void *a2);
char __cdecl sub_10019790(int a1);
// char __usercall sub_10019890@<al>(int a1@<edi>, char a2, unsigned __int8 a3);
char __cdecl sub_100198C0(char a1);
char __cdecl sub_100198E0(char a1);
char __thiscall sub_10019900(void *this);
char __cdecl sub_10019910(char a1);
char __cdecl sub_10019940(char a1);
bool __cdecl sub_10019970(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_100199E0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10019A40(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10019AB0(char a1, _BYTE *a2);
char __thiscall sub_10019AF0(void *this);
char __cdecl sub_10019B60(char a1, int a2);
char __cdecl sub_10019B90(char a1, int a2);
char __cdecl sub_10019BC0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
bool __thiscall sub_10019D90(void *this);
double sub_10019DA0(void); // weak
char __thiscall sub_10019DC0(void *this);
char __thiscall sub_10019E00(void *this);
int __cdecl sub_10019E30(int a1, int a2, int a3);
bool __thiscall sub_10019E90(void *this);
char __cdecl sub_10019F60(int a1);
char sub_10019F80();
int __cdecl sub_10019FB0(int a1, char *a2);
char __thiscall sub_1001A010(void *this);
char __thiscall sub_1001A030(void *this);
int __thiscall sub_1001A050(void *this);
char __thiscall sub_1001A070(void *this);
char __thiscall sub_1001A090(void *this);
char __thiscall sub_1001A0B0(void *this);
BOOL sub_1001A0D0();
int __cdecl sub_1001A0F0(char a1);
int __cdecl sub_1001A100(char a1);
int __cdecl sub_1001A110(char a1);
char __fastcall sub_1001A120(int a1);
BOOL __cdecl sub_1001A170(char a1);
char __cdecl sub_1001A270(unsigned int a1);
char __cdecl sub_1001A2E0(char a1);
char __cdecl sub_1001A330(char a1);
BOOL __cdecl sub_1001A360(char a1);
char __cdecl sub_1001A3D0(char a1);
void sub_1001A400();
char __cdecl sub_1001A410(char a1, int a2);
// char __usercall sub_1001A490@<al>(unsigned __int8 a1@<al>, _BYTE *a2);
// char __usercall sub_1001A4C0@<al>(bool *a1@<esi>);
char __cdecl sub_1001A4F0(char a1);
char __cdecl sub_1001A560(void *a1, int a2);
char __cdecl sub_1001A810(int a1, void *a2);
char __cdecl sub_1001A870(int a1);
char __cdecl sub_1001A8A0(void *a1);
char __cdecl sub_1001A8C0(char a1);
char __cdecl sub_1001A9E0(int a1, void *a2);
bool __cdecl sub_1001AB10(int a1, int a2);
char __cdecl sub_1001AC60(unsigned __int8 a1);
void sub_1001AEC0();
signed int sub_1001AED0();
char __thiscall sub_1001AF10(void *this);
char __cdecl sub_1001AF30(char a1);
char __thiscall sub_1001AF80(void *this);
char __thiscall sub_1001AFC0(void *this);
char sub_1001AFF0();
int __cdecl sub_1001B020(int a1);
char sub_1001B070();
char __cdecl sub_1001B0B0(char a1);
int __cdecl sub_1001B0F0(char a1);
double __cdecl sub_1001B110(char a1);
// bool __usercall sub_1001B190@<al>(int a1@<eax>);
char __cdecl sub_1001B200(char *a1);
double sub_1001B380(void); // weak
int __cdecl sub_1001B390(int a1, int a2, int a3);
void sub_1001B3A0();
int sub_1001B3B0();
void sub_1001B3E0();
signed int sub_1001B3F0();
signed int sub_1001B400();
char sub_1001B430();
int __thiscall sub_1001B4A0(void *this);
bool __cdecl sub_1001B4C0(char a1);
char *__cdecl sub_1001B530(int a1, char *a2, int a3, char *a4, int a5);
char sub_1001B660();
char __cdecl sub_1001B670(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_1001B770(char a1);
char __cdecl sub_1001B780(char *a1, int a2, char a3, char *a4);
char __cdecl sub_1001B7F0(char a1, _DWORD *a2);
// __int16 __usercall sub_1001B830@<ax>(int a1@<edi>, char a2);
// __int16 __usercall sub_1001B9D0@<ax>(int a1@<ebx>, unsigned __int8 a2);
// signed __int16 __usercall sub_1001BB30@<ax>(void *a1@<ecx>, signed __int16 a2@<bx>, const char *a3@<esi>);
char __cdecl sub_1001BD80(signed __int16 a1);
int __cdecl sub_1001BE10(signed __int16 a1);
int __cdecl sub_1001BF20(unsigned __int8 a1);
char __cdecl sub_1001BF40(unsigned __int16 a1);
char __cdecl sub_1001BFE0(signed __int16 a1, _BYTE *a2);
char __cdecl sub_1001C0A0(char a1, _BYTE *a2, unsigned __int8 a3);
char __cdecl sub_1001C160(char a1, int a2);
char __cdecl sub_1001C180(char a1);
char __cdecl sub_1001C1C0(int a1);
char sub_1001C1F0();
char __cdecl sub_1001C270(int a1);
bool sub_1001C320();
char __cdecl sub_1001C3C0(unsigned int a1);
double __fastcall sub_1001C400(int a1, int a2);
void *__cdecl sub_1001C460(__int16 a1);
// char __usercall sub_1001C7D0@<al>(unsigned __int16 a1@<ax>, int a2, char *a3);
// char __usercall sub_1001C840@<al>(int a1@<eax>, unsigned __int16 a2@<di>, char *a3@<esi>);
int sub_1001C980();
void *sub_1001CAD0();
char __cdecl sub_1001CB50(int a1, int a2, int a3, int a4, int a5, int a6, char *a7);
int sub_1001CF90();
// char __usercall sub_1001CFD0@<al>(char *a1@<eax>, int a2@<ebx>, unsigned __int8 a3, int a4, int a5, int a6);
bool __cdecl sub_1001D5D0(int a1, int a2, int a3, int a4, char *a5, char a6);
bool __cdecl sub_1001D810(int a1, char *a2);
int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1001DC80(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1001DE10(_DWORD *a1, unsigned int a2, int a3, int a4, int a5);
char __cdecl sub_1001DF30(char a1);
char __cdecl sub_1001DF60(char a1);
char __cdecl sub_1001DF90(char a1);
char __cdecl sub_1001DFB0(char a1, void *a2);
char __cdecl sub_1001DFD0(char a1, int a2, int a3, int a4, int a5);
char __cdecl sub_1001E050(int a1);
char __cdecl sub_1001E070(int a1, char a2);
// int __usercall sub_1001E520@<eax>(char a1@<al>, char a2@<cl>);
// char __usercall sub_1001E580@<al>(int a1@<esi>, char a2, char a3);
BOOL __cdecl sub_1001E5F0(unsigned __int8 a1, char a2);
__int16 __cdecl sub_1001E6C0(int a1, char a2);
// char __usercall sub_1001EA70@<al>(int a1@<esi>);
// char __usercall sub_1001EAC0@<al>(char a1@<bl>, unsigned __int8 a2, int a3);
int __cdecl sub_1001EB50(unsigned __int8 a1, char a2);
char __cdecl sub_1001EBF0(char a1, char a2, int a3, char a4);
char __cdecl sub_1001EC90(int a1, char a2);
char __cdecl sub_1001F3B0(unsigned __int8 a1);
char __cdecl sub_1001F3F0(unsigned __int8 a1);
char __cdecl sub_1001F420(char a1, void *a2);
char __cdecl sub_1001F440(char a1, void *a2);
bool __cdecl sub_1001F460(unsigned __int8 a1, char *a2);
bool __cdecl sub_1001F4A0(unsigned __int8 a1, _DWORD *a2);
char __cdecl sub_1001F4E0(int a1, unsigned __int8 a2);
char __cdecl sub_1001F570(int a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_1001F5B0(char a1, char a2, char *a3, char *a4);
int __thiscall sub_1001F7C0(void *this);
char __thiscall sub_1001F7E0(void *this);
char __cdecl sub_1001F870(char a1);
char __cdecl sub_1001F920(int a1, char a2);
char __cdecl sub_1001F9E0(int a1, char a2);
char __cdecl sub_1001FAA0(char a1, char a2);
char __cdecl sub_1001FAF0(char a1, unsigned __int8 *a2, _BYTE *a3);
char __cdecl sub_1001FB70(char a1, char a2);
char __cdecl sub_1001FBC0(char a1, unsigned __int8 *a2, _BYTE *a3);
char __cdecl sub_1001FC40(char a1);
char __cdecl sub_1001FC70(char a1);
char __cdecl sub_1001FCA0(char a1, unsigned __int8 *a2, _BYTE *a3);
char __cdecl sub_1001FD20(char a1);
char __cdecl sub_1001FD60(char a1, _BYTE *a2);
int *sub_1001FDB0();
char __cdecl sub_1001FDF0(char a1, int a2, _DWORD *a3);
// int __usercall sub_1001FEA0@<eax>(_BYTE *a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>);
signed int __cdecl sub_1001FEE0(int a1, int a2, _BYTE *a3, int a4);
_DWORD __cdecl sub_1001FFF0(_DWORD, _DWORD, _DWORD, _DWORD); // weak
bool __cdecl sub_10020000(int a1, char *a2);
char __cdecl sub_100200D0(char a1, __int16 a2, char a3, char a4, char a5);
char __cdecl sub_10020350(char a1, void *a2);
char __cdecl sub_10020400(char a1);
char __cdecl sub_10020460(char a1);
char *__cdecl sub_100204C0(char *a1);
char __cdecl sub_100205B0(int a1, int a2, int *a3);
int __cdecl sub_10020640(int a1, _BYTE *a2, int a3);
signed int __cdecl sub_10020690(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_10020700(void *, size_t); // idb
int __cdecl sub_10020730(char *, size_t, char *, va_list); // idb
int sub_10020770(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_100207A0(const char *a1, _BYTE *a2, int a3);
int __cdecl sub_100207E0(unsigned __int8 *a1, int a2);
int __cdecl sub_10020810(unsigned __int8 *a1, int a2);
int __cdecl sub_10020840(unsigned __int8 *a1, int a2);
int __cdecl sub_10020870(unsigned __int8 *a1, int a2);
int __cdecl sub_100208A0(unsigned __int8 *a1, int a2);
int __cdecl sub_100208D0(unsigned __int8 *a1, int a2);
int __cdecl sub_10020900(unsigned __int8 *a1, int a2);
int __cdecl sub_10020930(unsigned __int8 *a1, int a2);
int __cdecl sub_10020960(unsigned __int8 *a1, int a2);
int __cdecl sub_10020990(unsigned __int8 *a1);
int __cdecl sub_100209B0(unsigned __int8 *a1, int a2);
int __cdecl sub_100209E0(unsigned __int8 *a1, int a2);
int __cdecl sub_10020A10(unsigned __int8 *a1, int a2);
int __cdecl sub_10020A40(int a1);
unsigned int __cdecl sub_10020A70(char *a1);
int __cdecl sub_10020A90(unsigned __int8 *a1);
int __cdecl sub_10020AB0(_BYTE *a1);
int __cdecl sub_10020AD0(unsigned __int8 *a1);
int __cdecl sub_10020AF0(_BYTE *a1, int a2);
int __cdecl sub_10020B20(_BYTE *a1, int a2);
int __cdecl sub_10020B50(unsigned __int8 *a1, int a2);
signed int __cdecl sub_10020B80(_BYTE *a1, int a2);
int __cdecl sub_10020BB0(int a1, int a2);
int __cdecl sub_10020BF0(int a1);
unsigned int __cdecl sub_10020C20(int a1, int a2);
unsigned int __cdecl sub_10020F50(int a1, int a2);
_DWORD __cdecl sub_10021390(_DWORD); // weak
int __cdecl sub_100213A0(int a1);
unsigned int __cdecl sub_100213D0(_BYTE *a1);
int __cdecl sub_100213F0(unsigned __int8 *a1);
int __cdecl sub_10021410(unsigned __int8 *a1);
int __cdecl sub_10021430(_BYTE *a1);
int __cdecl sub_10021450(int a1);
// void __cdecl __noreturn exit(int);
int __cdecl sub_100214A0(unsigned __int8 *a1);
int __cdecl sub_100214C0(int a1);
unsigned int __cdecl sub_10021550(int a1);
signed int __cdecl sub_10021570(int a1);
unsigned int __cdecl sub_100215C0(int a1);
int __cdecl sub_10021620(_BYTE *a1);
unsigned int __cdecl sub_10021640(_BYTE *a1);
int __cdecl sub_10021660(unsigned __int8 *a1);
int __cdecl sub_10021680(_BYTE *a1);
int __cdecl sub_100216A0(_BYTE *a1);
int __cdecl sub_100216C0(_BYTE *a1, int a2);
int __cdecl sub_10021700(int a1, int a2);
int __cdecl sub_10021790(int a1);
int __cdecl sub_100217C0(unsigned __int8 *a1);
unsigned int __cdecl sub_100217E0(int a1);
int __cdecl sub_10021810(int a1);
int __cdecl sub_10021900(int a1);
int __cdecl sub_10021A10(unsigned __int8 *a1, int a2);
int __cdecl sub_10021A40(int a1);
unsigned int __cdecl sub_10021A70(void *a1, int a2);
int __cdecl sub_10021AA0(unsigned __int8 *a1, int a2);
int __cdecl sub_10021AD0(unsigned __int8 *a1, int a2);
signed int __cdecl sub_10021B00(int a1, int a2);
int __cdecl sub_10022010(_BYTE *a1, int a2);
signed int __cdecl sub_10022040(_BYTE *a1, int a2);
int __cdecl sub_100220B0(unsigned __int8 *a1);
int __cdecl sub_10022110(int a1);
int __cdecl sub_10022120(unsigned __int8 *a1, int a2);
int __cdecl sub_10022150(unsigned __int8 *a1);
int __cdecl sub_10022170(unsigned __int8 *a1, int a2);
int __cdecl sub_100221A0(unsigned __int8 *a1);
signed int __cdecl sub_100221C0(_BYTE *a1, int a2);
int __cdecl sub_100221F0(int a1, int a2);
_DWORD __cdecl sub_10022290(_DWORD); // weak
int __cdecl sub_100222A0(int a1);
unsigned int __cdecl sub_10022320(int a1);
unsigned int __cdecl sub_10022360(int a1);
int __cdecl sub_100223B0(int a1);
int __cdecl sub_100223E0(int a1, int a2);
signed int __cdecl sub_10022420(int a1);
unsigned int __cdecl sub_100227F0(void *a1, int a2);
int __cdecl sub_10022830(int a1);
unsigned int __cdecl sub_10022860(int a1);
unsigned int __cdecl sub_10022890(int a1);
unsigned int __cdecl sub_100228B0(int a1);
void __cdecl __noreturn sub_100228F0(int a1);
signed int __cdecl sub_10022A60(int a1, int a2);
unsigned int __cdecl sub_10022AB0(int a1, int a2);
int __cdecl sub_10022B20(int a1, int a2);
int __cdecl sub_10022B70(int a1);
int __cdecl sub_10022BE0(_BYTE *a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// int __usercall sub_10022C00@<eax>(unsigned __int8 *a1@<eax>, int a2@<edi>);
// signed int __usercall sub_10022C50@<eax>(int a1@<eax>, int a2@<edi>);
// int __usercall sub_10022D20@<eax>(unsigned __int8 *a1@<eax>, int a2@<esi>);
int __cdecl sub_10022E10(unsigned __int8 *a1);
signed int __cdecl sub_10022E20(_BYTE *a1, int a2);
unsigned int __cdecl sub_10022E70(int a1, int a2);
int __cdecl sub_10022F10(unsigned __int8 *a1);
signed int __cdecl sub_10022F20(int a1);
unsigned int __cdecl sub_10022F30(int a1, int a2);
char __cdecl sub_10023050(char a1);
char __cdecl sub_10023090(char a1);
signed int __cdecl sub_100230D0(char a1);
char __cdecl sub_10023110(char a1);
char __cdecl sub_10023150(int a1);
char __cdecl sub_10023190(char a1);
char __cdecl sub_100231B0(char a1);
char __cdecl sub_100231D0(char a1);
char __cdecl sub_100231F0(char a1);
char __cdecl sub_10023220(char a1);
char __cdecl sub_10023250(char a1);
int __cdecl sub_10023290(char *a1, char a2);
bool __cdecl sub_10023300(int a1, void *a2);
char __cdecl sub_100233C0(int a1, bool *a2);
int __cdecl sub_10023480(unsigned __int8 *a1);
unsigned int __cdecl sub_100234A0(void *a1);
unsigned int __cdecl sub_100234C0(void *a1);
unsigned int __cdecl sub_100234E0(void *a1);
unsigned int __cdecl sub_10023500(void *a1);
unsigned int __cdecl sub_10023520(void *a1);
int __cdecl sub_10023540(int a1);
int __cdecl sub_10023590(int a1);
signed int __cdecl sub_100235F0(_BYTE *a1, int a2);
int __cdecl sub_10023620(int a1);
int __cdecl sub_10023670(void *); // idb
unsigned int __cdecl sub_10023740(void *a1);
int __cdecl sub_100237A0(char a1);
signed int __fastcall sub_100237D0(unsigned __int8 a1);
char __cdecl sub_100237E0(unsigned __int8 a1);
__int16 __cdecl sub_10023800(unsigned __int8 a1);
char __cdecl sub_10023820(int a1, void *a2);
int __cdecl sub_10023890(int a1);
char __cdecl sub_100238C0(int a1, void *a2);
char __cdecl sub_10023950(int a1, int a2);
char __cdecl sub_10023A70(int a1);
char __cdecl sub_10023A80(int a1);
char __cdecl sub_10023A90(int a1);
char __cdecl sub_10023AA0(int a1);
char __cdecl sub_10023AB0(int a1);
char __cdecl sub_10023AC0(int a1);
int __cdecl sub_10023AD0(int *a1);
// char __usercall sub_10023B00@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_10023BA0(const char *a1);
char __cdecl sub_10023BE0(void *a1);
signed int __cdecl sub_10023C30(unsigned int a1, int a2);
char **sub_10023FD0();
int sub_10023FE0(void); // weak
signed int sub_10024010();
char *__cdecl sub_10024020(int a1, int a2, int a3, size_t a4, char *a5);
int sub_100241A0();
const char *__cdecl sub_100241B0(unsigned int a1);
int __cdecl sub_100241D0(int a1, int a2, int a3, int a4);
int __cdecl sub_10024280(int a1);
int __cdecl sub_100242A0(int a1);
char *sub_100242C0(char *a1, ...);
// char *__usercall sub_10024300@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_10024320@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_10024500();
int sub_10024520();
int __cdecl sub_10024540(int a1, int a2);
int __cdecl sub_100245A0(int a1);
int __cdecl sub_100245B0(int a1, int a2);
int __cdecl sub_10024610(int a1);
bool __cdecl sub_10024620(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_10024760(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_10024B10(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_10024F60(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_10025420(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_100257E0(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_10025BE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_10025FA0(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_100264E0(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_100268C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_10026C80(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_10027020(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_10027420(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_100277C0(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_10027DA0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_10028190(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_10028530();
// BOOL __usercall sub_10028560@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_100286D0@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_10028940(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_10028C40(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_10028CF0(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
char __cdecl sub_10028D30(char a1);
char __cdecl sub_10028D70(unsigned __int8 a1);
// __int16 __usercall sub_10028DA0@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10028DB0(unsigned __int8 a1, char *a2);
char __cdecl sub_10028E80(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
int __cdecl sub_10028F00(char a1);
// int __usercall sub_10028F10@<eax>(char *a1@<eax>, char a2@<cl>);
// char __usercall sub_10028F20@<al>(char a1@<bl>, char a2);
char __cdecl sub_10028FE0(char a1, char a2);
char __cdecl sub_10029000(char a1);
char __thiscall sub_10029030(void *this);
char sub_10029040();
bool __cdecl sub_10029080(int a1, void *a2, int a3);
char __cdecl sub_10029100(unsigned __int16 a1);
bool __cdecl sub_10029170(int a1, void *a2);
// signed int __usercall sub_100291A0@<eax>(unsigned __int8 a1@<al>, void *a2@<edi>, unsigned int a3@<esi>);
// int __usercall sub_10029210@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// signed int __usercall sub_10029240@<eax>(int a1@<edi>, unsigned __int8 a2, int a3);
// int __usercall sub_100293A0@<eax>(int a1@<ebx>, int a2, int a3);
// signed int __usercall sub_100294D0@<eax>(void *a1@<eax>, unsigned __int8 a2@<bl>, int a3);
// unsigned int __usercall sub_10029530@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, unsigned __int8 a5);
signed int __cdecl sub_100297D0(unsigned __int8 a1, unsigned int a2);
char __cdecl sub_10029A20(char *a1, char a2, int a3, int a4);
bool __cdecl sub_10029DD0(int a1, char *a2, int a3, int a4, int a5);
BOOL sub_1002A280();
char __cdecl sub_1002A2A0(char a1, __int16 a2, unsigned int *a3, unsigned int a4, char a5);
char __cdecl sub_1002A300(char a1, __int16 a2, unsigned int a3, int a4, int a5);
_DWORD __cdecl sub_1002A390(_DWORD, _DWORD); // weak
char __cdecl sub_1002A3A0(char *a1);
char __cdecl sub_1002A440(char a1);
char sub_1002A580();
char __cdecl sub_1002A5D0(int a1, char a2);
char __cdecl sub_1002A7A0(char a1);
__int16 *__cdecl sub_1002A800(char a1, unsigned __int16 a2);
int __cdecl sub_1002AA70(unsigned __int8 a1, char a2);
int __cdecl sub_1002AAF0(unsigned __int8 a1, char a2);
int __cdecl sub_1002AB70(unsigned __int8 a1, char a2);
void *__cdecl sub_1002ABF0(unsigned __int8 a1, char a2);
int __cdecl sub_1002AC70(char a1);
int __cdecl sub_1002AC90(char a1);
int __cdecl sub_1002ACB0(char a1);
void *__cdecl sub_1002ACD0(char a1, unsigned __int8 a2, char a3);
void *__cdecl sub_1002AD90(unsigned __int8 a1, char a2, char a3);
char __cdecl sub_1002AE30(char a1);
char __cdecl sub_1002AE50(char a1);
char __cdecl sub_1002AE70(char a1);
void *__cdecl sub_1002AE90(unsigned __int8 a1, char a2, char a3);
char sub_1002AF60();
int __cdecl sub_1002AF70(char a1);
char __cdecl sub_1002AF90(unsigned __int8 a1);
int __cdecl sub_1002AFB0(int, void *); // idb
// int __usercall sub_1002B010@<eax>(char a1@<al>);
BOOL __cdecl sub_1002B040(char a1, int a2);
int __cdecl sub_1002B070(int, char, int, int, void *); // idb
char __cdecl sub_1002B0A0(void *a1);
BOOL __cdecl sub_1002B0C0(int a1);
char __cdecl sub_1002B0E0(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_1002B110(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_1002B1A0(char a1, char a2, void *a3);
// char __usercall sub_1002B220@<al>(void *a1@<eax>, int a2);
bool __cdecl sub_1002B250(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
char __cdecl sub_1002B2F0(int a1, char a2, void *a3);
bool __cdecl sub_1002B410(char a1, void *a2);
// signed int __usercall sub_1002B450@<eax>(char a1@<al>);
bool __cdecl sub_1002B470(char a1, void *a2);
bool __cdecl sub_1002B560(char a1, char a2, int a3, int a4, void *a5);
BOOL __cdecl sub_1002B590(unsigned __int8 a1);
// BOOL __usercall sub_1002B5A0@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_1002B5D0(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_1002B780(unsigned __int8 a1, int a2);
bool __cdecl sub_1002B7C0(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
char sub_1002B8B0();
BOOL __cdecl sub_1002B950(int a1, int a2);
char __cdecl sub_1002B970(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_1002B9B0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_1002BA50(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1002BAD0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1002BB40(char a1, void *a2);
char __cdecl sub_1002BBC0(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1002BC40(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1002BCC0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1002BD30(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
BOOL sub_1002BE40();
char __cdecl sub_1002BEA0(int a1, char *a2);
BOOL __cdecl sub_1002BF90(int a1, int a2);
char __cdecl sub_1002BFB0(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_1002BFF0(int a1, int a2);
BOOL __cdecl sub_1002C0A0(int a1, int a2);
char __cdecl sub_1002C0C0(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_1002C100(void *a1);
char __cdecl sub_1002C120(void *a1);
bool __thiscall sub_1002C270(void *this);
char __cdecl sub_1002C290(unsigned __int8 a1);
char __cdecl sub_1002C300(int a1, char a2, char a3, int a4, void *a5, size_t a6);
bool __cdecl sub_1002C4A0(unsigned __int8 a1);
char __cdecl sub_1002C530(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_1002C640(char a1);
char __cdecl sub_1002C690(char a1, int a2);
// int __usercall sub_1002C800@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_1002C840@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_1002C880();
char __cdecl sub_1002C890(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_1002C8F0(char a1, void *a2);
char __cdecl sub_1002CA10(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1002CA90(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
char __cdecl sub_1002CC40(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_1002CD70(char a1, int a2);
bool __cdecl sub_1002CDF0(void *a1);
char __cdecl sub_1002CE40(char a1, int a2);
// __int16 __usercall sub_1002CF20@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_1002CF30(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_1002CFC0(unsigned __int8 a1, char a2);
bool __cdecl sub_1002D080(__int16 a1, char a2, int a3, int a4, void *a5);
int __cdecl sub_1002D180(char, void *); // idb
char __thiscall sub_1002D1C0(void *this);
// char __usercall sub_1002D230@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_1002D270@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_1002D310(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1002D350(char a1, char a2, void *a3);
char __cdecl sub_1002D3B0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1002D3F0(char a1, char a2, void *a3);
char __cdecl sub_1002D420(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1002D460(char a1, char a2, void *a3);
char __cdecl sub_1002D4A0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1002D4E0(char a1, char a2, void *a3);
char __cdecl sub_1002D530(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1002D570(char a1, char a2, void *a3);
char __cdecl sub_1002D5B0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1002D5F0(char a1, char a2, void *a3);
char __cdecl sub_1002D630(char a1, void *a2);
char __cdecl sub_1002D660(char a1, void *a2);
char __cdecl sub_1002D690(char a1, void *a2);
char __cdecl sub_1002D6C0(char a1, void *a2);
char __cdecl sub_1002D6F0(char a1, void *a2);
char __cdecl sub_1002D720(char a1, void *a2);
char __cdecl sub_1002D750(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1002D790(char a1, char a2, void *a3);
char __cdecl sub_1002D7E0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1002D820(char a1, char a2, void *a3);
char __cdecl sub_1002D850(char a1, void *a2);
char __cdecl sub_1002D880(char a1, void *a2);
char __cdecl sub_1002D8B0(char a1, void *a2);
char __cdecl sub_1002D8E0(int a1, char a2, char a3, int a4, void *a5);
BOOL __cdecl sub_1002DC80(int a1);
char __cdecl sub_1002DCA0(int a1);
int __cdecl sub_1002DD30(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_1002DE00(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
int __cdecl sub_1002E0A0(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_1002E170(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_1002E240(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_1002E310(unsigned __int8 a1, char a2);
int __cdecl sub_1002E3A0(unsigned __int8 a1, char a2);
int __cdecl sub_1002E430(unsigned __int8 a1, char a2);
char __cdecl sub_1002E4C0(unsigned __int8 a1);
char __cdecl sub_1002E4F0(unsigned __int8 a1);
char __cdecl sub_1002E520(unsigned __int8 a1);
int __cdecl sub_1002E550(unsigned __int8 a1, unsigned __int8 a2, char a3);
char __cdecl sub_1002E620(unsigned __int8 a1);
char __cdecl sub_1002E650(unsigned __int8 a1);
char __cdecl sub_1002E680(unsigned __int8 a1);
int __cdecl sub_1002E6B0(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_1002E780(unsigned __int8 a1, char a2);
int __cdecl sub_1002E810(unsigned __int8 a1, char a2);
int __cdecl sub_1002E8A0(int a1, unsigned __int8 a2, char a3);
int __cdecl sub_1002E940(unsigned __int8 a1, char a2);
int __cdecl sub_1002E960(unsigned __int8 a1, char a2);
char __cdecl sub_1002E980(char a1);
bool __cdecl sub_1002E9C0(unsigned __int8 a1, unsigned int a2);
char __cdecl sub_1002EA20(unsigned __int8 a1, int *a2, const void *a3);
bool __cdecl sub_1002EAE0(unsigned __int8 a1, unsigned int a2);
char __cdecl sub_1002EB40(char a1, _BYTE *a2, _BYTE *a3, char a4);
char __thiscall sub_1002EB80(void *this);
// void __usercall sub_1002EC40(unsigned __int16 a1@<bx>, unsigned __int16 *a2@<edi>, int a3, int a4, char a5, int a6);
char __cdecl sub_1002ECA0(char a1);
// char __usercall sub_1002ECE0@<al>(void *a1@<ecx>, int a2@<esi>);
char __cdecl sub_1002ED20(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_1002F2A0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_1002F300(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_1002F350(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_1002F3D0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_1002FB80(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_1002FC60(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_1002FCF0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_1002FF00(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_10030120(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_10030180(char a1, unsigned __int16 a2, int a3, int a4, int a5);
// void *__usercall sub_100301E0@<eax>(void *a1@<ebx>, const void *a2@<edi>, int a3@<esi>, int a4);
char sub_10030210();
char __cdecl sub_10030240(int a1);
bool __cdecl sub_10030280(unsigned __int8 a1);
char sub_100302C0();
char sub_100302D0();
char sub_100302E0();
int __cdecl sub_100302F0(char a1, char *a2);
char __cdecl sub_10030360(_DWORD *a1);
char __cdecl sub_10030470(int a1, unsigned int a2);
bool __cdecl sub_100304A0(const void **a1, int a2);
bool __cdecl sub_100304D0(const void **a1, int a2);
bool __cdecl sub_10030500(const void **a1, int a2);
bool __cdecl sub_10030530(const void **a1, int a2);
bool __cdecl sub_10030560(const void **a1, int a2);
bool __cdecl sub_10030590(int a1, int a2);
bool __cdecl sub_100305D0(int a1, int a2);
bool __cdecl sub_10030610(const void **a1, int a2);
bool __cdecl sub_10030640(const void **a1, int a2);
char __cdecl sub_10030670(int a1, unsigned int a2);
bool __cdecl sub_100306A0(const void **a1, int a2);
bool __cdecl sub_100306D0(const void **a1, int a2);
bool __cdecl sub_10030700(const void **a1, int a2);
bool __cdecl sub_10030730(const void **a1, int a2);
bool __cdecl sub_10030760(const void **a1, int a2);
bool __cdecl sub_10030790(const void **a1, int a2);
bool __cdecl sub_100307C0(const void **a1, int a2);
bool __cdecl sub_100307F0(const void **a1, int a2);
bool __cdecl sub_10030820(const void **a1, int a2);
bool __cdecl sub_10030850(const void **a1, int a2);
int __cdecl sub_10030880(int a1, int a2, int a3);
// void __cdecl __noreturn exit_0(int);
int __cdecl sub_100308F0(int a1, char a2);
int __cdecl sub_10030910(int a1, int a2, int a3);
int __cdecl sub_10030940(int a1, int a2, int a3, int a4);
int __cdecl sub_10030970(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_100309B0(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_100309F0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_10030A40(int a1);
char __cdecl sub_10030A70(int a1);
char __cdecl sub_10030A80(int a1, int a2);
signed int __cdecl sub_10030C00(int a1);
signed int __cdecl sub_10030C40(int a1, int a2, int a3);
char __cdecl sub_10030CE0(int a1);
char __cdecl sub_10030D40(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_10030DB0(char *a1);
int __cdecl sub_10030E50(int a1, int a2, int a3);
bool __cdecl sub_10030EC0(int a1, unsigned int a2, int a3);
char __cdecl sub_10030F50(int a1, int a2, char a3, char a4);
char __cdecl sub_10031000(int a1);
char __cdecl sub_10031010(int a1, void (__cdecl *a2)(int));
int (__cdecl *__cdecl sub_10031090(int a1, const char *a2))(const char *);
signed int __cdecl sub_100310E0(int a1, void (__cdecl *a2)(int));
unsigned int __cdecl sub_10031130(unsigned int a1);
int __cdecl sub_10031150(int a1);
bool __cdecl sub_10031160(int a1);
int __cdecl sub_10031230(int a1);
int __cdecl sub_10031250(int a1, int a2);
bool __cdecl sub_10031290(int a1);
signed int __cdecl sub_100312F0(int a1, void *a2, unsigned __int16 a3, __int16 a4);
signed int __cdecl sub_100313B0(int a1, int a2, int a3);
int __cdecl sub_10031460(int a1);
signed int __cdecl sub_10031480(_BYTE *a1, _BYTE *a2, int a3);
// int __usercall sub_100314E0@<eax>(int a1@<esi>, int a2, char a3);
// int __usercall sub_100315F0@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_100316A0@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_10031870@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_10031880@<eax>(int result@<eax>);
// char __usercall sub_100318A0@<al>(int a1@<eax>);
// int __usercall sub_100318C0@<eax>(int a1@<esi>, unsigned __int8 a2);
int __cdecl sub_10031900(unsigned int a1);
int __fastcall sub_10031AB0(int a1, int a2);
// int __usercall sub_10031AD0@<eax>(int result@<eax>, int a2@<ecx>);
// int __usercall sub_10031AE0@<eax>(int a1@<esi>);
// signed int __usercall sub_10031B20@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_10031D30(void *); // idb
int __cdecl sub_10031D90(int, int, void *, int); // idb
signed int __cdecl sub_10031E90(int a1, unsigned __int64 a2);
signed int __cdecl sub_10032090(int a1, int a2);
int __cdecl sub_100320B0(int a1);
int __cdecl sub_10032320(void *, int, char); // idb
signed int __cdecl sub_100323F0(unsigned int a1, int a2, int a3);
// int __usercall sub_10032490@<eax>(int a1@<eax>);
// int __usercall sub_100324B0@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_100324E0@<eax>(int a1@<eax>, int a2@<ebx>);
int __cdecl sub_10032550(int, char *, int); // idb
// void __cdecl __noreturn exit_1(int);
signed int __cdecl sub_100326C0(int a1);
// char __usercall sub_10032720@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_10032750@<eax>(int a1@<eax>);
// BOOL __usercall sub_10032780@<eax>(int a1@<ebx>, int a2);
signed int __cdecl sub_100327C0(unsigned int a1);
signed int __cdecl sub_10032810(int a1, int a2);
// bool __usercall sub_10032A00@<al>(int a1@<eax>);
int __cdecl sub_10032A30(int, int, char, void *, int); // idb
signed int __cdecl sub_10032B40(unsigned int a1, int a2, int a3);
signed int __cdecl sub_10032BA0(unsigned int a1, int a2, int a3);
int __cdecl sub_10032D30(int a1, char *a2, int a3, void *a4, int a5);
char __cdecl sub_10032F20(unsigned __int8 a1, signed int *a2, int a3, _BYTE *a4);
unsigned int __cdecl sub_10033610(void *a1, int a2);
int __cdecl sub_10033640(unsigned __int8 *a1, int a2);
signed int __cdecl sub_10033670(_BYTE *a1, int a2);
unsigned int __cdecl sub_100336A0(void *a1, int a2);
unsigned int __cdecl sub_100336D0(void *a1, int a2);
signed int __cdecl sub_10033710(unsigned __int8 *a1, int a2);
int __cdecl sub_10033740(unsigned __int8 *a1, int a2);
int __cdecl sub_10033770(int a1, int a2);
int __cdecl sub_100338F0(unsigned __int8 *a1, int a2);
int __cdecl sub_10033920(_BYTE *a1, int a2);
int __cdecl sub_10033950(int a1, int a2);
int __cdecl sub_10033A40(unsigned __int8 *a1, int a2);
int __cdecl sub_10033A70(unsigned __int8 *a1, int a2);
unsigned int __cdecl sub_10033AA0(void *a1, int a2);
unsigned int __cdecl sub_10033AD0(void *a1, int a2);
int __cdecl sub_10033B00(int a1, int a2);
int __cdecl sub_10033CC0(_BYTE *a1, int a2);
signed int __cdecl sub_10033CF0(unsigned __int8 *a1, int a2);
int __cdecl sub_10033D20(unsigned __int8 *a1, int a2);
signed int __cdecl sub_10033D50(int a1, int a2);
int __cdecl sub_10033DA0(void *, int); // idb
unsigned int __cdecl sub_10033DF0(void *a1, int a2);
int __cdecl sub_10033E20(int a1, int a2);
int __cdecl sub_10033E60(unsigned __int8 *a1);
int __cdecl sub_10033E80(unsigned __int8 *a1, int a2);
int __cdecl sub_10033EB0(int a1, int a2);
signed int __cdecl sub_10033EF0(_BYTE *a1, int a2);
int __cdecl sub_10033F20(int a1, int a2);
unsigned int __cdecl sub_10033F80(void *a1, int a2);
int __cdecl sub_10033FB0(unsigned __int8 *a1);
int __cdecl sub_10033FD0(int a1, int a2);
signed int __cdecl sub_10034010(_BYTE *a1, int a2);
int __cdecl sub_10034040(int a1, int a2);
int __cdecl sub_100340E0(int a1, int a2);
int __cdecl sub_10034120(int a1, int a2);
int __cdecl sub_10034270(int a1, int a2);
signed int __cdecl sub_100342B0(_BYTE *a1, int a2);
unsigned int __cdecl sub_100342E0(void *a1, int a2);
int __cdecl sub_10034310(int a1, int a2);
unsigned int __cdecl sub_10034390(int a1, int a2);
int __cdecl sub_10034450(unsigned __int8 *a1, int a2);
// signed int __usercall sub_10034480@<eax>(void *a1@<eax>, int a2@<esi>);
unsigned int __cdecl sub_100345E0(void *a1, int a2);
unsigned int __cdecl sub_10034620(void *a1, int a2);
signed int __cdecl sub_10034670(void *a1, int a2);
int __cdecl sub_10034680(int a1, int a2);
int __cdecl sub_100346D0(int a1, int a2);
int __cdecl sub_100347A0(int a1, int a2);
unsigned int __cdecl sub_10034800(void *a1, int a2);
int __cdecl sub_10034830(void *, int); // idb
int __cdecl sub_10034950(unsigned __int8 *a1, int a2);
int __cdecl sub_100349B0(int a1, int a2);
unsigned int __cdecl sub_10034A70(void *a1, int a2);
unsigned int __cdecl sub_10034AB0(void *a1, int a2);
int __cdecl sub_10034AF0(int a1, int a2);
int __cdecl sub_10034B80(int a1, int a2);
int __cdecl sub_10034C20(unsigned __int8 *a1, int a2);
int __cdecl sub_10034C90(int a1, int a2);
unsigned int __cdecl sub_10034CE0(int a1, int a2);
int __cdecl sub_10034DD0(int a1, int a2);
int __cdecl sub_10034EE0(int a1, int a2);
int __cdecl sub_10035150(int a1, int a2);
signed int __cdecl sub_10035190(_BYTE *a1, int a2);
signed int __cdecl sub_100351C0(int a1, int a2);
void *__cdecl sub_10035200(char a1);
void sub_10035260();
char __cdecl sub_10035270(const void *a1);
signed int sub_100352C0();
char __cdecl sub_100352D0(void *a1);
bool sub_10035320();
signed int __cdecl sub_10035360(int a1, int a2);
bool __cdecl sub_100353C0(signed int a1);
int sub_10035430();
char sub_10035750();
char sub_10035970();
char sub_10035B70();
char sub_10035CF0();
char sub_10035E70();
char sub_10035FE0();
char sub_100360E0();
char sub_10036240();
char sub_100363A0();
char sub_10036500();
char sub_10036670();
char sub_100367D0();
char sub_10036930();
char sub_10036B50();
char sub_10036CB0();
char sub_10036E10();
char sub_10036F70();
char sub_100370E0();
char sub_10037240();
char sub_100373A0();
char sub_100375C0();
char sub_100377C0();
char sub_10037940();
char sub_10037AC0();
char sub_10037C30();
char sub_10037D20();
char sub_10037E80();
char sub_10037FE0();
char sub_10038140();
char sub_100382B0();
char sub_10038410();
char sub_10038570();
char sub_10038770();
char sub_100388D0();
char sub_10038A30();
char sub_10038B90();
char sub_10038D00();
char sub_10038E60();
char sub_10038FC0();
char sub_10039560();
char sub_10039770();
char sub_10039960();
char sub_10039AD0();
char sub_10039C40();
char sub_10039DA0();
char sub_10039E90();
char sub_10039FF0();
char sub_1003A150();
char sub_1003A2B0();
char sub_1003A420();
char sub_1003A580();
char sub_1003A6E0();
char sub_1003A8E0();
char sub_1003AA40();
char sub_1003ABA0();
char sub_1003AD00();
char sub_1003AE70();
char sub_1003AFD0();
char sub_1003B130();
char sub_1003B340();
char sub_1003B530();
char sub_1003B6A0();
char sub_1003B810();
char sub_1003B970();
char sub_1003BA60();
char sub_1003BBC0();
char sub_1003BD20();
char sub_1003BE80();
char sub_1003BFF0();
char sub_1003C150();
char sub_1003C2B0();
char sub_1003C4B0();
char sub_1003C610();
char sub_1003C770();
char sub_1003C8D0();
char sub_1003CA40();
char sub_1003CBA0();
char **sub_1003CD00();
int __cdecl sub_1003CD10(_BYTE *a1);
int __cdecl sub_1003CD30(unsigned __int8 *a1);
int __cdecl sub_1003CD50(unsigned __int8 *a1);
int __cdecl sub_1003CD70(unsigned __int8 *a1);
int __cdecl sub_1003CD90(unsigned __int8 *a1);
_DWORD __cdecl sub_1003CDB0(_DWORD); // weak
int __cdecl sub_1003CDC0(int a1);
int __cdecl sub_1003CE00(int a1);
signed int __cdecl sub_1003CE20(_BYTE *a1, char a2, int a3);
int __cdecl sub_1003CE70(int, double, double, int, int, int); // idb
int __cdecl sub_1003CFC0(int, float, float, int, int); // idb
unsigned int __cdecl sub_1003D0B0(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_1003D100(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
unsigned int __cdecl sub_1003D1C0(void *a1, size_t a2, int a3);
int __cdecl sub_1003D220(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_1003D270(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_1003D310(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
char __cdecl sub_1003D3C0(char a1);
char __cdecl sub_1003D440(unsigned __int16 a1, _WORD *a2);
char __cdecl sub_1003D4A0(char a1, __int16 a2, unsigned __int16 *a3);
char __cdecl sub_1003D500(char *a1);
bool __thiscall sub_1003D530(void *this);
char __thiscall sub_1003D560(void *this);
char __cdecl sub_1003D590(const void *a1);
char __cdecl sub_1003D600(char a1);
char __cdecl sub_1003D640(char a1);
signed int __cdecl sub_1003D680(char a1);
bool __cdecl sub_1003D6D0(__int16 a1, __int16 a2, char a3, char *a4);
char sub_1003D870();
int __cdecl sub_1003D880(int a1, unsigned int a2);
__int16 __cdecl sub_1003D970(int a1, unsigned int a2);
__int16 __cdecl sub_1003D9C0(unsigned int *a1, _WORD *a2, _WORD *a3);
char *__cdecl sub_1003DA40(char **a1);
int sub_1003DA90();
int __cdecl sub_1003DAD0(_BYTE *a1, int a2);
signed int __cdecl sub_1003DB40(_BYTE *a1, int a2);
// int __usercall sub_1003DBE0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_1003DC10@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_1003DDE0@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// int __usercall sub_1003DE40@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_1003DED0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_1003DF20@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_1003DF80@<eax>(int a1@<eax>);
// int __usercall sub_1003DFA0@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_1003DFE0@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_1003E070@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_1003E1C0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_1003E260@<eax>(int result@<eax>);
char *__cdecl sub_1003E2A0(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_1003E450@<eax>(int a1@<eax>);
// int __usercall sub_1003E480@<eax>(int a1@<esi>);
void __cdecl sub_1003E4B0(int (**a1)(void), char **a2, _DWORD *a3);
int sub_1003E920();
void *sub_1003E970();
char *sub_1003E9D0();
char sub_1003E9F0();
char __cdecl sub_1003EA00(int a1, int a2, unsigned int a3);
// int *__usercall sub_1003EA40@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_1003EA90();
int __cdecl sub_1003EAA0(_DWORD *a1, int a2, int a3);
int __cdecl sub_1003EB50(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_1003ED60@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_1003EE20(char a1);
int *__cdecl sub_1003EEC0(_BYTE *a1);
// int __usercall sub_1003EF80@<eax>(int a1@<eax>);
// signed int __usercall sub_1003F0E0@<eax>(int a1@<esi>);
int __cdecl sub_1003F150(int, int); // weak
char **sub_1003F430();
// int __usercall sub_1003F440@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_1003F530(char *a1);
int sub_1003F770();
int __cdecl sub_1003F850(int a1, int a2, char a3);
int __cdecl sub_1003F8A0(int a1);
int __cdecl sub_1003F8B0(void *); // idb
int __cdecl sub_1003F930(int a1, int a2);
signed int __cdecl sub_1003F960(int a1, int a2, int a3);
const char *__cdecl sub_1003F980(int a1, int a2);
char __cdecl sub_1003F9C0(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_10040770(int a1, int a2);
char **__cdecl sub_100407F0(int a1);
int (__cdecl *__cdecl sub_10040830(const char *a1))(const char *);
const char *sub_10040850();
__int64 sub_10040860();
const char *sub_10040870();
// int __usercall sub_10040880@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_100408D0(int a1, int a2);
int sub_10040900(); // weak
// int __usercall sub_10040A20@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_10040DA0(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_10041BC0(int a1);
char __cdecl sub_10041C30(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_10041C70(const char *a1, int a2);
// char *__usercall sub_10041CE0@<eax>(char *result@<eax>);
void __cdecl sub_10041D10(char *a1);
void __cdecl sub_10041DD0(char *a1, char *a2);
void *__cdecl sub_10041E30(int a1);
int sub_10041FC0();
void __cdecl sub_10041FD0(int a1);
int __cdecl sub_10042000(int a1);
bool __cdecl sub_10042020(int a1);
void *__cdecl sub_10042050(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_10042090@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_100420B0@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_100420D0(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_10042100(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_100421E0(int a1, int a2, int a3);
// void *__usercall sub_10042290@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_10042510(int a1, int a2);
char __cdecl sub_100425E0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_10042650@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_100429B0@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_10042AC0(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_10042C50(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_10042DA0@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_10042EF0(int a1, int a2);
char __cdecl sub_10042F30(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
char __cdecl sub_10042F90(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
char __cdecl sub_10042FF0(unsigned __int8 a1);
int __cdecl sub_10043010(unsigned __int8 a1);
bool __thiscall sub_10043030(void *this);
char __cdecl sub_10043070(char a1, void *a2);
char __cdecl sub_10043120(char a1);
char __cdecl sub_10043150(char a1, void *a2);
int __cdecl sub_100431D0(char a1, _DWORD *a2);
signed int __cdecl sub_10043220(unsigned __int8 a1);
char __cdecl sub_10043350(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_10043480(char a1, char a2);
// bool __usercall sub_10043530@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_10043560@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_10043600(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10043680(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10043700(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10043780(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10043800(char a1);
BOOL __fastcall sub_100438A0(int a1);
void *__cdecl sub_100438D0(char a1);
char sub_10043920();
int *__cdecl sub_10043BB0(char a1);
bool __thiscall sub_10043C10(void *this);
void *__cdecl sub_10043C30(char a1);
int __cdecl sub_10043C90(unsigned __int8 a1, char a2);
int __cdecl sub_10043D10(unsigned __int8 a1);
int __cdecl sub_10043D30(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10043E00(unsigned __int8 a1, char a2);
int __cdecl sub_10043E90(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10043F60(int a1, unsigned __int8 a2, char a3);
int __cdecl sub_10044000(unsigned __int8 a1, char a2);
void *__cdecl sub_10044020(char a1);
void *__cdecl sub_10044080(char a1);
void *__cdecl sub_100440E0(char a1);
int __cdecl sub_10044140(char a1, char a2);
void *__cdecl sub_100441E0(char a1);
void *__cdecl sub_10044240(char a1);
BOOL __cdecl sub_100442A0(unsigned int a1);
BOOL __cdecl sub_100442C0(int a1);
_DWORD __cdecl sub_100442E0(_DWORD); // weak
unsigned int __cdecl sub_100442F0(int a1, char a2);
signed int __cdecl sub_10044350(void *a1, int a2, unsigned int a3);
int __cdecl sub_10044370(int a1, int a2, int a3);
char __cdecl sub_10044390(const char *a1, const char *a2);
int __cdecl sub_100444D0(int a1, int a2, unsigned int a3);
// signed int __usercall sub_10044550@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10045600@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_10045660@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_100463E0@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_10046400(int a1, unsigned int a2);
// int __usercall sub_10046460@<eax>(int result@<eax>);
// int __usercall sub_100464A0@<eax>(int result@<eax>);
// unsigned int __usercall sub_10047BC0@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_10047CC0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_10047D40@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_10047DE0@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_10047EA0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_10047F00@<eax>(char *a1@<edi>);
// int __usercall sub_10047FC0@<eax>(int a1@<ebx>);
char __cdecl sub_10048080(char *a1, size_t a2, int a3);
char __cdecl sub_100480D0(char *a1, unsigned int a2, int a3);
bool __cdecl sub_10048120(int a1, int a2);
// int __usercall sub_10048150@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_10048360@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_100483B0(int a1, int a2);
signed int __cdecl sub_10048440(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_10048570(void *a1, int a2);
// BOOL __usercall sub_100485F0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10048690@<eax>(int result@<eax>);
unsigned int __fastcall sub_10048720(unsigned int a1, int a2);
// int __usercall sub_10048740@<eax>(int result@<eax>);
// int __usercall sub_100487D0@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_10048C50@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_10048D00@<eax>(int a1@<edi>);
// int __usercall sub_10048D60@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_10048F30@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_10048FB0(int a1, int a2);
// signed int __usercall sub_10049020@<eax>(int a1@<esi>);
// unsigned int __usercall sub_100490E0@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_10049290@<eax>(int a1@<esi>, int a2);
// int __usercall sub_10049360@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_10049410@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_10049450@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_100494B0@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10049590@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
_WORD *__fastcall sub_10049B30(int a1, int a2);
signed int __cdecl sub_10049B90(int a1);
// int __usercall sub_10049C20@<eax>(int a1@<eax>);
// int __usercall sub_10049E60@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_10049F00@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_1004A0E0@<eax>(int a1@<edi>);
// int __usercall sub_1004A220@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_1004A4D0(int a1, int a2);
signed int __cdecl sub_1004A790(int a1, unsigned __int8 a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8);
// signed int __usercall sub_1004A940@<eax>(int a1@<eax>);
// _WORD *__usercall sub_1004AA10@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_1004AC30(int a1, int a2);
signed int __cdecl sub_1004AF40(int a1, int a2);
signed int __cdecl sub_1004B350(int a1, int a2);
int __cdecl sub_1004B4C0(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_1004B5C0(int a1);
// signed int __usercall sub_1004B5E0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_1004BA80@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_1004BAD0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_1004BAF0(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_1004BEA0@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_1004BFE0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_1004C030@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_1004C0D0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_1004C0F0(int a1, int a2, int a3, int a4);
signed int __cdecl sub_1004C1E0(int a1);
// int __usercall sub_1004C1F0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1004C890@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_1004D270@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_1004D5A0(int a1, int a2);
signed int __cdecl sub_1004D5C0(unsigned int a1);
signed int __cdecl sub_1004D600(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_1004D660(unsigned int a1, int a2, int a3);
int __cdecl sub_1004D680(_BYTE *a1, int a2);
int __cdecl sub_1004D6C0(_BYTE *a1, int a2);
bool __cdecl sub_1004D6F0(void *a1);
int __cdecl sub_1004D730(int a1);
int __cdecl sub_1004D740(int a1, int a2);
// char __usercall sub_1004D880@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_1004D950(_DWORD *a1, char *a2);
int __cdecl sub_1004DA30(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_1004DA50@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_1004DA60@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_1004DC90(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1004DCE0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1004DD30(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_1004DD80(int a1))(int);
int __cdecl sub_1004DE00(int a1, int a2);
int (__cdecl *__cdecl sub_1004DE80(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_1004DED0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1004DF10(int a1, int a2, int a3))(int);
char __cdecl sub_1004DF70(char a1);
int __cdecl sub_1004DFF0(int a1);
// int (*__usercall sub_1004E000@<eax>(int a1@<eax>, double *a2@<ecx>, int a3@<edi>, int a4@<esi>, int a5, int a6, char a7, double a8, int a9))(void);
// int __usercall sub_1004E0D0@<eax>(int result@<eax>, _DWORD *a2@<edi>, unsigned int a3@<esi>, char a4);
int (*__cdecl sub_1004E110(char a1, double a2, int a3, int a4, int a5, int a6))(void);
int (*__cdecl sub_1004E1A0(char a1, double a2, int a3, int a4, int a5, int a6))(void);
unsigned __int16 __cdecl sub_1004E220(_BYTE *a1, int a2, unsigned __int16 a3, char a4);
int __cdecl sub_1004E2A0(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_1004E2C0(unsigned int *a1, signed int a2, unsigned int a3);
double __cdecl sub_1004E3F0(float a1);
int __cdecl sub_1004E420(int a1);
int sub_1004E440();
int __cdecl sub_1004E460(int a1, int a2);
__int16 __cdecl sub_1004E490(int a1);
int sub_1004E4B0();
int __cdecl sub_1004E4D0(int a1, int a2, int a3, int a4);
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_1004E510(int a1, int a2, int a3, int a4);
int __cdecl sub_1004E540(int a1);
int __cdecl sub_1004E560(int a1, int a2);
int __cdecl sub_1004E590(int a1, int a2);
int __cdecl sub_1004E5C0(int a1, int a2, int a3, int a4);
int __cdecl sub_1004E5F0(int a1, int a2);
int __cdecl sub_1004E620(int a1);
int __cdecl sub_1004E640(int a1);
int __cdecl sub_1004E660(_BYTE *a1);
int __cdecl sub_1004E6A0(int a1, int a2);
int __cdecl sub_1004E6D0(int a1, int a2);
int __cdecl sub_1004E6F0(int a1);
int __cdecl j_REG_pvg_flush_que(_DWORD, _DWORD, _DWORD); // weak
unsigned int __cdecl sub_1004E740(unsigned int a1);
int __cdecl sub_1004E770(int a1, int a2, int a3);
int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_reg_get_tag_info(_DWORD, _DWORD); // weak
int __cdecl j_reg_get_xfil_tag_data(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1004E7C0(int a1, int a2, int a3);
int __cdecl sub_1004E7E0(int a1, int a2, __int16 a3, int a4, int a5);
char __cdecl sub_1004E840(int a1, int a2, int a3);
int __cdecl sub_1004E880(int, void *, int, void *); // idb
int __cdecl sub_1004E8C0(int a1, int a2, int a3);
int __cdecl sub_1004E8F0(int a1, int a2, int a3);
int __cdecl sub_1004E910(int a1, int a2, int a3);
int __cdecl sub_1004E970(int a1, int a2, int a3);
char __cdecl sub_1004E9B0(int a1, int a2, int a3);
int __cdecl j_REG_pvg_xfil_read_data(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_REG_pvg_xfil_shld_rqst_tag(_DWORD); // weak
int __cdecl j_REG_pvg_xfil_write_data(_DWORD, _DWORD); // weak
int __cdecl sub_1004EA20(int a1, unsigned __int8 a2);
char __cdecl sub_1004EB00(int a1, _DWORD *a2, int a3, int a4, int a5, unsigned int a6);
int __cdecl sub_1004EC10(int, void *, int, void *); // idb
int sub_1004EC60(void); // weak
int __cdecl j_HWM_pvg_get_anlg_outp(_DWORD); // weak
int __cdecl j_HWM_pvg_get_frmt_adc(_DWORD); // weak
int __cdecl j_HWM_pvg_get_uart(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_hsdb_get(_DWORD, _DWORD); // weak
int j_HWM_pvg_hsdb_get_lrus_online(void); // weak
int __cdecl j_HWM_pvg_hsdb_put(_DWORD); // weak
int __cdecl j_HWM_pvg_hsdb_set_sim_lrus_online(_DWORD); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_put_uart(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
int __cdecl j_HWM_pvg_set_uart(_DWORD);
int sub_1004ED20();
int __cdecl sub_1004ED40(int a1, int a2);
char __cdecl sub_1004EE60(char a1);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
void __cdecl sub_1004EEB0(int a1, _BYTE *a2);
int __cdecl sub_1004EEE0(int a1, int a2);
int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD); // weak
signed int __cdecl sub_1004EF10(unsigned int a1);
signed int __cdecl sub_1004EF50(unsigned int a1);
int __cdecl j_FIL_vfs_crc32(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl j_FIL_vfs_ioctl(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1004EFB0(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_1004F020(unsigned int a1, void *a2, int a3);
signed int __cdecl sub_1004F060(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
signed int __cdecl sub_1004F0F0(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_1004F140(int a1);
int j_FIL_vfs_sync_all(void); // weak
int __cdecl sub_1004F170(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1004F1A0(int a1, int a2, int a3, char a4);
char __cdecl sub_1004F1C0(int a1);
int __cdecl sub_1004F1F0(unsigned int a1, unsigned int a2);
signed int __cdecl sub_1004F240(unsigned int a1, int a2, int a3);
int __cdecl sub_1004F260(int a1, int a2, int a3);
int __cdecl j_HWM_pvg_arnc_open(_DWORD); // weak
int __cdecl j_HWM_pvg_arnc_read(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1004F2B0(int a1, int a2);
signed int __cdecl sub_1004F310(int a1);
// int __usercall sub_1004F390@<eax>(const char **a1@<esi>);
// int __usercall sub_1004F690@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_1004F6B0(int a1);
int __cdecl sub_1004F780(LONG Value); // idb
int __cdecl j_HWM_pvg_dspl_bklt_set_bias_data(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_dspl_bklt_set_cnfg(_DWORD, _DWORD, _DWORD); // weak
char __cdecl sub_1004F830(int a1, char a2);
char __cdecl sub_1004F930(int a1);
int __cdecl sub_1004F9A0(int a1);
int __cdecl sub_1004F9E0(int a1);
int __cdecl sub_1004FA20(int a1);
int __cdecl sub_1004FA60(int a1);
int __cdecl sub_1004FAA0(int a1, int a2, int a3, int a4);
int __cdecl sub_1004FB10(int a1, int a2, int a3);
int __cdecl sub_1004FBB0(int a1, char a2);
int __cdecl sub_1004FC80(int a1);
int __cdecl sub_1004FCD0(char a1);
int sub_1004FD00(void); // weak
char __cdecl sub_1004FD10(unsigned int a1, unsigned int *a2, int *a3);
int __cdecl sub_1004FFD0(int, void *); // idb
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_100502D0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_10050320(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
bool sub_10050390();
void __cdecl sub_100503B0(__int16 a1, _BYTE *a2);
unsigned int __cdecl sub_100503E0(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_10050590@<eax>(int a1@<esi>);
int __cdecl sub_10050640(int a1, unsigned __int64 a2);
// int __usercall sub_100506F0@<eax>(int a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_10050780(int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
// int SYS_exit_krnl(void); weak
// int SYS_enter_krnl(void); weak
// int __cdecl SYS_pvg_alrt_is_acked(_DWORD); weak
// int __cdecl SYS_pvg_alrt_is_set_queued(_DWORD); weak
// int __cdecl SYS_pvg_alrt_is_viewed(_DWORD); weak
// int __cdecl SYS_pvg_alrt_queue(_DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_set(_DWORD); weak
// int __cdecl SYS_pvg_alrt_set_data(_DWORD, _DWORD, _DWORD); weak
// int SYS_pvg_alrt_viewed(void); weak
// int __cdecl SYS_pvg_alrt_ack(_DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_clr(_DWORD); weak
// int __cdecl SYS_pvg_alrt_clr_data(_DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_set_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl reg_tag_dflt(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_read_from_xml(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD); weak
// int FIL_vfs_close(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl HWM_pvg_arnc_close(_DWORD); weak
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// void *__cdecl memset(void *, int, size_t);
// char *__cdecl strncpy(char *, const char *, size_t);
// void *__cdecl memcpy(void *, const void *, size_t);
// int _snprintf(char *, size_t, const char *, ...);
// int sprintf(char *, const char *, ...);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// char *__cdecl strstr(const char *, const char *);
// char *__cdecl strrchr(const char *, int);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isprint(int);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// char *__cdecl strchr(const char *, int);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// double __cdecl floor(double);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_10052ABC(int a1, int a2, char a3);
// int __cdecl strncmp(const char *, const char *, size_t);
// char *__cdecl strncat(char *, const char *, size_t);
// char *__cdecl strpbrk(const char *, const char *);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
int __cdecl sub_10053EB2(int, FILE *); // idb
int __cdecl sub_10054A47(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
signed int __cdecl sub_10054C1A(_DWORD *a1);
signed int __cdecl sub_10054C51(_DWORD *a1);
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_10055897();
int (*sub_10055D44())(void);
void __cdecl sub_10055D68(); // idb
// int __cdecl isleadbyte(int);
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_1005976A(FILE *, int, struct localeinfo_struct *, int); // idb
int __cdecl sub_1005B94C(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_1005B9F2(int, int, struct localeinfo_struct *); // idb
void sub_1005BE62();
// int _get_sse2_info(void); weak
int sub_1005BF1A();
DWORD __cdecl sub_1005BF27(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_1005C0C3(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_1005C6E5(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_1005C805(signed int a1);
void **sub_1005C863();
signed int sub_1005C869();
// int __cdecl _fileno(FILE *);
int sub_1005D152();
int __cdecl sub_1005D30F(int a1);
int __cdecl sub_1005D319(int a1);
int __cdecl sub_1005D323(int a1);
int __cdecl sub_1005D402(int a1);
int sub_1005ED0C();
int __cdecl sub_1005F7C6(FILE *); // idb
int __cdecl sub_1005F8E6(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
signed int __cdecl sub_1005FB2E(int a1, int a2);
signed int __cdecl sub_10060070(int a1, int a2);
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
signed int __cdecl sub_10061969(signed int a1);
signed int __cdecl sub_100619EA(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_10061AFB(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_10061DFC();
int __cdecl sub_10061E05(int a1, int a2, int a3);
// int __cdecl _read(int, void *, unsigned int);
signed int __cdecl sub_10062DE1(signed int a1);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();
// LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_1004BFA0; // weak
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
char *off_10064420[3] = { "test_cdu_cnfg", "$Id$", &off_10064290 }; // weak
char *off_1006448C = "test_gma_dig_frmt"; // weak
char byte_100647C9 = '\0'; // idb
_UNKNOWN unk_10065968; // weak
char byte_10065969[3010] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'C',
  'U',
  ' ',
  '1',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'C',
  'U',
  ' ',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'C',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  'R',
  'E',
  'Q',
  'U',
  'E',
  'S',
  'T',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'C',
  'U',
  ' ',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'R',
  'E',
  'Q',
  'U',
  'E',
  'S',
  'T',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'C',
  'U',
  ' ',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'R',
  'E',
  'Q',
  'U',
  'E',
  'S',
  'T',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'C',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  'V',
  'E',
  'R',
  'I',
  'F',
  'Y',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'C',
  'U',
  ' ',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'V',
  'E',
  'R',
  'I',
  'F',
  'Y',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'C',
  'U',
  ' ',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'V',
  'E',
  'R',
  'I',
  'F',
  'Y',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'C',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'C',
  'U',
  ' ',
  '1',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'C',
  'U',
  ' ',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'C',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'C',
  'U',
  ' ',
  '1',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'C',
  'U',
  ' ',
  '2',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'C',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\a',
  'G',
  'C',
  'U',
  ' ',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'C',
  'U',
  ' ',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'M',
  'C',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  'G',
  'C',
  'U',
  ' ',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'F',
  'A',
  'I',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'C',
  'U',
  ' ',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'F',
  'A',
  'I',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'M',
  'C',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'F',
  'A',
  'I',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\t',
  'G',
  'C',
  'U',
  ' ',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'C',
  'A',
  'N',
  'C',
  'E',
  'L',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'C',
  'U',
  ' ',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'C',
  'A',
  'N',
  'C',
  'E',
  'L',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'G',
  'M',
  'C',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'C',
  'A',
  'N',
  'C',
  'E',
  'L',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\n',
  'S',
  'T',
  'O',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'C',
  'U',
  ' ',
  '1',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'S',
  'T',
  'O',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'C',
  'U',
  ' ',
  '2',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'S',
  'T',
  'O',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'M',
  'C',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_10066A78; // weak
char byte_10066A79[] = { '\x01' }; // weak
__int16 word_10066A7A[] = { 1286 }; // weak
__int16 word_10066A7C[] = { 1292 }; // weak
__int16 word_10066AA4[] = { 111 }; // weak
__int16 word_10066AA6[] = { 110 }; // weak
__int16 word_10066AB0[] = { 235 }; // weak
__int16 word_10066AB2[] = { 233 }; // weak
__int16 word_10066AB4[] = { 234 }; // weak
__int16 word_10066AB6[] = { 236 }; // weak
__int16 word_10066AB8[] = { 320 }; // weak
__int16 word_10066ABA[] = { 326 }; // weak
_UNKNOWN unk_10066AD4; // weak
char byte_10066AD5[] = { '\t' }; // weak
__int16 word_10067814[] = { 83 }; // weak
__int16 word_10067816[] = { 219 }; // weak
__int16 word_10067818[] = { 148 }; // weak
_UNKNOWN unk_10067968; // weak
_UNKNOWN unk_10068780; // weak
char *off_10068B50[3] = { "IOP_A_test.c", "$Id:", &off_100689E8 }; // weak
_UNKNOWN unk_10069090; // weak
char byte_10069092[] = { '\x03' }; // weak
__int16 word_10069094[] = { 175 }; // weak
__int16 word_10069318[] = { 0 }; // weak
char aArfrm_feature[14] = "ARFRM.FEATURE"; // weak
int dword_10069798[] = { 81 }; // weak
char byte_10069882[] = { '\0' }; // weak
_UNKNOWN unk_1006A128; // weak
char byte_1006A19C[] = { '\0' }; // weak
_UNKNOWN unk_1006A260; // weak
_UNKNOWN unk_1006A368; // weak
_UNKNOWN unk_1006A698; // weak
_UNKNOWN unk_1006A6E0; // weak
_UNKNOWN unk_1006A724; // weak
char *off_1006A754 = "/shr_mem/iop_arnc_adc_intf.shr"; // weak
_UNKNOWN unk_1006A808; // weak
_UNKNOWN unk_1006A970; // weak
_UNKNOWN unk_1006AAF0; // weak
_UNKNOWN unk_1006AB38; // weak
_UNKNOWN unk_1006AB80; // weak
_UNKNOWN unk_1006ABC8; // weak
char *off_1006AC10 = "/shr_mem/iop_arnc_ahrs_intf.shr"; // weak
char byte_1006B170[] = { '\x05' }; // weak
char byte_1006E658[] = { '\0' }; // weak
int dword_1006E65C[] = { 0 }; // weak
int dword_1006E660[] = { 0 }; // weak
int dword_1006E664[] = { 0 }; // weak
int dword_1006E668[] = { 0 }; // weak
int dword_1006E66C[] = { 0 }; // weak
int dword_1006E670[] = { 0 }; // weak
int dword_1006E674[] = { 0 }; // weak
int dword_1006E678[] = { 0 }; // weak
int dword_1006E67C[] = { 0 }; // weak
int dword_1006E680[] = { 0 }; // weak
int dword_1006EBB0[] = { 28 }; // weak
char *off_1006EC94 = "/shr_mem/iop_a_cnfg_mngr_intf.shr"; // weak
char *off_1006ECA8 = "/shr_mem/iop_cnfg_mngr_intf.shr"; // weak
char *off_1006ECBC = "/shr_mem/iop_prod_enbl_intf.shr"; // weak
int dword_1006ECD0[] = { 29 }; // weak
_UNKNOWN unk_100704DC; // weak
_UNKNOWN unk_100704E8; // weak
int dword_100704EC[] = { 0 }; // weak
void *off_100704F0 = &unk_1006F3C0; // weak
__int16 word_100704F4[] = { 978 }; // weak
_UNKNOWN unk_10070888; // weak
int dword_1007088C[] = { 0 }; // weak
_UNKNOWN unk_10070AA0; // weak
char *off_10070AE0 = "/shr_mem/iop_b_cnfg_mngr_intf.shr"; // weak
char *off_10070AF4 = "/shr_mem/iop_c_cnfg_mngr_intf.shr"; // weak
char *off_10070B08 = "/shr_mem/iop_d_cnfg_mngr_intf.shr"; // weak
_UNKNOWN unk_10070E20; // weak
void *off_10070E24 = &unk_10070B98; // weak
char byte_10071048[] = { '5' }; // weak
_UNKNOWN unk_1007104A; // weak
char byte_1007104C[] = { '\0' }; // weak
char byte_1007104D[] = { '\x01' }; // weak
int off_10071050 = 269666548; // idb
double *off_1007105C = &dbl_1012C6C8; // weak
char *off_10071198 = "/shr_mem/iop_fltr_data_intf.shr"; // weak
int dword_10071D50[] = { 256 }; // weak
__int16 word_10071D54[] = { 75 }; // weak
__int16 word_10071D56[] = { 5 }; // weak
__int16 word_10071D58[] = { 6 }; // weak
_UNKNOWN unk_10071D68; // weak
_BYTE byte_10071D69[2010] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  73,
  65,
  32,
  35,
  49,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  73,
  65,
  32,
  35,
  50,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  82,
  69,
  81,
  85,
  69,
  83,
  84,
  73,
  78,
  71,
  32,
  71,
  73,
  65,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  82,
  69,
  81,
  85,
  69,
  83,
  84,
  73,
  78,
  71,
  32,
  71,
  73,
  65,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  86,
  69,
  82,
  73,
  70,
  89,
  73,
  78,
  71,
  32,
  71,
  73,
  65,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  86,
  69,
  82,
  73,
  70,
  89,
  73,
  78,
  71,
  32,
  71,
  73,
  65,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  4,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  73,
  65,
  32,
  35,
  49,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  73,
  65,
  32,
  35,
  50,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  6,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  73,
  65,
  32,
  35,
  49,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  73,
  78,
  71,
  32,
  71,
  73,
  65,
  32,
  35,
  50,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  7,
  71,
  73,
  65,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  71,
  73,
  65,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  85,
  82,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  8,
  71,
  73,
  65,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  70,
  65,
  73,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  71,
  73,
  65,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  70,
  65,
  73,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  9,
  71,
  73,
  65,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  67,
  65,
  78,
  67,
  69,
  76,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  71,
  73,
  65,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  32,
  67,
  65,
  78,
  67,
  69,
  76,
  76,
  69,
  68,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  83,
  84,
  79,
  82,
  73,
  78,
  71,
  32,
  71,
  73,
  65,
  32,
  35,
  49,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  83,
  84,
  79,
  82,
  73,
  78,
  71,
  32,
  71,
  73,
  65,
  32,
  35,
  50,
  32,
  67,
  79,
  78,
  70,
  73,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
int dword_10072544[] = { 0 }; // weak
char byte_10072548[] = { '\x02' }; // weak
char byte_10072549[] = { '\x03' }; // weak
_UNKNOWN unk_10072574; // weak
char byte_10072575[] = { '\x01' }; // weak
__int16 word_10072BD8[] = { 21 }; // weak
__int16 word_10072BDA[] = { 19 }; // weak
__int16 word_10072BDC[] = { 17 }; // weak
__int16 word_10072BDE[] = { 565 }; // weak
__int16 word_10072BE0[] = { 567 }; // weak
_UNKNOWN unk_10072BE2; // weak
_UNKNOWN unk_10073250; // weak
int dword_10073254[] = { 140 }; // weak
int dword_10073258[] = { 2 }; // weak
int dword_1007325C[] = { 15 }; // weak
__int16 word_10073420[] = { 0 }; // weak
__int16 word_10073424[] = { 2 }; // weak
__int16 word_10073428[] = { 4 }; // weak
__int16 word_1007342C[] = { 6 }; // weak
__int16 word_10073430[] = { 14 }; // weak
__int16 word_10073434[] = { 8 }; // weak
__int16 word_10073438[] = { 10 }; // weak
__int16 word_1007343C[] = { 12 }; // weak
_UNKNOWN unk_10073440; // weak
char byte_10073441[] = { '\0' }; // weak
_UNKNOWN unk_10073454; // weak
char byte_10073455[] = { '\x1A' }; // weak
_UNKNOWN unk_10073458; // weak
char byte_10073459[] = { '\x1C' }; // weak
_UNKNOWN unk_1007345C; // weak
char *off_10073460 = "/shr_mem/iop_grs_intf.shr"; // weak
_UNKNOWN unk_10077BB8; // weak
_WORD word_1007F530[744] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  65535,
  12,
  13,
  65535,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  64,
  65,
  66,
  67,
  68,
  65535,
  65535,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77,
  78,
  79,
  80,
  81,
  82,
  83,
  84,
  85,
  65535,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  123,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  65535,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  65535,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  65535,
  65535,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  208,
  209,
  210,
  211,
  212,
  213,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  240,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  253,
  254,
  255,
  256,
  257,
  258,
  259,
  260,
  65535,
  65535,
  261,
  262,
  263,
  264,
  265,
  266,
  267,
  268,
  269,
  270,
  271,
  272,
  273,
  274,
  275,
  276,
  65535,
  65535,
  277,
  278,
  279,
  280,
  281,
  282,
  283,
  284,
  285,
  286,
  65535,
  287,
  288,
  289,
  65535,
  65535,
  290,
  291,
  292,
  293,
  294,
  295,
  296,
  297,
  298,
  299,
  300,
  301,
  302,
  303,
  304,
  305,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  314,
  315,
  316,
  317,
  318,
  319,
  320,
  321,
  322,
  323,
  65535,
  65535,
  324,
  325,
  326,
  327,
  328,
  329,
  330,
  331,
  332,
  333,
  334,
  65535,
  65535,
  335,
  336,
  337,
  338,
  339,
  340,
  341,
  342,
  343,
  344,
  345,
  346,
  347,
  348,
  349,
  350,
  351,
  352,
  353,
  354,
  355,
  356,
  357,
  358,
  359,
  360,
  361,
  362,
  363,
  364,
  365,
  366,
  367,
  368,
  369,
  370,
  371,
  372,
  373,
  374,
  375,
  376,
  377,
  378,
  379,
  380,
  381,
  382,
  383,
  384,
  385,
  386,
  387,
  388,
  389,
  390,
  391,
  392,
  393,
  394,
  395,
  396,
  397,
  398,
  399,
  400,
  401,
  402,
  403,
  404,
  405,
  406,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  407,
  408,
  409,
  410,
  65535,
  411,
  412,
  413,
  414,
  415,
  416,
  65535,
  65535,
  417,
  418,
  419,
  420,
  421,
  422,
  423,
  424,
  425,
  426,
  427,
  428,
  429,
  430,
  431,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  432,
  433,
  434,
  435,
  436,
  437,
  438,
  439,
  440,
  441,
  442,
  443,
  444,
  445,
  446,
  447,
  448,
  449,
  450,
  451,
  452,
  453,
  454,
  455,
  456,
  457,
  458,
  459,
  460,
  461,
  462,
  463,
  464,
  465,
  466,
  467,
  468,
  469,
  65535,
  65535,
  470,
  471,
  472,
  473,
  474,
  475,
  476,
  477,
  478,
  479,
  65535,
  65535,
  480,
  481,
  482,
  483,
  484,
  65535,
  65535,
  485,
  486,
  487,
  488,
  489,
  490,
  491,
  492,
  493,
  494,
  495,
  496,
  497,
  498,
  499,
  500,
  501,
  502,
  503,
  504,
  505,
  506,
  507,
  508,
  509,
  510,
  511,
  512,
  513,
  514,
  515,
  516,
  517,
  518,
  519,
  520,
  521,
  522,
  523,
  524,
  525,
  526,
  527,
  528,
  529,
  65535,
  65535,
  530,
  531,
  532,
  533,
  534,
  535,
  536,
  537,
  538,
  539,
  540,
  541,
  542,
  543,
  544,
  545,
  546,
  547,
  548,
  549,
  550,
  551,
  552,
  553,
  554,
  555,
  556,
  557,
  558,
  559,
  560,
  561,
  562,
  563,
  564,
  565,
  566,
  567,
  568,
  569,
  570,
  571,
  572,
  573,
  574,
  575,
  576,
  577,
  578,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  579,
  580,
  581,
  582,
  583,
  584,
  585,
  586,
  587,
  588,
  589,
  590,
  591,
  592,
  593,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  594,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  65535,
  595,
  596,
  597,
  0,
  0,
  0
}; // idb
char *off_1007FB00[598] =
{
  "RGN_NOTIFICATION",
  "RGN_BUFFER",
  "RGN_ACK",
  "GET_HSDB",
  "CMD",
  "CFG_GIA_1_ACT",
  "CFG_GIA_1_CRC",
  "CFG_GIA_1_SET",
  "CFG_GIA_2_ACT",
  "CFG_GIA_2_CRC",
  "CFG_GIA_2_SET",
  "GIA_1_STATUS",
  "GIA_1_MODE",
  "GIA_2_STATUS",
  "GIA_2_MODE",
  "PIL_AHRS_SENSOR_SELECT",
  "COPIL_AHRS_SENSOR_SELECT",
  "PIL_ADC_SENSOR_SELECT",
  "COPIL_ADC_SENSOR_SELECT",
  "ACTV_PIL_BARO_SETTING",
  "ACTV_COPIL_BARO_SETTING",
  "ADC_1_PRESS_ALT_SSEC",
  "ADC_2_PRESS_ALT_SSEC",
  "ACTV_PIL_BARO_CRCTN",
  "ACTV_COPIL_BARO_CRCTN",
  "ADC_1_LBL_270",
  "ADC_2_LBL_270",
  "ADC_1_IAS_SSEC",
  "ADC_2_IAS_SSEC",
  "ADC_1_DNSTY_ALT",
  "ADC_2_DNSTY_ALT",
  "ADC_1_IAS",
  "ADC_2_IAS",
  "ADC_1_MACH_NMBR",
  "ADC_2_MACH_NMBR",
  "ADC_1_PRESS_ALT",
  "ADC_2_PRESS_ALT",
  "ADC_1_SAT",
  "ADC_2_SAT",
  "ADC_1_TAS",
  "ADC_2_TAS",
  "ADC_1_TTL_AT",
  "ADC_2_TTL_AT",
  "ADC_1_VSPD",
  "ADC_2_VSPD",
  "AHRS_1_ATT_HDG_RT",
  "AHRS_2_ATT_HDG_RT",
  "AHRS_1_ATT_PTCH_RT",
  "AHRS_2_ATT_PTCH_RT",
  "AHRS_1_ATT_RLL_RT",
  "AHRS_2_ATT_RLL_RT",
  "GRN_CRCL_RATIO_1",
  "GRN_CRCL_RATIO_2",
  "AHRS_1_DIS",
  "AHRS_2_DIS",
  "AHRS_1_M_HDG",
  "AHRS_2_M_HDG",
  "AHRS_1_PITCH",
  "AHRS_2_PITCH",
  "AHRS_1_ROLL",
  "AHRS_2_ROLL",
  "AHRS_1_VERT_ACCEL",
  "AHRS_2_VERT_ACCEL",
  "AHRS_1_X_ACCEL",
  "AHRS_2_X_ACCEL",
  "AHRS_1_Y_ACCEL",
  "AHRS_2_Y_ACCEL",
  "AHRS_1_Z_ACCEL",
  "AHRS_2_Z_ACCEL",
  "ADC_1_STATIC_PRESS",
  "ADC_2_STATIC_PRESS",
  "ADC_1_DIFF_PRESS",
  "ADC_2_DIFF_PRESS",
  "GRS_1_INST_TX",
  "GRS_1_INST_RX",
  "GRS_2_INST_TX",
  "GRS_2_INST_RX",
  "XFIL_REG_TAG_TBL_PFD_1",
  "XFIL_REG_TAG_TBL_MFD_1",
  "XFIL_REG_TAG_TBL_PFD_2",
  "XFIL_REG_DATA_RQST",
  "XFIL_REG_DATA_MFD_1",
  "XFIL_REG_DATA_PFD_1",
  "XFIL_REG_DATA_PFD_2",
  "AHRS_1_ALONG_HDG_ACCEL",
  "AHRS_2_ALONG_HDG_ACCEL",
  "ADC_1_TTL_PRESS",
  "ADC_2_TTL_PRESS",
  "ADC_1_IAS_LBL",
  "ADC_2_IAS_LBL",
  "ADC_1_LBL_274",
  "ADC_2_LBL_274",
  "ADC_1_LBL_275",
  "ADC_2_LBL_275",
  "PFD_1_VERT_FOV",
  "PFD_2_VERT_FOV",
  "MFD_1_REV_VERT_FOV",
  "ADC_1_LBL_272",
  "ADC_2_LBL_272",
  "CSP_1_SYS_IDENT",
  "CSP_2_SYS_IDENT",
  "ADC_1_CRC_DATA_LBL",
  "ADC_2_CRC_DATA_LBL",
  "ADC_1_LBL_271",
  "ADC_2_LBL_271",
  "ADC_1_LBL_276",
  "ADC_2_LBL_276",
  "ADC_1_LBL_277",
  "ADC_2_LBL_277",
  "ADC_1_LBL_350",
  "ADC_2_LBL_350",
  "ADC_1_LBL_351",
  "ADC_2_LBL_351",
  "ADC_1_LBL_352",
  "ADC_2_LBL_352",
  "ADC_1_LBL_353",
  "ADC_2_LBL_353",
  "ADC_1_STATIC_PRESS_LOCAL",
  "ADC_2_STATIC_PRESS_LOCAL",
  "ADC_1_STATIC_PRESS_OSP",
  "ADC_2_STATIC_PRESS_OSP",
  "ADC_1_TOTAL_PRESS_TRUE",
  "ADC_2_TOTAL_PRESS_TRUE",
  "ADC_1_STATIC_PRESS_Z_BETA",
  "ADC_2_STATIC_PRESS_Z_BETA",
  "ADC_1_TOTAL_PRESS_LOCAL",
  "ADC_2_TOTAL_PRESS_LOCAL",
  "ADC_1_CRC_DATA",
  "ADC_2_CRC_DATA",
  "PFD_1_TICK",
  "PFD_2_TICK",
  "MFD_1_TICK",
  "AOA_1",
  "AOA_2",
  "LSA_WARN_RATIO_1",
  "LSA_WARN_RATIO_2",
  "YLW_BND_RATIO_1",
  "YLW_BND_RATIO_2",
  "YLW_BND_OFFSET_1",
  "YLW_BND_OFFSET_2",
  "SWPS_1_LBL_270",
  "SWPS_2_LBL_270",
  "FC_1_BUS_VALID",
  "FC_2_BUS_VALID",
  "FC_FLAPS_LEVER_POS",
  "FC_1_FLP_ACTUATOR_POS_AVG",
  "FC_1_PTCH_TRM_DISCS",
  "FC_2_PTCH_TRM_DISCS",
  "FC_FLAP_DISCRETES",
  "FC_1_PTCH_TRM_ACTUATOR_POS",
  "FC_2_PTCH_TRM_ACTUATOR_POS",
  "FC_1_FCE_FAULT_MESSAGES",
  "FC_2_FCE_FAULT_MESSAGES",
  "FC_1_PTCH_TRM_FLT_MSGS",
  "FC_2_PTCH_TRM_FLT_MSGS",
  "FC_FLAP_FAULT_MESSAGES",
  "FC_SPOILER_SURF_POS_LEFT",
  "FC_SPOILER_SURF_POS_RIGHT",
  "FC_SPOILER_FAULT_MSG_1",
  "FC_1_FRESHNESS_COUNTER",
  "FC_2_FRESHNESS_COUNTER",
  "FC_SPOILER_FAULT_MSG_2",
  "FC_CTRL_WHEEL_POS",
  "FC_1_FLAP_POS_L",
  "FC_1_FLAP_POS_R",
  "FC_2_FLAP_POS_L",
  "FC_2_FLAP_POS_R",
  "FC_2_FLP_ACTUATOR_POS_AVG",
  "FC_SPOILER_ACT_POS_LEFT",
  "FC_SPOILER_ACT_POS_RIGHT",
  "FC_CTRL_WHEEL_POS_2",
  "FC_1_FCE_FLT_MSG_2",
  "FC_1_PTCH_TRM_FLT_MSG_2",
  "FC_FLP_FLT_MSG_2",
  "FC_1_FLP_FLT_MSG_3",
  "FC_2_PTCH_TRM_DSC_2",
  "FC_SPLR_EHSV_CMD_LFT",
  "FC_SPLR_EHSV_CMD_RGT",
  "FC_2_FCE_FLT_MSG_2",
  "FC_2_PTCH_TRM_FLT_MSG_2",
  "FC_2_FLP_FLT_MSG_3",
  "TAKEOFF_CONFIG_SWITCH",
  "SVO_1_CMC_FAULT",
  "SVO_2_CMC_FAULT",
  "SVO_1_STATUS",
  "SVO_2_STATUS",
  "PTCH_SVO_VOLT",
  "ROLL_SVO_VOLT",
  "YAW_SVO_VOLT",
  "PTCH_TRM_SVO_VOLT",
  "ROLL_TRM_SVO_VOLT",
  "YAW_TRM_SVO_VOLT",
  "AFCS_EP_GIA_1",
  "AFCS_EP_GIA_2",
  "AFCS_AHRS_MON_GIA_1",
  "AFCS_AHRS_MON_GIA_2",
  "SVO_DIAG_1_CHCK_CMND",
  "SVO_DIAG_2_CHCK_CMND",
  "SVO_DIAG_1_CHCK_RSLT",
  "SVO_DIAG_2_CHCK_RSLT",
  "SVO_DIAG_1_CHCK_PROMPT",
  "SVO_DIAG_2_CHCK_PROMPT",
  "SVO_DIAG_1_INST_TX",
  "SVO_DIAG_2_INST_TX",
  "SVO_DIAG_1_TARGET_AXIS",
  "SVO_DIAG_2_TARGET_AXIS",
  "SVO_DIAG_1_MON_STATUS",
  "SVO_DIAG_1_CTL_STATUS",
  "SVO_DIAG_2_MON_STATUS",
  "SVO_DIAG_2_CTL_STATUS",
  "EMB_TRIM_1_ALERTS",
  "EMB_TRIM_2_ALERTS",
  "TRIM_1_STATUS",
  "TRIM_2_STATUS",
  "RMT_INST_TX",
  "RMT_INST_RX",
  "CFG_GCU_1_ACT",
  "CFG_GCU_1_CRC",
  "CFG_GCU_1_DSPL_DATA",
  "CFG_GCU_1_STATUS",
  "CFG_GMC_ACT",
  "CFG_GMC_CRC",
  "CFG_GMC_DSPL_DATA",
  "CFG_GMC_STATUS",
  "GIA_1_DIS_IN",
  "GIA_2_DIS_IN",
  "ADC_1_LBL_355",
  "ADC_2_LBL_355",
  "LRU_PKT_ENBL",
  "AFCS_GENERIC_FLAP_POS_IN_0",
  "AFCS_GENERIC_FLAP_POS_IN_1",
  "AFCS_GENERIC_FLAP_POS_IN_2",
  "AFCS_GENERIC_FLAP_POS_IN_3",
  "AFCS_GENERIC_FLAP_POS_IN_4",
  "AFCS_GENERIC_FLAP_POS_IN_5",
  "AFCS_GENERIC_FLAP_POS_IN_6",
  "AFCS_GENERIC_FLAP_POS_IN_7",
  "AFCS_GENERIC_FLAP_POS_IN_8",
  "AFCS_GENERIC_FLAP_POS_IN_9",
  "AFCS_GENERIC_FLAP_POS_OUT_0",
  "AFCS_GENERIC_FLAP_POS_OUT_1",
  "AFCS_GENERIC_FLAP_POS_OUT_2",
  "AFCS_GENERIC_FLAP_POS_OUT_3",
  "AFCS_GENERIC_FLAP_POS_OUT_4",
  "AFCS_GENERIC_FLAP_POS_OUT_5",
  "AFCS_GENERIC_FLAP_POS_OUT_6",
  "AFCS_GENERIC_FLAP_POS_OUT_7",
  "AFCS_GENERIC_FLAP_POS_OUT_8",
  "AFCS_GENERIC_FLAP_POS_OUT_9",
  "AHRS_1_HPM_STATUS",
  "AHRS_2_HPM_STATUS",
  "AHRS_1_HPM_CMD",
  "RQST_ALRT_MSTR_TRNSFR",
  "RPLY_ALRT_MSTR_TRNSFR",
  "ALRT_MSTR_BRDCST",
  "AFCS_AHRS_GIA_1",
  "AFCS_AHRS_GIA_2",
  "XFIL_REG_TAG_TBL_GTC_1",
  "XFIL_REG_TAG_TBL_GTC_2",
  "XFIL_REG_DATA_GTC_1",
  "XFIL_REG_DATA_GTC_2",
  "FC_2_FLAP_DSCRT_LBL_A",
  "FC_2_FLAP_CALC_POS_AVG",
  "FC_2_FLAP_CALC_POS_L",
  "FC_2_FLAP_CALC_POS_R",
  "FC_2_FLAP_CALC_POS_ASYM",
  "FC_2_FLAP_UP_TIME",
  "FC_2_FLAP_DSCRT_LBL_B",
  "FC_2_FLAP_ACT_POS_ASYM",
  "FC_1_FLAP_DSCRT_LBL_A",
  "FC_1_FLAP_CALC_POS_AVG",
  "FC_1_FLAP_CALC_POS_L",
  "FC_1_FLAP_CALC_POS_R",
  "FC_1_FLAP_CALC_POS_ASYM",
  "FC_1_FLAP_ACT_POS_ASYM",
  "FC_1_FLAP_UP_TIME",
  "FC_1_FLAP_DSCRT_LBL_B",
  "SWPS_WARN_FAIL_1",
  "SWPS_WARN_FAIL_2",
  "SWPS_PROT_FAIL_1",
  "SWPS_PROT_FAIL_2",
  "AOA_MISC_L_HIGH_1",
  "AOA_MISC_R_HIGH_1",
  "AOA_MISC_L_HIGH_2",
  "AOA_MISC_R_HIGH_2",
  "STALL_WARN_INHIBIT_1",
  "STALL_WARN_INHIBIT_2",
  "SWPS_TEST",
  "RUDDER_BIAS_INHIBIT_1",
  "RUDDER_BIAS_INHIBIT_2",
  "ADC_1_IMPACT_PRESS",
  "ADC_2_IMPACT_PRESS",
  "CFG_GCU_2_ACT",
  "CFG_GCU_2_CRC",
  "CFG_GCU_2_DSPL_DATA",
  "CFG_GCU_2_STATUS",
  "SVO_1_SYNC_DATA",
  "SVO_2_SYNC_DATA",
  "AFCS_DSCRT_IN_RUDDER_BIAS_INHIBIT_1",
  "AFCS_DSCRT_IN_RUDDER_BIAS_INHIBIT_2",
  "AFCS_DSCRT_IN_RUDDER_SELF_TEST_1",
  "AFCS_DSCRT_IN_RUDDER_SELF_TEST_2",
  "AFCS_RUDDER_BOOST_INHIBIT_1",
  "AFCS_RUDDER_BOOST_INHIBIT_2",
  "AFCS_PIL_RUDDER_PEDAL_1",
  "AFCS_PIL_RUDDER_PEDAL_2",
  "AFCS_COPIL_RUDDER_PEDAL_1",
  "AFCS_COPIL_RUDDER_PEDAL_2",
  "AFCS_PIL_RUDDER_PEDAL_A_VLD_1",
  "AFCS_PIL_RUDDER_PEDAL_A_VLD_2",
  "AFCS_COPIL_RUDDER_PEDAL_A_VLD_1",
  "AFCS_COPIL_RUDDER_PEDAL_A_VLD_2",
  "AFCS_PIL_RUDDER_PEDAL_B_VLD_1",
  "AFCS_PIL_RUDDER_PEDAL_B_VLD_2",
  "AFCS_COPIL_RUDDER_PEDAL_B_VLD_1",
  "AFCS_COPIL_RUDDER_PEDAL_B_VLD_2",
  "AFCS_RUDDER_BOOST_STATUS_1",
  "AFCS_RUDDER_BOOST_STATUS_2",
  "AFCS_RUDDER_BOOST_DBG_1",
  "AFCS_RUDDER_BOOST_DBG_2",
  "ROLL_TRIM_INHIBIT_GIA_1",
  "ROLL_TRIM_INHIBIT_GIA_2",
  "YAW_TRIM_INHIBIT_GIA_1",
  "YAW_TRIM_INHIBIT_GIA_2",
  "TRIM_1_ALERTS",
  "TRIM_2_ALERTS",
  "GTC_1_TICK",
  "GTC_2_TICK",
  "NORMALIZED_AOA_1",
  "NORMALIZED_AOA_2",
  "STALL_PROT_INHIBIT_1",
  "STALL_PROT_INHIBIT_2",
  "FC_SPOILER_LEVER_POS",
  "ADC_1_PROBE_TEMP",
  "ADC_2_PROBE_TEMP",
  "HSTAB_PRI_1_VLD_1",
  "HSTAB_PRI_1_VLD_2",
  "HSTAB_PRI_2_VLD_1",
  "HSTAB_PRI_2_VLD_2",
  "HSTAB_PRI_OR_SEC_TRIM_SELECT_1",
  "HSTAB_PRI_OR_SEC_TRIM_SELECT_2",
  "HSTAB_SEC_1_VLD_1",
  "HSTAB_SEC_1_VLD_2",
  "HSTAB_SEC_2_VLD_1",
  "HSTAB_SEC_2_VLD_2",
  "HSTAB_SECONDARY_TRIM_SELECT_1",
  "HSTAB_SECONDARY_TRIM_SELECT_2",
  "AFCS_1_ALERTS",
  "AFCS_2_ALERTS",
  "AFCS_1_ANNUNC",
  "AFCS_2_ANNUNC",
  "FIU_AP_DISENGAGE_1",
  "FIU_AP_DISENGAGE_2",
  "LH_GEAR_ON_GROUND",
  "RH_GEAR_ON_GROUND",
  "LH_GEAR_ON_GROUND_2",
  "RH_GEAR_ON_GROUND_2",
  "SEC_PTCH_TRIM_SW_ARM_1",
  "SEC_PTCH_TRIM_SW_ARM_2",
  "SEC_PTCH_TRIM_SW_NDN_1",
  "SEC_PTCH_TRIM_SW_NDN_2",
  "SEC_PTCH_TRIM_SW_NUP_1",
  "SEC_PTCH_TRIM_SW_NUP_2",
  "COPIL_PTCH_ARM_GIA_1",
  "COPIL_PTCH_ARM_GIA_2",
  "COPIL_PTCH_DOWN_GIA_1",
  "COPIL_PTCH_DOWN_GIA_2",
  "COPIL_PTCH_UP_GIA_1",
  "COPIL_PTCH_UP_GIA_2",
  "COPIL_ROLL_ARM_GIA_1",
  "COPIL_ROLL_ARM_GIA_2",
  "COPIL_ROLL_LEFT_GIA_1",
  "COPIL_ROLL_LEFT_GIA_2",
  "COPIL_ROLL_RIGHT_GIA_1",
  "COPIL_ROLL_RIGHT_GIA_2",
  "PIL_PTCH_ARM_GIA_1",
  "PIL_PTCH_ARM_GIA_2",
  "PIL_PTCH_DOWN_GIA_1",
  "PIL_PTCH_DOWN_GIA_2",
  "PIL_PTCH_UP_GIA_1",
  "PIL_PTCH_UP_GIA_2",
  "PIL_ROLL_ARM_GIA_1",
  "PIL_ROLL_ARM_GIA_2",
  "PIL_ROLL_LEFT_GIA_1",
  "PIL_ROLL_LEFT_GIA_2",
  "PIL_ROLL_RIGHT_GIA_1",
  "PIL_ROLL_RIGHT_GIA_2",
  "YAW_ARM_GIA_1",
  "YAW_ARM_GIA_2",
  "YAW_LEFT_GIA_1",
  "YAW_LEFT_GIA_2",
  "YAW_RIGHT_GIA_1",
  "YAW_RIGHT_GIA_2",
  "PTCH_TRIM_ENABLE_GIA_1",
  "PTCH_TRIM_ENABLE_GIA_2",
  "ROLL_TRIM_ENABLE_GIA_1",
  "ROLL_TRIM_ENABLE_GIA_2",
  "YAW_TRIM_ENABLE_GIA_1",
  "YAW_TRIM_ENABLE_GIA_2",
  "FC_SPOILER_POS_LEFT",
  "FC_SPOILER_POS_RIGHT",
  "TRIM_1_POSN",
  "TRIM_2_POSN",
  "AHRS_1_T_HDG",
  "AHRS_2_T_HDG",
  "AHRS_1_MAG_VAR",
  "AHRS_2_MAG_VAR",
  "LSA_PROT_RATIO_1",
  "LSA_PROT_RATIO_2",
  "LSA_YLW_BND_AIRSPEED_1",
  "LSA_YLW_BND_AIRSPEED_2",
  "AOA_1_LBL_270",
  "AOA_1_LBL_271",
  "AOA_2_LBL_270",
  "AOA_2_LBL_271",
  "ENG_1_TLA",
  "ENG_2_TLA",
  "LCR100_1_ALGN_COUNTDOWN",
  "LCR100_2_ALGN_COUNTDOWN",
  "GEA7100_1_DIS_IN",
  "GEA7100_2_DIS_IN",
  "GEA7100_3_DIS_IN",
  "GEA7100_4_DIS_IN",
  "GEA7100_1_ANLG_IN",
  "GEA7100_2_ANLG_IN",
  "GEA7100_3_ANLG_IN",
  "GEA7100_4_ANLG_IN",
  "STALL_WARN_SPEED_RATIO_1",
  "STALL_WARN_SPEED_RATIO_2",
  "DSCRT_OUT_RUDDER_STANDBY_PUMP_ON",
  "EMB_TRIM_1_STATUS",
  "EMB_TRIM_2_STATUS",
  "FLAP_POS_L_VALID",
  "FLAP_POS_R_VALID",
  "AHRS_1_BDY_PTCH_RT",
  "AHRS_2_BDY_PTCH_RT",
  "AHRS_1_BDY_ROLL_RT",
  "AHRS_2_BDY_ROLL_RT",
  "AHRS_1_BDY_YAW_RT",
  "AHRS_2_BDY_YAW_RT",
  "ENG_1_FADEC_LBL_273_CH_A",
  "ENG_1_FADEC_LBL_273_CH_B",
  "ENG_2_FADEC_LBL_273_CH_A",
  "ENG_2_FADEC_LBL_273_CH_B",
  "ENG_1_FADEC_LBL_146_CH_A",
  "ENG_1_FADEC_LBL_146_CH_B",
  "ENG_2_FADEC_LBL_146_CH_A",
  "ENG_2_FADEC_LBL_146_CH_B",
  "SWPS_VSR_AOA_1",
  "SWPS_VSR_AOA_2",
  "SWPS_VSW_AOA_1",
  "SWPS_VSW_AOA_2",
  "SWPS_FLTRD_AOA_1",
  "SWPS_FLTRD_AOA_2",
  "AOA_1_RAW",
  "AOA_2_RAW",
  "AUD_MSG_VOICE",
  "DSCRT_OUT_STALL_WARN_1",
  "DSCRT_OUT_STALL_WARN_2",
  "PFD_1_GPU_STS",
  "PFD_2_GPU_STS",
  "MFD_1_GPU_STS",
  "ENG_1_RIGGED_TLA",
  "ENG_2_RIGGED_TLA",
  "XFIL_REG_TAG_TBL_GTC_3",
  "XFIL_REG_TAG_TBL_GTC_4",
  "XFIL_REG_DATA_GTC_3",
  "XFIL_REG_DATA_GTC_4",
  "GTC_3_TICK",
  "GTC_4_TICK",
  "AHRS_1_DIS_LBL_272",
  "AHRS_2_DIS_LBL_272",
  "AHRS_1_DIS_MAINT",
  "AHRS_2_DIS_MAINT",
  "PITCH_SVO_INHIBIT_GIA_1",
  "PITCH_SVO_INHIBIT_GIA_2",
  "ROLL_SVO_INHIBIT_GIA_1",
  "ROLL_SVO_INHIBIT_GIA_2",
  "YAW_SVO_INHIBIT_GIA_1",
  "YAW_SVO_INHIBIT_GIA_2",
  "AHRS_2_HPM_CMD",
  "DIS_IN_STICK_SHAKER_ACTV_1",
  "DIS_IN_STICK_SHAKER_ACTV_2",
  "FC_1_STP_APRCH_MD",
  "FC_2_STP_APRCH_MD",
  "NAOA_AT_STICK_SHAKER_1",
  "NAOA_AT_STICK_SHAKER_2",
  "AFCS_AUTOTHROTTLE_ENABLE",
  "AFCS_SVO_DISABLE_DISC_1",
  "AFCS_SVO_DISABLE_DISC_2",
  "AFCS_SVO_DISABLE_DISC_3",
  "AFCS_SVO_DISABLE_DISC_4",
  "AFCS_SVO_DISABLE_DISC_5",
  "AFCS_SVO_DISABLE_DISC_6",
  "ENG_1_TT2",
  "ENG_2_TT2",
  "ENG_1_TT2_CH_A",
  "ENG_1_TT2_CH_B",
  "ENG_2_TT2_CH_A",
  "ENG_2_TT2_CH_B",
  "FADEC_CROSS_300_DATA_1_A",
  "FADEC_CROSS_300_DATA_2_A",
  "FADEC_CROSS_300_DATA_1_B",
  "FADEC_CROSS_300_DATA_2_B",
  "FADEC_CROSS_301_DATA_1_A",
  "FADEC_CROSS_301_DATA_1_B",
  "FADEC_CROSS_301_DATA_2_A",
  "FADEC_CROSS_301_DATA_2_B",
  "FADEC_CROSS_302_DATA_1_A",
  "FADEC_CROSS_302_DATA_1_B",
  "FADEC_CROSS_302_DATA_2_A",
  "FADEC_CROSS_302_DATA_2_B",
  "FADEC_CROSS_327_DATA_1_A",
  "FADEC_CROSS_327_DATA_1_B",
  "FADEC_CROSS_327_DATA_2_A",
  "FADEC_CROSS_327_DATA_2_B",
  "ENG_1_FADEC_CTRL_CHNL",
  "ENG_2_FADEC_CTRL_CHNL",
  "ENG_1_FADEC_LBL_270",
  "ENG_1_FADEC_LBL_270_CH_A",
  "ENG_1_FADEC_LBL_270_CH_B",
  "ENG_2_FADEC_LBL_270",
  "ENG_2_FADEC_LBL_270_CH_A",
  "ENG_2_FADEC_LBL_270_CH_B",
  "GEA7100_2_ANLG_FLOW_1",
  "GEA7100_3_ANLG_FLOW_1",
  "AFCS_AHRS_STBY_GIA_1",
  "AFCS_AHRS_STBY_GIA_2",
  "FC_1_SPOILER_DISCS",
  "FC_2_SPOILER_DISCS",
  "GIA_1_A429_PORT_1",
  "GIA_1_A429_PORT_2",
  "GIA_1_A429_PORT_3",
  "GIA_1_A429_PORT_4",
  "GIA_1_A429_PORT_5",
  "GIA_1_A429_PORT_6",
  "GIA_1_A429_PORT_7",
  "GIA_1_A429_PORT_8",
  "GIA_2_A429_PORT_1",
  "GIA_2_A429_PORT_2",
  "GIA_2_A429_PORT_3",
  "GIA_2_A429_PORT_4",
  "GIA_2_A429_PORT_5",
  "GIA_2_A429_PORT_6",
  "GIA_2_A429_PORT_7",
  "GIA_2_A429_PORT_8",
  "FADEC_AF_DIS_1",
  "FADEC_AF_SP_BIN",
  "ENG_1_FADEC_INLET_TOTAL_TEMP",
  "ENG_2_FADEC_INLET_TOTAL_TEMP",
  "AFCS_AUTOTHROTTLE_HOLD",
  "PIL_FD_SELECT",
  "COPIL_FD_SELECT",
  "GEA7100_1_STATUS",
  "GEA7100_2_STATUS",
  "GEA7100_3_STATUS",
  "GEA7100_4_STATUS",
  "MFD_CRNT_SNSR_SIDE",
  "RGN_ACK_VAR",
  "BODY_AOA_1",
  "BODY_AOA_2",
  "AFCS_AHRS_1_GIA_1",
  "AFCS_AHRS_1_GIA_2",
  "AFCS_AHRS_2_GIA_1",
  "AFCS_AHRS_2_GIA_2",
  "ENG_1_A_TLA",
  "ENG_1_B_TLA",
  "ENG_2_A_TLA",
  "ENG_2_B_TLA",
  "ENG_1_A_ITT_TRIM",
  "ENG_1_B_ITT_TRIM",
  "ENG_2_A_ITT_TRIM",
  "ENG_2_B_ITT_TRIM",
  "ENG_1_A_T45_TRIM",
  "ENG_1_B_T45_TRIM",
  "ENG_2_A_T45_TRIM",
  "ENG_2_B_T45_TRIM",
  "CMD_DATA",
  "CMD_ACK",
  "SWPS_STATUS_1",
  "SWPS_STATUS_2",
  "AHRS_1_LBL_324",
  "AHRS_2_LBL_324",
  "AHRS_1_LBL_325",
  "AHRS_2_LBL_325",
  "GEA7100_RIG_RQST_TBL",
  "GEA7100_RIG_RQST_RIG",
  "GEA7100_RIG_DFLT_RQST",
  "GEA7100_RIG_RQST_DATA",
  "GEA7100_RIG_EXECUTE",
  "GEA7100_RIG_TBL_ACK",
  "GEA7100_RIG_RQST_RIG_ACK",
  "GEA7100_RIG_EXECUTE_ACK",
  "GEA7100_RIG_RQST_DATA_ACK",
  "ALRT_MSTR_TAKEN",
  "COMP_AOA_1",
  "COMP_AOA_2",
  "DSCRT_OUT_PTCH_FCT_INHIBIT"
}; // weak
_UNKNOWN unk_10080458; // weak
_UNKNOWN unk_10080B5C; // weak
char *off_10080B60 = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_10080B74 = "/shr_mem/iop_a_pkt_names_intf.shr"; // weak
int dword_1008152C[] = { 88 }; // weak
__int16 word_100819DC[] = { 836 }; // weak
char *off_100819FC = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_10081A10 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_10081A24 = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_10081A38 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_10081A4C = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_10081A60 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
__int16 word_10083338[] = { 398 }; // weak
char *off_10083564 = "/shr_mem/iop_rgn_data_intf.shr"; // weak
_UNKNOWN unk_10083FE8; // weak
_UNKNOWN unk_10083FF0; // weak
_UNKNOWN unk_10084EB8; // weak
_UNKNOWN unk_10084EBC; // weak
_UNKNOWN unk_100853F0; // weak
int dword_100862C8[] = { 256 }; // weak
int dword_100862CC[] = { 0 }; // weak
int (__cdecl *off_100862D0)(int, char, int, __int16) = &sub_1000C830; // weak
int (__cdecl *off_100862D4)(int, int, int, __int16) = &sub_1000C790; // weak
char *off_10086358 = "/shr_mem/iop_a_upld_mngr_intf.shr"; // weak
char *off_1008636C = "/shr_mem/iop_upld_mngr_intf.shr"; // weak
int dword_10086380[] = { 29 }; // weak
char *off_10086580 = "/shr_mem/iop_b_upld_mngr_intf.shr"; // weak
char *off_10086594 = "/shr_mem/iop_c_upld_mngr_intf.shr"; // weak
char *off_100865A8 = "/shr_mem/iop_d_upld_mngr_intf.shr"; // weak
_UNKNOWN unk_10086B08; // weak
__int16 word_10086B0C[] = { 86 }; // weak
_UNKNOWN unk_100870C0; // weak
int dword_100870C4[] = { 1 }; // weak
int dword_10087F58 = 6; // weak
int dword_10087F5C = 6000; // weak
int dword_10087F60 = 6961; // weak
_UNKNOWN unk_1008EC58; // weak
int dword_1008EC5C[] = { 0 }; // weak
__int16 word_1008EC60[] = { 0 }; // weak
char *off_100922E8[3] = { "iop_aud_msg_cnfg.c", "$Id$", &off_100921A8 }; // weak
char *off_10092458[3] = { "iop_xpdr_intf.c", "$Id$", &off_10092390 }; // weak
_UNKNOWN unk_100926F8; // weak
_UNKNOWN unk_10093D68; // weak
_UNKNOWN unk_10093D6C; // weak
int (*off_10093E50[3])() = { &sub_1003CD00, &sub_10023FD0, &sub_10004AD0 }; // weak
_UNKNOWN unk_10094388; // weak
_UNKNOWN unk_10094950; // weak
_UNKNOWN unk_10094958; // weak
char byte_10094960[] = { '\x01' }; // weak
_UNKNOWN unk_10094A50; // weak
_UNKNOWN unk_10094A68; // weak
_UNKNOWN unk_10094AB0; // weak
int dword_10094AB4[] = { 6767 }; // weak
_UNKNOWN unk_10094AC0; // weak
_UNKNOWN unk_10094AD8; // weak
_UNKNOWN unk_10094AF0; // weak
int dword_10094AF4[] = { 6769 }; // weak
_UNKNOWN unk_10094B08; // weak
int dword_10094B0C[] = { 6093 }; // weak
_UNKNOWN unk_10095040; // weak
_UNKNOWN unk_10095058; // weak
_UNKNOWN unk_1009509C; // weak
__int16 word_1009509E[] = { 136 }; // weak
int dword_10095840[] = { 1 }; // weak
_UNKNOWN off_10095844; // idb
_UNKNOWN unk_10095920; // weak
__int16 word_10095924[] = { 2 }; // weak
_UNKNOWN unk_10095944; // weak
_UNKNOWN unk_100967E8; // weak
__int16 word_100967EA[] = { 492 }; // weak
char byte_100967F8[] = { '@' }; // weak
char byte_100967F9[] = { '\x04' }; // weak
_UNKNOWN unk_10097EE8; // weak
__int16 word_10097EEA[] = { 9419 }; // weak
char *off_10097F7C = "/shr_mem/pvt_intf.shr"; // weak
__int16 word_10099858[] = { 0 }; // weak
__int16 word_1009985A[] = { 999 }; // weak
__int16 word_1009985C[] = { 1000 }; // weak
__int16 word_1009985E[] = { 1500 }; // weak
float flt_10099860[] = {  3000.0 }; // weak
_UNKNOWN unk_1009B034; // weak
_UNKNOWN unk_1009B07A; // weak
_UNKNOWN unk_1009B0C0; // weak
char byte_1009B0C1[] = { '\0' }; // weak
_UNKNOWN unk_1009B0CC; // weak
__int16 word_1009B0CE[] = { 17 }; // weak
_UNKNOWN unk_1009B0D8; // weak
__int16 word_1009B0DA[] = { 17 }; // weak
_UNKNOWN unk_1009B0E8; // weak
__int16 word_1009B0EA[] = { 17 }; // weak
_UNKNOWN unk_1009B108; // weak
__int16 word_1009B10A[] = { 10 }; // weak
_UNKNOWN unk_1009B128; // weak
__int16 word_1009B12A[] = { 10 }; // weak
_UNKNOWN unk_1009B148; // weak
int dword_1009B14C[] = { 1 }; // weak
int dword_1009B150[] = { 4 }; // weak
__int16 word_1009B1B4[] = { 236 }; // weak
_UNKNOWN unk_1009B1C0; // weak
_UNKNOWN unk_1009B1C4; // weak
_UNKNOWN unk_1009B1E0; // weak
char byte_1009B1E1[] = { '\0' }; // weak
_UNKNOWN unk_1009B204; // weak
char byte_1009B205[] = { '\x01' }; // weak
_UNKNOWN unk_1009B228; // weak
int dword_1009B22C[] = { 4 }; // weak
__int16 word_1009B230[] = { 2 }; // weak
_UNKNOWN unk_1009B270; // weak
char byte_1009B272[] = { '\0' }; // weak
__int16 word_1009B7A8[] = { 110 }; // weak
__int16 word_1009B7B2[] = { 233 }; // weak
__int16 word_1009B7B4[] = { 234 }; // weak
int dword_1009B7B8[] = { 6201 }; // weak
_UNKNOWN unk_1009C648; // weak
__int16 word_1009C64A[] = { 82 }; // weak
_UNKNOWN unk_1009CBA4; // weak
_UNKNOWN unk_1009CBAC; // weak
char byte_1009CBB4[] = { '\x02' }; // weak
char byte_1009CBB5[] = { '\0' }; // weak
_UNKNOWN unk_1009CBD4; // weak
_UNKNOWN unk_1009DB30; // weak
__int16 word_1009DB32[] = { 1 }; // weak
_UNKNOWN unk_1009DB70; // weak
__int16 word_1009DB72[] = { 16384 }; // weak
_UNKNOWN unk_1009FD10; // weak
_UNKNOWN unk_1009FD78; // weak
_UNKNOWN unk_1009FDDC; // weak
int (__cdecl *off_100A0390[3])(char) = { &sub_10019530, &sub_10019440, &sub_10019390 }; // weak
__int16 word_100A03C0[] = { 43 }; // weak
char byte_100A03C4[] = { '\x06' }; // weak
_UNKNOWN unk_100A0848; // weak
int dword_100A084C[] = { 1312 }; // weak
char *off_100A0EA8[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_100A0D18 }; // weak
_UNKNOWN unk_100A0EBC; // weak
_UNKNOWN unk_100A0EC0; // weak
char *off_100A1E54[18] =
{
  "FAIL",
  "PASS",
  "normal",
  "robust",
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_100A1E5C[16] =
{
  "normal",
  "robust",
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_100A1E64[14] =
{
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_100A1E80[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_100A1E8C[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_100A1E94[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_100A2178; // weak
_UNKNOWN unk_100A21C4; // weak
int dword_100A2344[] = { 6195 }; // weak
__int16 word_100A2358[] = { 114 }; // weak
_UNKNOWN unk_100A2DD8; // weak
char byte_100A2DDC[] = { '\0' }; // weak
_UNKNOWN unk_100A2E10; // weak
char byte_100A2E14[] = { '\0' }; // weak
char *off_100A3038[8] =
{
  "/mnt/card0/feat_unlk.dat",
  "/mnt/card0/feat_unlk2.dat",
  "/mnt/card1/feat_unlk.dat",
  "/mnt/card1/feat_unlk2.dat",
  "/dev/sd_card0",
  "/dev/sd_card0",
  "/dev/sd_card1",
  "/dev/sd_card1"
}; // weak
char *off_100A3048[4] = { "/dev/sd_card0", "/dev/sd_card0", "/dev/sd_card1", "/dev/sd_card1" }; // weak
int dword_100A3090[] = { 0 }; // weak
__int16 word_100A3094[] = { 0 }; // weak
char word_100A3160[] = { '=', '\0' }; // idb
_UNKNOWN unk_100A3A74; // weak
_UNKNOWN unk_100A3A78; // weak
_UNKNOWN unk_100A3DD0; // weak
char byte_100A3DD1[] = { '\0' }; // weak
_UNKNOWN unk_100A3DD2; // weak
_UNKNOWN unk_100A4678; // weak
int dword_100A4680[] = { 26 }; // weak
_UNKNOWN unk_100A5048; // weak
_UNKNOWN unk_100A504C; // weak
_UNKNOWN unk_100A5050; // weak
_UNKNOWN unk_100A5054; // weak
_UNKNOWN unk_100A5058; // weak
_UNKNOWN unk_100A505C; // weak
_UNKNOWN unk_100A5710; // weak
void *off_100A5714 = &unk_100A5048; // weak
_UNKNOWN unk_100A57C0; // weak
char byte_100A57C1[] = { '\x06' }; // weak
char byte_100A57C2[] = { '\x04' }; // weak
char byte_100A57C3[] = { '\x03' }; // weak
void *off_100A57C4 = &unk_100A5048; // weak
void *off_100A57D0 = &unk_100A504C; // weak
void *off_100A57DC = &unk_100A5050; // weak
void *off_100A57E8 = &unk_100A5054; // weak
void *off_100A57F4 = &unk_100A5058; // weak
void *off_100A5C80 = &unk_100A50B8; // weak
void *off_100A5C8C = &unk_100A5084; // weak
void *off_100A5C98 = &unk_100A5104; // weak
void *off_100A5CA4 = &unk_100A5138; // weak
void *off_100A5CB0 = &unk_100A5208; // weak
void *off_100A5CBC = &unk_100A51F4; // weak
void *off_100A5CC8 = &unk_100A52E4; // weak
void *off_100A5CD4 = &unk_100A5308; // weak
void *off_100A5CE0 = &unk_100A532C; // weak
void *off_100A5CEC = &unk_100A5350; // weak
void *off_100A5CF8 = &unk_100A5058; // weak
void *off_100A5D10 = &unk_100A5048; // weak
void *off_100A5D1C = &unk_100A504C; // weak
void *off_100A5D28 = &unk_100A565C; // weak
void *off_100A5D34 = &unk_100A5054; // weak
void *off_100A5D40 = &unk_100A5058; // weak
void *off_100A5D4C = &unk_100A505C; // weak
void *off_100A5D58 = &unk_100A5048; // weak
void *off_100A5D64 = &unk_100A5668; // weak
void *off_100A5D70 = &unk_100A5050; // weak
void *off_100A5D7C = &unk_100A5054; // weak
void *off_100A5D88 = &unk_100A5058; // weak
void *off_100A5D94 = &unk_100A505C; // weak
_UNKNOWN unk_100A5DA0; // weak
void *off_100A5DA4 = &unk_100A504C; // weak
void *off_100A5DB0 = &unk_100A52D4; // weak
char byte_100A5EF8[] = { '7' }; // weak
int dword_100A5EFC[] = { 6829 }; // weak
int dword_100A6D70 = 64; // weak
__int16 word_100A6D74[] = { 6782 }; // weak
__int16 word_100A6D78[] = { 128 }; // weak
_UNKNOWN unk_100A6D94; // weak
_DWORD dword_100A6D98[4] = { 64, 24, 62, 18 }; // idb
_UNKNOWN unk_100A6DAC; // weak
__int16 word_100A6DAE[] = { 420 }; // weak
int dword_100A6DBC[] = { 0 }; // weak
_UNKNOWN unk_100A6DC8; // weak
__int16 word_100A6DCA[] = { 0 }; // weak
__int16 word_100A81A8[] = { 1565 }; // weak
__int16 word_100A81AC[] = { 534 }; // weak
char byte_100A81B0[] = { '\x04' }; // weak
__int16 word_100A81B2[] = { 6512 }; // weak
int dword_100A81C8[] = { 118000 }; // weak
_UNKNOWN unk_100AC9A8; // weak
int dword_100AC9AC[] = { 6006 }; // weak
char *off_100AD858 = "/shr_mem/iop_gtx_intf.shr"; // weak
__int16 word_100AD978[] = { 551 }; // weak
void *off_100B2664 = &unk_100B1F70; // weak
void *off_100B266C = &unk_100B1F74; // weak
void *off_100B2674 = &unk_100B1F78; // weak
void *off_100B267C = &unk_100B1F7C; // weak
void *off_100B2684 = &unk_100B1F80; // weak
void *off_100B2F28 = &unk_100B1F70; // weak
void *off_100B2F30 = &unk_100B1F74; // weak
void *off_100B2F38 = &unk_100B1F78; // weak
void *off_100B2F40 = &unk_100B1F7C; // weak
void *off_100B2F48 = &unk_100B1F80; // weak
void *off_100B30B8 = &unk_100B1F70; // weak
void *off_100B30C0 = &unk_100B1F74; // weak
void *off_100B30C8 = &unk_100B1F78; // weak
void *off_100B30D0 = &unk_100B1F7C; // weak
void *off_100B30D8 = &unk_100B1F80; // weak
void *off_100B3158 = &unk_100B1F70; // weak
void *off_100B3160 = &unk_100B1F74; // weak
void *off_100B3168 = &unk_100B1F78; // weak
void *off_100B3170 = &unk_100B1F7C; // weak
void *off_100B3178 = &unk_100B1F80; // weak
void *off_100B3314 = &unk_100B1F70; // weak
void *off_100B331C = &unk_100B1F74; // weak
void *off_100B3324 = &unk_100B1F78; // weak
void *off_100B332C = &unk_100B1F7C; // weak
void *off_100B3334 = &unk_100B1F80; // weak
void *off_100B3470 = &unk_100B1F70; // weak
void *off_100B3478 = &unk_100B1F74; // weak
void *off_100B3480 = &unk_100B1F78; // weak
void *off_100B3488 = &unk_100B1F7C; // weak
void *off_100B3490 = &unk_100B1F80; // weak
void *off_100B34E8 = &unk_100B1F70; // weak
void *off_100B34F0 = &unk_100B1F74; // weak
void *off_100B34F8 = &unk_100AED50; // weak
void *off_100B3500 = &unk_100B1F7C; // weak
void *off_100B3508 = &unk_100B1F80; // weak
void *off_100B3510 = &unk_100B1628; // weak
void *off_100B3518 = &unk_100B1F74; // weak
void *off_100B3520 = &unk_100B1638; // weak
void *off_100B3528 = &unk_100B1F7C; // weak
void *off_100B3530 = &unk_100B1F80; // weak
void *off_100B3538 = &unk_100B11D8; // weak
void *off_100B3540 = &unk_100B12F8; // weak
void *off_100B3548 = &unk_100B13F0; // weak
void *off_100B3550 = &unk_100B1470; // weak
void *off_100B3558 = &unk_100B1594; // weak
char byte_100B3560[] = { '\x06' }; // weak
char byte_100B3561[] = { '\x04' }; // weak
char byte_100B3562[] = { '\x03' }; // weak
void *off_100B3564 = &unk_100B1F70; // weak
void *off_100B356C = &unk_100B1F74; // weak
void *off_100B3574 = &unk_100B1F78; // weak
void *off_100B357C = &unk_100B1F7C; // weak
void *off_100B3584 = &unk_100B1F80; // weak
char byte_100B3DD0[] = { '\x06' }; // weak
char byte_100B3DD1[] = { '\x04' }; // weak
char byte_100B3DD2[] = { '\x03' }; // weak
void *off_100B3DD4 = &unk_100B1F70; // weak
void *off_100B3DDC = &unk_100B1F74; // weak
void *off_100B3DE4 = &unk_100B1F78; // weak
void *off_100B3DEC = &unk_100B1F7C; // weak
void *off_100B3DF4 = &unk_100B1F80; // weak
void *off_100B42F4 = &unk_100B1F70; // weak
void *off_100B42FC = &unk_100B22EC; // weak
void *off_100B4304 = &unk_100B1F78; // weak
void *off_100B430C = &unk_100B1F7C; // weak
void *off_100B4314 = &unk_100B1F80; // weak
void *off_100B431C = &unk_100B233C; // weak
void *off_100B4324 = &unk_100B234C; // weak
void *off_100B432C = &unk_100B2384; // weak
void *off_100B4334 = &unk_100B1F7C; // weak
void *off_100B433C = &unk_100B1F80; // weak
void *off_100B4344 = &unk_100B1F70; // weak
void *off_100B436C = &unk_100B1F70; // weak
__int16 word_100B4414[] = { 6778 }; // weak
__int16 word_100B4418[] = { 77 }; // weak
__int16 word_100B4976[] = { 1 }; // weak
_UNKNOWN unk_100B49D2; // weak
_UNKNOWN unk_100B4A98; // weak
_UNKNOWN unk_100B4A99; // weak
_UNKNOWN unk_100B5AD8; // weak
_UNKNOWN unk_100B6160; // weak
int dword_100B6164[] = { 256 }; // weak
char byte_100B6168[] = { '\0' }; // weak
char byte_100B6169[] = { '\0' }; // weak
char byte_100B616A[] = { '\0' }; // weak
_UNKNOWN unk_100B7838; // weak
_UNKNOWN unk_100B783C; // weak
_UNKNOWN unk_100B7840; // weak
_UNKNOWN unk_100B78C8; // weak
_UNKNOWN unk_100B793C; // weak
char *off_100B79FC = "/shr_mem/iop_tcas_ii_intf.shr"; // weak
char off_100B8640[] = { '0', '\x1E', '\n', '\x10' }; // idb
int dword_100B865C = 1; // idb
char byte_100B8678[] = { '\x01' }; // weak
char *off_100B867C[3] = { "1", "2", "fail_normal_1" }; // weak
char *off_100B8680[2] = { "2", "fail_normal_1" }; // weak
char off_100B8684[8] = { '$', '', '\v', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100B8708[] = { '\0' }; // weak
char byte_100B8709[] = { '\0' }; // weak
int dword_100B870C[] = { 0 }; // weak
char *off_100B8710 = "0, 0, 0"; // weak
double dbl_100B8978[] = {  0.0 }; // weak
double dbl_100B8980[] = {  0.0 }; // weak
double dbl_100B8988[] = {  0.0 }; // weak
int dword_100B8990[] = { 0 }; // weak
char off_100B8994[32] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100B9598[] = {  0.0 }; // weak
float flt_100B959C[] = {  0.0 }; // weak
float flt_100B95A0[] = {  0.0 }; // weak
int dword_100B95A4[] = { 0 }; // weak
char off_100B95A8[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char *off_100B9D2C[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_100CE988
}; // weak
int dword_100B9D40[] = { 0 }; // weak
int dword_100B9D44[] = { 0 }; // weak
int dword_100B9D48[] = { 0 }; // weak
int dword_100B9D4C[] = { 0 }; // weak
char *off_100B9D50 = "0, 0, 0"; // weak
__int16 word_100BA4D8[] = { 0 }; // weak
__int16 word_100BA4DA[] = { 0 }; // weak
__int16 word_100BA4DC[] = { 0 }; // weak
int dword_100BA4E0[] = { 0 }; // weak
char *off_100BA4E4 = "0, 0, 0"; // weak
int dword_100BAAE8[] = { 0 }; // weak
int dword_100BAAEC[] = { 0 }; // weak
int dword_100BAAF0[] = { 0 }; // weak
int dword_100BAAF4[] = { 0 }; // weak
char off_100BAAF8[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100BB280[] = { 0 }; // weak
int dword_100BB284[] = { 0 }; // weak
int dword_100BB288[] = { 0 }; // weak
int dword_100BB28C[] = { 0 }; // weak
int dword_100BB290[] = { 0 }; // weak
int dword_100BB294[] = { 0 }; // weak
int dword_100BB298[] = { 0 }; // weak
char off_100BB29C[32] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100BBEA0[] = { '\0' }; // weak
char byte_100BBEA1[] = { '\0' }; // weak
char byte_100BBEA2[] = { '\0' }; // weak
int dword_100BBEA4[] = { 0 }; // weak
char *off_100BBEA8 = "0, 0, 0"; // weak
int dword_100BC330[] = { 0 }; // weak
int dword_100BC334[] = { 0 }; // weak
int dword_100BC338[] = { 0 }; // weak
int dword_100BC33C[] = { 0 }; // weak
char *off_100BC340 = "0, 0, 0"; // weak
int dword_100BCAC8[] = { 0 }; // weak
int dword_100BCACC[] = { 0 }; // weak
int dword_100BCAD0[] = { 0 }; // weak
int dword_100BCAD4[] = { 0 }; // weak
char off_100BCAD8[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100BCE38[] = { 0 }; // weak
__int16 word_100BCE3A[] = { 0 }; // weak
__int16 word_100BCE3C[] = { 0 }; // weak
int dword_100BCE40[] = { 0 }; // weak
char *off_100BCE44 = "0, 0, 0"; // weak
int dword_100BD0F8[] = { 0 }; // weak
int dword_100BD0FC[] = { 0 }; // weak
int dword_100BD100[] = { 0 }; // weak
int dword_100BD104[] = { 0 }; // weak
char off_100BD108[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100BD468[] = { 0 }; // weak
int dword_100BD46C[] = { 0 }; // weak
int dword_100BD470[] = { 0 }; // weak
int dword_100BD474[] = { 0 }; // weak
int dword_100BD478[] = { 0 }; // weak
int dword_100BD47C[] = { 0 }; // weak
int dword_100BD480[] = { 0 }; // weak
char *off_100BD484 = "0, 0, 0"; // weak
char byte_100BD9E8[] = { '\0' }; // weak
char byte_100BD9E9[] = { '\0' }; // weak
char byte_100BD9EA[] = { '\0' }; // weak
int dword_100BD9EC[] = { 0 }; // weak
char *off_100BD9F0 = "0, 0, 0"; // weak
int dword_100BDBF8[] = { 0 }; // weak
int dword_100BDBFC[] = { 0 }; // weak
int dword_100BDC00[] = { 0 }; // weak
int dword_100BDC04[] = { 0 }; // weak
char off_100BDC08[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100BDF68[] = { '\x01' }; // weak
char *off_100BDF6C[3] = { "1", "2", "fail_robust_1" }; // weak
char *off_100BDF70[2] = { "2", "fail_robust_1" }; // weak
char off_100BDF74[8] = { '', '', '\v', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100BDFF8[] = { '\0' }; // weak
char byte_100BDFF9[] = { '\0' }; // weak
int dword_100BDFFC[] = { 0 }; // weak
char *off_100BE000 = "0, 0, 0"; // weak
double dbl_100BE268[] = {  0.0 }; // weak
double dbl_100BE270[] = {  0.0 }; // weak
double dbl_100BE278[] = {  0.0 }; // weak
int dword_100BE280[] = { 0 }; // weak
char *off_100BE284 = "0, 0, 0"; // weak
float flt_100BEE88[] = {  0.0 }; // weak
float flt_100BEE8C[] = {  0.0 }; // weak
float flt_100BEE90[] = {  0.0 }; // weak
int dword_100BEE94[] = { 0 }; // weak
char off_100BEE98[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100BF620[] = { 0 }; // weak
int dword_100BF624[] = { 0 }; // weak
int dword_100BF628[] = { 0 }; // weak
int dword_100BF62C[] = { 0 }; // weak
char *off_100BF630 = "0, 0, 0"; // weak
__int16 word_100BFDB8[] = { 0 }; // weak
__int16 word_100BFDBA[] = { 0 }; // weak
__int16 word_100BFDBC[] = { 0 }; // weak
int dword_100BFDC0[] = { 0 }; // weak
char *off_100BFDC4 = "0, 0, 0"; // weak
int dword_100C03C8[] = { 0 }; // weak
int dword_100C03CC[] = { 0 }; // weak
int dword_100C03D0[] = { 0 }; // weak
int dword_100C03D4[] = { 0 }; // weak
char off_100C03D8[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100C0B60[] = { 0 }; // weak
int dword_100C0B64[] = { 0 }; // weak
int dword_100C0B68[] = { 0 }; // weak
int dword_100C0B6C[] = { 0 }; // weak
int dword_100C0B70[] = { 0 }; // weak
int dword_100C0B74[] = { 0 }; // weak
int dword_100C0B78[] = { 0 }; // weak
char off_100C0B7C[32] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100C1780[] = { '\0' }; // weak
char byte_100C1781[] = { '\0' }; // weak
char byte_100C1782[] = { '\0' }; // weak
int dword_100C1784[] = { 0 }; // weak
char *off_100C1788 = "0, 0, 0"; // weak
int dword_100C1C10[] = { 0 }; // weak
int dword_100C1C14[] = { 0 }; // weak
int dword_100C1C18[] = { 0 }; // weak
int dword_100C1C1C[] = { 0 }; // weak
char *off_100C1C20 = "0, 0, 0"; // weak
int dword_100C23A8[] = { 0 }; // weak
int dword_100C23AC[] = { 0 }; // weak
int dword_100C23B0[] = { 0 }; // weak
int dword_100C23B4[] = { 0 }; // weak
char off_100C23B8[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100C2718[] = { 0 }; // weak
__int16 word_100C271A[] = { 0 }; // weak
__int16 word_100C271C[] = { 0 }; // weak
int dword_100C2720[] = { 0 }; // weak
char *off_100C2724 = "0, 0, 0"; // weak
int dword_100C29D8[] = { 0 }; // weak
int dword_100C29DC[] = { 0 }; // weak
int dword_100C29E0[] = { 0 }; // weak
int dword_100C29E4[] = { 0 }; // weak
char off_100C29E8[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100C2D48[] = { 0 }; // weak
int dword_100C2D4C[] = { 0 }; // weak
int dword_100C2D50[] = { 0 }; // weak
int dword_100C2D54[] = { 0 }; // weak
int dword_100C2D58[] = { 0 }; // weak
int dword_100C2D5C[] = { 0 }; // weak
int dword_100C2D60[] = { 0 }; // weak
char *off_100C2D64 = "0, 0, 0"; // weak
char byte_100C32C8[] = { '\0' }; // weak
char byte_100C32C9[] = { '\0' }; // weak
char byte_100C32CA[] = { '\0' }; // weak
int dword_100C32CC[] = { 0 }; // weak
char *off_100C32D0 = "0, 0, 0"; // weak
int dword_100C34D8[] = { 0 }; // weak
int dword_100C34DC[] = { 0 }; // weak
int dword_100C34E0[] = { 0 }; // weak
int dword_100C34E4[] = { 0 }; // weak
char off_100C34E8[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100C3848[] = { '\x01' }; // weak
char *off_100C384C[3] = { "1", "1", "pass_normal_1" }; // weak
char *off_100C3850[2] = { "1", "pass_normal_1" }; // weak
char off_100C3854[8] = { '\f', '', '\v', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100C3898[] = { '\0' }; // weak
char byte_100C3899[] = { '\0' }; // weak
int dword_100C389C[] = { 0 }; // weak
char *off_100C38A0 = "0, 0, 0"; // weak
double dbl_100C3B08[] = {  0.0 }; // weak
double dbl_100C3B10[] = {  0.0 }; // weak
double dbl_100C3B18[] = {  0.0 }; // weak
int dword_100C3B20[] = { 0 }; // weak
char *off_100C3B24 = "0, 0, 0"; // weak
float flt_100C4728[] = {  0.0 }; // weak
float flt_100C472C[] = {  0.0 }; // weak
float flt_100C4730[] = {  0.0 }; // weak
int dword_100C4734[] = { 0 }; // weak
char off_100C4738[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100C4EC0[] = { 0 }; // weak
int dword_100C4EC4[] = { 0 }; // weak
int dword_100C4EC8[] = { 0 }; // weak
int dword_100C4ECC[] = { 0 }; // weak
char *off_100C4ED0 = "0, 0, 0"; // weak
__int16 word_100C5658[] = { 0 }; // weak
__int16 word_100C565A[] = { 0 }; // weak
__int16 word_100C565C[] = { 0 }; // weak
int dword_100C5660[] = { 0 }; // weak
char *off_100C5664 = "0, 0, 0"; // weak
int dword_100C5C68[] = { 0 }; // weak
int dword_100C5C6C[] = { 0 }; // weak
int dword_100C5C70[] = { 0 }; // weak
int dword_100C5C74[] = { 0 }; // weak
char off_100C5C78[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100C6400[] = { 0 }; // weak
int dword_100C6404[] = { 0 }; // weak
int dword_100C6408[] = { 0 }; // weak
int dword_100C640C[] = { 0 }; // weak
int dword_100C6410[] = { 0 }; // weak
int dword_100C6414[] = { 0 }; // weak
int dword_100C6418[] = { 0 }; // weak
char off_100C641C[32] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100C7020[] = { '\0' }; // weak
char byte_100C7021[] = { '\0' }; // weak
char byte_100C7022[] = { '\0' }; // weak
int dword_100C7024[] = { 0 }; // weak
char *off_100C7028 = "0, 0, 0"; // weak
int dword_100C74B0[] = { 0 }; // weak
int dword_100C74B4[] = { 0 }; // weak
int dword_100C74B8[] = { 0 }; // weak
int dword_100C74BC[] = { 0 }; // weak
char *off_100C74C0 = "0, 0, 0"; // weak
int dword_100C7C48[] = { 0 }; // weak
int dword_100C7C4C[] = { 0 }; // weak
int dword_100C7C50[] = { 0 }; // weak
int dword_100C7C54[] = { 0 }; // weak
char off_100C7C58[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100C7FB8[] = { 0 }; // weak
__int16 word_100C7FBA[] = { 0 }; // weak
__int16 word_100C7FBC[] = { 0 }; // weak
int dword_100C7FC0[] = { 0 }; // weak
char *off_100C7FC4 = "0, 0, 0"; // weak
int dword_100C8278[] = { 0 }; // weak
int dword_100C827C[] = { 0 }; // weak
int dword_100C8280[] = { 0 }; // weak
int dword_100C8284[] = { 0 }; // weak
char off_100C8288[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100C85E8[] = { 0 }; // weak
int dword_100C85EC[] = { 0 }; // weak
int dword_100C85F0[] = { 0 }; // weak
int dword_100C85F4[] = { 0 }; // weak
int dword_100C85F8[] = { 0 }; // weak
int dword_100C85FC[] = { 0 }; // weak
int dword_100C8600[] = { 0 }; // weak
char *off_100C8604 = "0, 0, 0"; // weak
char byte_100C8B68[] = { '\0' }; // weak
char byte_100C8B69[] = { '\0' }; // weak
char byte_100C8B6A[] = { '\0' }; // weak
int dword_100C8B6C[] = { 0 }; // weak
char *off_100C8B70 = "0, 0, 0"; // weak
int dword_100C8D78[] = { 0 }; // weak
int dword_100C8D7C[] = { 0 }; // weak
int dword_100C8D80[] = { 0 }; // weak
int dword_100C8D84[] = { 0 }; // weak
char off_100C8D88[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100C90E8[] = { '\x01' }; // weak
char *off_100C90EC[3] = { "1", "1", "pass_robust_1" }; // weak
char *off_100C90F0[2] = { "1", "pass_robust_1" }; // weak
char off_100C90F4[8] = { '', '', '\v', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100C9138[] = { '\0' }; // weak
char byte_100C9139[] = { '\0' }; // weak
int dword_100C913C[] = { 0 }; // weak
char *off_100C9140 = "0, 0, 0"; // weak
double dbl_100C93A8[] = {  0.0 }; // weak
double dbl_100C93B0[] = {  0.0 }; // weak
double dbl_100C93B8[] = {  0.0 }; // weak
int dword_100C93C0[] = { 0 }; // weak
char *off_100C93C4 = "0, 0, 0"; // weak
float flt_100C9FC8[] = {  0.0 }; // weak
float flt_100C9FCC[] = {  0.0 }; // weak
float flt_100C9FD0[] = {  0.0 }; // weak
int dword_100C9FD4[] = { 0 }; // weak
char off_100C9FD8[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100CA760[] = { 0 }; // weak
int dword_100CA764[] = { 0 }; // weak
int dword_100CA768[] = { 0 }; // weak
int dword_100CA76C[] = { 0 }; // weak
char *off_100CA770 = "0, 0, 0"; // weak
__int16 word_100CAEF8[] = { 0 }; // weak
__int16 word_100CAEFA[] = { 0 }; // weak
__int16 word_100CAEFC[] = { 0 }; // weak
int dword_100CAF00[] = { 0 }; // weak
char *off_100CAF04 = "0, 0, 0"; // weak
int dword_100CB508[] = { 0 }; // weak
int dword_100CB50C[] = { 0 }; // weak
int dword_100CB510[] = { 0 }; // weak
int dword_100CB514[] = { 0 }; // weak
char off_100CB518[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100CBCA0[] = { 0 }; // weak
int dword_100CBCA4[] = { 0 }; // weak
int dword_100CBCA8[] = { 0 }; // weak
int dword_100CBCAC[] = { 0 }; // weak
int dword_100CBCB0[] = { 0 }; // weak
int dword_100CBCB4[] = { 0 }; // weak
int dword_100CBCB8[] = { 0 }; // weak
char off_100CBCBC[32] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100CC8C0[] = { '\0' }; // weak
char byte_100CC8C1[] = { '\0' }; // weak
char byte_100CC8C2[] = { '\0' }; // weak
int dword_100CC8C4[] = { 0 }; // weak
char *off_100CC8C8 = "0, 0, 0"; // weak
int dword_100CCD50[] = { 0 }; // weak
int dword_100CCD54[] = { 0 }; // weak
int dword_100CCD58[] = { 0 }; // weak
int dword_100CCD5C[] = { 0 }; // weak
char *off_100CCD60 = "0, 0, 0"; // weak
int dword_100CD4E8[] = { 0 }; // weak
int dword_100CD4EC[] = { 0 }; // weak
int dword_100CD4F0[] = { 0 }; // weak
int dword_100CD4F4[] = { 0 }; // weak
char off_100CD4F8[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100CD858[] = { 0 }; // weak
__int16 word_100CD85A[] = { 0 }; // weak
__int16 word_100CD85C[] = { 0 }; // weak
int dword_100CD860[] = { 0 }; // weak
char *off_100CD864 = "0, 0, 0"; // weak
int dword_100CDB18[] = { 0 }; // weak
int dword_100CDB1C[] = { 0 }; // weak
int dword_100CDB20[] = { 0 }; // weak
int dword_100CDB24[] = { 0 }; // weak
char off_100CDB28[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100CDE88[] = { 0 }; // weak
int dword_100CDE8C[] = { 0 }; // weak
int dword_100CDE90[] = { 0 }; // weak
int dword_100CDE94[] = { 0 }; // weak
int dword_100CDE98[] = { 0 }; // weak
int dword_100CDE9C[] = { 0 }; // weak
int dword_100CDEA0[] = { 0 }; // weak
char *off_100CDEA4 = "0, 0, 0"; // weak
char byte_100CE408[] = { '\0' }; // weak
char byte_100CE409[] = { '\0' }; // weak
char byte_100CE40A[] = { '\0' }; // weak
int dword_100CE40C[] = { 0 }; // weak
char *off_100CE410 = "0, 0, 0"; // weak
int dword_100CE618[] = { 0 }; // weak
int dword_100CE61C[] = { 0 }; // weak
int dword_100CE620[] = { 0 }; // weak
int dword_100CE624[] = { 0 }; // weak
char off_100CE628[20] =
{
  '',
  '',
  '\v',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_100CF608; // weak
char byte_100D3550[] = { '\x01' }; // weak
__int16 word_100D3552[] = { 3020 }; // weak
char aAhrs1Tas[12] = "\aAHRS1 TAS"; // weak
char aAhrs1NotReceiv[36] = "AHRS1 not receiving valid airspeed."; // weak
_BYTE byte_100D614C[21] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // idb
_BYTE byte_100D6161[21] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // idb
char byte_100D6176[] = { '\x03' }; // weak
char byte_100D6177[] = { '\x01' }; // weak
int dword_100D6178[] = { 1000 }; // weak
__int16 word_100D617C[] = { 0 }; // weak
char byte_100D617E[] = { '\x01' }; // weak
char byte_100D617F[] = { '\x01' }; // weak
char byte_100D6180[] = { '\xFF' }; // weak
char byte_100D6181[] = { '\xFF' }; // weak
__int16 word_100D6182[] = { 0 }; // weak
int dword_100D6184[] = { 0 }; // weak
int dword_100D6188[] = { 0 }; // weak
__int16 word_100D618C[] = { 0 }; // weak
int dword_100D6190[] = { 0 }; // weak
_UNKNOWN unk_100E5DE0; // weak
_UNKNOWN unk_100E5DE2; // weak
int dword_100E5DE4 = 9429; // idb
_UNKNOWN unk_100E6AD8; // weak
int dword_100E6ADC[] = { 9826 }; // weak
_UNKNOWN unk_100E6AE0; // weak
_UNKNOWN unk_100E6C58; // weak
__int16 word_100E6C5A[] = { 301 }; // weak
__int16 word_100E6C5C[] = { 302 }; // weak
__int16 word_100E6C5E[] = { 303 }; // weak
__int16 word_100E6C60[] = { 304 }; // weak
__int16 word_100E6C62[] = { 305 }; // weak
__int16 word_100E6C64[] = { 306 }; // weak
__int16 word_100E6C66[] = { 307 }; // weak
_UNKNOWN unk_100E6D78; // weak
__int16 word_100E6D7A[] = { 282 }; // weak
_BYTE byte_100E6D7C[448] =
{
  76,
  82,
  85,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  138,
  1,
  71,
  67,
  85,
  49,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  4,
  0,
  139,
  1,
  71,
  67,
  85,
  50,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  0,
  140,
  1,
  71,
  77,
  67,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  0,
  141,
  1,
  71,
  69,
  78,
  32,
  82,
  77,
  84,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  5,
  0,
  134,
  1,
  71,
  84,
  67,
  49,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  6,
  0,
  135,
  1,
  71,
  84,
  67,
  50,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  7,
  0,
  136,
  1,
  71,
  84,
  67,
  51,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  8,
  0,
  137,
  1
}; // idb
_UNKNOWN unk_100E6F70; // weak
__int16 word_100E6F72[] = { 236 }; // weak
_UNKNOWN unk_100E7080; // weak
_UNKNOWN off_100E7084; // idb
_UNKNOWN unk_100E7D78; // weak
_UNKNOWN unk_100E897C; // weak
char byte_100E897D[] = { '\x01' }; // weak
_UNKNOWN unk_100E89A0; // weak
char aComXfer[9] = "COM XFER"; // weak
char *off_100EB904 = "Cannot send message. Data radio failed."; // weak
_UNKNOWN unk_100EBAF0; // weak
char *off_100EBC94[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_100EBCA8 }; // weak
char *off_100EBE38 = "true"; // weak
char byte_100EBE3C[] = { '\x01' }; // weak
char *off_100EBEA0 = "failure listener"; // weak
char *off_100EC890 = "printf_listener"; // weak
__int16 word_100ED4C4 = 2573; // weak
char *off_100ED620 = "gate_listener"; // weak
_UNKNOWN unk_100EDAC8; // weak
_UNKNOWN unk_100EDAEC; // weak
_UNKNOWN unk_100EDC90; // weak
int dword_100EDD84[] = { 1 }; // weak
int dword_100EDD88[] = { 0 }; // weak
char byte_100EDD8C[] = { '\0' }; // weak
_UNKNOWN dword_100EDD94; // idb
_UNKNOWN unk_100EF600; // weak
char byte_100EF601[] = { '\0' }; // weak
char byte_100EF685[] = { '\x1E' }; // weak
_UNKNOWN unk_100EFE90; // weak
int dword_100EFE94[] = { 0 }; // weak
_UNKNOWN unk_100EFEA8; // weak
int dword_100EFEAC[] = { 0 }; // weak
_UNKNOWN unk_100EFED0; // weak
int dword_100EFED4[] = { 0 }; // weak
_UNKNOWN unk_100EFF00; // weak
int dword_100EFF04[] = { 0 }; // weak
_UNKNOWN unk_100F01C4; // weak
_UNKNOWN unk_100F01C8; // weak
_UNKNOWN unk_100F01CC; // weak
_UNKNOWN unk_100F01D4; // weak
_UNKNOWN unk_100F01D8; // weak
_UNKNOWN unk_100F0280; // weak
_UNKNOWN unk_100F0290; // weak
_UNKNOWN unk_100F0384; // weak
_UNKNOWN unk_100F0410; // weak
_UNKNOWN unk_100F0414; // weak
_UNKNOWN unk_100F0418; // weak
_UNKNOWN unk_100F046C; // weak
_UNKNOWN unk_100F0490; // weak
void *off_100F0558 = &unk_100F04B0; // weak
void *off_100F0560 = &unk_100F04B4; // weak
void *off_100F0568 = &unk_100F051C; // weak
void *off_100F0570 = &unk_100F0520; // weak
void *off_100F0578 = &unk_100F0550; // weak
int dword_100F0580[] = { 67108864 }; // weak
void *off_100F2988 = &unk_100F2974; // weak
void *off_100F2994 = &unk_100F1A38; // weak
void *off_100F29A0 = &unk_100F1AB8; // weak
void *off_100F29AC = &unk_100F1B18; // weak
void *off_100F29B8 = &unk_100F1A24; // weak
void *off_100F29C4 = &unk_100F2974; // weak
void *off_100F2A04 = &unk_100F2974; // weak
void *off_100F2A10 = &unk_100F2978; // weak
void *off_100F2A1C = &unk_100F297C; // weak
void *off_100F2A28 = &unk_100F2980; // weak
void *off_100F2A34 = &unk_100F2984; // weak
void *off_100F32C4 = &unk_100F2974; // weak
void *off_100F32D0 = &unk_100F2978; // weak
void *off_100F32DC = &unk_100F297C; // weak
void *off_100F32E8 = &unk_100F2980; // weak
void *off_100F32F4 = &unk_100F2984; // weak
_UNKNOWN unk_100F3B30; // weak
_UNKNOWN unk_100F3B34; // weak
_UNKNOWN unk_100F3B38; // weak
_UNKNOWN unk_100F3B3C; // weak
_UNKNOWN unk_100F3B40; // weak
_UNKNOWN unk_100F3B44; // weak
_UNKNOWN unk_100F3B48; // weak
_UNKNOWN unk_100F3B74; // weak
_UNKNOWN unk_100F3B98; // weak
_UNKNOWN unk_100F3BC8; // weak
_UNKNOWN unk_100F3C40; // weak
_UNKNOWN unk_100F3D38; // weak
_UNKNOWN unk_100F3D44; // weak
_UNKNOWN unk_100F3D58; // weak
void *off_100F3D68 = &unk_100F3BBC; // weak
void *off_100F3D78 = &unk_100F3CA8; // weak
void *off_100F3D88 = &unk_100F3CD8; // weak
void *off_100F3D98 = &unk_100F3D08; // weak
void *off_100F3DA8 = &unk_100F3B40; // weak
void *off_100F3DB8 = &unk_100F3B44; // weak
_UNKNOWN unk_100F3DC8; // weak
_UNKNOWN unk_100F3DCC; // weak
_UNKNOWN unk_100F3E00; // weak
_UNKNOWN unk_100F3E30; // weak
_UNKNOWN unk_100F3E70; // weak
_UNKNOWN unk_100F3E98; // weak
_UNKNOWN unk_100F3E9C; // weak
_UNKNOWN unk_100F3EB8; // weak
_UNKNOWN unk_100F3EFC; // weak
_UNKNOWN unk_100F3F10; // weak
_WORD dword_100F3FA0[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_100F43A0[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_100F47A0[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_100F4BA0[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_100F4FA0[] = { 99 }; // weak
int dword_100F53A0[] = { 25344 }; // weak
int dword_100F57A0[] = { 6488064 }; // weak
int dword_100F5BA0[] = { 1660944384 }; // weak
int dword_100F5FC8[] = { 128 }; // weak
int dword_100F5FD8[] = { 0 }; // weak
int dword_100F5FE8[] = { 0 }; // weak
char byte_100F6059[] = { '\0' }; // weak
char byte_100F605A[] = { '\0' }; // weak
char byte_100F605B[] = { '\0' }; // weak
char byte_100F605C[] = { '\x10' }; // weak
int dword_100F6070[] = { 0 }; // weak
_UNKNOWN unk_100F60E8; // weak
_UNKNOWN unk_100F6568; // weak
char byte_100F65E0[] = { '\0' }; // weak
char byte_100F66E0[] = { '\0' }; // weak
char byte_100F67E0[] = { '\0' }; // weak
int dword_100F68E0[] = { 0 }; // weak
int dword_100F6958[] = { 0 }; // weak
__int16 word_100F69D0[] = { 0 }; // weak
__int16 word_100F69D2[] = { 0 }; // weak
__int16 word_100F69D4[] = { 0 }; // weak
__int16 word_100F69D6[] = { 0 }; // weak
int (__cdecl *off_100F69D8)(int, int) = &sub_1004B350; // weak
void *off_100F6B84 = &unk_100F60E8; // weak
void *off_100F6B98 = &unk_100F6568; // weak
_UNKNOWN unk_100F6BAC; // weak
int dword_100F6BC0[] = { 0 }; // weak
int dword_100F6C08[] = { 16 }; // weak
_UNKNOWN unk_100F6C58; // weak
_UNKNOWN unk_100F6CD8; // weak
_UNKNOWN unk_100F6D58; // weak
_UNKNOWN unk_100F6DD0; // weak
_UNKNOWN unk_100F6E48; // weak
_UNKNOWN unk_100F7E48; // weak
int dword_100FC0AC[] = { 0 }; // weak
__int16 *off_100FC0B0 = &word_100ED4C4; // weak
_UNKNOWN unk_100FC140; // weak
_UNKNOWN unk_100FC144; // weak
_UNKNOWN unk_100FC148; // weak
_UNKNOWN unk_100FC14C; // weak
_UNKNOWN unk_100FC150; // weak
_UNKNOWN unk_100FC154; // weak
_UNKNOWN unk_100FC158; // weak
_UNKNOWN unk_100FC15C; // weak
char byte_100FC160[] = { '\x01' }; // weak
__int16 word_100FC162[] = { 3020 }; // weak
char byte_100FDA28[] = { '\x01' }; // weak
__int16 word_100FDA30[] = { 3020 }; // weak
char byte_100FF6C2[] = { '\x04' }; // weak
char byte_100FF6C7[] = { '\a' }; // weak
__int16 word_10101078[] = { 0 }; // weak
__int16 word_10101278[] = { 0 }; // weak
int dword_10101478[] = { 0 }; // weak
_UNKNOWN unk_101028C8; // weak
char byte_101028CA[] = { '\0' }; // weak
_UNKNOWN unk_10103498; // weak
int dword_1010349C[] = { 3535 }; // weak
_UNKNOWN unk_101034D0; // weak
int dword_101034D4[] = { 6813 }; // weak
_UNKNOWN unk_10103508; // weak
int dword_1010350C[] = { 9036 }; // weak
_UNKNOWN unk_10103540; // weak
int dword_10103544[] = { 6763 }; // weak
char byte_10103AB0[] = { '\0' }; // weak
int dword_10103AB4[] = { 29 }; // weak
_UNKNOWN unk_10104B74; // weak
char byte_10104B78[] = { '\x01' }; // weak
char byte_10104B79[] = { '\0' }; // weak
int dword_101056B8[] = { 6103 }; // weak
int dword_101056BC[] = { 8000 }; // weak
_UNKNOWN unk_1010F2F0; // weak
_UNKNOWN unk_1010F2F8; // weak
int (*off_1011125C[3])() = { &_fptrap, &_fptrap, &_fptrap }; // weak
_UNKNOWN unk_10111280; // weak
void *off_10111CD0 = &unk_102368A0; // weak
_UNKNOWN unk_10111CE0; // weak
_UNKNOWN unk_10111D40; // weak
int dword_10111F50 = 2; // weak
int dword_10112254 = 1024; // weak
int dword_10112258 = 4294966273; // weak
int dword_1011225C = 53; // weak
int dword_10112260 = 11; // weak
int dword_10112264 = 64; // weak
int dword_10112268 = 1023; // weak
int dword_1011226C = 128; // weak
int dword_10112270 = 4294967169; // weak
int dword_10112274 = 24; // weak
int dword_10112278 = 8; // weak
int dword_1011227C = 32; // weak
int dword_10112280 = 127; // weak
float flt_10112780 =  0.0; // weak
__int16 word_10112784 = 0; // weak
char byte_10112786 = '\0'; // weak
char byte_10112787 = '\0'; // weak
float flt_10112788 =  0.0; // weak
float flt_1011278C =  0.0; // weak
__int16 word_10112790 = 0; // weak
char byte_10112792 = '\0'; // weak
char byte_10112793 = '\0'; // weak
int dword_10112794 = 0; // weak
int dword_101127B4 = 0; // weak
char byte_10112838 = '\0'; // weak
char byte_1011283C = '\0'; // weak
_UNKNOWN unk_1011283E; // weak
int dword_1011286C = 0; // weak
char byte_10112870 = '\0'; // weak
int dword_10112874 = 0; // weak
int dword_10112878 = 0; // weak
char byte_10112880[] = { '\0' }; // weak
char byte_10112881 = '\0'; // weak
char byte_10112882 = '\0'; // weak
char byte_10112883 = '\0'; // weak
char byte_10112884[] = { '\0' }; // weak
int dword_10112888 = 0; // weak
__int16 word_1011288C = 0; // weak
_UNKNOWN unk_10112890; // weak
int dword_10112C78 = 0; // weak
char byte_10112C7C[] = { '\0' }; // weak
int dword_10112C80 = 0; // weak
int dword_10112C84 = 0; // weak
int dword_10112C88 = 0; // weak
_UNKNOWN unk_10112C8C; // weak
int dword_10112D04 = 0; // weak
char byte_10112D08[] = { '\0' }; // weak
int dword_10112D10[] = { 0 }; // weak
int dword_10112D14[] = { 0 }; // weak
int dword_10112D18[] = { 0 }; // weak
int dword_10112D1C[] = { 0 }; // weak
int dword_10112D20[] = { 0 }; // weak
int dword_10112D24[] = { 0 }; // weak
int dword_10112D28[] = { 0 }; // weak
char byte_10112D2C[] = { '\0' }; // weak
_UNKNOWN unk_10112D30; // weak
int dword_10112DA4[] = { 0 }; // weak
char byte_10112E40[40] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_10112E68; // weak
char byte_101133F8; // weak
char byte_10113400[]; // weak
_UNKNOWN unk_10113408; // weak
int dword_101134B0; // weak
int dword_101134B4; // weak
int dword_101134B8; // weak
int dword_101134BC; // weak
char byte_101134C0[]; // weak
char byte_101134C2; // weak
char byte_101134C3; // weak
int dword_101134C4; // weak
_UNKNOWN unk_101134C8; // weak
char byte_10113548; // weak
char byte_10113549; // weak
char byte_1011354A; // weak
_UNKNOWN unk_10113560; // weak
int dword_1011CF30; // weak
int dword_1011CF34; // weak
char byte_1011CF38; // weak
char byte_1011CF39; // weak
_UNKNOWN unk_1011CF40; // weak
int dword_10120F3C; // weak
char byte_10120F40[100]; // idb
int dword_10120FA4; // weak
int dword_10120FA8; // weak
int dword_10120FAC; // weak
int dword_10120FB0; // weak
int dword_10120FB4; // weak
int dword_10120FB8; // weak
int dword_101267B8; // weak
char byte_101267BC; // weak
void *dword_101267C0; // idb
int dword_101267C4; // weak
int dword_101267C8; // weak
int dword_101267CC; // weak
int dword_101267D0; // weak
int dword_1012BFD0; // weak
int dword_1012BFD4; // weak
int dword_1012BFD8; // weak
int dword_1012BFDC; // weak
_UNKNOWN unk_1012BFE0; // weak
_UNKNOWN unk_1012C00C; // weak
_UNKNOWN unk_1012C038; // weak
_UNKNOWN unk_1012C064; // weak
_UNKNOWN unk_1012C090; // weak
double dbl_1012C0BC; // weak
double dbl_1012C0C4; // weak
double dbl_1012C0CC; // weak
double dbl_1012C0D4; // weak
double dbl_1012C0DC; // weak
int dword_1012C0E4; // weak
int dword_1012C0E8; // weak
double dbl_1012C0EC; // weak
double dbl_1012C0F4; // weak
double dbl_1012C0FC; // weak
double dbl_1012C104; // weak
double dbl_1012C10C; // weak
int dword_1012C114; // weak
int dword_1012C118; // weak
_UNKNOWN unk_1012C11C; // weak
float flt_1012C148[]; // weak
int dword_1012C14C; // weak
int dword_1012C150; // weak
_UNKNOWN unk_1012C154; // weak
_UNKNOWN unk_1012C180; // weak
double dbl_1012C1AC; // weak
double dbl_1012C1B4; // weak
double dbl_1012C1BC; // weak
double dbl_1012C1C4; // weak
double dbl_1012C1CC; // weak
int dword_1012C1D4; // weak
int dword_1012C1D8; // weak
_UNKNOWN unk_1012C1DC; // weak
_UNKNOWN unk_1012C208; // weak
_UNKNOWN unk_1012C234; // weak
_UNKNOWN unk_1012C260; // weak
_UNKNOWN unk_1012C28C; // weak
_UNKNOWN unk_1012C2B8; // weak
_UNKNOWN unk_1012C2E4; // weak
_UNKNOWN unk_1012C310; // weak
_UNKNOWN unk_1012C33C; // weak
double dbl_1012C368; // weak
double dbl_1012C370; // weak
double dbl_1012C378; // weak
double dbl_1012C380; // weak
double dbl_1012C388; // weak
int dword_1012C390; // weak
int dword_1012C394; // weak
_UNKNOWN unk_1012C398; // weak
double dbl_1012C3C4; // weak
double dbl_1012C3CC; // weak
double dbl_1012C3D4; // weak
double dbl_1012C3DC; // weak
double dbl_1012C3E4; // weak
int dword_1012C3EC; // weak
int dword_1012C3F0; // weak
double dbl_1012C3F4; // weak
double dbl_1012C3FC; // weak
double dbl_1012C404; // weak
double dbl_1012C40C; // weak
double dbl_1012C414; // weak
int dword_1012C41C; // weak
int dword_1012C420; // weak
_UNKNOWN unk_1012C424; // weak
_UNKNOWN unk_1012C450; // weak
_UNKNOWN unk_1012C47C; // weak
double dbl_1012C4A8; // weak
double dbl_1012C4B0; // weak
double dbl_1012C4B8; // weak
double dbl_1012C4C0; // weak
double dbl_1012C4C8; // weak
int dword_1012C4D0; // weak
int dword_1012C4D4; // weak
double dbl_1012C4D8; // weak
double dbl_1012C4E0; // weak
double dbl_1012C4E8; // weak
double dbl_1012C4F0; // weak
double dbl_1012C4F8; // weak
int dword_1012C500; // weak
int dword_1012C504; // weak
double dbl_1012C508; // weak
double dbl_1012C510; // weak
double dbl_1012C518; // weak
double dbl_1012C520; // weak
double dbl_1012C528; // weak
int dword_1012C530; // weak
int dword_1012C534; // weak
_UNKNOWN unk_1012C538; // weak
char byte_1012C564; // weak
_UNKNOWN unk_1012C568; // weak
_UNKNOWN unk_1012C594; // weak
_UNKNOWN unk_1012C5C0; // weak
_UNKNOWN unk_1012C5EC; // weak
_UNKNOWN unk_1012C618; // weak
_UNKNOWN unk_1012C644; // weak
_UNKNOWN unk_1012C670; // weak
_UNKNOWN unk_1012C69C; // weak
double dbl_1012C6C8; // weak
double dbl_1012C6D0; // weak
double dbl_1012C6D8; // weak
double dbl_1012C6E0; // weak
double dbl_1012C6E8; // weak
int dword_1012C6F0; // weak
int dword_1012C6F4; // weak
_UNKNOWN unk_1012C6F8; // weak
int dword_1012C724; // weak
_UNKNOWN unk_1012C728; // weak
_UNKNOWN unk_1012C754; // weak
_UNKNOWN unk_1012C780; // weak
_UNKNOWN unk_1012C7AC; // weak
__int16 word_1012C7D8; // weak
_UNKNOWN unk_1012C7DC; // weak
double dbl_1012C808; // weak
double dbl_1012C810; // weak
double dbl_1012C818; // weak
double dbl_1012C820; // weak
double dbl_1012C828; // weak
int dword_1012C830; // weak
int dword_1012C834; // weak
_UNKNOWN unk_1012C838; // weak
_UNKNOWN unk_1012C864; // weak
_UNKNOWN unk_1012C890; // weak
float flt_1012C8BC[]; // weak
int dword_1012C8C0; // weak
int dword_1012C8C4; // weak
_UNKNOWN unk_1012C8C8; // weak
_UNKNOWN unk_1012C8F4; // weak
_UNKNOWN unk_1012C920; // weak
double dbl_1012C94C; // weak
double dbl_1012C954; // weak
double dbl_1012C95C; // weak
double dbl_1012C964; // weak
double dbl_1012C96C; // weak
int dword_1012C974; // weak
int dword_1012C978; // weak
char byte_1012C97C; // weak
int dword_1012C980; // weak
char byte_1012C988[]; // weak
char byte_1012C992[]; // weak
char byte_1012C99D; // weak
char byte_1012C99E; // weak
char byte_1012C9A0[]; // weak
char byte_1012C9A1[]; // weak
_UNKNOWN unk_1012C9CC; // weak
_UNKNOWN unk_1012C9CD; // weak
int dword_1012CBB8[]; // weak
int dword_1012CC60[]; // weak
int dword_1012CC80[]; // weak
int dword_1012CC84[]; // weak
_UNKNOWN unk_1012CCA8; // weak
_UNKNOWN unk_1012CCA9; // weak
int dword_1012CE44; // weak
int dword_1012CE48; // weak
int dword_1012CE4C; // weak
int dword_1012CE50; // weak
char byte_1012CE54; // weak
char byte_1012CE55; // weak
_BYTE byte_1012D2E8[320]; // idb
_UNKNOWN unk_1012D428; // weak
char byte_1012DEC8[]; // weak
char byte_1012DECA; // weak
char byte_1012DECC[]; // weak
int dword_1012DED0; // weak
char byte_1012DED4[]; // weak
__int16 word_1012DED8; // weak
int dword_1012DEDC; // weak
__int16 word_1012DEE0; // weak
char byte_1012DEE2; // weak
char byte_1012DEE8[100]; // idb
int dword_1012DF4C; // weak
_UNKNOWN unk_1012DF50; // weak
int dword_1012DFE0[]; // weak
int dword_1012DFE4; // weak
int dword_1012DFE8; // weak
void *dword_1012DFF0; // idb
int dword_1012DFF4; // weak
_BYTE byte_1012DFF8[744]; // idb
int dword_1012E2E0; // weak
int dword_1012E2E4; // weak
int dword_1012E2E8; // weak
int dword_1012E2EC; // weak
int dword_1012E2F0; // weak
int dword_1012E2F4; // weak
int dword_1012E2F8; // weak
int dword_1012E2FC; // weak
int dword_1012E300; // weak
int dword_1012E304; // weak
int dword_1012E308; // weak
int dword_1012E30C; // weak
int dword_1012E310; // weak
int dword_1012E314; // weak
int dword_1012E318; // weak
int dword_1012E31C; // weak
int dword_1012E320; // weak
__int16 word_1012E324; // weak
int dword_1012E328; // weak
int dword_1012E32C; // weak
int dword_1012E334; // weak
int dword_1012E338; // weak
__int16 word_1012E340[]; // weak
_UNKNOWN unk_1012E342; // weak
__int16 word_1012E3D8; // weak
_UNKNOWN unk_1012E3DA; // weak
int dword_1012E3DC; // weak
char byte_1012E3E0[]; // weak
__int16 word_1012E3E2[]; // weak
int dword_1012E3E4[]; // weak
int dword_1012E480; // weak
int dword_1012E484; // weak
int dword_1012E488; // weak
char byte_1012E490[]; // weak
__int16 word_1012E492[]; // weak
int dword_1012E494[]; // weak
int dword_1012E7B0; // weak
char byte_1012E7B8; // weak
char byte_1012E7B9; // weak
char byte_1012E7BA; // weak
int dword_1012E7BC; // weak
int dword_1012E7C0; // weak
char byte_1012E7C8; // weak
__int16 word_1012E7CA; // weak
int dword_1012E7CC; // weak
int dword_1012E7D4; // weak
char byte_1012E879; // weak
char byte_1012E87A; // weak
char byte_1012E87B; // weak
int dword_1012E87C; // weak
int dword_1013A83C; // weak
int dword_1013AB5C; // weak
int dword_10140430; // weak
int dword_10140434; // weak
int dword_10140438; // weak
int dword_1014043C; // weak
int dword_101404C4; // weak
int dword_101404C8; // weak
int dword_101404CC; // weak
int dword_101404D0; // weak
char byte_101404D8; // weak
char byte_101404D9; // weak
int dword_101404DC; // weak
int dword_101404E0; // weak
int dword_101404E4; // weak
int dword_101404E8; // weak
int dword_101404EC; // weak
char byte_101404F0; // weak
int dword_10145CF4; // weak
int dword_10145CF8; // weak
int dword_10145CFC; // weak
int dword_10145D00; // weak
_UNKNOWN unk_10145D08; // weak
_UNKNOWN unk_101460B0; // weak
_UNKNOWN unk_101460B4; // weak
_UNKNOWN unk_101460D0; // weak
_UNKNOWN unk_101462D2; // weak
_UNKNOWN unk_101462D3; // weak
_UNKNOWN unk_101462D4; // weak
_UNKNOWN unk_101462D8; // weak
_UNKNOWN unk_10148B68; // weak
_UNKNOWN unk_10148C0C; // weak
_UNKNOWN unk_10148C14; // weak
_UNKNOWN unk_10148C18; // weak
_UNKNOWN unk_101492F0; // weak
_UNKNOWN unk_101494F0; // weak
_UNKNOWN unk_10149500; // weak
_UNKNOWN unk_10149620; // weak
_UNKNOWN unk_10149660; // weak
_UNKNOWN unk_10149661; // weak
_UNKNOWN unk_10149677; // weak
_UNKNOWN unk_10149678; // weak
_UNKNOWN unk_10149679; // weak
_UNKNOWN unk_1014967A; // weak
_UNKNOWN unk_1014967C; // weak
_UNKNOWN unk_10149680; // weak
_UNKNOWN unk_10149684; // weak
_UNKNOWN unk_101496A4; // weak
_UNKNOWN unk_101496C4; // weak
_UNKNOWN unk_101496E4; // weak
_UNKNOWN unk_10149704; // weak
_UNKNOWN unk_10149724; // weak
_UNKNOWN unk_10149744; // weak
_UNKNOWN unk_10149764; // weak
_UNKNOWN unk_10149784; // weak
_UNKNOWN unk_101497A4; // weak
_UNKNOWN unk_101497C4; // weak
_UNKNOWN unk_101497E4; // weak
_UNKNOWN unk_10149804; // weak
_UNKNOWN unk_10149824; // weak
_UNKNOWN unk_10149844; // weak
_UNKNOWN unk_10149864; // weak
_UNKNOWN unk_10149884; // weak
_UNKNOWN unk_101498A4; // weak
_UNKNOWN unk_101498C4; // weak
_UNKNOWN unk_101498E4; // weak
_UNKNOWN unk_10149904; // weak
_UNKNOWN unk_10149924; // weak
_UNKNOWN unk_10149944; // weak
_UNKNOWN unk_10149964; // weak
_UNKNOWN unk_10149984; // weak
_UNKNOWN unk_101499A4; // weak
_UNKNOWN unk_101499C4; // weak
_UNKNOWN unk_101499E4; // weak
_UNKNOWN unk_10149A04; // weak
_UNKNOWN unk_10149A08; // weak
_UNKNOWN unk_10149A0C; // weak
_UNKNOWN unk_10149A10; // weak
_UNKNOWN unk_10149A14; // weak
_UNKNOWN unk_10149A18; // weak
_UNKNOWN unk_10149A1C; // weak
_UNKNOWN unk_10149A3C; // weak
_UNKNOWN unk_10149A5C; // weak
_UNKNOWN unk_10149A7C; // weak
_UNKNOWN unk_10149A9C; // weak
_UNKNOWN unk_10149ABC; // weak
_UNKNOWN unk_10149ADC; // weak
_UNKNOWN unk_10149AFC; // weak
_UNKNOWN unk_10149B1C; // weak
_UNKNOWN unk_10149B1D; // weak
_UNKNOWN unk_10149B1E; // weak
_UNKNOWN unk_10149B70; // weak
_UNKNOWN unk_10149B90; // weak
_UNKNOWN unk_10149BB0; // weak
_UNKNOWN unk_10149BB4; // weak
_UNKNOWN unk_10149BB8; // weak
_UNKNOWN unk_10149BBC; // weak
_UNKNOWN unk_10149BDC; // weak
_UNKNOWN unk_10149BFC; // weak
_UNKNOWN unk_10149C1C; // weak
_UNKNOWN unk_10149C3C; // weak
_UNKNOWN unk_10149C5C; // weak
_UNKNOWN unk_10149C7C; // weak
_UNKNOWN unk_10149C9C; // weak
_UNKNOWN unk_10149CBC; // weak
_UNKNOWN unk_10149CDC; // weak
_UNKNOWN unk_10149D24; // weak
_UNKNOWN unk_10149D6C; // weak
_UNKNOWN unk_10149DB4; // weak
_UNKNOWN unk_10149DFC; // weak
_UNKNOWN unk_10149E44; // weak
_UNKNOWN unk_10149E8C; // weak
_UNKNOWN unk_10149ED4; // weak
_UNKNOWN unk_10149F1C; // weak
_UNKNOWN unk_10149F64; // weak
_UNKNOWN unk_10149FAC; // weak
_UNKNOWN unk_10149FF4; // weak
_UNKNOWN unk_1014A03C; // weak
_UNKNOWN unk_1014A084; // weak
_UNKNOWN unk_1014A0CC; // weak
_UNKNOWN unk_1014A114; // weak
_UNKNOWN unk_1014A15C; // weak
_UNKNOWN unk_1014A1A4; // weak
_UNKNOWN unk_1014A1EC; // weak
_UNKNOWN unk_1014A234; // weak
_UNKNOWN unk_1014A27C; // weak
_UNKNOWN unk_1014A2C4; // weak
_UNKNOWN unk_1014A30C; // weak
_UNKNOWN unk_1014A354; // weak
_UNKNOWN unk_1014A39C; // weak
_UNKNOWN unk_1014A3E4; // weak
_UNKNOWN unk_1014A42C; // weak
_UNKNOWN unk_1014A474; // weak
_UNKNOWN unk_1014A4BC; // weak
_UNKNOWN unk_1014A504; // weak
_UNKNOWN unk_1014A54C; // weak
_UNKNOWN unk_1014A564; // weak
_UNKNOWN unk_1014A584; // weak
_UNKNOWN unk_1014A5A4; // weak
_UNKNOWN unk_1014A5A8; // weak
_UNKNOWN unk_1014A64C; // weak
_UNKNOWN unk_1014A6F0; // weak
_UNKNOWN unk_1014A794; // weak
_UNKNOWN unk_1014A838; // weak
_UNKNOWN unk_1014A8DC; // weak
_UNKNOWN unk_1014A980; // weak
_UNKNOWN unk_1014AA24; // weak
_UNKNOWN unk_1014AAC8; // weak
_UNKNOWN unk_1014AB6C; // weak
_UNKNOWN unk_1014AC10; // weak
_UNKNOWN unk_1014ACB4; // weak
_UNKNOWN unk_1014AD58; // weak
_UNKNOWN unk_1014ADFC; // weak
_UNKNOWN unk_1014AEA0; // weak
_UNKNOWN unk_1014AF44; // weak
_UNKNOWN unk_1014AFE8; // weak
_UNKNOWN unk_1014B08C; // weak
_UNKNOWN unk_1014B130; // weak
_UNKNOWN unk_1014B1D4; // weak
_UNKNOWN unk_1014B278; // weak
_UNKNOWN unk_1014B31C; // weak
_UNKNOWN unk_1014B3C0; // weak
_UNKNOWN unk_1014B464; // weak
_UNKNOWN unk_1014B508; // weak
_UNKNOWN unk_1014B5AC; // weak
_UNKNOWN unk_1014B650; // weak
_UNKNOWN unk_1014B6F4; // weak
_UNKNOWN unk_1014B798; // weak
_UNKNOWN unk_1014B83C; // weak
_UNKNOWN unk_1014B8E0; // weak
_UNKNOWN unk_1014B984; // weak
_UNKNOWN unk_1014BA28; // weak
_UNKNOWN unk_1014BACC; // weak
_UNKNOWN unk_1014BB70; // weak
_UNKNOWN unk_1014BC14; // weak
_UNKNOWN unk_1014BCB8; // weak
_UNKNOWN unk_1014BD5C; // weak
_UNKNOWN unk_1014BE00; // weak
_UNKNOWN unk_1014BEA4; // weak
_UNKNOWN unk_1014BF48; // weak
_UNKNOWN unk_1014BFEC; // weak
_UNKNOWN unk_1014C090; // weak
_UNKNOWN unk_1014C134; // weak
_UNKNOWN unk_1014C1D8; // weak
_UNKNOWN unk_1014C27C; // weak
_UNKNOWN unk_1014C320; // weak
_UNKNOWN unk_1014C3C4; // weak
_UNKNOWN unk_1014C468; // weak
_UNKNOWN unk_1014C50C; // weak
_UNKNOWN unk_1014C5B0; // weak
_UNKNOWN unk_1014C654; // weak
_UNKNOWN unk_1014C6F8; // weak
_UNKNOWN unk_1014C79C; // weak
_UNKNOWN unk_1014C840; // weak
_UNKNOWN unk_1014C8E4; // weak
_UNKNOWN unk_1014C988; // weak
_UNKNOWN unk_1014CA2C; // weak
_UNKNOWN unk_1014CAD0; // weak
_UNKNOWN unk_1014CB74; // weak
_UNKNOWN unk_1014CC18; // weak
_UNKNOWN unk_1014CCBC; // weak
_UNKNOWN unk_1014CD60; // weak
_UNKNOWN unk_1014CE04; // weak
_UNKNOWN unk_1014CEA8; // weak
_UNKNOWN unk_1014CF4C; // weak
_UNKNOWN unk_1014CFF0; // weak
_UNKNOWN unk_1014D094; // weak
_UNKNOWN unk_1014D138; // weak
_UNKNOWN unk_1014D1DC; // weak
_UNKNOWN unk_1014D280; // weak
_UNKNOWN unk_1014D324; // weak
_UNKNOWN unk_1014D3C8; // weak
_UNKNOWN unk_1014D46C; // weak
_UNKNOWN unk_1014D510; // weak
_UNKNOWN unk_1014D5B4; // weak
_UNKNOWN unk_1014D658; // weak
_UNKNOWN unk_1014D6FC; // weak
_UNKNOWN unk_1014D7A0; // weak
_UNKNOWN unk_1014D844; // weak
_UNKNOWN unk_1014D8E8; // weak
_UNKNOWN unk_1014D98C; // weak
_UNKNOWN unk_1014DA30; // weak
_UNKNOWN unk_1014DAD4; // weak
_UNKNOWN unk_1014DB78; // weak
_UNKNOWN unk_1014DC1C; // weak
_UNKNOWN unk_1014DCC0; // weak
_UNKNOWN unk_1014DD64; // weak
_UNKNOWN unk_1014DE08; // weak
_UNKNOWN unk_1014DEAC; // weak
_UNKNOWN unk_1014DF50; // weak
_UNKNOWN unk_1014DFF4; // weak
_UNKNOWN unk_1014E098; // weak
_UNKNOWN unk_1014E13C; // weak
_UNKNOWN unk_1014E1E0; // weak
_UNKNOWN unk_1014E284; // weak
_UNKNOWN unk_1014E328; // weak
_UNKNOWN unk_1014E3CC; // weak
_UNKNOWN unk_1014E470; // weak
_UNKNOWN unk_1014E514; // weak
_UNKNOWN unk_1014E5B8; // weak
_UNKNOWN unk_1014E5D8; // weak
_UNKNOWN unk_1014E5F8; // weak
_UNKNOWN unk_1014E618; // weak
_UNKNOWN unk_1014E638; // weak
_UNKNOWN unk_1014E660; // weak
_UNKNOWN unk_1014E67C; // weak
_UNKNOWN unk_1014E698; // weak
_UNKNOWN unk_1014E6B4; // weak
_UNKNOWN unk_1014E6D0; // weak
_UNKNOWN unk_1014E6EC; // weak
_UNKNOWN unk_1014E708; // weak
_UNKNOWN unk_1014E724; // weak
_UNKNOWN unk_1014E740; // weak
_UNKNOWN unk_1014E75C; // weak
_UNKNOWN unk_1014E778; // weak
_UNKNOWN unk_1014E794; // weak
_UNKNOWN unk_1014E7B0; // weak
_UNKNOWN unk_1014E7CC; // weak
_UNKNOWN unk_1014E7E8; // weak
_UNKNOWN unk_1014E804; // weak
_UNKNOWN unk_1014E820; // weak
_UNKNOWN unk_1014E83C; // weak
_UNKNOWN unk_1014E858; // weak
_UNKNOWN unk_1014E874; // weak
_UNKNOWN unk_1014E890; // weak
_UNKNOWN unk_1014E8AC; // weak
_UNKNOWN unk_1014E8C8; // weak
_UNKNOWN unk_1014E8E4; // weak
_UNKNOWN unk_1014E900; // weak
_UNKNOWN unk_1014E91C; // weak
_UNKNOWN unk_1014E938; // weak
_UNKNOWN unk_1014E954; // weak
_UNKNOWN unk_1014E970; // weak
_UNKNOWN unk_1014E98C; // weak
_UNKNOWN unk_1014E9A8; // weak
_UNKNOWN unk_1014E9C4; // weak
_UNKNOWN unk_1014E9E0; // weak
_UNKNOWN unk_1014E9FC; // weak
_UNKNOWN unk_1014EA18; // weak
_UNKNOWN unk_1014EA34; // weak
_UNKNOWN unk_1014EA50; // weak
_UNKNOWN unk_1014EA6C; // weak
_UNKNOWN unk_1014EA88; // weak
_UNKNOWN unk_1014EAA4; // weak
_UNKNOWN unk_1014EAC0; // weak
_UNKNOWN unk_1014EADC; // weak
_UNKNOWN unk_1014EAF8; // weak
_UNKNOWN unk_1014EB14; // weak
_UNKNOWN unk_1014EB30; // weak
_UNKNOWN unk_1014EB4C; // weak
_UNKNOWN unk_1014EB68; // weak
_UNKNOWN unk_1014EB84; // weak
_UNKNOWN unk_1014EBA0; // weak
_UNKNOWN unk_1014EBBC; // weak
_UNKNOWN unk_1014EBD8; // weak
_UNKNOWN unk_1014EBF4; // weak
_UNKNOWN unk_1014EC10; // weak
_UNKNOWN unk_1014EC2C; // weak
_UNKNOWN unk_1014EC48; // weak
_UNKNOWN unk_1014EC64; // weak
_UNKNOWN unk_1014EC80; // weak
_UNKNOWN unk_1014EC9C; // weak
_UNKNOWN unk_1014ECB8; // weak
_UNKNOWN unk_1014ECD4; // weak
_UNKNOWN unk_1014ECF0; // weak
_UNKNOWN unk_1014ED0C; // weak
_UNKNOWN unk_1014ED28; // weak
_UNKNOWN unk_1014ED44; // weak
_UNKNOWN unk_1014ED60; // weak
_UNKNOWN unk_1014ED7C; // weak
_UNKNOWN unk_1014ED98; // weak
_UNKNOWN unk_1014EDB4; // weak
_UNKNOWN unk_1014EDD0; // weak
_UNKNOWN unk_1014EDEC; // weak
_UNKNOWN unk_1014EE08; // weak
_UNKNOWN unk_1014EE24; // weak
_UNKNOWN unk_1014EE40; // weak
_UNKNOWN unk_1014EE5C; // weak
_UNKNOWN unk_1014EE78; // weak
_UNKNOWN unk_1014EE94; // weak
_UNKNOWN unk_1014EEB0; // weak
_UNKNOWN unk_1014EECC; // weak
_UNKNOWN unk_1014EEE8; // weak
_UNKNOWN unk_1014EF04; // weak
_UNKNOWN unk_1014EF20; // weak
_UNKNOWN unk_1014EF3C; // weak
_UNKNOWN unk_1014EF58; // weak
_UNKNOWN unk_1014EF74; // weak
_UNKNOWN unk_1014EF90; // weak
_UNKNOWN unk_1014EFAC; // weak
_UNKNOWN unk_1014EFC8; // weak
_UNKNOWN unk_1014EFE4; // weak
_UNKNOWN unk_1014F000; // weak
_UNKNOWN unk_1014F01C; // weak
_UNKNOWN unk_1014F038; // weak
_UNKNOWN unk_1014F054; // weak
_UNKNOWN unk_1014F070; // weak
_UNKNOWN unk_1014F08C; // weak
_UNKNOWN unk_1014F0A8; // weak
_UNKNOWN unk_1014F0C4; // weak
_UNKNOWN unk_1014F0E0; // weak
_UNKNOWN unk_1014F0FC; // weak
_UNKNOWN unk_1014F118; // weak
_UNKNOWN unk_1014F134; // weak
_UNKNOWN unk_1014F150; // weak
_UNKNOWN unk_1014F154; // weak
_UNKNOWN unk_1014F158; // weak
_UNKNOWN unk_1014F15C; // weak
_UNKNOWN unk_1014F160; // weak
_UNKNOWN unk_1014F164; // weak
_UNKNOWN unk_1014F168; // weak
_UNKNOWN unk_1014F16C; // weak
_UNKNOWN unk_1014F170; // weak
_UNKNOWN unk_1014F174; // weak
_UNKNOWN unk_1014F178; // weak
_UNKNOWN unk_1014F17C; // weak
_UNKNOWN unk_1014F180; // weak
_UNKNOWN unk_1014F184; // weak
_UNKNOWN unk_1014F188; // weak
_UNKNOWN unk_1014F18C; // weak
_UNKNOWN unk_1014F190; // weak
_UNKNOWN unk_1014F194; // weak
_UNKNOWN unk_1014F198; // weak
_UNKNOWN unk_1014F27C; // weak
_UNKNOWN unk_1015043C; // weak
_UNKNOWN unk_10150440; // weak
_UNKNOWN unk_10150468; // weak
_UNKNOWN unk_10150490; // weak
_UNKNOWN unk_101504D0; // weak
_UNKNOWN unk_10150550; // weak
_UNKNOWN unk_10150554; // weak
_UNKNOWN unk_10150558; // weak
_UNKNOWN unk_1015055A; // weak
_UNKNOWN unk_1015055C; // weak
_UNKNOWN unk_1015055D; // weak
_UNKNOWN unk_1015055E; // weak
_UNKNOWN unk_10150560; // weak
_UNKNOWN unk_101505C4; // weak
_UNKNOWN unk_101505CC; // weak
_UNKNOWN unk_101505D4; // weak
_UNKNOWN unk_101505DC; // weak
_UNKNOWN unk_101505E4; // weak
_UNKNOWN unk_101505EC; // weak
_UNKNOWN unk_101505F4; // weak
_UNKNOWN unk_101505FC; // weak
_UNKNOWN unk_10150604; // weak
_UNKNOWN unk_1015060C; // weak
_UNKNOWN unk_10150614; // weak
_UNKNOWN unk_1015061C; // weak
_UNKNOWN unk_10150624; // weak
_UNKNOWN unk_1015062C; // weak
_UNKNOWN unk_10150634; // weak
_UNKNOWN unk_1015063C; // weak
_UNKNOWN unk_10150644; // weak
_UNKNOWN unk_1015064C; // weak
_UNKNOWN unk_10150654; // weak
_UNKNOWN unk_1015065C; // weak
_UNKNOWN unk_10150664; // weak
_UNKNOWN unk_1015066C; // weak
_UNKNOWN unk_10150674; // weak
_UNKNOWN unk_1015067C; // weak
_UNKNOWN unk_10150684; // weak
_UNKNOWN unk_1015068C; // weak
_UNKNOWN unk_10150694; // weak
_UNKNOWN unk_1015069C; // weak
_UNKNOWN unk_101506A4; // weak
_UNKNOWN unk_101506AC; // weak
_UNKNOWN unk_101506B4; // weak
_UNKNOWN unk_101506BC; // weak
_UNKNOWN unk_101506C4; // weak
_UNKNOWN unk_101506CC; // weak
_UNKNOWN unk_101506D4; // weak
_UNKNOWN unk_101506DC; // weak
_UNKNOWN unk_101506E4; // weak
_UNKNOWN unk_101506EC; // weak
_UNKNOWN unk_101506F4; // weak
_UNKNOWN unk_101506FC; // weak
_UNKNOWN unk_101508E4; // weak
_UNKNOWN unk_101508F4; // weak
_UNKNOWN unk_10150904; // weak
_UNKNOWN unk_10150914; // weak
_UNKNOWN unk_10150915; // weak
_UNKNOWN unk_10150916; // weak
_UNKNOWN unk_10150918; // weak
_UNKNOWN unk_1015091C; // weak
_UNKNOWN unk_101509C4; // weak
_UNKNOWN unk_101509C8; // weak
_UNKNOWN unk_101509CC; // weak
_UNKNOWN unk_10150A1C; // weak
_UNKNOWN unk_10150A20; // weak
_UNKNOWN unk_10150A24; // weak
_UNKNOWN unk_10150B14; // weak
_UNKNOWN unk_10150C04; // weak
_UNKNOWN unk_10150C08; // weak
_UNKNOWN unk_10150C10; // weak
_UNKNOWN unk_10150C18; // weak
_UNKNOWN unk_10150C20; // weak
_UNKNOWN unk_10150C28; // weak
_UNKNOWN unk_10150C30; // weak
_UNKNOWN unk_10150C38; // weak
_UNKNOWN unk_10150C40; // weak
_UNKNOWN unk_10150C48; // weak
_UNKNOWN unk_10150C50; // weak
_UNKNOWN unk_10150C58; // weak
_UNKNOWN unk_10150C60; // weak
_UNKNOWN unk_10150C64; // weak
_UNKNOWN unk_10150C68; // weak
_UNKNOWN unk_10150C6C; // weak
_UNKNOWN unk_10150CC0; // weak
_UNKNOWN unk_10150D14; // weak
_UNKNOWN unk_10150D1C; // weak
_UNKNOWN unk_10150D20; // weak
_UNKNOWN unk_10150D24; // weak
_UNKNOWN unk_10150D28; // weak
_UNKNOWN unk_10150D2C; // weak
_UNKNOWN unk_10150F34; // weak
_UNKNOWN unk_10151094; // weak
_UNKNOWN unk_101510AC; // weak
_UNKNOWN unk_101510C4; // weak
_UNKNOWN unk_101510CE; // weak
_UNKNOWN unk_101510D0; // weak
_UNKNOWN unk_101510E0; // weak
_UNKNOWN unk_101510E4; // weak
_UNKNOWN unk_101510E8; // weak
_UNKNOWN unk_101510EC; // weak
_UNKNOWN unk_101510ED; // weak
_UNKNOWN unk_101510F0; // weak
_UNKNOWN unk_10151140; // weak
_UNKNOWN unk_10151144; // weak
_UNKNOWN unk_10151145; // weak
_UNKNOWN unk_10151146; // weak
_UNKNOWN unk_10151147; // weak
_UNKNOWN unk_1015115B; // weak
_UNKNOWN unk_1015115C; // weak
_UNKNOWN unk_1015115D; // weak
_UNKNOWN unk_1015115E; // weak
_UNKNOWN unk_10151160; // weak
_UNKNOWN unk_10151200; // weak
_UNKNOWN unk_10151250; // weak
_UNKNOWN unk_10151254; // weak
_UNKNOWN unk_10151258; // weak
_UNKNOWN unk_1015125C; // weak
_UNKNOWN unk_10151260; // weak
_UNKNOWN unk_10151264; // weak
_UNKNOWN unk_10151268; // weak
_UNKNOWN unk_1015126C; // weak
_UNKNOWN unk_10151270; // weak
_UNKNOWN unk_10151274; // weak
_UNKNOWN unk_10151278; // weak
_UNKNOWN unk_1015127C; // weak
_UNKNOWN unk_10151280; // weak
_UNKNOWN unk_101513C0; // weak
_UNKNOWN unk_101513CC; // weak
_UNKNOWN unk_10151414; // weak
_UNKNOWN unk_10151415; // weak
_UNKNOWN unk_10151440; // weak
_UNKNOWN unk_10151470; // weak
_UNKNOWN unk_10151498; // weak
_UNKNOWN unk_1015149C; // weak
_UNKNOWN unk_101514A0; // weak
_UNKNOWN unk_101514A4; // weak
_UNKNOWN unk_101514D4; // weak
_UNKNOWN unk_101514D5; // weak
_UNKNOWN unk_101514D6; // weak
_UNKNOWN unk_101514D8; // weak
_UNKNOWN unk_101514DC; // weak
_UNKNOWN unk_101514E0; // weak
_UNKNOWN unk_101514E4; // weak
_UNKNOWN unk_101514E8; // weak
_UNKNOWN unk_101514EC; // weak
_UNKNOWN unk_101514F0; // weak
_UNKNOWN unk_101514F4; // weak
_UNKNOWN unk_101514F8; // weak
_UNKNOWN unk_101514FC; // weak
_UNKNOWN unk_1015185C; // weak
_UNKNOWN unk_10151860; // weak
_UNKNOWN unk_1015186A; // weak
_UNKNOWN unk_10151874; // weak
_UNKNOWN unk_10153030; // weak
_UNKNOWN unk_101530A0; // weak
_UNKNOWN unk_101530C0; // weak
_UNKNOWN unk_10153200; // weak
_UNKNOWN unk_10153470; // weak
_UNKNOWN unk_101534A0; // weak
_UNKNOWN unk_10154C14; // weak
_UNKNOWN unk_10154C18; // weak
_UNKNOWN unk_10154D20; // weak
_UNKNOWN unk_10154F28; // weak
_UNKNOWN unk_10186AFC; // weak
float flt_10186B30; // weak
float flt_10186B34; // weak
int dword_10186B38; // weak
int dword_10186B40; // weak
char byte_10186B48[]; // weak
char byte_10186B4C[]; // weak
char byte_10186B4D[]; // weak
int dword_10186B54[]; // weak
int dword_10186B5C[]; // weak
int dword_10186B90; // weak
char byte_10186B94; // weak
int dword_10186B98; // weak
char byte_10186B9C; // weak
char byte_10186B9D; // weak
char byte_10186BA0[104]; // idb
char byte_10186C08[]; // weak
char byte_10186C09[]; // weak
__int16 word_10186C0A; // weak
__int16 word_10186C0C; // weak
int dword_10186C10; // weak
char byte_10186C14[]; // weak
char byte_10186C18[]; // weak
char byte_10186C1C[]; // weak
char byte_10186C20[]; // weak
int dword_10186C24; // weak
int dword_10186C28; // weak
__int16 word_10186C2C; // weak
_UNKNOWN unk_10186C2E; // weak
char byte_10186C43[]; // weak
int dword_10186C44; // weak
char byte_1019E308[]; // weak
int dword_101A0A18[]; // weak
int dword_101A0A1C[]; // weak
_UNKNOWN unk_101B4298; // weak
_UNKNOWN unk_101B8120; // weak
_UNKNOWN unk_101B8122; // weak
_UNKNOWN unk_101B8141; // weak
_UNKNOWN unk_101B8174; // weak
_UNKNOWN unk_101B8189; // weak
char byte_101B819E[]; // weak
char byte_101B819F[]; // weak
int dword_101B81A0[]; // weak
__int16 word_101B81A4[]; // weak
char byte_101B81A6[]; // weak
char byte_101B81A7[]; // weak
char byte_101B81A8[]; // weak
char byte_101B81A9[]; // weak
__int16 word_101B81AA[]; // weak
int dword_101B81AC[]; // weak
int dword_101B81B0[]; // weak
__int16 word_101B81B4[]; // weak
int dword_101B81B8[]; // weak
__int16 word_101B81BC[]; // weak
char byte_101DF220[]; // weak
_UNKNOWN unk_101DF280; // weak
_UNKNOWN unk_101E5048; // weak
char byte_101E6948; // weak
char byte_101E694C; // weak
int dword_101E6950; // weak
int dword_101E6954; // weak
int dword_101E6958; // weak
__int16 word_101E695C; // weak
int dword_101E6960; // weak
int dword_101E6964; // weak
int dword_101E6968; // weak
int dword_101E696C; // weak
__int16 word_101E6970; // weak
__int16 word_101E6974; // weak
char byte_101E6976[]; // weak
int dword_101E6980; // weak
_UNKNOWN unk_101E6988; // weak
char byte_101E6C60[]; // weak
char byte_101E6C61[]; // weak
char byte_101E6C80[]; // weak
char byte_101E6C81[]; // weak
_UNKNOWN unk_101E7EC8; // weak
char byte_101E8238[]; // weak
char byte_101E8239[]; // weak
_UNKNOWN unk_101E9878; // weak
char byte_101E9879[]; // weak
char byte_101E9C84[]; // weak
int dword_101E9C88[]; // weak
char byte_101E9C94[]; // weak
char byte_101E9C95[]; // weak
char byte_101E9C96[]; // weak
_BYTE byte_101E9C97[3121]; // idb
__int16 word_101EA8C8; // weak
int dword_101EA8D0[]; // weak
char byte_101EA8E8[254]; // idb
char byte_101EA9E6[]; // weak
char byte_101EA9E7[]; // weak
_UNKNOWN unk_101EACD8; // weak
char byte_101EADE8[2800]; // idb
char byte_101EB8D8[1022]; // idb
char byte_101EBCD6[]; // weak
char byte_101EBCD7[]; // weak
char byte_101EBCD8[1022]; // idb
char byte_101EC0D6[]; // weak
char byte_101EC0D7[]; // weak
char byte_101EC0D8[1022]; // idb
char byte_101EC4D6[]; // weak
char byte_101EC4D7[]; // weak
int dword_101EF4D8[]; // weak
int dword_101EF4EC[]; // weak
char byte_101EF500[2800]; // idb
char byte_101EFFF0[2800]; // idb
char byte_101F0AE0[2800]; // idb
int dword_101F15D0[]; // weak
int dword_101F15E4[]; // weak
char byte_101F15F8[2796]; // idb
char byte_101F20E4[]; // weak
char byte_101F20E8[559]; // idb
char byte_101F2317[]; // weak
int dword_101F2BD8[]; // weak
int dword_101F2BEC[]; // weak
char byte_101F2C00[2800]; // idb
__int16 word_101F36F0[]; // weak
char byte_101F36F2[]; // weak
__int16 word_101F36F4; // weak
char byte_101F36F6; // weak
char byte_101F6AC0[]; // weak
char byte_101F6AC1[]; // weak
_UNKNOWN unk_101F6B60; // weak
int dword_101F6E30[]; // weak
int dword_101F6E34[]; // weak
_UNKNOWN unk_101F7350; // weak
_UNKNOWN unk_101FA258; // weak
_UNKNOWN unk_101FA758; // weak
_UNKNOWN unk_101FA800; // weak
char byte_101FA820; // weak
char byte_101FA821; // weak
char byte_101FA822; // weak
char byte_101FA823; // weak
_UNKNOWN unk_101FA828; // weak
_UNKNOWN unk_101FA848; // weak
int dword_101FA868; // weak
_UNKNOWN unk_101FA870; // weak
char byte_101FBDB0[]; // weak
char byte_101FBDBA[]; // weak
_UNKNOWN unk_101FBDC9; // weak
_UNKNOWN unk_101FBDF1; // weak
_UNKNOWN unk_101FBDF6; // weak
_UNKNOWN unk_101FBFE2; // weak
_UNKNOWN unk_101FC089; // weak
_UNKNOWN unk_101FC08A; // weak
_UNKNOWN unk_101FC0A9; // weak
_UNKNOWN unk_101FC0D0; // weak
_UNKNOWN unk_101FC0D1; // weak
_UNKNOWN unk_101FC0F0; // weak
char byte_101FC27C; // weak
__int16 word_101FC850[]; // weak
__int16 word_101FC852[]; // weak
__int16 word_101FC854[]; // weak
__int16 word_101FC856[]; // weak
__int16 word_101FC858[]; // weak
__int16 word_101FD020[]; // weak
__int16 word_101FD022[]; // weak
__int16 word_101FD024[]; // weak
__int16 word_101FD026[]; // weak
__int16 word_101FD028[]; // weak
_UNKNOWN unk_101FD7F0; // weak
_UNKNOWN unk_101FD87A; // weak
_UNKNOWN unk_10201678; // weak
_UNKNOWN unk_10201679; // weak
_UNKNOWN unk_102016FA; // weak
_UNKNOWN unk_10201715; // weak
_UNKNOWN unk_1020171A; // weak
_UNKNOWN unk_102019E9; // weak
_UNKNOWN unk_102019EA; // weak
_UNKNOWN unk_10201A69; // weak
char byte_10201F10; // idb
int dword_10202010; // weak
char byte_10202014; // weak
char byte_10202015; // weak
int dword_10202028[]; // weak
int dword_1020202C; // weak
int dword_10202030; // weak
int dword_10202034; // weak
int dword_10202038; // weak
int dword_1020203C[]; // weak
int dword_10202040; // weak
int dword_10202044; // weak
int dword_10202048; // weak
int dword_1020204C; // weak
_UNKNOWN unk_10202050; // weak
int dword_10202168; // weak
_UNKNOWN unk_10202170; // weak
_UNKNOWN unk_10202CC8; // weak
int dword_10205030; // weak
char byte_10205038[]; // weak
char byte_10205088[]; // weak
int dword_1020CA78[]; // weak
int dword_1020CA7C[]; // weak
int dword_1020CA80[]; // weak
int dword_1020CA84[]; // weak
int dword_1020CA88[]; // weak
int dword_1020CA8C[]; // weak
int dword_1020CA90[]; // weak
int dword_1020CA94[]; // weak
int dword_1020CA98[]; // weak
int dword_1020CA9C[]; // weak
int dword_1020CAA0[]; // weak
int dword_1020CAA4[]; // weak
int dword_1020CAA8[]; // weak
int dword_1020CAD4; // weak
int dword_1020CAD8; // weak
int dword_1020CADC; // weak
int dword_1020CAE0; // weak
int dword_1020CAE4; // weak
int dword_1020CAE8; // weak
int dword_1020CAEC; // weak
int dword_1020CAF0; // weak
int dword_1020CAF4; // weak
int dword_1020CAF8; // weak
_UNKNOWN unk_1021A2C8; // weak
_UNKNOWN unk_1021FAC8; // weak
char byte_102252C8[]; // weak
__int16 word_102252CA[]; // weak
_UNKNOWN unk_10226BC8; // weak
int dword_10226BE8; // weak
char byte_10226BF2; // weak
_UNKNOWN unk_10226C04; // weak
__int16 word_10226CE8[]; // weak
__int16 word_10226CEA[]; // weak
__int16 word_10226CEC[]; // weak
char byte_10226CEE[]; // weak
__int16 word_10228C28[]; // weak
__int16 word_10228CC4[]; // weak
_DWORD dword_1022CAB0[16]; // idb
int dword_1022CAF0[]; // weak
int dword_1022CB30; // weak
int dword_1022CB38[]; // weak
int dword_1022CBA8; // weak
int dword_1022CED4; // weak
int dword_1022CEDC; // weak
int dword_1022CEE8; // weak
int dword_1022D510; // weak
int dword_1022D51C; // weak
int dword_1022D528; // weak
int dword_1022D52C; // weak
int dword_1022D530; // weak
int dword_1022D54C; // weak
int dword_1022D550; // weak
int dword_1022D554; // weak
int dword_1022D558; // weak
int dword_1022D55C; // weak
_UNKNOWN unk_1022D620; // weak
void *dword_1022D6E8; // idb
_UNKNOWN unk_1022D700; // weak
_UNKNOWN unk_10232F40; // weak
_UNKNOWN unk_10233400; // weak
int dword_102362B8; // weak
_UNKNOWN unk_102362C0; // weak
__int16 word_102364C0; // weak
int dword_102364C4; // weak
int dword_102364E0; // weak
int dword_102364E4; // weak
int dword_102364E8; // weak
int dword_102364EC; // weak
int dword_102364F0; // weak
int dword_102364F4; // weak
char byte_10236500; // weak
char byte_10236501; // weak
char byte_10236502; // weak
char byte_10236503; // weak
int dword_10236504; // weak
int dword_1023650C; // weak
int dword_10236510; // weak
int dword_10236514; // weak
int dword_10236518; // weak
int dword_1023651C; // weak
int dword_10236520; // weak
int dword_10236524; // weak
int dword_10236528; // weak
int dword_1023652C; // weak
int dword_10236530; // weak
int dword_10236534; // weak
int dword_10236538; // weak
int dword_1023653C; // weak
int dword_10236540; // weak
int dword_10236544; // weak
int dword_10236548; // weak
int dword_1023654C; // weak
int dword_10236550; // weak
int dword_10236554; // weak
_UNKNOWN unk_10236560; // weak
int dword_10236820; // weak
int dword_10236824; // weak
char byte_10236828; // weak
char byte_10236830; // weak
int dword_10236838; // weak
int dword_1023683C; // weak
int dword_10236840; // weak
int dword_10236850; // weak
int dword_10236854; // weak
int dword_10236858; // weak
int dword_1023685C; // weak
int dword_10236860; // weak
int dword_10236864; // weak
void *dword_10236880; // idb
int dword_102378A0; // weak
int dword_102378A4; // weak
UINT uNumber; // idb
int dword_102378C0[]; // weak
int dword_102379C0; // weak
int dword_102379D8; // weak


//----- (10001000) --------------------------------------------------------
int sub_10001000()
{
  flt_1011278C = 0.0;
  word_10112784 = 17219;
  word_10112790 = 2827;
  return sub_1004E590(27, 16);
}
// 10112784: using guessed type __int16 word_10112784;
// 1011278C: using guessed type float flt_1011278C;
// 10112790: using guessed type __int16 word_10112790;

//----- (10001030) --------------------------------------------------------
char __usercall sub_10001030@<al>(char a1@<al>, int a2@<ecx>)
{
  char result; // al@7
  bool v3; // zf@9
  int v4; // [sp-2h] [bp-4h]@1

  v4 = a2;
  BYTE3(v4) = 1;
  if ( byte_10112792 == 2 )
    return 1;
  if ( (unsigned __int8)a2 >= 0x43u )
  {
    if ( a1 != 5 && a1 != 6 && a1 != 9 && a1 != 10 )
      return 0;
    return 1;
  }
  v3 = sub_10008340(a2, (_BYTE *)&v4 + 3) == 1;
  result = 1;
  if ( v3 )
    result = BYTE3(v4);
  return result;
}
// 10112792: using guessed type char byte_10112792;

//----- (10001080) --------------------------------------------------------
void sub_10001080()
{
  char v0; // al@3
  double v1; // st6@15
  float v2; // [sp+0h] [bp-8h]@1
  float v3; // [sp+4h] [bp-4h]@1

  sub_10018F20((bool *)&v2);
  if ( sub_10018E20(&v3) )
  {
    if ( !byte_10236828 )
    {
      if ( flt_10112780 <= (double)flt_1011278C )
      {
        v1 = v3;
      }
      else
      {
        v1 = v3;
        if ( v3 >= (double)flt_10112780 )
        {
          sub_1000A0C0(0.0);
          flt_1011278C = v3;
          return;
        }
      }
      if ( flt_10112788 < (double)flt_1011278C && v1 <= flt_10112788 )
      {
        sub_1000A0C0(COERCE_FLOAT(1));
        flt_1011278C = v3;
        return;
      }
      goto LABEL_21;
    }
    v0 = LOBYTE(v2);
    if ( byte_10112786 == LOBYTE(v2) )
    {
      if ( !byte_10112793 )
      {
LABEL_21:
        flt_1011278C = v3;
        return;
      }
    }
    else
    {
      byte_10112786 = LOBYTE(v2);
      dword_10112794 = sub_1004E4B0();
      v0 = LOBYTE(v2);
      byte_10112793 = 1;
    }
    if ( v0 )
    {
      if ( sub_1004E4B0() > (unsigned int)(dword_10112794 + 1000 * dword_10236824) )
      {
        byte_10112793 = 0;
        sub_1000A0C0(v2);
        flt_1011278C = v3;
        return;
      }
      v0 = LOBYTE(v2);
    }
    if ( byte_10112793 && !v0 && sub_1004E4B0() > (unsigned int)(dword_10112794 + 1000 * dword_10236820) )
    {
      byte_10112793 = 0;
      sub_1000A0C0(v2);
      flt_1011278C = v3;
      return;
    }
    goto LABEL_21;
  }
}
// 10112780: using guessed type float flt_10112780;
// 10112786: using guessed type char byte_10112786;
// 10112788: using guessed type float flt_10112788;
// 1011278C: using guessed type float flt_1011278C;
// 10112793: using guessed type char byte_10112793;
// 10112794: using guessed type int dword_10112794;
// 10236820: using guessed type int dword_10236820;
// 10236824: using guessed type int dword_10236824;
// 10236828: using guessed type char byte_10236828;

//----- (10001200) --------------------------------------------------------
char __thiscall sub_10001200(void *this)
{
  char result; // al@1
  void *v2; // ecx@1
  void *v3; // ecx@2
  char v4; // al@3
  signed int v5; // ebx@3
  int *v6; // esi@3
  int v7; // [sp+0h] [bp-1Ch]@1
  int v8; // [sp+4h] [bp-18h]@1
  int v9; // [sp+8h] [bp-14h]@1
  int v10; // [sp+Ch] [bp-10h]@1
  int v11; // [sp+10h] [bp-Ch]@1
  int v12; // [sp+14h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  result = sub_10019D90(this);
  if ( result == 1 )
  {
    result = sub_10019D90(v2);
    if ( result == 1 )
    {
      v4 = sub_10019900(v3);
      sub_10019260(v4, (int)&v7);
      v5 = 0;
      v6 = &v8;
      do
      {
        result = sub_10007E70((unsigned __int8)v5++, (int)v6, v7);
        ++v6;
      }
      while ( v5 <= 1 );
    }
  }
  return result;
}

//----- (10001290) --------------------------------------------------------
char __thiscall sub_10001290(void *this)
{
  void *v1; // ecx@1
  char v2; // bl@1
  void *v3; // ecx@1
  signed int v4; // esi@1
  char v5; // al@2
  char result; // al@4
  char v7; // [sp+Bh] [bp-Dh]@1
  float v8; // [sp+Ch] [bp-Ch]@1
  int v9; // [sp+10h] [bp-8h]@1
  int v10; // [sp+14h] [bp-4h]@2

  byte_10112792 = sub_1001A070(this);
  byte_10112787 = sub_10019D90(v1);
  v8 = 513.93005;
  v2 = 0;
  v7 = 0;
  v9 = 0;
  sub_1004E880(6683, &byte_10236828, 1, &v7);
  sub_1004E880(6270, &flt_10112780, 4, &v8);
  sub_1004E880(6271, &flt_10112788, 4, &v8);
  sub_1004E880(6682, &dword_10236824, 4, &v9);
  sub_1004E880(6681, &dword_10236820, 4, &v9);
  v4 = 0;
  do
  {
    v5 = sub_10019900(v3);
    sub_10007500(v5, v4, &v10);
    if ( *((_BYTE *)&word_10112790 + v4) != BYTE1(v10) )
    {
      *((_BYTE *)&word_10112790 + v4) = BYTE1(v10);
      v2 = 1;
    }
    result = sub_10019910(*((_BYTE *)&word_10112790 + v4));
    *((_BYTE *)&word_10112784 + v4++) = result;
  }
  while ( v4 < 2 );
  if ( v2 == 1 )
    result = sub_10001200(v3);
  return result;
}
// 10112780: using guessed type float flt_10112780;
// 10112784: using guessed type __int16 word_10112784;
// 10112787: using guessed type char byte_10112787;
// 10112788: using guessed type float flt_10112788;
// 10112790: using guessed type __int16 word_10112790;
// 10112792: using guessed type char byte_10112792;
// 10236820: using guessed type int dword_10236820;
// 10236824: using guessed type int dword_10236824;
// 10236828: using guessed type char byte_10236828;

//----- (10001390) --------------------------------------------------------
void __fastcall sub_10001390(char a1)
{
  signed int v1; // esi@4

  if ( byte_10112792 == 2 )
    sub_10001290((void *)a1);
  if ( byte_10112787 )
  {
    v1 = 0;
    do
    {
      if ( sub_10001030(*((_BYTE *)&word_10112790 + v1), *((_BYTE *)&word_10112784 + v1)) == 1 )
      {
        switch ( *((_BYTE *)&word_10112790 + v1) )
        {
          case 1:
          case 2:
          case 7:
          case 8:
          case 9:
          case 0xA:
            sub_10006B40(*((_BYTE *)&word_10112790 + v1));
            break;
          case 3:
          case 4:
            sub_10006480(*((_BYTE *)&word_10112790 + v1));
            break;
          case 5:
          case 6:
            sub_10005C90(*((_BYTE *)&word_10112790 + v1));
            break;
          default:
            break;
        }
      }
      ++v1;
    }
    while ( v1 < 2 );
  }
}
// 10112784: using guessed type __int16 word_10112784;
// 10112787: using guessed type char byte_10112787;
// 10112790: using guessed type __int16 word_10112790;
// 10112792: using guessed type char byte_10112792;

//----- (10001420) --------------------------------------------------------
void __noreturn sub_10001420()
{
  char v0; // bl@1
  void *v1; // ecx@1
  void *v2; // ecx@1
  char v3; // cl@2
  char v4; // [sp+7h] [bp-5h]@1
  char v5; // [sp+8h] [bp-4h]@1

  v0 = 4;
  v4 = 2;
  byte_10112786 = 1;
  sub_1004E660(&v5);
  sub_10001290(v1);
  sub_10001200(v2);
  while ( 1 )
  {
    do
      sub_1004E660(&v5);
    while ( !(v5 & 1) );
    sub_10001390(v3);
    sub_10001080();
    if ( --v0 <= 0 )
    {
      sub_10009D70(53);
      sub_10009D70(55);
      sub_10009D70(56);
      sub_10009D70(59);
      sub_10009D70(60);
      sub_10009D70(61);
      sub_10009D70(62);
      sub_10009D70(63);
      sub_10009D70(64);
      v0 = 4;
    }
    if ( --v4 <= 0 )
    {
      sub_10009D70(57);
      sub_10009D70(58);
      v4 = 2;
    }
    sub_10009D70(54);
    sub_10009D70(65);
    sub_10009D70(66);
  }
}
// 10112786: using guessed type char byte_10112786;

//----- (10001500) --------------------------------------------------------
#error "10001514: call analysis failed (funcsize=37)"

//----- (10001560) --------------------------------------------------------
char __cdecl sub_10001560(_DWORD *a1)
{
  int v1; // ecx@1
  char result; // al@3
  int v3; // [sp+4h] [bp-4h]@1

  v3 = 0;
  sub_1004E8C0(9210, (int)&v3, 4);
  v1 = v3;
  if ( a1 )
    *a1 = v3;
  result = 1;
  if ( v1 != dword_101127B4 )
    result = 0;
  return result;
}
// 101127B4: using guessed type int dword_101127B4;

//----- (100015A0) --------------------------------------------------------
char __cdecl sub_100015A0(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_acked(a1);
  SYS_exit_krnl();
  return v1;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 100508E2: using guessed type int __cdecl SYS_pvg_alrt_is_acked(_DWORD);

//----- (100015C0) --------------------------------------------------------
char __cdecl sub_100015C0(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_set_queued(a1);
  SYS_exit_krnl();
  return v1;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 100508E8: using guessed type int __cdecl SYS_pvg_alrt_is_set_queued(_DWORD);

//----- (100015E0) --------------------------------------------------------
char __cdecl sub_100015E0(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_viewed(a1);
  SYS_exit_krnl();
  return v1;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 100508EE: using guessed type int __cdecl SYS_pvg_alrt_is_viewed(_DWORD);

//----- (10001600) --------------------------------------------------------
int __cdecl sub_10001600(int a1, int a2, int a3)
{
  SYS_enter_krnl();
  SYS_pvg_alrt_queue(a1, a2, a3);
  return SYS_exit_krnl();
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 100508F4: using guessed type int __cdecl SYS_pvg_alrt_queue(_DWORD, _DWORD, _DWORD);

//----- (10001630) --------------------------------------------------------
int __cdecl sub_10001630(int a1)
{
  if ( !sub_10001560(0) )
    sub_1001B780("..\\lib\\adl\\sys_usr_alrt.c", 1371, 0, "Non-alert master attempted to alter the alert's database");
  SYS_enter_krnl();
  SYS_pvg_alrt_set(a1);
  return SYS_exit_krnl();
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 100508FA: using guessed type int __cdecl SYS_pvg_alrt_set(_DWORD);

//----- (10001670) --------------------------------------------------------
int __cdecl sub_10001670(int a1, int a2)
{
  char *v2; // eax@3
  _BYTE *v3; // edx@3
  char v4; // cl@4
  unsigned int v5; // eax@5
  _BYTE *v6; // edi@5
  char v7; // cl@6
  char *v8; // edi@7
  char *v9; // esi@7
  int v10; // ecx@7
  char *v11; // eax@7
  char v12; // dl@8
  unsigned int v13; // eax@9
  int *v14; // edi@9
  char v15; // cl@10
  char v17; // [sp+10h] [bp-A8h]@1
  _BYTE v18[3]; // [sp+11h] [bp-A7h]@5
  char v19; // [sp+12h] [bp-A6h]@3
  int v20; // [sp+30h] [bp-88h]@9
  char v21; // [sp+31h] [bp-87h]@3

  qmemcpy(&v17, (const void *)a1, 0x9Cu);
  if ( !sub_10001560(0) )
    sub_1001B780("..\\lib\\adl\\sys_usr_alrt.c", 1555, 0, "Non-alert master attempted to alter the alert's database");
  sub_10019E30(a2, (int)&v19, 31);
  sub_10019E30(a2, (int)&v21, 51);
  v2 = (char *)(a1 + 2);
  v3 = (_BYTE *)(a1 + 2);
  do
    v4 = *v2++;
  while ( v4 );
  v5 = v2 - v3;
  v6 = v18;
  do
    v7 = (v6++)[1];
  while ( v7 );
  qmemcpy(v6, v3, 4 * (v5 >> 2));
  v9 = &v3[4 * (v5 >> 2)];
  v8 = &v6[4 * (v5 >> 2)];
  v10 = v5 & 3;
  v11 = (char *)(a1 + 33);
  qmemcpy(v8, v9, v10);
  do
    v12 = *v11++;
  while ( v12 );
  v13 = (unsigned int)&v11[-a1 - 33];
  v14 = &v20;
  do
  {
    v15 = *((_BYTE *)v14 + 1);
    v14 = (int *)((char *)v14 + 1);
  }
  while ( v15 );
  qmemcpy(v14, (const void *)(a1 + 33), v13);
  SYS_enter_krnl();
  SYS_pvg_alrt_set_data(&v17, &a2, 4);
  return SYS_exit_krnl();
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050900: using guessed type int __cdecl SYS_pvg_alrt_set_data(_DWORD, _DWORD, _DWORD);

//----- (10001780) --------------------------------------------------------
int sub_10001780()
{
  if ( !sub_10001560(0) )
    sub_1001B780("..\\lib\\adl\\sys_usr_alrt.c", 1610, 0, "Non-alert master attempted to alter the alert's database");
  SYS_enter_krnl();
  SYS_pvg_alrt_viewed();
  return SYS_exit_krnl();
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050906: using guessed type int SYS_pvg_alrt_viewed(void);

//----- (10001860) --------------------------------------------------------
int __cdecl sub_10001860(int a1, int a2, int a3)
{
  if ( !sub_10001560(0) )
    sub_1001B780("..\\lib\\adl\\sys_usr_alrt.c", 282, 0, "Non-alert master attempted to alter the alert's database");
  SYS_enter_krnl();
  SYS_pvg_alrt_ack(a1, a2, a3);
  return SYS_exit_krnl();
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 1005090C: using guessed type int __cdecl SYS_pvg_alrt_ack(_DWORD, _DWORD, _DWORD);

//----- (100018B0) --------------------------------------------------------
int __cdecl sub_100018B0(int a1)
{
  if ( !sub_10001560(0) )
    sub_1001B780("..\\lib\\adl\\sys_usr_alrt.c", 352, 0, "Non-alert master attempted to alter the alert's database");
  SYS_enter_krnl();
  SYS_pvg_alrt_clr(a1);
  return SYS_exit_krnl();
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050912: using guessed type int __cdecl SYS_pvg_alrt_clr(_DWORD);

//----- (100018F0) --------------------------------------------------------
int __cdecl sub_100018F0(int a1, char a2)
{
  if ( !sub_10001560(0) )
    sub_1001B780("..\\lib\\adl\\sys_usr_alrt.c", 396, 0, "Non-alert master attempted to alter the alert's database");
  SYS_enter_krnl();
  SYS_pvg_alrt_clr_data(a1, &a2, 4);
  return SYS_exit_krnl();
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050918: using guessed type int __cdecl SYS_pvg_alrt_clr_data(_DWORD, _DWORD, _DWORD);

//----- (10001940) --------------------------------------------------------
char **sub_10001940()
{
  return off_10064420;
}
// 10064420: using guessed type char *off_10064420[3];

//----- (10001950) --------------------------------------------------------
char **sub_10001950()
{
  return &off_1006448C;
}
// 1006448C: using guessed type char *off_1006448C;

//----- (10001960) --------------------------------------------------------
char __cdecl sub_10001960(int a1, int a2, int a3, int a4, char a5, char *a6)
{
  char v6; // bl@1
  int v7; // eax@1
  char result; // al@2

  v6 = sub_1001DF90(a1);
  v7 = sub_1001DC80(&a5, 1u, (int)&unk_10065968, 301, 10, 10);
  if ( v7 == 10 )
  {
    result = 0;
  }
  else
  {
    strncpy(a6, &byte_10065969[301 * v7] + 100 * (unsigned __int8)v6, 0x64u);
    result = 1;
  }
  return result;
}

//----- (100019C0) --------------------------------------------------------
char __cdecl sub_100019C0(char a1)
{
  unsigned __int8 v1; // al@1

  byte_10112838 = 0;
  dword_10112878 = 0;
  dword_10112874 = 100;
  memset(&byte_1011283C, 0, 0x38u);
  v1 = sub_1001DF30(a1);
  return sub_1001F3F0(v1);
}
// 10112838: using guessed type char byte_10112838;
// 1011283C: using guessed type char byte_1011283C;
// 10112874: using guessed type int dword_10112874;
// 10112878: using guessed type int dword_10112878;

//----- (10001A00) --------------------------------------------------------
char sub_10001A00()
{
  if ( sub_1004E4B0() - dword_10112878 > (unsigned int)dword_10112874 )
    sub_10008470((unsigned __int8)byte_10112838);
  return 1;
}
// 10112838: using guessed type char byte_10112838;
// 10112874: using guessed type int dword_10112874;
// 10112878: using guessed type int dword_10112878;

//----- (10001A30) --------------------------------------------------------
int __cdecl sub_10001A30(char a1)
{
  void *v1; // ecx@0
  char v2; // ST10_1@1
  char v3; // al@1
  void *v4; // ecx@2
  int result; // eax@5
  signed int v6; // esi@6
  char v7; // [sp+7h] [bp-9h]@2
  char v8; // [sp+8h] [bp-8h]@2
  int v9; // [sp+Ch] [bp-4h]@1

  LOBYTE(v9) = sub_10019900(v1);
  sub_1001FD60(a1, &byte_10112870);
  v2 = byte_10112870;
  v3 = sub_10019900((void *)(unsigned __int8)byte_10112870);
  byte_1011283C = sub_1001FB70(v3, v2);
  if ( byte_1011283C != 2
    && (LOBYTE(v9) = sub_100193D0(v9), v8 = byte_1011283C, sub_1001F5B0(v9, 0, &v8, &v7))
    && v7 == 2 )
  {
    dword_1011286C = sub_1001B4A0(v4);
LABEL_5:
    result = 1;
  }
  else
  {
    v6 = 0;
    do
    {
      byte_1011283C = sub_1001FB70(v6, byte_10112870);
      if ( byte_1011283C != 2 )
      {
        LOBYTE(v9) = sub_100193D0(v6);
        v8 = byte_1011283C;
        if ( sub_1001F5B0(v9, 0, &v8, &v7) )
        {
          if ( v7 == 2 )
          {
            dword_1011286C = sub_100194B0(v6);
            return 1;
          }
        }
      }
      ++v6;
    }
    while ( v6 < 3 );
    result = j_HWM_pvg_read_reg(1);
    if ( result )
      goto LABEL_5;
  }
  return result;
}
// 1004ED00: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1011283C: using guessed type char byte_1011283C;
// 1011286C: using guessed type int dword_1011286C;
// 10112870: using guessed type char byte_10112870;

//----- (10001B50) --------------------------------------------------------
char __usercall sub_10001B50@<al>(char a1@<bl>)
{
  void *v1; // ecx@1
  signed int v3; // [sp-Ch] [bp-40h]@4
  char v4; // [sp+0h] [bp-34h]@1
  char v5; // [sp+1h] [bp-33h]@6
  __int16 v6; // [sp+2h] [bp-32h]@1
  char v7; // [sp+30h] [bp-4h]@1

  memset(&v4, 0, 0x32u);
  LOBYTE(v1) = byte_10112870;
  v4 = 12;
  v6 = 0;
  v7 = byte_10112870;
  if ( a1 == 11 || a1 == 16 )
  {
    if ( sub_1001B4A0(v1) == dword_1011286C )
    {
      v3 = 3074;
      goto LABEL_9;
    }
    if ( dword_1011286C )
    {
      v5 = 2;
      sub_100106F0(6, 231, &v4, 1, 50, 1);
      sub_100108A0(6, 231, dword_1011286C);
      return 1;
    }
  }
  else
  {
    if ( sub_1001B4A0(v1) == dword_1011286C )
    {
      v3 = 3076;
LABEL_9:
      sub_1001FFF0((unsigned __int8)byte_1011283C, v3, 0, 0);
      return 1;
    }
    if ( dword_1011286C )
    {
      v5 = 4;
      sub_100106F0(6, 231, &v4, 1, 50, 1);
      sub_100108A0(6, 231, dword_1011286C);
      return 1;
    }
  }
  return 0;
}
// 1001FFF0: using guessed type _DWORD __cdecl sub_1001FFF0(_DWORD, _DWORD, _DWORD, _DWORD);
// 1011283C: using guessed type char byte_1011283C;
// 1011286C: using guessed type int dword_1011286C;
// 10112870: using guessed type char byte_10112870;

//----- (10001C50) --------------------------------------------------------
char __usercall sub_10001C50@<al>(const void *a1@<eax>, char a2)
{
  void *v2; // ecx@1
  char v3; // bl@1
  char v5; // [sp+Ch] [bp-34h]@1
  char v6; // [sp+Dh] [bp-33h]@4
  __int16 v7; // [sp+Eh] [bp-32h]@4
  char v8; // [sp+10h] [bp-30h]@4
  char v9; // [sp+3Ch] [bp-4h]@4

  qmemcpy(&unk_1011283E, a1, 0x2Cu);
  memset(&v5, 0, 0x32u);
  v3 = sub_10001A30(a2);
  if ( v3 )
  {
    if ( dword_1011286C == sub_1001B4A0(v2) )
    {
      sub_1001FFF0((unsigned __int8)byte_1011283C, 3073, &unk_1011283E, 44);
      return v3;
    }
    v5 = 12;
    v6 = 1;
    v7 = 44;
    v9 = byte_10112870;
    qmemcpy(&v8, &unk_1011283E, 0x2Cu);
    sub_100106F0(6, 231, &v5, 1, 50, 1);
    sub_100108A0(6, 231, dword_1011286C);
  }
  return v3;
}
// 1001FFF0: using guessed type _DWORD __cdecl sub_1001FFF0(_DWORD, _DWORD, _DWORD, _DWORD);
// 1011283C: using guessed type char byte_1011283C;
// 1011286C: using guessed type int dword_1011286C;
// 10112870: using guessed type char byte_10112870;

//----- (10001D20) --------------------------------------------------------
void *__usercall sub_10001D20@<eax>(char a1@<bl>, char a2)
{
  void *result; // eax@2

  sub_10008360();
  if ( (unsigned int)sub_10008320() < 0xA )
  {
    if ( a2 )
    {
      sub_10008470(4);
      byte_10112838 = a1;
      result = (void *)sub_1004E4B0();
      dword_10112878 = (int)result;
      dword_10112874 = 500;
    }
    else
    {
      result = sub_10008470(a1);
    }
  }
  else
  {
    result = sub_10008470(8);
  }
  return result;
}
// 10112838: using guessed type char byte_10112838;
// 10112874: using guessed type int dword_10112874;
// 10112878: using guessed type int dword_10112878;

//----- (10001D80) --------------------------------------------------------
char __usercall sub_10001D80@<al>(void *a1@<ecx>, int a2@<eax>)
{
  char result; // al@3

  a2 = (unsigned __int8)a2;
  if ( (_BYTE)a2 )
  {
    if ( a2 == 1 )
      result = sub_100106F0(6, 316, a1, 0, 4, 1);
    else
      result = sub_100106F0(6, 237, a1, 0, 4, 1);
  }
  else
  {
    result = sub_100106F0(6, 233, a1, 0, 4, 1);
  }
  return result;
}

//----- (10001DD0) --------------------------------------------------------
char __usercall sub_10001DD0@<al>(int a1@<eax>, char a2)
{
  char result; // al@3

  a1 = (unsigned __int8)a1;
  if ( (_BYTE)a1 )
  {
    if ( a1 == 1 )
      result = sub_100106F0(6, 317, &a2, 0, 4, 1);
    else
      result = sub_100106F0(6, 238, &a2, 0, 4, 1);
  }
  else
  {
    result = sub_100106F0(6, 234, &a2, 0, 4, 1);
  }
  return result;
}

//----- (10001E30) --------------------------------------------------------
int __usercall sub_10001E30@<eax>(int a1@<eax>, const void *a2@<ecx>, char a3@<bl>)
{
  const void *v3; // esi@1
  int v4; // ebp@3
  char v6; // [sp+8h] [bp-30h]@6
  int v7; // [sp+34h] [bp-4h]@8

  a1 = (unsigned __int8)a1;
  v3 = a2;
  if ( (_BYTE)a1 )
  {
    if ( a1 == 1 )
      v4 = 6649;
    else
      v4 = 6202;
  }
  else
  {
    v4 = 6201;
  }
  sub_1004E840(v4, (int)&v6, 48);
  if ( a3 == 11 || a3 == 16 )
    qmemcpy(&v6, v3, 0x2Cu);
  else
    v7 = *(_DWORD *)v3;
  return sub_1004E970(v4, (int)&v6, 48);
}

//----- (10001EA0) --------------------------------------------------------
char __cdecl sub_10001EA0(char a1, char a2)
{
  char v2; // al@1
  unsigned __int8 v3; // si@1
  char result; // al@1
  int v5; // eax@4
  int v6; // eax@6
  char *v7; // eax@7
  char v8; // [sp+7h] [bp-35h]@1
  char v9; // [sp+8h] [bp-34h]@1
  char v10; // [sp+Ch] [bp-30h]@7
  char v11; // [sp+10h] [bp-2Ch]@4

  v2 = sub_1001DF90(a1);
  v9 = v2;
  v3 = v2;
  result = sub_10001A30(v2);
  v8 = result;
  if ( result )
  {
    sub_10001B50(a2);
    if ( sub_10008330() == 2 )
    {
      if ( j_HWM_pvg_read_reg(1) == 1 )
      {
        sub_1001F460(v3, &v11);
        LOBYTE(v5) = v9;
        sub_10001D80(&v11, v5);
      }
      sub_10008470(7);
      result = v8;
    }
    else
    {
      v6 = j_HWM_pvg_read_reg(1);
      if ( v6 == 1 )
      {
        LOBYTE(v6) = v9;
        sub_10001D80(&unk_1011283E, v6);
        sub_1001F4A0(v3, &v10);
        v7 = &v10;
        LOBYTE(v7) = v9;
        sub_10001DD0((int)v7, (unsigned int)&v10);
      }
      dword_10112874 = 100;
      if ( sub_10008330() == 5 && sub_100082F0() == 1 || sub_10008330() == 7 )
      {
        sub_10008470(4);
        byte_10112838 = 10;
      }
      else
      {
        sub_10008470(4);
        byte_10112838 = 3;
      }
      dword_10112878 = sub_1004E4B0();
      result = v8;
    }
  }
  return result;
}
// 1004ED00: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10112838: using guessed type char byte_10112838;
// 10112874: using guessed type int dword_10112874;
// 10112878: using guessed type int dword_10112878;

//----- (10001FB0) --------------------------------------------------------
char __cdecl sub_10001FB0(char a1, int a2, int a3, int a4, const void *a5, int a6)
{
  char v6; // si@1
  char result; // al@3
  char v8; // al@5
  char v9; // [sp+Bh] [bp-5h]@1

  v9 = 0;
  v6 = sub_1001DF90(a1);
  sub_1001F3B0(v6);
  sub_1001F3F0(v6);
  if ( v6 == 3 )
  {
    sub_1001B780("..\\lib\\adl\\iop_232_rmt_cnfg.c", 515, 0, 0);
LABEL_3:
    sub_10001D20(1, 1);
    return v9;
  }
  if ( a6 )
  {
    v8 = sub_10001C50(a5, v6);
  }
  else
  {
    sub_1001F460(v6, (char *)&unk_1011283E);
    v8 = sub_10001C50(&unk_1011283E, v6);
  }
  v9 = v8;
  if ( !v8 )
    goto LABEL_3;
  sub_10008470(4);
  byte_10112838 = 2;
  dword_10112878 = sub_1004E4B0();
  result = v9;
  dword_10112874 = 100;
  return result;
}
// 10112838: using guessed type char byte_10112838;
// 10112874: using guessed type int dword_10112874;
// 10112878: using guessed type int dword_10112878;

//----- (10002080) --------------------------------------------------------
char __cdecl sub_10002080(char a1, char a2, char a3)
{
  char v3; // bl@1
  int v4; // eax@2
  char result; // al@7
  char v6; // [sp+Ch] [bp-34h]@1
  char v7; // [sp+10h] [bp-30h]@2
  char v8; // [sp+14h] [bp-2Ch]@3
  char v9; // [sp+4Ch] [bp+Ch]@4

  v3 = a3;
  v6 = sub_1001DF90(a1);
  if ( a3 == 17 )
    LOBYTE(v4) = sub_1001F440(v6, &v7);
  else
    LOBYTE(v4) = sub_1001F420(v6, &v8);
  v9 = v4;
  if ( (_BYTE)v4 )
  {
    LOBYTE(v4) = v6;
    if ( a2 || v3 != 17 )
    {
      sub_10001E30(v4, &v8, v3);
      sub_100083C0(7, a1, 0, 17, 0, 0, 0);
      sub_10008470(2);
      result = v9;
    }
    else
    {
      sub_10001E30(v4, &v7, 17);
      sub_1001F3F0(v6);
      sub_10008470(7);
      result = v9;
    }
  }
  else
  {
    sub_10001D20(2, 0);
    result = v9;
  }
  return result;
}

//----- (10002150) --------------------------------------------------------
char __cdecl sub_10002150(int a1)
{
  char v1; // al@1
  char v2; // bl@1
  bool v3; // zf@1
  char v4; // al@1
  unsigned int v5; // eax@2
  _DWORD *v6; // ecx@2
  char *v7; // edx@2
  int v8; // esi@6
  int v9; // eax@7
  _BYTE *v10; // ecx@7
  _BYTE *v11; // edx@7
  int v12; // eax@9
  _BYTE *v13; // ecx@9
  _BYTE *v14; // edx@9
  _BYTE *v15; // ecx@11
  _BYTE *v16; // edx@11
  signed int v17; // eax@13
  char v19; // [sp+7h] [bp-2Dh]@1
  char v20; // [sp+8h] [bp-2Ch]@1

  memset(&v20, 0, 0x2Cu);
  v1 = sub_1001F570(a1, 0, 11, 0, &v20);
  v2 = v1;
  v3 = v1 == 0;
  v19 = v1;
  v4 = 2;
  if ( v3 )
    goto LABEL_18;
  v5 = 44;
  v6 = &unk_1011283E;
  v7 = &v20;
  do
  {
    if ( *(_DWORD *)v7 != *v6 )
      goto LABEL_6;
    v5 -= 4;
    ++v6;
    v7 += 4;
  }
  while ( v5 >= 4 );
  if ( !v5 )
  {
LABEL_15:
    v17 = 0;
    goto LABEL_16;
  }
LABEL_6:
  v8 = (unsigned __int8)*v7 - *(_BYTE *)v6;
  if ( (unsigned __int8)*v7 == *(_BYTE *)v6 )
  {
    v9 = v5 - 1;
    v10 = (char *)v6 + 1;
    v11 = v7 + 1;
    if ( !v9 )
      goto LABEL_15;
    v8 = *v11 - *v10;
    if ( *v11 == *v10 )
    {
      v12 = v9 - 1;
      v13 = v10 + 1;
      v14 = v11 + 1;
      if ( !v12 )
        goto LABEL_15;
      v8 = *v14 - *v13;
      if ( *v14 == *v13 )
      {
        v15 = v13 + 1;
        v16 = v14 + 1;
        if ( v12 == 1 )
          goto LABEL_15;
        v8 = *v16 - *v15;
        if ( *v16 == *v15 )
          goto LABEL_15;
      }
    }
  }
  v17 = 1;
  if ( v8 <= 0 )
    v17 = -1;
LABEL_16:
  if ( v17 )
  {
    v19 = 0;
    v4 = 1;
LABEL_18:
    sub_10001D20(v4, 0);
    return v19;
  }
  sub_10008470(10);
  return v2;
}

//----- (10002250) --------------------------------------------------------
int __cdecl sub_10002250(unsigned __int8 a1)
{
  int result; // eax@1

  result = a1;
  byte_10112C7C[a1] = 0;
  return result;
}

//----- (10002260) --------------------------------------------------------
int __cdecl sub_10002260(int a1, char a2)
{
  int v2; // esi@4
  int v3; // esi@6

  byte_10112C7C[(unsigned __int8)a1] = 1;
  sub_1001FDB0();
  sub_1001EB50(a1, a2);
  if ( a2 != 18 )
    sub_100019C0(a2);
  byte_10112880[0] = 0;
  byte_10112881 = 0;
  dword_10112C78 = 0;
  LOWORD(dword_10112D04) = 0;
  dword_10112888 = 0;
  if ( a2 == 18 )
  {
    byte_10112D08[(unsigned __int8)a1] = 0;
  }
  else
  {
    byte_10112D08[(unsigned __int8)a1] = 1;
    v2 = 38 * (unsigned __int8)a1;
    dword_10112D14[v2] = sub_1004E4B0() - 100;
    dword_10112D10[v2] = sub_1004E4B0() - 5000;
    dword_10112D18[v2] = sub_1004E4B0() - 250;
    dword_10112D1C[v2] = sub_1004E4B0() - 200;
    dword_10112D20[v2] = sub_1004E4B0() - 2000;
    dword_10112D28[v2] = sub_1004E4B0() - 5000;
    dword_10112D24[v2] = sub_1004E4B0();
  }
  v3 = 38 * (unsigned __int8)a1;
  memset((char *)&unk_10112D30 + 152 * (unsigned __int8)a1, 0, 0x74u);
  byte_10112D2C[v3 * 4] = 0;
  dword_10112DA4[v3] = 0;
  byte_10112884[(unsigned __int8)a1] = 0;
  return j_HWM_pvg_set_uart(a1);
}
// 10112881: using guessed type char byte_10112881;
// 10112888: using guessed type int dword_10112888;
// 10112C78: using guessed type int dword_10112C78;
// 10112D04: using guessed type int dword_10112D04;
// 10112D10: using guessed type int dword_10112D10[];
// 10112D14: using guessed type int dword_10112D14[];
// 10112D18: using guessed type int dword_10112D18[];
// 10112D1C: using guessed type int dword_10112D1C[];
// 10112D20: using guessed type int dword_10112D20[];
// 10112D24: using guessed type int dword_10112D24[];
// 10112D28: using guessed type int dword_10112D28[];
// 10112DA4: using guessed type int dword_10112DA4[];

//----- (10002390) --------------------------------------------------------
char __cdecl sub_10002390(int a1)
{
  char result; // al@1
  void *v2; // ecx@1
  char v3; // ST18_1@3
  char v4; // al@3
  char v5; // al@3
  __int16 v6; // dx@3
  int v7; // [sp+4h] [bp-3Ch]@1
  int v8; // [sp+8h] [bp-38h]@3
  char v9; // [sp+Ch] [bp-34h]@1
  unsigned __int8 v10; // [sp+Dh] [bp-33h]@3
  int v11; // [sp+10h] [bp-30h]@3
  int v12; // [sp+3Ch] [bp-4h]@3

  memset(&v9, 0, 0x32u);
  result = sub_10010C80(6, a1, &v9, (int)&v7);
  if ( result )
  {
    if ( (_WORD)a1 == 231 )
    {
      v3 = v12;
      v4 = sub_10019900(v2);
      v5 = sub_1001FB70(v4, v3);
      LOBYTE(v6) = 0;
      HIBYTE(v6) = v9;
      LOBYTE(v8) = v5;
      result = sub_1001FFF0(v8, (unsigned __int16)(v10 | v6), &v11, 44);
    }
    else
    {
      result = sub_1001EBF0(2, v12, v11, 0);
    }
  }
  return result;
}
// 1001FFF0: using guessed type _DWORD __cdecl sub_1001FFF0(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10002420) --------------------------------------------------------
char __cdecl sub_10002420(int a1, char a2)
{
  char result; // al@1
  int v3; // eax@5
  unsigned __int8 v4; // al@5
  signed int v5; // ecx@5
  unsigned __int16 v6; // ax@6
  char v7; // [sp+6h] [bp-32h]@1
  char v8; // [sp+7h] [bp-31h]@1
  int v9; // [sp+8h] [bp-30h]@1
  char v10; // [sp+Ch] [bp-2Ch]@1
  char v11; // [sp+Eh] [bp-2Ah]@1
  char v12; // [sp+11h] [bp-27h]@2
  char v13; // [sp+12h] [bp-26h]@3

  v8 = 0;
  v7 = 0;
  LOBYTE(v9) = sub_1001DF30(a2);
  sub_1001F460(v9, &v10);
  result = 5;
  if ( v11 == 5 || v12 == 5 )
  {
    if ( v13 == 4 )
    {
      v5 = (unsigned __int16)sub_1004ED20();
    }
    else
    {
      if ( v13 == 5 )
      {
        v6 = j_HWM_pvg_get_anlg_outp(3);
        v7 = ((signed int)(1374389535 * (unsigned __int64)v6 >> 32) >> 5)
           + ((unsigned int)(1374389535 * (unsigned __int64)v6 >> 32) >> 31);
        return sub_1001DFD0(a2, a1, 30981, (int)&v7, 1);
      }
      v3 = sub_1001DE10(&v8, 1u, (int)&unk_10066AD4, 2, 4);
      v4 = sub_1001DC80(&v13, 1u, (int)&unk_10066AD4, 2, 4, v3);
      v5 = (signed __int16)j_HWM_pvg_get_frmt_adc((unsigned __int8)byte_10066AD5[2 * v4]);
    }
    v7 = v5 / 100;
    return sub_1001DFD0(a2, a1, 30981, (int)&v7, 1);
  }
  return result;
}
// 1004EC70: using guessed type int __cdecl j_HWM_pvg_get_anlg_outp(_DWORD);
// 1004EC80: using guessed type int __cdecl j_HWM_pvg_get_frmt_adc(_DWORD);

//----- (10002520) --------------------------------------------------------
int __usercall sub_10002520@<eax>(char *a1@<eax>, int a2@<edx>)
{
  char *v2; // esi@1
  int result; // eax@1
  char v4; // cl@2

  v2 = a1;
  result = 0;
  if ( a2 > 0 )
  {
    while ( 1 )
    {
      v4 = *v2;
      if ( (unsigned __int8)*v2 < 0x41u || (unsigned __int8)v4 > 0x46u )
        result = result + (unsigned __int8)v4 - 48;
      else
        result = result + (unsigned __int8)v4 - 55;
      if ( --a2 <= 0 )
        break;
      result *= 16;
      ++v2;
    }
  }
  return result;
}

//----- (10002560) --------------------------------------------------------
char __cdecl sub_10002560(int a1, char a2)
{
  char v2; // al@1
  char result; // al@1
  int v4; // [sp+4h] [bp-8h]@1
  char v5[4]; // [sp+8h] [bp-4h]@1

  v4 = 0;
  v2 = sub_1001DF30(a2);
  v5[0] = v2;
  result = sub_1001F440(v2, &v4);
  if ( !result )
    result = sub_1001DFD0(a2, a1, 3076, 0, 0);
  return result;
}

//----- (100025B0) --------------------------------------------------------
char __usercall sub_100025B0@<al>(int a1@<edx>, int a2@<ecx>, int a3@<esi>)
{
  int v3; // eax@1
  char v4; // bl@1
  unsigned __int16 v5; // ax@3
  unsigned __int16 v7; // di@5

  v3 = *(_DWORD *)(a3 + 8);
  v4 = 1;
  if ( !v3 )
  {
    v7 = dword_10112D04;
    if ( *(_DWORD *)a3 + (unsigned int)(unsigned __int16)dword_10112D04 <= 0x78 )
    {
      if ( (_WORD)dword_10112D04 )
      {
LABEL_9:
        memcpy((char *)&unk_10112C8C + v7, (const void *)(a3 + 12), *(_DWORD *)a3);
        LOWORD(dword_10112D04) = *(_WORD *)a3 + v7;
        return v4;
      }
    }
    else
    {
      v4 = sub_100033A0(a1, a2, (int)&dword_10112C88);
      v7 = 0;
    }
    dword_10112C88 = dword_10112C84 + *(_DWORD *)(a3 + 4);
    goto LABEL_9;
  }
  if ( v3 != 1 )
  {
    v5 = __ROL2__(*(_WORD *)(a3 + 12), 8);
    dword_10112C84 = 16 * v5;
  }
  return sub_100033A0(a1, a2, (int)&dword_10112C88);
}
// 10112C84: using guessed type int dword_10112C84;
// 10112C88: using guessed type int dword_10112C88;
// 10112D04: using guessed type int dword_10112D04;

//----- (10002650) --------------------------------------------------------
int __cdecl sub_10002650(unsigned __int8 a1, char a2)
{
  int result; // eax@1
  int v3; // [sp+0h] [bp-1Ch]@1
  int v4; // [sp+4h] [bp-18h]@1
  int v5; // [sp+8h] [bp-14h]@1
  int v6; // [sp+Ch] [bp-10h]@1
  int v7; // [sp+10h] [bp-Ch]@1
  int v8; // [sp+14h] [bp-8h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  result = sub_1004E560(35, 10);
  if ( !result )
  {
    sub_1004E880(9132, &v3, 12, &v6);
    *((_BYTE *)&v3 + a1) = a2;
    *(&v4 + a1) = sub_1004E4B0();
    sub_1004E9B0(9132, (int)&v3, 12);
    result = sub_1004E540(35);
  }
  return result;
}

//----- (100026E0) --------------------------------------------------------
char __cdecl sub_100026E0(char a1, char a2, char *a3, int a4, int a5)
{
  int v5; // edi@1
  unsigned int v6; // esi@1
  char result; // al@1
  char *v8; // ecx@1
  char v9; // al@7
  int v10; // eax@7
  int v11; // edx@7
  int v12; // ecx@7
  char v13; // [sp+13h] [bp-E5h]@1
  int v14; // [sp+14h] [bp-E4h]@1
  char *v15; // [sp+18h] [bp-E0h]@2
  char *v16; // [sp+1Ch] [bp-DCh]@7
  int v17; // [sp+20h] [bp-D8h]@1
  int v18; // [sp+24h] [bp-D4h]@18
  int v19; // [sp+28h] [bp-D0h]@20
  char v20; // [sp+8Eh] [bp-6Ah]@22
  char v21; // [sp+8Fh] [bp-69h]@12
  char v22[100]; // [sp+90h] [bp-68h]@7

  v5 = 0;
  memset(&v17, 0, 0x70u);
  v6 = 0;
  result = 1;
  v14 = 0;
  v8 = (char *)a5;
  v13 = 1;
  if ( *(_DWORD *)(a5 + 1000) )
    v15 = (char *)a5;
  else
    v15 = a3;
  while ( *(_DWORD *)(a5 + 1000) || a4 )
  {
    v9 = *v15;
    ++v14;
    *v8 = *v15;
    v22[v6] = v9;
    v10 = *(_DWORD *)(a5 + 1000);
    v11 = (int)(v15 + 1);
    v12 = (int)(v8 + 1);
    ++v15;
    v16 = (char *)v12;
    if ( v10 )
    {
      *(_DWORD *)(a5 + 1000) = v10 - 1;
      if ( v10 == 1 )
        v15 = a3;
    }
    else
    {
      --a4;
    }
    ++v6;
    switch ( v5 )
    {
      case 0:
        if ( *(&v21 + v6) == 58 )
          v5 = 1;
        v6 = 0;
        break;
      case 1:
        if ( v6 == 2 )
        {
          v6 = 0;
          v17 = sub_10002520(v22, 2);
          v5 = 2;
        }
        break;
      case 2:
        if ( v6 == 4 )
        {
          v6 = 0;
          v18 = sub_10002520(v22, 4);
          v5 = 3;
        }
        break;
      case 3:
        if ( v6 == 2 )
        {
          v6 = 0;
          v19 = sub_10002520(v22, 2);
          v5 = 5 - (v17 != 0);
        }
        break;
      case 4:
        if ( !(v6 & 1) )
        {
          *((_BYTE *)&v19 + (v6 >> 1) + 3) = sub_10002520(&v20 + v6, 2);
          if ( v6 >> 1 == v17 )
          {
            v6 = 0;
            v5 = 5;
          }
        }
        break;
      default:
        if ( v6 == 2 )
        {
          LOBYTE(v12) = a2;
          LOBYTE(v11) = a1;
          v16 = (char *)a5;
          v14 = 0;
          v6 = 0;
          v13 = sub_100025B0(v11, v12, (int)&v17);
          v5 = 0;
        }
        break;
    }
    result = v13;
    if ( !v13 )
    {
      *(_DWORD *)(a5 + 1000) = v14;
      return result;
    }
    v8 = v16;
  }
  *(_DWORD *)(a5 + 1000) = v14;
  return result;
}
// 100026E0: using guessed type char var_68[100];

//----- (100028F0) --------------------------------------------------------
char __usercall sub_100028F0@<al>(char a1@<dl>, int a2@<ecx>, char a3)
{
  int v3; // esi@1
  char v4; // al@4
  __int16 v5; // cx@4
  int v6; // edx@4
  int v7; // eax@4
  char result; // al@4
  int v9; // eax@5
  char v10; // al@5
  int v11; // eax@5
  int v12; // eax@6
  int v13; // [sp+4h] [bp-Ch]@7
  char v14; // [sp+8h] [bp-8h]@4
  __int16 v15; // [sp+Ah] [bp-6h]@4
  int v16; // [sp+Ch] [bp-4h]@4

  v3 = (unsigned __int8)a1;
  switch ( byte_10112880[(unsigned __int8)a1] )
  {
    case 1:
      dword_10112C80 = 0;
      v13 = (unsigned __int16)word_1011288C;
      result = sub_1001FFF0(a1, 2051, &v13, 2);
      byte_10112880[v3] = 2;
      break;
    case 2:
      v14 = byte_10112883;
      v15 = word_1011288C;
      v16 = dword_10112C80;
      v12 = sub_1004E4B0();
      sub_1000EA10(2, 1, (int)&byte_10236500, &v14, v12);
      result = sub_1000F010(2, 255, (int)&byte_10236500);
      byte_10112880[v3] = 3;
      break;
    case 3:
      byte_10112880[(unsigned __int8)a1] = 4;
      v9 = *(_DWORD *)(a2 + 1012);
      dword_10112C80 = v9 + *(_DWORD *)(a2 + 8);
      v10 = sub_100026E0(a1, a3, (char *)(a2 + 12), v9, (int)&unk_10112890);
      byte_10112883 = v10;
      v14 = v10;
      v15 = word_1011288C;
      v16 = dword_10112C80;
      v11 = sub_1004E4B0();
      sub_1000EA10(2, 1, (int)&byte_10236500, &v14, v11);
      result = sub_1000F010(2, 255, (int)&byte_10236500);
      byte_10112880[v3] = 3;
      break;
    default:
      sub_1001FFF0(a1, 2049, 0, 0);
      v4 = byte_10112883;
      v5 = word_1011288C;
      v6 = dword_10112C80;
      byte_10112880[v3] = 0;
      v14 = v4;
      v15 = v5;
      v16 = v6;
      v7 = sub_1004E4B0();
      sub_1000EA10(2, 1, (int)&byte_10236500, &v14, v7);
      result = sub_1000F010(2, 255, (int)&byte_10236500);
      break;
  }
  return result;
}
// 1001FFF0: using guessed type _DWORD __cdecl sub_1001FFF0(_DWORD, _DWORD, _DWORD, _DWORD);
// 10112883: using guessed type char byte_10112883;
// 1011288C: using guessed type __int16 word_1011288C;
// 10112C80: using guessed type int dword_10112C80;
// 10236500: using guessed type char byte_10236500;

//----- (10002A90) --------------------------------------------------------
char __cdecl sub_10002A90(unsigned __int8 a1, char a2)
{
  int v2; // ebx@1
  int *v3; // esi@2
  char v4; // si@5
  char v5; // al@5
  char v6; // al@6
  int v7; // ecx@14
  char result; // al@14
  char v9; // [sp+11h] [bp-Fh]@1
  char v10; // [sp+12h] [bp-Eh]@6
  char v11; // [sp+13h] [bp-Dh]@1
  char v12; // [sp+14h] [bp-Ch]@6
  int v13; // [sp+18h] [bp-8h]@4
  int v14; // [sp+1Ch] [bp-4h]@1

  v2 = 0;
  v14 = 0;
  v11 = 1;
  v9 = sub_1001DF30(a2);
  if ( !byte_10112880[a1] )
  {
    v3 = &dword_10112D24[38 * a1];
    if ( (unsigned int)(sub_1004E4B0() - *v3) >= 0x1388 )
    {
      sub_10002650(a1, 1);
      *v3 = sub_1004E4B0();
    }
  }
  LOBYTE(v13) = 0;
  do
  {
    v4 = v13;
    v5 = sub_1001FB70(v13, a2);
    if ( v5 != 2 )
    {
      v12 = v5;
      ++v2;
      v6 = sub_100193D0(v4);
      if ( sub_1001F5B0(v6, 0, &v12, &v10) == 1 && v10 == 2 )
        ++v14;
    }
    LOBYTE(v13) = v13 + 1;
  }
  while ( (unsigned __int8)v13 < 3u );
  if ( v2 == v14 || v14 >= 1 )
  {
    result = sub_1001BD80(word_10066AA4[2 * (unsigned __int8)v9]);
    if ( result )
    {
      sub_1001BE10(word_10066AA4[2 * (unsigned __int8)v9]);
      result = sub_100019C0(a2);
    }
  }
  else
  {
    sub_1001BE10(word_10066AA6[2 * (unsigned __int8)v9]);
    if ( !sub_1001BD80(word_10066AA4[2 * (unsigned __int8)v9]) )
    {
      sub_1001BF40(word_10066AA4[2 * (unsigned __int8)v9]);
      sub_100200D0(a2, 0, 0, 0, 1);
      sub_1001EB50(a1, a2);
    }
    v7 = (unsigned __int16)word_10066ABA[6 * (unsigned __int8)v9];
    byte_10112D2C[152 * a1] = 0;
    result = sub_100106F0(2, v7, &v11, 0, 1, 1);
  }
  return result;
}
// 10066AA4: using guessed type __int16 word_10066AA4[];
// 10066AA6: using guessed type __int16 word_10066AA6[];
// 10066ABA: using guessed type __int16 word_10066ABA[];
// 10112D24: using guessed type int dword_10112D24[];

//----- (10002C30) --------------------------------------------------------
int __usercall sub_10002C30@<eax>(int a1@<ecx>, unsigned __int8 a2@<bl>, char a3)
{
  int v3; // esi@1
  char v4; // al@1
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // ecx@1
  int v9; // esi@1
  int v10; // eax@1
  int result; // eax@1
  int v12; // ecx@1
  char v13; // [sp+7h] [bp-19h]@1
  int v14; // [sp+8h] [bp-18h]@1
  int v15; // [sp+Ch] [bp-14h]@1
  int v16; // [sp+10h] [bp-10h]@1
  int v17; // [sp+14h] [bp-Ch]@1
  int v18; // [sp+18h] [bp-8h]@1

  v3 = a1;
  v13 = 2;
  v4 = sub_1001DF30(a3);
  v5 = *(_DWORD *)(v3 + 8);
  v14 = *(_DWORD *)(v3 + 4);
  v6 = *(_DWORD *)(v3 + 12);
  v15 = v5;
  v7 = *(_DWORD *)(v3 + 16);
  v16 = v6;
  v8 = *(_DWORD *)(v3 + 20);
  v9 = 6 * (unsigned __int8)v4;
  v10 = (unsigned __int16)word_10066AB6[6 * (unsigned __int8)v4];
  v17 = v7;
  v18 = v8;
  sub_100106F0(6, v10, &v14, 0, 20, 1);
  sub_100106F0(2, (unsigned __int16)word_10066ABA[v9], &v13, 0, 1, 1);
  sub_10002650(a2, 2);
  result = sub_1004E4B0();
  v12 = 38 * a2;
  dword_10112D24[v12] = result;
  dword_10112DA4[v12] = result;
  return result;
}
// 10066AB6: using guessed type __int16 word_10066AB6[];
// 10066ABA: using guessed type __int16 word_10066ABA[];
// 10112D24: using guessed type int dword_10112D24[];
// 10112DA4: using guessed type int dword_10112DA4[];

//----- (10002CF0) --------------------------------------------------------
char __usercall sub_10002CF0@<al>(_BYTE *a1@<eax>, unsigned int a2@<ecx>, char a3)
{
  int v3; // esi@1
  unsigned __int16 v4; // ax@1
  unsigned int v5; // ebx@1
  unsigned __int16 v6; // di@1
  int v7; // eax@1
  unsigned int v8; // ebp@7
  bool v9; // cl@11
  bool v10; // zf@11
  int v11; // edi@15
  int v12; // edi@16
  int v13; // edi@23
  int v14; // eax@23
  char v15; // cl@23
  int v16; // eax@23
  unsigned __int8 v18; // [sp+10h] [bp-4h]@1

  v3 = (int)a1;
  HIBYTE(v4) = *a1;
  v5 = a2;
  LOBYTE(v4) = *(_BYTE *)(v3 + 1);
  v6 = v4;
  LOBYTE(v7) = sub_1001DF30(a3);
  v18 = v7;
  if ( (signed int)v6 <= 3078 )
  {
    if ( v6 == 3078 )
    {
      LOBYTE(v7) = sub_100106F0(6, (unsigned __int16)word_10066AB0[6 * (unsigned __int8)v7], (void *)(v3 + 4), 0, 20, 1);
    }
    else if ( (signed int)v6 > 2052 )
    {
      if ( v6 == 3075 )
      {
        v12 = 3 * (unsigned __int8)v7;
        sub_100106F0(6, (unsigned __int16)word_10066AB2[6 * (unsigned __int8)v7], (void *)(v3 + 4), 0, 44, 1);
        LOBYTE(v7) = sub_100108A0(6, (unsigned __int16)word_10066AB2[2 * v12], 255);
      }
      else if ( v6 == 3077 )
      {
        v11 = 3 * (unsigned __int8)v7;
        sub_100106F0(6, (unsigned __int16)word_10066AB4[6 * (unsigned __int8)v7], (void *)(v3 + 4), 0, 4, 1);
        sub_100108A0(6, (unsigned __int16)word_10066AB4[2 * v11], 255);
        LOBYTE(v7) = sub_1001F4E0((unsigned __int16)word_10066AB4[2 * v11], v18);
      }
    }
    else
    {
      switch ( v6 )
      {
        case 0x804u:
          LOBYTE(v7) = *(_BYTE *)v3;
          v9 = *(_BYTE *)(v3 + 4) == 0;
          v10 = byte_10112880[(unsigned __int8)v5] == 2;
          byte_10112882 = *(_BYTE *)v3;
          byte_10112883 = v9;
          if ( v10 )
            LOBYTE(v7) = sub_100028F0(v5, 0, a3);
          break;
        case 0x100u:
          LOBYTE(v7) = sub_1001A070((void *)0x100);
          if ( (_BYTE)v7 == 8 && !(_BYTE)v5 )
            LOBYTE(v7) = sub_10002250(0);
          break;
        case 0x200u:
          v8 = 152 * (unsigned __int8)v5;
          ++byte_10112D2C[v8];
          qmemcpy((char *)&unk_10112D30 + v8, (const void *)(v3 + 4), 0x74u);
          sub_100106F0(2, (unsigned __int16)word_10066AB8[6 * (unsigned __int8)v7], (void *)(v3 + 4), 0, 116, 1);
          sub_10002650(v5, 2);
          v7 = sub_1004E4B0();
          dword_10112D24[v8 / 4] = v7;
          break;
      }
    }
    return v7;
  }
  if ( (signed int)v6 <= 30979 )
  {
    if ( v6 == 30979 )
    {
      LOBYTE(v7) = sub_10002C30(v3, v5, a3);
      return v7;
    }
    if ( v6 != 3328 )
    {
      if ( v6 == 30721 )
        LOBYTE(v7) = sub_1001EBF0(v5, a3, *(_DWORD *)(v3 + 4), 1);
      return v7;
    }
    v13 = 38 * (unsigned __int8)v5;
    byte_10112D2C[v13 * 4] = 0;
    v14 = sub_1001DC80(&byte_10112884[(unsigned __int8)v5], 1u, (int)&unk_10066A78, 6, 7, 6);
    v15 = *(_BYTE *)(v3 + 4);
    v16 = 3 * v14;
    if ( byte_10066A79[v16 * 2] == v15 )
    {
      if ( byte_10112880[(unsigned __int8)v5] != 1 )
      {
        byte_10112D08[(unsigned __int8)v5] = 0;
LABEL_31:
        sub_1001EB50(v5, a3);
        v7 = sub_1004E4B0() + 1000;
        dword_10112D14[v13] = v7;
        return v7;
      }
    }
    else if ( byte_10112880[(unsigned __int8)v5] != 1 )
    {
      byte_10112D08[(unsigned __int8)v5] = 1;
      dword_10112D20[v13] = sub_1004E4B0();
      goto LABEL_31;
    }
    if ( v15 == 32 )
    {
      sub_100028F0(v5, 0, a3);
      byte_10112D08[(unsigned __int8)v5] = 0;
    }
    else
    {
      sub_1001FFF0(v5, (unsigned __int16)word_10066A7C[v16], 0, 0);
      byte_10112D08[(unsigned __int8)v5] = 0;
    }
    goto LABEL_31;
  }
  if ( v6 == 30980 )
    LOBYTE(v7) = sub_1001E050(v3);
  return v7;
}
// 1001FFF0: using guessed type _DWORD __cdecl sub_1001FFF0(_DWORD, _DWORD, _DWORD, _DWORD);
// 10066A7C: using guessed type __int16 word_10066A7C[];
// 10066AB0: using guessed type __int16 word_10066AB0[];
// 10066AB2: using guessed type __int16 word_10066AB2[];
// 10066AB4: using guessed type __int16 word_10066AB4[];
// 10066AB8: using guessed type __int16 word_10066AB8[];
// 10112882: using guessed type char byte_10112882;
// 10112883: using guessed type char byte_10112883;
// 10112D14: using guessed type int dword_10112D14[];
// 10112D20: using guessed type int dword_10112D20[];
// 10112D24: using guessed type int dword_10112D24[];

//----- (10003010) --------------------------------------------------------
char __cdecl sub_10003010(int a1, char a2)
{
  unsigned int v2; // eax@1
  bool v3; // zf@1
  unsigned __int16 v4; // dx@3
  unsigned int v5; // ecx@3
  int v6; // edi@6
  int v7; // esi@7
  void *v8; // ecx@9
  char *v9; // ebp@11
  int v10; // eax@15
  char v11; // al@21
  int v13; // [sp+8h] [bp-414h]@1
  unsigned __int8 v14; // [sp+Ch] [bp-410h]@2
  unsigned __int8 v15; // [sp+Dh] [bp-40Fh]@3

  LOBYTE(v2) = a1;
  v3 = byte_10112C7C[(unsigned __int8)a1] == 0;
  v13 = 0;
  if ( !v3 )
  {
    while ( sub_10020000(a1, (char *)&v14) )
    {
      LOBYTE(v4) = 0;
      HIBYTE(v4) = v15;
      v5 = (unsigned __int16)(v14 | v4);
      v13 = (unsigned __int16)(v14 | v4);
      LOWORD(v5) = v14;
      LOBYTE(v4) = 0;
      HIBYTE(v4) = v14;
      if ( (v15 | v4) == 30979 )
        sub_1001DFD0(a2, a1, 1536, (int)&v13, 2);
      LOBYTE(v5) = a1;
      sub_10002CF0(&v14, v5, a2);
    }
    v2 = sub_1004E4B0();
    v6 = v2;
    if ( a2 != 18 )
    {
      v7 = 38 * (unsigned __int8)a1;
      if ( v2 - dword_10112D10[38 * (unsigned __int8)a1] >= 0x1388 )
      {
        sub_10002A90(a1, a2);
        dword_10112D10[v7] = v6;
      }
      LOBYTE(v2) = sub_10020400(1);
      if ( !(_BYTE)v2 )
        LOBYTE(v2) = sub_1001A070(v8);
      v9 = &byte_10112884[(unsigned __int8)a1];
      if ( byte_10112884[(unsigned __int8)a1] != (_BYTE)v2 )
      {
        byte_10112D08[(unsigned __int8)a1] = 1;
        *v9 = v2;
        v2 = sub_1004E4B0() - 2000;
        dword_10112D20[v7] = v2;
      }
      if ( byte_10112D08[(unsigned __int8)a1] == 1 )
      {
        v2 = v6 - dword_10112D20[v7];
        if ( v2 >= 0x7D0 )
        {
          v10 = sub_1001DC80(v9, 1u, (int)&unk_10066A78, 6, 7, 6);
          LOBYTE(v2) = sub_1001DFD0(a2, a1, (unsigned __int16)word_10066A7A[3 * v10], 0, 0);
          dword_10112D20[v7] = v6;
        }
      }
      if ( !byte_10112880[(unsigned __int8)a1] )
      {
        LOBYTE(v2) = sub_1001A090((void *)(unsigned __int8)a1);
        if ( (_BYTE)v2 == 2 )
        {
          if ( (unsigned int)(v6 - dword_10112D28[v7]) >= 0x1388 )
          {
            if ( (unsigned __int8)byte_10112D2C[v7 * 4] < 5u || dword_10112DA4[v7] < (unsigned int)(v6 - 3000) )
            {
              sub_1001DFD0(a2, a1, 256, 0, 0);
            }
            else
            {
              v11 = sub_1001DF30(a2);
              sub_100106F0(
                2,
                (unsigned __int16)word_10066AB8[6 * (unsigned __int8)v11],
                (char *)&unk_10112D30 + v7 * 4,
                0,
                4,
                1);
            }
            dword_10112D28[v7] = v6;
          }
          if ( (unsigned int)(v6 - dword_10112D18[v7]) >= 0xFA )
          {
            sub_10002560(a1, a2);
            dword_10112D18[v7] = v6;
          }
          if ( (unsigned int)(v6 - dword_10112D14[v7]) >= 0x64 )
          {
            sub_1001EC90(a1, a2);
            dword_10112D14[v7] = v6;
          }
          v2 = v6 - dword_10112D1C[v7];
          if ( v2 >= 0xC8 )
          {
            LOBYTE(v2) = sub_10002420(a1, a2);
            dword_10112D1C[v7] = v6;
          }
        }
      }
      if ( byte_10112880[(unsigned __int8)a1] == 1 )
      {
        LOBYTE(v2) = v6 - dword_10112888;
        if ( (unsigned int)(v6 - dword_10112888) > 0x1388 )
        {
          LOBYTE(v2) = sub_1001FFF0(a1, 1286, 0, 0);
          dword_10112888 = v6;
        }
      }
    }
  }
  return v2;
}
// 1001FFF0: using guessed type _DWORD __cdecl sub_1001FFF0(_DWORD, _DWORD, _DWORD, _DWORD);
// 10066A7A: using guessed type __int16 word_10066A7A[];
// 10066AB8: using guessed type __int16 word_10066AB8[];
// 10112888: using guessed type int dword_10112888;
// 10112D10: using guessed type int dword_10112D10[];
// 10112D14: using guessed type int dword_10112D14[];
// 10112D18: using guessed type int dword_10112D18[];
// 10112D1C: using guessed type int dword_10112D1C[];
// 10112D20: using guessed type int dword_10112D20[];
// 10112D28: using guessed type int dword_10112D28[];
// 10112DA4: using guessed type int dword_10112DA4[];

//----- (10003310) --------------------------------------------------------
char __cdecl sub_10003310(int a1, char a2, int a3)
{
  char result; // al@3

  if ( *(_WORD *)a3 == -32726 )
  {
    if ( (unsigned __int8)(*(_BYTE *)(a3 + 4) - 1) > 1u )
    {
      word_1011288C = *(_WORD *)(a3 + 8);
      byte_10112880[(unsigned __int8)a1] = 1;
      dword_10112C78 = 0;
      LOWORD(dword_10112D04) = 0;
      dword_10112888 = sub_1004E4B0();
      result = sub_1001FFF0(a1, 1292, 0, 0);
    }
    else
    {
      byte_10112880[(unsigned __int8)a1] = 5;
      result = sub_100028F0(a1, a3, a2);
    }
  }
  else
  {
    result = sub_100028F0(a1, a3, a2);
  }
  return result;
}
// 1001FFF0: using guessed type _DWORD __cdecl sub_1001FFF0(_DWORD, _DWORD, _DWORD, _DWORD);
// 10112888: using guessed type int dword_10112888;
// 1011288C: using guessed type __int16 word_1011288C;
// 10112C78: using guessed type int dword_10112C78;
// 10112D04: using guessed type int dword_10112D04;

//----- (100033A0) --------------------------------------------------------
char __cdecl sub_100033A0(int a1, int a2, int a3)
{
  char result; // al@1
  int v4; // ebp@2

  result = 1;
  if ( (_WORD)dword_10112D04 )
  {
    sub_1001FFF0(a1, 2050, a3, (unsigned __int16)(dword_10112D04 + 4));
    LOWORD(dword_10112D04) = 0;
    byte_10112882 = 0;
    v4 = sub_1004E4B0();
    while ( (unsigned int)(sub_1004E4B0() - v4) < 0x1388 )
    {
      sub_10003010(a1, a2);
      sub_1004E640(0);
      if ( byte_10112882 == 8 )
        return 1;
    }
    result = 0;
  }
  return result;
}
// 1001FFF0: using guessed type _DWORD __cdecl sub_1001FFF0(_DWORD, _DWORD, _DWORD, _DWORD);
// 10112882: using guessed type char byte_10112882;
// 10112D04: using guessed type int dword_10112D04;

//----- (10003430) --------------------------------------------------------
int sub_10003430()
{
  int result; // eax@1

  memset(byte_10113400, 0, 0xB0u);
  sub_100204C0(byte_10112E40);
  result = 0;
  dword_101134B0 = 0;
  dword_101134B4 = 0;
  dword_101134B8 = 0;
  dword_101134BC = 0;
  byte_101133F8 = 1;
  return result;
}
// 101133F8: using guessed type char byte_101133F8;
// 101134B0: using guessed type int dword_101134B0;
// 101134B4: using guessed type int dword_101134B4;
// 101134B8: using guessed type int dword_101134B8;
// 101134BC: using guessed type int dword_101134BC;

//----- (10003470) --------------------------------------------------------
char __cdecl sub_10003470(int a1, int a2)
{
  void *v2; // ecx@0
  int v3; // eax@1
  char v5; // [sp+1h] [bp-1h]@1

  v5 = sub_10019DC0(v2);
  v3 = sub_1004E4B0();
  return sub_1000EA10(a1, 1, a2, &v5, v3);
}

//----- (100034A0) --------------------------------------------------------
char __cdecl sub_100034A0(float a1, int a2)
{
  int v2; // esi@1
  char result; // al@1
  int v4; // eax@2
  int v5; // eax@3

  v2 = LODWORD(a1);
  result = LOBYTE(a1);
  switch ( LOWORD(a1) )
  {
    case 0x19u:
    case 0x1Au:
      a1 = sub_10019DA0();
      v4 = sub_1004E4B0();
      result = sub_1000EA10(v2, 1, a2, &a1, v4);
      break;
    case 0x15u:
    case 0x16u:
      a1 = sub_1001B380();
      v5 = sub_1004E4B0();
      result = sub_1000EA10(v2, 1, a2, &a1, v5);
      break;
    default:
      return result;
  }
  return result;
}
// 10019DA0: using guessed type double sub_10019DA0(void);
// 1001B380: using guessed type double sub_1001B380(void);

//----- (10003520) --------------------------------------------------------
bool __cdecl sub_10003520(float a1, int a2)
{
  int v2; // edi@1
  int v3; // esi@2
  bool result; // al@5
  int v5; // esi@6
  int v6; // eax@6

  v2 = LODWORD(a1);
  if ( LOWORD(a1) == 99 )
  {
    v3 = 9156;
  }
  else if ( LOWORD(a1) == 100 )
  {
    v3 = 9157;
  }
  else
  {
    v3 = 9158;
    result = sub_1001B4C0(1);
    if ( !result )
      return result;
  }
  a1 = 0.0;
  v5 = sub_1004E7C0(v3, (int)&a1, 4);
  v6 = sub_1004E4B0();
  return sub_1000EA10(v2, v5 == 0, a2, &a1, v6);
}

//----- (10003590) --------------------------------------------------------
char __cdecl sub_10003590(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@3
  int v4; // eax@4
  char v6; // [sp+8h] [bp-10h]@3

  v2 = 9216;
  if ( (_WORD)a1 == 577 )
    v2 = 9217;
  v3 = sub_1004E7C0(v2, (int)&v6, 12);
  if ( !v3 )
  {
    v4 = sub_1004E4B0();
    LOBYTE(v3) = sub_1000EA10(a1, 1, a2, &v6, v4);
  }
  return v3;
}

//----- (10003600) --------------------------------------------------------
char __cdecl sub_10003600(int a1, int a2)
{
  int v3; // [sp+0h] [bp-4h]@1

  v3 = sub_1004E4B0();
  return sub_1000EA10(a1, 1, a2, &v3, v3);
}

//----- (10003630) --------------------------------------------------------
bool __cdecl sub_10003630(char a1)
{
  void *v1; // ecx@0
  char v2; // al@1

  v2 = sub_1001B4A0(v1);
  return v2 & 0xF && a1 & 0xF || v2 & 0xF0 && a1 & 0xF0;
}

//----- (10003660) --------------------------------------------------------
char __usercall sub_10003660@<al>(int a1@<edi>)
{
  _BYTE *v1; // esi@1

  v1 = &unk_10112E68;
  while ( sub_10020690((_BYTE *)a1, v1 - 16, 16) || sub_10020690((_BYTE *)(a1 + 16), v1, 8) )
  {
    v1 += 24;
    if ( (signed int)v1 >= (signed int)&unk_10113408 )
      return 0;
  }
  return 1;
}

//----- (100036C0) --------------------------------------------------------
char __cdecl sub_100036C0(char a1)
{
  int v1; // eax@1
  void *v2; // ecx@1
  char v3; // al@2
  void *v4; // esi@4
  int v5; // eax@5
  char *v6; // ebx@5
  char *v7; // edi@5
  int v8; // ebp@5
  char v9; // al@6
  char v10; // al@11
  char v11; // al@12
  char v13; // [sp+3h] [bp-19A1h]@1
  int v14; // [sp+4h] [bp-19A0h]@4
  char v15; // [sp+8h] [bp-199Ch]@1
  char v16[3252]; // [sp+20h] [bp-1984h]@5
  char v17; // [sp+CD4h] [bp-CD0h]@1
  char v18[3252]; // [sp+CECh] [bp-CB8h]@5

  memset(&v15, 0, 0xCCCu);
  memset(&v17, 0, 0xCCCu);
  v13 = 1;
  LOBYTE(v1) = sub_100036B0();
  if ( (_BYTE)v1 )
  {
    v3 = sub_10019900(v2);
    LOBYTE(v1) = sub_10020350(v3, &v17);
    if ( (_BYTE)v1 )
    {
      LOBYTE(v1) = sub_10020350(a1, &v15);
      if ( (_BYTE)v1 )
      {
        v4 = &unk_10067968;
        v14 = 4;
        do
        {
          v5 = 232 * *(_BYTE *)v4;
          v6 = &v16[v5];
          v7 = &v18[v5];
          v1 = sub_1004ED40((int)&v18[v5], (int)&v16[v5]);
          v8 = v1;
          if ( !*((_BYTE *)v4 + 5) || (v9 = sub_100194B0(a1), LOBYTE(v1) = sub_10003630(v9), (_BYTE)v1) )
          {
            if ( !v7[2] && !v6[2] )
            {
              if ( v8 )
              {
                LOBYTE(v1) = sub_1001BF40(*((_WORD *)v4 + 1));
                if ( *((_BYTE *)v4 + 4) )
                {
                  v10 = sub_100193D0(a1);
                  LOBYTE(v1) = sub_10009800(v10, &v13);
                  if ( v13 )
                  {
                    v11 = sub_100193D0(a1);
                    LOBYTE(v1) = sub_10009A90(v11, 0);
                  }
                }
              }
            }
          }
          v4 = (char *)v4 + 6;
          --v14;
        }
        while ( v14 );
      }
    }
  }
  return v1;
}
// 100036B0: using guessed type int sub_100036B0(void);
// 10009800: using guessed type _DWORD __cdecl sub_10009800(char, _DWORD);
// 100036C0: using guessed type char var_1984[3252];
// 100036C0: using guessed type char var_CB8[3252];

//----- (10003830) --------------------------------------------------------
void sub_10003830()
{
  unsigned __int8 v0; // bl@1
  int *v1; // ebp@1
  int *v2; // edi@1
  char *v3; // esi@1
  int v4; // eax@2
  bool v5; // al@2
  char v6; // al@6
  void *v7; // ecx@14
  char v8; // al@15
  char v9; // al@17
  char v10; // bl@17
  int v11; // esi@19
  unsigned __int16 v12; // ST08_2@20
  char v13; // al@20
  unsigned __int16 v14; // ST08_2@23
  char v15; // al@15
  char v16; // [sp-4h] [bp-1E4h]@15
  char v17; // [sp+13h] [bp-1CDh]@8
  int v18; // [sp+14h] [bp-1CCh]@1
  int v19; // [sp+18h] [bp-1C8h]@1
  char v20; // [sp+1Ch] [bp-1C4h]@1
  unsigned int v21; // [sp+88h] [bp-158h]@12
  char v22; // [sp+8Ch] [bp-154h]@1
  unsigned int v23; // [sp+FCh] [bp-E4h]@12
  char v24; // [sp+104h] [bp-DCh]@19
  char v25; // [sp+140h] [bp-A0h]@21

  memset(&v20, 0, 0xE8u);
  v0 = 0;
  LOBYTE(v18) = 0;
  v1 = &v19;
  v2 = &dword_101134B0;
  v3 = &v22;
  do
  {
    LOBYTE(v4) = sub_10023110(v18);
    v5 = sub_10023300(v4, v3 - 112);
    *(_BYTE *)v1 = v5;
    if ( v5 )
    {
      if ( *(_DWORD *)v3 != v2[1] || *((_DWORD *)v3 - 1) != *(_BYTE *)v2 )
      {
        sub_100116A0(0);
        byte_101133F8 = 1;
      }
      v6 = *(v3 - 4);
      v2[1] = *(_DWORD *)v3;
      *(_BYTE *)v2 = v6;
    }
    ++v0;
    v1 = (int *)((char *)v1 + 1);
    v3 += 116;
    v2 += 2;
    LOBYTE(v18) = v0;
  }
  while ( v0 < 2u );
  sub_1004EEB0(54, &v17);
  if ( !byte_101133F8 || v17 )
    goto LABEL_13;
  byte_101133F8 = 1;
  if ( (_BYTE)v19 && BYTE1(v19) )
  {
    if ( v21 < 3 == v23 < 3 )
    {
LABEL_13:
      byte_101133F8 = 0;
      return;
    }
    if ( (unsigned __int8)sub_100036B0() )
    {
      byte_101133F8 = 0;
      sub_1001BF40(0x53u);
      sub_1001BF40(0x54u);
      v8 = sub_10023090(0);
      sub_10009A90(v8, 0);
      v16 = 0;
      v15 = sub_10023090(1);
LABEL_25:
      sub_10009A90(v15, v16);
      return;
    }
    if ( sub_1001A070(v7) != 1 )
      return;
    v9 = 0;
    v10 = 1;
    LOBYTE(v19) = 0;
    LOBYTE(v18) = 1;
    if ( v21 < v23 )
    {
      v9 = 1;
      v10 = 0;
      LOBYTE(v19) = 1;
      LOBYTE(v18) = 0;
    }
    v11 = 3 * (unsigned __int8)v9;
    if ( sub_10010C50(0, (unsigned __int16)word_10067818[3 * (unsigned __int8)v9], &v24) )
    {
      v12 = word_10067814[3 * (unsigned __int8)v10];
      byte_101133F8 = 0;
      sub_1001BF40(v12);
      v13 = v18;
LABEL_24:
      v16 = 0;
      v15 = sub_10023090(v13);
      goto LABEL_25;
    }
    if ( sub_10010C50(1, (unsigned __int16)word_10067816[3 * (unsigned __int8)v10], &v25) && !sub_10022420((int)&v25) )
    {
      v14 = word_10067814[v11];
      byte_101133F8 = 0;
      sub_1001BF40(v14);
      v13 = v19;
      goto LABEL_24;
    }
  }
}
// 100036B0: using guessed type int sub_100036B0(void);
// 10067814: using guessed type __int16 word_10067814[];
// 10067816: using guessed type __int16 word_10067816[];
// 10067818: using guessed type __int16 word_10067818[];
// 101133F8: using guessed type char byte_101133F8;
// 101134B0: using guessed type int dword_101134B0;

//----- (10003A70) --------------------------------------------------------
char __cdecl sub_10003A70(int a1)
{
  unsigned __int8 v1; // si@1
  unsigned int v2; // eax@1
  char v3; // al@3
  char v4; // bl@3
  int v5; // esi@7
  char v6; // si@14
  char v8; // [sp+Bh] [bp-81h]@1
  int v9; // [sp+Ch] [bp-80h]@1
  int v10; // [sp+10h] [bp-7Ch]@3
  char v11; // [sp+14h] [bp-78h]@9

  LOBYTE(v9) = sub_100237A0(a1);
  v1 = v9;
  LOBYTE(v2) = sub_100233C0(v9, (bool *)&v8);
  if ( (_BYTE)v2 && v8 )
  {
    v3 = sub_100237E0(v1);
    v4 = v3;
    LOBYTE(v10) = v3;
    if ( v3 == 6 || v3 == 7 )
      sub_10003830();
    LOBYTE(v2) = sub_100036B0();
    if ( (_BYTE)v2 )
    {
      v5 = (unsigned __int8)v9;
      if ( (unsigned __int8)byte_10113400[(unsigned __int8)v9] < 3u && (unsigned __int8)v4 < 0x43u )
      {
        LOBYTE(v2) = sub_10010C50(2, a1, &v11);
        if ( (_BYTE)v2 )
        {
          v2 = sub_10023740(&v11);
          if ( !v2 )
          {
            LOBYTE(v2) = sub_10003660((int)&v11);
            if ( (_BYTE)v2 )
            {
              byte_10113400[v5] = 3;
            }
            else if ( (unsigned __int8)++byte_10113400[v5] >= 3u )
            {
              v6 = v10;
              sub_10009A90(v10, 0);
              LOBYTE(v2) = sub_1001C180(v6);
            }
          }
        }
      }
    }
  }
  return v2;
}
// 100036B0: using guessed type int sub_100036B0(void);

//----- (10003BC0) --------------------------------------------------------
char __thiscall sub_10003BC0(void *this)
{
  void *v1; // ecx@1
  char result; // al@1
  void *v3; // ecx@1
  signed int v4; // esi@2
  char v5; // al@3
  bool v6; // zf@3
  void *v7; // [sp+0h] [bp-4h]@1

  v7 = this;
  byte_101134C3 = sub_1001A070(this);
  result = sub_10019D90(v1);
  byte_101134C2 = result;
  if ( !byte_10113548 )
  {
    v4 = 0;
    do
    {
      v5 = sub_10019900(v3);
      sub_10019A40(v5, v4, (int)&v7);
      result = (char)v7;
      v6 = (_BYTE)v7 == 2;
      byte_101134C0[v4] = (char)v7;
      if ( v6
        || result == 4
        || result == 6
        || result == 8
        || result == 9
        || result == 10
        || result == 11
        || result == 3
        || result == 5
        || result == 12
        || result == 13
        || result == 14
        || result == 15
        || result == 16
        || result == 17
        || result == 18 )
      {
        result = sub_10002260(v4, result);
      }
      ++v4;
    }
    while ( v4 < 2 );
    byte_10113548 = 1;
  }
  return result;
}
// 101134C2: using guessed type char byte_101134C2;
// 101134C3: using guessed type char byte_101134C3;
// 10113548: using guessed type char byte_10113548;

//----- (10003C60) --------------------------------------------------------
char __cdecl sub_10003C60(char a1)
{
  void *v1; // ecx@0
  char v2; // al@2
  bool v3; // zf@2
  char result; // al@2
  void *v5; // [sp-2h] [bp-4h]@1

  v5 = v1;
  BYTE3(v5) = 1;
  if ( sub_1001A070(v1) == 2
    || (v2 = sub_10019940(a1), v3 = (unsigned __int8)sub_10009800(v2, (char *)&v5 + 3) == 0, result = 1, !v3) )
  {
    result = BYTE3(v5);
  }
  return result;
}
// 10009800: using guessed type _DWORD __cdecl sub_10009800(char, _DWORD);

//----- (10003CA0) --------------------------------------------------------
char __usercall sub_10003CA0@<al>(int a1@<eax>)
{
  int v1; // ST10_4@1

  LOWORD(v1) = *(_WORD *)(a1 + 34);
  BYTE2(v1) = *(_BYTE *)(a1 + 38);
  BYTE3(v1) = *(_BYTE *)(a1 + 40);
  return sub_1001EBF0(*(_BYTE *)(a1 + 41), *(_BYTE *)(a1 + 39), v1, 1);
}

//----- (10003CE0) --------------------------------------------------------
char sub_10003CE0()
{
  char result; // al@2
  char v1; // [sp+0h] [bp-30h]@3

  if ( sub_10023890((int)&dword_102364E0) )
  {
    memset(&v1, 0, 0x2Cu);
    sub_10023820((int)&dword_102364E0, &v1);
    sub_10003CA0((int)&v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 102364E0: using guessed type int dword_102364E0;

//----- (10003D50) --------------------------------------------------------
char __fastcall sub_10003D50(void *a1)
{
  int v1; // esi@3
  char v2; // al@4
  int v3; // esi@8
  int v4; // eax@9
  void *v6; // [sp+0h] [bp-4h]@1

  v6 = a1;
  if ( byte_101134C3 == 2 )
    sub_10003BC0(a1);
  v1 = 0;
  while ( 1 )
  {
    v2 = sub_10019900(a1);
    sub_10019A40(v2, v1, (int)&v6);
    LOBYTE(a1) = byte_101134C0[v1];
    if ( (_BYTE)a1 != (_BYTE)v6 )
      break;
    if ( ++v1 >= 2 )
      goto LABEL_8;
  }
  byte_10113548 = 0;
  sub_10003BC0(a1);
LABEL_8:
  v3 = 0;
  do
  {
    v4 = (unsigned __int8)byte_101134C0[v3];
    switch ( v4 )
    {
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
        LOBYTE(v4) = sub_10003C60(byte_101134C0[v3]);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_10003010(v3, byte_101134C0[v3]);
        break;
      default:
        break;
    }
    ++v3;
  }
  while ( v3 < 2 );
  return v4;
}
// 101134C3: using guessed type char byte_101134C3;
// 10113548: using guessed type char byte_10113548;

//----- (10003E10) --------------------------------------------------------
char __usercall sub_10003E10@<al>(int a1@<eax>)
{
  unsigned int v1; // eax@1
  char result; // al@6

  v1 = *(_DWORD *)(a1 + 4);
  if ( v1 > 0x1A70 )
  {
    if ( v1 - 9936 > 3 )
      return sub_1001B780("..\\lib\\adl\\iop_a_main.c", 1238, 0, 0);
    result = sub_10011530(v1);
  }
  else
  {
    if ( v1 < 0x1A6F )
    {
      if ( v1 == 6005 )
        return sub_1000F870();
      if ( v1 <= 0x17CE || v1 > 0x17D1 )
        return sub_1001B780("..\\lib\\adl\\iop_a_main.c", 1238, 0, 0);
    }
    result = sub_1000F8E0();
  }
  return result;
}

//----- (10003E70) --------------------------------------------------------
int sub_10003E70()
{
  int result; // eax@1
  signed int v1; // edi@7
  char *v2; // esi@7
  unsigned int v3; // eax@15
  int v4; // [sp-Ch] [bp-548h]@31
  char v5; // [sp-8h] [bp-544h]@31
  int v6; // [sp+Ch] [bp-530h]@1
  unsigned __int16 v7; // [sp+10h] [bp-52Ch]@1
  char v8[4]; // [sp+14h] [bp-528h]@7
  int v9; // [sp+18h] [bp-524h]@7
  int v10; // [sp+1Ch] [bp-520h]@20
  int v11; // [sp+20h] [bp-51Ch]@20
  int v12; // [sp+24h] [bp-518h]@84
  int v13; // [sp+28h] [bp-514h]@84
  unsigned __int16 v14; // [sp+2Ch] [bp-510h]@84
  int v15; // [sp+2Eh] [bp-50Eh]@84
  char v16[4]; // [sp+44h] [bp-4F8h]@22
  int v17; // [sp+A0h] [bp-49Ch]@20
  int v18; // [sp+A4h] [bp-498h]@20
  int v19; // [sp+A8h] [bp-494h]@20
  int v20; // [sp+ACh] [bp-490h]@20
  unsigned __int16 v21; // [sp+4F0h] [bp-4Ch]@80
  int v22; // [sp+4F2h] [bp-4Ah]@80
  size_t v23; // [sp+530h] [bp-Ch]@26

  result = sub_1004E460((int)&v7, (int)&v6);
  if ( result != 1 )
  {
    while ( (signed int)v7 <= 32769 )
    {
      if ( (signed int)v7 >= 0x8000 )
      {
        if ( v7 == -32767 )
        {
          v1 = *(_DWORD *)v8;
          v2 = (char *)&v9;
        }
        else
        {
          v2 = v8;
          v1 = (HIWORD(v9) + 15) & 0xFFFFFFFC;
        }
        do
        {
          if ( v2[4] )
            sub_1000ED20(
              *((_WORD *)v2 + 1),
              *((_WORD *)v2 + 3),
              v2[1],
              (int)&byte_10236500,
              v2 + 12,
              *((_DWORD *)v2 + 2));
          else
            sub_1000EA10(*((_WORD *)v2 + 1), v2[1], (int)&byte_10236500, v2 + 12, *((_DWORD *)v2 + 2));
          if ( *v2 == 1 && *(_DWORD *)(52 * *(_WORD *)(dword_10236528 + 2 * *((_WORD *)v2 + 1)) + dword_10236520 + 36) )
            (*(void (__cdecl **)(_DWORD, char *))(52 * *(_WORD *)(dword_10236528 + 2 * *((_WORD *)v2 + 1))
                                                + dword_10236520
                                                + 36))(
              *((_WORD *)v2 + 1),
              &byte_10236500);
          v3 = (*((_WORD *)v2 + 3) + 15) & 0xFFFFFFFC;
          v2 += v3;
          v1 -= v3;
        }
        while ( *((_WORD *)v2 + 3) && v1 > 0 );
      }
      else
      {
        if ( v7 != 1 )
          goto LABEL_85;
        sub_10003E10((int)&v7);
      }
LABEL_87:
      result = sub_1004E460((int)&v7, (int)&v6);
      if ( result == 1 )
        return result;
    }
    switch ( v7 )
    {
      case 0x8002u:
        sub_1000F010(*(int *)v8, v9, (int)&byte_10236500);
        goto LABEL_87;
      case 0x8006u:
        sub_10014450(v20, v9, v8[0], v10, (const char *)&v11, v17, v18, *(__int16 *)&v8[2], v19);
        goto LABEL_87;
      case 0x8007u:
        sub_100135A0(1);
        sub_10023A90((int)&v7);
        sub_10023AA0((int)&v7);
        sub_10023AC0((int)&v7);
        goto LABEL_87;
      case 0x8008u:
        sub_1000D760(v8[0], *(int *)&v8[1], &v9, 44, v16[0]);
        goto LABEL_87;
      case 0x800Bu:
        sub_1000FE00();
        goto LABEL_87;
      case 0x8011u:
        sub_10010FE0(v8[0], (int)&byte_10236500);
        goto LABEL_87;
      case 0x8013u:
        switch ( v8[1] )
        {
          case 0x11:
          case 0x1F:
            sub_10008BD0(v8[0], *(int *)&v8[1], *(int *)&v8[2], *(int *)&v8[3], (int)&v9, (char *)&v9 + 3, v23);
            goto LABEL_87;
          case 8:
          case 9:
          case 0xA:
          case 0xB:
          case 0xC:
          case 0xD:
          case 0xE:
          case 0x13:
          case 0x20:
          case 0x22:
          case 0x23:
          case 0x24:
          case 0x25:
          case 0x2A:
          case 0x32:
            if ( v6 != 31 && v6 != 48 && v6 != 32 )
              goto LABEL_30;
            v5 = 0;
            v4 = 1488;
            goto LABEL_86;
          case 0xF:
          case 0x10:
          case 0x19:
          case 0x1A:
          case 0x2B:
          case 0x30:
          case 0x31:
          case 0x37:
          case 0x38:
            if ( v6 != 31 && v6 != 48 && v6 != 32 && v6 != 30 && v6 != 1 && v6 != 9 )
              goto LABEL_30;
            v5 = 0;
            v4 = 1527;
            goto LABEL_86;
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 0x12:
          case 0x14:
          case 0x15:
          case 0x16:
          case 0x17:
          case 0x18:
          case 0x1B:
          case 0x1C:
          case 0x1D:
          case 0x1E:
          case 0x21:
          case 0x26:
          case 0x27:
          case 0x28:
          case 0x29:
          case 0x2C:
          case 0x2D:
          case 0x2E:
          case 0x2F:
          case 0x33:
          case 0x34:
          case 0x35:
          case 0x36:
          case 0x3F:
          case 0x40:
          case 0x41:
          case 0x42:
            if ( v6 != 31 && v6 != 48 && v6 != 32 && v6 != 30 && v6 != 1 && v6 != 9 && v6 != 29 )
            {
LABEL_30:
              sub_10008BD0(v8[0], *(int *)&v8[1], *(int *)&v8[2], *(int *)&v8[3], (int)&v9, (char *)&v9 + 3, v23);
              goto LABEL_87;
            }
            v5 = 0;
            v4 = 1592;
            break;
          default:
            v5 = 0;
            v4 = 1598;
            goto LABEL_86;
        }
        goto LABEL_86;
      case 0x8014u:
        if ( v6 == 3 || v6 == 1 )
        {
          v5 = 0;
          v4 = 1756;
        }
        else
        {
          switch ( v8[0] )
          {
            case 0x11:
            case 0x1F:
              sub_100083A0(v8[0], v8[1]);
              goto LABEL_87;
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
            case 0xD:
            case 0xE:
            case 0x13:
            case 0x20:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x2A:
            case 0x32:
            case 0x3C:
            case 0x3D:
            case 0x3E:
              if ( v6 != 31 && v6 != 48 && v6 != 32 )
              {
                sub_100083A0(v8[0], v8[1]);
                goto LABEL_87;
              }
              v5 = 0;
              v4 = 1663;
              goto LABEL_86;
            case 0xF:
            case 0x10:
            case 0x19:
            case 0x1A:
            case 0x2B:
            case 0x30:
            case 0x31:
            case 0x37:
            case 0x38:
            case 0x3A:
            case 0x3B:
              if ( v6 != 31 && v6 != 48 && v6 != 32 && v6 != 30 && v6 != 9 )
              {
                sub_100083A0(v8[0], v8[1]);
                goto LABEL_87;
              }
              v5 = 0;
              v4 = 1697;
              goto LABEL_86;
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x26:
            case 0x28:
            case 0x29:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x33:
            case 0x34:
            case 0x39:
            case 0x3F:
            case 0x40:
            case 0x41:
            case 0x42:
              if ( v6 != 31 && v6 != 48 && v6 != 32 && v6 != 30 && v6 != 9 && v6 != 29 )
              {
                sub_100083A0(v8[0], v8[1]);
                goto LABEL_87;
              }
              v5 = 0;
              v4 = 1743;
              break;
            default:
              v5 = 0;
              v4 = 1749;
              goto LABEL_86;
          }
        }
        goto LABEL_86;
      case 0x8018u:
        sub_100036C0(v8[0]);
        goto LABEL_87;
      case 0x8019u:
        sub_10003A70(*(int *)v8);
        goto LABEL_87;
      case 0x802Cu:
        sub_100238C0((int)&dword_102364E0, v8);
        goto LABEL_87;
      case 0x803Eu:
        sub_10012850(v8[0], v8[1], v8[2]);
        goto LABEL_87;
      case 0x8041u:
        sub_10002250(0);
        goto LABEL_87;
      case 0x803Au:
        sub_100122A0(v8[0], *(__int16 *)&v8[2], v9);
        goto LABEL_87;
      case 0x803Bu:
        sub_100121A0(v8, v21, v22);
        goto LABEL_87;
      case 0x8039u:
        sub_10011740(v8[0], &v8[1]);
        goto LABEL_87;
      case 0x803Fu:
        sub_1000F8F0(*(int *)v8, (int)&v9 + 2, v9, 1, 1);
        goto LABEL_87;
      case 0x8047u:
        sub_10008190(*(int *)v8, v9, v10);
        goto LABEL_87;
      case 0x8048u:
        sub_10007FE0(*(int *)v8, v9, v10, v11, v12, v13, v14, v15);
        goto LABEL_87;
      default:
        break;
    }
LABEL_85:
    v5 = 0;
    v4 = 1852;
LABEL_86:
    sub_1001B780("..\\lib\\adl\\iop_a_main.c", v4, v5, 0);
    goto LABEL_87;
  }
  return result;
}
// 102364E0: using guessed type int dword_102364E0;
// 10236500: using guessed type char byte_10236500;
// 10236520: using guessed type int dword_10236520;
// 10236528: using guessed type int dword_10236528;

//----- (10004580) --------------------------------------------------------
void __thiscall sub_10004580(void *this)
{
  void *v1; // ecx@1
  void *v2; // ecx@2
  char v3; // al@3
  int v4; // esi@3
  int *v5; // edi@3
  int v6; // [sp+0h] [bp-1Ch]@1
  int v7; // [sp+4h] [bp-18h]@1
  int v8; // [sp+8h] [bp-14h]@1
  int v9; // [sp+Ch] [bp-10h]@1
  int v10; // [sp+10h] [bp-Ch]@1
  int v11; // [sp+14h] [bp-8h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  if ( sub_10019D90(this) == 1 && sub_10019D90(v1) == 1 )
  {
    v3 = sub_10019900(v2);
    sub_10019260(v3, (int)&v6);
    v4 = 0;
    v5 = &v9;
    do
    {
      sub_10007ED0(v4++, (int)v5);
      ++v5;
    }
    while ( v4 <= 1 );
  }
}

//----- (10004600) --------------------------------------------------------
void __usercall __noreturn sub_10004600(const void *a1@<esi>)
{
  char v1; // bl@1
  void *v2; // ecx@1
  void *v3; // ecx@3
  const void *v4; // ecx@9
  char v5; // [sp+6h] [bp-EAh]@1
  char v6; // [sp+7h] [bp-E9h]@1
  char v7; // [sp+8h] [bp-E8h]@1
  char v8; // [sp+Ch] [bp-E4h]@1

  v1 = 20;
  sub_10023FE0();
  sub_10004580(v2);
  v5 = 4;
  v6 = 40;
  sub_1004E660(&v7);
  sub_10001000();
  sub_10023BE0(&v8);
  while ( 1 )
  {
    sub_1004E660(&v7);
    if ( v7 & 1 )
    {
      sub_10003CE0();
      sub_1000E280((int)&byte_10236500);
      sub_10003D50(v3);
      sub_1000E680((int)&byte_10236500);
      if ( --v1 <= 0 )
      {
        sub_1000F560((int)&byte_10236500);
        v1 = 20;
      }
      if ( --v6 <= 0 )
      {
        sub_10023AD0((int *)&v8);
        v6 = 40;
      }
      if ( --v5 <= 0 )
      {
        sub_10014D60();
        v5 = 4;
      }
      sub_10009470();
      sub_100143A0(v4, a1);
      sub_10008080();
      sub_100123B0();
    }
    if ( v7 & 2 )
      sub_10003E70();
  }
}
// 10023FE0: using guessed type int sub_10023FE0(void);
// 10236500: using guessed type char byte_10236500;

//----- (10004700) --------------------------------------------------------
void *sub_10004700()
{
  void *v0; // ecx@1

  byte_10113548 = 0;
  sub_10008DB0();
  sub_100125E0();
  sub_10008270();
  sub_1000FE20();
  sub_10009C10();
  sub_10003430();
  sub_1000AA20();
  sub_10024010();
  sub_1001B3E0();
  sub_100147B0();
  sub_10003BC0(v0);
  sub_10004BF0();
  dword_102364E0 = 1;
  dword_102364E4 = (int)&unk_10236560;
  dword_102364E8 = 16;
  dword_102364EC = 44;
  dword_102364F0 = 0;
  dword_102364F4 = -1;
  dword_101134C4 = sub_1004E440();
  return memset(&unk_101134C8, 0, 0x80u);
}
// 10008270: using guessed type int sub_10008270(void);
// 101134C4: using guessed type int dword_101134C4;
// 10113548: using guessed type char byte_10113548;
// 102364E0: using guessed type int dword_102364E0;
// 102364E4: using guessed type int dword_102364E4;
// 102364E8: using guessed type int dword_102364E8;
// 102364EC: using guessed type int dword_102364EC;
// 102364F0: using guessed type int dword_102364F0;
// 102364F4: using guessed type int dword_102364F4;

//----- (100047A0) --------------------------------------------------------
bool sub_100047A0()
{
  unsigned __int8 v0; // al@1
  void *v1; // ecx@1
  int v2; // eax@1
  unsigned __int8 v3; // al@1
  unsigned __int8 v4; // ST5C_1@1
  int v6; // [sp+4h] [bp-A4h]@1

  sub_1004E7C0(14010, (int)&v6, 160);
  sub_10001630((int)&v6);
  v0 = sub_100015C0(v6);
  sub_10024620(0, 0, (int)".\\test\\iop_a_sys_alert_test.c", (int)"101", (int)"Case 3012 set alert?.", v0, 0, 0);
  sub_1004E7C0(14010, (int)&v6, 160);
  v2 = sub_1001B4A0(v1);
  sub_10001670((int)&v6, v2);
  v3 = sub_100015C0(v6);
  sub_10024620(0, 0, (int)".\\test\\iop_a_sys_alert_test.c", (int)"117", (int)"Case 3013 set alert?.", v3, 0, 0);
  sub_10001600(10, 0, 1);
  v4 = sub_100015C0(10);
  return sub_10024620(
           0,
           0,
           (int)".\\test\\iop_a_sys_alert_test.c",
           (int)&unk_10068780,
           (int)"Case 3018 set alert?.",
           v4,
           0,
           0);
}

//----- (100048B0) --------------------------------------------------------
bool sub_100048B0()
{
  unsigned __int8 v0; // ST54_1@1
  unsigned __int8 v1; // al@1
  unsigned __int8 v2; // al@1
  void *v3; // ecx@1
  char v4; // al@1
  unsigned __int8 v5; // al@1
  unsigned __int8 v6; // al@1
  unsigned __int8 v7; // ST54_1@1

  v0 = sub_100015C0(10);
  sub_100018B0(10);
  sub_10024620(0, 0, (int)".\\test\\iop_a_sys_alert_test.c", (int)"165", (int)"Pre-case 3016 alert set?.", v0, 1u, 0);
  v1 = sub_100015C0(10);
  sub_10024620(0, 0, (int)".\\test\\iop_a_sys_alert_test.c", (int)"168", (int)"Post-case 3016 alert set?.", v1, 1u, 0);
  v2 = sub_100015C0(10);
  sub_10024620(0, 0, (int)".\\test\\iop_a_sys_alert_test.c", (int)"179", (int)"Pre-case 3017 alert set?.", v2, 1u, 0);
  v4 = sub_1001B4A0(v3);
  sub_100018F0(10, v4);
  v5 = sub_100015C0(10);
  sub_10024620(0, 0, (int)".\\test\\iop_a_sys_alert_test.c", (int)"184", (int)"Post-case 3017 alert set?.", v5, 1u, 0);
  v6 = sub_100015C0(10);
  sub_10024620(0, 0, (int)".\\test\\iop_a_sys_alert_test.c", (int)"195", (int)"Pre-case 3019 alert set?.", v6, 1u, 0);
  sub_10001600(10, 0, 0);
  v7 = sub_100015C0(10);
  return sub_10024620(
           0,
           0,
           (int)".\\test\\iop_a_sys_alert_test.c",
           (int)"200",
           (int)"Post-case 3019 alert set?.",
           v7,
           1u,
           0);
}

//----- (100049F0) --------------------------------------------------------
bool sub_100049F0()
{
  unsigned __int8 v0; // al@1
  unsigned __int8 v1; // ST54_1@1

  sub_10001860(255, 10, 5);
  v0 = sub_100015C0(10);
  sub_10024620(0, 0, (int)".\\test\\iop_a_sys_alert_test.c", (int)"235", (int)"Pre-case 3014 alert queued?.", v0, 1u, 0);
  v1 = sub_100015A0(10);
  return sub_10024620(
           0,
           0,
           (int)".\\test\\iop_a_sys_alert_test.c",
           (int)"238",
           (int)"Post-case 3014 alert acked?.",
           v1,
           0,
           0);
}

//----- (10004A60) --------------------------------------------------------
bool sub_10004A60()
{
  unsigned __int8 v0; // al@1
  unsigned __int8 v1; // ST48_1@1

  sub_10001780();
  v0 = sub_100015C0(10);
  sub_10024620(0, 0, (int)".\\test\\iop_a_sys_alert_test.c", (int)"273", (int)"Pre-case 3015 alert queued?.", v0, 1u, 0);
  v1 = sub_100015E0(10);
  return sub_10024620(
           0,
           0,
           (int)".\\test\\iop_a_sys_alert_test.c",
           (int)"276",
           (int)"Post-case 3015 alert viewed?.",
           v1,
           0,
           0);
}

//----- (10004AD0) --------------------------------------------------------
char **sub_10004AD0()
{
  return off_10068B50;
}
// 10068B50: using guessed type char *off_10068B50[3];

//----- (10004B00) --------------------------------------------------------
char __cdecl sub_10004B00(int a1)
{
  int v1; // ecx@0
  int v2; // eax@1
  int v3; // esi@2
  int v5; // [sp-2h] [bp-4h]@1

  v5 = v1;
  v2 = sub_1001DC80(&a1, 2u, (int)&unk_10069090, 6, 4, -1);
  if ( v2 != -1 )
  {
    v3 = 3 * v2;
    LOBYTE(v2) = sub_10028D70(byte_10069092[6 * v2]);
    if ( (_BYTE)v2 )
    {
      LOBYTE(v2) = sub_10010C50(6, a1, (char *)&v5 + 3);
      if ( (_BYTE)v2 )
      {
        if ( BYTE3(v5) )
          LOBYTE(v2) = sub_1001BE10(word_10069094[v3]);
        else
          LOBYTE(v2) = sub_1001BF40(word_10069094[v3]);
      }
    }
  }
  return v2;
}
// 10069094: using guessed type __int16 word_10069094[];

//----- (10004B80) --------------------------------------------------------
char __cdecl sub_10004B80(int a1, int a2)
{
  char result; // al@2
  signed __int16 v3; // si@3

  if ( (unsigned __int16)a1 == 27 )
  {
    result = byte_10113549;
    v3 = 176;
  }
  else
  {
    result = a1 - 28;
    if ( (unsigned __int16)a1 != 28 )
      return result;
    result = byte_1011354A;
    v3 = 177;
  }
  if ( result )
  {
    result = sub_1000F620(a1, a2, &a1);
    if ( result )
    {
      if ( a1 & 0x1000000 )
        result = sub_1001BF40(v3);
      else
        result = sub_1001BE10(v3);
    }
  }
  return result;
}
// 10113549: using guessed type char byte_10113549;
// 1011354A: using guessed type char byte_1011354A;

//----- (10004BF0) --------------------------------------------------------
char sub_10004BF0()
{
  void *v0; // ecx@1
  void *v1; // ecx@1
  int v2; // eax@2

  dword_102364C4 = sub_1004E4B0();
  if ( sub_1001B4A0(v0) == 1 )
  {
    LOBYTE(v2) = sub_1001B0B0(1);
  }
  else
  {
    v2 = sub_1001B4A0(v1);
    if ( v2 == 2 )
      LOBYTE(v2) = sub_1001B0B0(2);
  }
  return v2;
}
// 102364C4: using guessed type int dword_102364C4;

//----- (10004C20) --------------------------------------------------------
char __cdecl sub_10004C20(int a1, int a2)
{
  void *v2; // ecx@0
  char v3; // al@2
  int v4; // eax@2
  char result; // al@2
  char v6; // [sp+7h] [bp-1h]@1

  v6 = 3;
  if ( (unsigned int)(unsigned __int16)a1 - 17 > 1 )
  {
    result = sub_1001B780("..\\lib\\acl\\iop\\iop_ahrs_data.c", 142, 1, 0);
  }
  else
  {
    v3 = sub_10029030(v2);
    v6 = sub_10028FE0(v3, 1);
    v4 = sub_1004E4B0();
    result = sub_1000EA10(a1, 1, a2, &v6, v4);
  }
  return result;
}

//----- (10004C80) --------------------------------------------------------
char __cdecl sub_10004C80(int a1, int a2)
{
  void *v2; // ecx@0
  char v3; // al@2
  int v4; // eax@2
  char result; // al@2
  char v6; // [sp+7h] [bp-1h]@1

  v6 = 3;
  if ( (unsigned int)(unsigned __int16)a1 - 19 > 1 )
  {
    result = sub_1001B780("..\\lib\\adl\\iop_air_data.c", 167, 1, 0);
  }
  else
  {
    v3 = sub_10029030(v2);
    v6 = sub_10028FE0(v3, 0);
    v4 = sub_1004E4B0();
    result = sub_1000EA10(a1, 1, a2, &v6, v4);
  }
  return result;
}

//----- (10004CE0) --------------------------------------------------------
int __usercall sub_10004CE0@<eax>(unsigned __int16 a1@<ax>)
{
  return (unsigned __int16)word_10069318[4 * a1];
}
// 10069318: using guessed type __int16 word_10069318[];

//----- (10004CF0) --------------------------------------------------------
signed int __cdecl sub_10004CF0(unsigned __int16 a1, signed int a2, int a3)
{
  int v3; // ecx@0
  signed int result; // eax@1
  int v5; // esi@2
  int v6; // edx@4
  int v7; // ecx@4

  result = 0;
  if ( a2 <= 0 )
  {
LABEL_8:
    result = -1;
  }
  else
  {
    v5 = v3 + 4;
    while ( 1 )
    {
      if ( *(_WORD *)(v5 - 4) == a1 )
      {
        v6 = *(_WORD *)(v5 + 4);
        v7 = 0;
        if ( v6 > 0 )
          break;
      }
LABEL_7:
      ++result;
      v5 += 12;
      if ( result >= a2 )
        goto LABEL_8;
    }
    while ( *(_BYTE *)(a3 + dword_10069798[16 * a1]) != *(_BYTE *)(*(_DWORD *)v5 + v7) )
    {
      if ( ++v7 >= v6 )
        goto LABEL_7;
    }
  }
  return result;
}
// 10069798: using guessed type int dword_10069798[];

//----- (10004D50) --------------------------------------------------------
void __cdecl sub_10004D50(int a1)
{
  signed int v1; // esi@1
  int v2; // eax@2
  int v3; // ecx@2

  v1 = 0;
  do
  {
    v2 = sub_10004CE0(v1);
    sub_1004EEB0(v3, (_BYTE *)(a1 + v2));
    ++v1;
  }
  while ( v1 <= 118 );
}

//----- (10004D90) --------------------------------------------------------
char __cdecl sub_10004D90(int a1, char a2, int a3, int a4, char a5)
{
  int v5; // edi@1
  char v6; // bl@1
  int v7; // ebp@4
  signed int v8; // esi@7
  unsigned int v9; // eax@8
  unsigned int v10; // edi@8
  _DWORD *v11; // edx@10
  unsigned int v12; // eax@10
  const char *v13; // ecx@10
  int v14; // esi@14
  int v15; // eax@15
  _BYTE *v16; // ecx@15
  _BYTE *v17; // edx@15
  int v18; // eax@17
  _BYTE *v19; // ecx@17
  _BYTE *v20; // edx@17
  _BYTE *v21; // ecx@19
  _BYTE *v22; // edx@19
  signed int v23; // eax@21
  void *v24; // ecx@26
  signed int v26; // [sp+10h] [bp-54h]@7
  char v27; // [sp+14h] [bp-50h]@1

  v5 = a3;
  v6 = 0;
  memset(&v27, 0, 0x4Bu);
  if ( a2 || a5 || a4 != 1228 )
  {
    sub_1001B780("..\\lib\\adl\\iop_airframe_cnfg_ini_file_intf.c", 576, 0, 0);
    return 0;
  }
  v7 = 0;
  while ( !sub_10029DD0(a1, &aArfrm_feature[64 * v7], (int)&aArfrm_feature[64 * v7 + 30], (int)&v27, 75) )
  {
LABEL_32:
    if ( ++v7 >= 4 )
      return v6;
  }
  if ( !sub_10029A20(
          &v27,
          aArfrm_feature[64 * v7 + 55],
          v5 + *(_DWORD *)&aArfrm_feature[64 * v7 + 56],
          *(_DWORD *)&aArfrm_feature[64 * v7 + 60]) )
    return 0;
  v8 = sub_10004CF0(v7, 4, v5);
  v26 = v8;
  if ( v8 < 0 )
  {
    sub_1001B780("..\\lib\\adl\\iop_airframe_cnfg_ini_file_intf.c", 566, 0, 0);
LABEL_31:
    v5 = a3;
    v6 = 1;
    goto LABEL_32;
  }
  v9 = j_FIL_vfs_open(a1, 4, 1809);
  v10 = v9;
  if ( v9 >= 0xFFFFFFC2 || !v9 )
    goto LABEL_36;
  v11 = (_DWORD *)a1;
  v12 = 13;
  v13 = "/shr_mem/cfg/";
  do
  {
    if ( *v11 != *(_DWORD *)v13 )
      goto LABEL_14;
    v12 -= 4;
    v13 += 4;
    ++v11;
  }
  while ( v12 >= 4 );
  if ( !v12 )
  {
LABEL_23:
    v23 = 0;
    goto LABEL_24;
  }
LABEL_14:
  v14 = *(_BYTE *)v11 - *v13;
  if ( *(_BYTE *)v11 == *v13 )
  {
    v15 = v12 - 1;
    v16 = v13 + 1;
    v17 = (char *)v11 + 1;
    if ( !v15 )
      goto LABEL_23;
    v14 = *v17 - *v16;
    if ( *v17 == *v16 )
    {
      v18 = v15 - 1;
      v19 = v16 + 1;
      v20 = v17 + 1;
      if ( !v18 )
        goto LABEL_23;
      v14 = *v20 - *v19;
      if ( *v20 == *v19 )
      {
        v21 = v19 + 1;
        v22 = v20 + 1;
        if ( v18 == 1 )
          goto LABEL_23;
        v14 = *v22 - *v21;
        if ( *v22 == *v21 )
          goto LABEL_23;
      }
    }
  }
  v23 = 1;
  if ( v14 <= 0 )
    v23 = -1;
LABEL_24:
  if ( !v23 || !sub_100297D0(1u, v10) )
  {
    sub_1004EF10(v10);
    if ( v7 == 3 && sub_1001A050(v24) & 2 && v27 == 49 )
    {
      sub_1001B780(
        "..\\lib\\adl\\iop_airframe_cnfg_ini_file_intf.c",
        559,
        0,
        "Must use Tier 2 SVS Unlock card on a 2 PFD system");
      return 0;
    }
    goto LABEL_31;
  }
  v8 = v26;
LABEL_36:
  sub_1001B780("..\\lib\\adl\\iop_airframe_cnfg_ini_file_intf.c", 520, 0, 0);
  if ( v10 < 0xFFFFFFC2 && v10 )
    sub_1004EF10(v10);
  *(_BYTE *)(a3 + *(_DWORD *)&aArfrm_feature[64 * v7 + 56]) = byte_10069882[12 * v8];
  return 0;
}
// 1004F010: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10005060) --------------------------------------------------------
int __cdecl sub_10005060(int a1)
{
  signed int v1; // esi@1
  int v2; // eax@2
  int v3; // ecx@2
  int result; // eax@2

  v1 = 0;
  do
  {
    v2 = sub_10004CE0(v1);
    result = sub_1004EEE0(v3, a1 + v2);
    ++v1;
  }
  while ( v1 <= 118 );
  return result;
}

//----- (100050A0) --------------------------------------------------------
char __cdecl sub_100050A0(char a1, int a2)
{
  char v2; // bl@1
  char v4; // [sp+8h] [bp-4D0h]@1

  memset(&v4, 0, 0x4CCu);
  v2 = 0;
  if ( a1 )
  {
    sub_1001B780("..\\lib\\adl\\iop_airframe_cnfg_ini_file_intf.c", 326, 0, 0);
    goto LABEL_5;
  }
  sub_10015630();
  memcpy(&unk_10113560, dword_1022D6E8, 0x99D0u);
  sub_10004D50((int)&v4);
  v2 = sub_10004D90(a2, 0, (int)&v4, 1228, 0);
  if ( !v2 )
  {
LABEL_5:
    sub_10008470(8);
    return v2;
  }
  sub_10005060((int)&v4);
  sub_10008470(7);
  return v2;
}

//----- (10005170) --------------------------------------------------------
char __cdecl sub_10005170(int a1, int a2)
{
  int v2; // ebx@1
  char v3; // al@3
  char result; // al@3
  int v5; // [sp+4h] [bp-14h]@3
  int v6; // [sp+8h] [bp-10h]@1
  int v7; // [sp+Ch] [bp-Ch]@1
  int v8; // [sp+10h] [bp-8h]@1
  char v9[4]; // [sp+14h] [bp-4h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  *(_DWORD *)v9 = 0;
  v2 = sub_1000DEC0(a1, a2);
  if ( !(_BYTE)v2 || (unsigned __int8)sub_1001A0D0() )
  {
    result = sub_1001A0D0();
    if ( !result )
      result = sub_1001B780("..\\lib\\acl\\iop\\iop_alrt_data.c", 169, 0, 0);
  }
  else
  {
    v7 = v2;
    v9[0] = sub_10019650(v2);
    v6 = sub_1004E4B0();
    v3 = sub_10019760(v9[0], &v5);
    v8 = v3 != 0 ? v5 : 0;
    result = sub_1004E8F0(41098, (int)&v6, 16);
  }
  return result;
}

//----- (10005220) --------------------------------------------------------
char __cdecl sub_10005220(int a1, int a2)
{
  char result; // al@1
  char v3; // [sp+3h] [bp-9h]@1
  int v4; // [sp+4h] [bp-8h]@1
  __int16 v5; // [sp+8h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v3 = 1;
  LOWORD(v4) = -32766;
  result = sub_1000F620(a1, a2, &v3);
  if ( result )
  {
    if ( v3 )
    {
      result = v3 - 1;
      if ( v3 == 1 )
      {
        BYTE2(v4) = 1;
        result = sub_1004E5C0(37, (int)&v4, 1000, 1);
      }
    }
    else
    {
      BYTE2(v4) = 2;
      result = sub_1004E5C0(37, (int)&v4, 1000, 1);
    }
  }
  return result;
}

//----- (100052B0) --------------------------------------------------------
char __cdecl sub_100052B0(int a1, int a2)
{
  char result; // al@1
  int v3; // esi@2
  int v4; // eax@4
  int v5; // eax@5
  char v6; // [sp+7h] [bp-15h]@1
  int v7; // [sp+8h] [bp-14h]@1
  int v8; // [sp+Ch] [bp-10h]@1
  int v9; // [sp+10h] [bp-Ch]@1
  int v10; // [sp+14h] [bp-8h]@1
  __int16 v11; // [sp+18h] [bp-4h]@1

  v10 = 0;
  v11 = 0;
  v8 = 0;
  v7 = 1;
  v9 = 0;
  v6 = 1;
  result = sub_10001560(&v9);
  if ( result )
  {
    v3 = sub_1000DEC0(a1, a2);
    result = sub_1000F620(a1, a2, &v7);
    if ( result )
    {
      sub_1004EB00(9, &v8, (int)&unk_1006A128, 1, 0, 0);
      if ( v7 == v8 )
      {
        v6 = 1;
        v4 = sub_1004E4B0();
        sub_1000EA10(270, 1, (int)&byte_10236500, &v6, v4);
        sub_1000F010(270, v3, (int)&byte_10236500);
        LOWORD(v10) = -32766;
        BYTE2(v10) = 0;
        result = sub_1004E5C0(37, (int)&v10, 1000, 1);
      }
      else
      {
        v6 = 0;
        v5 = sub_1004E4B0();
        sub_1000EA10(270, 1, (int)&byte_10236500, &v6, v5);
        result = sub_1000F010(270, v3, (int)&byte_10236500);
      }
    }
  }
  return result;
}
// 10236500: using guessed type char byte_10236500;

//----- (100053D0) --------------------------------------------------------
char __cdecl sub_100053D0(__int16 a1)
{
  char result; // al@2
  int v2; // [sp+0h] [bp-8h]@1
  __int16 v3; // [sp+4h] [bp-4h]@1

  v2 = 0;
  v3 = 0;
  if ( a1 == 712 )
  {
    result = sub_10001560(0);
    if ( result )
    {
      LOWORD(v2) = -32764;
      result = sub_1004E5C0(37, (int)&v2, 1000, 1);
    }
  }
  else
  {
    result = sub_1001B780(
               "..\\lib\\acl\\iop\\iop_alrt_data.c",
               527,
               0,
               "iop_rx_alrt_mstr_taken() was called by an incorrect HSDB packet.");
  }
  return result;
}

//----- (10005440) --------------------------------------------------------
int __cdecl sub_10005440(int a1)
{
  return HWM_pvg_arnc_close(*(_DWORD *)(a1 + 12));
}
// 10050A8C: using guessed type int __cdecl HWM_pvg_arnc_close(_DWORD);

//----- (10005450) --------------------------------------------------------
bool __cdecl sub_10005450(unsigned __int16 a1, int a2, int a3, _DWORD *a4)
{
  unsigned int v4; // esi@1
  int v5; // edx@1
  int v6; // ebp@1

  *a4 = *(_DWORD *)(*(_DWORD *)(a3 + 24) + 8 * a1 + 4);
  v4 = *(_DWORD *)(*(_DWORD *)(a3 + 24) + 8 * a1);
  *(_BYTE *)a2 = 0;
  v5 = *(_DWORD *)(a3 + 16);
  *(_DWORD *)(a2 + 4) = v4;
  v6 = v5 + 24 * a1;
  if ( (unsigned int)a1 < *(_DWORD *)(a3 + 4)
    && sub_1004E4B0() < (unsigned int)(*a4 + *(_DWORD *)(v6 + 12))
    && (!*(_BYTE *)(v6 + 5) || !(BYTE1(v4) & 3) || (BYTE1(v4) & 3) == *(_BYTE *)(a3 + 28)) )
  {
    *(_BYTE *)a2 = *(&byte_1006A19C[10 * *(_BYTE *)(v6 + 8)] + ((v4 >> 29) & 3));
  }
  return *(_BYTE *)a2 == 1;
}

//----- (100054D0) --------------------------------------------------------
int __fastcall sub_100054D0(int a1, unsigned int a2)
{
  int result; // eax@1
  signed int i; // ecx@1

  result = 0;
  for ( i = 1; a2; a2 >>= 4 )
  {
    result += i * (a2 & 0xF);
    i *= 10;
  }
  return result;
}

//----- (10005500) --------------------------------------------------------
_BYTE *__usercall sub_10005500@<eax>(int a1@<esi>, int a2)
{
  _BYTE *result; // eax@1
  unsigned int v3; // edi@1
  int v4; // edx@2
  char v5; // bl@3

  result = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  v3 = 0;
  if ( *(_DWORD *)(a2 + 4) )
  {
    v4 = 0;
    do
    {
      v5 = 1 << (*(_BYTE *)(v4 + *(_DWORD *)(a2 + 16)) & 7);
      result = (_BYTE *)(a1 + (unsigned __int8)(*(_BYTE *)(v4 + *(_DWORD *)(a2 + 16)) >> 3));
      ++v3;
      v4 += 24;
      *result |= v5;
    }
    while ( v3 < *(_DWORD *)(a2 + 4) );
  }
  return result;
}

//----- (10005560) --------------------------------------------------------
int __fastcall sub_10005560(unsigned int a1)
{
  unsigned int v1; // ecx@1

  v1 = (((a1 >> 16) ^ a1) >> 8) ^ (a1 >> 16) ^ a1;
  return ((unsigned __int8)((((v1 >> 4) ^ v1) >> 2) ^ (v1 >> 4) ^ v1) ^ (unsigned __int8)(((((v1 >> 4) ^ v1) >> 2) ^ (v1 >> 4) ^ v1) >> 1)) & 1;
}

//----- (10005590) --------------------------------------------------------
bool __cdecl sub_10005590(unsigned __int16 a1, int a2, int a3, _DWORD *a4)
{
  unsigned int v4; // edi@1
  int v5; // esi@1
  int v6; // eax@7
  char v7; // bl@7
  unsigned int v8; // edi@7
  int v9; // ecx@9
  unsigned int v10; // edi@9
  int v11; // eax@12
  double v12; // st7@14
  bool result; // al@14
  int v14; // eax@19
  unsigned int v15; // ebx@19
  unsigned int v16; // edi@19
  int v17; // ecx@21
  int v18; // eax@24
  bool v19; // zf@34
  char v20; // [sp+14h] [bp+4h]@7
  signed int v21; // [sp+1Ch] [bp+Ch]@11
  signed int v22; // [sp+1Ch] [bp+Ch]@23

  *a4 = *(_DWORD *)(*(_DWORD *)(a3 + 24) + 8 * a1 + 4);
  v4 = *(_DWORD *)(*(_DWORD *)(a3 + 24) + 8 * a1);
  *(_BYTE *)a2 = 0;
  v5 = 24 * a1 + *(_DWORD *)(a3 + 16);
  if ( (unsigned int)a1 >= *(_DWORD *)(a3 + 4)
    || sub_1004E4B0() >= (unsigned int)(*a4 + *(_DWORD *)(v5 + 12))
    || *(_BYTE *)(v5 + 5) && BYTE1(v4) & 3 && (BYTE1(v4) & 3) != *(_BYTE *)(*(_DWORD *)(a3 + 16) + 24 * a1 + 1) )
  {
LABEL_36:
    result = *(_BYTE *)a2 == 1;
  }
  else
  {
    *(_BYTE *)a2 = *(&byte_1006A19C[10 * *(_BYTE *)(v5 + 8)] + ((v4 >> 29) & 3));
    switch ( *(_BYTE *)(v5 + 7) )
    {
      case 1:
        v6 = *(_BYTE *)(v5 + 3);
        v7 = *(_BYTE *)(v5 + 6);
        v20 = BYTE3(v4);
        v8 = v4 << (32 - v6);
        if ( !v7 || *(_BYTE *)(v5 + 4) )
        {
          v9 = *(_BYTE *)(v5 + 2) - v6 + 31;
          v10 = v8 >> v9;
        }
        else
        {
          v9 = *(_BYTE *)(v5 + 2) - v6 + 31;
          v10 = (signed int)v8 >> v9;
        }
        v21 = v10;
        if ( !*(_BYTE *)(v5 + 4) )
          goto LABEL_18;
        v11 = sub_100054D0(v9, v10);
        v21 = v11;
        if ( v7 )
        {
          if ( (v20 & 0x60) == 96 )
          {
            v12 = *(float *)(v5 + 16) * (double)-v11;
            result = *(_BYTE *)a2 == 1;
            *(float *)(a2 + 4) = v12;
            return result;
          }
        }
        else if ( *(_BYTE *)(v5 + 8) == 1 && (v20 & 0x60) == 96 )
        {
          *(_BYTE *)a2 = 0;
          v21 = 0;
        }
LABEL_18:
        result = *(_BYTE *)a2 == 1;
        *(float *)(a2 + 4) = *(float *)(v5 + 16) * (double)v21;
        return result;
      case 2:
        v14 = *(_BYTE *)(v5 + 3);
        v15 = v4 >> 24;
        v16 = v4 << (32 - v14);
        if ( !*(_BYTE *)(v5 + 6) || *(_BYTE *)(v5 + 4) )
        {
          v17 = *(_BYTE *)(v5 + 2) - v14 + 31;
          v4 = v16 >> v17;
        }
        else
        {
          v17 = *(_BYTE *)(v5 + 2) - v14 + 31;
          v4 = (signed int)v16 >> v17;
        }
        v22 = v4;
        if ( !*(_BYTE *)(v5 + 4) )
          goto LABEL_31;
        v18 = sub_100054D0(v17, v4);
        v4 = v18;
        v22 = v18;
        if ( *(_BYTE *)(v5 + 6) )
        {
          if ( (v15 & 0x60) != 96 )
            goto LABEL_31;
          v4 = -v18;
          goto LABEL_30;
        }
        if ( *(_BYTE *)(v5 + 8) == 1 && (v15 & 0x60) == 96 )
        {
          *(_BYTE *)a2 = 0;
          v4 = 0;
LABEL_30:
          v22 = v4;
        }
LABEL_31:
        if ( 0.0 == *(float *)(v5 + 16) )
        {
LABEL_34:
          v19 = *(_BYTE *)a2 == 1;
          *(_DWORD *)(a2 + 4) = v4;
          result = v19;
        }
        else
        {
          *(_DWORD *)(a2 + 4) = (signed int)((double)v22 * *(float *)(v5 + 16));
          result = *(_BYTE *)a2 == 1;
        }
        break;
      case 4:
        v4 = (signed int)v4 >> (*(_BYTE *)(v5 + 2) - 1) << (*(_BYTE *)(v5 + 2) - *(_BYTE *)(v5 + 3) + 31);
        goto LABEL_34;
      case 3:
        goto LABEL_34;
      default:
        *(_DWORD *)(a2 + 4) = v4;
        sub_1001B780("..\\lib\\acl\\iop\\a429\\iop_arnc.c", 582, 1, 0);
        goto LABEL_36;
    }
  }
  return result;
}

//----- (100057F0) --------------------------------------------------------
int __cdecl sub_100057F0(int a1)
{
  unsigned int v1; // eax@1
  bool v2; // zf@1
  int v3; // ecx@3
  int result; // eax@3
  char v5; // [sp+8h] [bp-2Ch]@3
  char v6; // [sp+28h] [bp-Ch]@3
  char v7; // [sp+29h] [bp-Bh]@3
  int v8; // [sp+2Ch] [bp-8h]@3

  sub_1004E560(0, -1);
  v1 = 0;
  v2 = *(_DWORD *)(a1 + 4) == 0;
  *(_DWORD *)(a1 + 8) = 0;
  if ( !v2 )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 24) + 8 * v1 + 4) = 0;
      *(_DWORD *)(*(_DWORD *)(a1 + 24) + 8 * v1++) = 0x20000000;
    }
    while ( v1 < *(_DWORD *)(a1 + 4) );
  }
  sub_1004E540(0);
  sub_10005500((int)&v5, a1);
  v3 = *(_DWORD *)(a1 + 20);
  v6 = *(_BYTE *)a1;
  v8 = v3;
  v7 = 1;
  result = j_HWM_pvg_arnc_open(&v5);
  *(_DWORD *)(a1 + 12) = result;
  return result;
}
// 1004F290: using guessed type int __cdecl j_HWM_pvg_arnc_open(_DWORD);

//----- (10005880) --------------------------------------------------------
int __cdecl sub_10005880(int a1)
{
  int v1; // eax@1
  int v2; // ebp@1
  int result; // eax@1
  unsigned __int16 v4; // di@1
  int v5; // eax@2
  int v6; // ebx@5
  int v7; // eax@6
  unsigned int v8; // ebp@8
  unsigned int v9; // eax@8
  int v10; // edi@9
  char v11; // dl@11
  int v12; // edi@15
  unsigned int v13; // [sp+10h] [bp-138h]@2
  int v14; // [sp+14h] [bp-134h]@1
  unsigned int v15; // [sp+18h] [bp-130h]@2
  int v16[75]; // [sp+1Ch] [bp-12Ch]@1

  v1 = sub_1004E4B0();
  v2 = v1;
  v14 = v1;
  result = j_HWM_pvg_arnc_read(v16, 75, *(_DWORD *)(a1 + 12));
  v4 = result;
  if ( (signed __int16)result > 0 )
  {
    sub_1004E560(0, -1);
    v5 = 0;
    v13 = 0;
    v15 = v4;
    if ( v4 )
    {
      while ( 1 )
      {
        v6 = v16[v5];
        if ( (unsigned __int8)sub_10005560(v16[v5]) )
        {
          v7 = *(_DWORD *)(a1 + 8);
          if ( !v7 || (unsigned int)(v2 - v7) > 0x3E8 )
          {
            v8 = *(_DWORD *)(a1 + 4);
            v9 = 0;
            if ( v8 )
            {
              v10 = *(_DWORD *)(a1 + 16);
              do
              {
                if ( (_BYTE)v6 == *(_BYTE *)v10 )
                {
                  v11 = *(_BYTE *)(v10 + 1);
                  if ( v11 == 4 || v11 == (BYTE1(v6) & 3) )
                    break;
                }
                ++v9;
                v10 += 24;
              }
              while ( v9 < v8 );
            }
            if ( v9 < v8 )
            {
              *(_DWORD *)(*(_DWORD *)(a1 + 24) + 8 * v9) = v6;
              *(_DWORD *)(*(_DWORD *)(a1 + 24) + 8 * v9 + 4) = v14;
              v12 = 24 * v9;
              if ( *(_DWORD *)(*(_DWORD *)(a1 + 16) + 24 * v9 + 20) )
              {
                sub_1004E540(0);
                (*(void (**)(void))(*(_DWORD *)(a1 + 16) + v12 + 20))();
                sub_1004E560(0, -1);
              }
            }
          }
        }
        else
        {
          *(_DWORD *)(a1 + 8) = v2;
        }
        v5 = v13++ + 1;
        if ( v13 >= v15 )
          break;
        v2 = v14;
      }
    }
    result = sub_1004E540(0);
  }
  return result;
}
// 1004F2A0: using guessed type int __cdecl j_HWM_pvg_arnc_read(_DWORD, _DWORD, _DWORD);
// 10005880: using guessed type int var_12C[75];

//----- (10005C90) --------------------------------------------------------
char __cdecl sub_10005C90(char a1)
{
  char result; // al@1
  int v2; // esi@3
  _WORD *v3; // edi@3
  signed int v4; // ebx@3
  bool v5; // al@6
  int v6; // edx@6
  bool v7; // al@6
  int v8; // edx@6
  bool v9; // al@6
  int v10; // edx@6
  bool v11; // al@6
  int v12; // edx@6
  bool v13; // al@6
  int v14; // edx@6
  bool v15; // al@6
  int v16; // edx@6
  bool v17; // al@6
  int v18; // edx@6
  bool v19; // al@6
  int v20; // edx@6
  bool v21; // al@6
  int v22; // edx@6
  bool v23; // al@6
  int v24; // edx@6
  bool v25; // al@6
  int v26; // edx@6
  bool v27; // al@6
  int v28; // edx@6
  bool v29; // al@6
  int v30; // edx@6
  bool v31; // al@6
  int v32; // edx@6
  bool v33; // al@6
  int v34; // edx@6
  bool v35; // al@6
  int v36; // edx@6
  bool v37; // al@6
  int v38; // edx@6
  bool v39; // al@6
  int v40; // edx@6
  bool v41; // al@6
  int v42; // edx@6
  bool v43; // al@6
  int v44; // edx@6
  bool v45; // al@6
  int v46; // edx@6
  bool v47; // al@6
  int v48; // edx@6
  bool v49; // al@6
  int v50; // edx@6
  bool v51; // al@6
  int v52; // edx@6
  bool v53; // al@6
  int v54; // edx@6
  bool v55; // al@6
  int v56; // edx@6
  bool v57; // al@6
  int v58; // edx@6
  bool v59; // al@6
  int v60; // edx@6
  bool v61; // al@6
  int v62; // edx@6
  bool v63; // al@6
  int v64; // edx@6
  int v65; // [sp+Ch] [bp-1Ch]@1
  int v66; // [sp+10h] [bp-18h]@6
  int v67; // [sp+14h] [bp-14h]@3
  int v68; // [sp+18h] [bp-10h]@3
  int v69; // [sp+1Ch] [bp-Ch]@1
  int v70; // [sp+20h] [bp-8h]@1

  v69 = 0;
  v70 = 0;
  v65 = 0;
  result = a1 - 5;
  if ( a1 == 5 )
  {
    v2 = dword_1011CF30;
    v3 = &unk_1006A698;
    v4 = 12;
    v67 = 106;
    v68 = 93;
  }
  else
  {
    result = a1 - 6;
    if ( a1 != 6 )
      return result;
    v2 = dword_1011CF30 + 304;
    v3 = &unk_1006A6E0;
    v4 = 13;
    v67 = 107;
    v68 = 94;
  }
  if ( *(_DWORD *)(v2 + 24) )
  {
    sub_10005880(v2);
    v5 = sub_10005590(0, (int)&v69, v2, &v65);
    v6 = *v3;
    LOBYTE(v66) = v5;
    sub_1000EA10(v6, v5, (int)&byte_10236500, &v70, v65);
    LOBYTE(v66) = sub_10005450(0, (int)&v69, v2, &v65);
    sub_1000EA10(v67, v66, (int)&byte_10236500, &v70, v65);
    v7 = sub_10005590(1u, (int)&v69, v2, &v65);
    v8 = v3[1];
    LOBYTE(v66) = v7;
    sub_1000EA10(v8, v7, (int)&byte_10236500, &v70, v65);
    v9 = sub_10005590(2u, (int)&v69, v2, &v65);
    v10 = v3[2];
    LOBYTE(v66) = v9;
    sub_1000EA10(v10, v9, (int)&byte_10236500, &v70, v65);
    v11 = sub_10005590(3u, (int)&v69, v2, &v65);
    v12 = v3[3];
    LOBYTE(v66) = v11;
    sub_1000EA10(v12, v11, (int)&byte_10236500, &v70, v65);
    v13 = sub_10005590(4u, (int)&v69, v2, &v65);
    v14 = v3[4];
    LOBYTE(v66) = v13;
    sub_1000EA10(v14, v13, (int)&byte_10236500, &v70, v65);
    v15 = sub_10005590(5u, (int)&v69, v2, &v65);
    v16 = v3[5];
    LOBYTE(v66) = v15;
    sub_1000EA10(v16, v15, (int)&byte_10236500, &v70, v65);
    v17 = sub_10005590(6u, (int)&v69, v2, &v65);
    v18 = v3[6];
    LOBYTE(v66) = v17;
    sub_1000EA10(v18, v17, (int)&byte_10236500, &v70, v65);
    LOBYTE(v66) = sub_10005450(6u, (int)&v69, v2, &v65);
    sub_1000EA10(v68, v66, (int)&byte_10236500, &v70, v65);
    v19 = sub_10005590(7u, (int)&v69, v2, &v65);
    v20 = v3[7];
    LOBYTE(v66) = v19;
    sub_1000EA10(v20, v19, (int)&byte_10236500, &v70, v65);
    v21 = sub_10005590(8u, (int)&v69, v2, &v65);
    v22 = v3[8];
    LOBYTE(v66) = v21;
    sub_1000EA10(v22, v21, (int)&byte_10236500, &v70, v65);
    v23 = sub_10005590(9u, (int)&v69, v2, &v65);
    v24 = v3[9];
    LOBYTE(v66) = v23;
    sub_1000EA10(v24, v23, (int)&byte_10236500, &v70, v65);
    v25 = sub_10005590(0xAu, (int)&v69, v2, &v65);
    v26 = v3[10];
    LOBYTE(v66) = v25;
    sub_1000EA10(v26, v25, (int)&byte_10236500, &v70, v65);
    v27 = sub_10005590(0xBu, (int)&v69, v2, &v65);
    v28 = v3[11];
    LOBYTE(v66) = v27;
    sub_1000EA10(v28, v27, (int)&byte_10236500, &v70, v65);
    v29 = sub_10005590(v4, (int)&v69, v2, &v65);
    v30 = v3[v4];
    LOBYTE(v66) = v29;
    sub_1000EA10(v30, v29, (int)&byte_10236500, &v70, v65);
    v31 = sub_10005590(0xEu, (int)&v69, v2, &v65);
    v32 = v3[14];
    LOBYTE(v66) = v31;
    sub_1000EA10(v32, v31, (int)&byte_10236500, &v70, v65);
    v33 = sub_10005590(0xFu, (int)&v69, v2, &v65);
    v34 = v3[15];
    LOBYTE(v66) = v33;
    sub_1000EA10(v34, v33, (int)&byte_10236500, &v70, v65);
    LOBYTE(v66) = sub_10005590(0x10u, (int)&v69, v2, &v65);
    sub_1000EA10(v3[16], v66, (int)&byte_10236500, &v70, v65);
    v35 = sub_10005590(0x11u, (int)&v69, v2, &v65);
    v36 = v3[17];
    LOBYTE(v66) = v35;
    sub_1000EA10(v36, v35, (int)&byte_10236500, &v70, v65);
    v37 = sub_10005590(0x12u, (int)&v69, v2, &v65);
    v38 = v3[18];
    LOBYTE(v66) = v37;
    sub_1000EA10(v38, v37, (int)&byte_10236500, &v70, v65);
    v39 = sub_10005590(0x13u, (int)&v69, v2, &v65);
    v40 = v3[19];
    LOBYTE(v66) = v39;
    sub_1000EA10(v40, v39, (int)&byte_10236500, &v70, v65);
    LOBYTE(v66) = sub_10005590(0x14u, (int)&v69, v2, &v65);
    sub_1000EA10(v3[20], v66, (int)&byte_10236500, &v70, v65);
    v41 = sub_10005590(0x15u, (int)&v69, v2, &v65);
    v42 = v3[21];
    LOBYTE(v66) = v41;
    sub_1000EA10(v42, v41, (int)&byte_10236500, &v70, v65);
    v43 = sub_10005590(0x16u, (int)&v69, v2, &v65);
    v44 = v3[22];
    LOBYTE(v66) = v43;
    sub_1000EA10(v44, v43, (int)&byte_10236500, &v70, v65);
    v45 = sub_10005590(0x17u, (int)&v69, v2, &v65);
    v46 = v3[23];
    LOBYTE(v66) = v45;
    sub_1000EA10(v46, v45, (int)&byte_10236500, &v70, v65);
    v47 = sub_10005590(0x18u, (int)&v69, v2, &v65);
    v48 = v3[24];
    LOBYTE(v66) = v47;
    sub_1000EA10(v48, v47, (int)&byte_10236500, &v70, v65);
    v49 = sub_10005590(0x19u, (int)&v69, v2, &v65);
    v50 = v3[25];
    LOBYTE(v66) = v49;
    sub_1000EA10(v50, v49, (int)&byte_10236500, &v70, v65);
    v51 = sub_10005590(0x1Au, (int)&v69, v2, &v65);
    v52 = v3[26];
    LOBYTE(v66) = v51;
    sub_1000EA10(v52, v51, (int)&byte_10236500, &v70, v65);
    v53 = sub_10005590(0x1Bu, (int)&v69, v2, &v65);
    v54 = v3[27];
    LOBYTE(v66) = v53;
    sub_1000EA10(v54, v53, (int)&byte_10236500, &v70, v65);
    v55 = sub_10005590(0x1Cu, (int)&v69, v2, &v65);
    v56 = v3[28];
    LOBYTE(v66) = v55;
    sub_1000EA10(v56, v55, (int)&byte_10236500, &v70, v65);
    LOBYTE(v66) = sub_10005590(0x1Du, (int)&v69, v2, &v65);
    sub_1000EA10(v3[29], v66, (int)&byte_10236500, &v70, v65);
    v57 = sub_10005590(0x1Eu, (int)&v69, v2, &v65);
    v58 = v3[30];
    LOBYTE(v66) = v57;
    sub_1000EA10(v58, v57, (int)&byte_10236500, &v70, v65);
    v59 = sub_10005590(0x1Fu, (int)&v69, v2, &v65);
    v60 = v3[31];
    LOBYTE(v66) = v59;
    sub_1000EA10(v60, v59, (int)&byte_10236500, &v70, v65);
    v61 = sub_10005590(0x20u, (int)&v69, v2, &v65);
    v62 = v3[32];
    LOBYTE(v66) = v61;
    sub_1000EA10(v62, v61, (int)&byte_10236500, &v70, v65);
    v63 = sub_10005590(0x21u, (int)&v69, v2, &v65);
    v64 = v3[33];
    LOBYTE(v66) = v63;
    result = sub_1000EA10(v64, v63, (int)&byte_10236500, &v70, v65);
  }
  return result;
}
// 1011CF30: using guessed type int dword_1011CF30;
// 10236500: using guessed type char byte_10236500;

//----- (10006480) --------------------------------------------------------
char __cdecl sub_10006480(char a1)
{
  char result; // al@1
  int v2; // esi@3
  const wchar_t *v3; // edi@3
  int v4; // ebx@3
  bool v5; // al@6
  int v6; // edx@6
  bool v7; // al@6
  int v8; // edx@6
  bool v9; // al@6
  int v10; // ebx@6
  bool v11; // al@6
  int v12; // ecx@6
  bool v13; // al@6
  int v14; // ecx@6
  bool v15; // al@6
  int v16; // ecx@6
  bool v17; // al@6
  int v18; // ecx@6
  bool v19; // al@6
  int v20; // ecx@6
  bool v21; // al@6
  int v22; // ecx@6
  bool v23; // al@6
  int v24; // ecx@6
  int v25; // [sp+Ch] [bp-1Ch]@1
  int v26; // [sp+13h] [bp-15h]@6
  bool v27; // [sp+17h] [bp-11h]@6
  int v28; // [sp+18h] [bp-10h]@3
  int v29; // [sp+1Ch] [bp-Ch]@1
  int v30; // [sp+20h] [bp-8h]@1

  v29 = 0;
  v30 = 0;
  v25 = 0;
  result = a1 - 3;
  if ( a1 == 3 )
  {
    v2 = dword_1011CF30;
    v3 = (const wchar_t *)&unk_1006A724;
    v4 = 23;
    v28 = 29;
  }
  else
  {
    result = a1 - 4;
    if ( a1 != 4 )
      return result;
    v2 = dword_1011CF30 + 304;
    v3 = L" &$\"*,.(LJ\x1C";
    v4 = 24;
    v28 = 30;
  }
  if ( *(_DWORD *)(v2 + 24) )
  {
    sub_10005880(v2);
    v5 = sub_10005590(0, (int)&v29, v2, &v25);
    v6 = *v3;
    LOBYTE(v26) = v5;
    sub_1000EA10(v6, v5, (int)&byte_10236500, &v30, v25);
    v7 = sub_10005590(1u, (int)&v29, v2, &v25);
    v8 = v3[1];
    LOBYTE(v26) = v7;
    sub_1000EA10(v8, v7, (int)&byte_10236500, &v30, v25);
    LOBYTE(v26) = sub_10005450(1u, (int)&v29, v2, &v25);
    v27 = (v30 & 0x400) == 1024;
    sub_1000EA10(v4, v26, (int)&byte_10236500, &v27, v25);
    sub_10004B00(v4);
    LOBYTE(v26) = sub_10005590(2u, (int)&v29, v2, &v25);
    sub_1000EA10(v3[2], v26, (int)&byte_10236500, &v30, v25);
    LOBYTE(v26) = sub_10005590(3u, (int)&v29, v2, &v25);
    sub_1000EA10(v3[3], v26, (int)&byte_10236500, &v30, v25);
    v9 = sub_10005450(3u, (int)&v29, v2, &v25);
    v10 = v28;
    LOBYTE(v26) = v9;
    v27 = (v30 & 0x400) == 1024;
    sub_1000EA10(v28, v9, (int)&byte_10236500, &v27, v25);
    sub_10004B00(v10);
    v11 = sub_10005590(4u, (int)&v29, v2, &v25);
    v12 = v3[4];
    LOBYTE(v26) = v11;
    sub_1000EA10(v12, v11, (int)&byte_10236500, &v30, v25);
    v13 = sub_10005590(5u, (int)&v29, v2, &v25);
    v14 = v3[5];
    LOBYTE(v26) = v13;
    sub_1000EA10(v14, v13, (int)&byte_10236500, &v30, v25);
    v15 = sub_10005590(6u, (int)&v29, v2, &v25);
    v16 = v3[6];
    LOBYTE(v26) = v15;
    sub_1000EA10(v16, v15, (int)&byte_10236500, &v30, v25);
    v17 = sub_10005590(7u, (int)&v29, v2, &v25);
    v18 = v3[7];
    LOBYTE(v26) = v17;
    sub_1000EA10(v18, v17, (int)&byte_10236500, &v30, v25);
    v19 = sub_10005590(8u, (int)&v29, v2, &v25);
    v20 = v3[8];
    LOBYTE(v26) = v19;
    sub_1000EA10(v20, v19, (int)&byte_10236500, &v30, v25);
    v21 = sub_10005590(9u, (int)&v29, v2, &v25);
    v22 = v3[9];
    LOBYTE(v26) = v21;
    sub_1000EA10(v22, v21, (int)&byte_10236500, &v30, v25);
    v23 = sub_10005590(0xAu, (int)&v29, v2, &v25);
    v24 = v3[10];
    LOBYTE(v26) = v23;
    result = sub_1000EA10(v24, v23, (int)&byte_10236500, &v30, v25);
  }
  return result;
}
// 1006A73C: using guessed type wchar_t a_Lj[10];
// 1011CF30: using guessed type int dword_1011CF30;
// 10236500: using guessed type char byte_10236500;

//----- (10006810) --------------------------------------------------------
signed int sub_10006810()
{
  if ( !sub_1004F780((LONG)&off_1006A754) )
    sub_1001B780("..\\lib\\adl\\iop_arnc_adc_frmt.c", 1315, 1, 0);
  return sub_1004F310((int)&off_1006A754);
}
// 1006A754: using guessed type char *off_1006A754;

//----- (10006B40) --------------------------------------------------------
char __cdecl sub_10006B40(char a1)
{
  char *v1; // eax@1
  int v2; // edi@2
  void *v3; // esi@2
  bool v4; // al@8
  int v5; // edx@8
  bool v6; // al@8
  int v7; // ecx@8
  bool v8; // al@8
  int v9; // edx@8
  bool v10; // al@8
  int v11; // ecx@8
  int v12; // ecx@8
  int v13; // ecx@8
  int v14; // ecx@8
  bool v15; // al@8
  int v16; // edx@8
  bool v17; // al@9
  bool v18; // al@10
  int v19; // edx@12
  unsigned __int16 v20; // ax@14
  unsigned __int16 v21; // ax@16
  bool v22; // al@18
  int v23; // ecx@18
  unsigned __int16 v24; // ax@18
  bool v25; // al@19
  int v26; // edx@19
  unsigned __int16 v27; // ax@20
  int v29; // [sp+Ch] [bp-1Ch]@1
  int v30; // [sp+10h] [bp-18h]@8
  int v31; // [sp+14h] [bp-14h]@1
  int v32; // [sp+18h] [bp-10h]@1
  int v33; // [sp+1Ch] [bp-Ch]@1
  int v34; // [sp+20h] [bp-8h]@1

  v1 = 0;
  v33 = 0;
  v34 = 0;
  v31 = 0;
  v32 = 0;
  v29 = 0;
  switch ( a1 )
  {
    case 1:
    case 7:
      v2 = dword_1011CF34;
      v3 = &unk_1006AAF0;
      goto LABEL_7;
    case 2:
    case 8:
      v3 = &unk_1006AB38;
      goto LABEL_6;
    case 9:
      v2 = dword_1011CF34;
      v3 = &unk_1006AB80;
      goto LABEL_7;
    case 0xA:
      v3 = &unk_1006ABC8;
LABEL_6:
      v2 = dword_1011CF34 + 160;
LABEL_7:
      if ( *(_DWORD *)(v2 + 24) )
      {
        sub_10005880(v2);
        v4 = sub_10005590(*((_WORD *)v3 + 1), (int)&v33, v2, &v29);
        v5 = *(_WORD *)v3;
        LOBYTE(v30) = v4;
        sub_1000EA10(v5, v4, (int)&byte_10236500, &v34, v29);
        LOBYTE(v30) = sub_10005590(*((_WORD *)v3 + 3), (int)&v33, v2, &v29);
        sub_1000EA10(*((_WORD *)v3 + 2), v30, (int)&byte_10236500, &v34, v29);
        v6 = sub_10005590(*((_WORD *)v3 + 5), (int)&v33, v2, &v29);
        v7 = *((_WORD *)v3 + 4);
        LOBYTE(v30) = v6;
        sub_1000EA10(v7, v6, (int)&byte_10236500, &v34, v29);
        v8 = sub_10005590(*((_WORD *)v3 + 7), (int)&v33, v2, &v29);
        v9 = *((_WORD *)v3 + 6);
        LOBYTE(v30) = v8;
        sub_1000EA10(v9, v8, (int)&byte_10236500, &v34, v29);
        LOBYTE(v30) = sub_10005590(*((_WORD *)v3 + 9), (int)&v33, v2, &v29);
        sub_1000EA10(*((_WORD *)v3 + 8), v30, (int)&byte_10236500, &v34, v29);
        v10 = sub_10005590(*((_WORD *)v3 + 11), (int)&v33, v2, &v29);
        v11 = *((_WORD *)v3 + 10);
        LOBYTE(v30) = v10;
        sub_1000EA10(v11, v10, (int)&byte_10236500, &v34, v29);
        LOBYTE(v30) = sub_10005590(*((_WORD *)v3 + 13), (int)&v33, v2, &v29);
        v12 = *((_WORD *)v3 + 12);
        v34 = 32 * (v34 / 45);
        sub_1000EA10(v12, v30, (int)&byte_10236500, &v34, v29);
        LOBYTE(v30) = sub_10005590(*((_WORD *)v3 + 15), (int)&v33, v2, &v29);
        v13 = *((_WORD *)v3 + 14);
        v34 = 32 * (v34 / 45);
        sub_1000EA10(v13, v30, (int)&byte_10236500, &v34, v29);
        LOBYTE(v30) = sub_10005590(*((_WORD *)v3 + 17), (int)&v33, v2, &v29);
        v14 = *((_WORD *)v3 + 16);
        v34 = 32 * (v34 / 45);
        sub_1000EA10(v14, v30, (int)&byte_10236500, &v34, v29);
        v15 = sub_10005590(*((_WORD *)v3 + 19), (int)&v33, v2, &v29);
        v16 = *((_WORD *)v3 + 18);
        LOBYTE(v30) = v15;
        LOBYTE(v1) = sub_1000EA10(v16, v15, (int)&byte_10236500, &v34, v29);
        switch ( a1 )
        {
          case 1:
          case 2:
          case 7:
          case 8:
            v17 = sub_10005590(0xAu, (int)&v33, v2, &v29);
            v31 = v34;
            if ( !v17 || (v18 = sub_10005590(0xBu, (int)&v33, v2, &v29), LOBYTE(v30) = 1, !v18) )
              LOBYTE(v30) = 0;
            v19 = *((_WORD *)v3 + 20);
            v32 = v34;
            sub_1000EA10(v19, v30, (int)&byte_10236500, &v31, v29);
            sub_1000D3C0(*((_WORD *)v3 + 20));
            goto LABEL_14;
          case 9:
          case 0xA:
            LOBYTE(v30) = sub_10005590(0xAu, (int)&v33, v2, &v29);
            sub_1000EA10(*((_WORD *)v3 + 20), v30, (int)&byte_10236500, &v34, v29);
            sub_10011100(*((_WORD *)v3 + 20), (int)&byte_10236500);
            sub_10011100(*((_WORD *)v3 + 34), (int)&byte_10236500);
LABEL_14:
            v20 = *((_WORD *)v3 + 25);
            if ( v20 != -1 )
            {
              LOBYTE(v30) = sub_10005590(v20, (int)&v33, v2, &v29);
              sub_1000EA10(*((_WORD *)v3 + 24), v30, (int)&byte_10236500, &v34, v29);
            }
            v21 = *((_WORD *)v3 + 27);
            if ( v21 != -1 )
            {
              LOBYTE(v30) = sub_10005590(v21, (int)&v33, v2, &v29);
              sub_1000EA10(*((_WORD *)v3 + 26), v30, (int)&byte_10236500, &v34, v29);
            }
            v22 = sub_10005590(*((_WORD *)v3 + 29), (int)&v33, v2, &v29);
            v23 = *((_WORD *)v3 + 28);
            LOBYTE(v30) = v22;
            sub_1000EA10(v23, v22, (int)&byte_10236500, &v34, v29);
            v24 = *((_WORD *)v3 + 31);
            if ( v24 != -1 )
            {
              v25 = sub_10005590(v24, (int)&v33, v2, &v29);
              v26 = *((_WORD *)v3 + 30);
              LOBYTE(v30) = v25;
              sub_1000EA10(v26, v25, (int)&byte_10236500, &v34, v29);
            }
            v27 = *((_WORD *)v3 + 33);
            if ( v27 != -1 )
            {
              LOBYTE(v30) = sub_10005590(v27, (int)&v33, v2, &v29);
              sub_1000EA10(*((_WORD *)v3 + 32), v30, (int)&byte_10236500, &v34, v29);
            }
            LOWORD(v1) = *((_WORD *)v3 + 35);
            if ( (_WORD)v1 != -1 )
            {
              LOBYTE(v30) = sub_10005590((unsigned __int16)v1, (int)&v33, v2, &v29);
              LOBYTE(v1) = sub_1000EA10(*((_WORD *)v3 + 34), v30, (int)&byte_10236500, &v34, v29);
            }
            break;
          case 3:
          case 4:
          case 5:
          case 6:
            LOBYTE(v1) = sub_1001B780("..\\lib\\adl\\iop_arnc_ahrs_frmt.c", 768, 1, 0);
            break;
          default:
            goto LABEL_25;
        }
      }
      break;
    default:
LABEL_25:
      LOBYTE(v1) = sub_1001B780("..\\lib\\adl\\iop_arnc_ahrs_frmt.c", 523, 1, v1);
      break;
  }
  return (unsigned int)v1;
}
// 1011CF34: using guessed type int dword_1011CF34;
// 10236500: using guessed type char byte_10236500;

//----- (10007180) --------------------------------------------------------
signed int sub_10007180()
{
  dword_1011CF34 = -15;
  if ( !sub_1004F780((LONG)&off_1006AC10) )
    sub_1001B780("..\\lib\\adl\\iop_arnc_ahrs_frmt.c", 945, 1, 0);
  return sub_1004F310((int)&off_1006AC10);
}
// 1006AC10: using guessed type char *off_1006AC10;
// 1011CF34: using guessed type int dword_1011CF34;

//----- (10007190) --------------------------------------------------------
char __cdecl sub_10007190(int a1, int a2, int a3, int a4, char a5, char *a6)
{
  char result; // al@1

  result = 0;
  switch ( a5 )
  {
    case 0:
    case 7:
      strncpy(a6, &byte_100647C9, 0x64u);
      result = 1;
      break;
    case 5:
      strncpy(a6, "LOADING", 0x64u);
      result = 1;
      break;
    case 1:
    case 2:
    case 3:
    case 4:
    case 6:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
      strncpy(a6, byte_10120F40, 0x64u);
      result = 1;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10007210) --------------------------------------------------------
void *sub_10007210()
{
  byte_1011CF39 = 0;
  return memset(&unk_1011CF40, 0, 0x3FFCu);
}
// 1011CF39: using guessed type char byte_1011CF39;

//----- (10007230) --------------------------------------------------------
char __fastcall sub_10007230(int a1)
{
  char result; // al@1
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  result = sub_10009B50((_BYTE *)&v2 + 3);
  if ( result )
  {
    result = BYTE3(v2);
    if ( !BYTE3(v2) || BYTE3(v2) > 6u && BYTE3(v2) <= 9u )
      byte_1011CF39 = 0;
  }
  return result;
}
// 1011CF39: using guessed type char byte_1011CF39;

//----- (10007260) --------------------------------------------------------
char sub_10007260()
{
  char v0; // bl@1
  char v2; // [sp+7h] [bp-5h]@1
  int v3; // [sp+8h] [bp-4h]@5

  v0 = sub_100146C0(&v2);
  if ( v0 )
  {
    if ( v2 == 5 )
    {
      LOBYTE(v3) = 9;
      goto LABEL_8;
    }
    if ( v2 == 6 )
    {
      LOBYTE(v3) = 4;
      byte_1011CF38 = 3;
      dword_10120F3C = sub_1004E4B0();
      goto LABEL_8;
    }
    if ( v2 == 7 )
    {
      LOBYTE(v3) = 8;
LABEL_8:
      sub_10008470(v3);
      sub_1002A280();
      return v0;
    }
  }
  return v0;
}
// 1011CF38: using guessed type char byte_1011CF38;
// 10120F3C: using guessed type int dword_10120F3C;

//----- (100072D0) --------------------------------------------------------
char sub_100072D0()
{
  signed int v0; // esi@2
  void *v1; // ecx@2
  int v2; // ST10_4@3
  char result; // al@3

  if ( (unsigned __int8)byte_1011CF39 + 1 < 2 && (v0 = sub_100230D0(byte_1011CF39 + 1), v0 & sub_1001A050(v1)) )
  {
    v2 = (unsigned __int8)(byte_1011CF39++ + 1) + 1;
    _snprintf(byte_10120F40, 0x64u, "CONFIGURING GIA %d", v2);
    sub_10008470(1);
    result = 1;
  }
  else
  {
    _snprintf(byte_10120F40, 0x64u, "AUDIO MESSAGE CONFIGURATION UPLOAD COMPLETE");
    sub_10008470(7);
    result = 1;
  }
  return result;
}
// 1011CF39: using guessed type char byte_1011CF39;

//----- (10007350) --------------------------------------------------------
char sub_10007350()
{
  if ( (unsigned int)(sub_1004E4B0() - dword_10120F3C) > 0x3E8 )
    sub_10008470((unsigned __int8)byte_1011CF38);
  return 1;
}
// 1011CF38: using guessed type char byte_1011CF38;
// 10120F3C: using guessed type int dword_10120F3C;

//----- (10007380) --------------------------------------------------------
char sub_10007380()
{
  unsigned __int8 v0; // bl@1
  char v2; // [sp+8h] [bp-4h]@1

  strncpy(byte_10120F40, "VERIFYING TAWS AUDIO MSG CONFIGURATION", 0x64u);
  sub_10019220((int)&unk_1011CF40);
  v0 = 0;
  v2 = 0;
  while ( !sub_1002A7A0(v2) || sub_1002A5D0((int)&unk_1011CF40, v2) )
  {
    v2 = ++v0;
    if ( v0 >= 6u )
      return 1;
  }
  return 0;
}

//----- (100073F0) --------------------------------------------------------
char __cdecl sub_100073F0(int a1, int a2, int a3)
{
  char result; // al@1
  bool v4; // bl@8

  result = 0;
  if ( (_BYTE)a3 == 11 )
  {
    if ( sub_10007380() == 1 )
    {
      if ( j_HWM_pvg_read_reg(1) == 1 )
      {
        LOBYTE(a3) = 7;
        sub_10008470(a3);
        result = 1;
      }
      else
      {
        sub_10019220((int)&unk_1011CF40);
        v4 = sub_1002A2A0(byte_1006B170[(unsigned __int8)byte_1011CF39], 24, (unsigned int *)&unk_1011CF40, 0x3FFCu, 1)
          && sub_1002A300(byte_1006B170[(unsigned __int8)byte_1011CF39], 24, (unsigned int)&unk_1011CF40, 16380, 5000);
        LOBYTE(a3) = 11;
        _snprintf(byte_10120F40, 0x64u, "CONFIGURING GIA %d", (unsigned __int8)byte_1011CF39 + 1);
        sub_10008470(a3);
        result = v4;
      }
    }
    else
    {
      _snprintf(byte_10120F40, 0x64u, "FAILED: AUDIO CONFIG VERIFICATION FAILED");
      LOBYTE(a3) = 8;
      sub_10008470(a3);
      result = 0;
    }
  }
  return result;
}
// 1004ED00: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1011CF39: using guessed type char byte_1011CF39;

//----- (10007500) --------------------------------------------------------
char __cdecl sub_10007500(char a1, unsigned __int8 a2, _DWORD *a3)
{
  char result; // al@3
  int v4; // [sp+8h] [bp-1Ch]@1
  int v5; // [sp+Ch] [bp-18h]@1
  int v6; // [sp+10h] [bp-14h]@1
  int v7; // [sp+14h] [bp-10h]@1
  int v8; // [sp+18h] [bp-Ch]@1
  int v9; // [sp+1Ch] [bp-8h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  if ( (a2 & 0x80u) != 0 || a2 > 1u )
  {
    sub_1001B780("..\\lib\\acl\\iop\\iop_cdu_cnfg.c", 327, 0, 0);
    result = 0;
  }
  else
  {
    sub_10019260(a1, (int)&v4);
    *a3 = *(&v5 + a2);
    result = 1;
  }
  return result;
}

//----- (100075B0) --------------------------------------------------------
char __cdecl sub_100075B0(int a1, unsigned __int8 a2, int *a3)
{
  char result; // al@2
  int v4; // [sp+4h] [bp-1Ch]@1
  int v5; // [sp+8h] [bp-18h]@1
  int v6; // [sp+Ch] [bp-14h]@1
  int v7; // [sp+10h] [bp-10h]@1
  int v8; // [sp+14h] [bp-Ch]@1
  int v9; // [sp+18h] [bp-8h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  if ( a2 < 1u )
  {
    sub_10019260(a1, (int)&v4);
    *(&v9 + a2) = *a3;
    sub_100075A0(a1, &v4);
    result = sub_1000F8E0();
  }
  else
  {
    result = sub_1001B780("..\\lib\\acl\\iop\\iop_cdu_cnfg.c", 497, 0, 0);
  }
  return result;
}
// 100075A0: using guessed type _DWORD __cdecl sub_100075A0(_DWORD, _DWORD);

//----- (10007650) --------------------------------------------------------
char __cdecl sub_10007650(int a1, int a2, int a3)
{
  char v3; // bl@1
  char v4; // al@1
  int v5; // ecx@1
  char v6; // dl@2
  char v7; // al@10
  char v8; // al@20
  char result; // al@22
  char v10; // al@29
  char v11; // dl@29
  signed int v12; // eax@30
  signed int v13; // ecx@41
  char v14; // al@42
  char v15; // al@48
  signed int v16; // ecx@64
  char v17; // al@65
  char v18; // al@75
  void *v19; // ecx@86
  int v20; // [sp+10h] [bp-24h]@1
  int v21; // [sp+18h] [bp-1Ch]@1
  int v22; // [sp+1Ch] [bp-18h]@1
  int v23; // [sp+20h] [bp-14h]@1
  int v24; // [sp+24h] [bp-10h]@1
  int v25; // [sp+28h] [bp-Ch]@1
  int v26; // [sp+2Ch] [bp-8h]@1

  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v3 = 4;
  sub_10019260(a1, (int)&v21);
  v4 = *(_BYTE *)(a3 + 1);
  v5 = *(&v24 + (unsigned __int8)a2);
  v20 = *(&v24 + (unsigned __int8)a2);
  if ( v4 )
    goto LABEL_90;
  v6 = *(_BYTE *)a3;
  if ( !*(_BYTE *)a3 && (unsigned __int8)v20 >= 0x13u )
    goto LABEL_90;
  if ( v6 != 1 )
    goto LABEL_7;
  if ( BYTE1(v5) >= 0x13u )
  {
LABEL_90:
    v7 = sub_1002AE50(v4);
LABEL_13:
    v3 = v7;
    if ( v7 == 2 )
      goto LABEL_20;
    goto LABEL_14;
  }
  v3 = 4;
LABEL_7:
  if ( !v6 )
  {
    v7 = sub_1002AE50(v5);
    goto LABEL_13;
  }
  if ( v6 == 1 )
  {
    v7 = sub_1002AE50(SBYTE1(v20));
    goto LABEL_13;
  }
  sub_1001B780("..\\lib\\acl\\iop\\iop_cdu_cnfg.c", 759, 1, 0);
LABEL_14:
  if ( *(_BYTE *)a3 || BYTE1(v20) < 0x13u )
  {
    if ( *(_BYTE *)a3 == 1 && (unsigned __int8)v20 >= 0x13u )
      LOBYTE(v20) = 0;
  }
  else
  {
    BYTE1(v20) = *(_BYTE *)a3;
  }
LABEL_20:
  v8 = *(_BYTE *)a3;
  if ( *(_BYTE *)a3 && v8 != 1 )
  {
    result = sub_1001B780("..\\lib\\acl\\iop\\iop_cdu_cnfg.c", 793, 0, 0);
  }
  else
  {
    if ( v3 == 2 )
    {
      LOBYTE(v20) = *(_BYTE *)(a3 + 1);
      BYTE1(v20) = *(_BYTE *)(a3 + 1);
    }
    else if ( v3 == 3 )
    {
      if ( v8 )
        BYTE1(v20) = *(_BYTE *)(a3 + 1);
      else
        LOBYTE(v20) = *(_BYTE *)(a3 + 1);
    }
    BYTE2(v20) = sub_1002AE30(*(_BYTE *)(a3 + 1));
    v10 = sub_1002AE70(*(_BYTE *)(a3 + 1));
    v11 = *(_BYTE *)(a3 + 1);
    BYTE3(v20) = v10;
    if ( v11 )
    {
      v12 = 0;
      do
      {
        if ( *((_BYTE *)&v24 + 4 * v12) == (_BYTE)v20 )
          *((_BYTE *)&v24 + 4 * v12) = 0;
        if ( *((_BYTE *)&v24 + 4 * v12 + 1) == BYTE1(v20) )
          *((_BYTE *)&v24 + 4 * v12 + 1) = 0;
        ++v12;
      }
      while ( v12 < 2 );
    }
    if ( v11 == 2 || v11 == 4 || v11 == 6 || v11 == 8 || v11 == 12 )
    {
      v13 = 0;
      do
      {
        v14 = *((_BYTE *)&v24 + 4 * v13);
        if ( v14 == 2 || v14 == 4 || v14 == 6 || v14 == 8 || v14 == 12 )
          *((_BYTE *)&v24 + 4 * v13) = 0;
        v15 = *((_BYTE *)&v24 + 4 * v13 + 1);
        if ( v15 == 2 || v15 == 4 || v15 == 6 || v15 == 8 || v15 == 12 )
          *((_BYTE *)&v24 + 4 * v13 + 1) = 0;
        ++v13;
      }
      while ( v13 < 2 );
    }
    if ( v11 == 3 || v11 == 5 || v11 == 9 || v11 == 10 || v11 == 11 || v11 == 13 || v11 == 14 || v11 == 15 || v11 == 17 )
    {
      v16 = 0;
      do
      {
        v17 = *((_BYTE *)&v24 + 4 * v16);
        if ( v17 == 3
          || v17 == 5
          || v17 == 9
          || v17 == 10
          || v17 == 11
          || v17 == 13
          || v17 == 14
          || v17 == 15
          || v17 == 17 )
        {
          *((_BYTE *)&v24 + 4 * v16) = 0;
        }
        v18 = *((_BYTE *)&v24 + 4 * v16 + 1);
        if ( v18 == 3
          || v18 == 5
          || v18 == 9
          || v18 == 10
          || v18 == 11
          || v18 == 13
          || v18 == 14
          || v18 == 15
          || v18 == 17 )
        {
          *((_BYTE *)&v24 + 4 * v16 + 1) = 0;
        }
        ++v16;
      }
      while ( v16 < 2 );
    }
    *(&v24 + (unsigned __int8)a2) = v20;
    sub_100075A0(a1, &v21);
    sub_1000F8E0();
    result = sub_10019900(v19);
    if ( result == (_BYTE)a1 )
      result = j_HWM_pvg_set_uart(a2);
  }
  return result;
}
// 100075A0: using guessed type _DWORD __cdecl sub_100075A0(_DWORD, _DWORD);

//----- (10007920) --------------------------------------------------------
int __cdecl sub_10007920(int a1, _BYTE *a2)
{
  int v3; // [sp+8h] [bp-1Ch]@1
  int v4; // [sp+Ch] [bp-18h]@1
  int v5; // [sp+10h] [bp-14h]@1
  int v6; // [sp+14h] [bp-10h]@1
  int v7; // [sp+18h] [bp-Ch]@1
  int v8; // [sp+1Ch] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  sub_10019260(a1, (int)&v3);
  LOBYTE(v3) = *a2;
  return sub_100075A0(a1, &v3);
}
// 100075A0: using guessed type _DWORD __cdecl sub_100075A0(_DWORD, _DWORD);

//----- (10007990) --------------------------------------------------------
int sub_10007990()
{
  int result; // eax@1
  float *v1; // eax@2
  signed int v2; // ecx@2
  char v3; // [sp+0h] [bp-10h]@1

  result = sub_1004E7C0(6117, (int)&v3, 16);
  if ( !result )
  {
    v1 = (float *)&v3;
    v2 = 2;
    do
    {
      *v1 = 1.0;
      v1 += 2;
      --v2;
    }
    while ( v2 );
    result = sub_1004E910(6117, (int)&v3, 16);
  }
  return result;
}

//----- (100079E0) --------------------------------------------------------
char __usercall sub_100079E0@<al>(int a1@<edx>, char a2)
{
  char result; // al@1
  signed int v3; // esi@1
  signed int v4; // ecx@1
  signed int i; // ecx@8
  signed int v6; // ecx@13
  _WORD *v7; // edx@14

  result = 1;
  v3 = 6;
  v4 = 1000;
  if ( a2 == 1 )
  {
    v3 = 5;
    v4 = 0;
  }
  if ( *(_WORD *)a1 && *(_WORD *)(a1 + 2) || *(_WORD *)(a1 + 20) != 1000 && *(_WORD *)(a1 + 22) != v4 )
    result = 0;
  for ( i = 1; result; ++i )
  {
    if ( i >= 6 )
      break;
    if ( *(_WORD *)(a1 + 4 * i - 4) >= *(_WORD *)(a1 + 4 * i) )
      result = 0;
  }
  v6 = 1;
  if ( result )
  {
    v7 = (_WORD *)(a1 + 6);
    do
    {
      if ( v6 >= v3 )
        break;
      if ( *(v7 - 2) > *v7 )
        result = 0;
      ++v6;
      v7 += 2;
    }
    while ( result );
  }
  return result;
}

//----- (10007A70) --------------------------------------------------------
char __usercall sub_10007A70@<al>(int a1@<eax>, char a2)
{
  int v2; // esi@1
  char result; // al@1
  signed int v4; // edi@1
  signed int v5; // ecx@1
  signed int i; // ecx@8
  signed int v7; // ecx@13
  _BYTE *v8; // esi@14

  v2 = a1;
  result = 1;
  v4 = 6;
  v5 = 100;
  if ( a2 == 1 )
  {
    v4 = 5;
    v5 = 0;
  }
  if ( *(_BYTE *)v2 && *(_BYTE *)(v2 + 1) || *(_BYTE *)(v2 + 10) != 100 && *(_BYTE *)(v2 + 11) != v5 )
    result = 0;
  for ( i = 1; result; ++i )
  {
    if ( i >= 6 )
      break;
    if ( *(_BYTE *)(v2 + 2 * i - 2) >= *(_BYTE *)(v2 + 2 * i) )
      result = 0;
  }
  v7 = 1;
  if ( result )
  {
    v8 = (_BYTE *)(v2 + 3);
    do
    {
      if ( v7 >= v4 )
        break;
      if ( *(v8 - 2) > *v8 )
        result = 0;
      ++v7;
      v8 += 2;
    }
    while ( result );
  }
  return result;
}

//----- (10007AF0) --------------------------------------------------------
char __fastcall sub_10007AF0(int a1, int a2)
{
  unsigned __int16 v2; // cx@1
  char result; // al@1

  v2 = *(_WORD *)(a2 + 2);
  result = 1;
  if ( v2 > 0x2710u || *(_WORD *)a2 >= v2 )
    result = 0;
  return result;
}

//----- (10007B10) --------------------------------------------------------
char __cdecl sub_10007B10(int a1, unsigned __int8 a2, int a3)
{
  char v3; // cl@1
  signed int v4; // eax@2
  char result; // al@8
  int v6; // [sp+8h] [bp-1Ch]@1
  int v7; // [sp+Ch] [bp-18h]@1
  int v8; // [sp+10h] [bp-14h]@1
  int v9; // [sp+14h] [bp-10h]@1
  int v10; // [sp+18h] [bp-Ch]@1
  int v11; // [sp+1Ch] [bp-8h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  sub_10019260(a1, (int)&v6);
  v3 = *(_BYTE *)(a3 + 1);
  if ( v3 )
  {
    v4 = 0;
    do
    {
      if ( *((_BYTE *)&v7 + 4 * v4 + 1) == v3 )
      {
        *((_BYTE *)&v7 + 4 * v4 + 1) = 0;
        *((_BYTE *)&v7 + 4 * v4) = 0;
      }
      ++v4;
    }
    while ( v4 < 2 );
  }
  *(&v7 + a2) = *(_DWORD *)a3;
  if ( (a2 & 0x80u) != 0 || a2 > 1u )
  {
    result = sub_1001B780("..\\lib\\acl\\iop\\iop_cdu_cnfg.c", 423, 1, 0);
  }
  else
  {
    sub_100075A0(a1, &v6);
    result = sub_1000F8E0();
  }
  return result;
}
// 100075A0: using guessed type _DWORD __cdecl sub_100075A0(_DWORD, _DWORD);

//----- (10007BE0) --------------------------------------------------------
char __cdecl sub_10007BE0(char a1, int a2)
{
  int v2; // ecx@0
  signed int v3; // esi@1
  int v4; // edi@1
  signed int v5; // eax@8
  char result; // al@9
  char v7; // [sp+13h] [bp-1h]@1

  v7 = 1;
  v3 = 0;
  v4 = a2 + 28;
  do
  {
    if ( !sub_10007AF0(v2, v4 - 28) || !sub_100079E0(v4 - 24, v3 == 1) || !sub_100079E0(v4, v3 == 1) )
      v7 = 0;
    ++v3;
    v4 += 52;
  }
  while ( v3 < 2 );
  if ( v7 && (v5 = sub_100194B0(a1), j_HWM_pvg_dspl_bklt_set_bias_data(a2, 0, 0, v5)) )
    result = 0;
  else
    result = v7;
  return result;
}
// 1004F810: using guessed type int __cdecl j_HWM_pvg_dspl_bklt_set_bias_data(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10007C70) --------------------------------------------------------
char __cdecl sub_10007C70(char a1, int a2)
{
  signed int v2; // edi@1
  char v3; // bl@1
  _BYTE *v4; // esi@1
  unsigned __int8 v5; // cl@2
  unsigned __int8 v6; // al@6
  signed int v7; // eax@15
  char result; // al@16

  v2 = 0;
  v3 = 1;
  v4 = (_BYTE *)(a2 + 31);
  do
  {
    v5 = *(v4 - 1);
    if ( v5 >= 2u
      || *(_WORD *)(v4 - 31) > 0x2710u
      || *(v4 - 17) >= 0xAu
      || *v4 >= 0xAu
      || (v6 = *(v4 - 16), v6 >= 0x16u)
      || *(_WORD *)(v4 - 3) > 0x2710u
      || v5 != 1 && v6 == 9
      || !sub_10007A70((int)(v4 - 29), 0)
      || !sub_10007A70((int)(v4 - 15), v2 == 1) )
    {
      v3 = 0;
    }
    ++v2;
    v4 += 32;
  }
  while ( v2 < 2 );
  if ( v3 && (v7 = sub_100194B0(a1), j_HWM_pvg_dspl_bklt_set_cnfg(a2, 0, v7)) )
    result = 0;
  else
    result = v3;
  return result;
}
// 1004F820: using guessed type int __cdecl j_HWM_pvg_dspl_bklt_set_cnfg(_DWORD, _DWORD, _DWORD);

//----- (10007D20) --------------------------------------------------------
char __cdecl sub_10007D20(char a1, int a2, char a3, unsigned __int8 *a4, int *a5)
{
  char v5; // bl@1
  char result; // al@2
  char v7; // al@6
  int v8; // [sp+4h] [bp-4h]@0

  v5 = 0;
  LOBYTE(v8) = sub_100195A0(a1);
  switch ( a3 )
  {
    case 2:
      sub_10007B10(v8, *a4, (int)a5);
      sub_10008470(7);
      return 1;
    case 3:
      sub_100075B0(v8, *a4, a5);
      sub_10008470(7);
      return 1;
    case 7:
      sub_10007920(v8, a5);
      sub_10008470(7);
      return 1;
    case 0xC:
      sub_10007650(v8, *a4, (int)a5);
      sub_10008470(7);
      return 1;
    case 0xF:
      v7 = sub_10007BE0(v8, (int)a5);
      goto LABEL_8;
    case 0x10:
      v7 = sub_10007C70(v8, (int)a5);
LABEL_8:
      v5 = v7;
      if ( v7 != 1 )
        goto LABEL_10;
      sub_10008470(7);
      result = v5;
      break;
    default:
LABEL_10:
      sub_10008470(8);
      result = v5;
      break;
  }
  return result;
}

//----- (10007E70) --------------------------------------------------------
char __cdecl sub_10007E70(int a1, int a2, char a3)
{
  int v3; // eax@1

  v3 = *(_BYTE *)(a2 + 1);
  switch ( v3 )
  {
    case 1:
    case 2:
    case 7:
    case 8:
    case 9:
    case 10:
      switch ( *(_BYTE *)(a2 + 1) )
      {
        case 1:
        case 7:
          qmemcpy((void *)(dword_1011CF34 + 320), &unk_1006A808, 0x168u);
          *(_BYTE *)dword_1011CF34 = *(_BYTE *)a2;
          *(_DWORD *)(dword_1011CF34 + 16) = dword_1011CF34 + 320;
          *(_DWORD *)(dword_1011CF34 + 4) = 15;
          *(_DWORD *)(dword_1011CF34 + 20) = a1;
          *(_BYTE *)(dword_1011CF34 + 1) = 1;
          *(_DWORD *)(dword_1011CF34 + 24) = dword_1011CF34 + 32;
          *(_BYTE *)(dword_1011CF34 + 28) = a3;
          sub_10005440(dword_1011CF34);
          LOBYTE(v3) = sub_100057F0(dword_1011CF34);
          break;
        case 2:
        case 8:
          qmemcpy((void *)(dword_1011CF34 + 320), &unk_1006A808, 0x168u);
          *(_BYTE *)(dword_1011CF34 + 160) = *(_BYTE *)a2;
          *(_DWORD *)(dword_1011CF34 + 176) = dword_1011CF34 + 320;
          *(_DWORD *)(dword_1011CF34 + 164) = 15;
          *(_DWORD *)(dword_1011CF34 + 180) = a1;
          *(_BYTE *)(dword_1011CF34 + 161) = 1;
          *(_DWORD *)(dword_1011CF34 + 184) = dword_1011CF34 + 192;
          *(_BYTE *)(dword_1011CF34 + 188) = a3;
          sub_10005440(dword_1011CF34 + 160);
          LOBYTE(v3) = sub_100057F0(dword_1011CF34 + 160);
          break;
        case 9:
          qmemcpy((void *)(dword_1011CF34 + 320), &unk_1006A970, 0x180u);
          *(_BYTE *)dword_1011CF34 = *(_BYTE *)a2;
          *(_DWORD *)(dword_1011CF34 + 16) = dword_1011CF34 + 320;
          *(_DWORD *)(dword_1011CF34 + 4) = 16;
          *(_DWORD *)(dword_1011CF34 + 20) = a1;
          *(_BYTE *)(dword_1011CF34 + 1) = 1;
          *(_DWORD *)(dword_1011CF34 + 24) = dword_1011CF34 + 32;
          *(_BYTE *)(dword_1011CF34 + 28) = a3;
          sub_10005440(dword_1011CF34);
          LOBYTE(v3) = sub_100057F0(dword_1011CF34);
          break;
        case 0xA:
          qmemcpy((void *)(dword_1011CF34 + 320), &unk_1006A970, 0x180u);
          *(_BYTE *)(dword_1011CF34 + 160) = *(_BYTE *)a2;
          *(_DWORD *)(dword_1011CF34 + 176) = dword_1011CF34 + 320;
          *(_DWORD *)(dword_1011CF34 + 164) = 16;
          *(_DWORD *)(dword_1011CF34 + 180) = a1;
          *(_BYTE *)(dword_1011CF34 + 161) = 1;
          *(_DWORD *)(dword_1011CF34 + 184) = dword_1011CF34 + 192;
          *(_BYTE *)(dword_1011CF34 + 188) = a3;
          sub_10005440(dword_1011CF34 + 160);
          LOBYTE(v3) = sub_100057F0(dword_1011CF34 + 160);
          break;
        default:
          LOBYTE(v3) = sub_1001B780("..\\lib\\adl\\iop_arnc_ahrs_frmt.c", 426, 1, 0);
          break;
      }
      break;
    case 3:
    case 4:
    case 5:
    case 6:
      memset((void *)(dword_1011CF30 + 608), 0, 0x330u);
      memset((void *)(dword_1011CF30 + 32), 0, 0x110u);
      memset((void *)(dword_1011CF30 + 336), 0, 0x110u);
      switch ( *(_BYTE *)(a2 + 1) )
      {
        case 3:
          qmemcpy((void *)(dword_1011CF30 + 608), &unk_1006A260, 0x108u);
          *(_BYTE *)dword_1011CF30 = *(_BYTE *)a2;
          *(_DWORD *)(dword_1011CF30 + 16) = dword_1011CF30 + 608;
          *(_DWORD *)(dword_1011CF30 + 4) = 11;
          *(_DWORD *)(dword_1011CF30 + 20) = a1;
          *(_BYTE *)(dword_1011CF30 + 1) = 1;
          *(_DWORD *)(dword_1011CF30 + 24) = dword_1011CF30 + 32;
          *(_BYTE *)(dword_1011CF30 + 28) = a3;
          LOBYTE(v3) = sub_100057F0(dword_1011CF30);
          break;
        case 4:
          qmemcpy((void *)(dword_1011CF30 + 608), &unk_1006A260, 0x108u);
          *(_BYTE *)(dword_1011CF30 + 304) = *(_BYTE *)a2;
          *(_DWORD *)(dword_1011CF30 + 320) = dword_1011CF30 + 608;
          *(_DWORD *)(dword_1011CF30 + 308) = 11;
          *(_DWORD *)(dword_1011CF30 + 324) = a1;
          *(_BYTE *)(dword_1011CF30 + 305) = 1;
          *(_DWORD *)(dword_1011CF30 + 328) = dword_1011CF30 + 336;
          *(_BYTE *)(dword_1011CF30 + 332) = a3;
          LOBYTE(v3) = sub_100057F0(dword_1011CF30 + 304);
          break;
        case 5:
          qmemcpy((void *)(dword_1011CF30 + 608), &unk_1006A368, 0x330u);
          *(_BYTE *)dword_1011CF30 = *(_BYTE *)a2;
          *(_DWORD *)(dword_1011CF30 + 16) = dword_1011CF30 + 608;
          *(_DWORD *)(dword_1011CF30 + 4) = 34;
          *(_DWORD *)(dword_1011CF30 + 20) = a1;
          *(_BYTE *)(dword_1011CF30 + 1) = 1;
          *(_DWORD *)(dword_1011CF30 + 24) = dword_1011CF30 + 32;
          *(_BYTE *)(dword_1011CF30 + 28) = a3;
          LOBYTE(v3) = sub_100057F0(dword_1011CF30);
          break;
        case 6:
          qmemcpy((void *)(dword_1011CF30 + 608), &unk_1006A368, 0x330u);
          *(_BYTE *)(dword_1011CF30 + 304) = *(_BYTE *)a2;
          *(_DWORD *)(dword_1011CF30 + 320) = dword_1011CF30 + 608;
          *(_DWORD *)(dword_1011CF30 + 308) = 34;
          *(_DWORD *)(dword_1011CF30 + 324) = a1;
          *(_BYTE *)(dword_1011CF30 + 305) = 1;
          *(_DWORD *)(dword_1011CF30 + 328) = dword_1011CF30 + 336;
          *(_BYTE *)(dword_1011CF30 + 332) = a3;
          LOBYTE(v3) = sub_100057F0(dword_1011CF30 + 304);
          break;
        default:
          LOBYTE(v3) = sub_1001B780("..\\lib\\adl\\iop_arnc_adc_frmt.c", 243, 1, 0);
          break;
      }
      break;
    case 0:
      return v3;
    default:
      LOBYTE(v3) = sub_1001B780("..\\lib\\adl\\iop_cdu_ports.c", 158, 0, 0);
      break;
  }
  return v3;
}
// 1011CF30: using guessed type int dword_1011CF30;
// 1011CF34: using guessed type int dword_1011CF34;

//----- (10007ED0) --------------------------------------------------------
void __cdecl sub_10007ED0(int a1, int a2)
{
  char v2; // bl@1
  _BYTE *v3; // esi@1
  int v4; // ST10_4@3
  int v5; // ST0C_4@3
  char v6; // al@7
  char v7; // al@7

  v2 = a1;
  v3 = (_BYTE *)a2;
  if ( *(_BYTE *)a2 || *(_BYTE *)(a2 + 1) )
  {
    v4 = *(_BYTE *)(a2 + 3);
    v5 = *(_BYTE *)(a2 + 2);
    j_HWM_pvg_set_uart(a1);
  }
  if ( !v2 && *v3 != 18 && !memcmp((char *)dword_1022D6E8 + 20440, "Unknown Aircraft", 0x11u) )
  {
    LOBYTE(a1) = 0;
    LOWORD(a2) = 4608;
    v6 = sub_10019900(&a1);
    v7 = sub_100193D0(v6);
    sub_10009B80(v7, 0, 12, (int)&a1, &a2, 2u);
  }
}

//----- (10007F70) --------------------------------------------------------
char __cdecl sub_10007F70(int a1, int a2)
{
  char result; // al@1
  int v3; // eax@2
  char v4; // [sp+8h] [bp-14h]@2
  char v5; // [sp+Ch] [bp-10h]@1
  int v6; // [sp+10h] [bp-Ch]@1
  char v7; // [sp+14h] [bp-8h]@2

  result = sub_1000F640(a1, a2, &v6, (unsigned __int16 *)&v5);
  if ( result )
  {
    v3 = sub_1000DEC0(a1, a2);
    v4 = 2;
    if ( !v7 )
      v4 = 3;
    result = sub_10007F60(v3, v6, v4);
  }
  return result;
}
// 10007F60: using guessed type _DWORD __cdecl sub_10007F60(_DWORD, _DWORD, char);

//----- (10007FE0) --------------------------------------------------------
char __cdecl sub_10007FE0(int a1, int a2, int a3, int a4, int a5, int a6, unsigned __int16 a7, char a8)
{
  int v8; // eax@1
  char result; // al@1
  int v10; // [sp+4h] [bp-18h]@1
  int v11; // [sp+8h] [bp-14h]@1
  int v12; // [sp+Ch] [bp-10h]@1
  int v13; // [sp+10h] [bp-Ch]@1
  int v14; // [sp+14h] [bp-8h]@1

  v10 = a2;
  v11 = a3;
  v12 = a4;
  v13 = a5;
  v14 = a6;
  v8 = sub_1004E4B0();
  sub_1000ED20(678, a7, 1, (int)&byte_10236500, &v10, v8);
  result = sub_1000F010(678, a1, (int)&byte_10236500);
  if ( a8 )
    result = sub_10007F60(a1, v10, 1);
  return result;
}
// 10007F60: using guessed type _DWORD __cdecl sub_10007F60(_DWORD, _DWORD, char);
// 10236500: using guessed type char byte_10236500;

//----- (10008080) --------------------------------------------------------
int sub_10008080()
{
  int result; // eax@1
  unsigned __int8 *v1; // ecx@2
  unsigned __int8 v2; // bl@2
  int v3; // eax@3
  int v4; // esi@4

  result = sub_1004E560(103, 100);
  if ( !result )
  {
    v1 = (unsigned __int8 *)dword_10120FA4;
    v2 = 0;
    if ( *(_BYTE *)dword_10120FA4 )
    {
      do
      {
        v3 = 16 * v2;
        if ( v1[v3 + 12] == 1 )
        {
          v4 = (int)&v1[v3];
          if ( (unsigned int)(sub_1004E4B0() - *(_DWORD *)&v1[v3 + 16]) >= 0x2BF20 )
            *(_BYTE *)(v4 + 12) = 3;
          v1 = (unsigned __int8 *)dword_10120FA4;
        }
        ++v2;
      }
      while ( v2 < *v1 );
    }
    result = sub_1004E540(103);
  }
  return result;
}
// 10120FA4: using guessed type int dword_10120FA4;

//----- (100080E0) --------------------------------------------------------
char __usercall sub_100080E0@<al>(int a1@<edi>, unsigned __int8 *a2)
{
  char result; // al@1
  unsigned __int8 v3; // cl@1

  result = 0;
  v3 = 0;
  if ( *(_BYTE *)dword_10120FA4 )
  {
    while ( a1 != *(_DWORD *)(16 * v3 + dword_10120FA4 + 4) )
    {
      if ( ++v3 >= *(_BYTE *)dword_10120FA4 )
        return result;
    }
    *a2 = v3;
    result = 1;
  }
  return result;
}
// 10120FA4: using guessed type int dword_10120FA4;

//----- (10008120) --------------------------------------------------------
signed int sub_10008120()
{
  const char *v1; // [sp+0h] [bp-14h]@1
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+8h] [bp-Ch]@1
  int v4; // [sp+Ch] [bp-8h]@1
  int *v5; // [sp+10h] [bp-4h]@1

  v1 = "/shr_mem/iop_cmd_intf.shr";
  v2 = 5;
  v3 = 452;
  v4 = 0;
  v5 = &dword_10120FA4;
  dword_10120FA4 = -15;
  if ( !sub_1004F780((LONG)&v1) )
    sub_1001B780("..\\lib\\acl\\iop\\cmd\\iop_cmd_mngr.c", 319, 1, 0);
  *(_BYTE *)dword_10120FA4 = 0;
  return sub_1004F310((int)&v1);
}
// 10120FA4: using guessed type int dword_10120FA4;

//----- (10008190) --------------------------------------------------------
void __cdecl sub_10008190(int a1, unsigned int a2, unsigned __int8 a3)
{
  int v3; // ecx@0
  unsigned __int8 v4; // bl@5
  int v5; // eax@6
  unsigned __int8 v6; // cl@9
  int v7; // esi@11
  int v8; // eax@12
  int v9; // [sp-2h] [bp-4h]@1

  v9 = v3;
  if ( a3 < 4u && a2 <= 0xE && !sub_1004E560(103, 100) )
  {
    BYTE3(v9) = 28;
    if ( sub_100080E0(a1, (unsigned __int8 *)&v9 + 3)
      || (v4 = *(_BYTE *)dword_10120FA4, *(_BYTE *)dword_10120FA4 >= 0x1Cu) )
    {
      v4 = BYTE3(v9);
    }
    else
    {
      v5 = 16 * v4;
      *(_DWORD *)(v5 + dword_10120FA4 + 4) = a1;
      *(_DWORD *)(v5 + dword_10120FA4 + 8) = 14;
      ++*(_BYTE *)dword_10120FA4;
    }
    if ( v4 < 0x1Cu )
    {
      v6 = a3;
      if ( a3 == 1 || !a3 )
      {
        v7 = 16 * v4;
        *(_DWORD *)(v7 + dword_10120FA4 + 8) = a2;
        *(_DWORD *)(v7 + dword_10120FA4 + 16) = sub_1004E4B0();
        v6 = a3;
      }
      v8 = 16 * v4 + dword_10120FA4;
      if ( *(_DWORD *)(v8 + 8) == a2 )
        *(_BYTE *)(v8 + 12) = v6;
    }
    sub_1004E540(103);
  }
}
// 10120FA4: using guessed type int dword_10120FA4;

//----- (10008280) --------------------------------------------------------
int __cdecl sub_10008280(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10019090(a1, 11);
  return sub_1004E970(v2, a2, 24);
}

//----- (100082A0) --------------------------------------------------------
int __cdecl sub_100082A0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100190F0(a1);
  return sub_1004E970(v2, a2, 2720);
}

//----- (100082D0) --------------------------------------------------------
int __cdecl sub_100082D0(int a1)
{
  return sub_1004E970(6005, a1, 4);
}

//----- (100082F0) --------------------------------------------------------
char sub_100082F0()
{
  return *(_BYTE *)(dword_10120FB4 + 3);
}
// 10120FB4: using guessed type int dword_10120FB4;

//----- (10008300) --------------------------------------------------------
char __cdecl sub_10008300(_DWORD *a1)
{
  char result; // al@1

  result = 0;
  if ( dword_10120FB4 != -15 )
  {
    *a1 = dword_10120FB4;
    result = 1;
  }
  return result;
}
// 10120FB4: using guessed type int dword_10120FB4;

//----- (10008320) --------------------------------------------------------
int sub_10008320()
{
  return dword_10120FB0;
}
// 10120FB0: using guessed type int dword_10120FB0;

//----- (10008330) --------------------------------------------------------
char sub_10008330()
{
  return *(_BYTE *)(dword_10120FB4 + 1);
}
// 10120FB4: using guessed type int dword_10120FB4;

//----- (10008340) --------------------------------------------------------
char __cdecl sub_10008340(unsigned __int8 a1, _BYTE *a2)
{
  char result; // al@1

  result = 0;
  if ( a1 < 0x43u )
  {
    *a2 = *((_BYTE *)dword_101267C0 + a1);
    result = 1;
  }
  return result;
}

//----- (10008360) --------------------------------------------------------
void sub_10008360()
{
  ++dword_10120FB0;
}
// 10120FB0: using guessed type int dword_10120FB0;

//----- (10008370) --------------------------------------------------------
int (__cdecl *sub_10008370())(_DWORD)
{
  unsigned int v0; // esi@1
  int (__cdecl *result)(_DWORD); // eax@2

  v0 = 0;
  do
  {
    result = (int (__cdecl *)(_DWORD))dword_1006E680[v0];
    if ( result )
      result = (int (__cdecl *)(_DWORD))result((unsigned __int8)byte_1006E658[v0 * 4]);
    v0 += 11;
  }
  while ( v0 < 341 );
  return result;
}
// 1006E680: using guessed type int dword_1006E680[];

//----- (100083A0) --------------------------------------------------------
char __cdecl sub_100083A0(unsigned __int8 a1, char a2)
{
  char result; // al@1

  result = a1;
  if ( a1 < 0x43u )
  {
    *((_BYTE *)dword_101267C0 + a1) = a2;
    result = sub_1000F8E0();
  }
  return result;
}

//----- (100083C0) --------------------------------------------------------
int __cdecl sub_100083C0(char a1, char a2, char a3, char a4, int a5, void *a6, size_t a7)
{
  int v7; // eax@2
  int result; // eax@6

  *(_BYTE *)(dword_10120FB4 + 3) = a3;
  if ( a5 )
  {
    v7 = dword_10120FB4 + 5;
    *(_WORD *)v7 = *(_WORD *)a5;
    *(_BYTE *)(v7 + 2) = *(_BYTE *)(a5 + 2);
  }
  if ( a7 > 0x27100 )
  {
    *(_DWORD *)(dword_10120FB4 + 160008) = 0;
    sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 1412, 0, 0);
  }
  else
  {
    memcpy((void *)(dword_10120FB4 + 8), a6, a7);
    *(_DWORD *)(dword_10120FB4 + 160008) = a7;
  }
  result = dword_10120FB4;
  *(_BYTE *)(dword_10120FB4 + 4) = a4;
  LOBYTE(result) = a2;
  *(_BYTE *)(dword_10120FB4 + 2) = a2;
  *(_BYTE *)(dword_10120FB4 + 1) = a1;
  return result;
}
// 10120FB4: using guessed type int dword_10120FB4;

//----- (10008470) --------------------------------------------------------
void *__cdecl sub_10008470(int a1)
{
  int v1; // eax@7
  int (__cdecl *v2)(_DWORD, _DWORD, _DWORD, int, int, int); // ecx@8
  void *result; // eax@9

  *(_BYTE *)dword_10120FB4 = a1;
  switch ( (unsigned __int8)a1 )
  {
    case 7u:
      dword_10120FAC = sub_1004E4B0();
      break;
    case 8u:
      dword_101267C4 = sub_1004E4B0();
      break;
    case 9u:
      dword_101267C8 = sub_1004E4B0();
      break;
  }
  v1 = sub_1001DC80((_DWORD *)(dword_10120FB4 + 2), 1u, (int)byte_1006E658, 44, 31, 57);
  if ( v1 >= 57
    || (v2 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int, int, int))dword_1006E678[11 * v1]) == 0
    || (result = (void *)v2(
                           *(_BYTE *)(dword_10120FB4 + 2),
                           *(_BYTE *)(dword_10120FB4 + 3),
                           *(_BYTE *)(dword_10120FB4 + 4),
                           dword_10120FB4 + 5,
                           a1,
                           dword_10120FB4 + 160012),
        !(_BYTE)result) )
  {
    result = memset((void *)(dword_10120FB4 + 160012), 0, 0x64u);
  }
  return result;
}
// 1006E678: using guessed type int dword_1006E678[];
// 10120FAC: using guessed type int dword_10120FAC;
// 10120FB4: using guessed type int dword_10120FB4;
// 101267C4: using guessed type int dword_101267C4;
// 101267C8: using guessed type int dword_101267C8;

//----- (10008530) --------------------------------------------------------
char __cdecl sub_10008530(int a1, int a2, char a3)
{
  char result; // al@2

  if ( sub_10014DE0(a3, 0) )
  {
    sub_10008470(7);
    result = 1;
    if ( a3 == 31 || a3 == 32 || a3 == 11 )
    {
      sub_1001CF90();
      result = 1;
    }
  }
  else
  {
    sub_10008470(8);
    result = 0;
  }
  return result;
}

//----- (10008580) --------------------------------------------------------
char __usercall sub_10008580@<al>(char a1@<bl>, int a2@<edi>, const void *a3@<esi>, char a4, char a5, char a6, unsigned int a7)
{
  char v7; // dl@12
  char result; // al@19
  int v9; // [sp-8h] [bp-534h]@18
  char v10; // [sp-4h] [bp-530h]@18
  __int16 v11; // [sp+4h] [bp-528h]@1
  char v12; // [sp+8h] [bp-524h]@11
  char v13; // [sp+9h] [bp-523h]@11
  char v14; // [sp+Ah] [bp-522h]@11
  char v15; // [sp+Bh] [bp-521h]@11
  __int16 v16; // [sp+Ch] [bp-520h]@12
  char v17; // [sp+Eh] [bp-51Eh]@12
  char v18; // [sp+Fh] [bp-51Dh]@15
  unsigned int v19; // [sp+524h] [bp-8h]@15

  memset(&v11, 0, 0x524u);
  if ( (unsigned __int8)a1 >= 8u )
    sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 1658, 0, 0);
  if ( (unsigned __int8)a4 >= 0x39u )
    sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 1668, 0, 0);
  if ( (unsigned __int8)a5 >= 2u )
    sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 1669, 0, 0);
  if ( (unsigned __int8)a6 >= 0x2Cu )
    sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 1670, 0, 0);
  if ( a7 >= 0x514 )
    sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 1671, 0, 0);
  v11 = -32749;
  v12 = a1;
  v13 = a4;
  v14 = a5;
  v15 = a6;
  if ( a2 )
  {
    v7 = *(_BYTE *)(a2 + 2);
    v16 = *(_WORD *)a2;
    v17 = v7;
  }
  else
  {
    v16 = 0;
    v17 = 0;
  }
  if ( a3 )
  {
    memcpy(&v18, a3, a7);
    v19 = a7;
  }
  else
  {
    v19 = 0;
  }
  switch ( a4 )
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 0x12:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x1B:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x21:
    case 0x26:
    case 0x27:
    case 0x28:
    case 0x29:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x2F:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
      v10 = 1;
      v9 = 1753;
      goto LABEL_23;
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x19:
    case 0x1A:
    case 0x1F:
    case 0x2A:
    case 0x2B:
    case 0x30:
    case 0x31:
    case 0x37:
    case 0x38:
      result = sub_10023A90((int)&v11);
      break;
    case 8:
    case 9:
    case 0xA:
    case 0xB:
    case 0x13:
    case 0x20:
    case 0x22:
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x32:
      result = sub_10023AA0((int)&v11);
      break;
    case 0x11:
      result = sub_10023AC0((int)&v11);
      break;
    default:
      v10 = 1;
      v9 = 1778;
LABEL_23:
      result = sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", v9, v10, 0);
      break;
  }
  return result;
}

//----- (10008790) --------------------------------------------------------
signed int __usercall sub_10008790@<eax>(unsigned int a1@<eax>, int a2, char *a3, unsigned __int16 a4)
{
  __int16 v4; // bx@1
  unsigned int v5; // edx@1
  unsigned int v6; // esi@1
  signed int result; // eax@2
  void *v8; // eax@3
  unsigned int v9; // ecx@5
  int v10; // edx@13
  signed int v11; // ebx@13
  char *v12; // ecx@14
  int v13; // esi@14
  int v14; // eax@18
  unsigned int v15; // edi@18
  int v16; // eax@19
  unsigned int v17; // edx@19
  int v18; // eax@20
  int v19; // ecx@23
  bool v20; // cf@34
  char v21; // [sp+Ah] [bp-96h]@17
  char v22; // [sp+Bh] [bp-95h]@17
  int v23; // [sp+Ch] [bp-94h]@1
  int v24; // [sp+10h] [bp-90h]@18
  char *v25; // [sp+14h] [bp-8Ch]@14
  int v26; // [sp+18h] [bp-88h]@13
  int v27[32]; // [sp+20h] [bp-80h]@7

  v4 = word_102364C0;
  v5 = 0;
  v6 = a1;
  v23 = 0;
  if ( word_102364C0 == 1491 )
  {
    result = 0;
  }
  else
  {
    v8 = &unk_102362C0;
    do
    {
      if ( *((_WORD *)v8 + 2) == v4 )
      {
        v9 = *(_WORD *)v8;
        if ( v6 >= v9 && v6 < v9 + *((_WORD *)v8 + 1) )
        {
          v27[v23++] = (int)v8;
          if ( *((_DWORD *)v8 + 2) == -1 && *((_DWORD *)v8 + 3) == -1 )
            return 0;
        }
      }
      v5 += 16;
      v8 = (char *)v8 + 16;
    }
    while ( v5 < 0x200 );
    if ( v23 )
    {
      v10 = 0;
      v11 = 0;
      v26 = 0;
      if ( a4 )
      {
        v12 = a3;
        v13 = a2 - (_DWORD)a3;
        v25 = a3;
        while ( !v11 )
        {
          v22 = v12[v13];
          v21 = *v12;
          if ( v22 != *v12 )
          {
            v14 = 0;
            v15 = 8 * v10;
            v11 = -34;
            v24 = 0;
            if ( v23 > 0 )
            {
              while ( 1 )
              {
                v16 = v27[v14];
                v17 = *(_DWORD *)(v16 + 8);
                if ( v15 + 7 >= v17 )
                {
                  v18 = *(_DWORD *)(v16 + 12);
                  if ( v15 < v18 + v17 )
                    break;
                }
LABEL_31:
                v14 = v24++ + 1;
                if ( v24 >= v23 )
                  goto LABEL_34;
              }
              if ( v17 & 7 || v18 & 7 )
              {
                v19 = 0;
                while ( 1 )
                {
                  if ( (1 << v19) & (unsigned __int8)(v21 ^ v22) )
                  {
                    if ( v19 + v15 < v17 || v19 + v15 >= v18 + v17 )
                    {
                      v11 = -34;
                      goto LABEL_31;
                    }
                    v11 = 0;
                  }
                  if ( (unsigned int)++v19 >= 8 )
                    goto LABEL_31;
                }
              }
              v11 = 0;
            }
          }
LABEL_34:
          v10 = v26 + 1;
          v12 = v25 + 1;
          v20 = v26++ + 1 < (unsigned int)a4;
          ++v25;
          if ( !v20 )
          {
            if ( !v11 )
              goto LABEL_37;
            break;
          }
          v13 = a2 - (_DWORD)a3;
        }
        sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 2449, 0, "no perm for reg_tag bits\n");
      }
LABEL_37:
      result = v11;
    }
    else
    {
      sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 2367, 0, "no perm for reg_tag\n");
      result = -34;
    }
  }
  return result;
}
// 102364C0: using guessed type __int16 word_102364C0;
// 10008790: using guessed type int var_80[32];

//----- (10008970) --------------------------------------------------------
signed int sub_10008970()
{
  signed int result; // eax@2

  if ( sub_1004F780((LONG)&off_1006EC94) )
  {
    *(_BYTE *)dword_10120FB4 = 0;
    *(_BYTE *)(dword_10120FB4 + 2) = 67;
    result = sub_1004F310((int)&off_1006EC94);
  }
  else
  {
    sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 2504, 1, 0);
    result = sub_1004F310((int)&off_1006EC94);
  }
  return result;
}
// 1006EC94: using guessed type char *off_1006EC94;
// 10120FB4: using guessed type int dword_10120FB4;

//----- (100089C0) --------------------------------------------------------
signed int sub_100089C0()
{
  signed int result; // eax@5

  if ( sub_1004F780((LONG)&off_1006ECA8) )
  {
    *(_BYTE *)dword_10120FA8 = 0;
    *(_BYTE *)(dword_10120FA8 + 2) = 67;
  }
  else
  {
    sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 2583, 1, 0);
  }
  sub_1004F310((int)&off_1006ECA8);
  if ( sub_1004F780((LONG)&off_1006ECBC) )
  {
    memset(dword_101267C0, 1, 0x43u);
    result = sub_1004F310((int)&off_1006ECBC);
  }
  else
  {
    sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 2613, 1, 0);
    result = sub_1004F310((int)&off_1006ECBC);
  }
  return result;
}
// 1006ECA8: using guessed type char *off_1006ECA8;
// 1006ECBC: using guessed type char *off_1006ECBC;
// 10120FA8: using guessed type int dword_10120FA8;

//----- (10008A60) --------------------------------------------------------
void *sub_10008A60()
{
  void *result; // eax@1

  result = (void *)(sub_1004E4B0() - dword_101267C8);
  if ( (unsigned int)result >= 0x2710 )
    result = sub_10008470(0);
  return result;
}
// 101267C8: using guessed type int dword_101267C8;

//----- (10008A80) --------------------------------------------------------
void *sub_10008A80()
{
  void *result; // eax@1

  result = (void *)(sub_1004E4B0() - dword_10120FAC);
  if ( (unsigned int)result >= 0x2710 )
    result = sub_10008470(0);
  return result;
}
// 10120FAC: using guessed type int dword_10120FAC;

//----- (10008AA0) --------------------------------------------------------
void *sub_10008AA0()
{
  void *result; // eax@1

  result = (void *)(sub_1004E4B0() - dword_101267C4);
  if ( (unsigned int)result >= 0x2710 )
    result = sub_10008470(0);
  return result;
}
// 101267C4: using guessed type int dword_101267C4;

//----- (10008AC0) --------------------------------------------------------
char sub_10008AC0()
{
  char result; // al@1
  char v1; // bl@1
  unsigned int v2; // esi@3
  int v3; // [sp+4h] [bp-4h]@5

  result = *(_BYTE *)dword_10120FB4;
  v1 = 0;
  if ( *(_BYTE *)dword_10120FB4 )
  {
    *(_BYTE *)dword_10120FA8 = result;
    *(_BYTE *)(dword_10120FA8 + 2) = *(_BYTE *)(dword_10120FB4 + 2);
    result = sub_10020640(dword_10120FA8 + 160012, (_BYTE *)(dword_10120FB4 + 160012), 100);
  }
  else
  {
    v2 = 0;
    while ( v1 != 1 )
    {
      result = sub_10009BB0(dword_1006ECD0[v2], &v3);
      if ( result == 1 )
      {
        result = *(_BYTE *)v3;
        if ( *(_BYTE *)v3 )
        {
          *(_BYTE *)dword_10120FA8 = result;
          *(_BYTE *)(dword_10120FA8 + 2) = *(_BYTE *)(v3 + 2);
          result = sub_10020640(dword_10120FA8 + 160012, (_BYTE *)(v3 + 160012), 100);
          v1 = 1;
        }
      }
      ++v2;
      if ( v2 >= 3 )
      {
        if ( v1 != 1 )
        {
          *(_BYTE *)dword_10120FA8 = *(_BYTE *)dword_10120FB4;
          *(_BYTE *)(dword_10120FA8 + 2) = *(_BYTE *)(dword_10120FB4 + 2);
          result = sub_10020640(dword_10120FA8 + 160012, (_BYTE *)(dword_10120FB4 + 160012), 100);
        }
        return result;
      }
    }
  }
  return result;
}
// 1006ECD0: using guessed type int dword_1006ECD0[];
// 10120FA8: using guessed type int dword_10120FA8;
// 10120FB4: using guessed type int dword_10120FB4;

//----- (10008BD0) --------------------------------------------------------
char __cdecl sub_10008BD0(char a1, int a2, int a3, int a4, int a5, void *a6, size_t a7)
{
  char result; // al@7
  int v8; // eax@8

  if ( *(_BYTE *)dword_10120FB4 == 11 )
    sub_10014510();
  if ( *(_BYTE *)dword_10120FB4 )
    sub_10008470(0);
  if ( (unsigned __int8)a2 >= 0x39u || dword_1006EBB0[(unsigned __int8)a2] == 28 )
  {
    *(_BYTE *)(dword_10120FB4 + 3) = a3;
    v8 = dword_10120FB4 + 5;
    *(_WORD *)v8 = *(_WORD *)a5;
    *(_BYTE *)(v8 + 2) = *(_BYTE *)(a5 + 2);
    if ( a7 >= 0x27100 )
    {
      *(_DWORD *)(dword_10120FB4 + 160008) = 0;
      sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 1198, 0, 0);
    }
    else
    {
      memcpy((void *)(dword_10120FB4 + 8), a6, a7);
      *(_DWORD *)(dword_10120FB4 + 160008) = a7;
      *(_BYTE *)(dword_10120FB4 + a7 + 8) = 0;
    }
    *(_BYTE *)(dword_10120FB4 + 4) = a4;
    *(_BYTE *)(dword_10120FB4 + 2) = a2;
    *(_BYTE *)(dword_10120FB4 + 1) = a1;
    dword_101267B8 = 0;
    dword_10120FB0 = 0;
    byte_101267BC = 0;
    switch ( a1 )
    {
      case 0:
        result = (unsigned int)sub_10008470(9);
        break;
      case 1:
        result = (unsigned int)sub_10008470(5);
        byte_101267BC = 1;
        break;
      case 2:
        result = (unsigned int)sub_10008470(2);
        break;
      case 3:
        result = (unsigned int)sub_10008470(1);
        break;
      case 4:
      case 6:
        result = (unsigned int)sub_10008470(6);
        break;
      case 5:
        if ( (_BYTE)a3 )
          goto LABEL_19;
        result = (unsigned int)sub_10008470(6);
        goto LABEL_20;
      case 7:
LABEL_19:
        result = (unsigned int)sub_10008470(2);
LABEL_20:
        if ( (_BYTE)a4 == 11 )
          byte_101267BC = 1;
        break;
      default:
        result = sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 1301, 0, 0);
        break;
    }
  }
  else
  {
    result = sub_10008580(a1, a5, a6, a2, a3, a4, a7);
  }
  return result;
}
// 1006EBB0: using guessed type int dword_1006EBB0[];
// 10120FB0: using guessed type int dword_10120FB0;
// 10120FB4: using guessed type int dword_10120FB4;
// 101267B8: using guessed type int dword_101267B8;
// 101267BC: using guessed type char byte_101267BC;

//----- (10008DB0) --------------------------------------------------------
void *sub_10008DB0()
{
  void *result; // eax@1

  dword_10120FA8 = -15;
  dword_101267C0 = (void *)-15;
  sub_100089C0();
  dword_10120FB4 = -15;
  sub_10008970();
  result = memset(&unk_102362C0, 0, 0x200u);
  word_102364C0 = 0;
  dword_101267C8 = 0;
  dword_10120FAC = 0;
  dword_101267C4 = 0;
  dword_101267CC = 0;
  return result;
}
// 10120FA8: using guessed type int dword_10120FA8;
// 10120FAC: using guessed type int dword_10120FAC;
// 10120FB4: using guessed type int dword_10120FB4;
// 101267C4: using guessed type int dword_101267C4;
// 101267C8: using guessed type int dword_101267C8;
// 101267CC: using guessed type int dword_101267CC;
// 102364C0: using guessed type __int16 word_102364C0;

//----- (10008E10) --------------------------------------------------------
char __usercall sub_10008E10@<al>(char *a1@<eax>, int a2@<edi>, char a3, unsigned int a4, int a5)
{
  int v5; // ebp@1
  char *v6; // esi@1
  signed int v7; // eax@1
  char v8; // bl@1
  unsigned int v9; // eax@2
  _DWORD *v10; // ecx@2
  char *v11; // edx@2
  int v12; // esi@6
  int v13; // eax@7
  _BYTE *v14; // ecx@7
  _BYTE *v15; // edx@7
  int v16; // eax@9
  _BYTE *v17; // ecx@9
  _BYTE *v18; // edx@9
  _BYTE *v19; // ecx@11
  _BYTE *v20; // edx@11
  signed int v21; // eax@13
  char v22; // bl@23
  char v23; // al@27
  char v24; // al@28

  v5 = a5;
  v6 = a1;
  v7 = sub_10008790(a4, a2, a1, a5);
  v8 = v7;
  if ( v7 )
    return v7;
  v9 = (unsigned __int16)a5;
  v10 = (_DWORD *)a2;
  v11 = v6;
  if ( (unsigned __int16)a5 < 4u )
  {
LABEL_5:
    if ( !v9 )
      goto LABEL_16;
  }
  else
  {
    while ( *(_DWORD *)v11 == *v10 )
    {
      v9 -= 4;
      ++v10;
      v11 += 4;
      if ( v9 < 4 )
        goto LABEL_5;
    }
  }
  v12 = (unsigned __int8)*v11 - *(_BYTE *)v10;
  if ( (unsigned __int8)*v11 != *(_BYTE *)v10
    || (v13 = v9 - 1, v14 = (char *)v10 + 1, v15 = v11 + 1, v13)
    && ((v12 = *v15 - *v14, *v15 != *v14)
     || (v16 = v13 - 1, v17 = v14 + 1, v18 = v15 + 1, v16)
     && ((v12 = *v18 - *v17, *v18 != *v17)
      || (v19 = v17 + 1, v20 = v18 + 1, v16 != 1) && (v12 = *v20 - *v19, *v20 != *v19))) )
  {
    v5 = a5;
    v21 = 1;
    if ( v12 <= 0 )
      v21 = -1;
    goto LABEL_17;
  }
  v5 = a5;
LABEL_16:
  v21 = 0;
LABEL_17:
  if ( v21 )
  {
    if ( a4 > 0x193E )
    {
      switch ( a4 )
      {
        case 0x1A6Au:
        case 0x1A6Bu:
        case 0x1A6Cu:
        case 0x1A6Du:
        case 0x1A6Eu:
          v23 = sub_100195A0(a3);
          LOBYTE(v7) = sub_10007C70(v23, a2) != 1 ? 0xF1 : 0;
          break;
        case 0x1A9Bu:
        case 0x1A9Cu:
        case 0x1A9Du:
        case 0x1A9Eu:
        case 0x1A9Fu:
        case 0x1AA0u:
        case 0x1AA1u:
          v24 = sub_100195A0(a3);
          LOBYTE(v7) = sub_10007BE0(v24, a2) != 1 ? 0xF1 : 0;
          break;
        default:
          goto LABEL_29;
      }
    }
    else
    {
      switch ( a4 )
      {
        case 0x193Eu:
          sub_10007990();
          LOBYTE(v7) = sub_1004E910(a4, a2, v5);
          break;
        case 0x1774u:
          sub_10005060(a2);
          LOBYTE(v7) = v8;
          break;
        case 0x1775u:
          v22 = sub_1004E910(6005, a2, v5);
          sub_1000F870();
          LOBYTE(v7) = v22;
          break;
        default:
LABEL_29:
          if ( a4 > 0x1B31 )
            LOBYTE(v7) = sub_1004E8F0(a4, a2, v5);
          else
            LOBYTE(v7) = sub_1004E910(a4, a2, v5);
          break;
      }
    }
  }
  else
  {
    LOBYTE(v7) = 0;
  }
  return v7;
}

//----- (10009010) --------------------------------------------------------
char __cdecl sub_10009010(int a1)
{
  char *v1; // ecx@0
  int v2; // edi@1
  char v3; // al@1
  int v4; // esi@1
  _WORD *v5; // esi@2
  int v6; // ebp@3
  int v7; // esi@4
  int v8; // edi@4
  int v9; // eax@5
  __int16 v10; // di@7
  char v11; // bl@7
  int v12; // eax@9
  int v13; // eax@14
  bool v14; // sf@20
  unsigned __int8 v15; // of@20
  char v17; // bl@38
  char v18; // ST10_1@42
  char v19; // al@42
  char v20; // [sp+13h] [bp-99h]@1
  unsigned __int16 v21; // [sp+14h] [bp-98h]@1
  _WORD *v22; // [sp+18h] [bp-94h]@2
  char *v23; // [sp+1Ch] [bp-90h]@1
  char v24[4]; // [sp+20h] [bp-8Ch]@1
  int v25; // [sp+24h] [bp-88h]@1
  int v26; // [sp+28h] [bp-84h]@1
  int v27; // [sp+2Ch] [bp-80h]@4
  int v28; // [sp+30h] [bp-7Ch]@4
  unsigned int v29; // [sp+34h] [bp-78h]@4
  char v30; // [sp+3Ch] [bp-70h]@9
  char v31; // [sp+44h] [bp-68h]@11

  v2 = (int)v1;
  v26 = a1;
  v3 = *v1;
  v23 = v1;
  v20 = 0;
  v24[0] = v3;
  v4 = sub_10009810(v3, &v21);
  sub_1004E7C0(9171, (int)&word_102364C0, 2);
  sub_1004E7C0(6451, (int)&unk_102362C0, 512);
  v25 = 0;
  if ( v21 )
  {
    v5 = (_WORD *)(v4 + 2);
    v22 = v5;
    while ( 1 )
    {
      v6 = 0;
      if ( !*v5 )
        goto LABEL_19;
      while ( 1 )
      {
        v7 = v6 + *(v22 - 1);
        v27 = 0;
        v28 = 0;
        v29 = 0;
        j_reg_get_tag_hdr(&v27, v7, v7);
        v8 = *(unsigned int *)((char *)&v29 + 2);
        memset(&dword_101267D0, 0, HIWORD(v29));
        if ( v7 == 6004 )
        {
          sub_10004D50((int)&dword_101267D0);
          v9 = 0;
        }
        else
        {
          v9 = sub_1004E7C0(v7, (int)&dword_101267D0, v8);
        }
        v10 = HIWORD(v29);
        v11 = 0;
        if ( v9 )
        {
          v11 = 1;
          memset(&dword_101267D0, 0, HIWORD(v29));
        }
        memcpy(&dword_10120FB8, &dword_101267D0, (unsigned __int16)v10);
        v12 = sub_1004E7E0(v7, (int)&dword_101267D0, v10, v26, (int)&v30);
        if ( !v12 )
          break;
        if ( v12 != -24 )
        {
          sub_10020770(&v31, 0x64u, "error %i reading reg %i from xml\n", v12, v7);
          sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 1946, 0, &v31);
          goto LABEL_18;
        }
LABEL_15:
        if ( ++v6 >= *v22 )
          goto LABEL_19;
      }
      v20 = 1;
      if ( v11 )
        dword_10120FB8 = ~dword_101267D0;
      v13 = (unsigned __int8)sub_10008E10(
                               (char *)&dword_10120FB8,
                               (int)&dword_101267D0,
                               v24[0],
                               v7,
                               *(unsigned int *)((char *)&v29 + 2));
      if ( !(_BYTE)v13 )
        goto LABEL_15;
      sub_10020770(&v31, 0x64u, "error %i writing reg %i oem_id %i\n", v13, v7, (unsigned __int16)word_102364C0);
      sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 1967, 0, &v31);
LABEL_18:
      v20 = 0;
LABEL_19:
      if ( v6 == *v22 )
      {
        v5 = v22 + 2;
        v15 = __OFSUB__(v25 + 1, v21);
        v14 = v25++ + 1 - v21 < 0;
        v22 += 2;
        if ( v14 ^ v15 )
          continue;
      }
      v2 = (int)v23;
      break;
    }
  }
  if ( !sub_1004F1C0(v26) )
  {
    v20 = 0;
    sub_1001B780(
      "..\\lib\\adl\\iop_cnfg_mngr.c",
      1996,
      0,
      "The file being loaded was deleted during the upload process.");
LABEL_24:
    sub_10008470(8);
    return v20;
  }
  if ( v20 != 1 )
    goto LABEL_24;
  switch ( *(_BYTE *)v2 )
  {
    case 0:
      sub_10015630();
      v20 = sub_1002AF60();
      if ( !v20 )
        sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 2012, 0, &v31);
      goto LABEL_40;
    case 0x17:
      v20 = sub_1001D810(1, &v31);
      if ( !v20 )
        sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 2020, 0, &v31);
      goto LABEL_40;
    case 0x18:
      v20 = sub_1001D810(0, &v31);
      if ( !v20 )
        sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 2028, 0, &v31);
      goto LABEL_40;
    case 0x35:
      v20 = sub_1001D810(2, &v31);
      if ( !v20 )
        sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 2036, 0, &v31);
      goto LABEL_40;
    case 0x2C:
      v20 = sub_1001C270((int)&v31);
      if ( !v20 )
        sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 2044, 0, &v31);
      goto LABEL_40;
    case 0x2D:
      v31 = 0;
      v17 = sub_1002A580();
      v20 = sub_1002A3A0(&v31) & v17;
      if ( !v20 )
        sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 2054, 0, &v31);
LABEL_40:
      if ( v20 == 1 )
        goto LABEL_41;
      goto LABEL_24;
    default:
LABEL_41:
      if ( *(_DWORD *)(v2 + 8) )
      {
        sub_10008470(1);
        v18 = v24[0];
        v19 = sub_10008330();
        sub_100083C0(v19, v18, 0, 11, 0, 0, 0);
        sub_1000F8E0();
      }
      else
      {
        sub_10008470(7);
        sub_1000F8E0();
      }
      break;
  }
  return v20;
}
// 1004E790: using guessed type int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD);
// 10120FB8: using guessed type int dword_10120FB8;
// 101267D0: using guessed type int dword_101267D0;
// 102364C0: using guessed type __int16 word_102364C0;

//----- (10009470) --------------------------------------------------------
char sub_10009470()
{
  char v0; // bl@1
  int v1; // esi@1
  int v2; // ecx@2
  int (__cdecl *v3)(_DWORD, _DWORD, _DWORD, int, int, _DWORD); // esi@3
  char v4; // al@5
  void (__cdecl *v5)(_DWORD); // ecx@12
  int (__cdecl *v7)(_DWORD, _DWORD, int); // esi@17
  int (__cdecl *v8)(_DWORD, _DWORD, _DWORD, int); // esi@21
  int v9; // edi@23
  char *v10; // eax@23
  int v11; // edx@23
  char v12; // cl@24
  int v13; // ebp@25
  char v14; // [sp+0h] [bp-68h]@11

  v0 = 0;
  v1 = sub_1001DC80((_DWORD *)(dword_10120FB4 + 2), 1u, (int)byte_1006E658, 44, 31, 57);
  if ( v1 < 57 )
  {
    v2 = dword_10120FB4;
    switch ( *(_BYTE *)dword_10120FB4 )
    {
      case 1:
        v3 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int, int, _DWORD))dword_1006E660[11 * v1];
        goto LABEL_4;
      case 0:
        break;
      case 2:
        v7 = (int (__cdecl *)(_DWORD, _DWORD, int))dword_1006E65C[11 * v1];
        goto LABEL_18;
      case 3:
        v7 = (int (__cdecl *)(_DWORD, _DWORD, int))dword_1006E66C[11 * v1];
LABEL_18:
        if ( !v7 )
          goto LABEL_9;
        v4 = v7(*(_BYTE *)(dword_10120FB4 + 2), *(_BYTE *)(dword_10120FB4 + 4), dword_10120FB4 + 5);
        goto LABEL_6;
      case 4:
        v8 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int))dword_1006E670[11 * v1];
        if ( !v8 )
          goto LABEL_9;
        v4 = v8(
               *(_BYTE *)(dword_10120FB4 + 2),
               *(_BYTE *)(dword_10120FB4 + 3),
               *(_BYTE *)(dword_10120FB4 + 4),
               dword_10120FB4 + 5);
        goto LABEL_6;
      case 5:
        v9 = dword_10120FB4 + 8;
        v10 = (char *)(dword_10120FB4 + 8);
        v11 = dword_10120FB4 + 9;
        do
          v12 = *v10++;
        while ( v12 );
        v13 = (int)&v10[-v11];
        if ( sub_10020690(&v10[v9 - 4] - v11, ".ini", 5) )
        {
          if ( !sub_10020690((_BYTE *)(v9 + v13 - 5), ".greg", 6) )
            v0 = sub_10009010(v9);
          j_FIL_vfs_sync_all();
        }
        else if ( byte_1006E658[44 * v1] )
        {
          v0 = 0;
          j_FIL_vfs_sync_all();
        }
        else
        {
          v0 = sub_100050A0(*(_BYTE *)(dword_10120FB4 + 2), v9);
          j_FIL_vfs_sync_all();
        }
        goto LABEL_7;
      case 6:
        v3 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int, int, _DWORD))dword_1006E664[11 * v1];
        goto LABEL_4;
      case 0xB:
        v3 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int, int, _DWORD))dword_1006E668[11 * v1];
        goto LABEL_4;
      case 7:
        sub_10008A80();
        break;
      case 8:
        sub_10008AA0();
        break;
      case 0xA:
        v3 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int, int, _DWORD))dword_1006E674[11 * v1];
LABEL_4:
        if ( !v3 )
          goto LABEL_9;
        v4 = v3(
               *(_BYTE *)(dword_10120FB4 + 2),
               *(_BYTE *)(dword_10120FB4 + 3),
               *(_BYTE *)(dword_10120FB4 + 4),
               dword_10120FB4 + 5,
               dword_10120FB4 + 8,
               *(_DWORD *)(dword_10120FB4 + 160008));
LABEL_6:
        v0 = v4;
LABEL_7:
        if ( v0 != 1 )
          goto LABEL_8;
        break;
      case 9:
        sub_10008A60();
        break;
      default:
        sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 972, 0, 0);
LABEL_8:
        v2 = dword_10120FB4;
LABEL_9:
        if ( (unsigned int)++dword_101267B8 > 0x32 || (unsigned int)sub_10008320() > 0x32 )
        {
          sprintf(&v14, "EXCEEDED RETRIES CNFG_PROD %d STATE %d\n", *(_BYTE *)(v2 + 2), *(_BYTE *)v2);
          sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr.c", 1009, 0, &v14);
          sub_10008470(8);
        }
        break;
    }
  }
  v5 = (void (__cdecl *)(_DWORD))dword_1006E67C[11 * dword_101267CC];
  if ( v5 )
    v5((unsigned __int8)byte_1006E658[44 * dword_101267CC]);
  if ( (unsigned int)++dword_101267CC >= 0x1F )
    dword_101267CC = 0;
  return sub_10008AC0();
}
// 1004F160: using guessed type int j_FIL_vfs_sync_all(void);
// 1006E65C: using guessed type int dword_1006E65C[];
// 1006E660: using guessed type int dword_1006E660[];
// 1006E664: using guessed type int dword_1006E664[];
// 1006E668: using guessed type int dword_1006E668[];
// 1006E66C: using guessed type int dword_1006E66C[];
// 1006E670: using guessed type int dword_1006E670[];
// 1006E674: using guessed type int dword_1006E674[];
// 1006E67C: using guessed type int dword_1006E67C[];
// 10120FB4: using guessed type int dword_10120FB4;
// 101267B8: using guessed type int dword_101267B8;
// 101267CC: using guessed type int dword_101267CC;

//----- (10009740) --------------------------------------------------------
int __cdecl sub_10009740(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001DC80(&a1, 1u, (int)&unk_10070888, 8, 67, 0);
  if ( v1 )
  {
    result = dword_1007088C[2 * v1];
  }
  else
  {
    sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 1007088C: using guessed type int dword_1007088C[];

//----- (10009790) --------------------------------------------------------
char __cdecl sub_10009790(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int (__cdecl *v7)(int, int, int, int, int, int); // eax@2

  v6 = sub_1001DC80(&a1, 1u, (int)&unk_100704E8, 16, 58, 57);
  if ( v6 == 57 )
  {
    sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 2231, 0, 0);
  }
  else
  {
    v7 = (int (__cdecl *)(int, int, int, int, int, int))dword_100704EC[4 * v6];
    if ( v7 )
      return v7(a1, a2, a3, a4, a5, a6);
  }
  return 0;
}
// 100704EC: using guessed type int dword_100704EC[];

//----- (10009810) --------------------------------------------------------
int __cdecl sub_10009810(char a1, _WORD *a2)
{
  int v2; // eax@1
  int v3; // ecx@1

  v2 = 8 * sub_1001DC80(&a1, 1u, (int)&unk_100704E8, 16, 58, 67);
  v3 = *(int *)((char *)&off_100704F0 + v2 * 2);
  *a2 = word_100704F4[v2];
  return v3;
}
// 100704F0: using guessed type void *off_100704F0;
// 100704F4: using guessed type __int16 word_100704F4[];

//----- (10009850) --------------------------------------------------------
char __cdecl sub_10009850(unsigned int a1)
{
  bool v1; // zf@2
  char result; // al@2
  unsigned int v3; // [sp+4h] [bp-4h]@1

  v3 = sub_1004E740(a1);
  if ( sub_1001DC80(&v3, 4u, (int)&unk_10070AA0, 4, 16, -1) == -1
    || (v1 = sub_1001DC80(&a1, 4u, (int)&unk_100704DC, 4, 3, -1) == -1, result = 1, !v1) )
  {
    result = 0;
  }
  return result;
}

//----- (100098B0) --------------------------------------------------------
signed int sub_100098B0()
{
  signed int result; // eax@1

  result = -15;
  dword_1012BFD4 = -15;
  dword_1012BFDC = -15;
  dword_1012BFD8 = -15;
  return result;
}
// 1012BFD4: using guessed type int dword_1012BFD4;
// 1012BFD8: using guessed type int dword_1012BFD8;
// 1012BFDC: using guessed type int dword_1012BFDC;

//----- (100098D0) --------------------------------------------------------
char sub_100098D0()
{
  return sub_10008300(&dword_1012BFD0);
}
// 1012BFD0: using guessed type int dword_1012BFD0;

//----- (100098E0) --------------------------------------------------------
signed int __usercall sub_100098E0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@1
  int v3; // eax@2
  signed int result; // eax@4

  v2 = a1 - 29;
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 == 1 )
        result = sub_1004F6B0((int)&off_10070B08);
      else
        result = sub_1004F6B0(a2);
    }
    else
    {
      result = sub_1004F6B0((int)&off_10070AF4);
    }
  }
  else
  {
    result = sub_1004F6B0((int)&off_10070AE0);
  }
  return result;
}
// 10070AE0: using guessed type char *off_10070AE0;
// 10070AF4: using guessed type char *off_10070AF4;
// 10070B08: using guessed type char *off_10070B08;

//----- (10009930) --------------------------------------------------------
char __usercall sub_10009930@<al>(char a1@<bl>, int a2@<edi>, const void *a3@<esi>, char a4, char a5, char a6, unsigned int a7)
{
  char v7; // dl@12
  __int16 v9; // [sp+4h] [bp-528h]@1
  char v10; // [sp+8h] [bp-524h]@11
  char v11; // [sp+9h] [bp-523h]@11
  char v12; // [sp+Ah] [bp-522h]@11
  char v13; // [sp+Bh] [bp-521h]@11
  __int16 v14; // [sp+Ch] [bp-520h]@12
  char v15; // [sp+Eh] [bp-51Eh]@12
  char v16; // [sp+Fh] [bp-51Dh]@15
  unsigned int v17; // [sp+524h] [bp-8h]@15

  memset(&v9, 0, 0x524u);
  if ( (unsigned __int8)a1 >= 8u )
    sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3425, 0, 0);
  if ( (unsigned __int8)a4 >= 0x39u )
    sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3426, 0, 0);
  if ( (unsigned __int8)a5 >= 2u )
    sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3427, 0, 0);
  if ( (unsigned __int8)a6 >= 0x2Cu )
    sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3428, 0, 0);
  if ( a7 >= 0x514 )
    sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3429, 0, 0);
  v13 = a6;
  v9 = -32749;
  v10 = a1;
  v11 = a4;
  v12 = a5;
  if ( a2 )
  {
    v7 = *(_BYTE *)(a2 + 2);
    v14 = *(_WORD *)a2;
    v15 = v7;
  }
  else
  {
    v14 = 0;
    v15 = 0;
  }
  if ( a3 )
  {
    memcpy(&v16, a3, a7);
    v17 = a7;
  }
  else
  {
    v17 = 0;
  }
  return sub_10023A80((int)&v9);
}

//----- (10009A90) --------------------------------------------------------
char __cdecl sub_10009A90(char a1, char a2)
{
  char result; // al@3
  char v3; // [sp+7h] [bp-Dh]@3
  int v4; // [sp+8h] [bp-Ch]@1
  __int16 v5; // [sp+Ch] [bp-8h]@1

  v4 = 0;
  v5 = 0;
  if ( (unsigned __int8)a1 >= 0x43u )
    sub_1001B780("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 2085, 0, 0);
  result = sub_10009800(a1, &v3);
  if ( result == 1 )
  {
    result = a2;
    if ( v3 != a2 )
    {
      LOWORD(v4) = -32748;
      LOBYTE(v5) = a1;
      HIBYTE(v5) = a2;
      result = sub_10023A80((int)&v4);
    }
  }
  if ( !a2 && (a1 == 4 || a1 == 5 || a1 == 3 || a1 == 40 || a1 == 41 || a1 == 51 || a1 == 52) )
  {
    sub_1001A110(0);
    result = sub_1001BF40(0x3Fu);
  }
  return result;
}
// 10009800: using guessed type _DWORD __cdecl sub_10009800(char, _DWORD);

//----- (10009B50) --------------------------------------------------------
char __cdecl sub_10009B50(_BYTE *a1)
{
  char result; // al@2

  if ( sub_100098D0() == 1 )
  {
    *a1 = *(_BYTE *)dword_1012BFD0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1012BFD0: using guessed type int dword_1012BFD0;

//----- (10009B80) --------------------------------------------------------
char __cdecl sub_10009B80(char a1, char a2, char a3, int a4, const void *a5, unsigned int a6)
{
  return sub_10009930(4, a4, a5, a1, a2, a3, a6);
}

//----- (10009BB0) --------------------------------------------------------
char __cdecl sub_10009BB0(int a1, _DWORD *a2)
{
  int v2; // ecx@0
  char result; // al@5

  if ( (unsigned __int8)sub_100098E0(a1, v2) == 1 )
  {
    if ( a1 == 29 )
    {
      *a2 = dword_1012BFD4;
    }
    else
    {
      if ( a1 == 30 )
      {
        *a2 = dword_1012BFDC;
        return 1;
      }
      if ( a1 == 31 )
      {
        *a2 = dword_1012BFD8;
        return 1;
      }
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1012BFD4: using guessed type int dword_1012BFD4;
// 1012BFD8: using guessed type int dword_1012BFD8;
// 1012BFDC: using guessed type int dword_1012BFDC;

//----- (10009C10) --------------------------------------------------------
void sub_10009C10()
{
  dword_102362B8 = -15;
}
// 102362B8: using guessed type int dword_102362B8;

//----- (10009C30) --------------------------------------------------------
char __cdecl sub_10009C30(unsigned __int8 a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  int v3; // eax@1
  char result; // al@2
  char v5[68]; // [sp+0h] [bp-48h]@1

  v2 = sub_10029030(v1);
  v3 = sub_10028F00(v2);
  if ( sub_1004E7C0(v3, (int)v5, 67) )
    result = 0;
  else
    result = v5[a1];
  return result;
}
// 10009C30: using guessed type char var_48[68];

//----- (10009C90) --------------------------------------------------------
char __cdecl sub_10009C90(unsigned __int8 a1, unsigned __int8 a2, float *a3)
{
  char result; // al@1
  int v4; // eax@4
  int v5; // esi@7
  int v6; // edi@8

  result = 0;
  if ( a1 < 0x43u && a2 < 3u )
  {
    if ( a1 > 0x34u )
    {
      result = sub_1000A030(a1, a2, a3);
    }
    else
    {
      v4 = sub_10009D60(a1);
      if ( v4
        && (v5 = v4 + 4 * a2, *(_BYTE *)v5 < 7)
        && (v6 = *(_WORD *)(v5 + 2), (unsigned __int16)v6 < (unsigned __int16)sub_1000FF80(*(_BYTE *)v5)) )
      {
        result = sub_10010C50(*(_BYTE *)v5, v6, a3);
      }
      else
      {
        result = 0;
      }
    }
  }
  return result;
}
// 10009D60: using guessed type _DWORD __cdecl sub_10009D60(char);

//----- (10009D10) --------------------------------------------------------
char __cdecl sub_10009D10(unsigned __int8 a1, float *a2)
{
  unsigned __int8 v2; // al@1

  v2 = sub_10009C30(a1);
  return sub_10009C90(a1, v2, a2);
}

//----- (10009D30) --------------------------------------------------------
int __cdecl sub_10009D30(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001DC80(&a1, 1u, (int)&unk_10070E20, 8, 53, 67);
  if ( v1 == 67 )
    result = 0;
  else
    result = (int)*(&off_10070E24 + 2 * v1);
  return result;
}
// 10070E24: using guessed type void *off_10070E24;

//----- (10009D70) --------------------------------------------------------
char __cdecl sub_10009D70(char a1)
{
  int v1; // ebx@1
  signed int v2; // eax@4
  unsigned int v3; // edi@9
  int v4; // esi@9
  char v5; // al@11
  char v6; // cl@11
  double v7; // st7@13
  double v8; // st7@15
  double v9; // st7@17
  int v10; // edx@24
  double v11; // st7@27
  char result; // al@33
  float v13; // [sp+38h] [bp-20h]@1
  int v14; // [sp+3Ch] [bp-1Ch]@9
  char v15[4]; // [sp+40h] [bp-18h]@11
  int v16; // [sp+44h] [bp-14h]@1
  float v17; // [sp+48h] [bp-10h]@29
  int v18; // [sp+4Ch] [bp-Ch]@1
  int v19[2]; // [sp+50h] [bp-8h]@21

  v18 = sub_1004E4B0();
  v1 = sub_1001DC80(&a1, 1u, (int)byte_10071048, 24, 14, 14);
  v13 = 0.0;
  v16 = v1;
  if ( v1 >= 14 )
  {
    result = sub_1001B780("..\\lib\\adl\\iop_fltr_data.c", 690, 0, 0);
  }
  else
  {
    if ( a1 == 59 )
    {
      if ( byte_1012C564 )
      {
        v2 = (unsigned __int16)word_1012C7D8 - 1 <= 0 ? 0 : (unsigned __int16)word_1012C7D8 - 1;
      }
      else
      {
        v2 = (unsigned __int16)word_1012C7D8 + 1;
        if ( v2 >= 60 )
          LOWORD(v2) = 60;
      }
      word_1012C7D8 = v2;
    }
    if ( !sub_1004E560(33, 10) )
    {
      v3 = 24 * v1;
      LOBYTE(v14) = 0;
      v4 = 0;
      while ( 1 )
      {
        v5 = sub_10009C90(byte_1007104C[v3], v14, &v13);
        v6 = a1;
        v15[0] = v5;
        if ( !v5 )
          goto LABEL_19;
        if ( a1 == 59 )
        {
          v7 = v13;
          if ( v13 < 11.31777763366699 )
            v7 = 11.317778;
          v13 = v7;
          v8 = v13;
        }
        else
        {
          if ( a1 != 66 )
            goto LABEL_19;
          v9 = v13;
          flt_1012C8BC[v4] = (flt_1012C8BC[v4] + v13 - flt_1012C148[v4]) * 0.9997500777244568;
          flt_1012C148[v4] = v9;
          v8 = flt_1012C8BC[v4];
        }
        v13 = v8;
LABEL_19:
        if ( byte_1007104D[v3] )
        {
          if ( byte_1007104D[v3] != 1 )
            goto LABEL_24;
          sub_1004E1A0(
            v15[0],
            v13,
            (int)(&off_1007105C)[v3 / 8],
            *(&off_10071050 + v4 + 6 * v1),
            (unsigned __int8)v6 + v4 + 2 * (unsigned __int8)v6 + dword_1012C724 + 37,
            (int)v19);
        }
        else
        {
          sub_1004E110(
            v15[0],
            v13,
            (int)(&off_1007105C)[v3 / 8],
            *(&off_10071050 + v4 + 6 * v1),
            (unsigned __int8)v6 + v4 + 2 * (unsigned __int8)v6 + dword_1012C724 + 37,
            (int)v19);
        }
        v6 = a1;
LABEL_24:
        v10 = dword_1012C724;
        if ( !*(_BYTE *)((unsigned __int8)v6 + v4 + 2 * (unsigned __int8)v6 + dword_1012C724 + 37) )
          goto LABEL_32;
        if ( byte_10071048[v3] == 59 )
        {
          if ( !word_1012C7D8 )
          {
            v11 = 0.0;
LABEL_30:
            *(double *)v19 = v11;
            goto LABEL_31;
          }
          if ( (unsigned __int16)word_1012C7D8 < 0x3Cu )
          {
            LODWORD(v17) = (unsigned __int16)word_1012C7D8;
            v11 = (double)(unsigned __int16)word_1012C7D8 / 60.0 * *(double *)v19;
            goto LABEL_30;
          }
        }
LABEL_31:
        v17 = *(double *)v19;
        *(float *)(dword_1012C724 + 4 * ((unsigned __int8)v6 - 53 + v4 + 2 * ((unsigned __int8)v6 - 53))) = v17;
        v6 = a1;
        v10 = dword_1012C724;
LABEL_32:
        *(_DWORD *)(v10 + 4 * ((unsigned __int8)v6 - 33 + v4++ + 2 * ((unsigned __int8)v6 - 33))) = v18;
        LOBYTE(v14) = v14 + 1;
        if ( (unsigned __int8)v14 >= 3u )
          return sub_1004E540(33);
        v1 = v16;
      }
    }
    result = sub_1001B780("..\\lib\\adl\\iop_fltr_data.c", 685, 0, 0);
  }
  return result;
}
// 1007105C: using guessed type double *off_1007105C;
// 1012C148: using guessed type float flt_1012C148[];
// 1012C564: using guessed type char byte_1012C564;
// 1012C724: using guessed type int dword_1012C724;
// 1012C7D8: using guessed type __int16 word_1012C7D8;
// 1012C8BC: using guessed type float flt_1012C8BC[];

//----- (1000A030) --------------------------------------------------------
char __cdecl sub_1000A030(unsigned __int8 a1, unsigned __int8 a2, float *a3)
{
  int v3; // eax@1
  char result; // al@5

  v3 = sub_1004E4B0();
  if ( (unsigned __int8)(a1 - 53) > 0xDu || a2 >= 3u )
  {
    sub_1001B780("..\\lib\\adl\\iop_fltr_data.c", 771, 0, 0);
    result = 0;
  }
  else if ( (unsigned int)(v3 - *(_DWORD *)(dword_1012C724 + 4 * (a1 - 33 + a2 + 2 * (a1 - 33)))) <= 0x258
         && *(_BYTE *)(a1 + a2 + 2 * a1 + dword_1012C724 + 37) )
  {
    *a3 = *(float *)(dword_1012C724 + 4 * (a1 - 53 + a2 + 2 * (a1 - 53)));
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1012C724: using guessed type int dword_1012C724;

//----- (1000A0C0) --------------------------------------------------------
int __cdecl sub_1000A0C0(float a1)
{
  char v1; // bl@1
  double v2; // st7@4
  double v3; // st5@4
  double v4; // st5@4
  double v5; // st3@4
  double v6; // st7@4
  double v7; // st7@6
  double v8; // st6@6
  double v9; // st5@6
  double v10; // st4@6
  double v11; // st6@6
  double v12; // st5@6
  double v13; // st7@6
  double v14; // st5@6
  double v15; // st7@6
  double v16; // st5@6
  double v17; // st7@6
  double v18; // st5@6
  double v19; // st7@6
  double v20; // st5@6
  double v21; // st7@6
  double v22; // st5@6
  int result; // eax@6
  int v24; // [sp-10h] [bp-30h]@2
  float *v25; // [sp-Ch] [bp-2Ch]@2
  __int64 *v26; // [sp-4h] [bp-24h]@2
  __int64 v27; // [sp+4h] [bp-1Ch]@1
  float v28; // [sp+Ch] [bp-14h]@6
  float v29; // [sp+10h] [bp-10h]@2
  float v30; // [sp+14h] [bp-Ch]@4
  __int64 v31; // [sp+18h] [bp-8h]@4
  float v32; // [sp+24h] [bp+4h]@4
  float v33; // [sp+24h] [bp+4h]@4
  float v34; // [sp+24h] [bp+4h]@4
  float v35; // [sp+24h] [bp+4h]@4
  float v36; // [sp+24h] [bp+4h]@6
  float v37; // [sp+24h] [bp+4h]@6
  float v38; // [sp+24h] [bp+4h]@6
  float v39; // [sp+24h] [bp+4h]@6
  float v40; // [sp+24h] [bp+4h]@6
  float v41; // [sp+24h] [bp+4h]@6
  float v42; // [sp+24h] [bp+4h]@6
  float v43; // [sp+24h] [bp+4h]@6
  float v44; // [sp+24h] [bp+4h]@6
  float v45; // [sp+24h] [bp+4h]@6
  float v46; // [sp+24h] [bp+4h]@6
  float v47; // [sp+24h] [bp+4h]@6
  float v48; // [sp+24h] [bp+4h]@6
  float v49; // [sp+24h] [bp+4h]@6
  float v50; // [sp+24h] [bp+4h]@6

  v1 = LOBYTE(a1);
  *(float *)&v27 = 0.152;
  if ( LOBYTE(a1) )
  {
    v26 = &v27;
    v25 = &v29;
    v24 = 6167;
  }
  else
  {
    v26 = &v27;
    v25 = &v29;
    v24 = 6269;
  }
  sub_1004E880(v24, v25, 4, v26);
  *(float *)&v27 = 1.35;
  sub_1004E880(6168, &v31, 4, &v27);
  dword_1012C4D0 = 14000;
  v32 = 1.414213562 / v29;
  v2 = v32;
  v33 = 2.828427124 * v32 / 0.08;
  *(float *)&v27 = v2 * v2;
  v3 = *(float *)&v27;
  *(float *)&v27 = v33 + 625.0 + *(float *)&v27;
  dbl_1012C6C8 = (v3 * 2.0 - 1250.0) / *(float *)&v27;
  dbl_1012C6D0 = (625.0 - v33 + v3) / *(float *)&v27;
  dbl_1012C6D8 = v3 / *(float *)&v27;
  dbl_1012C6E0 = dbl_1012C6D8 * 2.0;
  dbl_1012C6E8 = dbl_1012C6D8;
  dbl_1012C4A8 = -1.98653484543867;
  dword_1012C6F0 = 1000 * (unsigned __int64)(signed __int64)(3.68888 / v2 / 0.707106781);
  dbl_1012C4B0 = 0.9865907091056494;
  dbl_1012C4B8 = 0.001117441608985017;
  dbl_1012C4C0 = 0.0;
  dbl_1012C4C8 = -0.001117441608985017;
  dbl_1012C3F4 = -1.663865633267327;
  byte_1012C564 = v1 == 0;
  dbl_1012C3FC = 0.6974790317485409;
  dword_1012C41C = 0;
  dbl_1012C404 = 0.168067235645623;
  dbl_1012C40C = 0.0;
  dbl_1012C414 = -0.168067235645623;
  v34 = 2.0 / *(float *)&v31;
  v4 = v34;
  v35 = 4.0 * v34 / 0.04;
  *(float *)&v27 = v4 * v4;
  v5 = *(float *)&v27;
  *(float *)&v27 = v35 + 2500.0 + *(float *)&v27;
  dbl_1012C368 = (v5 * 2.0 - 5000.0) / *(float *)&v27;
  dbl_1012C370 = (2500.0 - v35 + v5) / *(float *)&v27;
  dbl_1012C378 = v5 / *(float *)&v27;
  dbl_1012C380 = 2.0 * dbl_1012C378;
  dbl_1012C388 = dbl_1012C378;
  v27 = (signed __int64)(3.68888 / v4);
  dword_1012C390 = 1000 * v27;
  *(float *)&v27 = 0.0;
  sub_1004E880(6950, &v30, 4, &v27);
  v6 = 0.001;
  if ( v30 > 0.001 )
    v6 = v30;
  v36 = v6;
  v7 = v36;
  v30 = v36;
  v37 = 8.0 / v36;
  v8 = v37;
  v9 = v37;
  v38 = v37 * 16.0 / 0.05;
  *(float *)&v27 = v9 * v9;
  v10 = *(float *)&v27;
  *(float *)&v27 = v38 + 1600.0 + *(float *)&v27;
  dbl_1012C508 = (v10 * 2.0 - 3200.0) / *(float *)&v27;
  dbl_1012C510 = (1600.0 - v38 + v10) / *(float *)&v27;
  dbl_1012C518 = v10 / *(float *)&v27;
  dbl_1012C520 = dbl_1012C518 * 2.0;
  dbl_1012C528 = dbl_1012C518;
  v27 = (signed __int64)(v7 * 1000.0);
  dword_1012C530 = v27;
  v39 = v8;
  v11 = v39;
  v40 = 16.0 * v39 / 0.025;
  *(float *)&v27 = v11 * v11;
  v12 = *(float *)&v27;
  *(float *)&v27 = v40 + 6399.999999999999 + *(float *)&v27;
  dword_1012C0E4 = (signed __int64)(v7 * 1000.0);
  dbl_1012C0BC = (v12 * 2.0 - 12800.0) / *(float *)&v27;
  dbl_1012C0C4 = (6399.999999999999 - v40 + v12) / *(float *)&v27;
  dbl_1012C0CC = v12 / *(float *)&v27;
  dbl_1012C0D4 = 2.0 * dbl_1012C0CC;
  dbl_1012C0DC = dbl_1012C0CC;
  *(float *)&v27 = 0.152;
  sub_1004E880(6658, &v28, 4, &v27);
  v41 = 1.414213562 / v28;
  v13 = v41;
  v42 = 2.828427124 * v41 / 0.08;
  *(float *)&v27 = v13 * v13;
  v14 = *(float *)&v27;
  *(float *)&v27 = v42 + 625.0 + *(float *)&v27;
  dbl_1012C94C = (v14 * 2.0 - 1250.0) / *(float *)&v27;
  dbl_1012C954 = (625.0 - v42 + v14) / *(float *)&v27;
  dbl_1012C95C = v14 / *(float *)&v27;
  dbl_1012C964 = 2.0 * dbl_1012C95C;
  dbl_1012C96C = dbl_1012C95C;
  v27 = (signed __int64)(3.68888 / v13 / 0.707106781);
  *(float *)&v27 = 0.152;
  dword_1012C974 = 1000 * (unsigned __int64)(signed __int64)(3.68888 / v13 / 0.707106781);
  sub_1004E880(6659, &v28, 4, &v27);
  v43 = 1.414213562 / v28;
  v15 = v43;
  v44 = 2.828427124 * v43 / 0.08;
  *(float *)&v27 = v15 * v15;
  v16 = *(float *)&v27;
  *(float *)&v27 = v44 + 625.0 + *(float *)&v27;
  dbl_1012C1AC = (v16 * 2.0 - 1250.0) / *(float *)&v27;
  dbl_1012C1B4 = (625.0 - v44 + v16) / *(float *)&v27;
  dbl_1012C1BC = v16 / *(float *)&v27;
  dbl_1012C1C4 = 2.0 * dbl_1012C1BC;
  dbl_1012C1CC = dbl_1012C1BC;
  v27 = (signed __int64)(3.68888 / v15 / 0.707106781);
  *(float *)&v27 = 0.152;
  dword_1012C1D4 = 1000 * (unsigned __int64)(signed __int64)(3.68888 / v15 / 0.707106781);
  sub_1004E880(6660, &v28, 4, &v27);
  v45 = 1.414213562 / v28;
  v17 = v45;
  v46 = 2.828427124 * v45 / 0.08;
  *(float *)&v27 = v17 * v17;
  v18 = *(float *)&v27;
  *(float *)&v27 = v46 + 625.0 + *(float *)&v27;
  dbl_1012C808 = (v18 * 2.0 - 1250.0) / *(float *)&v27;
  dbl_1012C810 = (625.0 - v46 + v18) / *(float *)&v27;
  dbl_1012C818 = v18 / *(float *)&v27;
  dbl_1012C820 = 2.0 * dbl_1012C818;
  dbl_1012C828 = dbl_1012C818;
  v27 = (signed __int64)(3.68888 / v17 / 0.707106781);
  *(float *)&v27 = 0.152;
  dword_1012C830 = 1000 * (unsigned __int64)(signed __int64)(3.68888 / v17 / 0.707106781);
  sub_1004E880(6661, &v28, 4, &v27);
  v47 = 1.414213562 / v28;
  v19 = v47;
  v48 = 2.828427124 * v47 / 0.08;
  *(float *)&v27 = v19 * v19;
  v20 = *(float *)&v27;
  *(float *)&v27 = v48 + 625.0 + *(float *)&v27;
  dbl_1012C0EC = (v20 * 2.0 - 1250.0) / *(float *)&v27;
  dbl_1012C0F4 = (625.0 - v48 + v20) / *(float *)&v27;
  dbl_1012C0FC = v20 / *(float *)&v27;
  dbl_1012C104 = 2.0 * dbl_1012C0FC;
  dbl_1012C10C = dbl_1012C0FC;
  v27 = (signed __int64)(3.68888 / v19 / 0.707106781);
  *(float *)&v27 = 0.152;
  dword_1012C114 = 1000 * (unsigned __int64)(signed __int64)(3.68888 / v19 / 0.707106781);
  sub_1004E880(6662, &v28, 4, &v27);
  v49 = 1.414213562 / v28;
  v21 = v49;
  v50 = 2.828427124 * v49 / 0.08;
  *(float *)&v27 = v21 * v21;
  v22 = *(float *)&v27;
  *(float *)&v27 = v50 + 625.0 + *(float *)&v27;
  dbl_1012C3C4 = (v22 * 2.0 - 1250.0) / *(float *)&v27;
  dword_1012C500 = 14000;
  result = LOWORD(v50) | 0xC00;
  dbl_1012C3CC = (625.0 - v50 + v22) / *(float *)&v27;
  dbl_1012C3D4 = v22 / *(float *)&v27;
  dbl_1012C3DC = 2.0 * dbl_1012C3D4;
  dbl_1012C3E4 = dbl_1012C3D4;
  dbl_1012C4D8 = -1.98653484543867;
  dword_1012C3EC = 1000 * (unsigned __int64)(signed __int64)(3.68888 / v21 / 0.707106781);
  dbl_1012C4E0 = 0.9865907091056494;
  dbl_1012C4E8 = 0.001117441608985017;
  dbl_1012C4F0 = 0.0;
  dbl_1012C4F8 = -0.001117441608985017;
  return result;
}
// 1012C0BC: using guessed type double dbl_1012C0BC;
// 1012C0C4: using guessed type double dbl_1012C0C4;
// 1012C0CC: using guessed type double dbl_1012C0CC;
// 1012C0D4: using guessed type double dbl_1012C0D4;
// 1012C0DC: using guessed type double dbl_1012C0DC;
// 1012C0E4: using guessed type int dword_1012C0E4;
// 1012C0EC: using guessed type double dbl_1012C0EC;
// 1012C0F4: using guessed type double dbl_1012C0F4;
// 1012C0FC: using guessed type double dbl_1012C0FC;
// 1012C104: using guessed type double dbl_1012C104;
// 1012C10C: using guessed type double dbl_1012C10C;
// 1012C114: using guessed type int dword_1012C114;
// 1012C1AC: using guessed type double dbl_1012C1AC;
// 1012C1B4: using guessed type double dbl_1012C1B4;
// 1012C1BC: using guessed type double dbl_1012C1BC;
// 1012C1C4: using guessed type double dbl_1012C1C4;
// 1012C1CC: using guessed type double dbl_1012C1CC;
// 1012C1D4: using guessed type int dword_1012C1D4;
// 1012C368: using guessed type double dbl_1012C368;
// 1012C370: using guessed type double dbl_1012C370;
// 1012C378: using guessed type double dbl_1012C378;
// 1012C380: using guessed type double dbl_1012C380;
// 1012C388: using guessed type double dbl_1012C388;
// 1012C390: using guessed type int dword_1012C390;
// 1012C3C4: using guessed type double dbl_1012C3C4;
// 1012C3CC: using guessed type double dbl_1012C3CC;
// 1012C3D4: using guessed type double dbl_1012C3D4;
// 1012C3DC: using guessed type double dbl_1012C3DC;
// 1012C3E4: using guessed type double dbl_1012C3E4;
// 1012C3EC: using guessed type int dword_1012C3EC;
// 1012C3F4: using guessed type double dbl_1012C3F4;
// 1012C3FC: using guessed type double dbl_1012C3FC;
// 1012C404: using guessed type double dbl_1012C404;
// 1012C40C: using guessed type double dbl_1012C40C;
// 1012C414: using guessed type double dbl_1012C414;
// 1012C41C: using guessed type int dword_1012C41C;
// 1012C4A8: using guessed type double dbl_1012C4A8;
// 1012C4B0: using guessed type double dbl_1012C4B0;
// 1012C4B8: using guessed type double dbl_1012C4B8;
// 1012C4C0: using guessed type double dbl_1012C4C0;
// 1012C4C8: using guessed type double dbl_1012C4C8;
// 1012C4D0: using guessed type int dword_1012C4D0;
// 1012C4D8: using guessed type double dbl_1012C4D8;
// 1012C4E0: using guessed type double dbl_1012C4E0;
// 1012C4E8: using guessed type double dbl_1012C4E8;
// 1012C4F0: using guessed type double dbl_1012C4F0;
// 1012C4F8: using guessed type double dbl_1012C4F8;
// 1012C500: using guessed type int dword_1012C500;
// 1012C508: using guessed type double dbl_1012C508;
// 1012C510: using guessed type double dbl_1012C510;
// 1012C518: using guessed type double dbl_1012C518;
// 1012C520: using guessed type double dbl_1012C520;
// 1012C528: using guessed type double dbl_1012C528;
// 1012C530: using guessed type int dword_1012C530;
// 1012C564: using guessed type char byte_1012C564;
// 1012C6C8: using guessed type double dbl_1012C6C8;
// 1012C6D0: using guessed type double dbl_1012C6D0;
// 1012C6D8: using guessed type double dbl_1012C6D8;
// 1012C6E0: using guessed type double dbl_1012C6E0;
// 1012C6E8: using guessed type double dbl_1012C6E8;
// 1012C6F0: using guessed type int dword_1012C6F0;
// 1012C808: using guessed type double dbl_1012C808;
// 1012C810: using guessed type double dbl_1012C810;
// 1012C818: using guessed type double dbl_1012C818;
// 1012C820: using guessed type double dbl_1012C820;
// 1012C828: using guessed type double dbl_1012C828;
// 1012C830: using guessed type int dword_1012C830;
// 1012C94C: using guessed type double dbl_1012C94C;
// 1012C954: using guessed type double dbl_1012C954;
// 1012C95C: using guessed type double dbl_1012C95C;
// 1012C964: using guessed type double dbl_1012C964;
// 1012C96C: using guessed type double dbl_1012C96C;
// 1012C974: using guessed type int dword_1012C974;

//----- (1000A9E0) --------------------------------------------------------
char sub_1000A9E0()
{
  char result; // al@2

  dword_1012C724 = -15;
  if ( sub_1004F780((LONG)&off_10071198) )
    result = sub_1004F310((int)&off_10071198);
  else
    result = sub_1001B780("..\\lib\\adl\\iop_fltr_data.c", 1297, 1, 0);
  return result;
}
// 10071198: using guessed type char *off_10071198;
// 1012C724: using guessed type int dword_1012C724;

//----- (1000AA20) --------------------------------------------------------
signed int sub_1000AA20()
{
  signed int result; // eax@1
  _WORD *v1; // ecx@1

  sub_1000A0C0(COERCE_FLOAT(1));
  dword_1012C6F4 = (int)sub_1004E4B0;
  dword_1012C4D4 = (int)sub_1004E4B0;
  dword_1012C420 = (int)sub_1004E4B0;
  dword_1012C394 = (int)sub_1004E4B0;
  dword_1012C534 = (int)sub_1004E4B0;
  dword_1012C0E8 = (int)sub_1004E4B0;
  dword_1012C978 = (int)sub_1004E4B0;
  dword_1012C1D8 = (int)sub_1004E4B0;
  dword_1012C834 = (int)sub_1004E4B0;
  dword_1012C118 = (int)sub_1004E4B0;
  dword_1012C3F0 = (int)sub_1004E4B0;
  dword_1012C504 = (int)sub_1004E4B0;
  sub_1004DFF0((int)&unk_1012C8F4);
  sub_1004DFF0((int)&unk_1012C644);
  sub_1004DFF0((int)&unk_1012C5C0);
  sub_1004DFF0((int)&unk_1012C090);
  sub_1004DFF0((int)&unk_1012BFE0);
  sub_1004DFF0((int)&unk_1012C670);
  sub_1004DFF0((int)&unk_1012C838);
  sub_1004DFF0((int)&unk_1012C8C8);
  sub_1004DFF0((int)&unk_1012C2B8);
  sub_1004DFF0((int)&unk_1012C47C);
  sub_1004DFF0((int)&unk_1012C5EC);
  sub_1004DFF0((int)&unk_1012C398);
  sub_1004DFF0((int)&unk_1012C180);
  sub_1004DFF0((int)&unk_1012C450);
  sub_1004DFF0((int)&unk_1012C208);
  sub_1004DFF0((int)&unk_1012C260);
  sub_1004DFF0((int)&unk_1012C33C);
  sub_1004DFF0((int)&unk_1012C1DC);
  sub_1004DFF0((int)&unk_1012C154);
  sub_1004DFF0((int)&unk_1012C310);
  sub_1004DFF0((int)&unk_1012C6F8);
  sub_1004DFF0((int)&unk_1012C780);
  sub_1004DFF0((int)&unk_1012C00C);
  sub_1004DFF0((int)&unk_1012C7DC);
  sub_1004DFF0((int)&unk_1012C11C);
  sub_1004DFF0((int)&unk_1012C568);
  sub_1004DFF0((int)&unk_1012C064);
  sub_1004DFF0((int)&unk_1012C728);
  sub_1004DFF0((int)&unk_1012C7AC);
  sub_1004DFF0((int)&unk_1012C28C);
  sub_1004DFF0((int)&unk_1012C890);
  sub_1004DFF0((int)&unk_1012C234);
  sub_1004DFF0((int)&unk_1012C2E4);
  sub_1004DFF0((int)&unk_1012C618);
  sub_1004DFF0((int)&unk_1012C594);
  sub_1004DFF0((int)&unk_1012C754);
  sub_1004DFF0((int)&unk_1012C69C);
  sub_1004DFF0((int)&unk_1012C038);
  sub_1004DFF0((int)&unk_1012C920);
  sub_1004DFF0((int)&unk_1012C538);
  sub_1004DFF0((int)&unk_1012C424);
  sub_1004DFF0((int)&unk_1012C864);
  byte_1012C564 = 0;
  word_1012C7D8 = 60;
  LODWORD(flt_1012C148[0]) = 0;
  dword_1012C14C = 0;
  dword_1012C150 = 0;
  LODWORD(flt_1012C8BC[0]) = 0;
  dword_1012C8C0 = 0;
  dword_1012C8C4 = 0;
  sub_1000A9E0();
  result = 168;
  v1 = &unk_1007104A;
  do
  {
    *(_WORD *)(result + dword_1012C724) = *v1;
    result += 2;
    v1 += 12;
  }
  while ( result < 196 );
  return result;
}
// 1012C0E8: using guessed type int dword_1012C0E8;
// 1012C118: using guessed type int dword_1012C118;
// 1012C148: using guessed type float flt_1012C148[];
// 1012C14C: using guessed type int dword_1012C14C;
// 1012C150: using guessed type int dword_1012C150;
// 1012C1D8: using guessed type int dword_1012C1D8;
// 1012C394: using guessed type int dword_1012C394;
// 1012C3F0: using guessed type int dword_1012C3F0;
// 1012C420: using guessed type int dword_1012C420;
// 1012C4D4: using guessed type int dword_1012C4D4;
// 1012C504: using guessed type int dword_1012C504;
// 1012C534: using guessed type int dword_1012C534;
// 1012C564: using guessed type char byte_1012C564;
// 1012C6F4: using guessed type int dword_1012C6F4;
// 1012C724: using guessed type int dword_1012C724;
// 1012C7D8: using guessed type __int16 word_1012C7D8;
// 1012C834: using guessed type int dword_1012C834;
// 1012C8BC: using guessed type float flt_1012C8BC[];
// 1012C8C0: using guessed type int dword_1012C8C0;
// 1012C8C4: using guessed type int dword_1012C8C4;
// 1012C978: using guessed type int dword_1012C978;

//----- (1000AC70) --------------------------------------------------------
char __cdecl sub_1000AC70(int a1, char a2)
{
  char v2; // bl@1
  int v3; // edi@1
  void *v4; // ecx@1
  char result; // al@8
  char v6; // [sp+Fh] [bp-1h]@1
  char v7; // [sp+14h] [bp+4h]@7

  v2 = 0;
  v6 = 0;
  v3 = j_HWM_pvg_hsdb_get_lrus_online();
  if ( (a1 & (sub_1001B4A0(v4) | v3)) != a1 )
    return 0;
  if ( a2 )
  {
    if ( a2 != 1 )
    {
      sub_1001B780("..\\lib\\acl\\iop\\iop_gdu_upld.c", 170, 1, 0);
      goto LABEL_7;
    }
  }
  else
  {
    v6 = 1;
  }
  v2 = 2;
LABEL_7:
  v7 = sub_10019650(a1);
  if ( sub_10020400(v7) == v2 )
    result = 1;
  else
    result = v6;
  return result;
}
// 1004ECB0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (1000ACF0) --------------------------------------------------------
char __cdecl sub_1000ACF0(signed int a1)
{
  int v1; // esi@1
  char v2; // bl@1
  char result; // al@2
  char v4; // di@3
  void *v5; // ecx@3

  v1 = a1;
  v2 = 0;
  if ( (a1 & dword_1012C980) == a1 )
  {
    result = 1;
  }
  else
  {
    v4 = j_HWM_pvg_hsdb_get_lrus_online();
    if ( ((unsigned __int8)v1 & (unsigned __int8)(sub_1001B4A0(v5) | v4) & 0xF0) == v1 )
    {
      dword_1012C980 |= v1;
      v2 = 1;
      a1 = byte_1012C97C != 0 ? 1 : 8;
      sub_100106F0(6, 4, &a1, 0, 4, 1);
      sub_100108A0(6, 4, v1);
    }
    result = v2;
  }
  return result;
}
// 1004ECB0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1012C97C: using guessed type char byte_1012C97C;
// 1012C980: using guessed type int dword_1012C980;

//----- (1000AD70) --------------------------------------------------------
char __cdecl sub_1000AD70(int a1)
{
  char v1; // bl@1
  char v2; // si@1
  void *v3; // ecx@1
  char v4; // al@3
  int v5; // eax@3
  char v7; // [sp+8h] [bp-78h]@3

  v1 = 0;
  v2 = j_HWM_pvg_hsdb_get_lrus_online();
  if ( ((unsigned __int8)a1 & (unsigned __int8)(sub_1001B4A0(v3) | v2) & 0xF0) == a1 )
  {
    dword_1012C980 &= ~a1;
    v1 = 1;
  }
  v4 = sub_10019650(a1);
  LOBYTE(v5) = sub_10019530(v4);
  byte_1012C97C = sub_10023300(v5, &v7) == 0;
  return v1;
}
// 1004ECB0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1012C97C: using guessed type char byte_1012C97C;
// 1012C980: using guessed type int dword_1012C980;

//----- (1000ADF0) --------------------------------------------------------
char __cdecl sub_1000ADF0(char a1, void *a2)
{
  char result; // al@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_1000F620(8, (int)&byte_10236500, a2);
    }
    else
    {
      sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg.c", 250, 1, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_1000F620(5, (int)&byte_10236500, a2);
  }
  return result;
}
// 10236500: using guessed type char byte_10236500;

//----- (1000AE50) --------------------------------------------------------
char __cdecl sub_1000AE50(char a1, _BYTE *a2)
{
  char result; // al@3
  char v3; // [sp+7h] [bp-1h]@1

  v3 = 0;
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg.c", 322, 1, 0);
      return 0;
    }
    result = sub_1000F620(16, (int)&byte_10236500, &v3);
  }
  else
  {
    result = sub_1000F620(13, (int)&byte_10236500, &v3);
  }
  if ( result == 1 )
    *a2 = v3;
  return result;
}
// 10236500: using guessed type char byte_10236500;

//----- (1000AEC0) --------------------------------------------------------
unsigned int __cdecl sub_1000AEC0(char a1)
{
  memset(byte_1012C988, 0, 0xAA0u);
  sub_10019280(a1, (int)byte_1012C988);
  return sub_1004E2C0((unsigned int *)byte_1012C988, 2720, 0xFFFFFFFF);
}

//----- (1000AF00) --------------------------------------------------------
char __cdecl sub_1000AF00(char a1, int a2, int a3, int a4, char a5, int a6)
{
  int v6; // esi@1
  char v7; // al@2
  char result; // al@2

  v6 = sub_1001DC80(&a5, 1u, (int)&unk_10071D68, 201, 10, 10);
  if ( v6 == 10 )
  {
    result = 0;
  }
  else
  {
    v7 = sub_10023050(a1);
    sub_10020640(a6, &byte_10071D69[201 * v6] + 100 * (unsigned __int8)v7, 100);
    result = 1;
  }
  return result;
}

//----- (1000AF60) --------------------------------------------------------
char sub_1000AF60()
{
  if ( (unsigned int)(sub_1004E4B0() - dword_1012DED0) > 0x3E8 )
    sub_10008470((unsigned __int8)byte_1012DECA);
  return 1;
}
// 1012DECA: using guessed type char byte_1012DECA;
// 1012DED0: using guessed type int dword_1012DED0;

//----- (1000AF90) --------------------------------------------------------
char __cdecl sub_1000AF90(__int16 a1)
{
  int v1; // esi@1
  char result; // al@3
  __int16 v3; // [sp+4h] [bp-5Ch]@1
  char v4[2]; // [sp+6h] [bp-5Ah]@1
  __int16 v5; // [sp+8h] [bp-58h]@1
  __int16 v6; // [sp+Ah] [bp-56h]@1
  __int16 v7; // [sp+Ch] [bp-54h]@1
  char v8; // [sp+Eh] [bp-52h]@1
  __int16 v9; // [sp+10h] [bp-50h]@1
  __int16 v10; // [sp+12h] [bp-4Eh]@1
  char v11; // [sp+14h] [bp-4Ch]@4
  char v12; // [sp+1Dh] [bp-43h]@11
  char v13; // [sp+2Ah] [bp-36h]@5
  char v14; // [sp+2Bh] [bp-35h]@8
  unsigned __int8 v15; // [sp+2Eh] [bp-32h]@14

  v3 = 11;
  v4[0] = 0;
  v5 = 79;
  v6 = 77;
  v7 = 14;
  v8 = 1;
  v9 = 80;
  v10 = 78;
  v1 = sub_1001DC80(&a1, 2u, (int)&v3, 8, 2, -1);
  if ( a1 == 11 || a1 == 14 )
  {
    result = sub_1002D180(v4[8 * v1], &v11);
    if ( result )
    {
      if ( v13 )
        sub_1001BF40(*(&v5 + 4 * v1));
      else
        sub_1001BE10(*(&v5 + 4 * v1));
      if ( v14 )
        sub_1001BF40(*(&v6 + 4 * v1));
      else
        sub_1001BE10(*(&v6 + 4 * v1));
      if ( v12 || *((_WORD *)dword_1022D6E8 + 14205) > 50 && *((_BYTE *)dword_1022D6E8 + 28412) && v15 >= 4u )
      {
        if ( a1 == 11 )
          result = sub_1001BF40(0x51u);
        else
          result = sub_1001BF40(0x52u);
      }
      else if ( a1 == 11 )
      {
        result = sub_1001BE10(81);
      }
      else
      {
        result = sub_1001BE10(82);
      }
    }
  }
  else
  {
    result = sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg.c", 1373, 0, 0);
  }
  return result;
}
// 1000AF90: using guessed type char var_5A[2];

//----- (1000B110) --------------------------------------------------------
char __cdecl sub_1000B110(int a1)
{
  char v1; // al@1
  char v2; // al@1
  int v3; // eax@1
  __int16 v4; // si@1
  int v6; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@1

  v6 = 0;
  v1 = sub_10023150(a1);
  byte_1012DECC[(unsigned __int8)v1] = 0;
  v2 = sub_10019900((void *)(unsigned __int8)v1);
  v7 = sub_100194B0(v2);
  sub_1002DCA0(a1);
  v3 = 6 * (unsigned __int8)sub_1001DC80(&a1, 4u, (int)dword_10071D50, 12, 2, 256);
  v4 = word_10071D56[v3];
  LOWORD(v6) = word_10071D58[v3];
  sub_1000F2D0(3, a1, &v6, 1, (int)&byte_10236500);
  LOWORD(v6) = v4;
  return sub_1000F2D0(3, a1, &v6, 1, (int)&byte_10236500);
}
// 10071D50: using guessed type int dword_10071D50[];
// 10071D56: using guessed type __int16 word_10071D56[];
// 10071D58: using guessed type __int16 word_10071D58[];
// 10236500: using guessed type char byte_10236500;

//----- (1000B1E0) --------------------------------------------------------
char __cdecl sub_1000B1E0(char a1)
{
  void *v1; // ecx@0
  char result; // al@1
  int v3; // eax@2
  int v4; // [sp+4h] [bp-Ch]@1
  int v5; // [sp+8h] [bp-8h]@1

  result = 0;
  v4 = 0;
  v5 = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    v5 = sub_1001B4A0(v1);
    LOWORD(v4) = a1 != 0 ? 8 : 5;
    v3 = sub_100230D0(a1);
    result = sub_1000F2D0(3, v3, &v4, 1, (int)&byte_10236500);
  }
  return result;
}
// 10236500: using guessed type char byte_10236500;

//----- (1000B250) --------------------------------------------------------
char __cdecl sub_1000B250(char a1, const void *a2)
{
  char result; // al@3
  int v3; // eax@4
  int v4; // eax@5

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = sub_1004E4B0();
      result = sub_1000EA10(8, 1, (int)&byte_10236500, a2, v3);
    }
    else
    {
      result = sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg.c", 2938, 1, 0);
    }
  }
  else
  {
    v4 = sub_1004E4B0();
    result = sub_1000EA10(5, 1, (int)&byte_10236500, a2, v4);
  }
  return result;
}
// 10236500: using guessed type char byte_10236500;

//----- (1000B2B0) --------------------------------------------------------
char __cdecl sub_1000B2B0(unsigned __int8 a1, char a2)
{
  char result; // al@1

  result = a2;
  if ( a2 == 4 )
    result = 1;
  if ( a1 < 2u )
    byte_1012DEC8[a1] = result;
  return result;
}

//----- (1000B2D0) --------------------------------------------------------
char __cdecl sub_1000B2D0(char a1, char a2)
{
  char v2; // dl@1
  int v3; // eax@6
  void *v4; // ecx@6
  int v5; // eax@6
  int v6; // eax@7
  int v8; // [sp+4h] [bp-4h]@1

  v8 = 0;
  sub_1000B2B0(a1, a2);
  switch ( v2 )
  {
    case 1:
      v8 = 2;
      goto LABEL_6;
    case 2:
      v8 = 3;
      goto LABEL_6;
    case 8:
      v8 = 4;
      goto LABEL_6;
    case 0x10:
      v8 = 5;
LABEL_6:
      v3 = sub_1004E4B0();
      sub_1000EA10(4, 1, (int)&byte_10236500, &v8, v3);
      v5 = sub_1001B4A0(v4);
      if ( v5 == 1 )
      {
        v6 = sub_100230D0(a1);
        LOBYTE(v5) = sub_1000F010(4, v6, (int)&byte_10236500);
      }
      break;
    default:
      LOBYTE(v5) = sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg.c", 3058, 0, 0);
      break;
  }
  return v5;
}
// 10236500: using guessed type char byte_10236500;

//----- (1000B3B0) --------------------------------------------------------
int __usercall sub_1000B3B0@<eax>(int a1@<esi>)
{
  int result; // eax@1
  unsigned int v2; // edx@1
  int v3; // edi@3

  result = 0;
  v2 = 0;
  do
  {
    switch ( *(_BYTE *)(dword_10072544[v2] + a1) )
    {
      case 1:
      case 2:
      case 5:
      case 7:
      case 8:
        v3 = (1 << byte_10072549[v2 * 4]) | (1 << byte_10072548[v2 * 4]);
        goto LABEL_5;
      case 3:
        v3 = 1 << byte_10072548[v2 * 4];
LABEL_5:
        result |= v3;
        break;
      default:
        break;
    }
    v2 += 2;
  }
  while ( v2 < 12 );
  return result;
}
// 10072544: using guessed type int dword_10072544[];

//----- (1000B430) --------------------------------------------------------
void __usercall sub_1000B430(char a1@<bl>)
{
  bool v1; // zf@1
  char v2; // [sp+7h] [bp-1h]@1

  v1 = byte_1012DECC[(unsigned __int8)a1] == 0;
  v2 = 0;
  if ( v1 && (unsigned int)(sub_1004E4B0() - dword_1012DEDC) >= 0xBB8 )
  {
    if ( sub_1000AE50(a1, &v2) && byte_1012DEC8[(unsigned __int8)a1] == v2 )
    {
      byte_1012DECC[(unsigned __int8)a1] = 1;
    }
    else
    {
      sub_1000B2D0(a1, byte_1012DEC8[(unsigned __int8)a1]);
      dword_1012DEDC = sub_1004E4B0();
    }
  }
}
// 1012DEDC: using guessed type int dword_1012DEDC;

//----- (1000B4A0) --------------------------------------------------------
char __usercall sub_1000B4A0@<al>(int a1@<eax>, void *a2@<ecx>, char a3)
{
  int v3; // edi@1
  void *v4; // esi@1
  int v5; // ebx@1

  a1 = (unsigned __int8)a1;
  v3 = 7;
  v4 = a2;
  v5 = 5;
  if ( (_BYTE)a1 )
  {
    if ( a1 == 1 )
    {
      v3 = 10;
      v5 = 8;
    }
    else
    {
      sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg.c", 3311, 1, 0);
    }
  }
  sub_1000F2D0(v3, 0xFFFFFFF, v4, a3, (int)&byte_10236500);
  qmemcpy(&unk_1012D428, v4, 0xAA0u);
  return sub_1000DC40(v5, (int)&byte_10236500);
}
// 10236500: using guessed type char byte_10236500;

//----- (1000B510) --------------------------------------------------------
int __usercall sub_1000B510@<eax>(char a1@<bl>, const void *a2@<edi>)
{
  int v2; // esi@1
  int v3; // eax@5

  v2 = 7;
  if ( a1 )
  {
    if ( a1 == 1 )
      v2 = 10;
    else
      sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg.c", 3395, 1, 0);
  }
  v3 = sub_1004E4B0();
  sub_1000EA10(v2, 1, (int)&byte_10236500, a2, v3);
  return sub_100082A0(a1, (int)a2);
}
// 10236500: using guessed type char byte_10236500;

//----- (1000B560) --------------------------------------------------------
void __usercall sub_1000B560(int a1@<ecx>, char a2@<bl>)
{
  void *v2; // ecx@2
  unsigned __int8 v3; // al@3
  int v4; // [sp-2h] [bp-4h]@1

  v4 = a1;
  if ( (unsigned __int8)a2 < 2u )
  {
    sub_10019280(a2, (int)byte_1012C988);
    BYTE3(v4) = sub_10019E00(v2);
    if ( byte_1012C99D == byte_10072575[2 * sub_1001DC80((int *)((char *)&v4 + 3), 1u, (int)&unk_10072574, 2, 5, 4)]
      && (v3 = sub_10023110(a2), sub_1002C4A0(v3)) )
    {
      *((_BYTE *)&word_1012DED8 + (unsigned __int8)a2) = 1;
    }
    else
    {
      *((_BYTE *)&word_1012DED8 + (unsigned __int8)a2) = 2;
    }
  }
}
// 1012C99D: using guessed type char byte_1012C99D;
// 1012DED8: using guessed type __int16 word_1012DED8;

//----- (1000B5D0) --------------------------------------------------------
char __usercall sub_1000B5D0@<al>(char a1@<bl>)
{
  unsigned int v1; // eax@1
  unsigned int v2; // esi@2
  void *v3; // ecx@2
  int v4; // eax@4
  int v5; // edx@4
  int v7; // [sp+0h] [bp-10h]@1
  int v8; // [sp+4h] [bp-Ch]@1
  int v9; // [sp+8h] [bp-8h]@1

  LOBYTE(v1) = 0;
  v8 = 0;
  v9 = 0;
  v7 = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    v2 = 6 * (unsigned __int8)a1;
    if ( sub_1000F620((unsigned __int16)word_10071D58[6 * (unsigned __int8)a1], (int)&byte_10236500, &v7) == 1 )
    {
      v1 = sub_1000AEC0(a1);
      *((_BYTE *)&word_1012DED8 + (unsigned __int8)a1) = (v7 == v1) + 2;
    }
    else
    {
      v4 = sub_1001B4A0(v3);
      v5 = dword_10071D50[v2 / 2];
      v9 = v4;
      LOWORD(v8) = word_10071D58[v2];
      LOBYTE(v1) = sub_1000F2D0(3, v5, &v8, 1, (int)&byte_10236500);
    }
  }
  return v1;
}
// 10071D50: using guessed type int dword_10071D50[];
// 10071D58: using guessed type __int16 word_10071D58[];
// 1012DED8: using guessed type __int16 word_1012DED8;
// 10236500: using guessed type char byte_10236500;

//----- (1000B690) --------------------------------------------------------
unsigned __int8 __cdecl sub_1000B690(char a1)
{
  int v1; // ebp@1
  void *v2; // ecx@1
  int v3; // ebx@1
  void *v4; // ecx@1
  unsigned __int8 result; // al@1
  int v6; // esi@2
  int v7; // ecx@2
  unsigned int v8; // edi@2
  void *v9; // ecx@4
  int v10; // ecx@7
  __int16 v11; // dx@14
  int v12; // ST04_4@14
  char v13; // [sp+8h] [bp-14h]@1
  int v14; // [sp+Ch] [bp-10h]@1
  int v15; // [sp+10h] [bp-Ch]@1
  int v16; // [sp+14h] [bp-8h]@1

  v1 = j_HWM_pvg_hsdb_get_lrus_online();
  v3 = sub_1001A050(v2);
  v15 = 0;
  v16 = 0;
  v14 = sub_1001B4A0(v4);
  result = sub_10023050(a1);
  v13 = result;
  if ( result < 2u )
  {
    v6 = result;
    v7 = dword_10071D50[3 * result];
    v8 = 12 * result;
    if ( (v3 & dword_10071D50[3 * result]) == v7 )
    {
      if ( (v1 & v7) == v7 )
      {
        sub_1000B430(result);
        if ( !byte_1012DED4[v6] )
        {
          sub_1000B110(dword_10071D50[v8 / 4]);
          byte_1012DED4[v6] = 1;
        }
        if ( *((_BYTE *)&word_1012DED8 + v6) < 3u && sub_10019060(v9) )
        {
          if ( *((_BYTE *)&word_1012DED8 + v6) )
            sub_1000B5D0(v13);
          else
            sub_1000B560(v10, v13);
          if ( *((_BYTE *)&word_1012DED8 + v6) == 2 )
          {
            sub_1001BF40(word_10071D54[v8 / 2]);
            sub_10009A90(a1, 0);
            *((_BYTE *)&word_1012DED8 + v6) = 3;
          }
        }
        result = sub_1000ADF0(v13, byte_1012C988);
        if ( result != 1 )
        {
          v11 = word_10071D56[v8 / 2];
          v16 = v14;
          v12 = dword_10071D50[v8 / 4];
          LOWORD(v15) = v11;
          result = sub_1000F2D0(3, v12, &v15, 1, (int)&byte_10236500);
        }
      }
      else
      {
        byte_1012DED4[result] = 0;
      }
    }
  }
  return result;
}
// 1004ECB0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 10071D50: using guessed type int dword_10071D50[];
// 10071D54: using guessed type __int16 word_10071D54[];
// 10071D56: using guessed type __int16 word_10071D56[];
// 1012DED8: using guessed type __int16 word_1012DED8;
// 10236500: using guessed type char byte_10236500;

//----- (1000B800) --------------------------------------------------------
char __cdecl sub_1000B800(char a1)
{
  char v1; // ST0C_1@1
  char v2; // bl@1
  char result; // al@4

  v1 = sub_10023050(a1);
  v2 = sub_1000B1E0(v1);
  if ( sub_10008330() != 5 || sub_100082F0() != 1 )
  {
    sub_10008470(3);
    result = v2;
  }
  else if ( v2 == 1 )
  {
    sub_10008470(10);
    result = 1;
  }
  else
  {
    sub_10008360();
    if ( (unsigned int)sub_10008320() <= 0x14 )
    {
      sub_10008470(4);
      byte_1012DECA = 2;
      dword_1012DED0 = sub_1004E4B0();
      result = v2;
    }
    else
    {
      sub_10008470(8);
      result = v2;
    }
  }
  return result;
}
// 1012DECA: using guessed type char byte_1012DECA;
// 1012DED0: using guessed type int dword_1012DED0;

//----- (1000B8A0) --------------------------------------------------------
char __cdecl sub_1000B8A0(char a1, char a2)
{
  char v2; // bl@1
  char result; // al@2
  char v4; // al@3
  char v5; // [sp+14h] [bp+8h]@3

  v2 = sub_10023050(a1);
  if ( a2 )
  {
    v4 = sub_1000ADF0(v2, byte_1012C988);
    v5 = v4;
    if ( v4 )
    {
      sub_1000B510(v2, byte_1012C988);
      v4 = v5;
    }
    if ( v4 == 1 )
    {
      sub_1000F8E0();
      sub_10008470(7);
      result = v5;
    }
    else
    {
      sub_10008470(8);
      result = v5;
    }
  }
  else
  {
    sub_1000B510(v2, &unk_1012D428);
    sub_1000F8E0();
    sub_10008470(7);
    result = 1;
  }
  return result;
}

//----- (1000B940) --------------------------------------------------------
char __cdecl sub_1000B940(char a1)
{
  char v1; // bl@3
  unsigned int v2; // eax@4
  _DWORD *v3; // ecx@4
  char *v4; // edx@4
  int v5; // esi@8
  int v6; // eax@9
  _BYTE *v7; // ecx@9
  _BYTE *v8; // edx@9
  int v9; // eax@11
  _BYTE *v10; // ecx@11
  _BYTE *v11; // edx@11
  _BYTE *v12; // ecx@13
  _BYTE *v13; // edx@13
  signed int v14; // eax@15
  char result; // al@21
  char v16; // [sp+8h] [bp-4h]@1

  v16 = sub_10023050(a1);
  if ( j_HWM_pvg_read_reg(1) == 1 )
    sub_1000B250(v16, &unk_1012D428);
  v1 = sub_1000ADF0(v16, byte_1012C988);
  if ( v1 != 1 )
    goto LABEL_20;
  v2 = 2720;
  v3 = &unk_1012D428;
  v4 = byte_1012C988;
  do
  {
    if ( *(_DWORD *)v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    v4 += 4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v14 = 0;
    goto LABEL_18;
  }
LABEL_8:
  v5 = (unsigned __int8)*v4 - *(_BYTE *)v3;
  if ( (unsigned __int8)*v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v5 = *v13 - *v12;
        if ( *v13 == *v12 )
          goto LABEL_17;
      }
    }
  }
  v14 = 1;
  if ( v5 <= 0 )
    v14 = -1;
LABEL_18:
  if ( !v14 )
  {
    sub_10008470(10);
    return 1;
  }
  v1 = 0;
LABEL_20:
  sub_10008360();
  if ( (unsigned int)sub_10008320() <= 0x14 )
  {
    sub_10008470(1);
    result = v1;
  }
  else
  {
    sub_10008470(8);
    result = v1;
  }
  return result;
}
// 1004ED00: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1000BA60) --------------------------------------------------------
char sub_1000BA60()
{
  void *v0; // ecx@1
  signed int v1; // esi@1
  char v2; // al@2
  int v3; // eax@2

  memset(byte_1012C988, 0, 0xAA0u);
  word_1012DED8 = 0;
  v1 = 0;
  do
  {
    v2 = sub_1001A070(v0);
    sub_1000B2B0(v1, v2);
    byte_1012DECC[v1] = 0;
    sub_10019280(v1, (int)byte_1012C988);
    byte_1012DED4[v1] = 0;
    v3 = j_HWM_pvg_read_reg(1);
    if ( v3 == 1 )
      LOBYTE(v3) = sub_1000B250(v1, byte_1012C988);
    ++v1;
  }
  while ( v1 < 2 );
  return v3;
}
// 1004ED00: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1012DED8: using guessed type __int16 word_1012DED8;

//----- (1000BAD0) --------------------------------------------------------
char __cdecl sub_1000BAD0(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // al@3
  char *v4; // eax@9
  int v5; // eax@15
  char result; // al@15

  memset(byte_1012C988, 0, 0xAA0u);
  if ( a2 > 0xAu
    || a2 + 1 < 1
    || (v3 = *(_BYTE *)(a3 + 1), v3 >= 0x33u) && (v3 < 0x64u || v3 > 0x81u) && (v3 < 0x96u || v3 > 0x9Eu) )
  {
    sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg.c", 1652, 0, 0);
    result = 0;
  }
  else
  {
    sub_10019280(a1, (int)byte_1012C988);
    if ( *(_BYTE *)(a3 + 1) )
    {
      v4 = byte_1012C9A1;
      do
      {
        if ( *v4 == *(_BYTE *)(a3 + 1) && (*v4 != 9 || *(v4 - 1) == *(_BYTE *)a3) )
        {
          *v4 = 0;
          *(v4 - 1) = 0;
        }
        v4 += 4;
      }
      while ( (signed int)v4 < (signed int)&unk_1012C9CD );
    }
    v5 = *(_BYTE *)(a3 + 1);
    byte_1012C9A1[4 * a2] = v5;
    LOBYTE(v5) = a1;
    byte_1012C9A0[4 * a2] = *(_BYTE *)a3;
    sub_1000B4A0(v5, byte_1012C988, 1);
    result = 1;
  }
  return result;
}

//----- (1000BBB0) --------------------------------------------------------
char __cdecl sub_1000BBB0(char a1, unsigned __int8 a2, _BYTE *a3)
{
  char result; // al@1
  int v4; // eax@2

  memset(byte_1012C988, 0, 0xAA0u);
  result = 0;
  if ( a2 < 0xAu )
  {
    sub_10019280(a1, (int)byte_1012C988);
    v4 = *a3;
    byte_1012C988[a2] = v4;
    LOBYTE(v4) = a1;
    sub_1000B4A0(v4, byte_1012C988, 1);
    result = 1;
  }
  return result;
}

//----- (1000BC10) --------------------------------------------------------
char __cdecl sub_1000BC10(char a1, unsigned __int8 a2, _BYTE *a3)
{
  char result; // al@1
  int v4; // eax@2

  memset(byte_1012C988, 0, 0xAA0u);
  result = 0;
  if ( a2 < 0xBu )
  {
    sub_10019280(a1, (int)byte_1012C988);
    v4 = *a3;
    byte_1012C992[a2] = v4;
    LOBYTE(v4) = a1;
    sub_1000B4A0(v4, byte_1012C988, 1);
    result = 1;
  }
  return result;
}

//----- (1000BC70) --------------------------------------------------------
char __cdecl sub_1000BC70(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@1
  char *v4; // eax@4

  memset(byte_1012C988, 0, 0xAA0u);
  result = 0;
  if ( a2 < 2u && *(_BYTE *)a3 < 8u && *(_BYTE *)(a3 + 1) < 8u )
  {
    sub_10019280(a1, (int)byte_1012C988);
    v4 = (char *)&unk_1012CCA8 + 16 * a2;
    *(_DWORD *)v4 = *(_DWORD *)a3;
    *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 4);
    *((_DWORD *)v4 + 2) = *(_DWORD *)(a3 + 8);
    *((_DWORD *)v4 + 3) = *(_DWORD *)(a3 + 12);
    LOBYTE(v4) = a1;
    sub_1000B4A0((int)v4, byte_1012C988, 1);
    result = 1;
  }
  return result;
}

//----- (1000BCF0) --------------------------------------------------------
char __cdecl sub_1000BCF0(char a1, char *a2)
{
  char result; // al@1
  int v3; // eax@3

  memset(byte_1012C988, 0, 0xAA0u);
  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)*a2 < 3u )
  {
    sub_10019280(a1, (int)byte_1012C988);
    byte_1012CE54 = *a2;
    LOBYTE(v3) = a1;
    sub_1000B4A0(v3, byte_1012C988, 1);
    result = 1;
  }
  return result;
}
// 1012CE54: using guessed type char byte_1012CE54;

//----- (1000BD50) --------------------------------------------------------
char __cdecl sub_1000BD50(unsigned __int8 a1, void *a2)
{
  char result; // al@2

  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    sub_1000B4A0(a1, a2, 1);
    result = 1;
  }
  return result;
}

//----- (1000BD80) --------------------------------------------------------
char __cdecl sub_1000BD80(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@1
  char *v4; // eax@3

  memset(byte_1012C988, 0, 0xAA0u);
  result = 0;
  if ( a2 < 0x29u && *(_WORD *)(a3 + 2) < 0x319u )
  {
    sub_10019280(a1, (int)byte_1012C988);
    v4 = (char *)&unk_1012C9CC + 12 * a2;
    *(_DWORD *)v4 = *(_DWORD *)a3;
    *((_DWORD *)v4 + 1) = *(_DWORD *)(a3 + 4);
    *((_DWORD *)v4 + 2) = *(_DWORD *)(a3 + 8);
    LOBYTE(v4) = a1;
    sub_1000B4A0((int)v4, byte_1012C988, 1);
    result = 1;
  }
  return result;
}

//----- (1000BE00) --------------------------------------------------------
char __cdecl sub_1000BE00(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@1
  int v4; // eax@3

  memset(byte_1012C988, 0, 0xAA0u);
  result = 0;
  if ( a2 < 0x2Au && *(_WORD *)(a3 + 2) < 0x145u )
  {
    sub_10019280(a1, (int)byte_1012C988);
    LOBYTE(v4) = a1;
    dword_1012CBB8[a2] = *(_DWORD *)a3;
    sub_1000B4A0(v4, byte_1012C988, 1);
    result = 1;
  }
  return result;
}
// 1012CBB8: using guessed type int dword_1012CBB8[];

//----- (1000BE70) --------------------------------------------------------
char __cdecl sub_1000BE70(char a1, char *a2)
{
  char result; // al@1
  int v3; // eax@2

  memset(byte_1012C988, 0, 0xAA0u);
  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10019280(a1, (int)byte_1012C988);
    v3 = (int)a2;
    byte_1012CE55 = *a2;
    LOBYTE(v3) = a1;
    sub_1000B4A0(v3, byte_1012C988, 1);
    result = 1;
  }
  return result;
}
// 1012CE55: using guessed type char byte_1012CE55;

//----- (1000BEC0) --------------------------------------------------------
char __cdecl sub_1000BEC0(char a1, int a2)
{
  char result; // al@1
  int v3; // eax@2

  memset(byte_1012C988, 0, 0xAA0u);
  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10019280(a1, (int)byte_1012C988);
    dword_1012CE44 = *(_DWORD *)a2;
    dword_1012CE48 = *(_DWORD *)(a2 + 4);
    dword_1012CE4C = *(_DWORD *)(a2 + 8);
    dword_1012CE50 = *(_DWORD *)(a2 + 12);
    if ( sub_1001FC70(4) )
    {
      v3 = sub_1000B3B0(a2 + 8);
      LOWORD(dword_1012CE48) = v3;
    }
    LOBYTE(v3) = a1;
    sub_1000B4A0(v3, byte_1012C988, 1);
    result = 1;
  }
  return result;
}
// 1012CE44: using guessed type int dword_1012CE44;
// 1012CE48: using guessed type int dword_1012CE48;
// 1012CE4C: using guessed type int dword_1012CE4C;
// 1012CE50: using guessed type int dword_1012CE50;

//----- (1000BF60) --------------------------------------------------------
char __cdecl sub_1000BF60(char a1, char *a2)
{
  char result; // al@1
  int v3; // eax@3

  memset(byte_1012C988, 0, 0xAA0u);
  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)*a2 < 4u )
  {
    sub_10019280(a1, (int)byte_1012C988);
    byte_1012C99D = *a2;
    LOBYTE(v3) = a1;
    sub_1000B4A0(v3, byte_1012C988, 1);
    result = 1;
  }
  return result;
}
// 1012C99D: using guessed type char byte_1012C99D;

//----- (1000BFC0) --------------------------------------------------------
char __cdecl sub_1000BFC0(char a1, int a2)
{
  char result; // al@1
  int v3; // eax@2

  memset(byte_1012C988, 0, 0xAA0u);
  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10019280(a1, (int)byte_1012C988);
    qmemcpy(byte_1012D2E8, (const void *)a2, 0x40u);
    LOBYTE(v3) = a1;
    byte_1012D2E8[64] = *(_BYTE *)(a2 + 64);
    sub_1000B4A0(v3, byte_1012C988, 1);
    result = 1;
  }
  return result;
}

//----- (1000C020) --------------------------------------------------------
char __cdecl sub_1000C020(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@1
  unsigned __int8 v4; // al@5
  int v5; // ebp@5
  int v6; // ecx@5
  char v7; // dl@6
  char v8; // al@14
  int v9; // eax@26
  char *v10; // esi@27
  char v11; // bl@28
  char v12; // bl@32
  int v13; // [sp+4h] [bp-8h]@5

  memset(byte_1012C988, 0, 0xAA0u);
  result = 0;
  if ( (unsigned __int8)a1 >= 2u || a2 >= 8u || *(_BYTE *)a3 >= 2u || *(_BYTE *)(a3 + 1) >= 0x31u )
    return result;
  sub_10019280(a1, (int)byte_1012C988);
  v4 = *(_BYTE *)(a3 + 1);
  v5 = a2;
  v6 = dword_1012CC60[a2];
  v13 = dword_1012CC60[a2];
  if ( v4 )
    goto LABEL_14;
  v7 = *(_BYTE *)a3;
  if ( !*(_BYTE *)a3 && (unsigned __int8)v13 >= 0x31u )
    goto LABEL_14;
  if ( v7 == 1 && BYTE1(v6) >= 0x31u )
    goto LABEL_14;
  if ( !v7 )
  {
    v8 = sub_1002E4F0(v6);
LABEL_15:
    if ( !v8 || v8 == 2 )
      LOBYTE(v13) = *(_BYTE *)(a3 + 1);
    if ( v8 == 1 || v8 == 2 )
      BYTE1(v13) = *(_BYTE *)(a3 + 1);
    if ( v8 == 3 )
    {
      if ( *(_BYTE *)a3 )
        BYTE1(v13) = *(_BYTE *)(a3 + 1);
      else
        LOBYTE(v13) = *(_BYTE *)(a3 + 1);
    }
    goto LABEL_26;
  }
  if ( v7 == 1 )
  {
    v4 = BYTE1(v13);
LABEL_14:
    v8 = sub_1002E4F0(v4);
    goto LABEL_15;
  }
  sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg.c", 2495, 1, 0);
LABEL_26:
  BYTE2(v13) = sub_1002E4C0(*(_BYTE *)(a3 + 1));
  BYTE3(v13) = sub_1002E520(*(_BYTE *)(a3 + 1));
  if ( *(_BYTE *)(a3 + 1) )
  {
    v10 = (char *)dword_1012CC60 + 1;
    do
    {
      v11 = sub_10023220(v13);
      if ( *(v10 - 1) == (_BYTE)v13 || (unsigned __int8)v11 < 0x43u && v11 == sub_10023220(*(v10 - 1)) )
        *(v10 - 1) = 0;
      v12 = sub_10023220(SBYTE1(v13));
      v9 = (unsigned __int8)*v10;
      if ( (_BYTE)v9 == BYTE1(v13) || (unsigned __int8)v12 < 0x43u && v12 == sub_10023220(*v10) )
        *v10 = 0;
      v10 += 4;
    }
    while ( (signed int)v10 < (signed int)dword_1012CC80 + 1 );
    v5 = a2;
  }
  LOBYTE(v9) = a1;
  dword_1012CC60[v5] = v13;
  sub_1000B4A0(v9, byte_1012C988, 1);
  return 1;
}
// 1012CC60: using guessed type int dword_1012CC60[];
// 1012CC80: using guessed type int dword_1012CC80[];

//----- (1000C1E0) --------------------------------------------------------
char __cdecl sub_1000C1E0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@1
  unsigned __int8 v4; // al@5
  int v5; // ecx@5
  int v6; // ebp@5
  char v7; // dl@6
  char v8; // al@14
  char *v9; // eax@26
  int v10; // [sp+4h] [bp-Ch]@5

  memset(byte_1012C988, 0, 0xAA0u);
  result = 0;
  if ( (unsigned __int8)a1 >= 2u || a2 >= 5u || *(_BYTE *)a3 >= 2u || *(_BYTE *)(a3 + 1) >= 0x1Du )
    return result;
  sub_10019280(a1, (int)byte_1012C988);
  v4 = *(_BYTE *)(a3 + 1);
  v5 = dword_1012CC80[2 * a2];
  v6 = dword_1012CC84[2 * a2];
  v10 = dword_1012CC80[2 * a2];
  if ( v4 )
    goto LABEL_14;
  v7 = *(_BYTE *)a3;
  if ( !*(_BYTE *)a3 && (unsigned __int8)v5 >= 0x1Du )
    goto LABEL_14;
  if ( v7 == 1 && BYTE1(v5) >= 0x1Du )
    goto LABEL_14;
  if ( !v7 )
  {
    v8 = sub_1002E650(v5);
LABEL_15:
    if ( !v8 || v8 == 2 )
      LOBYTE(v10) = *(_BYTE *)(a3 + 1);
    if ( v8 == 1 || v8 == 2 )
      BYTE1(v10) = *(_BYTE *)(a3 + 1);
    if ( v8 == 3 )
    {
      if ( *(_BYTE *)a3 )
        BYTE1(v10) = *(_BYTE *)(a3 + 1);
      else
        LOBYTE(v10) = *(_BYTE *)(a3 + 1);
    }
    goto LABEL_26;
  }
  if ( v7 == 1 )
  {
    v4 = BYTE1(v10);
LABEL_14:
    v8 = sub_1002E650(v4);
    goto LABEL_15;
  }
  sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg.c", 2696, 1, 0);
LABEL_26:
  BYTE2(v10) = sub_1002E620(*(_BYTE *)(a3 + 1));
  BYTE3(v10) = sub_1002E680(*(_BYTE *)(a3 + 1));
  if ( *(_BYTE *)(a3 + 1) )
  {
    v9 = (char *)dword_1012CC80 + 1;
    do
    {
      if ( *(v9 - 1) == (_BYTE)v10 )
        *(v9 - 1) = 0;
      if ( *v9 == BYTE1(v10) )
        *v9 = 0;
      v9 += 8;
    }
    while ( (signed int)v9 < (signed int)&unk_1012CCA9 );
  }
  LOBYTE(v9) = a1;
  dword_1012CC80[2 * a2] = v10;
  dword_1012CC84[2 * a2] = v6;
  sub_1000B4A0((int)v9, byte_1012C988, 1);
  return 1;
}
// 1012CC80: using guessed type int dword_1012CC80[];
// 1012CC84: using guessed type int dword_1012CC84[];

//----- (1000C380) --------------------------------------------------------
char __cdecl sub_1000C380(char a1, char *a2)
{
  char result; // al@1
  int v3; // eax@3

  memset(byte_1012C988, 0, 0xAA0u);
  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)*a2 <= 3u )
  {
    sub_10019280(a1, (int)byte_1012C988);
    byte_1012C99E = *a2;
    LOBYTE(v3) = a1;
    sub_1000B4A0(v3, byte_1012C988, 1);
    result = 1;
  }
  return result;
}
// 1012C99E: using guessed type char byte_1012C99E;

//----- (1000C3F0) --------------------------------------------------------
char __cdecl sub_1000C3F0(char a1, int a2, char a3, unsigned __int8 *a4, char *a5, int a6)
{
  char v6; // bl@1
  char v7; // al@2
  char result; // al@20
  char v9; // [sp+4h] [bp-4h]@1

  memset(byte_1012C988, 0, 0xAA0u);
  v6 = 0;
  v9 = sub_10023050(a1);
  switch ( a3 )
  {
    case 2:
      v7 = sub_1000BAD0(v9, *a4, (int)a5);
      goto LABEL_19;
    case 5:
      v7 = sub_1000BBB0(v9, *a4, a5);
      goto LABEL_19;
    case 6:
      v7 = sub_1000BC10(v9, *a4, a5);
      goto LABEL_19;
    case 9:
      v7 = sub_1000BC70(v9, *a4, (int)a5);
      goto LABEL_19;
    case 3:
      v7 = sub_1000BD80(v9, *a4, (int)a5);
      goto LABEL_19;
    case 4:
      v7 = sub_1000BE00(v9, *a4, (int)a5);
      goto LABEL_19;
    case 0x21:
      v7 = sub_1000BE70(v9, a5);
      goto LABEL_19;
    case 8:
      v7 = sub_1000BEC0(v9, (int)a5);
      goto LABEL_19;
    case 7:
      v7 = sub_1000C380(v9, a5);
      goto LABEL_19;
    case 0xC:
      v7 = sub_1000C020(v9, *a4, (int)a5);
      goto LABEL_19;
    case 0xD:
      v7 = sub_1000C1E0(v9, *a4, (int)a5);
      goto LABEL_19;
    case 0x14:
      v7 = sub_1000BCF0(v9, a5);
      goto LABEL_19;
    case 0x17:
      v7 = sub_1000BF60(v9, a5);
      goto LABEL_19;
    case 0x1D:
      v7 = sub_1000BFC0(v9, (int)a5);
      goto LABEL_19;
    case 0xB:
      if ( a6 )
      {
        v7 = sub_1000BD50(v9, a5);
      }
      else
      {
        sub_10019280(v9, (int)byte_1012C988);
        v7 = sub_1000BD50(v9, byte_1012C988);
      }
LABEL_19:
      v6 = v7;
      if ( v7 != 1 )
        goto LABEL_21;
      sub_10008470(4);
      byte_1012DECA = 3;
      dword_1012DED0 = sub_1004E4B0();
      result = v6;
      break;
    default:
LABEL_21:
      sub_10008470(8);
      result = v6;
      break;
  }
  return result;
}
// 1012DECA: using guessed type char byte_1012DECA;
// 1012DED0: using guessed type int dword_1012DED0;

//----- (1000C670) --------------------------------------------------------
char __usercall sub_1000C670@<al>(int a1@<ecx>, _BYTE *a2@<edi>, _BYTE *a3@<esi>)
{
  char result; // al@1
  char v4; // cl@3
  char v5; // al@5
  char v6; // dl@8
  char v7; // cl@10
  int v8; // [sp-2h] [bp-4h]@1

  v8 = a1;
  result = 0;
  if ( a1 & 0x100 )
  {
    result = sub_10010C50(6, 13, (char *)&v8 + 3);
    if ( result == 1 )
    {
      v4 = BYTE3(v8);
      *a2 = 6;
      *a3 = v4;
      return result;
    }
    if ( sub_10010C50(0, 14, (char *)&v8 + 3) == 1 )
    {
      v5 = BYTE3(v8);
      *a2 = 0;
      *a3 = v5;
      return 1;
    }
  }
  else
  {
    if ( !(a1 & 0x200) )
      return result;
    result = sub_10010C50(6, 16, (char *)&v8 + 3);
    if ( result == 1 )
    {
      v6 = BYTE3(v8);
      *a2 = 6;
      *a3 = v6;
      return result;
    }
    result = sub_10010C50(0, 17, (char *)&v8 + 3);
    if ( result == 1 )
    {
      v7 = BYTE3(v8);
      *a2 = 0;
      *a3 = v7;
      return result;
    }
  }
  result = 0;
  *a3 = 0;
  return result;
}

//----- (1000C710) --------------------------------------------------------
char __usercall sub_1000C710@<al>(unsigned __int8 a1@<al>, int a2)
{
  int v2; // eax@1
  int v3; // eax@2
  int v5; // [sp+0h] [bp-4h]@1

  v2 = a1 - 1;
  v5 = 0;
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 != 14 )
        return sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_upld.c", 542, 1, 0);
      v5 = 5;
    }
    else
    {
      v5 = 3;
    }
  }
  else
  {
    v5 = 2;
  }
  sub_100106F0(6, 4, &v5, 0, 4, 1);
  return sub_100108A0(6, 4, a2);
}

//----- (1000C790) --------------------------------------------------------
char __cdecl sub_1000C790(int a1, int a2, int a3, __int16 a4)
{
  int v4; // eax@1
  void *v5; // ecx@1
  int v6; // ebp@1
  char result; // al@4
  unsigned __int8 v8; // bl@5
  char v9; // [sp+Bh] [bp-5h]@1
  int v10; // [sp+Ch] [bp-4h]@3

  v9 = 0;
  v4 = j_HWM_pvg_hsdb_get_lrus_online();
  v6 = a1;
  if ( (a1 & v4) == a1 )
  {
    if ( a4 == 68 )
    {
      v10 = 1;
      sub_100106F0(6, 4, &v10, 0, 4, 1);
      sub_100108A0(6, 4, v6);
      return 1;
    }
    v8 = sub_1001A070(v5);
    if ( sub_1000C670(v6, &a1, &v9) == 1 )
    {
      if ( v9 == v8 )
        return 1;
      sub_1000C710(v8, v6);
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1004ECB0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (1000C830) --------------------------------------------------------
char __cdecl sub_1000C830(int a1, char a2, int a3, __int16 a4)
{
  void *v4; // ecx@1
  unsigned __int8 v5; // bl@2
  char result; // al@9
  char v7; // [sp+Ah] [bp-2h]@1
  char v8; // [sp+Bh] [bp-1h]@1

  v8 = 0;
  v7 = 6;
  if ( (a1 & j_HWM_pvg_hsdb_get_lrus_online()) == a1 )
  {
    v5 = sub_1001A070(v4);
    if ( !a2 )
    {
      switch ( a4 )
      {
        case 0:
        case 1:
        case 0xF:
        case 0x39:
        case 0x3A:
          v5 = 16;
          break;
        default:
          break;
      }
    }
    if ( sub_1000C670(a1, &v7, &v8) == 1 )
    {
      if ( !v7 )
        sub_100133D0(0);
      if ( v8 == v5 )
        return 1;
      sub_1000C710(v5, a1);
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1004ECB0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (1000C910) --------------------------------------------------------
char __cdecl sub_1000C910(int a1, int a2, int a3, int a4, char a5, int a6)
{
  char v6; // bl@1
  char result; // al@2

  v6 = 0;
  switch ( a5 )
  {
    case 5:
      sub_10020640(a6, "LOADING", 100);
      result = 1;
      break;
    case 1:
    case 2:
    case 3:
    case 4:
    case 6:
    case 8:
    case 9:
    case 0xA:
      sub_10020640(a6, byte_1012DEE8, 100);
      result = 1;
      break;
    case 0:
    case 7:
      v6 = 1;
      goto LABEL_5;
    default:
LABEL_5:
      sub_10020640(a6, &byte_100647C9, 100);
      result = v6;
      break;
  }
  return result;
}

//----- (1000C990) --------------------------------------------------------
char sub_1000C990()
{
  __int16 *v0; // esi@1
  char *v1; // edi@1
  signed int v2; // ebx@1
  char result; // al@2

  byte_1012DEE2 = 0;
  dword_1012DF4C = 0;
  word_1012DEE0 = 0;
  memset(&unk_1012DF50, 0, 0x90u);
  dword_1012DFE0[0] = 0;
  dword_1012DFE4 = 0;
  memset(byte_1012DEE8, 0, 0x64u);
  v0 = &word_1012DEE0;
  v1 = (char *)&unk_10072BE2;
  v2 = 2;
  do
  {
    result = sub_1001FC40(*v1);
    if ( !result )
      *(_BYTE *)v0 = 1;
    v1 += 12;
    v0 = (__int16 *)((char *)v0 + 1);
    --v2;
  }
  while ( v2 );
  return result;
}
// 1012DEE0: using guessed type __int16 word_1012DEE0;
// 1012DEE2: using guessed type char byte_1012DEE2;
// 1012DF4C: using guessed type int dword_1012DF4C;
// 1012DFE0: using guessed type int dword_1012DFE0[];
// 1012DFE4: using guessed type int dword_1012DFE4;

//----- (1000CA10) --------------------------------------------------------
char sub_1000CA10()
{
  if ( j_HWM_pvg_read_reg(1) || (unsigned int)(sub_1004E4B0() - dword_1012DF4C) > 0x1F4 )
    sub_10008470((unsigned __int8)byte_1012DEE2);
  return 1;
}
// 1004ED00: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1012DEE2: using guessed type char byte_1012DEE2;
// 1012DF4C: using guessed type int dword_1012DF4C;

//----- (1000CA50) --------------------------------------------------------
char __cdecl sub_1000CA50(char a1, _DWORD *a2)
{
  char result; // al@2
  int v3; // [sp+4h] [bp-90h]@1

  memset(&v3, 0, 0x90u);
  if ( sub_1000D6C0(a1, 28, &v3) )
  {
    result = 1;
    *a2 = v3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000CAB0) --------------------------------------------------------
char __cdecl sub_1000CAB0(unsigned __int8 a1, unsigned int *a2)
{
  char result; // al@2
  char v3; // [sp+4h] [bp-90h]@1

  memset(&v3, 0, 0x90u);
  if ( sub_1002E9C0(a1, (unsigned int)&v3) )
  {
    *a2 = sub_1004E2C0((unsigned int *)&v3, 144, 0xFFFFFFFF);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000CB20) --------------------------------------------------------
char __usercall sub_1000CB20@<al>(unsigned __int8 a1@<bl>, char a2)
{
  int v2; // eax@3
  char result; // al@5
  int v4; // [sp+0h] [bp-98h]@2
  int v5; // [sp+4h] [bp-94h]@3
  char v6; // [sp+8h] [bp-90h]@2

  if ( a1 >= 2u )
  {
    result = sub_1001B780("..\\lib\\acl\\iop\\grs\\iop_grs_cnfg.c", 1165, 0, 0);
  }
  else
  {
    v4 = 0;
    memset(&v6, 0, 0x90u);
    if ( a2 )
    {
      LOBYTE(v5) = 28;
      v2 = 4;
      LOWORD(v4) = 12805;
    }
    else
    {
      LOBYTE(v5) = 26;
      v2 = 144;
      LOWORD(v4) = 2572;
    }
    sub_1000D760(a1, v5, &v6, v2, 0);
    result = sub_1002EA20(a1, &v4, &v6);
  }
  return result;
}

//----- (1000CBD0) --------------------------------------------------------
char __usercall sub_1000CBD0@<al>(unsigned __int8 a1@<bl>, void *a2)
{
  char result; // al@2
  int v3; // [sp+0h] [bp-94h]@2
  char v4; // [sp+4h] [bp-90h]@2

  if ( a1 >= 2u )
  {
    result = sub_1001B780("..\\lib\\acl\\iop\\grs\\iop_grs_cnfg.c", 1234, 0, 0);
  }
  else
  {
    memset(&v4, 0, 0x90u);
    sub_1000D760(a1, 26, &v4, 144, 0);
    v3 = 9439500;
    memcpy(&v4, a2, 0x90u);
    result = sub_1002EA20(a1, &v3, &v4);
  }
  return result;
}

//----- (1000CC70) --------------------------------------------------------
unsigned __int8 __cdecl sub_1000CC70(char a1)
{
  unsigned __int8 result; // al@1
  unsigned __int8 v2; // bl@1
  void *v3; // ecx@2
  int v4; // esi@5
  int v5; // edi@5
  int v6; // eax@6
  int v7; // ebx@12
  bool v8; // zf@14
  int v9; // esi@21
  unsigned __int16 v10; // [sp-Ch] [bp-28h]@7
  char v11; // [sp+Ah] [bp-12h]@2
  char v12; // [sp+Bh] [bp-11h]@17
  unsigned int v13; // [sp+Ch] [bp-10h]@1
  int v14; // [sp+10h] [bp-Ch]@5
  int v15; // [sp+14h] [bp-8h]@12
  int v16; // [sp+18h] [bp-4h]@13

  result = sub_1002E980(a1);
  v2 = result;
  LOBYTE(v13) = result;
  if ( result >= 2u )
    return result;
  if ( !(unsigned __int8)sub_10009800(a1, &v11) || !v11 )
    return sub_1001BE10(word_10072BDC[6 * v2]);
  if ( sub_10019060(v3) )
  {
    v4 = v2;
    v5 = 6 * v2;
    if ( !sub_1000F620((unsigned __int16)word_10072BDE[6 * v2], (int)&byte_10236500, &v14) )
      goto LABEL_11;
    v6 = v14;
    if ( v14 & 0x400000 )
    {
      v10 = word_10072BD8[v5];
    }
    else
    {
      if ( !(v6 & 0x200000) )
        goto LABEL_11;
      v10 = word_10072BDA[v5];
    }
    *((_BYTE *)&word_1012DEE0 + v2) = 1;
    sub_1001BF40(v10);
    sub_10009A90(a1, 0);
LABEL_11:
    if ( !*((_BYTE *)&word_1012DEE0 + v2) )
    {
      v7 = sub_1004E4B0();
      if ( sub_1000CA50(v13, &v15) && sub_1000CAB0(v13, (unsigned int *)&v16) )
      {
        v8 = v15 == v16;
        *((_BYTE *)&word_1012DEE0 + v4) = 1;
        if ( !v8 )
        {
          sub_1001BF40(word_10072BDA[v5]);
          sub_10009A90(a1, 0);
        }
      }
      else if ( (unsigned int)(v7 - dword_1012DFE0[v4]) > 0x3E8 && (!sub_10009B50(&v12) || !v12) )
      {
        dword_1012DFE0[v4] = v7;
        sub_1000CB20(v13, 1);
      }
      v2 = v13;
    }
  }
  v9 = 6 * v2;
  result = sub_1000F620((unsigned __int16)word_10072BE0[6 * v2], (int)&byte_10236500, &v14);
  if ( result )
  {
    if ( v14 & 0x7FFC00 )
      result = sub_1001BF40(word_10072BDC[v9]);
    else
      result = sub_1001BE10(word_10072BDC[v9]);
  }
  return result;
}
// 10009800: using guessed type _DWORD __cdecl sub_10009800(char, _DWORD);
// 10072BD8: using guessed type __int16 word_10072BD8[];
// 10072BDA: using guessed type __int16 word_10072BDA[];
// 10072BDC: using guessed type __int16 word_10072BDC[];
// 10072BDE: using guessed type __int16 word_10072BDE[];
// 10072BE0: using guessed type __int16 word_10072BE0[];
// 1012DEE0: using guessed type __int16 word_1012DEE0;
// 1012DFE0: using guessed type int dword_1012DFE0[];
// 10236500: using guessed type char byte_10236500;

//----- (1000CE60) --------------------------------------------------------
char __cdecl sub_1000CE60(char a1, char a2)
{
  char v2; // bl@1
  char result; // al@1
  int v4; // ebp@3
  char v5; // al@7
  int v6; // [sp+4h] [bp-9Ch]@0
  char v7; // [sp+8h] [bp-98h]@1
  char v8; // [sp+10h] [bp-90h]@1

  memset(&v8, 0, 0x90u);
  v2 = sub_1002E980(a1);
  result = 0;
  v7 = 0;
  if ( (unsigned __int8)v2 < 2u )
  {
    if ( a2 == 17 )
    {
      LOBYTE(v6) = 28;
      v4 = 4;
    }
    else
    {
      LOBYTE(v6) = 26;
      v4 = 144;
    }
    if ( j_HWM_pvg_read_reg(1) )
    {
      if ( a2 == 17 )
        v5 = sub_1000CAB0(v2, (unsigned int *)&v8);
      else
        v5 = sub_1002E9C0(v2, (unsigned int)&v8);
      v7 = v5;
      sub_1000D760(v2, v6, &v8, v4, v5);
    }
    if ( sub_10008330() == 2 )
    {
      sub_1000CB20(v2, a2 == 17);
      LOBYTE(v6) = 7;
      sub_10008470(v6);
      return v7;
    }
    v7 = sub_1000D6C0(v2, v6, &v8);
    LOBYTE(v6) = 3;
    if ( !v7 )
    {
      sub_10008360();
      if ( (unsigned int)sub_10008320() > 0x14 )
      {
        sub_10020770(byte_1012DEE8, 0x64u, "FAILED: UNABLE TO REQUEST GRS %d CNFG", (unsigned __int8)v2 + 1);
        LOBYTE(v6) = 8;
        sub_10008470(v6);
        return v7;
      }
      sub_1000CB20(v2, a2 == 17);
      v7 = 1;
      LOBYTE(v6) = 4;
      byte_1012DEE2 = 2;
      dword_1012DF4C = sub_1004E4B0();
    }
    sub_10008470(v6);
    return v7;
  }
  return result;
}
// 1004ED00: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1012DEE2: using guessed type char byte_1012DEE2;
// 1012DF4C: using guessed type int dword_1012DF4C;

//----- (1000CFD0) --------------------------------------------------------
bool __cdecl sub_1000CFD0(int a1, int a2, char a3, int a4, void *a5, size_t a6)
{
  unsigned __int8 v6; // bl@1
  bool v8; // [sp+7h] [bp-9h]@1
  int v9; // [sp+Ch] [bp-4h]@0

  v6 = sub_1002E980(a1);
  v8 = 0;
  if ( v6 < 2u && a3 == 11 )
  {
    if ( a6 )
    {
      if ( (unsigned int)a5 < 0xFFFFFFC2 && a5 && a6 == 144 )
      {
        v8 = 1;
        memcpy(&unk_1012DF50, a5, 0x90u);
        goto LABEL_5;
      }
    }
    else
    {
      v8 = sub_1002E9C0(v6, (unsigned int)&unk_1012DF50);
      if ( v8 )
      {
LABEL_5:
        sub_1000CBD0(v6, &unk_1012DF50);
        LOBYTE(v9) = 4;
        byte_1012DEE2 = 2;
        dword_1012DF4C = sub_1004E4B0();
        sub_10020770(byte_1012DEE8, 0x64u, "CONFIGURING GRS %d", v6 + 1);
        sub_10008470(v9);
        return v8;
      }
    }
  }
  LOBYTE(v9) = 8;
  sub_10020770(byte_1012DEE8, 0x64u, "FAILED: UNABLE TO SEND CNFG TO GRS %d", v6 + 1);
  sub_10008470(v9);
  return v8;
}
// 1012DEE2: using guessed type char byte_1012DEE2;
// 1012DF4C: using guessed type int dword_1012DF4C;

//----- (1000D0E0) --------------------------------------------------------
char __cdecl sub_1000D0E0(char a1, char a2, char a3)
{
  unsigned __int8 v3; // bl@1
  char result; // al@3
  bool v5; // [sp+Bh] [bp-5h]@1

  v3 = sub_1002E980(a1);
  v5 = 0;
  if ( v3 >= 2u )
    goto LABEL_9;
  if ( a3 == 17 )
  {
    sub_10008470(7);
    return 1;
  }
  v5 = sub_1002EAE0(v3, (unsigned int)&unk_1012DF50);
  if ( v5 )
  {
    sub_10008470(2);
    sub_100083C0(7, a1, a2, 17, 0, 0, 0);
    sub_1000CB20(v3, 1);
    result = v5;
  }
  else
  {
LABEL_9:
    sub_10008470(8);
    sub_10020770(byte_1012DEE8, 0x64u, "UNABLE TO STORE GRS %d CNFG", v3 + 1);
    result = v5;
  }
  return result;
}

//----- (1000D1A0) --------------------------------------------------------
bool __cdecl sub_1000D1A0(char a1, char a2)
{
  bool v2; // bl@1
  bool result; // al@6
  unsigned int v4; // eax@8
  _DWORD *v5; // ecx@8
  int *v6; // edx@8
  int v7; // esi@12
  int v8; // eax@13
  _BYTE *v9; // ecx@13
  _BYTE *v10; // edx@13
  int v11; // eax@15
  _BYTE *v12; // ecx@15
  _BYTE *v13; // edx@15
  _BYTE *v14; // ecx@17
  _BYTE *v15; // edx@17
  signed int v16; // eax@19
  char v17; // [sp+Ch] [bp-98h]@1
  int v18; // [sp+10h] [bp-94h]@4
  int v19; // [sp+14h] [bp-90h]@1

  memset(&v19, 0, 0x90u);
  v2 = 0;
  v17 = sub_1002E980(a1);
  if ( (unsigned __int8)v17 >= 2u )
    goto LABEL_25;
  if ( a2 != 17 )
  {
    if ( sub_1000D6C0(v17, 26, &v19) )
    {
      v4 = 144;
      v5 = &unk_1012DF50;
      v6 = &v19;
      do
      {
        if ( *v6 != *v5 )
          goto LABEL_12;
        v4 -= 4;
        ++v5;
        ++v6;
      }
      while ( v4 >= 4 );
      if ( v4 )
      {
LABEL_12:
        v7 = *(_BYTE *)v6 - *(_BYTE *)v5;
        if ( *(_BYTE *)v6 != *(_BYTE *)v5
          || (v8 = v4 - 1, v9 = (char *)v5 + 1, v10 = (char *)v6 + 1, v8)
          && ((v7 = *v10 - *v9, *v10 != *v9)
           || (v11 = v8 - 1, v12 = v9 + 1, v13 = v10 + 1, v11)
           && ((v7 = *v13 - *v12, *v13 != *v12)
            || (v14 = v12 + 1, v15 = v13 + 1, v11 != 1) && (v7 = *v15 - *v14, *v15 != *v14))) )
        {
          v16 = 1;
          if ( v7 <= 0 )
            v16 = -1;
LABEL_22:
          if ( !v16 )
          {
            v2 = 1;
LABEL_6:
            sub_10008470(10);
            sub_10020770(byte_1012DEE8, 0x64u, "STORING GRS %d CNFG", (unsigned __int8)v17 + 1);
            return v2;
          }
          goto LABEL_24;
        }
      }
      v16 = 0;
      goto LABEL_22;
    }
LABEL_24:
    v2 = 0;
    goto LABEL_25;
  }
  if ( sub_1000CA50(v17, &v19) )
  {
    if ( sub_1000CAB0(v17, (unsigned int *)&v18) )
    {
      v2 = v19 == v18;
      if ( v19 == v18 )
        goto LABEL_6;
    }
  }
LABEL_25:
  sub_10008360();
  if ( (unsigned int)sub_10008320() <= 0x14 )
  {
    sub_10020770(byte_1012DEE8, 0x64u, "RESENDING GRS %d CNFG", (unsigned __int8)v17 + 1);
    if ( a2 == 17 )
      sub_100083C0(7, a1, 0, 11, 0, &unk_1012DF50, 0x90u);
    sub_10008470(1);
    result = v2;
  }
  else
  {
    if ( a2 == 17 )
      sub_10020770(byte_1012DEE8, 0x64u, "FAILED: GRS %d CNFG CRC MISMATCH", (unsigned __int8)v17 + 1);
    else
      sub_10020770(byte_1012DEE8, 0x64u, "FAILED: UNABLE TO VERIFY GRS %d CNFG", (unsigned __int8)v17 + 1);
    sub_10008470(8);
    result = v2;
  }
  return result;
}

//----- (1000D3C0) --------------------------------------------------------
char __cdecl sub_1000D3C0(int a1)
{
  char result; // al@1
  char v2; // bl@4
  int v3; // esi@10
  char v4; // [sp+5h] [bp-Fh]@2
  char v5; // [sp+6h] [bp-Eh]@6
  char v6; // [sp+7h] [bp-Dh]@8
  char v7; // [sp+8h] [bp-Ch]@4
  char v8; // [sp+9h] [bp-Bh]@4
  char v9; // [sp+Ah] [bp-Ah]@4
  char v10; // [sp+Bh] [bp-9h]@10
  unsigned int v11; // [sp+Ch] [bp-8h]@1
  unsigned int v12; // [sp+10h] [bp-4h]@4

  result = sub_10010C50(6, a1, &v11);
  if ( !result )
    return result;
  v4 = 0;
  if ( (_WORD)a1 == 56 )
    v4 = 1;
  v7 = (v12 >> 12) & 1;
  v8 = (v12 >> 15) & 1;
  v2 = (v12 >> 10) & 1;
  v9 = (v12 >> 19) & 1;
  if ( !(v11 & 0x400) && !(v12 & 0x240000) )
  {
    v5 = 1;
LABEL_9:
    v6 = 0;
    goto LABEL_10;
  }
  v5 = 0;
  if ( v11 & 0x400 )
    goto LABEL_9;
  v6 = 1;
  if ( v12 & 0x200000 )
    goto LABEL_9;
LABEL_10:
  v3 = (unsigned __int8)v4;
  v10 = (v12 >> 22) & 1;
  if ( (v11 >> 17) & 1 )
    sub_1001BF40(word_10073420[v3]);
  else
    sub_1001BE10(word_10073420[v3]);
  if ( v2 )
    sub_1001BF40(word_10073424[v3]);
  else
    sub_1001BE10(word_10073424[v3]);
  if ( v7 )
    sub_1001BF40(word_10073428[v3]);
  else
    sub_1001BE10(word_10073428[v3]);
  if ( v8 )
    sub_1001BF40(word_1007342C[v3]);
  else
    sub_1001BE10(word_1007342C[v3]);
  if ( v9 )
    sub_1001BF40(word_10073430[v3]);
  else
    sub_1001BE10(word_10073430[v3]);
  if ( v5 )
    sub_1001BF40(word_10073434[v3]);
  else
    sub_1001BE10(word_10073434[v3]);
  if ( v6 )
    sub_1001BF40(word_10073438[v3]);
  else
    sub_1001BE10(word_10073438[v3]);
  if ( v10 )
    result = sub_1001BF40(word_1007343C[v3]);
  else
    result = sub_1001BE10(word_1007343C[v3]);
  return result;
}
// 10073420: using guessed type __int16 word_10073420[];
// 10073424: using guessed type __int16 word_10073424[];
// 10073428: using guessed type __int16 word_10073428[];
// 1007342C: using guessed type __int16 word_1007342C[];
// 10073430: using guessed type __int16 word_10073430[];
// 10073434: using guessed type __int16 word_10073434[];
// 10073438: using guessed type __int16 word_10073438[];
// 1007343C: using guessed type __int16 word_1007343C[];

//----- (1000D5B0) --------------------------------------------------------
int __usercall sub_1000D5B0@<eax>(unsigned __int8 a1@<bl>, char a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // esi@1
  int v5; // eax@1
  int v6; // ecx@3
  int v7; // edx@3
  int v8; // eax@3

  v4 = 0;
  v5 = sub_1001DC80(&a2, 1u, (int)&unk_10073250, 16, 29, 29);
  if ( a1 >= 2u
    || v5 >= 29
    || (v6 = 4 * v5,
        v7 = dword_10073254[4 * v5],
        v8 = 304 * a1,
        *a3 = dword_1012DFE8 + v8 + v7,
        *a4 = dword_1012DFE8 + v8 + dword_1007325C[v6],
        (v4 = dword_10073258[v6]) == 0) )
  {
    sub_1001B780("..\\lib\\acl\\iop\\grs\\iop_grs_frmt.c", 735, 0, 0);
  }
  return v4;
}
// 10073254: using guessed type int dword_10073254[];
// 10073258: using guessed type int dword_10073258[];
// 1007325C: using guessed type int dword_1007325C[];
// 1012DFE8: using guessed type int dword_1012DFE8;

//----- (1000D640) --------------------------------------------------------
char __cdecl sub_1000D640(char a1)
{
  int v1; // eax@1
  char v2; // bl@1

  v1 = sub_1001DC80(&a1, 2u, (int)&unk_1007345C, 2, 2, 2);
  v2 = v1;
  if ( v1 == 2 )
  {
    sub_1001B780("..\\lib\\acl\\iop\\grs\\iop_grs_frmt.c", 788, 1, 0);
    LOBYTE(v1) = v2;
  }
  return v1;
}

//----- (1000D680) --------------------------------------------------------
signed int sub_1000D680()
{
  dword_1012DFE8 = -15;
  if ( !sub_1004F780((LONG)&off_10073460) )
    sub_1001B780("..\\lib\\acl\\iop\\grs\\iop_grs_frmt.c", 846, 1, 0);
  return sub_1004F310((int)&off_10073460);
}
// 10073460: using guessed type char *off_10073460;
// 1012DFE8: using guessed type int dword_1012DFE8;

//----- (1000D6C0) --------------------------------------------------------
char __cdecl sub_1000D6C0(char a1, int a2, void *a3)
{
  int v3; // eax@1
  char v4; // bl@8
  char result; // al@8
  void *v6; // [sp+Ch] [bp-8h]@1
  char *v7; // [sp+10h] [bp-4h]@1

  v6 = 0;
  v7 = 0;
  v3 = sub_1000D5B0(a1, a2, &v6, &v7);
  if ( (unsigned int)a3 < 0xFFFFFFC2
    && a3
    && v3
    && (unsigned int)v6 < 0xFFFFFFC2
    && v6
    && (unsigned int)v7 < 0xFFFFFFC2
    && v7 )
  {
    v4 = *v7;
    memcpy(a3, v6, v3);
    result = v4;
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\iop\\grs\\iop_grs_frmt.c", 218, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1000D760) --------------------------------------------------------
char __cdecl sub_1000D760(char a1, int a2, void *a3, int a4, char a5)
{
  unsigned int v5; // eax@1
  char *v6; // esi@7
  char result; // al@9
  void *v8; // [sp+8h] [bp-8h]@1
  unsigned int v9; // [sp+Ch] [bp-4h]@1

  v8 = 0;
  v9 = 0;
  v5 = sub_1000D5B0(a1, a2, &v8, &v9);
  if ( (unsigned int)a3 < 0xFFFFFFC2
    && a3
    && v5
    && a4 >= v5
    && (unsigned int)v8 < 0xFFFFFFC2
    && v8
    && (v6 = (char *)v9, v9 < 0xFFFFFFC2)
    && v9 )
  {
    memcpy(v8, a3, v5);
    result = a5;
    *v6 = a5;
  }
  else
  {
    result = sub_1001B780("..\\lib\\acl\\iop\\grs\\iop_grs_frmt.c", 654, 0, 0);
  }
  return result;
}

//----- (1000D800) --------------------------------------------------------
char __cdecl sub_1000D800(int a1, int a2)
{
  char result; // al@1
  int v3; // ST14_4@9
  char v4; // al@9
  int v5; // [sp+4h] [bp-9Ch]@0
  int v6; // [sp+8h] [bp-98h]@1
  char v7; // [sp+Ch] [bp-94h]@1
  char v8; // [sp+Dh] [bp-93h]@5
  char v9; // [sp+10h] [bp-90h]@9

  v6 = 0;
  memset(&v7, 0, 0x94u);
  result = sub_1000F640(a1, a2, &v7, (unsigned __int16 *)&v6);
  if ( result == 1 )
  {
    result = v7;
    if ( v7 == 5 )
    {
      result = byte_10073459[2 * sub_1001DC80(&v8, 1u, (int)&unk_10073458, 2, 2, 1)];
    }
    else if ( v7 == 12 )
    {
      result = byte_10073455[2 * sub_1001DC80(&v8, 1u, (int)&unk_10073454, 2, 2, 1)];
    }
    else
    {
      if ( v7 != 103 )
        return result;
      result = byte_10073441[2 * sub_1001DC80(&v8, 1u, (int)&unk_10073440, 2, 9, 8)];
    }
    LOBYTE(v5) = result;
    if ( (unsigned __int8)result < 0x1Du )
    {
      v3 = (unsigned __int16)v6 - 4;
      v4 = sub_1000D640(a1);
      result = sub_1000D760(v4, v5, &v9, v3, 1);
    }
  }
  return result;
}

//----- (1000D900) --------------------------------------------------------
signed __int16 __usercall sub_1000D900@<ax>(int a1@<eax>, int a2@<ecx>)
{
  signed __int16 result; // ax@2

  a1 = (unsigned __int16)a1;
  if ( (signed int)(unsigned __int16)a1 >= *(_DWORD *)(a2 + 4) )
    result = -1;
  else
    result = *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * a1);
  return result;
}

//----- (1000D920) --------------------------------------------------------
int __usercall sub_1000D920@<eax>(int a1@<esi>, signed int a2)
{
  int v2; // edx@1
  char v3; // cl@1
  int v4; // ebp@1
  signed int v5; // edx@1
  int v6; // eax@1
  int v7; // edi@2
  int v8; // ecx@3
  bool v9; // zf@3
  int v10; // edi@5
  signed int v11; // ebx@5
  int v12; // ebp@8
  int v13; // edx@9
  int v14; // eax@11
  __int16 v15; // cx@11
  char v16; // dl@11
  int v17; // edx@11
  int v18; // eax@11
  int v19; // ecx@11
  unsigned int v20; // eax@15
  int v21; // ecx@15
  char v23; // [sp+7h] [bp-29h]@5
  int v24; // [sp+8h] [bp-28h]@1
  int v25; // [sp+Ch] [bp-24h]@1
  int v26; // [sp+10h] [bp-20h]@8
  int v27; // [sp+14h] [bp-1Ch]@3
  int v28; // [sp+18h] [bp-18h]@3
  int v29; // [sp+1Ch] [bp-14h]@1
  char v30; // [sp+20h] [bp-10h]@1
  char v31; // [sp+21h] [bp-Fh]@1
  __int16 v32; // [sp+22h] [bp-Eh]@16
  int v33; // [sp+24h] [bp-Ch]@11
  int v34; // [sp+28h] [bp-8h]@11

  v2 = *(_DWORD *)(a1 + 60);
  v3 = *(_BYTE *)(a1 + 1);
  v4 = ~*(_DWORD *)(a1 + 72);
  v29 = *(_DWORD *)(a1 + 16);
  v30 = v3;
  v31 = 1;
  v25 = v4;
  sub_1004E560(v2, -1);
  v5 = a2;
  v6 = 0;
  v24 = 0;
  if ( a2 > 0 )
  {
    do
    {
      v7 = *(_DWORD *)(a1 + 48);
      if ( *(_BYTE *)(v7 + 20 * v6) != 1 )
      {
        v8 = v4 & (*(_DWORD *)(v7 + 20 * v6 + 12) | 0xC00000);
        v9 = *(_BYTE *)(a1 + 1) == 6;
        v27 = v4 & (*(_DWORD *)(v7 + 20 * v6 + 12) | 0xC00000);
        v28 = v4 & (*(_DWORD *)(v7 + 20 * v6 + 12) | 0xC00000);
        if ( v9 || !(v8 & *(_DWORD *)(a1 + 84)) )
        {
          v23 = 1;
          v10 = *(_DWORD *)(a1 + 16) + 12;
          v11 = 12;
        }
        else
        {
          v10 = *(_DWORD *)(a1 + 16);
          v23 = 0;
          v11 = 0;
        }
        if ( v6 < v5 )
        {
          v12 = 20 * v6;
          v26 = v5 - v6;
          do
          {
            v13 = *(_DWORD *)(a1 + 48);
            if ( !*(_BYTE *)(v13 + v12) && v8 == (v25 & (*(_DWORD *)(v13 + v12 + 12) | 0xC00000)) )
            {
              v14 = v13 + v12;
              v15 = *(_WORD *)(v13 + v12 + 6);
              LOWORD(v33) = *(_WORD *)(v13 + v12 + 4);
              v16 = *(_BYTE *)(v13 + v12 + 1);
              BYTE1(v34) = *(_BYTE *)(v14 + 2);
              HIWORD(v33) = v15;
              LOBYTE(v34) = v16;
              v17 = v34;
              *(_DWORD *)v10 = v33;
              *(_DWORD *)(v10 + 4) = v17;
              memcpy(
                (void *)(v10 + 8),
                *(const void **)(*(_DWORD *)(a1 + 48) + v12 + 8),
                *(_WORD *)(*(_DWORD *)(a1 + 48) + v12 + 6));
              v18 = *(_DWORD *)(a1 + 48) + v12;
              v19 = *(_WORD *)(v18 + 6);
              v10 += v19 + 8;
              v11 += v19 + 8;
              v8 = v27;
              *(_BYTE *)v18 = 1;
            }
            v12 += 20;
            --v26;
          }
          while ( v26 );
          v4 = v25;
        }
        if ( v23 )
        {
          v20 = sub_1004E2C0((unsigned int *)(*(_DWORD *)(a1 + 16) + 12), v11 - 12, 0xFFFFFFFF);
          v21 = *(_DWORD *)(a1 + 16);
          v33 = 327678;
          LOWORD(v34) = 1;
          *(_DWORD *)v21 = 327678;
          *(_DWORD *)(v21 + 4) = v34;
          *(_DWORD *)(v21 + 8) = v20;
        }
        v32 = v11;
        if ( j_HWM_pvg_hsdb_put(&v28) == -100 )
          sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 4355, 0, 0);
        v5 = a2;
      }
      v6 = v24 + 1;
      v24 = v6;
      v6 = (unsigned __int16)v6;
    }
    while ( (unsigned __int16)v6 < v5 );
  }
  return sub_1004E540(*(_DWORD *)(a1 + 60));
}
// 1004ECC0: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);

//----- (1000DB20) --------------------------------------------------------
int __usercall sub_1000DB20@<eax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // ebx@1
  int v4; // edi@2
  signed __int16 v5; // ax@3
  int v6; // ebx@3
  int v7; // ebp@3
  int v8; // eax@3
  int v9; // ecx@3
  int v11; // [sp+4h] [bp-8h]@2
  int v12; // [sp+8h] [bp-4h]@3

  v3 = a1;
  sub_1004E560(*(_DWORD *)(a2 + 60), -1);
  if ( v3 )
  {
    v4 = 0;
    v11 = v3;
    do
    {
      v12 = *(_WORD *)(v4 + *(_DWORD *)(a2 + 48) + 4);
      v5 = sub_1000D900(v12, a2);
      v6 = (unsigned __int16)v5;
      v7 = 52 * (unsigned __int16)v5;
      memcpy(
        (void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(*(_DWORD *)(a2 + 32) + v7 + 4)),
        *(const void **)(v4 + *(_DWORD *)(a2 + 48) + 8),
        *(_WORD *)(v4 + *(_DWORD *)(a2 + 48) + 6));
      v8 = 24 * v6;
      *(_WORD *)(v8 + *(_DWORD *)(a2 + 64) + 4) = *(_WORD *)(v4 + *(_DWORD *)(a2 + 48) + 6);
      *(_BYTE *)(v8 + *(_DWORD *)(a2 + 64) + 1) = *(_BYTE *)(v4 + *(_DWORD *)(a2 + 48) + 1);
      *(_DWORD *)(v8 + *(_DWORD *)(a2 + 64) + 20) = *(_DWORD *)(v4 + *(_DWORD *)(a2 + 48) + 16);
      *(_BYTE *)(v8 + *(_DWORD *)(a2 + 64) + 2) = *(_BYTE *)(v4 + *(_DWORD *)(a2 + 48) + 2);
      *(_DWORD *)(v8 + *(_DWORD *)(a2 + 64) + 16) = a3;
      *(_BYTE *)(v8 + *(_DWORD *)(a2 + 64)) = 0;
      v9 = v7 + *(_DWORD *)(a2 + 32);
      if ( *(_DWORD *)(v9 + 36) && !*(_DWORD *)(v9 + 12) && !(*(_BYTE *)(v8 + *(_DWORD *)(a2 + 64) + 6) & 1) )
      {
        sub_1004E540(*(_DWORD *)(a2 + 60));
        (*(void (__cdecl **)(int, int))(*(_DWORD *)(a2 + 32) + v7 + 36))(v12, a2);
        sub_1004E560(*(_DWORD *)(a2 + 60), -1);
      }
      v4 += 20;
      --v11;
    }
    while ( v11 );
  }
  return sub_1004E540(*(_DWORD *)(a2 + 60));
}

//----- (1000DC40) --------------------------------------------------------
char __cdecl sub_1000DC40(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@2
  char result; // al@2

  LOWORD(v2) = sub_1000D900(a1, a2);
  if ( (_WORD)v2 == -1 )
  {
    result = sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 670, 0, 0);
  }
  else
  {
    sub_1004E560(*(_DWORD *)(a2 + 60), -1);
    v2 = (unsigned __int16)v2;
    v3 = 52 * (unsigned __int16)v2 + *(_DWORD *)(a2 + 32);
    memset((void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(v3 + 4)), 0, *(_WORD *)v3);
    result = sub_1004E540(*(_DWORD *)(a2 + 60));
    *(_BYTE *)(*(_DWORD *)(a2 + 64) + 24 * v2 + 1) = 0;
  }
  return result;
}

//----- (1000DCC0) --------------------------------------------------------
signed __int16 __cdecl sub_1000DCC0(int a1, int a2)
{
  return sub_1000D900(a2, a1);
}

//----- (1000DCD0) --------------------------------------------------------
char __cdecl sub_1000DCD0(int a1, int a2, void *a3, unsigned __int16 a4)
{
  signed __int16 v4; // di@1
  int v5; // ebp@2
  int v6; // eax@2
  int v7; // ST30_4@3
  const char *v8; // eax@3
  int v10; // edx@4
  int v11; // ecx@4
  unsigned __int16 v12; // di@4
  int v13; // ecx@6
  int v14; // ST2C_4@16
  int v15; // ST28_4@16
  const char *v16; // eax@16
  char v17; // [sp+13h] [bp-75h]@4
  unsigned __int16 v18; // [sp+18h] [bp-70h]@1
  unsigned int v19; // [sp+1Ch] [bp-6Ch]@1
  char v20; // [sp+20h] [bp-68h]@3

  v4 = sub_1000D900(a1, a2);
  v18 = v4;
  v19 = sub_1004E4B0();
  if ( v4 == -1 )
  {
    v17 = 0;
    sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 943, 0, 0);
  }
  else
  {
    v5 = 52 * (unsigned __int16)v4;
    v6 = *(_DWORD *)(a2 + 32) + v5;
    if ( *(_BYTE *)(v6 + 8) )
    {
      v7 = *(_BYTE *)(a2 + 1);
      v8 = sub_10010CB0(a2, v4);
      _snprintf(&v20, 0x64u, "%d-%s is var pipe=%d", (unsigned __int16)a1, v8, v7);
      sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 874, 0, &v20);
      return 0;
    }
    v10 = *(_DWORD *)(a2 + 64);
    v11 = 24 * (unsigned __int16)v4;
    v12 = *(_WORD *)(v10 + v11 + 4);
    v17 = *(_BYTE *)(v10 + v11 + 1);
    if ( *(_BYTE *)(v11 + v10)
      || *(_DWORD *)(v6 + 12)
      && ((v13 = *(_DWORD *)(v11 + *(_DWORD *)(a2 + 64) + 16)) == 0
       || v19 > v13 + *(_DWORD *)(a2 + 36) + *(_DWORD *)(v6 + 16)) )
    {
      v17 = 0;
    }
    if ( v12 && v12 <= a4 && v12 == *(_WORD *)v6 )
    {
      sub_1004E560(*(_DWORD *)(a2 + 60), -1);
      memcpy(a3, (const void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(*(_DWORD *)(a2 + 32) + v5 + 4)), v12);
      sub_1004E540(*(_DWORD *)(a2 + 60));
    }
    else
    {
      v17 = 0;
    }
    if ( v12 > a4 || v12 != *(_WORD *)(*(_DWORD *)(a2 + 32) + v5) )
    {
      v14 = *(_BYTE *)(a2 + 1);
      v15 = *(_WORD *)(*(_DWORD *)(a2 + 32) + v5);
      v16 = sub_10010CB0(a2, v18);
      _snprintf(&v20, 0x64u, "%d-%s by=%d sz=%d pi=%d bsz=%d", (unsigned __int16)a1, v16, v12, v15, v14, a4);
      sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 936, 0, &v20);
    }
  }
  return v17;
}

//----- (1000DEC0) --------------------------------------------------------
int __cdecl sub_1000DEC0(int a1, int a2)
{
  signed __int16 v2; // ax@1
  int v3; // edx@1
  int result; // eax@2

  v2 = sub_1000D900(a1, a2);
  if ( v2 == -1 )
  {
    sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 992, 0, 0);
    result = 0;
  }
  else
  {
    result = *(_DWORD *)(*(_DWORD *)(v3 + 64) + 24 * (unsigned __int16)v2 + 20);
  }
  return result;
}

//----- (1000DF10) --------------------------------------------------------
char __cdecl sub_1000DF10(int a1, int a2, void *a3, unsigned __int16 *a4, unsigned __int16 a5)
{
  signed __int16 v5; // bp@1
  int v6; // edi@2
  int v7; // ST30_4@3
  const char *v8; // eax@3
  int v10; // ecx@4
  unsigned __int16 v11; // bp@4
  int v12; // eax@4
  int v13; // eax@5
  int v14; // ecx@6
  unsigned __int16 v15; // ax@14
  unsigned __int16 v16; // cx@14
  int v17; // ST2C_4@16
  int v18; // ST28_4@16
  int v19; // ST24_4@16
  const char *v20; // eax@16
  char v21; // [sp+13h] [bp-75h]@4
  unsigned __int16 v22; // [sp+18h] [bp-70h]@1
  unsigned int v23; // [sp+1Ch] [bp-6Ch]@1
  char v24; // [sp+20h] [bp-68h]@3

  v5 = sub_1000D900(a1, a2);
  v22 = v5;
  v23 = sub_1004E4B0();
  if ( v5 == -1 )
  {
    v21 = 0;
    *a4 = 0;
    sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1267, 0, 0);
  }
  else
  {
    v6 = 52 * (unsigned __int16)v5;
    if ( *(_BYTE *)(*(_DWORD *)(a2 + 32) + v6 + 8) != 1 )
    {
      v7 = *(_BYTE *)(a2 + 1);
      v8 = sub_10010CB0(a2, v5);
      _snprintf(&v24, 0x64u, "%d-%s !var pipe=%d", (unsigned __int16)a1, v8, v7);
      sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1189, 0, &v24);
      return 0;
    }
    v10 = 24 * (unsigned __int16)v5;
    v11 = *(_WORD *)(v10 + *(_DWORD *)(a2 + 64) + 4);
    *a4 = v11;
    v12 = *(_DWORD *)(a2 + 64);
    v21 = *(_BYTE *)(v10 + v12 + 1);
    if ( *(_BYTE *)(v10 + v12)
      || (v13 = *(_DWORD *)(a2 + 32) + v6, *(_DWORD *)(v13 + 12))
      && ((v14 = *(_DWORD *)(v10 + *(_DWORD *)(a2 + 64) + 16)) == 0
       || v23 > v14 + *(_DWORD *)(a2 + 36) + *(_DWORD *)(v13 + 16)) )
    {
      v21 = 0;
    }
    if ( v11 && v11 <= *(_WORD *)(v6 + *(_DWORD *)(a2 + 32)) && v11 <= a5 )
    {
      sub_1004E560(*(_DWORD *)(a2 + 60), -1);
      memcpy(a3, (const void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(*(_DWORD *)(a2 + 32) + v6 + 4)), *a4);
      sub_1004E540(*(_DWORD *)(a2 + 60));
    }
    else
    {
      v21 = 0;
    }
    v15 = *a4;
    v16 = *(_WORD *)(v6 + *(_DWORD *)(a2 + 32));
    if ( *a4 > v16 || v15 > a5 )
    {
      v17 = *(_BYTE *)(a2 + 1);
      v18 = v16;
      v19 = v15;
      v20 = sub_10010CB0(a2, v22);
      _snprintf(&v24, 0x64u, "%d-%s by=%d sz=%d pipe=%d bsz=%d", (unsigned __int16)a1, v20, v19, v18, v17, a5);
      sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1260, 0, &v24);
    }
  }
  return v21;
}

//----- (1000E120) --------------------------------------------------------
int __cdecl sub_1000E120(int a1)
{
  int v1; // ebp@1
  int v2; // edi@1
  int v3; // eax@2
  int v4; // ecx@3
  signed int v5; // ebx@7
  unsigned __int16 v6; // cx@7
  int v7; // eax@8
  int v8; // ecx@14

  v1 = *(_DWORD *)(a1 + 8);
  sub_1004E560(*(_DWORD *)(a1 + 60), -1);
  v2 = 0;
  if ( *(_DWORD *)(a1 + 4) > 0 )
  {
    do
    {
      LOWORD(v3) = sub_1000D900(v2, a1);
      if ( (_WORD)v3 != -1 )
      {
        v3 = (unsigned __int16)v3;
        v4 = *(_DWORD *)(a1 + 32) + 52 * (unsigned __int16)v3;
        if ( *(_BYTE *)(v4 + 28) & *(_BYTE *)a1 )
        {
          if ( *(_BYTE *)(v3 + *(_DWORD *)(a1 + 24)) == 1
            && *(_DWORD *)(v4 + 12)
            && *(_DWORD *)(v4 + 24) & *(_DWORD *)(a1 + 72) )
          {
            v5 = *(_DWORD *)(a1 + 8);
            v6 = 0;
            if ( v5 > 0 )
            {
              v7 = 0;
              do
              {
                if ( *(_WORD *)(*(_DWORD *)(a1 + 68) + 2 * v7) == (_WORD)v2 )
                  break;
                v7 = ++v6;
              }
              while ( v6 < v5 );
            }
            if ( v6 == v5 )
              *(_WORD *)(*(_DWORD *)(a1 + 68) + 2 * v1++) = v2;
          }
        }
      }
      ++v2;
    }
    while ( (signed int)(unsigned __int16)v2 < *(_DWORD *)(a1 + 4) );
  }
  v8 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 8) = v1;
  return sub_1004E540(v8);
}

//----- (1000E1D0) --------------------------------------------------------
int __cdecl sub_1000E1D0(int a1)
{
  int v1; // ebp@1
  int v2; // edi@1
  signed __int16 v3; // ax@2
  int v4; // ecx@3
  int v5; // eax@3
  int v6; // edx@12

  v1 = 0;
  sub_1004E560(*(_DWORD *)(a1 + 60), -1);
  v2 = 0;
  if ( *(_DWORD *)(a1 + 4) > 0 )
  {
    do
    {
      v3 = sub_1000D900(v2, a1);
      if ( v3 != -1 )
      {
        v4 = (unsigned __int16)v3;
        v5 = 52 * (unsigned __int16)v3 + *(_DWORD *)(a1 + 32);
        if ( *(_BYTE *)(v5 + 28) & *(_BYTE *)a1 )
        {
          if ( *(_BYTE *)(v4 + *(_DWORD *)(a1 + 24)) == 1
            && *(_DWORD *)(v5 + 12)
            && *(_DWORD *)(v5 + 20) & *(_DWORD *)(a1 + 72)
            && *(_DWORD *)(v5 + 24) )
          {
            if ( (unsigned int)*(_WORD *)v5 + 20 > *(_DWORD *)(a1 + 20) )
              sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1622, 0, 0);
            else
              *(_WORD *)(*(_DWORD *)(a1 + 76) + 2 * v1++) = v2;
          }
        }
      }
      ++v2;
    }
    while ( (signed int)(unsigned __int16)v2 < *(_DWORD *)(a1 + 4) );
  }
  v6 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 12) = v1;
  return sub_1004E540(v6);
}

//----- (1000E280) --------------------------------------------------------
char __cdecl sub_1000E280(int a1)
{
  char v1; // cl@1
  int v2; // eax@2
  int v3; // ebx@3
  signed int v4; // ebp@3
  unsigned int v5; // eax@3
  unsigned int v6; // edi@3
  bool v7; // zf@3
  unsigned int v8; // eax@4
  unsigned int v9; // eax@6
  int v10; // edx@15
  int v11; // eax@15
  int v12; // edi@15
  int v13; // edx@15
  int v14; // ebp@15
  int v15; // ebx@15
  int v16; // eax@15
  int v17; // eax@19
  char v18; // cl@19
  int v19; // ecx@24
  int v20; // edi@25
  int v21; // ecx@30
  int v22; // edx@30
  unsigned int v23; // edi@38
  int v24; // ebp@44
  int v25; // eax@45
  int v26; // edx@45
  int v27; // ecx@45
  void (__cdecl *v28)(int, int); // edi@45
  unsigned int v30; // [sp+10h] [bp-90h]@3
  int v31; // [sp+14h] [bp-8Ch]@3
  int v32; // [sp+18h] [bp-88h]@20
  unsigned int v33; // [sp+18h] [bp-88h]@44
  int v34; // [sp+1Ch] [bp-84h]@1
  int v35; // [sp+20h] [bp-80h]@2
  int v36; // [sp+24h] [bp-7Ch]@1
  char v37; // [sp+28h] [bp-78h]@1
  unsigned __int16 v38; // [sp+2Ah] [bp-76h]@3
  unsigned int v39; // [sp+2Ch] [bp-74h]@1
  int v40; // [sp+30h] [bp-70h]@15
  int v41; // [sp+34h] [bp-6Ch]@3
  char v42; // [sp+38h] [bp-68h]@9

  v1 = *(_BYTE *)(a1 + 1);
  v36 = *(_DWORD *)(a1 + 16);
  v37 = v1;
  v39 = sub_1004E4B0();
  v34 = 0;
LABEL_2:
  while ( 1 )
  {
    v2 = j_HWM_pvg_hsdb_get(&v35, *(_DWORD *)(a1 + 20));
    if ( v2 <= 0 )
      break;
    v3 = *(_DWORD *)(a1 + 16);
    v4 = v38;
    v5 = *(_DWORD *)v3;
    v6 = 0;
    v7 = (unsigned __int16)*(_DWORD *)v3 == -2;
    v31 = v38;
    v30 = 0;
    v41 = *(_DWORD *)(v3 + 4);
    if ( v7 )
    {
      v8 = v5 >> 16;
      v4 = -8 - (unsigned __int16)v8 + v38;
      v31 = -8 - (unsigned __int16)v8 + v38;
      v3 += (unsigned __int16)v8 + 8;
      if ( (unsigned __int16)v8 < 4u || v4 <= 0 )
      {
        v31 = 0;
        v4 = 0;
        v9 = ~v34;
      }
      else
      {
        v34 = *(_DWORD *)(v3 - 4);
        v9 = sub_1004E2C0((unsigned int *)v3, v4, 0xFFFFFFFF);
      }
      if ( v34 != v9 )
      {
        _snprintf(&v42, 0x64u, "crc error rxsz=%d pipe=%d addr=0x%lx", v38, v37, v35);
        sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1796, 0, &v42);
        continue;
      }
    }
    else if ( *(_BYTE *)(a1 + 1) == 6 )
    {
      _snprintf(&v42, 0x64u, "crc error rxsz=%d pipe=%d addr=0x%lx", v38, v37, v35);
      sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1817, 0, &v42);
      continue;
    }
    if ( v4 > 0 )
    {
      while ( 1 )
      {
        v10 = *(_DWORD *)v3;
        v11 = *(_DWORD *)(v3 + 4);
        v12 = 20 * v6;
        *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 4) = *(_DWORD *)v3;
        *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 6) = HIWORD(v10);
        *(_BYTE *)(v12 + *(_DWORD *)(a1 + 48) + 1) = v11;
        *(_BYTE *)(v12 + *(_DWORD *)(a1 + 48) + 2) = BYTE1(v11);
        v40 = v10;
        LOWORD(v14) = sub_1000D900(v10, a1);
        *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 16) = v35;
        v15 = v3 + 8;
        *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 8) = v15;
        v16 = *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 6);
        v3 = v16 + v15;
        v31 += -8 - v16;
        if ( v31 < 0 )
        {
          _snprintf(
            &v42,
            0x64u,
            "error with pkt id %d rxsz=%d pipe=%d",
            (unsigned __int16)v13,
            HIWORD(v40),
            *(_BYTE *)(a1 + 1));
          sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1877, 0, &v42);
          goto LABEL_2;
        }
        if ( *(_DWORD *)(a1 + 80) )
          (*(void (__cdecl **)(int, int, _DWORD, _DWORD))(a1 + 80))(
            a1,
            v13,
            *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 6),
            *(_DWORD *)(*(_DWORD *)(a1 + 48) + v12 + 8));
        if ( (_WORD)v14 == -1 )
        {
LABEL_39:
          v23 = v30;
          goto LABEL_40;
        }
        v14 = (unsigned __int16)v14;
        v17 = 52 * (unsigned __int16)v14 + *(_DWORD *)(a1 + 32);
        v18 = *(_BYTE *)(v17 + 8);
        if ( v18 )
        {
          v32 = v12 + *(_DWORD *)(a1 + 48);
          if ( *(_WORD *)(v32 + 6) <= *(_WORD *)v17 )
            goto LABEL_23;
          if ( v18 )
            goto LABEL_39;
        }
        v32 = v12 + *(_DWORD *)(a1 + 48);
        if ( *(_WORD *)(v32 + 6) != *(_WORD *)v17 )
          goto LABEL_39;
LABEL_23:
        if ( *(_BYTE *)(*(_DWORD *)(a1 + 24) + v14) != 1 )
          goto LABEL_39;
        v19 = *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 16);
        if ( (v19 & *(_DWORD *)(v17 + 20)) != v19 )
        {
          v20 = *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 16);
          if ( (v20 & 0xC00000) != v20 && !(*(_BYTE *)a1 & 4) )
            goto LABEL_39;
        }
        if ( !(*(_DWORD *)(v17 + 24) & *(_DWORD *)(a1 + 72)) || !(*(_BYTE *)(v17 + 28) & *(_BYTE *)a1) )
          goto LABEL_39;
        if ( *(_DWORD *)(v17 + 12) )
        {
          v21 = *(_DWORD *)(a1 + 64) + 24 * v14;
          v22 = *(_DWORD *)(v21 + 16);
          if ( v22 )
          {
            if ( v39 <= v22 + *(_DWORD *)(a1 + 36) + (*(_DWORD *)(v17 + 16) >> 1)
              && (*(_BYTE *)(v32 + 1) != 1 || *(_BYTE *)(v21 + 1) == 1 && *(_BYTE *)(v32 + 2) > *(_BYTE *)(v21 + 2))
              && (*(_BYTE *)(v21 + 1) == 1 || *(_BYTE *)(v32 + 2) > *(_BYTE *)(v21 + 2))
              && *(_BYTE *)(v32 + 2) != *(_BYTE *)(v21 + 2) )
            {
              goto LABEL_39;
            }
          }
        }
        v23 = v30++ + 1;
LABEL_40:
        if ( !v31 || v23 >= *(_DWORD *)(a1 + 52) )
        {
          if ( v23 )
          {
            sub_1000DB20(v23, a1, v39);
            if ( v23 )
            {
              v24 = 0;
              v33 = v23;
              do
              {
                v25 = (unsigned __int16)sub_1000D900(*(_WORD *)(*(_DWORD *)(a1 + 48) + v24 + 4), a1);
                v27 = *(_DWORD *)(a1 + 32) + 52 * (unsigned __int16)v25;
                v28 = *(void (__cdecl **)(int, int))(v27 + 36);
                if ( v28 && *(_DWORD *)(v27 + 12) && !(*(_BYTE *)(*(_DWORD *)(a1 + 64) + 24 * v25 + 6) & 1) )
                  v28(v26, a1);
                v24 += 20;
                --v33;
              }
              while ( v33 );
            }
          }
          v30 = 0;
        }
        if ( v31 <= 0 )
          goto LABEL_2;
        v6 = v30;
      }
    }
  }
  if ( v2 == -95 )
    LOBYTE(v2) = sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2094, 0, 0);
  return v2;
}
// 1004ECA0: using guessed type int __cdecl j_HWM_pvg_hsdb_get(_DWORD, _DWORD);

//----- (1000E680) --------------------------------------------------------
int __cdecl sub_1000E680(int a1)
{
  int result; // eax@1
  signed __int16 v2; // ax@2
  int v3; // ebx@2
  int v4; // edi@2
  unsigned int *v5; // edx@2
  int v6; // ebp@3
  unsigned int v7; // ecx@3
  unsigned int v8; // ebx@4
  unsigned int v9; // eax@4
  int v10; // ecx@5
  int v11; // eax@5
  int v12; // edx@8
  int v13; // ecx@8
  int v14; // edx@8
  unsigned int v15; // eax@12
  int v16; // edx@16
  int v17; // ST24_4@19
  const char *v18; // eax@19
  int v19; // eax@20
  int v20; // ecx@21
  int v21; // ebx@24
  int v22; // edx@26
  int v23; // eax@27
  int v24; // eax@29
  int v25; // eax@31
  int v26; // edx@31
  int v27; // eax@32
  int v28; // ecx@32
  int v29; // ebp@32
  void (__cdecl *v30)(int, int); // ebp@33
  unsigned int v31; // [sp+8h] [bp-8Ch]@1
  signed int v32; // [sp+Ch] [bp-88h]@1
  unsigned int v33; // [sp+10h] [bp-84h]@1
  int v34; // [sp+14h] [bp-80h]@1
  int v35; // [sp+18h] [bp-7Ch]@2
  int v36; // [sp+1Ch] [bp-78h]@1
  unsigned __int16 v37; // [sp+24h] [bp-70h]@2
  int v38; // [sp+28h] [bp-6Ch]@2
  char v39; // [sp+2Ch] [bp-68h]@19

  v33 = 12;
  v36 = j_HWM_pvg_hsdb_get_lrus_online();
  v32 = 0;
  result = sub_1004E4B0();
  v31 = result;
  v34 = 0;
  if ( *(_DWORD *)(a1 + 12) > 0 )
  {
    do
    {
      v35 = *(_WORD *)(*(_DWORD *)(a1 + 76) + 2 * v34);
      v2 = sub_1000D900(v35, a1);
      v3 = (unsigned __int16)v2;
      v4 = 24 * (unsigned __int16)v2;
      v5 = (unsigned int *)(v4 + *(_DWORD *)(a1 + 64) + 8);
      v37 = v2;
      v38 = (unsigned __int16)v2;
      if ( v31 >= *v5 - *(_DWORD *)(a1 + 36) )
      {
        v6 = 52 * (unsigned __int16)v2;
        v7 = *v5 + *(_DWORD *)(*(_DWORD *)(a1 + 32) + 52 * (unsigned __int16)v2 + 12);
        if ( v31 >= v7 )
        {
          v8 = *(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 12);
          v5 = (unsigned int *)(v4 + *(_DWORD *)(a1 + 64) + 8);
          v9 = v8 * ((*(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 12) - v7 + v31 - 1) / v8);
          v3 = v38;
          v7 += v9;
        }
        *v5 = v7;
        v10 = v36;
        v11 = v6 + *(_DWORD *)(a1 + 32);
        if ( v36 & *(_DWORD *)(v11 + 24) || v10 & 0xC00000 || (*(_DWORD *)(v11 + 32) >> 3) & 1 )
        {
          v15 = *(_WORD *)v11 + v33 + 8;
          if ( v32 > 0 && (v15 > *(_DWORD *)(a1 + 20) || v15 > 0x5B0) )
          {
            sub_1000D920(a1, v32);
            v32 = 0;
            v33 = 12;
          }
          v16 = *(_DWORD *)(a1 + 32);
          if ( !*(_DWORD *)(v16 + v6 + 44) || *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 6) & 4 )
            goto LABEL_42;
          if ( (*(_DWORD *)(v16 + v6 + 32) >> 1) & 1 )
          {
            v17 = *(_BYTE *)(a1 + 1);
            v18 = sub_10010CB0(a1, v37);
            _snprintf(&v39, 0x64u, "%d-%s is TX_ON_PUT, pipe=%d", (unsigned __int16)v35, v18, v17);
            sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2279, 0, &v39);
          }
          v19 = v4 + *(_DWORD *)(a1 + 64);
          if ( *(_BYTE *)(*(_BYTE *)(a1 + 3) + v3 * *(_BYTE *)(a1 + 2) + *(_DWORD *)(a1 + 56)) > *(_BYTE *)(v19 + 2)
            && (v20 = *(_DWORD *)(v19 + 16)) != 0
            && v31 <= *(_DWORD *)(a1 + 36) + v20 + (*(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 16) >> 1)
            && *(_BYTE *)(v19 + 1) == 1 )
          {
LABEL_42:
            v21 = v35;
          }
          else
          {
            v21 = v35;
            (*(void (__cdecl **)(int, int))(*(_DWORD *)(a1 + 32) + v6 + 44))(v35, a1);
          }
          v22 = *(_DWORD *)(a1 + 64);
          if ( *(_BYTE *)(v4 + v22 + 3) == 1 )
          {
            v23 = *(_DWORD *)(v4 + v22 + 16);
            if ( v23 )
            {
              if ( v31 <= *(_DWORD *)(a1 + 36) + v23 + *(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 12) )
              {
                *(_DWORD *)(v4 + *(_DWORD *)(a1 + 64) + 12) = v31;
                *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 3) = 0;
                v24 = *(_DWORD *)(a1 + 64);
                if ( *(_DWORD *)(v4 + v24 + 20) & *(_DWORD *)(a1 + 72) )
                {
                  if ( *(_WORD *)(v4 + v24 + 4) )
                  {
                    v25 = 20 * v32;
                    *(_DWORD *)(v25 + *(_DWORD *)(a1 + 48) + 8) = *(_DWORD *)(a1 + 28)
                                                                + *(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 4);
                    *(_DWORD *)(v25 + *(_DWORD *)(a1 + 48) + 12) = v36 & *(_DWORD *)(*(_DWORD *)(a1 + 32) + v6 + 24);
                    *(_WORD *)(v25 + *(_DWORD *)(a1 + 48) + 4) = v21;
                    *(_WORD *)(v25 + *(_DWORD *)(a1 + 48) + 6) = *(_WORD *)(v4 + *(_DWORD *)(a1 + 64) + 4);
                    *(_BYTE *)(v25 + *(_DWORD *)(a1 + 48)) = 0;
                    ++v32;
                    *(_BYTE *)(v25 + *(_DWORD *)(a1 + 48) + 1) = *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 1);
                    *(_BYTE *)(v25 + *(_DWORD *)(a1 + 48) + 2) = *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 2);
                    v26 = *(_DWORD *)(a1 + 32);
                    v33 += *(_WORD *)(v26 + v6) + 8;
                    if ( (*(_DWORD *)(v26 + v6 + 32) >> 2) & 1 )
                    {
                      v27 = *(_DWORD *)(a1 + 32);
                      v28 = *(_DWORD *)(v6 + v27 + 24);
                      v29 = v27 + v6;
                      if ( v28 & *(_DWORD *)(a1 + 72) )
                      {
                        v30 = *(void (__cdecl **)(int, int))(v29 + 36);
                        if ( v30 )
                        {
                          if ( !(*(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 6) & 1) )
                            v30(v21, a1);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        else
        {
          v12 = *(_DWORD *)(a1 + 64);
          v13 = *(_DWORD *)(v12 + v4 + 16);
          v14 = v4 + v12;
          if ( (!v13 || v31 > *(_DWORD *)(a1 + 36) + v13 + *(_DWORD *)(v11 + 16)) && *(_BYTE *)(v14 + 1) == 1 )
          {
            *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 1) = 0;
            *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64) + 3) = 0;
          }
        }
      }
      ++v34;
    }
    while ( v34 < *(_DWORD *)(a1 + 12) );
    result = v32;
    if ( v32 > 0 && v33 <= *(_DWORD *)(a1 + 20) )
      result = sub_1000D920(a1, v32);
  }
  return result;
}
// 1004ECB0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (1000EA10) --------------------------------------------------------
char __cdecl sub_1000EA10(int a1, char a2, int a3, const void *a4, int a5)
{
  signed __int16 v5; // ax@1
  int v6; // ebx@2
  int v7; // ebp@2
  int v8; // edi@2
  int v9; // ecx@2
  int v10; // ST2C_4@4
  const char *v11; // eax@4
  int v12; // eax@5
  int v13; // edx@5
  int v14; // ecx@7
  int v15; // edx@7
  int v16; // ecx@7
  int v17; // eax@15
  unsigned int v18; // ecx@15
  int v19; // eax@15
  int v20; // edx@16
  int (__cdecl *v21)(int, int); // ebp@18
  int v22; // ST2C_4@23
  int v23; // ST28_4@23
  int v24; // ST24_4@23
  const char *v25; // eax@23
  unsigned int v26; // eax@4
  unsigned int v28; // [sp+10h] [bp-70h]@5
  char v29; // [sp+18h] [bp-68h]@4

  v5 = sub_1000D900(a1, a3);
  if ( v5 == -1
    || (v6 = (unsigned __int16)v5,
        v7 = 52 * (unsigned __int16)v5,
        v8 = 24 * (unsigned __int16)v5,
        v9 = v7 + *(_DWORD *)(a3 + 32),
        *(_WORD *)(*(_DWORD *)(a3 + 64) + v8 + 4) != *(_WORD *)v9) )
  {
    if ( (signed int)(unsigned __int16)a1 >= *(_DWORD *)(a3 + 4) || v5 == -1 )
    {
      _snprintf(&v29, 0x64u, "pkt:%d lut_id:%d pipe:%d", (unsigned __int16)a1, (unsigned __int16)v5, *(_BYTE *)(a3 + 1));
      LOBYTE(v26) = sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2645, 0, &v29);
    }
    else
    {
      v22 = *(_BYTE *)(a3 + 1);
      v23 = *(_WORD *)(52 * (unsigned __int16)v5 + *(_DWORD *)(a3 + 32));
      v24 = *(_WORD *)(*(_DWORD *)(a3 + 64) + 24 * (unsigned __int16)v5 + 4);
      v25 = sub_10010CB0(a3, v5);
      _snprintf(&v29, 0x64u, "%d-%s stssz=%d infsz=%d pipe=%d", (unsigned __int16)a1, v25, v24, v23, v22);
      LOBYTE(v26) = sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2660, 0, &v29);
    }
  }
  else if ( *(_BYTE *)(v9 + 8) )
  {
    v10 = *(_BYTE *)(a3 + 1);
    v11 = sub_10010CB0(a3, v5);
    _snprintf(&v29, 0x64u, "%d-%s is var pipe=%d", (unsigned __int16)a1, v11, v10);
    LOBYTE(v26) = sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2511, 0, &v29);
  }
  else
  {
    v12 = sub_1004E4B0();
    v13 = *(_DWORD *)(a3 + 32);
    v28 = v12;
    if ( !*(_DWORD *)(v13 + v7 + 12)
      || (v26 = *(_DWORD *)(v13 + v7 + 16), v28 <= a5 + v26 + *(_DWORD *)(a3 + 36))
      && ((v14 = *(_DWORD *)(a3 + 64), v15 = *(_DWORD *)(v14 + v8 + 16), v16 = v8 + v14, !v15)
       || v28 > *(_DWORD *)(a3 + 36) + v15 + (v26 >> 1)
       || a2
       && (*(_BYTE *)(v16 + 1) != 1
        || *(_BYTE *)(*(_BYTE *)(a3 + 3) + v6 * *(_BYTE *)(a3 + 2) + *(_DWORD *)(a3 + 56)) <= *(_BYTE *)(v16 + 2))
       || *(_BYTE *)(v16 + 1) != 1
       && *(_BYTE *)(*(_BYTE *)(a3 + 3) + v6 * *(_BYTE *)(a3 + 2) + *(_DWORD *)(a3 + 56)) <= *(_BYTE *)(v16 + 2)
       || (v26 = *(_DWORD *)(a3 + 56),
           *(_BYTE *)(*(_BYTE *)(a3 + 3) + v6 * *(_BYTE *)(a3 + 2) + v26) == *(_BYTE *)(v16 + 2))) )
    {
      sub_1004E560(*(_DWORD *)(a3 + 60), -1);
      *(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 1) = a2;
      *(_DWORD *)(*(_DWORD *)(a3 + 64) + v8 + 16) = a5;
      *(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 2) = *(_BYTE *)(*(_BYTE *)(a3 + 3)
                                                           + v6 * *(_BYTE *)(a3 + 2)
                                                           + *(_DWORD *)(a3 + 56));
      *(_BYTE *)(v8 + *(_DWORD *)(a3 + 64)) = 0;
      *(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 3) = 1;
      *(_DWORD *)(*(_DWORD *)(a3 + 64) + v8 + 20) = *(_DWORD *)(a3 + 72);
      v17 = *(_DWORD *)(a3 + 32);
      v18 = *(_DWORD *)(v17 + v7 + 32);
      v19 = v7 + v17;
      if ( (v18 >> 1) & 1 )
      {
        v20 = *(_DWORD *)(a3 + 64);
        if ( v28 < *(_DWORD *)(v20 + v8 + 8) )
          *(_DWORD *)(v20 + v8 + 8) -= *(_DWORD *)(v19 + 12);
      }
      memcpy(
        (void *)(*(_DWORD *)(a3 + 28) + *(_DWORD *)(*(_DWORD *)(a3 + 32) + v7 + 4)),
        a4,
        *(_WORD *)(*(_DWORD *)(a3 + 64) + v8 + 4));
      LOBYTE(v26) = sub_1004E540(*(_DWORD *)(a3 + 60));
      v21 = *(int (__cdecl **)(int, int))(*(_DWORD *)(a3 + 32) + v7 + 48);
      if ( v21 && !(*(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 6) & 8) )
        LOBYTE(v26) = v21(a1, a3);
    }
  }
  return v26;
}

//----- (1000ED20) --------------------------------------------------------
char __cdecl sub_1000ED20(int a1, unsigned __int16 a2, char a3, int a4, const void *a5, int a6)
{
  signed __int16 v6; // ax@1
  int v7; // ebp@2
  int v8; // ebx@2
  int v9; // ecx@2
  int v10; // ST28_4@4
  const char *v11; // eax@4
  unsigned int v12; // edx@5
  int v13; // ecx@5
  unsigned int v14; // ecx@6
  int v15; // edx@7
  int v16; // edi@7
  int v17; // edi@14
  int v18; // eax@14
  int v19; // ecx@15
  int (__cdecl *v20)(int, int); // ebx@17
  int v21; // ST28_4@22
  const char *v22; // eax@22
  int v23; // eax@4
  unsigned int v25; // [sp+10h] [bp-70h]@5
  char v26; // [sp+18h] [bp-68h]@4

  v6 = sub_1000D900(a1, a4);
  if ( v6 == -1
    || (v7 = (unsigned __int16)v6, v8 = 52 * (unsigned __int16)v6, v9 = v8 + *(_DWORD *)(a4 + 32), a2 > *(_WORD *)v9) )
  {
    if ( (signed int)(unsigned __int16)a1 >= *(_DWORD *)(a4 + 4) || v6 == -1 )
    {
      _snprintf(&v26, 0x64u, "pkt:%d lut_id:%d pipe:%d", (unsigned __int16)a1, (unsigned __int16)v6, *(_BYTE *)(a4 + 1));
      LOBYTE(v23) = sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2939, 0, &v26);
    }
    else
    {
      v21 = *(_BYTE *)(a4 + 1);
      v22 = sub_10010CB0(a4, v6);
      _snprintf(&v26, 0x64u, "%d-%s >max sz sz=%d pipe=%d", (unsigned __int16)a1, v22, a2, v21);
      LOBYTE(v23) = sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2953, 0, &v26);
    }
  }
  else if ( *(_BYTE *)(v9 + 8) == 1 )
  {
    v12 = sub_1004E4B0();
    v13 = *(_DWORD *)(a4 + 32) + v8;
    v25 = v12;
    if ( !*(_DWORD *)(v13 + 12)
      || (v14 = *(_DWORD *)(v13 + 16), v23 = *(_DWORD *)(a4 + 36), v12 <= a6 + v23 + v14)
      && ((v15 = *(_DWORD *)(a4 + 64) + 24 * v7, (v16 = *(_DWORD *)(v15 + 16)) == 0)
       || v25 > v23 + v16 + (v14 >> 1)
       || a3
       && (*(_BYTE *)(v15 + 1) != 1
        || (LOBYTE(v23) = *(_BYTE *)(*(_BYTE *)(a4 + 3) + v7 * *(_BYTE *)(a4 + 2) + *(_DWORD *)(a4 + 56)),
            (unsigned __int8)v23 <= *(_BYTE *)(v15 + 2)))
       || *(_BYTE *)(v15 + 1) != 1
       && (v23 = *(_DWORD *)(a4 + 56),
           *(_BYTE *)(*(_BYTE *)(a4 + 3) + v7 * *(_BYTE *)(a4 + 2) + v23) <= *(_BYTE *)(v15 + 2))) )
    {
      sub_1004E560(*(_DWORD *)(a4 + 60), -1);
      v17 = 24 * v7;
      *(_WORD *)(v17 + *(_DWORD *)(a4 + 64) + 4) = a2;
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 1) = a3;
      *(_DWORD *)(v17 + *(_DWORD *)(a4 + 64) + 16) = a6;
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 2) = *(_BYTE *)(*(_BYTE *)(a4 + 3)
                                                            + v7 * *(_BYTE *)(a4 + 2)
                                                            + *(_DWORD *)(a4 + 56));
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64)) = 0;
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 3) = 1;
      *(_DWORD *)(v17 + *(_DWORD *)(a4 + 64) + 20) = *(_DWORD *)(a4 + 72);
      v18 = *(_DWORD *)(a4 + 32) + v8;
      if ( (*(_DWORD *)(v18 + 32) >> 1) & 1 )
      {
        v19 = *(_DWORD *)(a4 + 64);
        if ( v25 < *(_DWORD *)(v17 + v19 + 8) )
          *(_DWORD *)(v17 + v19 + 8) -= *(_DWORD *)(v18 + 12);
      }
      memcpy(
        (void *)(*(_DWORD *)(a4 + 28) + *(_DWORD *)(*(_DWORD *)(a4 + 32) + v8 + 4)),
        a5,
        *(_WORD *)(v17 + *(_DWORD *)(a4 + 64) + 4));
      sub_1004E540(*(_DWORD *)(a4 + 60));
      v23 = *(_DWORD *)(a4 + 32);
      v20 = *(int (__cdecl **)(int, int))(v23 + v8 + 48);
      if ( v20 && !(*(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 6) & 8) )
        LOBYTE(v23) = v20(a1, a4);
    }
  }
  else
  {
    v10 = *(_BYTE *)(a4 + 1);
    v11 = sub_10010CB0(a4, v6);
    _snprintf(&v26, 0x64u, "%d-%s !var pipe=%d", (unsigned __int16)a1, v11, v10);
    LOBYTE(v23) = sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2802, 0, &v26);
  }
  return v23;
}

//----- (1000F010) --------------------------------------------------------
char __cdecl sub_1000F010(int a1, int a2, int a3)
{
  signed __int16 v3; // ax@1
  char result; // al@2
  int v5; // ecx@3
  int v6; // ebp@3
  int v7; // eax@3
  int v8; // edi@3
  int v9; // ebx@3
  int v10; // ST24_4@5
  const char *v11; // eax@5
  int v12; // eax@7
  int v13; // ebp@10
  void (__cdecl *v14)(int, int); // eax@10
  char v15; // cl@13
  int v16; // edx@13
  __int16 v17; // ax@13
  bool v18; // cf@13
  bool v19; // zf@13
  int v20; // ebx@17
  int v21; // eax@19
  char v22; // dl@19
  __int16 v23; // cx@19
  unsigned int v24; // eax@20
  int v25; // ecx@20
  int v26; // edi@21
  char v27; // [sp+6h] [bp-7Eh]@3
  char v28; // [sp+7h] [bp-7Dh]@17
  int v29; // [sp+8h] [bp-7Ch]@13
  int v30; // [sp+Ch] [bp-78h]@13
  char v31; // [sp+10h] [bp-74h]@13
  char v32; // [sp+11h] [bp-73h]@15
  __int16 v33; // [sp+12h] [bp-72h]@13
  int v34; // [sp+14h] [bp-70h]@1
  int v35; // [sp+18h] [bp-6Ch]@19
  char v36; // [sp+1Ch] [bp-68h]@5

  v3 = sub_1000D900(a1, a3);
  v34 = (unsigned __int16)v3;
  if ( v3 == -1 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD *)(a3 + 72);
    v6 = (unsigned __int16)v3;
    v7 = *(_DWORD *)(a3 + 32);
    v8 = 52 * v6;
    v9 = a2 & ~v5 & (*(_DWORD *)(v7 + 52 * v6 + 24) | 0xC00000);
    v27 = 1;
    if ( !*(_DWORD *)(52 * v6 + v7 + 12) || (*(_DWORD *)(*(_DWORD *)(a3 + 32) + v8 + 32) >> 6) & 1 )
    {
      if ( *(_BYTE *)(*(_DWORD *)(a3 + 24) + v6) != 1 )
        goto LABEL_26;
      v12 = v8 + *(_DWORD *)(a3 + 32);
      if ( !(v5 & *(_DWORD *)(v12 + 20)) || !(*(_BYTE *)(v12 + 28) & *(_BYTE *)a3) || !v9 )
        goto LABEL_26;
      v13 = 24 * v6;
      *(_DWORD *)(*(_DWORD *)(a3 + 64) + v13 + 12) = sub_1004E4B0();
      v14 = *(void (__cdecl **)(int, int))(*(_DWORD *)(a3 + 32) + v8 + 44);
      if ( v14 && !(*(_BYTE *)(*(_DWORD *)(a3 + 64) + v13 + 6) & 4) )
        v14(a1, a3);
      v15 = *(_BYTE *)(a3 + 1);
      v16 = *(_DWORD *)(a3 + 64);
      v30 = *(_DWORD *)(a3 + 16);
      v31 = v15;
      v29 = v9;
      v17 = *(_WORD *)(v16 + v13 + 4) + 20;
      v18 = (unsigned int)(unsigned __int16)v17 < *(_DWORD *)(a3 + 20);
      v19 = (unsigned __int16)v17 == *(_DWORD *)(a3 + 20);
      v33 = *(_WORD *)(v16 + v13 + 4) + 20;
      if ( !v18 && !v19 )
      {
        sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3198, 1, 0);
        v17 = v33;
      }
      v19 = *(_BYTE *)(a3 + 1) == 6;
      v32 = *(_BYTE *)(*(_DWORD *)(a3 + 32) + v8 + 32) & 1;
      if ( v19 || !(a2 & *(_DWORD *)(a3 + 84)) )
      {
        v28 = 1;
        v20 = *(_DWORD *)(a3 + 16) + 12;
      }
      else
      {
        v20 = *(_DWORD *)(a3 + 16);
        v28 = 0;
        v33 = v17 - 12;
      }
      sub_1004E560(*(_DWORD *)(a3 + 60), -1);
      v21 = *(_DWORD *)(a3 + 64) + v13;
      v22 = *(_BYTE *)(v21 + 1);
      LOWORD(v34) = a1;
      v23 = *(_WORD *)(v21 + 4);
      BYTE1(v35) = *(_BYTE *)(v21 + 2);
      HIWORD(v34) = v23;
      *(_DWORD *)v20 = v34;
      LOBYTE(v35) = v22;
      *(_DWORD *)(v20 + 4) = v35;
      memcpy(
        (void *)(v20 + 8),
        (const void *)(*(_DWORD *)(a3 + 28) + *(_DWORD *)(*(_DWORD *)(a3 + 32) + v8 + 4)),
        *(_WORD *)(*(_DWORD *)(a3 + 64) + v13 + 4));
      if ( v28 )
      {
        v24 = sub_1004E2C0(
                (unsigned int *)(*(_DWORD *)(a3 + 16) + 12),
                *(_WORD *)(*(_DWORD *)(a3 + 64) + v13 + 4) + 8,
                0xFFFFFFFF);
        v25 = *(_DWORD *)(a3 + 16);
        v34 = 327678;
        LOWORD(v35) = 1;
        *(_DWORD *)v25 = 327678;
        *(_DWORD *)(v25 + 4) = v35;
        *(_DWORD *)(v25 + 8) = v24;
      }
      v26 = j_HWM_pvg_hsdb_put(&v29);
      sub_1004E540(*(_DWORD *)(a3 + 60));
      if ( v26 < 0 )
LABEL_26:
        v27 = 0;
      result = v27;
    }
    else
    {
      v10 = *(_BYTE *)(a3 + 1);
      v11 = sub_10010CB0(a3, v34);
      _snprintf(&v36, 0x64u, "%d-%s is prdc pipe=%d", (unsigned __int16)a1, v11, v10);
      sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3123, 0, &v36);
      result = 0;
    }
  }
  return result;
}
// 1004ECC0: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);

//----- (1000F2D0) --------------------------------------------------------
char __cdecl sub_1000F2D0(int a1, int a2, void *a3, char a4, int a5)
{
  signed __int16 v5; // ax@1
  char result; // al@2
  int v7; // ebp@3
  int v8; // ebx@3
  int v9; // eax@3
  int v10; // ecx@3
  int v11; // edi@3
  int v12; // ST24_4@4
  const char *v13; // eax@4
  int v14; // eax@6
  int v15; // ebp@9
  char v16; // cl@9
  int v17; // edx@9
  __int16 v18; // ax@9
  bool v19; // cf@9
  bool v20; // zf@9
  int v21; // edi@13
  char v22; // bl@13
  int v23; // eax@15
  __int16 v24; // cx@15
  int v25; // ecx@15
  void *v26; // edx@15
  unsigned int v27; // eax@16
  int v28; // ecx@16
  int v29; // edi@17
  char v30; // [sp+7h] [bp-81h]@3
  int v31; // [sp+8h] [bp-80h]@9
  int v32; // [sp+Ch] [bp-7Ch]@9
  char v33; // [sp+10h] [bp-78h]@9
  char v34; // [sp+11h] [bp-77h]@11
  __int16 v35; // [sp+12h] [bp-76h]@9
  void *v36; // [sp+14h] [bp-74h]@1
  int v37; // [sp+18h] [bp-70h]@1
  int v38; // [sp+1Ch] [bp-6Ch]@15
  char v39; // [sp+20h] [bp-68h]@4

  v36 = a3;
  v5 = sub_1000D900(a1, a5);
  v37 = (unsigned __int16)v5;
  if ( v5 == -1 )
  {
    result = 0;
  }
  else
  {
    v7 = (unsigned __int16)v5;
    v8 = 52 * (unsigned __int16)v5;
    v9 = *(_DWORD *)(a5 + 32) + v8;
    v10 = *(_DWORD *)(a5 + 72);
    v11 = a2 & ~v10 & (*(_DWORD *)(v9 + 24) | 0xC00000);
    v30 = 0;
    if ( *(_DWORD *)(v9 + 12) )
    {
      v12 = *(_BYTE *)(a5 + 1);
      v13 = sub_10010CB0(a5, v37);
      _snprintf(&v39, 0x64u, "%d-%s is prdc pipe=%d", (unsigned __int16)a1, v13, v12);
      sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3486, 0, &v39);
      result = 0;
    }
    else
    {
      if ( *(_BYTE *)(*(_DWORD *)(a5 + 24) + v7) == 1
        && (v14 = v8 + *(_DWORD *)(a5 + 32), v10 & *(_DWORD *)(v14 + 20))
        && *(_BYTE *)(v14 + 28) & *(_BYTE *)a5
        && v11 )
      {
        v15 = 24 * v7;
        *(_DWORD *)(*(_DWORD *)(a5 + 64) + v15 + 12) = sub_1004E4B0();
        v16 = *(_BYTE *)(a5 + 1);
        v17 = *(_DWORD *)(a5 + 64);
        v32 = *(_DWORD *)(a5 + 16);
        v33 = v16;
        v31 = v11;
        v18 = *(_WORD *)(v17 + v15 + 4) + 20;
        v19 = (unsigned int)(unsigned __int16)v18 < *(_DWORD *)(a5 + 20);
        v20 = (unsigned __int16)v18 == *(_DWORD *)(a5 + 20);
        v35 = *(_WORD *)(v17 + v15 + 4) + 20;
        if ( !v19 && !v20 )
        {
          sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3535, 1, 0);
          v18 = v35;
        }
        v20 = *(_BYTE *)(a5 + 1) == 6;
        v34 = *(_BYTE *)(*(_DWORD *)(a5 + 32) + v8 + 32) & 1;
        if ( v20 || !(a2 & *(_DWORD *)(a5 + 84)) )
        {
          v22 = 1;
          v21 = *(_DWORD *)(a5 + 16) + 12;
        }
        else
        {
          v21 = *(_DWORD *)(a5 + 16);
          v22 = 0;
          v35 = v18 - 12;
        }
        sub_1004E560(*(_DWORD *)(a5 + 60), -1);
        v23 = *(_DWORD *)(a5 + 64) + v15;
        LOWORD(v37) = a1;
        v24 = *(_WORD *)(v23 + 4);
        LOBYTE(v23) = *(_BYTE *)(v23 + 2);
        HIWORD(v37) = v24;
        v25 = v37;
        LOBYTE(v38) = a4;
        BYTE1(v38) = v23;
        *(_DWORD *)(v21 + 4) = v38;
        v26 = v36;
        *(_DWORD *)v21 = v25;
        memcpy((void *)(v21 + 8), v26, *(_WORD *)(*(_DWORD *)(a5 + 64) + v15 + 4));
        if ( v22 )
        {
          v27 = sub_1004E2C0(
                  (unsigned int *)(*(_DWORD *)(a5 + 16) + 12),
                  *(_WORD *)(*(_DWORD *)(a5 + 64) + v15 + 4) + 8,
                  0xFFFFFFFF);
          v28 = *(_DWORD *)(a5 + 16);
          v37 = 327678;
          LOWORD(v38) = 1;
          *(_DWORD *)v28 = 327678;
          *(_DWORD *)(v28 + 4) = v38;
          *(_DWORD *)(v28 + 8) = v27;
        }
        v29 = j_HWM_pvg_hsdb_put(&v31);
        sub_1004E540(*(_DWORD *)(a5 + 60));
        if ( v29 >= 0 )
          v30 = 1;
      }
      else
      {
        v30 = 0;
      }
      result = v30;
    }
  }
  return result;
}
// 1004ECC0: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);

//----- (1000F560) --------------------------------------------------------
int __cdecl sub_1000F560(int a1)
{
  int result; // eax@1
  int v2; // edi@2
  int v3; // eax@2
  int v4; // ecx@2
  int v5; // edx@2
  int v6; // edx@3
  void (__cdecl *v7)(int, int); // eax@5
  int i; // [sp+4h] [bp-8h]@1
  unsigned int v9; // [sp+8h] [bp-4h]@1

  v9 = sub_1004E4B0();
  result = 0;
  for ( i = 0; i < *(_DWORD *)(a1 + 8); ++i )
  {
    v2 = *(_WORD *)(*(_DWORD *)(a1 + 68) + 2 * result);
    v3 = (unsigned __int16)sub_1000D900(v2, a1);
    v4 = 24 * (unsigned __int16)v3;
    v5 = v4 + *(_DWORD *)(a1 + 64);
    if ( !*(_BYTE *)v5 )
    {
      v6 = *(_DWORD *)(v5 + 16);
      if ( !v6 || v9 > v6 + *(_DWORD *)(a1 + 36) + *(_DWORD *)(52 * v3 + *(_DWORD *)(a1 + 32) + 16) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 64) + v4 + 1) = 0;
        *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64)) = 1;
        v7 = *(void (__cdecl **)(int, int))(52 * v3 + *(_DWORD *)(a1 + 32) + 40);
        if ( v7 )
        {
          if ( !(*(_BYTE *)(*(_DWORD *)(a1 + 64) + v4 + 6) & 2) )
            v7(v2, a1);
        }
      }
    }
    result = i + 1;
  }
  return result;
}

//----- (1000F620) --------------------------------------------------------
char __cdecl sub_1000F620(int a1, int a2, void *a3)
{
  return sub_1000DCD0(a1, a2, a3, 0xFFFFu);
}

//----- (1000F640) --------------------------------------------------------
char __cdecl sub_1000F640(int a1, int a2, void *a3, unsigned __int16 *a4)
{
  return sub_1000DF10(a1, a2, a3, a4, 0xFFFFu);
}

//----- (1000F670) --------------------------------------------------------
int __cdecl sub_1000F670(int a1)
{
  int v1; // esi@1
  int v2; // ecx@3
  signed __int16 v3; // ax@5
  int v4; // ebp@6
  int v5; // edi@6
  int v6; // ecx@6
  unsigned int v7; // edi@6
  int v8; // ST10_4@10
  int v10; // [sp+8h] [bp-8h]@1
  unsigned int v11; // [sp+Ch] [bp-4h]@4
  int v12; // [sp+14h] [bp+4h]@3

  v1 = a1;
  v10 = sub_1004E4B0();
  if ( *(_BYTE *)(a1 + 3) >= 4u )
    sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1321, 1, 0);
  sub_1004E560(*(_DWORD *)(a1 + 60), -1);
  v2 = 0;
  v12 = 0;
  if ( *(_DWORD *)(v1 + 4) > 0 )
  {
    v11 = 0;
    do
    {
      v3 = sub_1000D900(v2, v1);
      if ( v3 != -1 )
      {
        v4 = (unsigned __int16)v3;
        v5 = 52 * (unsigned __int16)v3;
        memset(
          (void *)(*(_DWORD *)(v1 + 28) + *(_DWORD *)(*(_DWORD *)(v1 + 32) + v5 + 4)),
          0,
          *(_WORD *)(*(_DWORD *)(v1 + 32) + v5));
        v6 = 24 * v4;
        *(_BYTE *)(v6 + *(_DWORD *)(v1 + 64)) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 1) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 2) = -1;
        *(_WORD *)(*(_DWORD *)(v1 + 64) + v6 + 4) = *(_WORD *)(v5 + *(_DWORD *)(v1 + 32));
        *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 16) = 0;
        *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 12) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 3) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 6) = 0;
        v7 = *(_DWORD *)(*(_DWORD *)(v1 + 32) + v5 + 12);
        if ( v7 )
          *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 8) = v10 + 25 * (v11 % (v7 / 0x19));
        else
          *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 8) = v10;
      }
      v2 = v12++ + 1;
      v11 = (unsigned __int16)v12;
    }
    while ( (signed int)(unsigned __int16)v12 < *(_DWORD *)(v1 + 4) );
  }
  v8 = *(_DWORD *)(v1 + 60);
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 0;
  sub_1004E540(v8);
  sub_1000E120(v1);
  return sub_1000E1D0(v1);
}

//----- (1000F7C0) --------------------------------------------------------
char __cdecl sub_1000F7C0(int a1, int a2)
{
  signed __int16 v2; // ax@1
  int v3; // edx@1
  int v4; // esi@2
  int v5; // edi@2
  int v6; // eax@2
  int v7; // edx@2

  v2 = sub_1000D900(a1, a2);
  if ( v2 == -1 )
  {
    LOBYTE(v6) = sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3035, 0, 0);
  }
  else
  {
    v4 = *(_DWORD *)(v3 + 28) + *(_DWORD *)(52 * (unsigned __int16)v2 + *(_DWORD *)(v3 + 32) + 4);
    v5 = *(_WORD *)v4;
    LOWORD(v6) = sub_1000D900(v5, v3);
    if ( (_WORD)v6 != -1 )
    {
      v6 = 3 * (unsigned __int16)v6;
      if ( *(_BYTE *)(*(_DWORD *)(v7 + 64) + 8 * v6 + 1) == 1 )
        LOBYTE(v6) = sub_1000F010(v5, *(_DWORD *)(v4 + 4), v7);
    }
  }
  return v6;
}

//----- (1000F840) --------------------------------------------------------
int sub_1000F840()
{
  int v1; // [sp+0h] [bp-4h]@1

  v1 = 0;
  sub_10019330((int)&v1);
  return sub_1001A0F0(v1);
}

//----- (1000F870) --------------------------------------------------------
char sub_1000F870()
{
  int v1; // [sp+0h] [bp-4h]@1

  v1 = 0;
  sub_10019330((int)&v1);
  sub_1001A0F0(v1);
  return sub_1000F8E0();
}

//----- (1000F8B0) --------------------------------------------------------
char __cdecl sub_1000F8B0(char a1, int a2, int a3, int a4, int a5)
{
  char result; // al@2

  if ( a1 == 1 )
  {
    sub_1000F860(a5);
    sub_1000F870();
    sub_10008470(7);
    result = 1;
  }
  else
  {
    sub_10008470(8);
    result = 0;
  }
  return result;
}
// 1000F860: using guessed type _DWORD __cdecl sub_1000F860(_DWORD);

//----- (1000F8E0) --------------------------------------------------------
char sub_1000F8E0()
{
  return sub_100116A0(0);
}

//----- (1000F8F0) --------------------------------------------------------
int __cdecl sub_1000F8F0(int a1, int a2, unsigned __int16 a3, char a4, char a5)
{
  unsigned __int16 v5; // di@1
  _WORD *v6; // edx@2
  int v7; // esi@2
  unsigned __int16 v8; // ax@3
  int v9; // eax@4

  v5 = 0;
  if ( a3 )
  {
    v6 = dword_1012DFF0;
    v7 = a1;
    do
    {
      v8 = *(_WORD *)(a2 + 2 * v5);
      if ( v8 >= 0x2E5u )
        break;
      LOWORD(v9) = v6[v8 + 120606];
      if ( (unsigned __int16)v9 < 0x256u )
      {
        v9 = (unsigned __int16)v9;
        if ( (a1 & (*(_DWORD *)&v6[26 * (unsigned __int16)v9 + 105068] | *(_DWORD *)&v6[26 * (unsigned __int16)v9
                                                                                      + 105070])) == a1
          || v7 & 0xC00000 )
        {
          sub_1002EB40(a4, (_BYTE *)v6 + v9, &byte_1012DFF8[v9], a5);
          v6 = dword_1012DFF0;
        }
      }
      ++v5;
    }
    while ( v5 < a3 );
  }
  sub_1000E120((int)&byte_10236500);
  return sub_1000E1D0((int)&byte_10236500);
}
// 10236500: using guessed type char byte_10236500;

//----- (1000F9A0) --------------------------------------------------------
char __cdecl sub_1000F9A0(int a1, int a2)
{
  int v2; // eax@1
  int v3; // esi@2
  int v4; // ebp@2
  unsigned __int16 v5; // di@2
  unsigned __int16 v6; // cx@3
  int v7; // edi@8
  unsigned __int16 v8; // di@9
  int v9; // eax@10
  int v11; // [sp+4h] [bp-530h]@2
  __int16 v12; // [sp+8h] [bp-52Ch]@9
  int v13; // [sp+Ch] [bp-528h]@10
  int v14; // [sp+10h] [bp-524h]@12

  LOWORD(v2) = sub_1000DCC0(a2, a1);
  if ( (_WORD)v2 != -1 )
  {
    v3 = *(_DWORD *)(a2 + 28) + *(_DWORD *)(52 * (unsigned __int16)v2 + *(_DWORD *)(a2 + 32) + 4);
    v4 = 24 * (unsigned __int16)v2;
    v5 = *(_WORD *)(*(_DWORD *)(a2 + 64) + v4 + 4);
    v2 = sub_1004FCD0(*(_BYTE *)v3);
    v11 = v2;
    if ( v5 > 4u )
    {
      v6 = *(_WORD *)(v3 + 2);
      if ( v6 <= 0x1F4u && 2 * (unsigned int)v6 <= (unsigned int)v5 - 4 && v2 != -1 )
      {
        if ( *(_BYTE *)v3 == 6 )
        {
          LOBYTE(v2) = sub_1000F8F0(*(_DWORD *)(*(_DWORD *)(a2 + 64) + v4 + 20), v3 + 4, v6, 1, 1);
        }
        else
        {
          v7 = sub_1001DC80((_DWORD *)(a2 + 1), 1u, (int)&unk_10080B5C, 1, 4, -1);
          v2 = sub_1001DC80((_DWORD *)v3, 1u, (int)&unk_10080B5C, 1, 4, 4);
          if ( v2 >= v7 )
          {
            LOBYTE(v2) = sub_1001B780("..\\lib\\adl\\iop_hsdb_pkt.c", 787, 0, 0);
          }
          else
          {
            v8 = 0;
            v12 = -32705;
            if ( *(_WORD *)(v3 + 2) )
            {
              do
              {
                v13 = *(_DWORD *)(*(_DWORD *)(a2 + 64) + v4 + 20);
                v9 = *(_WORD *)(v3 + 2) - v8;
                if ( v9 >= 100 )
                  LOWORD(v9) = 100;
                LOWORD(v14) = v9;
                memcpy((char *)&v14 + 2, (const void *)(v3 + 2 * v8 + 4), 2 * (unsigned __int16)v9);
                LOBYTE(v2) = sub_1004E5C0(v11, (int)&v12, 50000, 0);
                v8 += v14;
              }
              while ( v8 < *(_WORD *)(v3 + 2) );
            }
          }
        }
      }
    }
  }
  return v2;
}

//----- (1000FB40) --------------------------------------------------------
char sub_1000FB40()
{
  memset(byte_1012DFF8, 0, 0x2E5u);
  memset(dword_1012DFF0, 0, 0x256u);
  sub_1002ED20(6, 0x2E5u, (int)dword_1012DFF0, (int)byte_1012DFF8, (int)dword_1012DFF0 + 241212);
  sub_1002FF00(6, 0x2E5u, (int)dword_1012DFF0, (int)byte_1012DFF8, (int)dword_1012DFF0 + 241212);
  sub_1002F3D0(6, 0x2E5u, (int)dword_1012DFF0, (int)byte_1012DFF8, (int)dword_1012DFF0 + 241212);
  sub_1002FCF0(6, 0x2E5u, (int)dword_1012DFF0, (int)byte_1012DFF8, (int)dword_1012DFF0 + 241212);
  sub_1002F2A0(6, 0x2E5u, (int)dword_1012DFF0, (int)byte_1012DFF8, (int)dword_1012DFF0 + 241212);
  sub_1002F300(6, 0x2E5u, (int)dword_1012DFF0, (int)byte_1012DFF8, (int)dword_1012DFF0 + 241212);
  sub_10030120(6, 0x2E5u, (int)dword_1012DFF0, (int)byte_1012DFF8, (int)dword_1012DFF0 + 241212);
  sub_10030180(6, 0x2E5u, (int)dword_1012DFF0, (int)byte_1012DFF8, (int)dword_1012DFF0 + 241212);
  sub_1002FB80(6, 0x2E5u, (int)dword_1012DFF0, (int)byte_1012DFF8, (int)dword_1012DFF0 + 241212);
  sub_1002F350(6, 0x2E5u, (int)dword_1012DFF0, (int)byte_1012DFF8, (int)dword_1012DFF0 + 241212);
  return sub_1002FC60(6, 0x2E5u, (int)dword_1012DFF0, (int)byte_1012DFF8, (int)dword_1012DFF0 + 241212);
}

//----- (1000FCC0) --------------------------------------------------------
signed int sub_1000FCC0()
{
  char *v0; // edi@3
  void *v1; // ecx@4
  char *v2; // ecx@6
  unsigned int v3; // eax@6
  int v4; // edx@9
  signed int result; // eax@13
  int v6; // edi@14
  void **v7; // esi@14
  size_t v8; // eax@15

  if ( sub_1004F780((LONG)&off_10080B60) )
  {
    memcpy((char *)dword_1012DFF0 + 210116, &unk_10077BB8, 0x7978u);
    v0 = (char *)dword_1012DFF0 + 241212;
    qmemcpy((char *)dword_1012DFF0 + 241212, word_1007F530, 0x5C8u);
    *((_WORD *)v0 + 740) = word_1007F530[740];
  }
  else
  {
    sub_1001B780("..\\lib\\adl\\iop_hsdb_pkt.c", 1037, 1, 0);
  }
  if ( sub_10030210() == 1 && sub_1001A070(v1) == 4 )
  {
    v2 = (char *)dword_1012DFF0;
    v3 = 210184;
    do
    {
      if ( *(_DWORD *)&v2[v3 - 52] )
      {
        *(_DWORD *)&v2[v3 - 52] += 1500;
        v2 = (char *)dword_1012DFF0;
      }
      v4 = *(_DWORD *)&v2[v3];
      if ( v4 )
      {
        *(_DWORD *)&v2[v3] = v4 + 1500;
        v2 = (char *)dword_1012DFF0;
      }
      v3 += 104;
    }
    while ( v3 < 0x3AE80 );
  }
  sub_1004F310((int)&off_10080B60);
  if ( sub_1004F780((LONG)&off_10080B74) )
  {
    v6 = 0;
    v7 = (void **)off_1007FB00;
    do
    {
      v8 = sub_10020700(*v7, 0x29u);
      memcpy((void *)(v6 + dword_1012DFF4), *v7, v8);
      ++v7;
      v6 += 41;
    }
    while ( (signed int)v7 < (signed int)&unk_10080458 );
    result = sub_1004F310((int)&off_10080B74);
  }
  else
  {
    sub_1001B780("..\\lib\\adl\\iop_hsdb_pkt.c", 1087, 1, 0);
    result = sub_1004F310((int)&off_10080B74);
  }
  return result;
}
// 1007FB00: using guessed type char *off_1007FB00[598];
// 10080B60: using guessed type char *off_10080B60;
// 10080B74: using guessed type char *off_10080B74;
// 1012DFF4: using guessed type int dword_1012DFF4;

//----- (1000FE00) --------------------------------------------------------
int sub_1000FE00()
{
  sub_1000FB40();
  sub_1000E120((int)&byte_10236500);
  return sub_1000E1D0((int)&byte_10236500);
}
// 10236500: using guessed type char byte_10236500;

//----- (1000FE20) --------------------------------------------------------
int sub_1000FE20()
{
  void *v0; // ecx@1
  void *v1; // ecx@1
  char v2; // al@4
  void *v3; // ecx@4
  int result; // eax@8

  dword_1012DFF0 = (void *)-15;
  dword_1012DFF4 = -15;
  sub_1000FCC0();
  dword_10236518 = (int)dword_1012DFF0;
  dword_10236510 = (int)&unk_1022D700;
  dword_10236514 = 22568;
  dword_1023651C = (int)dword_1012DFF0 + 14952;
  dword_10236520 = (int)&unk_10077BB8;
  dword_10236524 = 12;
  dword_10236528 = (int)word_1007F530;
  byte_10236501 = 6;
  dword_10236504 = 741;
  dword_1023652C = (int)off_1007FB00;
  dword_10236530 = (int)&unk_10233400;
  dword_10236534 = 598;
  dword_10236538 = (int)&unk_10080458;
  byte_10236502 = 3;
  byte_10236503 = sub_1002EB80(v0);
  dword_10236550 = 0;
  dword_1023653C = 87;
  dword_10236540 = (int)dword_1012DFF0 + 600;
  dword_10236544 = (int)&unk_10232F40;
  dword_10236554 = 0;
  if ( sub_10030210() == 1 && sub_1001A070(v1) == 4 )
    dword_10236520 = (int)dword_1012DFF0 + 210116;
  v2 = sub_1001A070(v1);
  byte_10236500 = v2;
  if ( v2 == 8 )
  {
    byte_10236500 = 11;
  }
  else if ( v2 == 4 )
  {
    byte_10236500 = 5;
  }
  dword_10236548 = sub_1001B4A0(v3);
  dword_1023654C = (int)dword_1012DFF0 + 242694;
  sub_1000FB40();
  result = sub_1000F670((int)&byte_10236500);
  *((_DWORD *)dword_1012DFF0 + 60973) = dword_1023650C;
  return result;
}
// 1007FB00: using guessed type char *off_1007FB00[598];
// 1012DFF4: using guessed type int dword_1012DFF4;
// 10236500: using guessed type char byte_10236500;
// 10236501: using guessed type char byte_10236501;
// 10236502: using guessed type char byte_10236502;
// 10236503: using guessed type char byte_10236503;
// 10236504: using guessed type int dword_10236504;
// 1023650C: using guessed type int dword_1023650C;
// 10236510: using guessed type int dword_10236510;
// 10236514: using guessed type int dword_10236514;
// 10236518: using guessed type int dword_10236518;
// 1023651C: using guessed type int dword_1023651C;
// 10236520: using guessed type int dword_10236520;
// 10236524: using guessed type int dword_10236524;
// 10236528: using guessed type int dword_10236528;
// 1023652C: using guessed type int dword_1023652C;
// 10236530: using guessed type int dword_10236530;
// 10236534: using guessed type int dword_10236534;
// 10236538: using guessed type int dword_10236538;
// 1023653C: using guessed type int dword_1023653C;
// 10236540: using guessed type int dword_10236540;
// 10236544: using guessed type int dword_10236544;
// 10236548: using guessed type int dword_10236548;
// 1023654C: using guessed type int dword_1023654C;
// 10236550: using guessed type int dword_10236550;
// 10236554: using guessed type int dword_10236554;

//----- (1000FF80) --------------------------------------------------------
int __cdecl sub_1000FF80(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_100819DC[a1];
  return result;
}
// 100819DC: using guessed type __int16 word_100819DC[];

//----- (1000FFA0) --------------------------------------------------------
signed int sub_1000FFA0()
{
  signed int result; // eax@1

  result = -15;
  dword_1012E2FC = -15;
  dword_1012E308 = -15;
  dword_1012E2E4 = -15;
  dword_1012E30C = -15;
  dword_1012E2F8 = -15;
  dword_1012E2E8 = -15;
  dword_1012E2E0 = -15;
  dword_1012E2F4 = -15;
  dword_1012E304 = -15;
  dword_1012E300 = -15;
  dword_1012E2F0 = -15;
  dword_1012E2EC = -15;
  return result;
}
// 1012E2E0: using guessed type int dword_1012E2E0;
// 1012E2E4: using guessed type int dword_1012E2E4;
// 1012E2E8: using guessed type int dword_1012E2E8;
// 1012E2EC: using guessed type int dword_1012E2EC;
// 1012E2F0: using guessed type int dword_1012E2F0;
// 1012E2F4: using guessed type int dword_1012E2F4;
// 1012E2F8: using guessed type int dword_1012E2F8;
// 1012E2FC: using guessed type int dword_1012E2FC;
// 1012E300: using guessed type int dword_1012E300;
// 1012E304: using guessed type int dword_1012E304;
// 1012E308: using guessed type int dword_1012E308;
// 1012E30C: using guessed type int dword_1012E30C;

//----- (1000FFF0) --------------------------------------------------------
signed int __usercall sub_1000FFF0@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_1004F6B0((int)&off_100819FC);
      break;
    case 0:
      result = sub_1004F6B0((int)&off_10081A10);
      break;
    case 1:
      result = sub_1004F6B0((int)&off_10081A24);
      break;
    case 2:
      result = sub_1004F6B0((int)&off_10081A4C);
      break;
    case 3:
      result = sub_1004F6B0((int)&off_10081A38);
      break;
    case 5:
      result = sub_1004F6B0((int)&off_10081A60);
      break;
    default:
      result = sub_1004F6B0(a2);
      break;
  }
  return result;
}
// 100819FC: using guessed type char *off_100819FC;
// 10081A10: using guessed type char *off_10081A10;
// 10081A24: using guessed type char *off_10081A24;
// 10081A38: using guessed type char *off_10081A38;
// 10081A4C: using guessed type char *off_10081A4C;
// 10081A60: using guessed type char *off_10081A60;

//----- (10010090) --------------------------------------------------------
int __usercall sub_10010090@<eax>(char a1@<al>)
{
  return sub_1004E540(dword_1008152C[a1]);
}
// 1008152C: using guessed type int dword_1008152C[];

//----- (100100B0) --------------------------------------------------------
int __usercall sub_100100B0@<eax>(char a1@<al>)
{
  return sub_1004E560(dword_1008152C[a1], 10);
}
// 1008152C: using guessed type int dword_1008152C[];

//----- (100100D0) --------------------------------------------------------
signed __int16 __usercall sub_100100D0@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  signed __int16 result; // ax@3
  bool v3; // cf@4

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        result = *(_WORD *)(dword_10236528 + 2 * a2);
        v3 = (unsigned __int16)result < 0x256u;
        goto LABEL_30;
      }
      sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    case 0:
      if ( a2 < 0x344u )
      {
        if ( (unsigned __int8)sub_1000FFF0(a1, a1) )
        {
          result = *(_WORD *)(dword_1012E308 + 2 * a2 + 284664);
          v3 = (unsigned __int16)result < 0x211u;
          goto LABEL_30;
        }
        if ( !sub_10019F60(15000) )
          sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
        goto LABEL_10;
      }
      sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
      return -1;
    default:
      goto LABEL_10;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_1000FFF0(a1, a1) )
        goto LABEL_10;
      result = *(_WORD *)(dword_1012E2E4 + 2 * a2 + 447808);
      v3 = (unsigned __int16)result < 0x979u;
      goto LABEL_30;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_1000FFF0(a1, a1) )
        goto LABEL_10;
      result = *(_WORD *)(dword_1012E30C + 2 * a2 + 356016);
      v3 = (unsigned __int16)result < 0x23Du;
      goto LABEL_30;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_1000FFF0(a1, a1) )
      {
        sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_1012E2F8 + 2 * a2 + 23096);
      v3 = (unsigned __int16)result < 0x52u;
      goto LABEL_30;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_1000FFF0(a1, a1) )
        {
          result = *(_WORD *)(dword_1012E2E8 + 2 * a2 + 1804);
          v3 = (unsigned __int16)result < 4u;
LABEL_30:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_10:
          result = 0;
        }
      }
      else
      {
        sub_1001B780("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 1012E2E4: using guessed type int dword_1012E2E4;
// 1012E2E8: using guessed type int dword_1012E2E8;
// 1012E2F8: using guessed type int dword_1012E2F8;
// 1012E308: using guessed type int dword_1012E308;
// 1012E30C: using guessed type int dword_1012E30C;
// 10236528: using guessed type int dword_10236528;

//----- (100102E0) --------------------------------------------------------
char __cdecl sub_100102E0(char a1, unsigned __int16 a2, _BYTE *a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v6; // eax@8

  v3 = sub_100100D0(a1, a2);
  if ( v3 != -1 && !sub_100100B0(a1) )
  {
    switch ( a1 )
    {
      case 6:
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_10236518);
        sub_10010090(a1);
        return 1;
      case 0:
        if ( (unsigned __int8)sub_1000FFF0(a1, v4) != 1 )
          goto LABEL_16;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_1012E308);
        sub_10010090(a1);
        return 1;
      case 1:
        if ( (unsigned __int8)sub_1000FFF0(a1, v4) != 1 )
          goto LABEL_16;
        v6 = dword_1012E2E4;
        goto LABEL_15;
      case 2:
        if ( (unsigned __int8)sub_1000FFF0(a1, v4) != 1 )
          goto LABEL_16;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_1012E30C);
        sub_10010090(a1);
        return 1;
      case 3:
        if ( (unsigned __int8)sub_1000FFF0(a1, v4) != 1 )
          goto LABEL_16;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_1012E2F8);
        sub_10010090(a1);
        return 1;
      case 5:
        if ( (unsigned __int8)sub_1000FFF0(a1, v4) != 1 )
          goto LABEL_16;
        v6 = dword_1012E2E8;
LABEL_15:
        *a3 = *(_BYTE *)((unsigned __int16)v3 + v6);
        sub_10010090(a1);
        return 1;
      default:
LABEL_16:
        sub_10010090(a1);
        break;
    }
  }
  return 0;
}
// 1012E2E4: using guessed type int dword_1012E2E4;
// 1012E2E8: using guessed type int dword_1012E2E8;
// 1012E2F8: using guessed type int dword_1012E2F8;
// 1012E308: using guessed type int dword_1012E308;
// 1012E30C: using guessed type int dword_1012E30C;
// 10236518: using guessed type int dword_10236518;

//----- (10010430) --------------------------------------------------------
char __cdecl sub_10010430(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  signed __int16 v4; // si@1
  char result; // al@2

  v4 = sub_100100D0(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        qmemcpy(a3, (const void *)(dword_10236520 + 52 * (unsigned __int16)v4), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_1000FFF0(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1012E308 + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        if ( (unsigned __int8)sub_1000FFF0(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1012E2E4 + 321708), 0x34u);
        result = 1;
        break;
      case 2:
        result = sub_1000FFF0(a1, v3);
        if ( result != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1012E30C + 326220), 0x34u);
        break;
      case 3:
        if ( (unsigned __int8)sub_1000FFF0(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1012E2F8 + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        if ( (unsigned __int8)sub_1000FFF0(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1012E2E8 + 1596), 0x34u);
        result = 1;
        break;
      default:
LABEL_15:
        result = 0;
        break;
    }
  }
  return result;
}
// 1012E2E4: using guessed type int dword_1012E2E4;
// 1012E2E8: using guessed type int dword_1012E2E8;
// 1012E2F8: using guessed type int dword_1012E2F8;
// 1012E308: using guessed type int dword_1012E308;
// 1012E30C: using guessed type int dword_1012E30C;
// 10236520: using guessed type int dword_10236520;

//----- (100105A0) --------------------------------------------------------
char __cdecl sub_100105A0(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@4

  v3 = sub_100100D0(a1, a2);
  if ( v3 != -1 && !sub_100100B0(a1) )
  {
    switch ( a1 )
    {
      case 6:
        v5 = dword_10236540 + 24 * (unsigned __int16)v3;
        goto LABEL_15;
      case 0:
        if ( (unsigned __int8)sub_1000FFF0(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_1012E308 + 24 * (unsigned __int16)v3 + 532;
        goto LABEL_15;
      case 1:
        if ( (unsigned __int8)sub_1000FFF0(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_1012E2E4 + 24 * (unsigned __int16)v3 + 2428;
        goto LABEL_15;
      case 2:
        if ( (unsigned __int8)sub_1000FFF0(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_1012E30C + 24 * ((unsigned __int16)v3 + 24);
        goto LABEL_15;
      case 3:
        if ( (unsigned __int8)sub_1000FFF0(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_1012E2F8 + 24 * (unsigned __int16)v3 + 84;
        goto LABEL_15;
      case 5:
        if ( (unsigned __int8)sub_1000FFF0(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_1012E2E8 + 24 * (unsigned __int16)v3 + 4;
LABEL_15:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_10010090(a1);
        return 1;
      default:
LABEL_16:
        sub_10010090(a1);
        break;
    }
  }
  return 0;
}
// 1012E2E4: using guessed type int dword_1012E2E4;
// 1012E2E8: using guessed type int dword_1012E2E8;
// 1012E2F8: using guessed type int dword_1012E2F8;
// 1012E308: using guessed type int dword_1012E308;
// 1012E30C: using guessed type int dword_1012E30C;
// 10236540: using guessed type int dword_10236540;

//----- (100106F0) --------------------------------------------------------
char __cdecl sub_100106F0(int a1, int a2, void *a3, char a4, int a5, int a6)
{
  int v6; // ecx@0
  signed __int16 v7; // ax@1
  int v8; // ebp@2
  __int16 v9; // si@10
  int v11; // [sp-8h] [bp-570h]@16
  __int16 v12; // [sp+8h] [bp-560h]@12
  __int16 v13; // [sp+3Ch] [bp-52Ch]@9
  char v14; // [sp+40h] [bp-528h]@15
  char v15; // [sp+41h] [bp-527h]@9
  __int16 v16; // [sp+42h] [bp-526h]@9
  char v17; // [sp+44h] [bp-524h]@9
  __int16 v18; // [sp+46h] [bp-522h]@14
  int v19; // [sp+48h] [bp-520h]@15
  char v20; // [sp+4Ch] [bp-51Ch]@14

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 0:
      v8 = 29;
      goto LABEL_7;
    case 1:
      v8 = 30;
      goto LABEL_7;
    case 2:
      v8 = 31;
      goto LABEL_7;
    case 3:
      v8 = 32;
      goto LABEL_7;
    case 5:
      v8 = 33;
LABEL_7:
      LOBYTE(v7) = sub_1000FFF0(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_100100D0(a1, a2);
      if ( v7 == -1 )
        return v7;
      v15 = a6;
      LOBYTE(v7) = a4;
      v13 = -32768;
      v16 = a2;
      v17 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_10010430(a1, a2, &v12) != 1 )
          goto LABEL_15;
        v9 = v12;
      }
      memcpy(&v20, a3, (unsigned __int16)v9);
      v18 = v9;
LABEL_15:
      v19 = sub_1004E4B0();
      v14 = 0;
      LOBYTE(v7) = sub_10023950(v8, (int)&v13);
      return v7;
    default:
      return v7;
    case 6:
      v11 = sub_1004E4B0();
      if ( a4 == 1 )
        LOBYTE(v7) = sub_1000ED20(a2, a5, a6, (int)&byte_10236500, a3, v11);
      else
        LOBYTE(v7) = sub_1000EA10(a2, a6, (int)&byte_10236500, a3, v11);
      return v7;
  }
}
// 10236500: using guessed type char byte_10236500;

//----- (100108A0) --------------------------------------------------------
char __cdecl sub_100108A0(char a1, int a2, int a3)
{
  signed __int16 v3; // ax@1
  int v4; // edi@3
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      LOBYTE(v3) = sub_1000F010(a2, a3, (int)&byte_10236500);
      return v3;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_100100D0(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_10023950(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}
// 10236500: using guessed type char byte_10236500;

//----- (100109B0) --------------------------------------------------------
char __cdecl sub_100109B0(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  signed __int16 v8; // si@3
  int v9; // ebp@6
  int v10; // eax@6
  int v11; // esi@6
  int v12; // edi@6
  unsigned int v13; // ebx@6
  int v14; // eax@8
  int v15; // eax@10
  int v16; // eax@12
  int v17; // eax@14
  int v18; // eax@16
  int v19; // eax@24
  char v20; // [sp+7h] [bp-9h]@18
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_1004E4B0();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_100100D0(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          v9 = dword_1023651C;
          v10 = (unsigned __int16)v8;
          v11 = dword_10236520 + 52 * (unsigned __int16)v8;
          v12 = dword_10236540 + 24 * v10;
          v13 = 195164;
          goto LABEL_17;
        case 0:
          if ( !(unsigned __int8)sub_1000FFF0(a1, v7) )
            goto LABEL_29;
          v14 = 3 * (unsigned __int16)v8;
          v9 = dword_1012E308 + 13228;
          v11 = 52 * (unsigned __int16)v8 + dword_1012E308 + 257156;
          v12 = dword_1012E308 + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_17;
        case 1:
          if ( !(unsigned __int8)sub_1000FFF0(a1, v7) )
            goto LABEL_29;
          v15 = 3 * (unsigned __int16)v8;
          v9 = dword_1012E2E4 + 60628;
          v11 = 52 * (unsigned __int16)v8 + dword_1012E2E4 + 321708;
          v12 = dword_1012E2E4 + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_17;
        case 2:
          if ( !(unsigned __int8)sub_1000FFF0(a1, v7) )
            goto LABEL_29;
          v16 = 3 * (unsigned __int16)v8 + 72;
          v9 = dword_1012E30C + 14328;
          v11 = 52 * (unsigned __int16)v8 + dword_1012E30C + 326220;
          v12 = dword_1012E30C + 8 * v16;
          v13 = 311892;
          goto LABEL_17;
        case 3:
          if ( !(unsigned __int8)sub_1000FFF0(a1, v7) )
            goto LABEL_29;
          v17 = 3 * (unsigned __int16)v8;
          v9 = dword_1012E2F8 + 2052;
          v11 = 52 * (unsigned __int16)v8 + dword_1012E2F8 + 18832;
          v12 = dword_1012E2F8 + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_17;
        case 5:
          if ( !(unsigned __int8)sub_1000FFF0(a1, v7) )
            goto LABEL_29;
          v18 = 3 * (unsigned __int16)v8;
          v9 = dword_1012E2E8 + 100;
          v11 = 52 * (unsigned __int16)v8 + dword_1012E2E8 + 1596;
          v12 = dword_1012E2E8 + 8 * v18 + 4;
          v13 = 1496;
LABEL_17:
          if ( sub_100100B0(a1) )
            goto LABEL_29;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v9 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_32;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_32:
              v20 = 0;
            else
              memcpy(a5, (const void *)(v9 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_10010090(a1);
          result = v20;
          break;
        default:
LABEL_29:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1012E2E0: using guessed type int dword_1012E2E0;
// 1012E2E4: using guessed type int dword_1012E2E4;
// 1012E2E8: using guessed type int dword_1012E2E8;
// 1012E2F4: using guessed type int dword_1012E2F4;
// 1012E2F8: using guessed type int dword_1012E2F8;
// 1012E304: using guessed type int dword_1012E304;
// 1012E308: using guessed type int dword_1012E308;
// 1012E30C: using guessed type int dword_1012E30C;
// 1023651C: using guessed type int dword_1023651C;
// 10236520: using guessed type int dword_10236520;
// 10236540: using guessed type int dword_10236540;

//----- (10010C20) --------------------------------------------------------
char __cdecl sub_10010C20(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_100109B0(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (10010C50) --------------------------------------------------------
char __cdecl sub_10010C50(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_100109B0(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (10010C80) --------------------------------------------------------
char __cdecl sub_10010C80(char a1, int a2, void *a3, int a4)
{
  return sub_100109B0(a1, a2, 0, 0, a3, a4);
}

//----- (10010CB0) --------------------------------------------------------
const char *__cdecl sub_10010CB0(int a1, unsigned __int16 a2)
{
  int v2; // ecx@1
  const char *result; // eax@1

  v2 = *(_DWORD *)(a1 + 44);
  result = "UNKNOWN";
  if ( v2 )
  {
    if ( a2 <= *(_WORD *)(*(_DWORD *)(a1 + 40) + 2 * *(_DWORD *)(a1 + 4)) )
      result = *(const char **)(v2 + 4 * a2);
  }
  return result;
}

//----- (10010CE0) --------------------------------------------------------
char __cdecl sub_10010CE0(int a1, int a2)
{
  int v2; // ecx@0
  unsigned int v3; // eax@1
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v2;
  LOBYTE(v3) = sub_1000F620(a1, a2, &v5);
  if ( (_BYTE)v3 == 1 && v5 == 9 )
  {
    v3 = j_FIL_vfs_open("/mnt/sys_nand0/cmd_user_reset", 10, 1911);
    if ( v3 < 0xFFFFFFC2 )
    {
      if ( v3 )
      {
        sub_1004EF10(v3);
        LOBYTE(v3) = j_FIL_vfs_sync_all();
      }
    }
  }
  return v3;
}
// 1004F010: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1004F160: using guessed type int j_FIL_vfs_sync_all(void);

//----- (10010D30) --------------------------------------------------------
char __usercall sub_10010D30@<al>(__int16 a1@<bx>, int a2)
{
  bool v2; // zf@2
  int v3; // edx@2
  int v4; // ecx@2
  int v5; // edx@2
  int v6; // ecx@2
  int v7; // esi@3
  int v8; // ecx@3
  int v9; // edx@3
  int v10; // eax@3
  char v11; // ST08_1@5
  char v12; // al@5
  int v14; // [sp+8h] [bp-538h]@0
  _WORD *v15; // [sp+Ch] [bp-534h]@0
  __int16 v16; // [sp+10h] [bp-530h]@1
  int v17; // [sp+14h] [bp-52Ch]@2
  int v18; // [sp+18h] [bp-528h]@2
  int v19; // [sp+1Ch] [bp-524h]@2
  int v20; // [sp+20h] [bp-520h]@2
  int v21; // [sp+24h] [bp-51Ch]@2

  v16 = a1;
  if ( a1 == -32726 )
  {
    v2 = *(_BYTE *)a2 == 0;
    v3 = *(_DWORD *)(a2 + 4);
    v17 = *(_DWORD *)a2;
    v4 = *(_DWORD *)(a2 + 8);
    v18 = v3;
    v5 = *(_DWORD *)(a2 + 12);
    v19 = v4;
    v6 = *(_DWORD *)(a2 + 16);
    v20 = v5;
    v21 = v6;
    if ( v2 )
    {
      v7 = *(_DWORD *)(a2 + 4);
      v8 = *(_DWORD *)(a2 + 8);
      dword_1012E310 = *(_DWORD *)a2;
      v9 = *(_DWORD *)(a2 + 12);
      v10 = *(_DWORD *)(a2 + 16);
      dword_1012E314 = v7;
      dword_1012E318 = v8;
      dword_1012E31C = v9;
      dword_1012E320 = v10;
      word_1012E324 = v7;
    }
  }
  else
  {
    qmemcpy(&v17, (const void *)a2, 0x3F8u);
    v15 = (_WORD *)a2;
  }
  v11 = dword_1012E318;
  v12 = sub_10019900((void *)(unsigned __int8)dword_1012E318);
  LOBYTE(v14) = sub_1001FB70(v12, v11);
  if ( a1 == -32726 )
  {
    if ( (unsigned __int8)sub_1001DF30(dword_1012E318) <= 2u )
    {
      sub_10003310(v14, dword_1012E318, (int)&v16);
      return 1;
    }
  }
  else if ( a1 == -32725 && *v15 == word_1012E324 )
  {
    sub_10003310(v14, dword_1012E318, (int)&v16);
  }
  return 0;
}
// 1012E310: using guessed type int dword_1012E310;
// 1012E314: using guessed type int dword_1012E314;
// 1012E318: using guessed type int dword_1012E318;
// 1012E31C: using guessed type int dword_1012E31C;
// 1012E320: using guessed type int dword_1012E320;
// 1012E324: using guessed type __int16 word_1012E324;

//----- (10010E80) --------------------------------------------------------
char __cdecl sub_10010E80(int a1, int a2)
{
  char result; // al@1
  char v3; // [sp+0h] [bp-18h]@1
  char v4; // [sp+1h] [bp-17h]@2

  result = sub_1000F620(a1, a2, &v3);
  if ( result )
  {
    if ( v4 == 1 )
      result = sub_10010D30(-32726, (int)&v3);
  }
  return result;
}

//----- (10010EE0) --------------------------------------------------------
char __cdecl sub_10010EE0(int a1, int a2)
{
  char result; // al@1
  char v3; // [sp+0h] [bp-3FCh]@1

  result = sub_1000F620(a1, a2, &v3);
  if ( result )
    result = sub_10010D30(-32725, (int)&v3);
  return result;
}

//----- (10010F40) --------------------------------------------------------
char __cdecl sub_10010F40(int a1, int a2)
{
  int v2; // eax@2
  char v4; // [sp+8h] [bp-410h]@6
  int v5; // [sp+18h] [bp-400h]@7
  char v6; // [sp+1Ch] [bp-3FCh]@3
  int v7; // [sp+410h] [bp-8h]@4

  if ( (_WORD)a1 )
  {
    LOBYTE(v2) = a1 - 1;
    if ( (unsigned __int16)a1 == 1 )
    {
      LOBYTE(v2) = sub_1000F620(a1, a2, &v6);
      if ( (_BYTE)v2 )
      {
        v2 = sub_10012AB0();
        if ( v7 == v2 )
          LOBYTE(v2) = sub_10010EE0(a1, a2);
      }
    }
  }
  else
  {
    LOBYTE(v2) = sub_1000F620(a1, a2, &v4);
    if ( (_BYTE)v2 )
    {
      v2 = sub_10012AB0();
      if ( v5 == v2 )
        LOBYTE(v2) = sub_10010E80(a1, a2);
    }
  }
  return v2;
}

//----- (10010FE0) --------------------------------------------------------
int __cdecl sub_10010FE0(char a1, int a2)
{
  void *v2; // ecx@1
  void *v3; // ecx@1
  void *v4; // ecx@2
  int v5; // eax@3
  int v6; // ecx@16

  sub_1004E560(*(_DWORD *)(a2 + 60), -1);
  *(_BYTE *)a2 = sub_1001A070(v2) | 1;
  if ( a1 == 1 )
  {
    if ( sub_10030240(2048) )
      v5 = sub_1001B4A0(v4) | 0x300;
    else
      v5 = sub_1001B4A0(v4) | 0x83B00;
    *(_DWORD *)(a2 + 72) = v5;
    if ( !sub_10030240(0x10000) )
      *(_DWORD *)(a2 + 72) |= 0x110000u;
    if ( !sub_10030240(0x20000) )
      *(_DWORD *)(a2 + 72) |= 0x220000u;
    if ( !sub_10030240(1024) )
      *(_DWORD *)(a2 + 72) |= 0x400u;
    if ( !sub_10030240(0x1000000) )
      *(_DWORD *)(a2 + 72) |= 0x3000000u;
    if ( !sub_10030240(0x4000000) )
      *(_DWORD *)(a2 + 72) |= 0x4000000u;
    if ( !sub_10030240(0x8000000) )
    {
      v6 = *(_DWORD *)(a2 + 60);
      *(_DWORD *)(a2 + 72) |= 0x8000000u;
      sub_1004E540(v6);
      return sub_1000F670(a2);
    }
  }
  else
  {
    *(_DWORD *)(a2 + 72) = sub_1001B4A0(v3);
  }
  sub_1004E540(*(_DWORD *)(a2 + 60));
  return sub_1000F670(a2);
}

//----- (10011100) --------------------------------------------------------
char __cdecl sub_10011100(int a1, int a2)
{
  char v2; // bl@1
  int v3; // esi@1
  int *v4; // edx@2
  char result; // al@4
  int v6; // esi@9
  bool v7; // al@11
  bool v8; // al@16
  int v9; // esi@31
  bool v10; // al@33
  bool v11; // al@37
  bool v12; // al@41
  int v13; // esi@47
  char v14; // [sp+Bh] [bp-9h]@1
  unsigned int v15; // [sp+Ch] [bp-8h]@1
  int v16; // [sp+10h] [bp-4h]@29
  unsigned __int8 v17; // [sp+18h] [bp+4h]@8
  char v18; // [sp+18h] [bp+4h]@26

  v2 = sub_10019F60(10000);
  v3 = (unsigned __int16)a1 - 435;
  v14 = 0;
  v15 = 0;
  switch ( (unsigned __int16)a1 )
  {
    case 0x1B3u:
    case 0x1B4u:
    case 0x1C8u:
    case 0x1C9u:
      v4 = (int *)&v15;
      goto LABEL_4;
    case 0x1BBu:
    case 0x1BCu:
      v4 = (int *)&v14;
LABEL_4:
      result = sub_1000F620(a1, a2, v4);
      if ( result )
      {
        switch ( (unsigned __int16)a1 )
        {
          case 0x1B3u:
          case 0x1BBu:
          case 0x1C8u:
            result = 0;
            goto LABEL_8;
          case 0x1B4u:
          case 0x1BCu:
          case 0x1C9u:
            result = 1;
LABEL_8:
            v17 = result;
            switch ( v3 )
            {
              case 0:
              case 1:
                v6 = (unsigned __int8)result;
                sub_10011500((unsigned __int8)result, 0, (v15 >> 11) & 1);
                sub_100114D0(v6, 0, ~(unsigned __int8)(v15 >> 11) & 1);
                v7 = v15 & 0x400000 && v15 & 0x400;
                sub_10011500(v6, 1, v7);
                sub_100114D0(v6, 1, ~(unsigned __int8)(v15 >> 10) & 1);
                sub_10011500(v6, 2, BYTE3(v15) & 1);
                sub_100114D0(v6, 2, ~BYTE3(v15) & 1);
                sub_10011500(v6, 6, (v15 >> 18) & 1);
                sub_100114D0(v6, 6, ~(unsigned __int8)(v15 >> 18) & 1);
                v8 = !(v15 & 0x2000) && v15 & 0x800 && sub_10030280(v17);
                sub_10011500(v6, 8, v8);
                if ( !(v15 & 0x2000) && v15 & 0x800 && sub_10030280(v17) )
                  result = sub_100114D0(v6, 8, 0);
                else
                  result = sub_100114D0(v6, 8, 1);
                break;
              case 21:
              case 22:
                if ( !v2 )
                {
                  if ( v15 & 0x208000 )
                    v2 = 1;
                  v18 = 0;
                  if ( v15 & 0x410000 )
                    v18 = 1;
                  if ( !v2 || (LOBYTE(v16) = 1, !v18) )
                    LOBYTE(v16) = 0;
                  v9 = (unsigned __int8)result;
                  sub_10011500((unsigned __int8)result, 3, v16);
                  sub_100114D0(v9, 3, (_BYTE)v16 == 0);
                  v10 = v2 && !(_BYTE)v16;
                  sub_10011500(v9, 4, v10);
                  v11 = !v2 || (_BYTE)v16 == 1;
                  sub_100114D0(v9, 4, v11);
                  v12 = v18 && !(_BYTE)v16;
                  sub_10011500(v9, 5, v12);
                  if ( v18 && (_BYTE)v16 != 1 )
                    result = sub_100114D0(v9, 5, 0);
                  else
                    result = sub_100114D0(v9, 5, 1);
                }
                break;
              case 8:
              case 9:
                v13 = (unsigned __int8)result;
                sub_10011500((unsigned __int8)result, 7, v14 == 1);
                result = sub_100114D0(v13, 7, v14 == 0);
                break;
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 10:
              case 11:
              case 12:
              case 13:
              case 14:
              case 15:
              case 16:
              case 17:
              case 18:
              case 19:
              case 20:
                result = sub_1001B780("..\\lib\\acl\\iop\\iop_lcr100_frmt.c", 280, 1, 0);
                break;
              default:
                goto LABEL_50;
            }
            break;
          case 0x1B5u:
          case 0x1B6u:
          case 0x1B7u:
          case 0x1B8u:
          case 0x1B9u:
          case 0x1BAu:
          case 0x1BDu:
          case 0x1BEu:
          case 0x1BFu:
          case 0x1C0u:
          case 0x1C1u:
          case 0x1C2u:
          case 0x1C3u:
          case 0x1C4u:
          case 0x1C5u:
          case 0x1C6u:
          case 0x1C7u:
            result = sub_1001B780("..\\lib\\acl\\iop\\iop_lcr100_frmt.c", 184, 1, 0);
            break;
          default:
            goto LABEL_50;
        }
      }
      break;
    default:
LABEL_50:
      result = sub_1001B780("..\\lib\\acl\\iop\\iop_lcr100_frmt.c", 146, 1, 0);
      break;
  }
  return result;
}

//----- (100114D0) --------------------------------------------------------
int __cdecl sub_100114D0(int a1, int a2, char a3)
{
  int result; // eax@2

  if ( a3 )
    result = sub_1001BE10(word_10083338[a1 + 2 * a2]);
  return result;
}
// 10083338: using guessed type __int16 word_10083338[];

//----- (10011500) --------------------------------------------------------
char __cdecl sub_10011500(int a1, int a2, char a3)
{
  char result; // al@2

  if ( a3 )
    result = sub_1001BF40(word_10083338[a1 + 2 * a2]);
  return result;
}
// 10083338: using guessed type __int16 word_10083338[];

//----- (10011530) --------------------------------------------------------
char __cdecl sub_10011530(int a1)
{
  int v1; // eax@2
  char v3; // [sp+0h] [bp-1Ch]@2
  char v4; // [sp+8h] [bp-14h]@8

  switch ( a1 )
  {
    case 9936:
      v1 = sub_1004E7C0(9936, (int)&v3, 8);
      if ( !v1 && v3 == 1 )
      {
        dword_1012E328 = 6;
        v3 = 0;
        LOBYTE(v1) = sub_1004E8F0(9936, (int)&v3, 8);
      }
      break;
    case 9937:
      v1 = sub_1004E7C0(9937, (int)&v3, 8);
      if ( !v1 && v3 == 1 )
      {
        v3 = 0;
        dword_1012E32C = 6;
        LOBYTE(v1) = sub_1004E8F0(9937, (int)&v3, 8);
      }
      break;
    case 9938:
      v1 = sub_1004E7C0(9938, (int)&v4, 20);
      if ( !v1 && v4 == 1 )
      {
        dword_1012E334 = 6;
        v4 = 0;
        LOBYTE(v1) = sub_1004E8F0(9938, (int)&v4, 20);
      }
      break;
    case 9939:
      v1 = sub_1004E7C0(9939, (int)&v4, 20);
      if ( !v1 && v4 == 1 )
      {
        dword_1012E338 = 6;
        v4 = 0;
        LOBYTE(v1) = sub_1004E8F0(9939, (int)&v4, 20);
      }
      break;
    default:
      LOBYTE(v1) = sub_1001B780("..\\lib\\acl\\iop\\iop_lcr100_intf.c", 382, 1, 0);
      break;
  }
  return v1;
}
// 1012E328: using guessed type int dword_1012E328;
// 1012E32C: using guessed type int dword_1012E32C;
// 1012E334: using guessed type int dword_1012E334;
// 1012E338: using guessed type int dword_1012E338;

//----- (100116A0) --------------------------------------------------------
char __cdecl sub_100116A0(char a1)
{
  char result; // al@2
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 0;
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 == 1 )
      result = sub_10011710();
  }
  else
  {
    LOWORD(v2) = -32757;
    sub_10023A80((int)&v2);
    sub_10023A90((int)&v2);
    sub_10023AA0((int)&v2);
    sub_10023AC0((int)&v2);
    sub_10023AB0((int)&v2);
    result = sub_10023A70((int)&v2);
  }
  return result;
}

//----- (10011710) --------------------------------------------------------
int sub_10011710()
{
  return sub_1004E590(2, 0x80000);
}

//----- (10011720) --------------------------------------------------------
char __cdecl sub_10011720(_DWORD *a1)
{
  char result; // al@1

  result = 0;
  if ( dword_1012E480 != -15 )
  {
    *a1 = dword_1012E480;
    result = 1;
  }
  return result;
}
// 1012E480: using guessed type int dword_1012E480;

//----- (10011740) --------------------------------------------------------
void __cdecl sub_10011740(unsigned __int8 a1, char *a2)
{
  int v2; // eax@3
  int v3; // esi@4
  char *v4; // edi@4
  int v5; // ebp@4
  unsigned __int8 v6; // cl@5
  char v7; // bl@6
  int v8; // edx@6
  unsigned __int8 v9; // cl@7
  int v10; // edx@8
  bool v11; // cf@8

  if ( a1 && !sub_1004E560(97, 100) )
  {
    v2 = sub_1004E4B0() - 15000;
    if ( a1 )
    {
      v3 = dword_1012E480;
      v4 = a2;
      v5 = a1;
      do
      {
        v6 = *v4;
        if ( (unsigned __int8)*v4 < 0xB0u )
        {
          v7 = *(_BYTE *)(v3 + 4 * v6);
          v8 = v3 + 4 * v6;
          if ( v7 )
          {
            v9 = 0;
            if ( v7 )
            {
              do
              {
                *(_DWORD *)(136 * (v9 + *(_WORD *)(v8 + 2)) + v3 + 720) = v2;
                v10 = (unsigned __int8)*v4;
                v3 = dword_1012E480;
                v11 = ++v9 < *(_BYTE *)(dword_1012E480 + 4 * v10);
                v8 = dword_1012E480 + 4 * v10;
              }
              while ( v11 );
            }
          }
        }
        ++v4;
        --v5;
      }
      while ( v5 );
    }
    sub_1004E540(97);
  }
}
// 1012E480: using guessed type int dword_1012E480;

//----- (100117F0) --------------------------------------------------------
char __usercall sub_100117F0@<al>(__int16 *a1@<esi>, unsigned __int8 a2, __int16 a3, int a4, char a5, char a6)
{
  __int16 v6; // di@1
  bool v7; // zf@1
  char result; // al@2
  int v9; // ebp@3
  unsigned __int8 v10; // al@3
  int v11; // ecx@4
  __int16 v12; // ax@5
  signed int v13; // eax@5
  unsigned __int16 v14; // di@10
  unsigned __int16 v15; // dx@13
  unsigned __int16 v16; // dx@16
  void *v17; // eax@19
  unsigned __int16 v18; // dx@20
  unsigned __int16 v19; // dx@23
  unsigned __int16 v20; // dx@26
  unsigned __int16 v21; // dx@29
  int v22; // eax@35
  __int16 v23; // di@35

  v6 = word_1012E3D8;
  v7 = word_1012E3D8 == 120;
  *a1 = 0;
  if ( v7 )
  {
    result = 0;
  }
  else
  {
    v9 = 4 * a2;
    v10 = *(_BYTE *)(dword_1012E480 + v9);
    if ( v10 )
    {
      v12 = v10 + *(_WORD *)(dword_1012E480 + v9 + 2);
      *a1 = v12;
      memcpy_0(
        (void *)(dword_1012E480 + 136 * (unsigned __int16)v12 + 840),
        (const void *)(dword_1012E480 + 136 * (unsigned __int16)v12 + 704),
        136 * ((unsigned __int16)v6 - (unsigned __int16)v12));
      v11 = dword_1012E480;
      v13 = 0;
      do
      {
        if ( *(_BYTE *)(v13 + v11) && (unsigned __int16)*a1 <= *(_WORD *)(v13 + v11 + 2) )
        {
          ++*(_WORD *)(v13 + v11 + 2);
          v11 = dword_1012E480;
        }
        if ( *(_BYTE *)(v13 + v11 + 4) )
        {
          v14 = *(_WORD *)(v13 + v11 + 6);
          if ( (unsigned __int16)*a1 <= v14 )
          {
            *(_WORD *)(v13 + v11 + 6) = v14 + 1;
            v11 = dword_1012E480;
          }
        }
        if ( *(_BYTE *)(v13 + v11 + 8) )
        {
          v15 = *(_WORD *)(v13 + v11 + 10);
          if ( (unsigned __int16)*a1 <= v15 )
          {
            *(_WORD *)(v13 + v11 + 10) = v15 + 1;
            v11 = dword_1012E480;
          }
        }
        if ( *(_BYTE *)(v13 + v11 + 12) )
        {
          v16 = *(_WORD *)(v13 + v11 + 14);
          if ( (unsigned __int16)*a1 <= v16 )
          {
            *(_WORD *)(v13 + v11 + 14) = v16 + 1;
            v11 = dword_1012E480;
          }
        }
        v13 += 16;
      }
      while ( v13 < 704 );
      v17 = &unk_1012E342;
      do
      {
        v18 = *((_WORD *)v17 - 1);
        if ( v18 != 255 && (unsigned __int16)*a1 <= v18 )
          *((_WORD *)v17 - 1) = v18 + 1;
        v19 = *(_WORD *)v17;
        if ( *(_WORD *)v17 != 255 && (unsigned __int16)*a1 <= v19 )
          *(_WORD *)v17 = v19 + 1;
        v20 = *((_WORD *)v17 + 1);
        if ( v20 != 255 && (unsigned __int16)*a1 <= v20 )
          *((_WORD *)v17 + 1) = v20 + 1;
        v21 = *((_WORD *)v17 + 2);
        if ( v21 != 255 && (unsigned __int16)*a1 <= v21 )
          *((_WORD *)v17 + 2) = v21 + 1;
        v17 = (char *)v17 + 8;
      }
      while ( (signed int)v17 < (signed int)&unk_1012E3DA );
      v6 = word_1012E3D8;
    }
    else
    {
      *a1 = v6;
      *(_WORD *)(dword_1012E480 + v9 + 2) = v6;
      v11 = dword_1012E480;
    }
    ++*(_BYTE *)(v11 + v9);
    *(_BYTE *)(136 * (unsigned __int16)*a1 + dword_1012E480 + 705) = 0;
    *(_DWORD *)(136 * (unsigned __int16)*a1 + dword_1012E480 + 716) = a4;
    *(_WORD *)(136 * (unsigned __int16)*a1 + dword_1012E480 + 710) = a3;
    *(_BYTE *)(136 * (unsigned __int16)*a1 + dword_1012E480 + 704) = a5;
    memset((void *)(136 * (unsigned __int16)*a1 + dword_1012E480 + 724), 0, 0x74u);
    if ( a6 )
    {
      v22 = sub_1004E4B0();
      v23 = word_1012E3D8 + 1;
      *(_DWORD *)(136 * (unsigned __int16)*a1 + dword_1012E480 + 720) = v22;
      word_1012E3D8 = v23;
      result = 1;
    }
    else
    {
      *(_DWORD *)(136 * (unsigned __int16)*a1 + dword_1012E480 + 720) = 0;
      word_1012E3D8 = v6 + 1;
      result = 1;
    }
  }
  return result;
}
// 1012E3D8: using guessed type __int16 word_1012E3D8;
// 1012E480: using guessed type int dword_1012E480;

//----- (10011A70) --------------------------------------------------------
BOOL __usercall sub_10011A70@<eax>(unsigned __int16 a1@<ax>, unsigned __int8 a2)
{
  return a1 != -1 && a1 < 0x4Cu && a2 < 0xB0u;
}

//----- (10011A90) --------------------------------------------------------
char __usercall sub_10011A90@<al>(unsigned __int8 a1@<al>, _WORD *a2@<edx>, __int16 a3@<di>)
{
  int v3; // eax@1
  int v4; // ecx@2
  char result; // al@5

  v3 = 4 * a1;
  if ( *(_BYTE *)(v3 + dword_1012E480)
    && (*a2 = *(_WORD *)(v3 + dword_1012E480 + 2),
        v4 = dword_1012E480,
        *a2 < *(_BYTE *)(v3 + dword_1012E480) + *(_WORD *)(v3 + dword_1012E480 + 2)) )
  {
    while ( *(_WORD *)(136 * *a2 + v4 + 710) != a3 )
    {
      ++*a2;
      v4 = dword_1012E480;
      if ( *a2 >= *(_BYTE *)(v3 + dword_1012E480) + *(_WORD *)(v3 + dword_1012E480 + 2) )
        goto LABEL_5;
    }
    result = 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}
// 1012E480: using guessed type int dword_1012E480;

//----- (10011B10) --------------------------------------------------------
signed int sub_10011B10()
{
  if ( !sub_1004F780((LONG)&off_10083564) )
    sub_1001B780("..\\lib\\acl\\iop\\iop_rgn_data.c", 921, 1, 0);
  return sub_1004F310((int)&off_10083564);
}
// 10083564: using guessed type char *off_10083564;

//----- (10011B50) --------------------------------------------------------
void __cdecl sub_10011B50(unsigned __int16 a1)
{
  int v1; // eax@2
  signed int v2; // ecx@2
  unsigned __int8 v3; // bl@3
  unsigned __int16 v4; // si@4
  unsigned __int8 v5; // dl@9
  unsigned __int16 v6; // si@10
  unsigned __int8 v7; // dl@15
  unsigned __int16 v8; // si@16
  unsigned __int8 v9; // dl@21
  unsigned __int16 v10; // si@22
  int v11; // edx@28
  int v12; // eax@28
  void *v13; // eax@30
  unsigned __int16 v14; // cx@31
  unsigned __int16 v15; // cx@34
  unsigned __int16 v16; // cx@37
  unsigned __int16 v17; // cx@40

  if ( a1 >= 0x78u )
    return;
  v1 = dword_1012E480;
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + v1);
    if ( !v3 )
      goto LABEL_9;
    v4 = *(_WORD *)(v2 + v1 + 2);
    if ( a1 >= v4 )
    {
      if ( a1 >= v3 + v4 )
        goto LABEL_9;
      --*(_BYTE *)(v2 + v1);
    }
    else
    {
      --*(_WORD *)(v2 + v1 + 2);
    }
    v1 = dword_1012E480;
LABEL_9:
    v5 = *(_BYTE *)(v2 + v1 + 4);
    if ( !v5 )
      goto LABEL_15;
    v6 = *(_WORD *)(v2 + v1 + 6);
    if ( a1 >= v6 )
    {
      if ( a1 >= v5 + v6 )
        goto LABEL_15;
      *(_BYTE *)(v2 + v1 + 4) = v5 - 1;
    }
    else
    {
      *(_WORD *)(v2 + v1 + 6) = v6 - 1;
    }
    v1 = dword_1012E480;
LABEL_15:
    v7 = *(_BYTE *)(v2 + v1 + 8);
    if ( !v7 )
      goto LABEL_21;
    v8 = *(_WORD *)(v2 + v1 + 10);
    if ( a1 >= v8 )
    {
      if ( a1 >= v8 + v7 )
        goto LABEL_21;
      *(_BYTE *)(v2 + v1 + 8) = v7 - 1;
    }
    else
    {
      *(_WORD *)(v2 + v1 + 10) = v8 - 1;
    }
    v1 = dword_1012E480;
LABEL_21:
    v9 = *(_BYTE *)(v2 + v1 + 12);
    if ( !v9 )
      goto LABEL_27;
    v10 = *(_WORD *)(v2 + v1 + 14);
    if ( a1 >= v10 )
    {
      if ( a1 >= v10 + v9 )
        goto LABEL_27;
      *(_BYTE *)(v2 + v1 + 12) = v9 - 1;
    }
    else
    {
      *(_WORD *)(v2 + v1 + 14) = v10 - 1;
    }
    v1 = dword_1012E480;
LABEL_27:
    v2 += 16;
  }
  while ( v2 < 704 );
  v11 = 136 * a1 + v1;
  v12 = *(_WORD *)(v11 + 710);
  if ( word_1012E340[v12] == a1 )
    word_1012E340[v12] = 255;
  v13 = &unk_1012E342;
  do
  {
    v14 = *((_WORD *)v13 - 1);
    if ( v14 != 255 && a1 < v14 )
      *((_WORD *)v13 - 1) = v14 - 1;
    v15 = *(_WORD *)v13;
    if ( *(_WORD *)v13 != 255 && a1 < v15 )
      *(_WORD *)v13 = v15 - 1;
    v16 = *((_WORD *)v13 + 1);
    if ( v16 != 255 && a1 < v16 )
      *((_WORD *)v13 + 1) = v16 - 1;
    v17 = *((_WORD *)v13 + 2);
    if ( v17 != 255 && a1 < v17 )
      *((_WORD *)v13 + 2) = v17 - 1;
    v13 = (char *)v13 + 8;
  }
  while ( (signed int)v13 < (signed int)&unk_1012E3DA );
  memcpy_0((void *)(v11 + 704), (const void *)(v11 + 840), 136 * ((unsigned __int16)word_1012E3D8 - a1 - 1));
  --word_1012E3D8;
}
// 1012E340: using guessed type __int16 word_1012E340[];
// 1012E3D8: using guessed type __int16 word_1012E3D8;
// 1012E480: using guessed type int dword_1012E480;

//----- (10011D30) --------------------------------------------------------
unsigned int __usercall sub_10011D30@<eax>(__int16 a1@<dx>, int a2@<ecx>, char a3@<bl>, unsigned __int16 a4)
{
  unsigned int result; // eax@2

  if ( a4 >= 0x64u )
  {
    result = 8 * (unsigned __int16)(a4 - 100);
    dword_1012E3E4[result / 4] = a2;
    word_1012E3E2[result / 2] = a1;
    byte_1012E3E0[result] = a3;
  }
  else
  {
    result = 8 * a4;
    dword_1012E494[result / 4] = a2;
    word_1012E492[result / 2] = a1;
    byte_1012E490[result] = a3;
  }
  return result;
}
// 1012E3E2: using guessed type __int16 word_1012E3E2[];
// 1012E3E4: using guessed type int dword_1012E3E4[];
// 1012E492: using guessed type __int16 word_1012E492[];
// 1012E494: using guessed type int dword_1012E494[];

//----- (10011D80) --------------------------------------------------------
char __usercall sub_10011D80@<al>(int a1@<ebx>, unsigned __int16 a2, unsigned __int8 a3, int a4, char a5, char a6)
{
  int v6; // ebp@1
  void *v7; // ecx@1
  int v8; // eax@2
  int v9; // eax@4
  int v10; // esi@15
  void *v11; // ecx@18
  unsigned __int16 v13; // [sp+Ch] [bp-4h]@1

  v6 = 136 * a2;
  v13 = *(_WORD *)(dword_1012E480 + v6 + 710);
  qmemcpy((void *)(dword_1012E480 + v6 + 724), (const void *)a4, 0x74u);
  v7 = 0;
  *(_DWORD *)(dword_1012E480 + v6 + 712) = a1;
  *(_BYTE *)(dword_1012E480 + v6 + 706) = 0;
  if ( a6 )
  {
    v8 = sub_1004E4B0();
    v7 = (void *)dword_1012E480;
    *(_DWORD *)(dword_1012E480 + v6 + 720) = v8;
  }
  else
  {
    *(_DWORD *)(dword_1012E480 + v6 + 720) = 0;
  }
  LOBYTE(v9) = dword_1012E480;
  LOBYTE(v7) = 1;
  if ( a5 & 1 )
  {
    if ( *(_DWORD *)(dword_1012E480 + v6 + 716) == a1 )
    {
      *(_BYTE *)(dword_1012E480 + v6 + 705) = 3;
    }
    else
    {
      *(_BYTE *)(dword_1012E480 + v6 + 705) = 2;
      *(_BYTE *)(dword_1012E480 + v6 + 706) = 1;
      LOBYTE(v9) = sub_10019060(v7);
      if ( (_BYTE)v9 )
        LOBYTE(v9) = sub_10012730(a3);
    }
  }
  else
  {
    *(_BYTE *)(dword_1012E480 + v6 + 705) = 1;
  }
  if ( a5 & 2 && *(_BYTE *)(dword_1012E480 + v6 + 705) != 2 )
  {
    LOWORD(v9) = word_1012E340[v13];
    if ( (_WORD)v9 == 255 )
    {
      word_1012E340[v13] = a2;
    }
    else if ( (_WORD)v9 != a2 )
    {
      v10 = 136 * (unsigned __int16)v9 + dword_1012E480;
      if ( *(_DWORD *)(v10 + 712) != a1
        || strcmp((const char *)(v10 + 724), (const char *)a4)
        || (v9 = strcmp((const char *)(v10 + 740), (const char *)(a4 + 16))) != 0 )
      {
        *(_BYTE *)(dword_1012E480 + v6 + 705) = 2;
        v11 = (void *)dword_1012E480;
        *(_BYTE *)(dword_1012E480 + v6 + 706) = 2;
        LOBYTE(v9) = sub_10019060(v11);
        if ( (_BYTE)v9 )
          LOBYTE(v9) = sub_10012760(a3);
      }
    }
  }
  return v9;
}
// 1012E340: using guessed type __int16 word_1012E340[];
// 1012E480: using guessed type int dword_1012E480;

//----- (10011F60) --------------------------------------------------------
char sub_10011F60()
{
  int v0; // ecx@1
  unsigned __int8 v1; // bl@2
  __int16 v2; // dx@2
  int v3; // ecx@2
  bool v4; // sf@3
  unsigned __int8 v5; // of@3
  int v6; // ecx@4
  unsigned __int8 v7; // bl@5
  char result; // al@5
  __int16 v9; // dx@5
  int v10; // ecx@5
  int v11; // [sp+4h] [bp-4h]@1

  dword_1012E480 = -15;
  word_1012E3D8 = 0;
  dword_1012E488 = 0;
  sub_10011B10();
  memset32(word_1012E340, 16711935, 0x26u);
  v11 = 76;
  sub_1004E7C0(6456, (int)byte_1012E490, 800);
  v0 = 0;
  dword_1012E484 = 0;
  do
  {
    v1 = byte_1012E490[8 * v0];
    if ( !(unsigned __int8)sub_10011A70(word_1012E492[4 * v0], byte_1012E490[8 * v0]) )
      break;
    sub_100117F0((__int16 *)&v11, v1, v2, dword_1012E494[2 * v3], v3, 1);
    v0 = dword_1012E484 + 1;
    v5 = __OFSUB__(dword_1012E484 + 1, 100);
    v4 = dword_1012E484++ - 99 < 0;
  }
  while ( v4 ^ v5 );
  sub_1004E7C0(6899, (int)byte_1012E3E0, 160);
  v6 = 0;
  dword_1012E3DC = 0;
  do
  {
    v7 = byte_1012E3E0[8 * v6];
    result = sub_10011A70(word_1012E3E2[4 * v6], byte_1012E3E0[8 * v6]);
    if ( !result )
      break;
    result = sub_100117F0((__int16 *)&v11, v7, v9, dword_1012E3E4[2 * v10], v10 + 100, 1);
    v6 = dword_1012E3DC + 1;
    v5 = __OFSUB__(dword_1012E3DC + 1, 20);
    v4 = dword_1012E3DC++ - 19 < 0;
  }
  while ( v4 ^ v5 );
  return result;
}
// 1012E340: using guessed type __int16 word_1012E340[];
// 1012E3D8: using guessed type __int16 word_1012E3D8;
// 1012E3DC: using guessed type int dword_1012E3DC;
// 1012E3E2: using guessed type __int16 word_1012E3E2[];
// 1012E3E4: using guessed type int dword_1012E3E4[];
// 1012E480: using guessed type int dword_1012E480;
// 1012E484: using guessed type int dword_1012E484;
// 1012E488: using guessed type int dword_1012E488;
// 1012E492: using guessed type __int16 word_1012E492[];
// 1012E494: using guessed type int dword_1012E494[];

//----- (10012090) --------------------------------------------------------
char __usercall sub_10012090@<al>(__int16 a1@<ax>, unsigned __int8 a2@<cl>, int a3, int a4, char a5, char a6)
{
  unsigned __int8 v6; // bl@1
  char result; // al@1
  int v8; // [sp+Ch] [bp-4h]@1

  v6 = a2;
  v8 = 0;
  result = sub_100117F0((__int16 *)&v8, a2, a1, 0, -1, a6);
  if ( result )
    result = sub_10011D80(a4, v8, v6, a3, a5, a6);
  return result;
}

//----- (100120E0) --------------------------------------------------------
char __usercall sub_100120E0@<al>(unsigned __int16 a1@<di>)
{
  int v1; // esi@1
  char result; // al@2

  v1 = 136 * a1;
  *(_BYTE *)(v1 + dword_1012E480 + 705) = 0;
  *(_DWORD *)(v1 + dword_1012E480 + 720) = 0;
  memset((void *)(v1 + dword_1012E480 + 724), 0, 0x74u);
  if ( *(_BYTE *)(v1 + dword_1012E480 + 704) == -1 )
  {
    sub_10011B50(a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1012E480: using guessed type int dword_1012E480;

//----- (10012140) --------------------------------------------------------
unsigned __int8 __usercall sub_10012140@<al>(char a1@<bl>, __int16 a2@<si>, int a3)
{
  unsigned __int8 v3; // al@2
  unsigned __int8 v5; // [sp+1h] [bp-1h]@2

  if ( sub_1004EE60(a2) == 2 )
  {
    v3 = dword_1012E3DC + 100;
    v5 = dword_1012E3DC++ + 100;
  }
  else
  {
    v5 = dword_1012E484++;
    v3 = v5;
  }
  sub_10011D30(a2, a3, a1, v3);
  return v5;
}
// 1012E3DC: using guessed type int dword_1012E3DC;
// 1012E484: using guessed type int dword_1012E484;

//----- (100121A0) --------------------------------------------------------
char __cdecl sub_100121A0(_BYTE *a1, unsigned __int16 a2, char a3)
{
  _BYTE *v3; // ebx@2
  unsigned int v4; // ebp@5
  int *v5; // esi@6
  __int16 v6; // di@7
  unsigned __int8 v7; // cl@7
  char result; // al@12

  if ( a2 <= 4u || (v3 = a1, *a1 > 0xAu) || 124 * *a1 != a2 - 4 || sub_1004E560(97, 100) )
  {
    result = sub_1001B780("..\\lib\\acl\\iop\\iop_rgn_data.c", 441, 0, 0);
  }
  else
  {
    v4 = 0;
    if ( *a1 )
    {
      v5 = (int *)(a1 + 8);
      do
      {
        v6 = *((_WORD *)v5 - 1);
        if ( (unsigned __int8)sub_10011A70(*((_WORD *)v5 - 1), *((_BYTE *)v5 - 3)) )
        {
          if ( sub_10011A90(v7, &a2, v6) )
          {
            sub_10011D80(*v5, a2, *((_BYTE *)v5 - 3), (int)(v5 + 1), *((_BYTE *)v5 - 4), a3);
            v3 = a1;
          }
          else
          {
            sub_10012090(v6, *((_BYTE *)v5 - 3), (int)(v5 + 1), *v5, *((_BYTE *)v5 - 4), a3);
          }
        }
        ++v4;
        v5 += 31;
      }
      while ( v4 < *v3 );
    }
    result = sub_1004E540(97);
  }
  return result;
}

//----- (100122A0) --------------------------------------------------------
int __cdecl sub_100122A0(char a1, __int16 a2, int a3)
{
  int result; // eax@1
  int v4; // ebp@5
  unsigned __int8 v5; // al@5
  unsigned __int16 v6; // [sp+8h] [bp-8h]@3
  int v7; // [sp+Ch] [bp-4h]@4

  result = sub_10011A70(a2, a1);
  if ( (_BYTE)result )
  {
    result = sub_1004E560(97, 100);
    if ( !result )
    {
      if ( sub_10011A90(a1, &v6, a2) )
      {
        v4 = 136 * v6;
        *(_DWORD *)(dword_1012E480 + v4 + 716) = a3;
        *(_BYTE *)(dword_1012E480 + v4 + 705) = 0;
        v5 = *(_BYTE *)(dword_1012E480 + v4 + 704);
        if ( v5 == -1 )
          *(_BYTE *)(dword_1012E480 + v4 + 704) = sub_10012140(a1, a2, a3);
        else
          sub_10011D30(a2, a3, a1, v5);
      }
      else
      {
        LOBYTE(v7) = sub_10012140(a1, a2, a3);
        sub_100117F0((__int16 *)&v6, a1, a2, a3, v7, 1);
      }
      sub_1004E8F0(6456, (int)byte_1012E490, 800);
      sub_1004E910(6899, (int)byte_1012E3E0, 160);
      result = sub_1004E540(97);
    }
  }
  return result;
}
// 1012E480: using guessed type int dword_1012E480;

//----- (100123B0) --------------------------------------------------------
unsigned int sub_100123B0()
{
  unsigned int result; // eax@1
  unsigned int v1; // ebp@1
  unsigned __int16 v2; // di@3
  int v3; // esi@4
  int v4; // eax@4
  signed int v5; // ebx@10
  __int16 v6; // di@11
  unsigned __int16 v7; // ax@11
  unsigned __int8 v8; // cl@11
  int v9; // eax@14
  signed int v10; // ebx@17
  __int16 v11; // di@18
  unsigned __int16 v12; // ax@18
  unsigned __int8 v13; // cl@18
  char v14; // al@19
  int v15; // ecx@19
  int v16; // eax@21
  unsigned __int16 v17; // [sp+4h] [bp-8h]@12
  int v18; // [sp+8h] [bp-4h]@11

  result = sub_1004E4B0();
  v1 = result;
  if ( result >= dword_1012E488 )
  {
    result = sub_1004E560(97, 100);
    if ( !result )
    {
      v2 = 0;
      if ( word_1012E3D8 )
      {
        do
        {
          v3 = 136 * v2;
          v4 = *(_DWORD *)(v3 + dword_1012E480 + 720);
          if ( !v4 || v4 + 15000 > v1 || !sub_100120E0(v2) )
          {
            *(_BYTE *)(v3 + dword_1012E480 + 704) = -1;
            ++v2;
          }
        }
        while ( v2 < (unsigned __int16)word_1012E3D8 );
      }
      if ( !sub_1004E7C0(6456, (int)byte_1012E490, 800) )
      {
        v5 = 0;
        dword_1012E484 = 0;
        do
        {
          v6 = word_1012E492[4 * v5];
          v7 = word_1012E492[4 * v5];
          LOBYTE(v18) = byte_1012E490[8 * v5];
          if ( !(unsigned __int8)sub_10011A70(v7, v18) )
            break;
          if ( sub_10011A90(v8, &v17, v6) )
          {
            v9 = 136 * v17;
            *(_DWORD *)(v9 + dword_1012E480 + 716) = dword_1012E494[2 * v5];
            *(_BYTE *)(v9 + dword_1012E480 + 704) = v5;
          }
          else
          {
            sub_100117F0((__int16 *)&v17, v18, v6, dword_1012E494[2 * v5], v5, 1);
            v5 = dword_1012E484;
          }
          dword_1012E484 = ++v5;
        }
        while ( v5 < 100 );
      }
      if ( !sub_1004E7C0(6899, (int)byte_1012E3E0, 160) )
      {
        v10 = 0;
        dword_1012E3DC = 0;
        do
        {
          v11 = word_1012E3E2[4 * v10];
          v12 = word_1012E3E2[4 * v10];
          LOBYTE(v18) = byte_1012E3E0[8 * v10];
          if ( !(unsigned __int8)sub_10011A70(v12, v18) )
            break;
          v14 = sub_10011A90(v13, &v17, v11);
          v15 = dword_1012E3E4[2 * v10];
          if ( v14 )
          {
            v16 = 136 * v17;
            *(_DWORD *)(v16 + dword_1012E480 + 716) = v15;
            *(_BYTE *)(v16 + dword_1012E480 + 704) = v10 + 100;
          }
          else
          {
            sub_100117F0((__int16 *)&v17, v18, v11, v15, v10 + 100, 1);
            v10 = dword_1012E3DC;
          }
          dword_1012E3DC = ++v10;
        }
        while ( v10 < 20 );
      }
      result = sub_1004E540(97);
      dword_1012E488 = v1 + 1000;
    }
  }
  return result;
}
// 1012E3D8: using guessed type __int16 word_1012E3D8;
// 1012E3DC: using guessed type int dword_1012E3DC;
// 1012E3E2: using guessed type __int16 word_1012E3E2[];
// 1012E3E4: using guessed type int dword_1012E3E4[];
// 1012E480: using guessed type int dword_1012E480;
// 1012E484: using guessed type int dword_1012E484;
// 1012E488: using guessed type int dword_1012E488;
// 1012E492: using guessed type __int16 word_1012E492[];
// 1012E494: using guessed type int dword_1012E494[];

//----- (100125E0) --------------------------------------------------------
void sub_100125E0()
{
  dword_1012E7B0 = -15;
}
// 1012E7B0: using guessed type int dword_1012E7B0;

//----- (100125F0) --------------------------------------------------------
int __cdecl sub_100125F0(char a1, __int16 a2, int a3)
{
  __int16 v4; // [sp+0h] [bp-52Ch]@1
  char v5; // [sp+4h] [bp-528h]@1
  __int16 v6; // [sp+6h] [bp-526h]@1
  int v7; // [sp+8h] [bp-524h]@1

  v5 = a1;
  v4 = -32710;
  v6 = a2;
  v7 = a3;
  return sub_1004E5C0(28, (int)&v4, 50000, 0);
}

//----- (10012660) --------------------------------------------------------
char sub_10012660()
{
  return sub_10011720(&dword_1012E7B0);
}
// 1012E7B0: using guessed type int dword_1012E7B0;

//----- (10012670) --------------------------------------------------------
char __cdecl sub_10012670(unsigned __int8 a1, __int16 a2, _DWORD *a3)
{
  int v3; // edx@4
  unsigned __int8 v4; // cl@4
  char result; // al@8
  char v6; // [sp+7h] [bp-1h]@1

  v6 = 0;
  if ( sub_10012660() )
  {
    if ( a1 < 0xB0u && !sub_1004E560(97, 100) )
    {
      v3 = dword_1012E7B0 + 4 * a1;
      v4 = 0;
      while ( v4 < *(_BYTE *)(dword_1012E7B0 + 4 * a1) )
      {
        if ( *(_WORD *)(dword_1012E7B0 + 136 * (v4 + *(_WORD *)(v3 + 2)) + 710) == a2 )
        {
          *a3 = *(_DWORD *)(136 * (v4 + *(_WORD *)(v3 + 2)) + dword_1012E7B0 + 716);
          v6 = 1;
          break;
        }
        if ( ++v4 >= 0x78u )
        {
          sub_1004E540(97);
          return 0;
        }
      }
      sub_1004E540(97);
    }
    result = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1012E7B0: using guessed type int dword_1012E7B0;

//----- (10012730) --------------------------------------------------------
char __cdecl sub_10012730(unsigned __int8 a1)
{
  char v1; // al@1
  char v2; // al@1

  v1 = sub_100237E0(a1);
  sub_10009A90(v1, 0);
  v2 = sub_100237E0(a1);
  return sub_1001C180(v2);
}

//----- (10012760) --------------------------------------------------------
char __cdecl sub_10012760(unsigned __int8 a1)
{
  char v1; // al@1

  v1 = sub_100237E0(a1);
  return sub_1001C180(v1);
}

//----- (10012780) --------------------------------------------------------
char sub_10012780()
{
  char result; // al@1
  void *v1; // ecx@2
  char v2; // al@2
  int v3; // eax@2
  int v4; // [sp+0h] [bp-4Ch]@0
  char v5; // [sp+4h] [bp-48h]@1

  memset(&v5, 0, 0x43u);
  result = sub_100302E0();
  if ( !result )
  {
    LOBYTE(v4) = sub_10029040();
    memset(&v5, v4, 0x43u);
    v2 = sub_10029030(v1);
    v3 = sub_10028F00(v2);
    result = sub_1004E9B0(v3, (int)&v5, 67);
  }
  return result;
}

//----- (100127F0) --------------------------------------------------------
bool __cdecl sub_100127F0(char a1)
{
  void *v1; // ecx@0
  int v2; // esi@1
  void *v3; // ecx@1
  int v4; // edi@1
  void *v5; // ecx@1
  int v6; // eax@1
  _DWORD *v7; // edx@1
  unsigned __int8 v8; // cl@3
  int v9; // esi@3

  v2 = sub_1001F7C0(v1);
  v4 = sub_1001A050(v3);
  v6 = sub_1001B4A0(v5);
  v7 = &unk_10083FE8;
  if ( a1 == 1 )
    v7 = &unk_10083FF0;
  v8 = 0;
  v9 = v6 | ~v2;
  while ( !(v9 & v7[v8] & v4) )
  {
    if ( ++v8 >= 2u )
      return 1;
  }
  return v6 == v7[v8];
}

//----- (10012850) --------------------------------------------------------
char __cdecl sub_10012850(char a1, char a2, char a3)
{
  char v3; // bl@1
  void *v4; // ecx@1
  int v5; // esi@1
  char result; // al@1
  char *v7; // ecx@2
  bool v8; // zf@3
  char *v9; // eax@3
  char v10; // [sp+Ch] [bp-90h]@1
  char v11; // [sp+10h] [bp-8Ch]@1
  char v12[68]; // [sp+54h] [bp-48h]@1

  v3 = 0;
  memset(&v11, 0, 0x43u);
  memset(v12, 0, 0x43u);
  v10 = sub_10029030(v4);
  sub_100302F0(a1, &v11);
  v5 = sub_10028F00(v10);
  sub_1004E840(v5, (int)v12, 67);
  result = v11;
  if ( v11 != 67 )
  {
    v7 = &v11;
    do
    {
      v8 = v12[(unsigned __int8)result] == a2;
      v9 = &v12[(unsigned __int8)result];
      if ( !v8 )
      {
        *v9 = a2;
        v3 = 1;
      }
      result = (v7++)[1];
    }
    while ( result != 67 );
    if ( v3 == 1 )
    {
      if ( a3 || (result = sub_100127F0(v10)) != 0 )
        result = sub_1004E9B0(v5, (int)v12, 67);
    }
  }
  return result;
}
// 10012850: using guessed type char var_48[68];

//----- (10012930) --------------------------------------------------------
char sub_10012930()
{
  char v1; // [sp+0h] [bp-410h]@1
  char v2; // [sp+1h] [bp-40Fh]@1
  __int16 v3; // [sp+4h] [bp-40Ch]@1
  int v4; // [sp+Ch] [bp-404h]@1
  int v5; // [sp+10h] [bp-400h]@1
  __int16 v6; // [sp+14h] [bp-3FCh]@1
  int v7; // [sp+18h] [bp-3F8h]@1
  int v8; // [sp+404h] [bp-Ch]@1
  int v9; // [sp+408h] [bp-8h]@1

  v8 = 500;
  v7 = 0;
  v6 = 0;
  v9 = 1;
  v1 = 2;
  v4 = 1000;
  v3 = 0;
  v5 = 1;
  v2 = 1;
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\iop_test_hsdb_rgn.c",
    (int)"143",
    (int)"Sending invalid IOP_A_RGN_NOTIFICATION packet.\n");
  sub_100106F0(6, 0, &v1, 0, 20, 0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\iop_test_hsdb_rgn.c",
    (int)"146",
    (int)"Sending invalid IOP_A_RGN_BUFFER packet.\n");
  sub_100106F0(6, 1, &v6, 0, 1016, 0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\iop_test_hsdb_rgn.c",
    (int)"152",
    (int)"Sending IOP_A_RGN_NOTIFICATION packet with the wrong source_lru.\n");
  v5 = 256;
  sub_100106F0(6, 0, &v1, 0, 20, 1);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\iop_test_hsdb_rgn.c",
    (int)&unk_100853F0,
    (int)"Sending IOP_A_RGN_BUFFER packet with the wrong source_lru.\n");
  v9 = 256;
  return sub_100106F0(6, 1, &v6, 0, 1016, 1);
}

//----- (10012A80) --------------------------------------------------------
char sub_10012A80()
{
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\iop_test_hsdb_rgn.c",
    (int)"100",
    (int)"Sending region packets for robustness testing...\n");
  return sub_10012930();
}

//----- (10012AB0) --------------------------------------------------------
int sub_10012AB0()
{
  int result; // eax@2

  if ( *(_BYTE *)dword_1012E7CC )
    result = *(_DWORD *)(dword_1012E7CC + 144);
  else
    result = 0;
  return result;
}
// 1012E7CC: using guessed type int dword_1012E7CC;

//----- (10012AD0) --------------------------------------------------------
char __cdecl sub_10012AD0(_DWORD *a1)
{
  char result; // al@1

  result = 0;
  if ( dword_1014043C != -15 )
  {
    *a1 = dword_1014043C;
    result = 1;
  }
  return result;
}
// 1014043C: using guessed type int dword_1014043C;

//----- (10012AF0) --------------------------------------------------------
_BYTE *__usercall sub_10012AF0@<eax>(char a1@<bl>, int a2@<esi>)
{
  signed int v2; // ecx@4
  int v3; // eax@5
  _BYTE *result; // eax@9
  unsigned int v5; // eax@11
  unsigned int v6; // eax@14

  if ( !*(_WORD *)(a2 + 10) && a1 == 3 )
    *(_DWORD *)(a2 + 16) = sub_1004E4B0();
  v2 = 0;
  if ( *(_BYTE *)(a2 + 184) )
  {
    v3 = a2 + 29;
    do
    {
      *(_BYTE *)(v3 + 7) = a1;
      if ( **(_BYTE **)(a2 + 12) != 3 )
        *(_BYTE *)v3 = 0;
      ++v2;
      v3 += 32;
    }
    while ( v2 < *(_BYTE *)(a2 + 184) );
  }
  result = *(_BYTE **)(a2 + 12);
  if ( *result != a1 )
  {
    if ( !a1 )
    {
      v5 = *(_DWORD *)(a2 + 188);
      if ( v5 < 0xFFFFFFC2 && v5 )
      {
        sub_1004EF10(*(_DWORD *)(a2 + 188));
        *(_DWORD *)(a2 + 188) = -15;
      }
      v6 = *(_DWORD *)(a2 + 49276);
      if ( v6 < 0xFFFFFFC2 )
      {
        if ( v6 )
        {
          sub_10031D30((void *)(a2 + 49160));
          *(_DWORD *)(a2 + 49276) = -15;
        }
      }
    }
    result = *(_BYTE **)(a2 + 12);
    *(_BYTE *)(a2 + 8) = *result;
    *result = a1;
  }
  return result;
}

//----- (10012B90) --------------------------------------------------------
char __usercall sub_10012B90@<al>(int a1@<edi>, const char *a2@<esi>, char a3, char a4, int a5, int a6, int a7, __int16 a8, int a9)
{
  char result; // al@18
  __int16 v10; // [sp+0h] [bp-A4h]@1
  char v11; // [sp+4h] [bp-A0h]@3
  __int16 v12; // [sp+6h] [bp-9Eh]@3
  int v13; // [sp+8h] [bp-9Ch]@3
  int v14; // [sp+Ch] [bp-98h]@3
  char v15; // [sp+10h] [bp-94h]@3
  int v16; // [sp+90h] [bp-14h]@3
  int v17; // [sp+94h] [bp-10h]@3
  int v18; // [sp+98h] [bp-Ch]@3
  char v19; // [sp+9Ch] [bp-8h]@3

  memset(&v10, 0, 0xA0u);
  if ( strlen(a2) >= 0x80 )
    sub_1001B780("..\\lib\\adl\\iop_upld_mngr.c", 1750, 1, 0);
  v11 = a4;
  v10 = -32762;
  v13 = a1;
  v14 = a5;
  v12 = a8;
  sub_10020640((int)&v15, a2, 128);
  v16 = a6;
  v17 = a7;
  v18 = a9;
  v19 = a3;
  switch ( a1 )
  {
    case 0x800:
    case 0x8000:
      result = sub_10023AC0((int)&v10);
      break;
    case 0x400:
    case 0x4000:
    case 0x10000:
    case 0x20000:
    case 0x100000:
    case 0x200000:
    case 0x1000000:
    case 0x2000000:
      result = sub_10023AA0((int)&v10);
      break;
    case 0x1000:
    case 0x2000:
    case 0x80000:
    case 0x4000000:
    case 0x8000000:
      result = sub_10023A90((int)&v10);
      break;
    default:
      result = sub_1001B780("..\\lib\\adl\\iop_upld_mngr.c", 1805, 1, 0);
      break;
  }
  return result;
}

//----- (10012D90) --------------------------------------------------------
_DWORD *__usercall sub_10012D90@<eax>(int a1@<ecx>, int a2@<esi>)
{
  int v2; // edx@1
  _DWORD *result; // eax@1
  _DWORD *v4; // ecx@2

  v2 = *(_BYTE *)(a1 + 184);
  result = 0;
  if ( v2 > 0 )
  {
    v4 = (_DWORD *)(a1 + 24);
    do
    {
      if ( *v4 == a2 )
        result = v4;
      v4 += 8;
      --v2;
    }
    while ( v2 );
  }
  return result;
}

//----- (10012DB0) --------------------------------------------------------
signed int __usercall sub_10012DB0@<eax>(int a1@<eax>, int a2@<edx>, void *a3@<ecx>)
{
  return sub_1004F020(*(_DWORD *)(a2 + 188), a3, a1);
}

//----- (10012DD0) --------------------------------------------------------
signed int sub_10012DD0()
{
  if ( !sub_1004F780((LONG)&off_10086358) )
    sub_1001B780("..\\lib\\adl\\iop_upld_mngr.c", 1938, 1, 0);
  *(_BYTE *)dword_1014043C = 0;
  byte_1012E7B8 = 0;
  return sub_1004F310((int)&off_10086358);
}
// 10086358: using guessed type char *off_10086358;
// 1012E7B8: using guessed type char byte_1012E7B8;
// 1014043C: using guessed type int dword_1014043C;

//----- (10012E20) --------------------------------------------------------
signed int sub_10012E20()
{
  if ( !sub_1004F780((LONG)&off_1008636C) )
    sub_1001B780("..\\lib\\adl\\iop_upld_mngr.c", 2003, 1, 0);
  *(_BYTE *)dword_1013AB5C = 0;
  return sub_1004F310((int)&off_1008636C);
}
// 1008636C: using guessed type char *off_1008636C;
// 1013AB5C: using guessed type int dword_1013AB5C;

//----- (10012E60) --------------------------------------------------------
_BYTE *__usercall sub_10012E60@<eax>(_DWORD *a1@<eax>)
{
  int v1; // esi@1
  _BYTE *result; // eax@1

  v1 = (int)a1;
  result = (_BYTE *)(sub_1004E4B0() - *a1);
  if ( (unsigned int)result >= 0x1388 )
  {
    byte_1012E7B8 = 0;
    dword_10140438 = 0;
    result = sub_10012AF0(0, v1);
  }
  return result;
}
// 1012E7B8: using guessed type char byte_1012E7B8;
// 10140438: using guessed type int dword_10140438;

//----- (10012E90) --------------------------------------------------------
char __usercall sub_10012E90@<al>(int a1@<esi>, char a2, int a3, char a4, int a5, int a6, int a7, int a8, __int16 a9, int a10)
{
  int v10; // edi@1
  unsigned int v11; // eax@1
  _DWORD *v12; // edx@5
  unsigned int v13; // eax@5
  const char *v14; // ecx@5
  int v15; // edi@9
  int v16; // eax@10
  _BYTE *v17; // ecx@10
  _BYTE *v18; // edx@10
  int v19; // eax@12
  _BYTE *v20; // ecx@12
  _BYTE *v21; // edx@12
  _BYTE *v22; // ecx@14
  _BYTE *v23; // edx@14
  signed int v24; // eax@17
  unsigned int v25; // eax@20
  char *v26; // ecx@22
  _BYTE *v27; // eax@22
  char v28; // dl@23
  signed int v29; // edx@24
  bool v30; // zf@35
  bool v31; // sf@35

  v10 = a3;
  *(_DWORD *)(a1 + 188) = -15;
  *(_DWORD *)(a1 + 49276) = -15;
  memset((void *)(a1 + 50024), 0, 0x34u);
  v11 = j_FIL_vfs_open(a6, 4, 1792);
  *(_DWORD *)(a1 + 188) = v11;
  if ( (v11 >= 0xFFFFFFC2 || !v11)
    && sub_1004F1C0((int)"/mnt/card0/avtn_rgn.gca")
    && !sub_10031D90(
          (int)"/mnt/card0/avtn_rgn.gca",
          4,
          (void *)(a1 + 49160),
          (int)"Garmin Dont Give Out sYsTem lOader 1543krats&$*%(dh)#2654/*-") )
  {
    v12 = (_DWORD *)a6;
    v13 = 10;
    v14 = "/mnt/card0";
    do
    {
      if ( *v12 != *(_DWORD *)v14 )
        goto LABEL_9;
      v13 -= 4;
      v14 += 4;
      ++v12;
    }
    while ( v13 >= 4 );
    if ( !v13 )
    {
LABEL_17:
      v24 = 0;
      goto LABEL_18;
    }
LABEL_9:
    v15 = *(_BYTE *)v12 - *v14;
    if ( *(_BYTE *)v12 == *v14 )
    {
      v16 = v13 - 1;
      v17 = v14 + 1;
      v18 = (char *)v12 + 1;
      if ( !v16
        || (v15 = *v18 - *v17, *v18 == *v17)
        && ((v19 = v16 - 1, v20 = v17 + 1, v21 = v18 + 1, !v19)
         || (v15 = *v21 - *v20, *v21 == *v20)
         && ((v22 = v20 + 1, v23 = v21 + 1, v19 == 1) || (v15 = *v23 - *v22, *v23 == *v22))) )
      {
        v10 = a3;
        goto LABEL_17;
      }
    }
    v30 = v15 == 0;
    v31 = v15 < 0;
    v10 = a3;
    v24 = 1;
    if ( v31 || v30 )
      v24 = -1;
LABEL_18:
    if ( !v24 )
    {
      *(_DWORD *)(a1 + 50048) = a1 + 192;
      *(_DWORD *)(a1 + 50056) = a1 + 2240;
      *(_DWORD *)(a1 + 50024) = 0;
      *(_DWORD *)(a1 + 50028) = 0;
      *(_WORD *)(a1 + 50032) = 0;
      *(_DWORD *)(a1 + 50040) = 0;
      *(_WORD *)(a1 + 50044) = 0;
      *(_DWORD *)(a1 + 50052) = 2048;
      *(_DWORD *)(a1 + 50060) = 46920;
      *(_DWORD *)(a1 + 50064) = 15;
      *(_BYTE *)(a1 + 50068) = -2;
      *(_DWORD *)(a1 + 50072) = 0xFFFF;
      *(_DWORD *)(a1 + 188) = sub_10032D30(a1 + 49160, (char *)(a6 + 11), 4, (void *)(a1 + 49288), a1 + 50024);
    }
  }
  v25 = *(_DWORD *)(a1 + 188);
  if ( v25 < 0xFFFFFFC2 && v25 )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 12) + 4) = a2;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 144) = v10;
    *(_BYTE *)(*(_DWORD *)(a1 + 12) + 5) = a4;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 140) = a5;
    *(_WORD *)(*(_DWORD *)(a1 + 12) + 136) = a9;
    *(_WORD *)(*(_DWORD *)(a1 + 12) + 138) = -1;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 168) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 152) = a7;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 148) = a8;
    v26 = (char *)a6;
    v27 = (_BYTE *)(*(_DWORD *)(a1 + 12) + 7);
    do
    {
      v28 = *v26;
      *v27++ = *v26++;
    }
    while ( v28 );
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 156) = a10;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 160) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 164) = 1000;
    sub_1004F240(
      *(_DWORD *)(a1 + 188),
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 152) + *(_DWORD *)(*(_DWORD *)(a1 + 12) + 168),
      0);
    *(_WORD *)(a1 + 10) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    dword_10140438 = sub_1004E4B0();
    **(_BYTE **)(a1 + 12) = 1;
    memset((void *)(a1 + 24), 0, 0xA0u);
    *(_BYTE *)(a1 + 184) = 0;
    v29 = 2;
    do
    {
      v25 = 1 << (v29 - 2);
      if ( v25 & v10 )
      {
        *(_DWORD *)(32 * *(_BYTE *)(a1 + 184) + a1 + 24) = v25;
        LOBYTE(v25) = **(_BYTE **)(a1 + 12);
        *(_BYTE *)(32 * *(_BYTE *)(a1 + 184) + a1 + 36) = v25;
        *(_DWORD *)(32 * ((*(_BYTE *)(a1 + 184))++ + 1) + a1) = 0;
        if ( *(_BYTE *)(a1 + 184) >= 5u )
          break;
      }
      v25 = 1 << (v29 - 1);
      if ( v25 & v10 )
      {
        *(_DWORD *)(32 * *(_BYTE *)(a1 + 184) + a1 + 24) = v25;
        LOBYTE(v25) = **(_BYTE **)(a1 + 12);
        *(_BYTE *)(32 * *(_BYTE *)(a1 + 184) + a1 + 36) = v25;
        *(_DWORD *)(32 * ((*(_BYTE *)(a1 + 184))++ + 1) + a1) = 0;
        if ( *(_BYTE *)(a1 + 184) >= 5u )
          break;
      }
      if ( (1 << v29) & v10 )
      {
        *(_DWORD *)(32 * *(_BYTE *)(a1 + 184) + a1 + 24) = 1 << v29;
        LOBYTE(v25) = **(_BYTE **)(a1 + 12);
        *(_BYTE *)(32 * *(_BYTE *)(a1 + 184) + a1 + 36) = v25;
        *(_DWORD *)(32 * ((*(_BYTE *)(a1 + 184))++ + 1) + a1) = 0;
        if ( *(_BYTE *)(a1 + 184) >= 5u )
          break;
      }
      v25 = 1 << (v29 + 1);
      if ( v25 & v10 )
      {
        *(_DWORD *)(32 * *(_BYTE *)(a1 + 184) + a1 + 24) = v25;
        LOBYTE(v25) = **(_BYTE **)(a1 + 12);
        *(_BYTE *)(32 * *(_BYTE *)(a1 + 184) + a1 + 36) = v25;
        *(_DWORD *)(32 * ((*(_BYTE *)(a1 + 184))++ + 1) + a1) = 0;
        if ( *(_BYTE *)(a1 + 184) >= 5u )
          break;
      }
      v29 += 4;
      LOBYTE(v25) = v29 - 2;
    }
    while ( (unsigned int)(v29 - 2) < 0x20 );
  }
  return v25;
}
// 1004F010: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10140438: using guessed type int dword_10140438;

//----- (100132D0) --------------------------------------------------------
char __usercall sub_100132D0@<al>(const void *a1@<eax>, int a2@<ebx>, char a3, unsigned __int16 a4)
{
  const void *v4; // edi@1
  int v5; // esi@3
  int v6; // eax@4
  int v7; // ecx@5
  int v8; // edi@5
  char result; // al@6
  int v10; // eax@8

  v4 = a1;
  *(_DWORD *)(a2 + 20) = sub_1004E4B0();
  if ( a3 == 1 )
  {
    v5 = 1;
  }
  else
  {
    if ( a3 == 2 )
    {
      v5 = 0xFFFF;
      v10 = sub_1004E4B0();
      sub_1000ED20(0xFFFF, a4, 1, (int)&byte_10236500, v4, v10);
      goto LABEL_5;
    }
    v5 = 0;
  }
  v6 = sub_1004E4B0();
  sub_1000EA10(v5, 1, (int)&byte_10236500, v4, v6);
LABEL_5:
  v7 = *(_DWORD *)(a2 + 12);
  v8 = *(_DWORD *)(v7 + 144);
  if ( v8 == sub_1001B4A0((void *)v7) || (result = sub_1000F010(v5, v8, (int)&byte_10236500)) != 0 )
    result = 1;
  return result;
}
// 10236500: using guessed type char byte_10236500;

//----- (100133D0) --------------------------------------------------------
char __cdecl sub_100133D0(char a1)
{
  char result; // al@3
  __int16 v2; // [sp+8h] [bp-A4h]@1
  char v3; // [sp+Ch] [bp-A0h]@1
  __int16 v4; // [sp+Eh] [bp-9Eh]@1
  int v5; // [sp+10h] [bp-9Ch]@1
  int v6; // [sp+14h] [bp-98h]@1
  char v7; // [sp+18h] [bp-94h]@1
  int v8; // [sp+98h] [bp-14h]@1
  int v9; // [sp+9Ch] [bp-10h]@1
  int v10; // [sp+A0h] [bp-Ch]@1

  memset(&v2, 0, 0xA0u);
  v2 = -32762;
  v5 = *(_DWORD *)(dword_1012E7CC + 144);
  v3 = *(_BYTE *)(dword_1012E7CC + 5);
  v6 = *(_DWORD *)(dword_1012E7CC + 140);
  v4 = *(_WORD *)(dword_1012E7CC + 136);
  sub_10020640((int)&v7, (_BYTE *)(dword_1012E7CC + 7), 128);
  v8 = *(_DWORD *)(dword_1012E7CC + 152);
  v9 = *(_DWORD *)(dword_1012E7CC + 148);
  v10 = *(_DWORD *)(dword_1012E7CC + 156);
  sub_10012AF0(0, (int)&dword_1012E7C0);
  if ( a1 )
  {
    if ( a1 == 6 )
      result = sub_10023A80((int)&v2);
    else
      result = sub_1001B780("..\\lib\\adl\\iop_upld_mngr.c", 712, 1, 0);
  }
  else
  {
    result = sub_10023A90((int)&v2);
  }
  return result;
}
// 1012E7C0: using guessed type int dword_1012E7C0;
// 1012E7CC: using guessed type int dword_1012E7CC;

//----- (10013500) --------------------------------------------------------
int sub_10013500()
{
  unsigned int v0; // esi@1
  void (__cdecl *v1)(int); // eax@2
  int result; // eax@5

  dword_1013AB5C = -15;
  sub_10012E20();
  dword_1014043C = -15;
  sub_10012DD0();
  memset(&dword_1012E7C0, 0, 0xC39Cu);
  dword_10140430 = 0;
  dword_10140434 = 0;
  v0 = 0;
  do
  {
    v1 = (void (__cdecl *)(int))dword_100862CC[v0];
    if ( v1 )
      v1(dword_100862C8[v0]);
    v0 += 4;
  }
  while ( v0 < 36 );
  result = sub_1004E4B0();
  dword_1012E87C = -15;
  dword_1013A83C = -15;
  dword_10140430 = result;
  LOBYTE(dword_10140434) = 0;
  dword_1012E7CC = dword_1014043C;
  byte_1012E7BA = 0;
  byte_1012E7B9 = 0;
  return result;
}
// 100862C8: using guessed type int dword_100862C8[];
// 100862CC: using guessed type int dword_100862CC[];
// 1012E7B9: using guessed type char byte_1012E7B9;
// 1012E7BA: using guessed type char byte_1012E7BA;
// 1012E7C0: using guessed type int dword_1012E7C0;
// 1012E7CC: using guessed type int dword_1012E7CC;
// 1012E87C: using guessed type int dword_1012E87C;
// 1013A83C: using guessed type int dword_1013A83C;
// 1013AB5C: using guessed type int dword_1013AB5C;
// 10140430: using guessed type int dword_10140430;
// 10140434: using guessed type int dword_10140434;
// 1014043C: using guessed type int dword_1014043C;

//----- (100135A0) --------------------------------------------------------
_BYTE *__cdecl sub_100135A0(char a1)
{
  void *v1; // ecx@4
  char v2; // bl@5
  int v4; // [sp+8h] [bp-18h]@1
  int v5; // [sp+Ch] [bp-14h]@1
  int v6; // [sp+10h] [bp-10h]@1
  int v7; // [sp+14h] [bp-Ch]@1
  int v8; // [sp+18h] [bp-8h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  if ( (unsigned __int8)byte_1012E7C8 >= 2u && *(_BYTE *)dword_1012E7CC == 5 || *(_BYTE *)dword_1012E7CC >= 2u )
  {
    LOBYTE(v4) = 2;
    v1 = *(void **)(dword_1012E7CC + 140);
    v6 = *(_DWORD *)(dword_1012E7CC + 140);
    v7 = *(_DWORD *)(dword_1012E7CC + 148);
    LOWORD(v5) = *(_WORD *)(dword_1012E7CC + 136);
    LOWORD(v1) = v5;
    BYTE1(v4) = *(_BYTE *)(dword_1012E7CC + 5);
    v8 = sub_1001B4A0(v1);
    sub_100132D0(&v4, (int)&dword_1012E7C0, 0, 0x14u);
  }
  dword_1012E7C0 = sub_1004E4B0();
  v2 = 5;
  if ( !a1 )
    v2 = 7;
  return sub_10012AF0(v2, (int)&dword_1012E7C0);
}
// 1012E7C0: using guessed type int dword_1012E7C0;
// 1012E7C8: using guessed type char byte_1012E7C8;
// 1012E7CC: using guessed type int dword_1012E7CC;

//----- (10013660) --------------------------------------------------------
_BYTE *__usercall sub_10013660@<eax>(_BYTE *result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // esi@1
  char v4; // bl@1
  int v5; // ecx@3
  signed int v6; // eax@3
  int v7; // edi@4
  _BYTE *v8; // ecx@9

  v3 = a3;
  v4 = (char)result;
  if ( *(_BYTE *)(a2 + 12) != (_BYTE)result )
  {
    *(_BYTE *)(a2 + 12) = (_BYTE)result;
    if ( (_BYTE)result == 7 )
    {
      *(_DWORD *)(*(_DWORD *)(a3 + 12) + 144) &= ~*(_DWORD *)a2;
      v5 = *(_BYTE *)(a3 + 184);
      v6 = 0;
      if ( v5 > 0 )
      {
        v7 = v3 + 24;
        do
        {
          ++v6;
          if ( v7 == a2 )
            break;
          v7 += 32;
        }
        while ( v6 < *(_BYTE *)(v3 + 184) );
      }
      memcpy_0((void *)a2, (const void *)(a2 + 32), 32 * (v5 - v6));
      v4 = *(_BYTE *)(v3 + 36);
      --*(_BYTE *)(v3 + 184);
    }
    result = 0;
    if ( *(_BYTE *)(v3 + 184) )
    {
      v8 = (_BYTE *)(v3 + 36);
      while ( *v8 == v4 )
      {
        ++result;
        v8 += 32;
        if ( (signed int)result >= *(_BYTE *)(v3 + 184) )
          goto LABEL_12;
      }
    }
    else
    {
LABEL_12:
      if ( v4 == 7 )
        result = sub_100135A0(0);
      else
        result = sub_10012AF0(v4, v3);
    }
  }
  return result;
}

//----- (10013710) --------------------------------------------------------
unsigned int __usercall sub_10013710@<eax>(unsigned int result@<eax>)
{
  int v1; // esi@1
  char v2; // bl@1
  signed int v3; // ebp@1
  unsigned int v4; // edi@2
  bool v5; // zf@11
  int (__cdecl *v6)(_DWORD, _DWORD, _DWORD, _DWORD); // edx@28
  unsigned int v7; // [sp+Ch] [bp-4h]@0

  v1 = result;
  v2 = 0;
  v3 = 0;
  if ( *(_BYTE *)(result + 184) )
  {
    v4 = result + 24;
    while ( 1 )
    {
      result = *(_DWORD *)v4;
      v7 = v4;
      if ( *(_DWORD *)v4 > 0x4000u )
        break;
      if ( *(_DWORD *)v4 == 0x4000 )
        goto LABEL_27;
      if ( result > 0x200 )
      {
        if ( result > 0x1000 )
        {
          v5 = result == 0x2000;
        }
        else
        {
          if ( result == 4096 || result == 1024 )
            goto LABEL_27;
          v5 = result == 2048;
        }
LABEL_26:
        if ( !v5 )
          goto LABEL_31;
        goto LABEL_27;
      }
      if ( result != 512 )
      {
        switch ( result )
        {
          case 0x10u:
          case 0x20u:
          case 0x40u:
          case 0x80u:
          case 0x100u:
            goto LABEL_27;
          default:
            break;
        }
LABEL_31:
        v2 = 1;
        goto LABEL_32;
      }
LABEL_27:
      result = sub_1001DC80((_DWORD *)v4, 4u, (int)dword_100862C8, 16, 9, 10);
      if ( (signed int)result < 10 )
      {
        result *= 16;
        v6 = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))((char *)&off_100862D4 + result);
        if ( v6 )
        {
          result = v6(
                     *(int *)((char *)dword_100862C8 + result),
                     *(_BYTE *)(*(_DWORD *)(v1 + 12) + 5),
                     *(_DWORD *)(*(_DWORD *)(v1 + 12) + 140),
                     *(_WORD *)(*(_DWORD *)(v1 + 12) + 136));
          v2 = result;
          if ( (_BYTE)result != 1 )
            ++*(_DWORD *)(v4 + 8);
          goto LABEL_32;
        }
        goto LABEL_31;
      }
LABEL_32:
      ++v3;
      v4 += 32;
      if ( v3 >= *(_BYTE *)(v1 + 184) )
        goto LABEL_33;
    }
    if ( result > 0x200000 )
    {
      if ( result > 0x4000000 )
      {
        v5 = result == 0x8000000;
      }
      else
      {
        if ( result == 0x4000000 || result == 0x1000000 )
          goto LABEL_27;
        v5 = result == 0x2000000;
      }
    }
    else
    {
      if ( result == 0x200000 )
        goto LABEL_27;
      if ( result > 0x20000 )
      {
        if ( result == 0x80000 )
          goto LABEL_27;
        v5 = result == 0x100000;
      }
      else
      {
        if ( result == 0x20000 || result == 0x8000 )
          goto LABEL_27;
        v5 = result == 0x10000;
      }
    }
    goto LABEL_26;
  }
LABEL_33:
  if ( *(_DWORD *)(v7 + 8) > 500 )
    result = (unsigned int)sub_100135A0(0);
  if ( v2 == 1 )
  {
    result = sub_1004E4B0() - *(_DWORD *)(v1 + 4);
    if ( result >= *(_DWORD *)(*(_DWORD *)(v1 + 12) + 156) )
      result = (unsigned int)sub_10012AF0(0, v1);
  }
  return result;
}
// 100862C8: using guessed type int dword_100862C8[];
// 100862D4: using guessed type int (__cdecl *off_100862D4)(int, int, int, __int16);

//----- (10013980) --------------------------------------------------------
__int16 __usercall sub_10013980@<ax>(unsigned __int64 a1@<edx:eax>)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // esi@2
  int v4; // edx@12
  unsigned int v5; // ecx@18
  unsigned int v6; // ebp@18
  unsigned int v7; // edi@27
  int v8; // ecx@27

  v1 = dword_1012E7CC;
  v2 = a1;
  LOWORD(a1) = *(_WORD *)(a1 + 2);
  if ( (_WORD)a1 == *(_WORD *)(dword_1012E7CC + 136) )
  {
    LODWORD(a1) = sub_10012D90((int)&dword_1012E7C0, *(_DWORD *)(v2 + 28));
    v3 = a1;
    if ( (_DWORD)a1 )
    {
      if ( *(_BYTE *)v2 != 1 )
      {
        HIDWORD(a1) = a1;
        LOBYTE(a1) = 7;
        LOWORD(a1) = (unsigned int)sub_10013660((_BYTE *)a1, SHIDWORD(a1), (int)&dword_1012E7C0);
        return a1;
      }
      if ( *(_BYTE *)v1 != 3
        || (LODWORD(a1) = *(_DWORD *)(v1 + 168), *(_DWORD *)(v2 + 4) != (_DWORD)a1)
        || (LODWORD(a1) = *(_DWORD *)(v2 + 8), (_DWORD)a1) )
      {
        if ( *(_BYTE *)(v2 + 1) < 2u )
          return a1;
        LODWORD(a1) = *(_DWORD *)(v2 + 8);
        v5 = *(_DWORD *)(v3 + 20);
        HIDWORD(a1) = *(_DWORD *)(v2 + 4);
        v6 = *(_DWORD *)(v3 + 16);
        if ( (unsigned int)a1 <= v5 && ((unsigned int)a1 < v5 || HIDWORD(a1) <= v6) )
        {
          if ( (unsigned int)a1 < v5 || (unsigned int)a1 <= v5 && HIDWORD(a1) < v6 )
            return a1;
          *(_DWORD *)(v1 + 168) = HIDWORD(a1);
          sub_1004F240(dword_1012E87C, *(_DWORD *)(dword_1012E7CC + 152) + *(_DWORD *)(dword_1012E7CC + 168), 0);
          if ( (unsigned __int8)++byte_1012E87A > 5u )
            byte_1012E87A = 5;
        }
        *(_DWORD *)(v3 + 16) = *(_DWORD *)(v2 + 4);
        *(_DWORD *)(v3 + 20) = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v3 + 28) = sub_1004E4B0();
        LOWORD(a1) = *(_WORD *)(v2 + 24);
        *(_WORD *)(v3 + 24) = a1;
        if ( *(_BYTE *)dword_1012E7CC == 3 )
        {
          v7 = *(_DWORD *)(dword_1012E7CC + 168);
          v8 = *(_DWORD *)(dword_1012E7CC + 148);
          if ( v7 != v8 || *(_DWORD *)(v3 + 16) == v8 && !*(_DWORD *)(v3 + 20) )
          {
            a1 = *(_QWORD *)(v3 + 16) + (unsigned __int16)a1;
            if ( v7 < a1 )
            {
              LOBYTE(a1) = byte_1012E7C8;
              LOWORD(a1) = (unsigned int)sub_10013660((_BYTE *)a1, v3, (int)&dword_1012E7C0);
            }
          }
        }
      }
      else
      {
        *(_BYTE *)(v3 + 5) = 1;
        word_1012E7CA = 0;
        dword_1012E7D4 = 0;
        if ( *(_BYTE *)(v2 + 1) >= 1u && byte_1012E7C8 == 4 )
        {
          *(_WORD *)(dword_1012E7CC + 138) = *(_WORD *)(v2 + 16);
          LODWORD(a1) = *(_DWORD *)(v2 + 12);
          *(_DWORD *)(dword_1012E7CC + 160) = a1;
        }
        if ( *(_BYTE *)(v2 + 1) < 2u )
        {
          byte_1012E87B = 1;
          byte_1012E879 = 1;
          byte_1012E87A = 0;
          *(_WORD *)(v3 + 24) = 1000;
        }
        else
        {
          v4 = *(_DWORD *)(v2 + 8) | *(_DWORD *)(v2 + 4);
          if ( !*(_QWORD *)(v2 + 4) )
          {
            byte_1012E87B = *(_BYTE *)(v2 + 8) | *(_BYTE *)(v2 + 4);
            byte_1012E879 = 25;
            byte_1012E87A = v4;
          }
          LODWORD(a1) = sub_1004E4B0();
          *(_DWORD *)(v3 + 28) = a1;
          LOWORD(a1) = *(_WORD *)(v2 + 24);
          *(_WORD *)(v3 + 24) = a1;
        }
        *(_DWORD *)(v3 + 16) = *(_DWORD *)(v2 + 4);
        *(_DWORD *)(v3 + 20) = *(_DWORD *)(v2 + 8);
        LOBYTE(a1) = byte_1012E7C8;
        LOWORD(a1) = (unsigned int)sub_10013660((_BYTE *)a1, v3, (int)&dword_1012E7C0);
      }
    }
  }
  return a1;
}
// 1012E7C0: using guessed type int dword_1012E7C0;
// 1012E7C8: using guessed type char byte_1012E7C8;
// 1012E7CA: using guessed type __int16 word_1012E7CA;
// 1012E7CC: using guessed type int dword_1012E7CC;
// 1012E7D4: using guessed type int dword_1012E7D4;
// 1012E879: using guessed type char byte_1012E879;
// 1012E87A: using guessed type char byte_1012E87A;
// 1012E87B: using guessed type char byte_1012E87B;
// 1012E87C: using guessed type int dword_1012E87C;

//----- (10013B90) --------------------------------------------------------
char __thiscall sub_10013B90(void *this)
{
  int v1; // esi@1
  signed int v2; // eax@1
  int v3; // edi@1
  int v4; // ecx@2
  int v5; // eax@8
  int v6; // ecx@10
  char result; // al@11
  int v8; // eax@13
  unsigned int v9; // ebp@13
  int v10; // eax@13
  unsigned int v11; // ebx@14
  int v12; // eax@16
  int v13; // ecx@18
  int v14; // [sp+10h] [bp-7FCh]@2
  int v15; // [sp+14h] [bp-7F8h]@1
  __int16 v16; // [sp+18h] [bp-7F4h]@1
  char v17; // [sp+1Ah] [bp-7F2h]@25
  int v18; // [sp+1Ch] [bp-7F0h]@18
  char v19; // [sp+20h] [bp-7ECh]@16
  size_t v20; // [sp+408h] [bp-404h]@16
  int v21; // [sp+40Ch] [bp-400h]@12
  __int16 v22; // [sp+410h] [bp-3FCh]@1
  char v23; // [sp+412h] [bp-3FAh]@25
  int v24; // [sp+414h] [bp-3F8h]@25
  size_t v25; // [sp+418h] [bp-3F4h]@25
  int v26; // [sp+41Ch] [bp-3F0h]@25
  char v27; // [sp+420h] [bp-3ECh]@25

  v1 = (int)this;
  memset(&v16, 0, 0x3F8u);
  memset(&v22, 0, 0x3F8u);
  v15 = sub_1004E4B0();
  v2 = *(_BYTE *)(v1 + 184);
  byte_1012E7B8 = 0;
  v3 = v1 + 24;
  if ( v2 > 1 )
  {
    v4 = v1 + 72;
    v14 = v2 - 1;
    do
    {
      if ( *(_QWORD *)v4 + (unsigned __int64)*(_WORD *)(v4 + 8) < *(_QWORD *)(v3 + 16)
                                                                + (unsigned __int64)*(_WORD *)(v3 + 24) )
        v3 = v4 - 16;
      v4 += 32;
      --v14;
    }
    while ( v14 );
  }
  if ( *(_WORD *)(v1 + 10) )
  {
    *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168) = *(_DWORD *)(v3 + 16);
    sub_1004F240(
      *(_DWORD *)(v1 + 188),
      *(_DWORD *)(*(_DWORD *)(v1 + 12) + 152) + *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168),
      0);
    if ( *(_WORD *)(v1 + 10) > 1u )
    {
      v5 = *(_DWORD *)(v1 + 12);
      if ( *(_DWORD *)(v5 + 164) < 0x3E8u )
        *(_DWORD *)(v5 + 164) = 1000;
    }
  }
  v6 = *(_DWORD *)(v1 + 12);
  if ( *(_DWORD *)(v6 + 168) >= *(_QWORD *)(v3 + 16) + (unsigned __int64)*(_WORD *)(v3 + 24) )
    return (unsigned int)sub_10012AF0(3, v1);
  v16 = *(_WORD *)(v6 + 136);
  v21 = sub_1001B4A0((void *)v6);
  while ( 1 )
  {
    v8 = sub_1004E4B0();
    dword_1012E7BC = v8;
    v9 = v8 - v15;
    v10 = *(_DWORD *)(v1 + 12);
    if ( *(_DWORD *)(v10 + 168) < *(_DWORD *)(v10 + 148) )
      break;
    result = (unsigned int)sub_10012AF0(4, v1);
LABEL_31:
    if ( **(_BYTE **)(v1 + 12) != 2 || v9 >= 0x23 )
      return result;
  }
  v11 = *(_DWORD *)(v10 + 148) - *(_DWORD *)(v10 + 168);
  if ( v11 > *(_DWORD *)(v10 + 164) )
    v11 = *(_DWORD *)(v10 + 164);
  v12 = sub_10012DB0(v11, v1, &v19);
  v20 = v12;
  if ( v12 != v11 )
  {
    v20 = 0;
    sub_100135A0(1);
    v12 = v20;
  }
  v13 = *(_DWORD *)(v1 + 12);
  v18 = *(_DWORD *)(v13 + 168);
  if ( (unsigned int)(v18 + v12) > *(_DWORD *)(v13 + 148) )
  {
    v12 = *(_DWORD *)(v13 + 148) - v18;
    v20 = *(_DWORD *)(v13 + 148) - v18;
  }
  *(_DWORD *)(v13 + 168) += v12;
  if ( *(_BYTE *)(v1 + 187)
    || *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168) >= *(_DWORD *)(*(_DWORD *)(v1 + 12) + 148)
    || *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168) >= *(_QWORD *)(v3 + 16) + (unsigned __int64)*(_WORD *)(v3 + 24) )
  {
    sub_10012AF0(3, v1);
  }
  if ( *(_DWORD *)(*(_DWORD *)(v1 + 12) + 164) >= 0x3E8u )
  {
    result = sub_100132D0(&v16, v1, 1, 0x3F8u);
  }
  else
  {
    v22 = v16;
    v24 = v18;
    v25 = v20;
    v23 = v17;
    v26 = v21;
    memcpy(&v27, &v19, v20);
    result = sub_100132D0(&v22, v1, 2, v25 + 16);
  }
  if ( result )
    goto LABEL_31;
  *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168) -= v20;
  return sub_1004F240(
           *(_DWORD *)(v1 + 188),
           *(_DWORD *)(*(_DWORD *)(v1 + 12) + 152) + *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168),
           0);
}
// 1012E7B8: using guessed type char byte_1012E7B8;
// 1012E7BC: using guessed type int dword_1012E7BC;

//----- (10013EB0) --------------------------------------------------------
_BYTE *__usercall sub_10013EB0@<eax>(int a1@<esi>)
{
  _BYTE *result; // eax@1
  bool v2; // zf@1
  int v3; // edi@4
  int v4; // eax@8
  int v5; // eax@8
  void *v6; // ecx@8
  _BYTE *v7; // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int (__cdecl *v10)(int, _DWORD, _DWORD, _DWORD); // edx@10
  signed int v11; // [sp+0h] [bp-20h]@3
  int v12; // [sp+8h] [bp-18h]@1
  int v13; // [sp+Ch] [bp-14h]@1
  int v14; // [sp+10h] [bp-10h]@1
  int v15; // [sp+14h] [bp-Ch]@1
  _BYTE *v16; // [sp+18h] [bp-8h]@1

  result = 0;
  v2 = *(_BYTE *)(a1 + 184) == 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( v2 )
    result = sub_100135A0(0);
  v11 = 0;
  if ( *(_BYTE *)(a1 + 184) )
  {
    v3 = a1 + 24;
    do
    {
      if ( *(_BYTE *)(v3 + 4) == 1 )
      {
        if ( *(_BYTE *)(v3 + 5) == 1 )
        {
          LOBYTE(result) = 2;
          sub_10013660(result, v3, a1);
        }
        else
        {
          byte_1012E7B8 = 1;
          v4 = sub_1004E4B0();
          LOBYTE(v12) = 0;
          dword_1012E7BC = v4;
          v5 = *(_DWORD *)(a1 + 12);
          v6 = *(void **)(v5 + 140);
          v14 = *(_DWORD *)(v5 + 140);
          v15 = *(_DWORD *)(v5 + 148);
          LOWORD(v13) = *(_WORD *)(v5 + 136);
          LOWORD(v6) = v13;
          BYTE1(v12) = *(_BYTE *)(v5 + 5);
          v7 = (_BYTE *)sub_1001B4A0(v6);
          v16 = v7;
          LOBYTE(v7) = 3;
          sub_10013660(v7, v3, a1);
          sub_100132D0(&v12, a1, 0, 0x14u);
        }
      }
      else
      {
        v8 = sub_1001DC80((_DWORD *)v3, 4u, (int)dword_100862C8, 16, 9, 10);
        if ( v8 < 10 )
        {
          v9 = 4 * v8;
          v10 = *(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD))((char *)&off_100862D0 + v9 * 4);
          if ( v10 )
            *(_BYTE *)(v3 + 4) = v10(
                                   dword_100862C8[v9],
                                   *(_BYTE *)(*(_DWORD *)(a1 + 12) + 5),
                                   *(_DWORD *)(*(_DWORD *)(a1 + 12) + 140),
                                   *(_WORD *)(*(_DWORD *)(a1 + 12) + 136));
        }
      }
      if ( (double)(unsigned int)(sub_1004E4B0() - dword_10140438) > 600000.0 )
        sub_100135A0(0);
      result = (_BYTE *)(v11 + 1);
      v3 += 32;
      ++v11;
    }
    while ( v11 < *(_BYTE *)(a1 + 184) );
  }
  return result;
}
// 100862C8: using guessed type int dword_100862C8[];
// 100862D0: using guessed type int (__cdecl *off_100862D0)(int, char, int, __int16);
// 1012E7B8: using guessed type char byte_1012E7B8;
// 1012E7BC: using guessed type int dword_1012E7BC;
// 10140438: using guessed type int dword_10140438;

//----- (10014050) --------------------------------------------------------
void __usercall sub_10014050(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // edi@1

  v1 = a1;
  v2 = sub_1004E4B0();
  v3 = v2;
  if ( byte_1012E7B8 == 1 )
  {
    if ( (double)(unsigned int)(v2 - dword_1012E7BC) <= 12000.0 )
    {
      if ( (double)(unsigned int)(v2 - *(_DWORD *)(v1 + 16)) > 360000.0 )
        sub_100135A0(0);
    }
    else
    {
      sub_10012AF0(1, v1);
    }
  }
  if ( (double)(unsigned int)(v3 - dword_1012E7BC) <= 360000.0 )
  {
    if ( *(_BYTE *)(v1 + 8) == 2
      && *(_DWORD *)(*(_DWORD *)(v1 + 12) + 164) < 0x3E8u
      && (unsigned int)(v3 - *(_DWORD *)(v1 + 20)) >= 0x3E8 )
    {
      sub_10012AF0(2, v1);
      ++*(_WORD *)(v1 + 10);
    }
  }
  else
  {
    sub_100135A0(0);
  }
}
// 1012E7B8: using guessed type char byte_1012E7B8;
// 1012E7BC: using guessed type int dword_1012E7BC;

//----- (10014130) --------------------------------------------------------
char __thiscall sub_10014130(int this)
{
  int v1; // esi@1
  unsigned __int8 v2; // cl@1
  char v3; // dl@1
  _BYTE *v4; // eax@2
  int v5; // edi@2
  int v6; // eax@6
  void *v7; // ecx@7
  __int16 v9; // cx@9
  signed int v10; // eax@11
  _DWORD *v11; // ecx@12
  int v12; // [sp+8h] [bp-18h]@1
  int v13; // [sp+Ch] [bp-14h]@1
  int v14; // [sp+10h] [bp-10h]@1
  int v15; // [sp+14h] [bp-Ch]@1
  int v16; // [sp+18h] [bp-8h]@1

  v1 = this;
  v2 = *(_BYTE *)(this + 184);
  v3 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( v2 )
  {
    v4 = (_BYTE *)(v1 + 29);
    v5 = v2;
    do
    {
      if ( *v4 == 1 )
        ++v3;
      v4 += 32;
      --v5;
    }
    while ( v5 );
  }
  v6 = *(_DWORD *)(v1 + 12);
  if ( v2 != v3 )
  {
    LOBYTE(v12) = 1;
    v7 = *(void **)(v6 + 140);
    v14 = *(_DWORD *)(v6 + 140);
    v15 = *(_DWORD *)(v6 + 148);
    LOWORD(v13) = *(_WORD *)(v6 + 136);
    LOWORD(v7) = v13;
    BYTE1(v12) = *(_BYTE *)(v6 + 5);
    v16 = sub_1001B4A0(v7);
    sub_10012AF0(3, v1);
    return sub_100132D0(&v12, v1, 0, 0x14u);
  }
  if ( *(_WORD *)(v6 + 136) == 74 )
  {
    v9 = *(_WORD *)(v6 + 138);
    if ( v9 == -1 )
    {
      sub_100135A0(0);
      return sub_1001B780("..\\lib\\adl\\iop_upld_mngr.c", 2939, 0, 0);
    }
    sub_100125F0(*(_BYTE *)(v6 + 4), v9, *(_DWORD *)(v6 + 160));
  }
  v10 = 0;
  if ( *(_BYTE *)(v1 + 184) )
  {
    v11 = (_DWORD *)(v1 + 32);
    do
    {
      *v11 = 0;
      ++v10;
      v11 += 8;
    }
    while ( v10 < *(_BYTE *)(v1 + 184) );
  }
  *(_DWORD *)(v1 + 4) = sub_1004E4B0();
  return (unsigned int)sub_10012AF0(6, v1);
}

//----- (100142A0) --------------------------------------------------------
char __cdecl sub_100142A0(int a1, int a2)
{
  char result; // al@2
  unsigned __int64 v3; // rax@6
  void *v4; // ecx@6
  void *v5; // ecx@8
  int v6; // [sp+8h] [bp-28h]@1
  int v7; // [sp+Ch] [bp-24h]@1
  int v8; // [sp+10h] [bp-20h]@1
  int v9; // [sp+14h] [bp-1Ch]@1
  int v10; // [sp+18h] [bp-18h]@1
  int v11; // [sp+1Ch] [bp-14h]@1
  int v12; // [sp+20h] [bp-10h]@1
  int v13; // [sp+24h] [bp-Ch]@1
  int v14; // [sp+28h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v6 = 0;
  if ( (_WORD)a1 == 2 )
  {
    result = sub_1000F620(2, a2, &v7);
    if ( !result )
      return result;
    BYTE2(v11) = BYTE1(v7);
    BYTE1(v7) = 0;
  }
  else
  {
    result = sub_1000F640(a1, a2, &v7, (unsigned __int16 *)&v6);
  }
  if ( result )
  {
    LODWORD(v3) = sub_1000DEC0(a1, a2);
    LOBYTE(v4) = BYTE1(v7);
    if ( BYTE1(v7) <= 1u )
      goto LABEL_10;
    if ( BYTE1(v7) == 2 )
    {
      v14 = v3;
      LODWORD(v3) = sub_1001B4A0(v4);
      if ( !((unsigned int)v3 & v14) )
      {
LABEL_11:
        LODWORD(v3) = &v7;
        return sub_10013980(v3);
      }
      LODWORD(v3) = sub_1001B4A0(v5);
LABEL_10:
      v14 = v3;
      goto LABEL_11;
    }
    result = sub_1001B780("..\\lib\\adl\\iop_upld_mngr.c", 1177, 0, 0);
  }
  return result;
}

//----- (100143A0) --------------------------------------------------------
void __usercall sub_100143A0(const void *a1@<ecx>, const void *a2@<esi>)
{
  const void *v2; // esi@9
  char v3; // bl@9
  unsigned int v4; // ebp@10
  const void *v5; // [sp+0h] [bp-4h]@2

  switch ( *(_BYTE *)dword_1012E7CC )
  {
    case 1:
      v5 = a2;
      sub_10013EB0((int)&dword_1012E7C0);
      break;
    case 2:
      sub_10013B90(&dword_1012E7C0);
      break;
    case 3:
      sub_10014050((int)&dword_1012E7C0);
      break;
    case 4:
      sub_10014130((int)&dword_1012E7C0);
      break;
    case 6:
      sub_10013710((unsigned int)&dword_1012E7C0);
      break;
    case 5:
    case 7:
      sub_10012E60(&dword_1012E7C0);
      break;
    case 0:
      break;
    default:
      sub_1001B780("..\\lib\\adl\\iop_upld_mngr.c", 1268, 1, 0);
      break;
  }
  v5 = a1;
  v2 = (const void *)dword_1014043C;
  v3 = 0;
  if ( *(_BYTE *)dword_1014043C )
    goto LABEL_17;
  v4 = 0;
  do
  {
    if ( sub_10014750(dword_10086380[v4], &v5) == 1 )
    {
      if ( *(_BYTE *)v5 )
      {
        qmemcpy((void *)dword_1013AB5C, v5, 0xACu);
        v3 = 1;
      }
    }
    ++v4;
  }
  while ( v4 < 3 );
  if ( v3 != 1 )
  {
    v2 = (const void *)dword_1014043C;
LABEL_17:
    qmemcpy((void *)dword_1013AB5C, v2, 0xACu);
  }
}
// 10086380: using guessed type int dword_10086380[];
// 1012E7C0: using guessed type int dword_1012E7C0;
// 1012E7CC: using guessed type int dword_1012E7CC;
// 1013AB5C: using guessed type int dword_1013AB5C;
// 1014043C: using guessed type int dword_1014043C;

//----- (10014450) --------------------------------------------------------
char __cdecl sub_10014450(char a1, int a2, char a3, int a4, const char *a5, int a6, int a7, __int16 a8, int a9)
{
  char result; // al@2

  if ( a2 )
  {
    if ( (_BYTE)a2 || a2 & 0x300 )
    {
      if ( strlen(a5) >= 0x80 )
        sub_1001B780("..\\lib\\adl\\iop_upld_mngr.c", 1375, 1, 0);
      result = sub_10012E90((int)&dword_1012E7C0, a1, a2, a3, a4, (int)a5, a6, a7, a8, a9);
    }
    else
    {
      result = sub_10012B90(a2, a5, a1, a3, a4, a6, a7, a8, a9);
    }
  }
  else
  {
    result = (unsigned int)sub_100135A0(0);
  }
  return result;
}
// 1012E7C0: using guessed type int dword_1012E7C0;

//----- (10014510) --------------------------------------------------------
char sub_10014510()
{
  int v1; // [sp+0h] [bp-4h]@1

  v1 = 0;
  LOWORD(v1) = -32761;
  return sub_10023A80((int)&v1);
}

//----- (10014530) --------------------------------------------------------
void sub_10014530()
{
  dword_101404D0 = -15;
}
// 101404D0: using guessed type int dword_101404D0;

//----- (10014540) --------------------------------------------------------
signed int sub_10014540()
{
  signed int result; // eax@1

  result = -15;
  dword_101404CC = -15;
  dword_101404C4 = -15;
  dword_101404C8 = -15;
  return result;
}
// 101404C4: using guessed type int dword_101404C4;
// 101404C8: using guessed type int dword_101404C8;
// 101404CC: using guessed type int dword_101404CC;

//----- (10014560) --------------------------------------------------------
char sub_10014560()
{
  return sub_10012AD0(&dword_101404D0);
}
// 101404D0: using guessed type int dword_101404D0;

//----- (10014570) --------------------------------------------------------
signed int __usercall sub_10014570@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@1
  int v3; // eax@2
  signed int result; // eax@4

  v2 = a1 - 29;
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 == 1 )
        result = sub_1004F6B0((int)&off_100865A8);
      else
        result = sub_1004F6B0(a2);
    }
    else
    {
      result = sub_1004F6B0((int)&off_10086594);
    }
  }
  else
  {
    result = sub_1004F6B0((int)&off_10086580);
  }
  return result;
}
// 10086580: using guessed type char *off_10086580;
// 10086594: using guessed type char *off_10086594;
// 100865A8: using guessed type char *off_100865A8;

//----- (100145C0) --------------------------------------------------------
char __usercall sub_100145C0@<al>(const char *a1@<esi>, int a2, int a3, char a4, int a5, int a6, __int16 a7, char a8, int a9)
{
  __int16 v10; // [sp+0h] [bp-A4h]@1
  char v11; // [sp+4h] [bp-A0h]@3
  __int16 v12; // [sp+6h] [bp-9Eh]@3
  int v13; // [sp+8h] [bp-9Ch]@3
  int v14; // [sp+Ch] [bp-98h]@3
  char v15; // [sp+10h] [bp-94h]@3
  int v16; // [sp+90h] [bp-14h]@3
  int v17; // [sp+94h] [bp-10h]@3
  int v18; // [sp+98h] [bp-Ch]@3
  char v19; // [sp+9Ch] [bp-8h]@3

  memset(&v10, 0, 0xA0u);
  if ( strlen(a1) >= 0x80 )
    sub_1001B780("..\\lib\\adl\\iop_upld_mngr_intf.c", 711, 1, 0);
  v11 = a8;
  v13 = a5;
  v10 = -32762;
  v14 = a6;
  v12 = a7;
  sub_10020640((int)&v15, a1, 128);
  v17 = a3;
  v16 = a2;
  v18 = a9;
  v19 = a4;
  return sub_10023A80((int)&v10);
}

//----- (100146C0) --------------------------------------------------------
char __cdecl sub_100146C0(_BYTE *a1)
{
  char result; // al@2

  if ( sub_10014560() == 1 )
  {
    *a1 = *(_BYTE *)dword_101404D0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101404D0: using guessed type int dword_101404D0;

//----- (100146F0) --------------------------------------------------------
char __cdecl sub_100146F0(const char *a1, int a2, int a3, char a4, __int16 a5, int a6)
{
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v8 = 0;
  LOBYTE(v7) = 7;
  sub_10032F20(a4, &v8, (int)&v9, &v7);
  return sub_100145C0(a1, a2, a3, a4, v8, v9, a5, v7, a6);
}

//----- (10014750) --------------------------------------------------------
char __cdecl sub_10014750(int a1, _DWORD *a2)
{
  int v2; // ecx@0
  char result; // al@5

  if ( (unsigned __int8)sub_10014570(a1, v2) == 1 )
  {
    if ( a1 == 29 )
    {
      *a2 = dword_101404CC;
    }
    else
    {
      if ( a1 == 30 )
      {
        *a2 = dword_101404C4;
        return 1;
      }
      if ( a1 == 31 )
      {
        *a2 = dword_101404C8;
        return 1;
      }
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101404C4: using guessed type int dword_101404C4;
// 101404C8: using guessed type int dword_101404C8;
// 101404CC: using guessed type int dword_101404CC;

//----- (100147B0) --------------------------------------------------------
char sub_100147B0()
{
  char *v0; // eax@1
  char *v1; // ecx@1
  signed int v2; // edx@1
  void *v3; // ecx@3
  char result; // al@3
  char v5; // [sp+4h] [bp-28h]@1
  char v6; // [sp+Ch] [bp-20h]@1

  v0 = &v5;
  v1 = &v6;
  v2 = 7;
  do
  {
    *v0 = 0;
    *(_DWORD *)v1 = 42066;
    ++v0;
    v1 += 4;
    --v2;
  }
  while ( v2 );
  sub_1004E8F0(41101, (int)&v5, 36);
  dword_10145CF8 = 0;
  dword_10145D00 = 0;
  dword_10145CFC = 0;
  byte_101404D9 = 0;
  dword_101404DC = 0;
  dword_10145CF4 = 0;
  result = sub_1001A070(v3);
  byte_101404D8 = result;
  return result;
}
// 101404D8: using guessed type char byte_101404D8;
// 101404D9: using guessed type char byte_101404D9;
// 101404DC: using guessed type int dword_101404DC;
// 10145CF4: using guessed type int dword_10145CF4;
// 10145CF8: using guessed type int dword_10145CF8;
// 10145CFC: using guessed type int dword_10145CFC;
// 10145D00: using guessed type int dword_10145D00;

//----- (10014840) --------------------------------------------------------
char __cdecl sub_10014840(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v2;
  LOBYTE(v3) = sub_1000F640(a1, a2, &dword_101404E0, (unsigned __int16 *)&v5);
  if ( (_BYTE)v3 == 1 )
  {
    v3 = j_REG_pvg_xfil_write_data(&dword_101404E0, (unsigned __int16)v5);
    if ( v3 != (unsigned __int16)v5 )
      LOBYTE(v3) = sub_1001B780("..\\lib\\adl\\iop_xfil_reg_frmt.c", 345, 0, 0);
  }
  return v3;
}
// 1004EA10: using guessed type int __cdecl j_REG_pvg_xfil_write_data(_DWORD, _DWORD);
// 101404E0: using guessed type int dword_101404E0;

//----- (100148A0) --------------------------------------------------------
char __cdecl sub_100148A0(int a1, int a2, __int16 a3)
{
  int v4; // [sp+0h] [bp-Ch]@1
  int v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v6 = 0;
  v4 = a2;
  LOWORD(v6) = a3;
  v5 = sub_1001B4A0((void *)a3);
  return sub_1000F2D0(84, a1, &v4, 1, (int)&byte_10236500);
}
// 10236500: using guessed type char byte_10236500;

//----- (100148F0) --------------------------------------------------------
int __cdecl sub_100148F0(int a1, int a2)
{
  int v2; // ebx@1
  void *v3; // ecx@1
  int result; // eax@1

  v2 = sub_1000DEC0(a1, a2);
  result = sub_1001A050(v3);
  if ( v2 & result )
  {
    sub_1001BF40(0x3Fu);
    result = *(_DWORD *)(a2 + 32);
    dword_10145CF8 |= *(_DWORD *)(52 * *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * (unsigned __int16)a1) + result + 20);
  }
  return result;
}
// 10145CF4: using guessed type int dword_10145CF4;
// 10145CF8: using guessed type int dword_10145CF8;

//----- (10014940) --------------------------------------------------------
char __cdecl sub_10014940(int a1)
{
  unsigned int v1; // eax@2
  char v2; // bl@3
  int v3; // eax@5
  int v4; // ecx@5
  __int16 v5; // si@8
  int v6; // eax@8
  char v8; // [sp+0h] [bp-168h]@8

  if ( !dword_101404DC || (v1 = sub_1004E4B0(), dword_101404DC <= v1) )
  {
    v2 = byte_101404D9;
    if ( (unsigned __int8)byte_101404D9 >= 0x32u )
    {
      v2 = 0;
      byte_101404D9 = 0;
    }
    v3 = 30 * (unsigned __int8)v2;
    v4 = 30;
    if ( v3 + 30 > 1473 )
    {
      v4 = 1473 - v3;
      if ( 1473 - v3 <= 0 )
      {
        v2 = 0;
        v4 = 30;
        byte_101404D9 = 0;
      }
    }
    v5 = j_reg_get_xfil_tag_data(&v8, 30 * (unsigned __int8)v2, v4);
    v6 = sub_1004E4B0();
    LOBYTE(v1) = sub_1000ED20(a1, 12 * v5, 1, (int)&byte_10236500, &v8, v6);
    ++byte_101404D9;
  }
  return v1;
}
// 1004E7B0: using guessed type int __cdecl j_reg_get_xfil_tag_data(_DWORD, _DWORD, _DWORD);
// 101404D9: using guessed type char byte_101404D9;
// 101404DC: using guessed type int dword_101404DC;
// 10236500: using guessed type char byte_10236500;

//----- (10014A00) --------------------------------------------------------
__int16 __thiscall sub_10014A00(void *this)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = sub_1001B4A0(this);
  return word_10086B0C[4 * sub_1001DC80(&v2, 4u, (int)&unk_10086B08, 8, 7, 0)];
}
// 10086B0C: using guessed type __int16 word_10086B0C[];

//----- (10014A30) --------------------------------------------------------
char __cdecl sub_10014A30(int a1, int a2, unsigned __int16 a3)
{
  signed int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned __int8 v5; // bl@1
  int v6; // esi@8
  unsigned int v7; // ebp@8
  unsigned int v8; // edi@9
  int v9; // edi@15
  int v10; // ecx@20
  char v12; // [sp+13h] [bp-29h]@1
  char v13[8]; // [sp+14h] [bp-28h]@2
  int v14[7]; // [sp+1Ch] [bp-20h]@15

  v3 = a3 / 0xCu;
  LOBYTE(v4) = sub_10019650(a1);
  v5 = v4;
  v12 = 0;
  if ( byte_101404D8 == 2 )
    LOBYTE(v4) = sub_1004E7C0(41101, (int)v13, 36);
  if ( (unsigned int)(v3 - 1) <= 0x4D && !(a3 % 0xCu) )
  {
    if ( !dword_101404DC || (v4 = sub_1004E4B0(), dword_101404DC <= v4) )
    {
      if ( v3 > 0 )
      {
        v6 = a2 + 2;
        v7 = a3 / 0xCu;
        while ( 1 )
        {
          v4 = j_REG_pvg_xfil_shld_rqst_tag(v6 - 2);
          v8 = v4;
          if ( v4 == 2 )
            LOBYTE(v4) = sub_100148A0(a1, *(_WORD *)v6, *(_WORD *)(v6 + 8));
          if ( byte_101404D8 != 2 )
            goto LABEL_22;
          if ( v5 == 7 )
            goto LABEL_22;
          LOBYTE(v4) = sub_10009850(*(_WORD *)v6);
          if ( !(_BYTE)v4 )
            goto LABEL_22;
          if ( v8 != 1 )
          {
            v10 = *(_WORD *)v6;
            v4 = v5;
            v13[v4] = 0;
            v14[v4] = v10;
            goto LABEL_21;
          }
          v4 = *(_WORD *)v6;
          v9 = v14[v5];
          if ( v4 == v9 )
          {
            v4 = (unsigned int)&v13[v5];
            if ( v13[v5] != 1 )
            {
              *(_BYTE *)v4 = 1;
LABEL_21:
              v12 = 1;
              goto LABEL_22;
            }
          }
          else if ( v9 == 42066 )
          {
            v14[v5] = v4;
            goto LABEL_21;
          }
LABEL_22:
          v6 += 12;
          if ( !--v7 )
          {
            if ( v12 )
              LOBYTE(v4) = sub_1004E8F0(41101, (int)v13, 36);
            return v4;
          }
        }
      }
    }
  }
  return v4;
}
// 1004EA00: using guessed type int __cdecl j_REG_pvg_xfil_shld_rqst_tag(_DWORD);
// 101404D8: using guessed type char byte_101404D8;
// 101404DC: using guessed type int dword_101404DC;
// 10014A30: using guessed type char var_28[8];
// 10014A30: using guessed type int var_20[7];

//----- (10014B90) --------------------------------------------------------
char __cdecl sub_10014B90(const void *a1, unsigned __int16 a2, int a3)
{
  void *v3; // ecx@0
  int v4; // esi@1
  int v5; // eax@1

  v4 = (unsigned __int16)sub_10014A00(v3);
  v5 = sub_1004E4B0();
  sub_1000ED20(v4, a2, 1, (int)&byte_10236500, a1, v5);
  return sub_1000F010(v4, a3, (int)&byte_10236500);
}
// 10236500: using guessed type char byte_10236500;

//----- (10014BD0) --------------------------------------------------------
char __cdecl sub_10014BD0(int a1, int a2)
{
  int v2; // eax@2
  int v3; // eax@4
  int v5; // [sp+8h] [bp-4h]@1

  memset(&unk_10145D08, 0, 0x3A8u);
  if ( sub_1000F640(a1, a2, &unk_10145D08, (unsigned __int16 *)&v5) == 1 )
  {
    v2 = sub_10014DB0(a1);
    sub_10014A30(v2, (int)&unk_10145D08, v5);
  }
  if ( dword_10145CF8 || (LOBYTE(v3) = sub_1001BD80(63), (_BYTE)v3) )
  {
    v3 = ~*(_DWORD *)(52 * *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * (unsigned __int16)a1) + *(_DWORD *)(a2 + 32) + 20);
    dword_10145CF8 &= v3;
    if ( !dword_10145CF8 )
      LOBYTE(v3) = sub_1001BE10(63);
  }
  return v3;
}
// 10145CF8: using guessed type int dword_10145CF8;

//----- (10014C60) --------------------------------------------------------
int __cdecl sub_10014C60(int a1, __int16 a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // eax@5
  bool v6; // zf@6

  dword_101404E0 = 0;
  dword_101404E4 = 0;
  dword_101404E8 = 0;
  dword_101404EC = 0;
  byte_101404F0 = 0;
  result = j_REG_pvg_xfil_read_data(a1, &dword_101404E0, 22545, 1436);
  v4 = result;
  if ( result >= 0 && result )
  {
    if ( a1 == -1 || a2 == (_WORD)dword_101404E4 )
    {
      sub_10014B90(&dword_101404E0, result, a3);
      v5 = 0;
      while ( 1 )
      {
        v6 = *(int *)((char *)&dword_101404E8 + v5) == 3134;
        v5 += *(_WORD *)((char *)&dword_101404E4 + v5) + 17;
        if ( v6 )
          break;
        if ( v5 >= v4 )
          return v4;
      }
      dword_101404DC = sub_1004E4B0() + 7000;
    }
    result = v4;
  }
  return result;
}
// 1004E9F0: using guessed type int __cdecl j_REG_pvg_xfil_read_data(_DWORD, _DWORD, _DWORD, _DWORD);
// 101404DC: using guessed type int dword_101404DC;
// 101404E0: using guessed type int dword_101404E0;
// 101404E4: using guessed type int dword_101404E4;
// 101404E8: using guessed type int dword_101404E8;
// 101404EC: using guessed type int dword_101404EC;
// 101404F0: using guessed type char byte_101404F0;

//----- (10014D10) --------------------------------------------------------
char __cdecl sub_10014D10(int a1, int a2)
{
  char result; // al@1
  int v3; // [sp+0h] [bp-Ch]@1
  int v4; // [sp+4h] [bp-8h]@1
  int v5; // [sp+8h] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  v5 = 0;
  result = sub_1000F620(a1, a2, &v3);
  if ( result == 1 )
    result = sub_10014C60(v3, v5, v4);
  return result;
}

//----- (10014D60) --------------------------------------------------------
int sub_10014D60()
{
  signed int v0; // esi@1
  int result; // eax@2

  v0 = 0;
  do
  {
    result = sub_10014C60(-1, 0, 0xFFFFFFF);
    if ( result <= 0 )
      break;
    ++v0;
  }
  while ( v0 < 10 );
  if ( v0 <= 0 || dword_10145CF4 > 50 )
  {
    result = j_REG_pvg_flush_que(0, 1, 12);
    dword_10145CF4 = 0;
  }
  else
  {
    ++dword_10145CF4;
  }
  return result;
}
// 1004E730: using guessed type int __cdecl j_REG_pvg_flush_que(_DWORD, _DWORD, _DWORD);
// 10145CF4: using guessed type int dword_10145CF4;

//----- (10014DB0) --------------------------------------------------------
int __cdecl sub_10014DB0(char a1)
{
  return dword_100870C4[2 * sub_1001DC80(&a1, 2u, (int)&unk_100870C0, 8, 7, 0)];
}
// 100870C4: using guessed type int dword_100870C4[];

//----- (10014DE0) --------------------------------------------------------
char __cdecl sub_10014DE0(char a1, unsigned __int8 a2)
{
  unsigned __int8 v2; // dl@1
  char v3; // bl@1
  char v4; // cl@2
  unsigned int v5; // edi@7
  int v6; // eax@9
  unsigned int v7; // eax@32
  bool v8; // cf@32
  bool v9; // zf@32
  bool v10; // dl@33
  unsigned int v11; // esi@35
  char *v12; // ebp@36
  int v13; // ebx@36
  size_t v14; // eax@36
  unsigned int v15; // esi@36
  unsigned int v16; // eax@36
  _DWORD *v17; // ecx@36
  int v18; // eax@40
  unsigned int v19; // eax@42
  void *v20; // ecx@42
  unsigned int v21; // edi@42
  int v22; // ecx@68
  int v23; // eax@68
  int v24; // edi@69
  int v25; // eax@75
  char v27; // [sp+7h] [bp-2FDh]@1
  unsigned int v28; // [sp+8h] [bp-2FCh]@32
  unsigned int v29; // [sp+Ch] [bp-2F8h]@7
  int v30; // [sp+10h] [bp-2F4h]@36
  size_t v31; // [sp+14h] [bp-2F0h]@36
  int v32; // [sp+18h] [bp-2ECh]@54
  char v33; // [sp+1Ch] [bp-2E8h]@65
  char v34; // [sp+5Ch] [bp-2A8h]@66
  char v35; // [sp+C4h] [bp-240h]@50
  __int16 v36; // [sp+C6h] [bp-23Eh]@52
  int v37; // [sp+C8h] [bp-23Ch]@52
  int v38; // [sp+CCh] [bp-238h]@52
  char v39; // [sp+D0h] [bp-234h]@52
  char v40; // [sp+D7h] [bp-22Dh]@52
  char v41; // [sp+D8h] [bp-22Ch]@52
  int v42; // [sp+DCh] [bp-228h]@52
  int v43; // [sp+1A0h] [bp-164h]@62
  char v44; // [sp+1C0h] [bp-144h]@51
  __int16 v45; // [sp+1C2h] [bp-142h]@52
  int v46; // [sp+1C4h] [bp-140h]@52
  int v47; // [sp+1C8h] [bp-13Ch]@52
  char v48; // [sp+1CCh] [bp-138h]@52
  char v49; // [sp+1D3h] [bp-131h]@52
  char v50; // [sp+1D4h] [bp-130h]@52
  int v51; // [sp+1D8h] [bp-12Ch]@52
  int v52; // [sp+29Ch] [bp-68h]@62
  int v53; // [sp+2BCh] [bp-48h]@67
  __int16 v54; // [sp+2C0h] [bp-44h]@67
  char v55; // [sp+2C2h] [bp-42h]@67
  char v56; // [sp+2C4h] [bp-40h]@36

  memset(&unk_10153030, 0, 0x70u);
  sub_100336D0(&unk_10153030, 2);
  sub_100351C0((int)&unk_10154C14, 2);
  sub_10020BB0((int)&unk_101460B0, 2);
  sub_100349B0((int)&unk_101494F0, 2);
  sub_100338F0((unsigned __int8 *)&unk_101462D2, 2);
  memset(&unk_101460D0, 0, 0x202u);
  sub_10022F30((int)&unk_101460D0, 2);
  memset(&unk_10149620, 0, 0x3Eu);
  sub_100227F0(&unk_10149620, 2);
  memset(&unk_10149500, 0, 0x120u);
  memset(&unk_101492F0, 0, 0x200u);
  sub_10035150((int)&unk_101492F0, 2);
  memset(&unk_10154C18, 0, 0x108u);
  sub_10034AB0(&unk_10154C18, 2);
  memset(&unk_10154D20, 0, 0x208u);
  sub_100345E0(&unk_10154D20, 2);
  sub_10034C90((int)&unk_10148C0C, 2);
  sub_10034450((unsigned __int8 *)&unk_101462D3, 2);
  sub_10033770((int)&unk_101460B4, 2);
  sub_10033B00((int)&unk_10148B68, 2);
  sub_10034EE0((int)&unk_10148C18, 2);
  sub_10034C20((unsigned __int8 *)&unk_101534A0, 2);
  memset(&unk_101462D8, 0, 0x2890u);
  sub_10034390((int)&unk_101530A0, 2);
  sub_10033EF0(&unk_10148C14, 2);
  sub_10033E20((int)&unk_101462D4, 2);
  sub_10033E20((int)&unk_101462D4, 2);
  sub_10034CE0((int)&unk_10153470, 2);
  sub_10034DD0((int)&unk_10153200, 2);
  sub_100346D0((int)&unk_101530C0, 2);
  v2 = a2;
  v3 = 1;
  v27 = 1;
  if ( a2 >= 3u )
    return 0;
  v4 = a1;
  if ( a1 != 11 && a1 != 32 && a1 != 22 && a1 != 30 && a1 != 31 )
    return 0;
  v5 = 0;
  v29 = 0;
  while ( 1 )
  {
    v6 = *(int *)((char *)&dword_10087F58 + v5);
    if ( (v6 == 14 || v6 == 22 || v6 == 15) && v4 == 30
      || (v6 == 12 || v6 == 21 || v6 == 13) && v4 == 22
      || (v6 == 23 || v6 == 24 || v6 == 25) && v4 == 31
      || v4 == 11
      || v4 == 32
      || v6 == 18 )
    {
      if ( (v6 == 6 || v6 == 40 || v6 == 42) && (!v2 || v2 == 2) )
      {
        v11 = *(int *)((char *)&dword_10087F5C + v5);
        v8 = v11 < *(int *)((char *)&dword_10087F60 + v5);
        v9 = v11 == *(int *)((char *)&dword_10087F60 + v5);
        v28 = *(int *)((char *)&dword_10087F5C + v5);
        if ( !v8 && !v9 )
          goto LABEL_83;
        while ( 2 )
        {
          v12 = 0;
          v13 = 0;
          LOBYTE(v30) = a2;
          v14 = j_reg_get_tag_info(v11, &v56);
          v15 = v28;
          v31 = v14;
          v16 = 0;
          v17 = &unk_10104B74;
          while ( *v17 != v28 )
          {
            ++v16;
            v17 = (_DWORD *)((char *)v17 + 10);
            if ( v16 > 0x120 )
              goto LABEL_42;
          }
          v18 = 5 * v16;
          v9 = byte_10104B78[2 * v18] == 0;
          LOBYTE(v30) = byte_10104B79[2 * v18];
          if ( v9 || a1 != 32 )
          {
LABEL_42:
            v19 = sub_1001DC80(&v28, 4u, (int)&unk_1008EC58, 12, 1074, 1074);
            v21 = v19;
            if ( v19 >= 0x432 )
              goto LABEL_55;
            v15 = v28;
            if ( v28 > 0x1A6E )
            {
              switch ( v28 )
              {
                case 0x1A8Du:
                case 0x1A8Eu:
                  goto LABEL_65;
                case 0x1A9Bu:
                case 0x1A9Cu:
                case 0x1A9Du:
                case 0x1A9Eu:
                case 0x1A9Fu:
                case 0x1AA0u:
                case 0x1AA1u:
                  memset(&v34, 0, 0x68u);
                  sub_1004FC80((int)&v34);
                  v12 = &v34;
                  v13 = 104;
                  goto LABEL_55;
                case 0x1B1Bu:
                  v53 = 0;
                  v54 = 0;
                  v55 = 0;
                  sub_1004E970(v28, (int)&v53, 7);
                  goto LABEL_55;
                default:
                  goto LABEL_68;
              }
              goto LABEL_68;
            }
            if ( v28 >= 0x1A6A )
            {
LABEL_65:
              memset(&v33, 0, 0x40u);
              sub_1004F930((int)&v33);
              v12 = &v33;
              v13 = 64;
              goto LABEL_55;
            }
            if ( v28 > 0x17D7 )
            {
              if ( v28 != 6455 )
                goto LABEL_68;
              memset(&v35, 0, 0xFCu);
              memcpy(&v35, (const void *)dword_1008EC5C[3 * v21], (unsigned __int16)word_1008EC60[6 * v21]);
              if ( a1 == 32 )
              {
                memset(&v44, 0, 0xFCu);
                if ( sub_1004E7C0(6455, (int)&v44, 252) )
                  return 0;
                v15 = v28;
                v43 = v52;
              }
              v12 = &v35;
              v13 = 252;
LABEL_56:
              if ( v15 != 6103 )
              {
                if ( v12 )
                {
                  if ( (v15 < 0x9C40 || v15 > 0x9D6C) && v15 - 42000 > 0x41 )
                    v25 = sub_1004E910(v15, (int)v12, v13);
                  else
                    v25 = sub_1004E8F0(v15, (int)v12, v13);
                  v27 &= v25 == 0;
                }
                else
                {
                  v27 &= sub_1004EA20(v15, v30) == 0;
                }
                v15 = v28;
              }
            }
            else if ( v28 != 6103 )
            {
              if ( v28 == 6005 )
              {
                v32 = sub_1001B4A0(v20);
                v12 = (char *)&v32;
                v13 = 4;
              }
              else
              {
                if ( v28 > 0x17CC && v28 <= 0x17CE )
                {
                  memset(&v35, 0, 0xFCu);
                  memcpy(&v35, (const void *)dword_1008EC5C[3 * v21], (unsigned __int16)word_1008EC60[6 * v21]);
                  if ( a1 == 32 )
                  {
                    memset(&v44, 0, 0xFCu);
                    if ( sub_1004E7C0(v15, (int)&v44, 60) )
                      return 0;
                    v15 = v28;
                    v37 = v46;
                    v39 = v48;
                    v38 = v47;
                    v36 = v45;
                    v42 = v51;
                    v40 = v49;
                    v41 = v50;
                  }
                  v12 = &v35;
                  v13 = 60;
                  goto LABEL_56;
                }
LABEL_68:
                v22 = dword_1008EC5C[3 * v19];
                v23 = 6 * v19;
                if ( v22 )
                {
                  v13 = (unsigned __int16)word_1008EC60[v23];
                  v12 = (char *)dword_1008EC5C[3 * v21];
                  goto LABEL_56;
                }
                v24 = v31;
                memset(&unk_10154F28, 0, v31);
                if ( sub_1004E770(v15, (int)&unk_10154F28, v24) == -46 )
                {
                  v12 = (char *)&unk_10154F28;
                  v13 = (unsigned __int16)v24;
                }
              }
LABEL_55:
              v15 = v28;
              goto LABEL_56;
            }
            v5 = v29;
          }
          v11 = v15 + 1;
          v8 = v11 < *(int *)((char *)&dword_10087F60 + v5);
          v9 = v11 == *(int *)((char *)&dword_10087F60 + v5);
          v28 = v11;
          if ( v8 || v9 )
            continue;
          break;
        }
        v3 = v27;
LABEL_82:
        v4 = a1;
        goto LABEL_83;
      }
      if ( v6 != 6 && v6 != 40 && v6 != 42 )
      {
        v7 = *(int *)((char *)&dword_10087F5C + v5);
        v8 = v7 < *(int *)((char *)&dword_10087F60 + v5);
        v9 = v7 == *(int *)((char *)&dword_10087F60 + v5);
        v28 = *(int *)((char *)&dword_10087F5C + v5);
        if ( v8 || v9 )
        {
          do
          {
            v10 = sub_1004EA20(v7, a2) == 0;
            v7 = v28 + 1;
            v3 &= v10;
            v8 = v28 + 1 < *(int *)((char *)&dword_10087F60 + v5);
            v9 = v28++ + 1 == *(int *)((char *)&dword_10087F60 + v5);
          }
          while ( v8 || v9 );
          v27 = v3;
          goto LABEL_82;
        }
      }
    }
LABEL_83:
    v5 += 12;
    v29 = v5;
    if ( v5 >= 0xD8 )
      return v3;
    v2 = a2;
  }
}
// 1004E7A0: using guessed type int __cdecl j_reg_get_tag_info(_DWORD, _DWORD);
// 10087F58: using guessed type int dword_10087F58;
// 10087F5C: using guessed type int dword_10087F5C;
// 10087F60: using guessed type int dword_10087F60;
// 1008EC5C: using guessed type int dword_1008EC5C[];
// 1008EC60: using guessed type __int16 word_1008EC60[];

//----- (100155E0) --------------------------------------------------------
void *__usercall sub_100155E0@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@0
  int v5; // [sp+4h] [bp-8h]@0
  int v6; // [sp+8h] [bp-4h]@0

  result = (void *)sub_1004E7C0(v4, v5, v6);
  if ( a2 == 6011 )
  {
    if ( result || *(_BYTE *)a3 > 0x3Fu )
    {
      *(_BYTE *)a3 = 63;
      result = (void *)sub_1004E970(6011, (int)a3, a1);
    }
  }
  else if ( result )
  {
    result = memset(a3, 204, a1);
  }
  return result;
}

//----- (10015630) --------------------------------------------------------
signed int sub_10015630()
{
  int v0; // edi@5
  void *v1; // esi@5
  signed int v2; // ebp@5
  signed int result; // eax@7
  char v4; // [sp+13h] [bp-1h]@1

  dword_1022D6E8 = 0;
  v4 = 0;
  sub_1004EEB0(94, &v4);
  if ( v4 == 3 )
  {
    v4 = 1;
    sub_1004E8F0(3201, (int)&v4, 1);
    sub_1004EEE0(94, (int)&v4);
  }
  else if ( v4 == 2 )
  {
    v4 = 0;
    sub_1004E8F0(3201, (int)&v4, 1);
    sub_1004EEE0(94, (int)&v4);
  }
  sub_100155E0(1u, 6011, &unk_10149660);
  sub_100155E0(0x16u, 6194, &unk_10149661);
  sub_100155E0(1u, 6012, &unk_10149677);
  sub_100155E0(1u, 6013, &unk_10149678);
  sub_100155E0(1u, 6014, &unk_10149679);
  sub_100155E0(1u, 6015, &unk_1014967A);
  sub_100155E0(4u, 6078, &unk_1014967C);
  sub_100155E0(4u, 6104, &unk_10149680);
  sub_100155E0(0x20u, 6016, &unk_10149684);
  sub_100155E0(0x20u, 6017, &unk_101496A4);
  sub_100155E0(0x20u, 6018, &unk_101496C4);
  sub_100155E0(0x20u, 6019, &unk_101496E4);
  sub_100155E0(0x20u, 6020, &unk_10149704);
  sub_100155E0(0x20u, 6021, &unk_10149724);
  sub_100155E0(0x20u, 6022, &unk_10149744);
  sub_100155E0(0x20u, 6023, &unk_10149764);
  sub_100155E0(0x20u, 6024, &unk_10149784);
  sub_100155E0(0x20u, 6025, &unk_101497A4);
  sub_100155E0(0x20u, 6026, &unk_101497C4);
  sub_100155E0(0x20u, 6027, &unk_101497E4);
  sub_100155E0(0x20u, 6028, &unk_10149804);
  sub_100155E0(0x20u, 6029, &unk_10149824);
  sub_100155E0(0x20u, 6030, &unk_10149844);
  sub_100155E0(0x20u, 6031, &unk_10149864);
  sub_100155E0(0x20u, 6032, &unk_10149884);
  sub_100155E0(0x20u, 6033, &unk_101498A4);
  sub_100155E0(0x20u, 6034, &unk_101498C4);
  sub_100155E0(0x20u, 6035, &unk_101498E4);
  sub_100155E0(0x20u, 6036, &unk_10149904);
  sub_100155E0(0x20u, 6037, &unk_10149924);
  sub_100155E0(0x20u, 6038, &unk_10149944);
  sub_100155E0(0x20u, 6039, &unk_10149964);
  sub_100155E0(0x20u, 6040, &unk_10149984);
  sub_100155E0(0x20u, 6041, &unk_101499A4);
  sub_100155E0(0x20u, 6042, &unk_101499C4);
  sub_100155E0(0x20u, 6043, &unk_101499E4);
  sub_100155E0(4u, 6044, &unk_10149A04);
  sub_100155E0(4u, 6045, &unk_10149A08);
  sub_100155E0(4u, 6046, &unk_10149A0C);
  sub_100155E0(4u, 6357, &unk_10149A10);
  sub_100155E0(4u, 6358, &unk_10149A14);
  sub_100155E0(4u, 6359, &unk_10149A18);
  sub_100155E0(0x20u, 6047, &unk_10149A1C);
  sub_100155E0(0x20u, 6048, &unk_10149A3C);
  sub_100155E0(0x20u, 6049, &unk_10149A5C);
  sub_100155E0(0x20u, 6050, &unk_10149A7C);
  sub_100155E0(0x20u, 6051, &unk_10149A9C);
  sub_100155E0(0x20u, 6052, &unk_10149ABC);
  sub_100155E0(0x20u, 6053, &unk_10149ADC);
  sub_100155E0(0x20u, 6054, &unk_10149AFC);
  sub_100155E0(1u, 6511, &unk_10149B1C);
  sub_100155E0(1u, 6522, &unk_10149B1D);
  sub_100155E0(1u, 6057, &unk_10149B1E);
  sub_100155E0(0x20u, 6075, &unk_10149B70);
  sub_100155E0(0x20u, 6076, &unk_10149B90);
  sub_100155E0(1u, 6077, &unk_10149BB0);
  sub_100155E0(4u, 6079, &unk_10149BB4);
  sub_100155E0(4u, 6080, &unk_10149BB8);
  sub_100155E0(0x20u, 6082, &unk_10149BBC);
  sub_100155E0(0x20u, 6083, &unk_10149BDC);
  sub_100155E0(0x20u, 6084, &unk_10149BFC);
  sub_100155E0(0x20u, 6085, &unk_10149C1C);
  sub_100155E0(0x20u, 6086, &unk_10149C3C);
  sub_100155E0(0x20u, 6087, &unk_10149C5C);
  sub_100155E0(0x20u, 6088, &unk_10149C7C);
  sub_100155E0(0x20u, 6089, &unk_10149C9C);
  sub_100155E0(0x20u, 6123, &unk_10149CBC);
  sub_100155E0(0x48u, 6906, &unk_10149CDC);
  sub_100155E0(0x48u, 6907, &unk_10149D24);
  sub_100155E0(0x48u, 6908, &unk_10149D6C);
  sub_100155E0(0x48u, 6909, &unk_10149DB4);
  sub_100155E0(0x48u, 6910, &unk_10149DFC);
  sub_100155E0(0x48u, 6911, &unk_10149E44);
  sub_100155E0(0x48u, 6912, &unk_10149E8C);
  sub_100155E0(0x48u, 6913, &unk_10149ED4);
  sub_100155E0(0x48u, 6914, &unk_10149F1C);
  sub_100155E0(0x48u, 6915, &unk_10149F64);
  sub_100155E0(0x48u, 6916, &unk_10149FAC);
  sub_100155E0(0x48u, 6917, &unk_10149FF4);
  sub_100155E0(0x48u, 6918, &unk_1014A03C);
  sub_100155E0(0x48u, 6919, &unk_1014A084);
  sub_100155E0(0x48u, 6920, &unk_1014A0CC);
  sub_100155E0(0x48u, 6921, &unk_1014A114);
  sub_100155E0(0x48u, 6922, &unk_1014A15C);
  sub_100155E0(0x48u, 6923, &unk_1014A1A4);
  sub_100155E0(0x48u, 6924, &unk_1014A1EC);
  sub_100155E0(0x48u, 6925, &unk_1014A234);
  sub_100155E0(0x48u, 6926, &unk_1014A27C);
  sub_100155E0(0x48u, 6927, &unk_1014A2C4);
  sub_100155E0(0x48u, 6928, &unk_1014A30C);
  sub_100155E0(0x48u, 6929, &unk_1014A354);
  sub_100155E0(0x48u, 6930, &unk_1014A39C);
  sub_100155E0(0x48u, 6931, &unk_1014A3E4);
  sub_100155E0(0x48u, 6932, &unk_1014A42C);
  sub_100155E0(0x48u, 6933, &unk_1014A474);
  sub_100155E0(0x48u, 6934, &unk_1014A4BC);
  sub_100155E0(0x48u, 6935, &unk_1014A504);
  sub_100155E0(0x18u, 6163, &unk_1014A54C);
  sub_100155E0(0x20u, 6164, &unk_1014A564);
  sub_100155E0(0x20u, 6165, &unk_1014A584);
  sub_100155E0(2u, 6166, &unk_1014A5A4);
  sub_100155E0(0xA4u, 40100, &unk_1014A5A8);
  sub_100155E0(0xA4u, 40101, &unk_1014A64C);
  sub_100155E0(0xA4u, 40102, &unk_1014A6F0);
  sub_100155E0(0xA4u, 40103, &unk_1014A794);
  sub_100155E0(0xA4u, 40104, &unk_1014A838);
  sub_100155E0(0xA4u, 40105, &unk_1014A8DC);
  sub_100155E0(0xA4u, 40106, &unk_1014A980);
  sub_100155E0(0xA4u, 40107, &unk_1014AA24);
  sub_100155E0(0xA4u, 40108, &unk_1014AAC8);
  sub_100155E0(0xA4u, 40109, &unk_1014AB6C);
  sub_100155E0(0xA4u, 40110, &unk_1014AC10);
  sub_100155E0(0xA4u, 40111, &unk_1014ACB4);
  sub_100155E0(0xA4u, 40112, &unk_1014AD58);
  sub_100155E0(0xA4u, 40113, &unk_1014ADFC);
  sub_100155E0(0xA4u, 40114, &unk_1014AEA0);
  sub_100155E0(0xA4u, 40115, &unk_1014AF44);
  sub_100155E0(0xA4u, 40116, &unk_1014AFE8);
  sub_100155E0(0xA4u, 40117, &unk_1014B08C);
  sub_100155E0(0xA4u, 40118, &unk_1014B130);
  sub_100155E0(0xA4u, 40119, &unk_1014B1D4);
  sub_100155E0(0xA4u, 40120, &unk_1014B278);
  sub_100155E0(0xA4u, 40121, &unk_1014B31C);
  sub_100155E0(0xA4u, 40122, &unk_1014B3C0);
  sub_100155E0(0xA4u, 40123, &unk_1014B464);
  sub_100155E0(0xA4u, 40124, &unk_1014B508);
  sub_100155E0(0xA4u, 40125, &unk_1014B5AC);
  sub_100155E0(0xA4u, 40126, &unk_1014B650);
  sub_100155E0(0xA4u, 40127, &unk_1014B6F4);
  sub_100155E0(0xA4u, 40128, &unk_1014B798);
  sub_100155E0(0xA4u, 40129, &unk_1014B83C);
  sub_100155E0(0xA4u, 40130, &unk_1014B8E0);
  sub_100155E0(0xA4u, 40131, &unk_1014B984);
  sub_100155E0(0xA4u, 40132, &unk_1014BA28);
  sub_100155E0(0xA4u, 40133, &unk_1014BACC);
  sub_100155E0(0xA4u, 40134, &unk_1014BB70);
  sub_100155E0(0xA4u, 40135, &unk_1014BC14);
  sub_100155E0(0xA4u, 40136, &unk_1014BCB8);
  sub_100155E0(0xA4u, 40137, &unk_1014BD5C);
  sub_100155E0(0xA4u, 40138, &unk_1014BE00);
  sub_100155E0(0xA4u, 40139, &unk_1014BEA4);
  sub_100155E0(0xA4u, 40140, &unk_1014BF48);
  sub_100155E0(0xA4u, 40141, &unk_1014BFEC);
  sub_100155E0(0xA4u, 40142, &unk_1014C090);
  sub_100155E0(0xA4u, 40143, &unk_1014C134);
  sub_100155E0(0xA4u, 40144, &unk_1014C1D8);
  sub_100155E0(0xA4u, 40145, &unk_1014C27C);
  sub_100155E0(0xA4u, 40146, &unk_1014C320);
  sub_100155E0(0xA4u, 40147, &unk_1014C3C4);
  sub_100155E0(0xA4u, 40148, &unk_1014C468);
  sub_100155E0(0xA4u, 40149, &unk_1014C50C);
  sub_100155E0(0xA4u, 40150, &unk_1014C5B0);
  sub_100155E0(0xA4u, 40151, &unk_1014C654);
  sub_100155E0(0xA4u, 40152, &unk_1014C6F8);
  sub_100155E0(0xA4u, 40153, &unk_1014C79C);
  sub_100155E0(0xA4u, 40154, &unk_1014C840);
  sub_100155E0(0xA4u, 40155, &unk_1014C8E4);
  sub_100155E0(0xA4u, 40156, &unk_1014C988);
  sub_100155E0(0xA4u, 40157, &unk_1014CA2C);
  sub_100155E0(0xA4u, 40158, &unk_1014CAD0);
  sub_100155E0(0xA4u, 40159, &unk_1014CB74);
  sub_100155E0(0xA4u, 40160, &unk_1014CC18);
  sub_100155E0(0xA4u, 40161, &unk_1014CCBC);
  sub_100155E0(0xA4u, 40162, &unk_1014CD60);
  sub_100155E0(0xA4u, 40163, &unk_1014CE04);
  sub_100155E0(0xA4u, 40164, &unk_1014CEA8);
  sub_100155E0(0xA4u, 40165, &unk_1014CF4C);
  sub_100155E0(0xA4u, 40166, &unk_1014CFF0);
  sub_100155E0(0xA4u, 40167, &unk_1014D094);
  sub_100155E0(0xA4u, 40168, &unk_1014D138);
  sub_100155E0(0xA4u, 40169, &unk_1014D1DC);
  sub_100155E0(0xA4u, 40170, &unk_1014D280);
  sub_100155E0(0xA4u, 40171, &unk_1014D324);
  sub_100155E0(0xA4u, 40172, &unk_1014D3C8);
  sub_100155E0(0xA4u, 40173, &unk_1014D46C);
  sub_100155E0(0xA4u, 40174, &unk_1014D510);
  sub_100155E0(0xA4u, 40175, &unk_1014D5B4);
  sub_100155E0(0xA4u, 40176, &unk_1014D658);
  sub_100155E0(0xA4u, 40177, &unk_1014D6FC);
  sub_100155E0(0xA4u, 40178, &unk_1014D7A0);
  sub_100155E0(0xA4u, 40179, &unk_1014D844);
  sub_100155E0(0xA4u, 40180, &unk_1014D8E8);
  sub_100155E0(0xA4u, 40181, &unk_1014D98C);
  sub_100155E0(0xA4u, 40182, &unk_1014DA30);
  sub_100155E0(0xA4u, 40183, &unk_1014DAD4);
  sub_100155E0(0xA4u, 40184, &unk_1014DB78);
  sub_100155E0(0xA4u, 40185, &unk_1014DC1C);
  sub_100155E0(0xA4u, 40186, &unk_1014DCC0);
  sub_100155E0(0xA4u, 40187, &unk_1014DD64);
  sub_100155E0(0xA4u, 40188, &unk_1014DE08);
  sub_100155E0(0xA4u, 40189, &unk_1014DEAC);
  sub_100155E0(0xA4u, 40190, &unk_1014DF50);
  sub_100155E0(0xA4u, 40191, &unk_1014DFF4);
  sub_100155E0(0xA4u, 40192, &unk_1014E098);
  sub_100155E0(0xA4u, 40193, &unk_1014E13C);
  sub_100155E0(0xA4u, 40194, &unk_1014E1E0);
  sub_100155E0(0xA4u, 40195, &unk_1014E284);
  sub_100155E0(0xA4u, 40196, &unk_1014E328);
  sub_100155E0(0xA4u, 40197, &unk_1014E3CC);
  sub_100155E0(0xA4u, 40198, &unk_1014E470);
  sub_100155E0(0xA4u, 40199, &unk_1014E514);
  sub_100155E0(0x20u, 6190, &unk_1014E5B8);
  sub_100155E0(0x20u, 6191, &unk_1014E5D8);
  sub_100155E0(0x20u, 6192, &unk_1014E5F8);
  sub_100155E0(0x20u, 6199, &unk_1014E618);
  sub_100155E0(0x28u, 6207, &unk_1014E638);
  sub_100155E0(4u, 6231, &unk_1014F150);
  sub_100155E0(4u, 6232, &unk_1014F154);
  sub_100155E0(4u, 6233, &unk_1014F158);
  sub_100155E0(4u, 6234, &unk_1014F15C);
  sub_100155E0(0x1Cu, 40000, &unk_1014E660);
  sub_100155E0(0x1Cu, 40001, &unk_1014E67C);
  sub_100155E0(0x1Cu, 40002, &unk_1014E698);
  sub_100155E0(0x1Cu, 40003, &unk_1014E6B4);
  sub_100155E0(0x1Cu, 40004, &unk_1014E6D0);
  sub_100155E0(0x1Cu, 40005, &unk_1014E6EC);
  sub_100155E0(0x1Cu, 40006, &unk_1014E708);
  sub_100155E0(0x1Cu, 40007, &unk_1014E724);
  sub_100155E0(0x1Cu, 40008, &unk_1014E740);
  sub_100155E0(0x1Cu, 40009, &unk_1014E75C);
  sub_100155E0(0x1Cu, 40010, &unk_1014E778);
  sub_100155E0(0x1Cu, 40011, &unk_1014E794);
  sub_100155E0(0x1Cu, 40012, &unk_1014E7B0);
  sub_100155E0(0x1Cu, 40013, &unk_1014E7CC);
  sub_100155E0(0x1Cu, 40014, &unk_1014E7E8);
  sub_100155E0(0x1Cu, 40015, &unk_1014E804);
  sub_100155E0(0x1Cu, 40016, &unk_1014E820);
  sub_100155E0(0x1Cu, 40017, &unk_1014E83C);
  sub_100155E0(0x1Cu, 40018, &unk_1014E858);
  sub_100155E0(0x1Cu, 40019, &unk_1014E874);
  sub_100155E0(0x1Cu, 40020, &unk_1014E890);
  sub_100155E0(0x1Cu, 40021, &unk_1014E8AC);
  sub_100155E0(0x1Cu, 40022, &unk_1014E8C8);
  sub_100155E0(0x1Cu, 40023, &unk_1014E8E4);
  sub_100155E0(0x1Cu, 40024, &unk_1014E900);
  sub_100155E0(0x1Cu, 40025, &unk_1014E91C);
  sub_100155E0(0x1Cu, 40026, &unk_1014E938);
  sub_100155E0(0x1Cu, 40027, &unk_1014E954);
  sub_100155E0(0x1Cu, 40028, &unk_1014E970);
  sub_100155E0(0x1Cu, 40029, &unk_1014E98C);
  sub_100155E0(0x1Cu, 40030, &unk_1014E9A8);
  sub_100155E0(0x1Cu, 40031, &unk_1014E9C4);
  sub_100155E0(0x1Cu, 40032, &unk_1014E9E0);
  sub_100155E0(0x1Cu, 40033, &unk_1014E9FC);
  sub_100155E0(0x1Cu, 40034, &unk_1014EA18);
  sub_100155E0(0x1Cu, 40035, &unk_1014EA34);
  sub_100155E0(0x1Cu, 40036, &unk_1014EA50);
  sub_100155E0(0x1Cu, 40037, &unk_1014EA6C);
  sub_100155E0(0x1Cu, 40038, &unk_1014EA88);
  sub_100155E0(0x1Cu, 40039, &unk_1014EAA4);
  sub_100155E0(0x1Cu, 40040, &unk_1014EAC0);
  sub_100155E0(0x1Cu, 40041, &unk_1014EADC);
  sub_100155E0(0x1Cu, 40042, &unk_1014EAF8);
  sub_100155E0(0x1Cu, 40043, &unk_1014EB14);
  sub_100155E0(0x1Cu, 40044, &unk_1014EB30);
  sub_100155E0(0x1Cu, 40045, &unk_1014EB4C);
  sub_100155E0(0x1Cu, 40046, &unk_1014EB68);
  sub_100155E0(0x1Cu, 40047, &unk_1014EB84);
  sub_100155E0(0x1Cu, 40048, &unk_1014EBA0);
  sub_100155E0(0x1Cu, 40049, &unk_1014EBBC);
  sub_100155E0(0x1Cu, 40050, &unk_1014EBD8);
  sub_100155E0(0x1Cu, 40051, &unk_1014EBF4);
  sub_100155E0(0x1Cu, 40052, &unk_1014EC10);
  sub_100155E0(0x1Cu, 40053, &unk_1014EC2C);
  sub_100155E0(0x1Cu, 40054, &unk_1014EC48);
  sub_100155E0(0x1Cu, 40055, &unk_1014EC64);
  sub_100155E0(0x1Cu, 40056, &unk_1014EC80);
  sub_100155E0(0x1Cu, 40057, &unk_1014EC9C);
  sub_100155E0(0x1Cu, 40058, &unk_1014ECB8);
  sub_100155E0(0x1Cu, 40059, &unk_1014ECD4);
  sub_100155E0(0x1Cu, 40060, &unk_1014ECF0);
  sub_100155E0(0x1Cu, 40061, &unk_1014ED0C);
  sub_100155E0(0x1Cu, 40062, &unk_1014ED28);
  sub_100155E0(0x1Cu, 40063, &unk_1014ED44);
  sub_100155E0(0x1Cu, 40064, &unk_1014ED60);
  sub_100155E0(0x1Cu, 40065, &unk_1014ED7C);
  sub_100155E0(0x1Cu, 40066, &unk_1014ED98);
  sub_100155E0(0x1Cu, 40067, &unk_1014EDB4);
  sub_100155E0(0x1Cu, 40068, &unk_1014EDD0);
  sub_100155E0(0x1Cu, 40069, &unk_1014EDEC);
  sub_100155E0(0x1Cu, 40070, &unk_1014EE08);
  sub_100155E0(0x1Cu, 40071, &unk_1014EE24);
  sub_100155E0(0x1Cu, 40072, &unk_1014EE40);
  sub_100155E0(0x1Cu, 40073, &unk_1014EE5C);
  sub_100155E0(0x1Cu, 40074, &unk_1014EE78);
  sub_100155E0(0x1Cu, 40075, &unk_1014EE94);
  sub_100155E0(0x1Cu, 40076, &unk_1014EEB0);
  sub_100155E0(0x1Cu, 40077, &unk_1014EECC);
  sub_100155E0(0x1Cu, 40078, &unk_1014EEE8);
  sub_100155E0(0x1Cu, 40079, &unk_1014EF04);
  sub_100155E0(0x1Cu, 40080, &unk_1014EF20);
  sub_100155E0(0x1Cu, 40081, &unk_1014EF3C);
  sub_100155E0(0x1Cu, 40082, &unk_1014EF58);
  sub_100155E0(0x1Cu, 40083, &unk_1014EF74);
  sub_100155E0(0x1Cu, 40084, &unk_1014EF90);
  sub_100155E0(0x1Cu, 40085, &unk_1014EFAC);
  sub_100155E0(0x1Cu, 40086, &unk_1014EFC8);
  sub_100155E0(0x1Cu, 40087, &unk_1014EFE4);
  sub_100155E0(0x1Cu, 40088, &unk_1014F000);
  sub_100155E0(0x1Cu, 40089, &unk_1014F01C);
  sub_100155E0(0x1Cu, 40090, &unk_1014F038);
  sub_100155E0(0x1Cu, 40091, &unk_1014F054);
  sub_100155E0(0x1Cu, 40092, &unk_1014F070);
  sub_100155E0(0x1Cu, 40093, &unk_1014F08C);
  sub_100155E0(0x1Cu, 40094, &unk_1014F0A8);
  sub_100155E0(0x1Cu, 40095, &unk_1014F0C4);
  sub_100155E0(0x1Cu, 40096, &unk_1014F0E0);
  sub_100155E0(0x1Cu, 40097, &unk_1014F0FC);
  sub_100155E0(0x1Cu, 40098, &unk_1014F118);
  sub_100155E0(0x1Cu, 40099, &unk_1014F134);
  sub_100155E0(4u, 6238, &unk_1014F160);
  sub_100155E0(4u, 6239, &unk_1014F164);
  sub_100155E0(4u, 6240, &unk_1014F168);
  sub_100155E0(4u, 6242, &unk_1014F16C);
  sub_100155E0(4u, 6244, &unk_1014F170);
  sub_100155E0(4u, 6245, &unk_1014F174);
  sub_100155E0(4u, 6246, &unk_1014F178);
  sub_100155E0(4u, 6251, &unk_1014F17C);
  sub_100155E0(4u, 6252, &unk_1014F180);
  sub_100155E0(4u, 6253, &unk_1014F184);
  sub_100155E0(4u, 6254, &unk_1014F188);
  sub_100155E0(1u, 6255, &unk_1014F18C);
  sub_100155E0(4u, 6256, &unk_1014F190);
  sub_100155E0(4u, 6257, &unk_1014F194);
  sub_100155E0(0xE2u, 6286, &unk_1014F198);
  v0 = 18000;
  v1 = &unk_1014F27C;
  v2 = 16;
  do
  {
    sub_100155E0(0x11Cu, v0, v1);
    v1 = (char *)v1 + 284;
    ++v0;
    --v2;
  }
  while ( v2 );
  sub_100155E0(4u, 6262, &unk_1015043C);
  sub_100155E0(0x28u, 6263, &unk_10150440);
  sub_100155E0(0x28u, 6264, &unk_10150468);
  sub_100155E0(0x40u, 6268, &unk_10150490);
  sub_100155E0(4u, 6272, &unk_10150550);
  sub_100155E0(4u, 6273, &unk_10150554);
  sub_100155E0(1u, 6274, &unk_10150558);
  sub_100155E0(2u, 6275, &unk_1015055A);
  sub_100155E0(1u, 6276, &unk_1015055C);
  sub_100155E0(1u, 6277, &unk_1015055D);
  sub_100155E0(1u, 6278, &unk_1015055E);
  sub_100155E0(0x40u, 6279, &unk_10150560);
  sub_100155E0(0x28u, 6753, &unk_10151415);
  sub_100155E0(0x30u, 6754, &unk_10151440);
  sub_100155E0(0x28u, 6958, &unk_10151470);
  sub_100155E0(0x80u, 6802, &unk_101504D0);
  sub_100155E0(1u, 6760, &unk_10151498);
  sub_100155E0(0x10u, 6312, &unk_101508E4);
  sub_100155E0(0x10u, 6313, &unk_101508F4);
  sub_100155E0(0x10u, 6314, &unk_10150904);
  sub_100155E0(1u, 6307, &unk_10150914);
  sub_100155E0(1u, 6308, &unk_10150915);
  sub_100155E0(1u, 6309, &unk_10150916);
  sub_100155E0(4u, 6285, &unk_10150918);
  sub_100155E0(0xA8u, 6318, &unk_1015091C);
  sub_100155E0(4u, 6319, &unk_101509C4);
  sub_100155E0(1u, 6350, &unk_101509C8);
  sub_100155E0(0x50u, 6351, &unk_101509CC);
  sub_100155E0(4u, 6352, &unk_10150A1C);
  sub_100155E0(4u, 6353, &unk_10150A20);
  sub_100155E0(0x54u, 6448, &unk_10150C6C);
  sub_100155E0(0x54u, 6449, &unk_10150CC0);
  sub_100155E0(8u, 6287, &unk_101505C4);
  sub_100155E0(8u, 6288, &unk_101505CC);
  sub_100155E0(8u, 6289, &unk_101505D4);
  sub_100155E0(8u, 6290, &unk_101505DC);
  sub_100155E0(8u, 6291, &unk_101505E4);
  sub_100155E0(8u, 6292, &unk_101505EC);
  sub_100155E0(8u, 6293, &unk_101505F4);
  sub_100155E0(8u, 6294, &unk_101505FC);
  sub_100155E0(8u, 6295, &unk_10150604);
  sub_100155E0(8u, 6296, &unk_1015060C);
  sub_100155E0(8u, 6297, &unk_10150614);
  sub_100155E0(8u, 6298, &unk_1015061C);
  sub_100155E0(8u, 6299, &unk_10150624);
  sub_100155E0(8u, 6300, &unk_1015062C);
  sub_100155E0(8u, 6301, &unk_10150634);
  sub_100155E0(8u, 6302, &unk_1015063C);
  sub_100155E0(8u, 6303, &unk_10150644);
  sub_100155E0(8u, 6304, &unk_1015064C);
  sub_100155E0(8u, 6305, &unk_10150654);
  sub_100155E0(8u, 6306, &unk_1015065C);
  sub_100155E0(8u, 6409, &unk_10150664);
  sub_100155E0(8u, 6410, &unk_1015066C);
  sub_100155E0(8u, 6411, &unk_10150674);
  sub_100155E0(8u, 6412, &unk_1015067C);
  sub_100155E0(8u, 6413, &unk_10150684);
  sub_100155E0(8u, 6414, &unk_1015068C);
  sub_100155E0(8u, 6415, &unk_10150694);
  sub_100155E0(8u, 6416, &unk_1015069C);
  sub_100155E0(8u, 6417, &unk_101506A4);
  sub_100155E0(8u, 6418, &unk_101506AC);
  sub_100155E0(8u, 6419, &unk_101506B4);
  sub_100155E0(8u, 6420, &unk_101506BC);
  sub_100155E0(8u, 6421, &unk_101506C4);
  sub_100155E0(8u, 6422, &unk_101506CC);
  sub_100155E0(8u, 6423, &unk_101506D4);
  sub_100155E0(8u, 6424, &unk_101506DC);
  sub_100155E0(8u, 6425, &unk_101506E4);
  sub_100155E0(8u, 6426, &unk_101506EC);
  sub_100155E0(8u, 6427, &unk_101506F4);
  sub_100155E0(8u, 6428, &unk_101506FC);
  sub_100155E0(4u, 6429, &unk_10150C04);
  sub_100155E0(8u, 6430, &unk_10150C08);
  sub_100155E0(8u, 6431, &unk_10150C10);
  sub_100155E0(8u, 6432, &unk_10150C18);
  sub_100155E0(8u, 6433, &unk_10150C20);
  sub_100155E0(8u, 6434, &unk_10150C28);
  sub_100155E0(8u, 6435, &unk_10150C30);
  sub_100155E0(8u, 6436, &unk_10150C38);
  sub_100155E0(8u, 6437, &unk_10150C40);
  sub_100155E0(8u, 6438, &unk_10150C48);
  sub_100155E0(8u, 6439, &unk_10150C50);
  sub_100155E0(8u, 6440, &unk_10150C58);
  sub_100155E0(0xAu, 6519, &unk_101510C4);
  sub_100155E0(4u, 6442, &unk_10150C60);
  sub_100155E0(4u, 6443, &unk_10150C64);
  sub_100155E0(0xF0u, 6367, &unk_10150A24);
  sub_100155E0(0xF0u, 6368, &unk_10150B14);
  sub_100155E0(1u, 6446, &unk_10150C68);
  sub_100155E0(6u, 6452, &unk_10150D14);
  sub_100155E0(4u, 6457, &unk_10150D1C);
  sub_100155E0(4u, 6458, &unk_10150D20);
  sub_100155E0(4u, 6459, &unk_10150D24);
  sub_100155E0(4u, 6460, &unk_10150D28);
  sub_100155E0(0x208u, 6515, &unk_10150D2C);
  sub_100155E0(0x160u, 6516, &unk_10150F34);
  sub_100155E0(0x18u, 6517, &unk_10151094);
  sub_100155E0(0x18u, 6518, &unk_101510AC);
  sub_100155E0(1u, 6520, &unk_101510CE);
  sub_100155E0(0x10u, 6521, &unk_101510D0);
  sub_100155E0(4u, 6523, &unk_101510E0);
  sub_100155E0(4u, 6524, &unk_101510E4);
  sub_100155E0(4u, 6525, &unk_101510E8);
  sub_100155E0(1u, 6526, &unk_101510EC);
  sub_100155E0(1u, 6527, &unk_101510ED);
  sub_100155E0(0x50u, 6528, &unk_101510F0);
  sub_100155E0(4u, 6529, &unk_10151140);
  sub_100155E0(1u, 6530, &unk_10151144);
  sub_100155E0(1u, 6531, &unk_10151145);
  sub_100155E0(1u, 6532, &unk_10151146);
  sub_100155E0(0x14u, 6533, &unk_10151147);
  sub_100155E0(0xAu, 6883, &unk_10151860);
  sub_100155E0(0xAu, 6884, &unk_1015186A);
  sub_100155E0(0xAu, 6885, &unk_10151874);
  sub_100155E0(1u, 6664, &unk_1015115B);
  sub_100155E0(1u, 6666, &unk_1015115C);
  sub_100155E0(1u, 6667, &unk_1015115D);
  sub_100155E0(1u, 6668, &unk_1015115E);
  sub_100155E0(0xA0u, 6669, &unk_10151160);
  sub_100155E0(2u, 6670, &unk_10151250);
  sub_100155E0(4u, 6671, &unk_10151254);
  sub_100155E0(4u, 6672, &unk_10151258);
  sub_100155E0(4u, 6673, &unk_1015125C);
  sub_100155E0(4u, 6674, &unk_10151260);
  sub_100155E0(4u, 6675, &unk_10151264);
  sub_100155E0(4u, 6676, &unk_1015126C);
  sub_100155E0(4u, 6677, &unk_10151274);
  sub_100155E0(4u, 6678, &unk_10151278);
  sub_100155E0(1u, 6679, &unk_1015127C);
  sub_100155E0(0x140u, 6680, &unk_10151280);
  sub_100155E0(4u, 6882, &unk_1015185C);
  sub_100155E0(0xCu, 6652, &unk_101513C0);
  sub_100155E0(0x48u, 6653, &unk_101513CC);
  sub_100155E0(1u, 6688, &unk_10151414);
  sub_100155E0(4u, 6771, &unk_1015149C);
  sub_100155E0(4u, 6772, &unk_101514A0);
  sub_100155E0(8u, 6787, &unk_101514A4);
  sub_100155E0(1u, 6832, &unk_101514D4);
  sub_100155E0(1u, 6833, &unk_101514D5);
  sub_100155E0(1u, 6834, &unk_101514D6);
  sub_100155E0(4u, 6835, &unk_101514D8);
  sub_100155E0(4u, 6836, &unk_101514DC);
  sub_100155E0(4u, 6837, &unk_101514E0);
  sub_100155E0(4u, 6838, &unk_101514E4);
  sub_100155E0(1u, 6839, &unk_101514E8);
  sub_100155E0(0x50u, 6840, &unk_10151200);
  sub_100155E0(4u, 6841, &unk_101514EC);
  sub_100155E0(4u, 6842, &unk_101514F0);
  sub_100155E0(4u, 6843, &unk_101514F4);
  sub_100155E0(1u, 6844, &unk_101514F8);
  sub_100155E0(0x360u, 6845, &unk_101514FC);
  sub_100155E0(4u, 6846, &unk_10151268);
  sub_100155E0(4u, 6847, &unk_10151270);
  result = 1;
  dword_1022D6E8 = &unk_10149660;
  return result;
}

//----- (10017430) --------------------------------------------------------
char **sub_10017430()
{
  return off_100922E8;
}
// 100922E8: using guessed type char *off_100922E8[3];

//----- (10017440) --------------------------------------------------------
char **sub_10017440()
{
  return off_10092458;
}
// 10092458: using guessed type char *off_10092458[3];

//----- (10017450) --------------------------------------------------------
bool sub_10017450()
{
  unsigned __int8 v0; // ST14_1@1
  char *v1; // eax@1
  int v3; // [sp+4h] [bp-6Ch]@1
  char v4; // [sp+8h] [bp-68h]@1

  v0 = sub_10007190(0, 0, 0, (int)&v3, 12, &v4);
  v1 = sub_100242C0("iop_aud_msg_cnfg_get_status_str_proc: Invalid cnfg_mngr_state = IOP_NMBR_CNFG_MNGR_STATES");
  return sub_10024620(1, 0, (int)".\\test\\tst_iop_aud_msg.c", (int)"114", (int)v1, v0, 0, 0);
}

//----- (100174C0) --------------------------------------------------------
bool sub_100174C0()
{
  unsigned __int8 v0; // ST14_1@1
  char *v1; // eax@1
  char v3[4]; // [sp+4h] [bp-4h]@1

  v3[0] = sub_100073F0(0, 0, 44);
  v0 = v3[0];
  v1 = sub_100242C0("iop_aud_msg_cnfg_send_proc: Invalid cnfg_type = IOP_NMBR_CNFG_TYPES");
  return sub_10024620(1, 0, (int)".\\test\\tst_iop_aud_msg.c", (int)"146", (int)v1, v0, 0, 0);
}

//----- (10017510) --------------------------------------------------------
bool sub_10017510()
{
  char v1; // [sp+0h] [bp-Ch]@1
  int v2; // [sp+4h] [bp-8h]@1
  int v3; // [sp+8h] [bp-4h]@1

  v2 = 0;
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"134",
    (int)"Try to configure an invalid config type");
  v1 = 0;
  LOBYTE(v3) = sub_10007D20(3, 0, 44, (unsigned __int8 *)&v1, &v2);
  return sub_10024620(
           1,
           0,
           (int)".\\test\\tst_iop_cdu_cnfg.c",
           (int)&unk_100926F8,
           (int)"Invalid config type",
           v3,
           0,
           0);
}

//----- (10017580) --------------------------------------------------------
bool sub_10017580()
{
  unsigned __int8 v0; // al@1
  unsigned __int8 v1; // ST48_1@1
  char v2; // al@1
  unsigned __int8 v3; // al@1
  unsigned __int8 v4; // al@1
  unsigned __int8 v5; // ST48_1@1
  char v6; // al@1
  unsigned __int8 v7; // al@1
  unsigned __int8 v8; // al@1
  unsigned __int8 v9; // ST48_1@1
  char v10; // al@1
  unsigned __int8 v11; // al@1
  unsigned __int8 v12; // al@1
  unsigned __int8 v13; // ST48_1@1
  char v14; // al@1
  unsigned __int8 v15; // al@1
  unsigned __int8 v16; // al@1
  char v17; // al@1
  unsigned __int8 v18; // al@1
  unsigned __int8 v19; // al@1
  char v20; // al@1
  unsigned __int8 v21; // al@1
  char v22; // al@1
  unsigned __int8 v23; // al@1
  char v24; // al@1
  unsigned __int8 v25; // al@1
  char v26; // al@1
  unsigned __int8 v27; // ST54_1@1
  int v29; // [sp+8h] [bp-Ch]@1
  int v30; // [sp+Ch] [bp-8h]@1

  v30 = 0;
  sub_10030970(
    3,
    (int)"Tested Requirement:",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"175",
    (int)"R00240498, R00240497");
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"180",
    (int)"Configure A429 channel IOP_CDU_A429_RX_1 to format IOP_CDU_A429_OFF and hi_speed FALSE");
  LOBYTE(v29) = 0;
  LOWORD(v30) = 0;
  v0 = sub_10007D20(3, 0, 2, (unsigned __int8 *)&v29, &v30);
  sub_10024620(
    0,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"185",
    (int)"IOP_CDU_A429_RX_1, IOP_CDU_A429_OFF",
    v0,
    1u,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"187",
    (int)"Check to make sure IOP_CDU_A429_RX_1 was set properly");
  v1 = v29;
  v30 = 0;
  v2 = sub_100195A0(3);
  v3 = sub_10007500(v2, v1, &v30);
  sub_10024620(0, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"190", (int)"Config is valid", v3, 1u, 0);
  sub_10027DA0(
    0,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"191",
    (int)"Format equals what was set",
    BYTE1(v30),
    0,
    0,
    0);
  sub_10024620(0, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"192", (int)"High speed equals what was set", v30, 0, 0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"195",
    (int)"Configure A429 channel IOP_CDU_A429_RX_2 to format IOP_CDU_A429_OFF and hi_speed FALSE");
  LOBYTE(v29) = 1;
  LOWORD(v30) = 0;
  v4 = sub_10007D20(3, 0, 2, (unsigned __int8 *)&v29, &v30);
  sub_10024620(
    0,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"200",
    (int)"IOP_CDU_A429_RX_2, IOP_CDU_A429_OFF",
    v4,
    1u,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"202",
    (int)"Check to make sure IOP_CDU_A429_RX_2 was set properly");
  v5 = v29;
  v30 = 0;
  v6 = sub_100195A0(3);
  v7 = sub_10007500(v6, v5, &v30);
  sub_10024620(0, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"205", (int)"Config is valid", v7, 1u, 0);
  sub_10027DA0(
    0,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"206",
    (int)"Format equals what was set",
    BYTE1(v30),
    0,
    0,
    0);
  sub_10024620(0, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"207", (int)"High speed equals what was set", v30, 0, 0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"210",
    (int)"Configure A429 channel IOP_CDU_A429_RX_1 to format IOP_CDU_A429_IN_GRS77_1 and hi_speed TRUE");
  LOBYTE(v29) = 0;
  LOWORD(v30) = 257;
  v8 = sub_10007D20(3, 0, 2, (unsigned __int8 *)&v29, &v30);
  sub_10024620(
    0,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"215",
    (int)"IOP_CDU_A429_RX_1, IOP_CDU_A429_IN_GRS77_1",
    v8,
    1u,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"217",
    (int)"Check to make sure IOP_CDU_A429_RX_1 was set properly");
  v9 = v29;
  v30 = 0;
  v10 = sub_100195A0(3);
  v11 = sub_10007500(v10, v9, &v30);
  sub_10024620(0, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"220", (int)"Config is valid", v11, 1u, 0);
  sub_10027DA0(
    0,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"221",
    (int)"Format equals what was set:",
    BYTE1(v30),
    1u,
    0,
    0);
  sub_10024620(0, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"222", (int)"High speed equals what was set:", v30, 1u, 0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"225",
    (int)"Configure A429 channel IOP_CDU_A429_RX_2 to format IOP_CDU_A429_IN_GDC74_2 and hi_speed TRUE");
  LOBYTE(v29) = 1;
  LOWORD(v30) = 1025;
  v12 = sub_10007D20(3, 0, 2, (unsigned __int8 *)&v29, &v30);
  sub_10024620(
    0,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)&unk_10084EBC,
    (int)"IOP_CDU_A429_RX_2, IOP_CDU_A429_IN_GDC74_2",
    v12,
    1u,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"232",
    (int)"Check to make sure IOP_CDU_A429_RX_2 was set properly");
  v13 = v29;
  v30 = 0;
  v14 = sub_100195A0(3);
  v15 = sub_10007500(v14, v13, &v30);
  sub_10024620(0, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"235", (int)"Config is valid", v15, 1u, 0);
  sub_10027DA0(
    0,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)&unk_10084EB8,
    (int)"Format equals what was set",
    BYTE1(v30),
    4u,
    0,
    0);
  sub_10024620(0, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"237", (int)"High speed equals what was set", v30, 1u, 0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"242",
    (int)"Configure A429 channel IOP_CDU_A429_RX_1 to format IOP_CDU_A429_IN_GDC74_1 and hi_speed TRUE");
  LOBYTE(v29) = 0;
  LOWORD(v30) = 769;
  v16 = sub_10007D20(3, 0, 2, (unsigned __int8 *)&v29, &v30);
  sub_10024620(
    0,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"247",
    (int)"IOP_CDU_A429_RX_1, IOP_CDU_A429_IN_GDC74_1",
    v16,
    1u,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"249",
    (int)"Check to make sure IOP_CDU_A429_RX_1 was set properly");
  v30 = 0;
  LOBYTE(v29) = 0;
  v17 = sub_100195A0(3);
  v18 = sub_10007500(v17, 0, &v30);
  sub_10024620(0, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"253", (int)"Config is valid", v18, 1u, 0);
  sub_10027DA0(
    0,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"254",
    (int)"Format equals what was set:",
    BYTE1(v30),
    3u,
    0,
    0);
  sub_10024620(0, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"255", (int)"High speed equals what was set:", v30, 1u, 0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"257",
    (int)"Configure A429 channel IOP_CDU_A429_RX_2 to format IOP_CDU_A429_IN_GDC74_1 and hi_speed TRUE");
  LOBYTE(v29) = 1;
  LOWORD(v30) = 769;
  v19 = sub_10007D20(3, 0, 2, (unsigned __int8 *)&v29, &v30);
  sub_10024620(
    0,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"262",
    (int)"IOP_CDU_A429_RX_2, IOP_CDU_A429_IN_GDC74_1",
    v19,
    1u,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"264",
    (int)"Check to make sure IOP_CDU_A429_RX_1 was cleared");
  v30 = 0;
  LOBYTE(v29) = 0;
  v20 = sub_100195A0(3);
  v21 = sub_10007500(v20, 0, &v30);
  sub_10024620(0, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"268", (int)"Config is valid", v21, 1u, 0);
  sub_10027DA0(
    0,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"269",
    (int)"Format equals what was set:",
    BYTE1(v30),
    0,
    0,
    0);
  sub_10024620(0, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"270", (int)"High speed equals what was set:", v30, 0, 0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"272",
    (int)"Check to make sure IOP_CDU_A429_RX_2 was set properly");
  v30 = 0;
  LOBYTE(v29) = 1;
  v22 = sub_100195A0(3);
  v23 = sub_10007500(v22, 1u, &v30);
  sub_10024620(0, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"276", (int)"Config is valid", v23, 1u, 0);
  sub_10027DA0(
    0,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"277",
    (int)"Format equals what was set:",
    BYTE1(v30),
    3u,
    0,
    0);
  sub_10024620(0, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"278", (int)"High speed equals what was set:", v30, 1u, 0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"283",
    (int)"Try to get configure data for a channel out of range");
  v30 = 0;
  LOBYTE(v29) = 2;
  v24 = sub_100195A0(3);
  v25 = sub_10007500(v24, 2u, &v30);
  sub_10024620(1, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"287", (int)"Config is invalid", v25, 0, 0);
  v30 = 0;
  LOBYTE(v29) = -1;
  v26 = sub_100195A0(3);
  v27 = sub_10007500(v26, 0xFFu, &v30);
  return sub_10024620(1, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"292", (int)"Config is invalid", v27, 0, 0);
}

//----- (10017D00) --------------------------------------------------------
bool sub_10017D00()
{
  char v1; // [sp+0h] [bp-Ch]@1
  int v2; // [sp+4h] [bp-8h]@1
  int v3; // [sp+8h] [bp-4h]@1

  v2 = 0;
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"329",
    (int)"Try to configure and invalid A429 channel to format IOP_CDU_A429_IN_GDC74_1 and hi_speed TRUE");
  v1 = 2;
  LOWORD(v2) = 769;
  LOBYTE(v3) = sub_10007D20(3, 0, 2, (unsigned __int8 *)&v1, &v2);
  return sub_10024620(
           1,
           0,
           (int)".\\test\\tst_iop_cdu_cnfg.c",
           (int)"334",
           (int)"Should assert and not see this",
           v3,
           0,
           0);
}

//----- (10017D80) --------------------------------------------------------
bool sub_10017D80()
{
  char v1; // [sp+0h] [bp-Ch]@1
  int v2; // [sp+4h] [bp-8h]@1
  int v3; // [sp+8h] [bp-4h]@1

  v2 = 0;
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"371",
    (int)"Try to configure an invalid A429 channel to format IOP_CDU_A429_IN_GDC74_1 and hi_speed TRUE");
  v1 = -1;
  LOWORD(v2) = 769;
  LOBYTE(v3) = sub_10007D20(3, 0, 2, (unsigned __int8 *)&v1, &v2);
  return sub_10024620(
           1,
           0,
           (int)".\\test\\tst_iop_cdu_cnfg.c",
           (int)"376",
           (int)"Should assert and not see this",
           v3,
           0,
           0);
}

//----- (10017E00) --------------------------------------------------------
bool sub_10017E00()
{
  char v1; // [sp+0h] [bp-Ch]@1
  int v2; // [sp+4h] [bp-8h]@1
  int v3; // [sp+8h] [bp-4h]@1

  v2 = 0;
  sub_10030970(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"413", (int)"R00240499");
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"418",
    (int)"Configure Discrete in channel IOP_CDU_DIS_IN_SPARE to function IOP_DSCRT_IN_DATA_TYPE_AFCS_GO_ARND and inverted FALSE");
  v1 = 0;
  HIWORD(v2) = 9;
  BYTE1(v2) = 0;
  LOBYTE(v3) = sub_10007D20(3, 0, 3, (unsigned __int8 *)&v1, &v2);
  sub_10024620(
    0,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"423",
    (int)"IOP_CDU_DIS_IN_SPARE, IOP_DSCRT_IN_DATA_TYPE_AFCS_GO_ARND",
    v3,
    1u,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"425",
    (int)"Configure Discrete in channel IOP_NMBR_CDU_DIS_IN to function IOP_DSCRT_IN_DATA_TYPE_AFCS_GO_ARND and inverted TRUE");
  v1 = 1;
  HIWORD(v2) = 9;
  BYTE1(v2) = 1;
  LOBYTE(v3) = sub_10007D20(3, 0, 3, (unsigned __int8 *)&v1, &v2);
  return sub_10024620(
           0,
           0,
           (int)".\\test\\tst_iop_cdu_cnfg.c",
           (int)"430",
           (int)"IOP_NMBR_CDU_DIS_IN, IOP_DSCRT_IN_DATA_TYPE_AFCS_GO_ARND",
           v3,
           1u,
           0);
}

//----- (10017F00) --------------------------------------------------------
bool sub_10017F00()
{
  char v1; // [sp+Ch] [bp-88h]@1
  int v2; // [sp+10h] [bp-84h]@1
  char v3; // [sp+14h] [bp-80h]@1
  char v4; // [sp+16h] [bp-7Eh]@1
  char v5; // [sp+17h] [bp-7Dh]@1
  char v6; // [sp+18h] [bp-7Ch]@1
  char v7; // [sp+20h] [bp-74h]@1
  char v8; // [sp+21h] [bp-73h]@1
  char v9; // [sp+24h] [bp-70h]@1
  char v10; // [sp+25h] [bp-6Fh]@1
  char v11; // [sp+2Eh] [bp-66h]@1
  char v12; // [sp+2Fh] [bp-65h]@1
  __int16 v13; // [sp+34h] [bp-60h]@1
  char v14; // [sp+36h] [bp-5Eh]@1
  char v15; // [sp+37h] [bp-5Dh]@1
  char v16; // [sp+39h] [bp-5Bh]@1
  char v17; // [sp+42h] [bp-52h]@1
  char v18; // [sp+43h] [bp-51h]@1
  __int16 v19; // [sp+50h] [bp-44h]@1
  char v20; // [sp+53h] [bp-41h]@1
  char v21; // [sp+54h] [bp-40h]@1

  memset(&v3, 0, 0x40u);
  memset(&v21, 0, 0x40u);
  sub_1004FB10((int)&v21, 0, 1);
  sub_10030970(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"470", (int)"R00240500");
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"475",
    (int)"Get the current backlight config for PFD1, then write it back.");
  v1 = 0;
  sub_1004FB10((int)&v3, 0, 1);
  LOBYTE(v2) = sub_10007D20(4, 0, 16, (unsigned __int8 *)&v1, (int *)&v3);
  sub_10024620(0, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"479", (int)"Current", v2, 1u, 0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"485",
    (int)"Configure photo curve with endpoint that doesn't reach edge.");
  qmemcpy(&v3, &v21, 0x40u);
  v1 = 0;
  v9 = 1;
  v10 = 1;
  v11 = 100;
  v12 = 100;
  LOBYTE(v2) = sub_10007D20(4, 0, 16, (unsigned __int8 *)&v1, (int *)&v3);
  sub_10024620(1, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"493", (int)"Left endpoint not on edge", v2, 0, 0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"499",
    (int)"Configure main curve with endpoint that doesn't reach edge.");
  qmemcpy(&v3, &v21, 0x40u);
  v1 = 0;
  v4 = 1;
  v5 = 1;
  v7 = 100;
  v8 = 100;
  LOBYTE(v2) = sub_10007D20(4, 0, 16, (unsigned __int8 *)&v1, (int *)&v3);
  sub_10024620(1, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"507", (int)"Left endpoint not on edge", v2, 0, 0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"509",
    (int)"Configure main curve with other endpoint that doesn't reach edge.");
  qmemcpy(&v3, &v21, 0x40u);
  v1 = 0;
  v4 = 0;
  v5 = 0;
  v7 = 99;
  v8 = 99;
  LOBYTE(v2) = sub_10007D20(4, 0, 16, (unsigned __int8 *)&v1, (int *)&v3);
  sub_10024620(1, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"517", (int)"Right endpoint not on edge", v2, 0, 0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"523",
    (int)"Configure main curve with two consecutive x coordinates equal.");
  qmemcpy(&v3, &v21, 0x40u);
  v1 = 0;
  v4 = 0;
  v6 = 0;
  LOBYTE(v2) = sub_10007D20(4, 0, 16, (unsigned __int8 *)&v1, (int *)&v3);
  sub_10024620(
    1,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"529",
    (int)"Two consecutive equal x coordinates",
    v2,
    0,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"535",
    (int)"Configure main curve with two consecutive y coordinates decreasing.");
  qmemcpy(&v3, &v21, 0x40u);
  v1 = 0;
  v14 = 0;
  v15 = 10;
  v16 = 5;
  LOBYTE(v2) = sub_10007D20(4, 0, 16, (unsigned __int8 *)&v1, (int *)&v3);
  sub_10024620(
    1,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"542",
    (int)"Two consecutive decreasing y coordinates",
    v2,
    0,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"547",
    (int)"Configure lighting with photo overide greater than HWM_ANLG_PWR_MAX.");
  qmemcpy(&v3, &v21, 0x40u);
  v1 = 0;
  v19 = 10001;
  LOBYTE(v2) = sub_10007D20(4, 0, 16, (unsigned __int8 *)&v1, (int *)&v3);
  sub_10024620(1, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"552", (int)"phot_ovrd > HWM_ANLG_PWR_MAX", v2, 0, 0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"557",
    (int)"Configure lighting with source equal to HWM_DSPL_BKLT_SRC_NUM.");
  qmemcpy(&v3, &v21, 0x40u);
  v1 = 0;
  v18 = 22;
  LOBYTE(v2) = sub_10007D20(4, 0, 16, (unsigned __int8 *)&v1, (int *)&v3);
  sub_10024620(1, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"562", (int)"source = HWM_DSPL_BKLT_SRC_NUM", v2, 0, 0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"567",
    (int)"Configure lighting with response time equal to HWM_DSPL_BKLT_TCONST_NUM.");
  qmemcpy(&v3, &v21, 0x40u);
  v1 = 0;
  v17 = 10;
  v20 = 10;
  LOBYTE(v2) = sub_10007D20(4, 0, 16, (unsigned __int8 *)&v1, (int *)&v3);
  sub_10024620(
    1,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"573",
    (int)"resp_time = HWM_DSPL_BKLT_TCONST_NUM",
    v2,
    0,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"578",
    (int)"Configure lighting with minimum greater than HWM_ANLG_PWR_MAX.");
  qmemcpy(&v3, &v21, 0x40u);
  v1 = 0;
  v13 = 10001;
  LOBYTE(v2) = sub_10007D20(4, 0, 16, (unsigned __int8 *)&v1, (int *)&v3);
  return sub_10024620(1, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"583", (int)"min > HWM_ANLG_PWR_MAX", v2, 0, 0);
}

//----- (100183E0) --------------------------------------------------------
bool sub_100183E0()
{
  char v1; // [sp+0h] [bp-48h]@1
  int v2; // [sp+4h] [bp-44h]@1
  char v3; // [sp+8h] [bp-40h]@1

  memset(&v3, 0, 0x40u);
  sub_10030970(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"621", (int)"R00240500");
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"626",
    (int)"Get the current backlight config for PFD1, then write it back.");
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"627",
    (int)"In order for this test to pass, registry writes for REG_TAG_LGHT_CNFG_PFD_1 need to be disabled.");
  v1 = 0;
  sub_1004FB10((int)&v3, 0, 1);
  LOBYTE(v2) = sub_10007D20(4, 0, 16, (unsigned __int8 *)&v1, (int *)&v3);
  return sub_10024620(
           1,
           0,
           (int)".\\test\\tst_iop_cdu_cnfg.c",
           (int)"631",
           (int)"Write back current, with failed registry write.",
           v2,
           0,
           0);
}

//----- (100184A0) --------------------------------------------------------
bool sub_100184A0()
{
  char v0; // al@1
  char v1; // al@1
  char v2; // al@1
  char v3; // al@1
  char v4; // al@1
  char v5; // al@1
  char v6; // al@1
  char v7; // al@1
  int v9; // [sp+4h] [bp-28h]@1
  char v10; // [sp+8h] [bp-24h]@1
  int v11; // [sp+Ch] [bp-20h]@1
  char v12; // [sp+10h] [bp-1Ch]@1
  char v13; // [sp+1Ch] [bp-10h]@1
  char v14; // [sp+1Dh] [bp-Fh]@1

  sub_10030970(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"670", (int)"R00240501");
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"675",
    (int)"Configure RS-232 channel IOP_CDU_RS232_CHNL_1 to dir IOP_FORMAT_DIR_IN and format IOP_CDU_RS232_OFF");
  v10 = 0;
  LOWORD(v9) = 0;
  LOBYTE(v11) = sub_10007D20(3, 0, 12, (unsigned __int8 *)&v10, &v9);
  sub_10024620(
    0,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"680",
    (int)"IOP_CDU_RS232_CHNL_1, IOP_CDU_RS232_OFF",
    v11,
    1u,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"682",
    (int)"Configure RS-232 channel IOP_CDU_RS232_CHNL_1 to dir IOP_FORMAT_DIR_OUT and format IOP_CDU_RS232_OFF");
  v10 = 0;
  LOWORD(v9) = 1;
  LOBYTE(v11) = sub_10007D20(4, 0, 12, (unsigned __int8 *)&v10, &v9);
  sub_10024620(
    0,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"687",
    (int)"IOP_CDU_RS232_CHNL_1, IOP_CDU_RS232_OFF",
    v11,
    1u,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"689",
    (int)"Try to configure RS-232 channel IOP_CDU_RS232_CHNL_1 to an invalid dir and format IOP_CDU_RS232_GCU475");
  v10 = 0;
  LOWORD(v9) = 514;
  LOBYTE(v11) = sub_10007D20(4, 0, 12, (unsigned __int8 *)&v10, &v9);
  sub_10024620(
    1,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"694",
    (int)"IOP_CDU_RS232_CHNL_1, IOP_CDU_RS232_GCU475",
    v11,
    1u,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"699",
    (int)"Set RS-232 channel IOP_CDU_RS232_CHNL_1 to have an invalid format");
  v0 = sub_100195A0(3);
  sub_10019260(v0, (int)&v12);
  v13 = 19;
  v14 = 19;
  v1 = sub_100195A0(3);
  sub_10008280(v1, (int)&v12);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"705",
    (int)"Configure RS-232 channel IOP_CDU_RS232_CHNL_1 to dir IOP_FORMAT_DIR_IN and format IOP_CDU_RS232_OFF");
  v10 = 0;
  LOWORD(v9) = 0;
  LOBYTE(v11) = sub_10007D20(3, 0, 12, (unsigned __int8 *)&v10, &v9);
  sub_10024620(
    1,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"710",
    (int)"IOP_CDU_RS232_CHNL_1, IOP_CDU_RS232_OFF",
    v11,
    1u,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"712",
    (int)"Configure RS-232 channel IOP_CDU_RS232_CHNL_1 to dir IOP_FORMAT_DIR_IN and format IOP_CDU_RS232_OFF");
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"713",
    (int)"This is repeated in order to show that the previous step reset the out format appropriately");
  v10 = 0;
  LOWORD(v9) = 0;
  LOBYTE(v11) = sub_10007D20(3, 0, 12, (unsigned __int8 *)&v10, &v9);
  sub_10024620(
    1,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"718",
    (int)"IOP_CDU_RS232_CHNL_1, IOP_CDU_RS232_OFF",
    v11,
    1u,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"721",
    (int)"Set RS-232 channel IOP_CDU_RS232_CHNL_1 to have an invalid format");
  v2 = sub_100195A0(3);
  sub_10019260(v2, (int)&v12);
  v13 = 19;
  v14 = 19;
  v3 = sub_100195A0(3);
  sub_10008280(v3, (int)&v12);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"727",
    (int)"Configure RS-232 channel IOP_CDU_RS232_CHNL_1 to dir IOP_FORMAT_DIR_OUT and format IOP_CDU_RS232_OFF");
  v10 = 0;
  LOWORD(v9) = 1;
  LOBYTE(v11) = sub_10007D20(3, 0, 12, (unsigned __int8 *)&v10, &v9);
  sub_10024620(
    1,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"732",
    (int)"IOP_CDU_RS232_CHNL_1, IOP_CDU_RS232_OFF",
    v11,
    1u,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"734",
    (int)"Configure RS-232 channel IOP_CDU_RS232_CHNL_1 to dir IOP_FORMAT_DIR_OUT and format IOP_CDU_RS232_OFF");
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"735",
    (int)"This is repeated in order to show that the previous step reset the out format appropriately");
  v10 = 0;
  LOWORD(v9) = 1;
  LOBYTE(v11) = sub_10007D20(3, 0, 12, (unsigned __int8 *)&v10, &v9);
  sub_10024620(
    1,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"740",
    (int)"IOP_CDU_RS232_CHNL_1, IOP_CDU_RS232_OFF",
    v11,
    1u,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"743",
    (int)"Set RS-232 channel IOP_CDU_RS232_CHNL_1 to have an invalid format");
  v4 = sub_100195A0(3);
  sub_10019260(v4, (int)&v12);
  v14 = 19;
  v5 = sub_100195A0(3);
  sub_10008280(v5, (int)&v12);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"748",
    (int)"Configure RS-232 channel IOP_CDU_RS232_CHNL_1 to dir IOP_FORMAT_DIR_OUT and format IOP_CDU_RS232_OFF");
  v10 = 0;
  LOWORD(v9) = 1;
  LOBYTE(v11) = sub_10007D20(3, 0, 12, (unsigned __int8 *)&v10, &v9);
  sub_10024620(
    1,
    0,
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"753",
    (int)"IOP_CDU_RS232_CHNL_1, IOP_CDU_RS232_OFF",
    v11,
    1u,
    0);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"758",
    (int)"Set RS-232 channel IOP_CDU_RS232_CHNL_1 to have IOP_CDU_RS232_GCU475 for in and out format.");
  v6 = sub_100195A0(3);
  sub_10019260(v6, (int)&v12);
  v13 = 2;
  v14 = 2;
  v7 = sub_100195A0(3);
  sub_10008280(v7, (int)&v12);
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"764",
    (int)"Configure RS-232 channel IOP_CDU_RS232_CHNL_2 to dir IOP_FORMAT_DIR_IN and format IOP_CDU_RS232_GCU475");
  v10 = 1;
  LOWORD(v9) = 512;
  LOBYTE(v11) = sub_10007D20(3, 0, 12, (unsigned __int8 *)&v10, &v9);
  return sub_10024620(
           1,
           0,
           (int)".\\test\\tst_iop_cdu_cnfg.c",
           (int)"769",
           (int)"IOP_CDU_RS232_CHNL_2, IOP_CDU_RS232_GCU475",
           v11,
           1u,
           0);
}

//----- (100189F0) --------------------------------------------------------
bool sub_100189F0()
{
  int v1; // [sp+0h] [bp-Ch]@1
  char v2; // [sp+4h] [bp-8h]@1
  int v3; // [sp+8h] [bp-4h]@1

  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"808",
    (int)"Try to configure RS-232 channel IOP_CDU_RS232_CHNL_1 to an invalid dir and format IOP_CDU_RS232_OFF");
  v2 = 0;
  LOWORD(v1) = 2;
  LOBYTE(v3) = sub_10007D20(3, 0, 12, (unsigned __int8 *)&v2, &v1);
  return sub_10024620(
           1,
           0,
           (int)".\\test\\tst_iop_cdu_cnfg.c",
           (int)"813",
           (int)"Should assert and not see this",
           v3,
           0,
           0);
}

//----- (10018A70) --------------------------------------------------------
bool sub_10018A70()
{
  char v1; // [sp+3h] [bp-9h]@1
  char v2; // [sp+4h] [bp-8h]@1
  int v3; // [sp+8h] [bp-4h]@1

  sub_10030970(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"850", (int)"R00240504");
  sub_10030970(
    3,
    (int)"**MSG**",
    (int)".\\test\\tst_iop_cdu_cnfg.c",
    (int)"855",
    (int)"Configure A429 SDI to IOP_SDI_1");
  v2 = 0;
  v1 = 1;
  LOBYTE(v3) = sub_10007D20(3, 0, 7, (unsigned __int8 *)&v2, (int *)&v1);
  return sub_10024620(0, 0, (int)".\\test\\tst_iop_cdu_cnfg.c", (int)"859", (int)"IOP_SDI_1", v3, 1u, 0);
}

//----- (10018B00) --------------------------------------------------------
bool sub_10018B00()
{
  void *v0; // esi@1
  void *v1; // esi@1

  sub_10030970(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_gma_dig_frmt.c", (int)"104", (int)"R00191584");
  sub_1001B770(1);
  v0 = sub_10035200(7);
  sub_1001B770(-1);
  sub_10020640((int)&unk_1022D620, "Verify digital GMA format info table.", 200);
  sub_10028C40(0, 0, (int)".\\test\\tst_iop_gma_dig_frmt.c", (int)&unk_10093D6C, (int)&unk_1022D620, (int)v0, 0, 0);
  sub_1001B770(1);
  v1 = sub_10035200(5);
  sub_1001B770(-1);
  sub_10020640((int)&unk_1022D620, "Verify digital GMA format info table.", 200);
  return sub_10028C40(
           0,
           0,
           (int)".\\test\\tst_iop_gma_dig_frmt.c",
           (int)&unk_10093D68,
           (int)&unk_1022D620,
           (int)v1,
           0,
           0);
}

//----- (10018BC0) --------------------------------------------------------
char sub_10018BC0()
{
  char v1; // [sp+8h] [bp-38h]@1
  __int16 v2; // [sp+32h] [bp-Eh]@1

  qmemcpy(&v1, &unk_10186AFC, 0x34u);
  sub_10030970(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_xpdr.c", (int)"113", (int)"R00028970");
  v2 = 8888;
  return sub_10035270(&v1);
}

//----- (10018C20) --------------------------------------------------------
bool sub_10018C20()
{
  unsigned __int8 v0; // al@1

  sub_10030970(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_xpdr.c", (int)"147", (int)"R00028980");
  v0 = sub_1001A8C0(0);
  return sub_10024620(1, 0, (int)".\\test\\tst_iop_xpdr.c", (int)"149", (int)"Set the IDENT state off", v0, 0, 0);
}

//----- (10018C70) --------------------------------------------------------
bool sub_10018C70()
{
  unsigned __int8 v0; // al@1

  sub_10030970(3, (int)"Tested Requirement:", (int)".\\test\\tst_iop_xpdr.c", (int)"181", (int)"R00028981");
  v0 = sub_1001AC60(3u);
  return sub_10024620(
           1,
           0,
           (int)".\\test\\tst_iop_xpdr.c",
           (int)"183",
           (int)"Set the transponder mode to GND",
           v0,
           0,
           0);
}

//----- (10018CC0) --------------------------------------------------------
char sub_10018CC0()
{
  return sub_10035270(&unk_10186AFC);
}

//----- (10018CD0) --------------------------------------------------------
char sub_10018CD0()
{
  sub_10035260();
  return sub_100352D0(&unk_10186AFC);
}

//----- (10018CF0) --------------------------------------------------------
int (**sub_10018CF0())()
{
  return off_10093E50;
}
// 10093E50: using guessed type int (*off_10093E50[3])();

//----- (10018D00) --------------------------------------------------------
int __cdecl sub_10018D00(float a1, float a2)
{
  float *v2; // ecx@0
  double v3; // st7@1
  double v4; // st7@3
  bool v5; // c0@3
  bool v6; // c3@3
  int result; // eax@4

  v3 = a1;
  if ( (COERCE_UNSIGNED_INT(*v2) & 0x7F800000) != 2139095040
    && *v2 <= v3
    && (v4 = *v2, v5 = a2 < v4, v6 = a2 == v4, v3 = a2, v5 || v6) )
  {
    result = 1;
  }
  else
  {
    *v2 = v3;
    result = 0;
  }
  return result;
}

//----- (10018D50) --------------------------------------------------------
bool __cdecl sub_10018D50(float *a1)
{
  void *v1; // ecx@0
  float *v2; // edi@1
  unsigned int v3; // ebp@1
  char v4; // bl@1
  _DWORD *v5; // esi@1
  unsigned __int8 v6; // al@3
  bool result; // al@6
  int v8; // [sp+10h] [bp-8h]@1
  float v9; // [sp+14h] [bp-4h]@3
  char v10; // [sp+1Ch] [bp+4h]@1

  v2 = a1;
  *a1 = 0.0;
  v3 = 0;
  v4 = 0;
  v8 = sub_1001A050(v1);
  v10 = 0;
  v5 = &unk_10094388;
  do
  {
    if ( v8 & *v5 )
    {
      v6 = sub_10028FE0(v10, 0);
      if ( sub_10009C90(3u, v6, &v9) )
      {
        ++v3;
        *v2 = *v2 + v9;
      }
    }
    ++v4;
    ++v5;
    v10 = v4;
  }
  while ( (unsigned __int8)v4 < 2u );
  result = v3 != 0;
  if ( v3 )
    *v2 = *v2 / (double)v3;
  return result;
}

//----- (10018DF0) --------------------------------------------------------
int sub_10018DF0()
{
  int result; // eax@1

  sub_1004E8C0(6361, (int)&flt_10186B30, 4);
  result = sub_1004E8C0(6362, (int)&flt_10186B34, 4);
  dword_10186B38 = 1379255385;
  return result;
}
// 10186B30: using guessed type float flt_10186B30;
// 10186B34: using guessed type float flt_10186B34;
// 10186B38: using guessed type int dword_10186B38;

//----- (10018E20) --------------------------------------------------------
char __cdecl sub_10018E20(float *a1)
{
  char v1; // bl@1
  double v2; // st7@2
  double v3; // st7@6
  char result; // al@9
  float v5; // [sp+Ch] [bp-Ch]@1
  float v6; // [sp+10h] [bp-8h]@5
  float v7; // [sp+14h] [bp-4h]@2

  v1 = sub_10009D10(0x35u, &v5);
  if ( v1 )
  {
    v2 = v5;
    v7 = v5;
    if ( (LODWORD(v5) & 0x7F800000) == 2139095040 || v2 > 526.79114 || v2 < -526.79114 )
      return 0;
    if ( sub_10009D10(0x3Bu, &v6) )
    {
      v3 = v6;
      v7 = v6;
      if ( (LODWORD(v6) & 0x7F800000) != 2139095040 && v3 <= 526.79114 && v3 >= -526.79114 )
      {
        sub_10018D00(flt_10186B30, 0.0);
        result = v1;
        v5 = flt_10186B34 * v6 + v5;
        *a1 = v5;
        return result;
      }
    }
    *a1 = v5;
  }
  return v1;
}
// 10186B30: using guessed type float flt_10186B30;
// 10186B34: using guessed type float flt_10186B34;

//----- (10018F20) --------------------------------------------------------
char __cdecl sub_10018F20(bool *a1)
{
  unsigned __int8 v1; // bl@1
  unsigned __int16 *v2; // esi@1
  signed int v3; // edi@4
  void *v4; // ecx@5
  char v5; // al@9
  void *v6; // ecx@13
  char v8; // [sp+1h] [bp-Bh]@1
  char v9; // [sp+2h] [bp-Ah]@1
  unsigned __int8 v10; // [sp+3h] [bp-9h]@1
  unsigned __int8 v11; // [sp+4h] [bp-8h]@1
  bool v12; // [sp+5h] [bp-7h]@1
  char v13; // [sp+6h] [bp-6h]@6
  bool v14; // [sp+7h] [bp-5h]@1
  float v15; // [sp+8h] [bp-4h]@1

  v14 = (unsigned __int8)sub_1001B400() > 1u;
  v1 = 0;
  v12 = sub_10018D50(&v15);
  v8 = 1;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v2 = (unsigned __int16 *)&unk_10094958;
  if ( sub_10029100(0x2E6u) || sub_10029100(0x2E7u) )
    v2 = (unsigned __int16 *)&unk_10094950;
  v3 = 4;
  do
  {
    if ( sub_10029100(*v2) && sub_10029170(*v2, &v13) )
    {
      v10 += v13;
      ++v1;
      LOBYTE(v4) = v13 == 0;
      v11 += v13 == 0;
    }
    ++v2;
    --v3;
  }
  while ( v3 );
  v5 = byte_10094960[v1];
  if ( v10 >= (unsigned __int8)v5 )
    goto LABEL_20;
  if ( v11 >= (unsigned __int8)v5 )
    goto LABEL_19;
  if ( v14 )
  {
    if ( !sub_1001B430() )
    {
      if ( !v12 )
        goto LABEL_20;
      goto LABEL_18;
    }
LABEL_19:
    v8 = 1;
LABEL_21:
    v9 = 1;
    goto LABEL_22;
  }
  if ( v12 )
  {
LABEL_18:
    if ( v15 > 25.72207 )
      goto LABEL_19;
LABEL_20:
    v8 = 0;
    goto LABEL_21;
  }
  if ( sub_1001A070(v4) == 2 || sub_1001A070(v6) == 8 )
  {
    *a1 = 1;
    return 0;
  }
LABEL_22:
  *a1 = v8 == 0;
  return v9;
}

//----- (10019060) --------------------------------------------------------
bool __thiscall sub_10019060(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  return sub_1001A070(this) == 1 && sub_10018F20((bool *)&v2 + 3) && BYTE3(v2);
}

//----- (10019090) --------------------------------------------------------
signed int __cdecl sub_10019090(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_10094A50;
    v6 = &unk_10094A50;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_10094A68;
    v6 = &unk_10094A68;
    v5 = &a1;
  }
  v3 = sub_1001DC80(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (100190F0) --------------------------------------------------------
int __cdecl sub_100190F0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001DC80(&a1, 1u, (int)&unk_10094AB0, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_10094AB4[2 * v1];
  return result;
}
// 10094AB4: using guessed type int dword_10094AB4[];

//----- (10019130) --------------------------------------------------------
signed int __cdecl sub_10019130(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_10094AC0;
    v7 = &unk_10094AC0;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_10094AD8;
    v7 = &unk_10094AD8;
    v6 = &a1;
  }
  v4 = sub_1001DC80(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (100191A0) --------------------------------------------------------
int __cdecl sub_100191A0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001DC80(&a1, 1u, (int)&unk_10094AF0, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_10094AF4[2 * v1];
  return result;
}
// 10094AF4: using guessed type int dword_10094AF4[];

//----- (100191E0) --------------------------------------------------------
int __cdecl sub_100191E0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001DC80(&a1, 1u, (int)&unk_10094B08, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_10094B0C[2 * v1];
  return result;
}
// 10094B0C: using guessed type int dword_10094B0C[];

//----- (10019220) --------------------------------------------------------
char __cdecl sub_10019220(int a1)
{
  return sub_1004E840(6758, a1, 16380);
}

//----- (10019240) --------------------------------------------------------
char __cdecl sub_10019240(int a1, int a2)
{
  return sub_1004E840(a1 + 37000, a2, 284);
}

//----- (10019260) --------------------------------------------------------
char __cdecl sub_10019260(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10019090(a1, 11);
  return sub_1004E840(v2, a2, 24);
}

//----- (10019280) --------------------------------------------------------
char __cdecl sub_10019280(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100190F0(a1);
  return sub_1004E840(v2, a2, 2720);
}

//----- (100192B0) --------------------------------------------------------
char __cdecl sub_100192B0(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_10019130(a1, 11, 1);
  sub_1004E840(v2, a2, 36);
  v3 = sub_10019130(a1, 11, 0);
  return sub_1004E840(v3, a2 + 36, 32);
}

//----- (10019300) --------------------------------------------------------
char __cdecl sub_10019300(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100191A0(a1);
  return sub_1004E840(v2, a2, 2192);
}

//----- (10019330) --------------------------------------------------------
char __cdecl sub_10019330(int a1)
{
  return sub_1004E840(6005, a1, 4);
}

//----- (10019350) --------------------------------------------------------
char __cdecl sub_10019350(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100191E0(a1);
  return sub_1004E840(v2, a2, 60);
}

//----- (10019370) --------------------------------------------------------
char __cdecl sub_10019370(int a1)
{
  return sub_1004E840(6453, a1, 5);
}

//----- (10019390) --------------------------------------------------------
char __cdecl sub_10019390(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (100193D0) --------------------------------------------------------
char __cdecl sub_100193D0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 3;
      break;
    case 1:
      result = 4;
      break;
    case 2:
      result = 5;
      break;
    case 3:
      result = 40;
      break;
    case 4:
      result = 41;
      break;
    case 5:
      result = 51;
      break;
    case 6:
      result = 52;
      break;
    default:
      sub_1001B780("..\\lib\\adl\\iop_cdu_unit_intf.c", 490, 0, 0);
      result = 67;
      break;
  }
  return result;
}

//----- (10019440) --------------------------------------------------------
char __cdecl sub_10019440(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_1001B780("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (100194B0) --------------------------------------------------------
signed int __cdecl sub_100194B0(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_1001B780("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10019530) --------------------------------------------------------
char __cdecl sub_10019530(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_1001B780("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (100195A0) --------------------------------------------------------
char __cdecl sub_100195A0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_1001B780("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10019650) --------------------------------------------------------
char __cdecl sub_10019650(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 4:
      result = 0;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      if ( !(_BYTE)a1 )
        sub_1001B780("..\\lib\\adl\\iop_cdu_unit_intf.c", 859, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10019760) --------------------------------------------------------
char __cdecl sub_10019760(char a1, void *a2)
{
  int v2; // eax@1

  v2 = sub_1001DC80(&a1, 1u, (int)&unk_1009509C, 4, 7, 1);
  return sub_10010C50(6, (unsigned __int16)word_1009509E[2 * v2], a2);
}
// 1009509E: using guessed type __int16 word_1009509E[];

//----- (10019790) --------------------------------------------------------
char __cdecl sub_10019790(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_1001B780("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10019890) --------------------------------------------------------
char __usercall sub_10019890@<al>(int a1@<edi>, char a2, unsigned __int8 a3)
{
  int v3; // esi@1
  int v4; // eax@1
  char result; // al@2

  v3 = a3;
  v4 = sub_1001DC80(&a2, 1u, a1, 2, a3, a3);
  if ( v4 >= v3 )
    result = -80;
  else
    result = *(_BYTE *)(a1 + 2 * v4 + 1);
  return result;
}

//----- (100198C0) --------------------------------------------------------
char __cdecl sub_100198C0(char a1)
{
  return sub_10019890((int)&unk_10095040, a1, 0xBu);
}

//----- (100198E0) --------------------------------------------------------
char __cdecl sub_100198E0(char a1)
{
  return sub_10019890((int)&unk_10095058, a1, 0x13u);
}

//----- (10019900) --------------------------------------------------------
char __thiscall sub_10019900(void *this)
{
  int v1; // eax@1

  v1 = sub_1001B4A0(this);
  return sub_10019790(v1);
}

//----- (10019910) --------------------------------------------------------
char __cdecl sub_10019910(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_100198C0(a1);
  if ( v2 == -80 )
    result = 67;
  else
    result = sub_100237E0(v2);
  return result;
}

//----- (10019940) --------------------------------------------------------
char __cdecl sub_10019940(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_100198E0(a1);
  if ( v2 == -80 )
    result = 67;
  else
    result = sub_100237E0(v2);
  return result;
}

//----- (10019970) --------------------------------------------------------
bool __cdecl sub_10019970(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_10186B40 != 1379255385 )
    {
      sub_10019260(a1, (int)&byte_10186B48[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_10186B4D[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_10186B4C[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 10186B40: using guessed type int dword_10186B40;

//----- (100199E0) --------------------------------------------------------
bool __cdecl sub_100199E0(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_10186B40 != 1379255385 )
      sub_10019260(a1, (int)&byte_10186B48[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_10186B5C[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10186B40: using guessed type int dword_10186B40;
// 10186B5C: using guessed type int dword_10186B5C[];

//----- (10019A40) --------------------------------------------------------
bool __cdecl sub_10019A40(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_10186B40 != 1379255385 )
    {
      sub_10019260(a1, (int)&byte_10186B48[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_10186B54[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 10186B40: using guessed type int dword_10186B40;
// 10186B54: using guessed type int dword_10186B54[];

//----- (10019AB0) --------------------------------------------------------
char __cdecl sub_10019AB0(char a1, _BYTE *a2)
{
  if ( dword_10186B40 != 1379255385 )
    sub_10019260(a1, (int)&byte_10186B48[24 * (unsigned __int8)a1]);
  *a2 = byte_10186B48[24 * (unsigned __int8)a1];
  return 1;
}
// 10186B40: using guessed type int dword_10186B40;

//----- (10019AF0) --------------------------------------------------------
char __thiscall sub_10019AF0(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_10186B40 = sub_1001A070(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_10186B48, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_10186B48;
  do
  {
    result = sub_10019260(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 10186B40: using guessed type int dword_10186B40;

//----- (10019B60) --------------------------------------------------------
char __cdecl sub_10019B60(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_100194B0(a1);
  v3 = sub_1004FAA0(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10019B90) --------------------------------------------------------
char __cdecl sub_10019B90(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_100194B0(a1);
  v3 = sub_1004FB10(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10019BC0) --------------------------------------------------------
char __cdecl sub_10019BC0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_100195A0(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_10019A40(v7, *a4, (int)a5);
      }
      else
      {
        sub_1001B780("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_10019970(v7, *a4, (int)a5);
      }
      else
      {
        sub_1001B780("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_100199E0(v7, *a4, (int)a5);
      }
      else
      {
        sub_1001B780("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_10019AB0(v7, a5);
      }
      else
      {
        sub_1001B780("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_10019B90(v7, (int)a5);
      }
      else
      {
        sub_1001B780("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_10019B60(v7, (int)a5);
      }
      else
      {
        sub_1001B780("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_1001B780("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10019D90) --------------------------------------------------------
bool __thiscall sub_10019D90(void *this)
{
  return sub_1001A070(this) != 8;
}

//----- (10019DA0) --------------------------------------------------------
void sub_10019DA0()
{
  float v0; // ST00_4@1

  v0 = sub_1001B380();
  sub_1004E3F0(v0);
}
// 1001B380: using guessed type double sub_1001B380(void);

//----- (10019DC0) --------------------------------------------------------
char __thiscall sub_10019DC0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  if ( sub_1004E7C0(3137, (int)&v2 + 3, 1) )
  {
    sub_1004EEB0(86, (_BYTE *)&v2 + 3);
    sub_1004E8F0(3137, (int)&v2 + 3, 1);
  }
  return BYTE3(v2);
}

//----- (10019E00) --------------------------------------------------------
char __thiscall sub_10019E00(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_1004EC10(6077, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10019E30) --------------------------------------------------------
int __cdecl sub_10019E30(int a1, int a2, int a3)
{
  void *v3; // ecx@0
  int v4; // eax@1
  unsigned int v5; // esi@3
  int result; // eax@7

  v4 = a1;
  if ( !a1 )
    v4 = sub_1001B4A0(v3);
  v5 = 0;
  while ( v4 != dword_10095840[2 * v5] )
  {
    if ( ++v5 >= 0x1C )
      return sub_10020640(a2, &unk_10095944, a3);
  }
  result = sub_10020640(a2, off_10095844[2 * v5], a3);
  if ( v5 < 0x1C )
    return result;
  return sub_10020640(a2, &unk_10095944, a3);
}
// 10019E30: too many cbuild loops
// 10095840: using guessed type int dword_10095840[];

//----- (10019E90) --------------------------------------------------------
bool __thiscall sub_10019E90(void *this)
{
  int v1; // eax@2
  bool result; // al@2
  unsigned __int16 v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@1

  LOBYTE(v4) = sub_10019900(this);
  v5 = 2;
  sub_1004E880(9129, &v3, 2, &v5);
  if ( sub_1001FAA0(v4, 4) )
  {
    v1 = sub_1001DC80(&v4, 1u, (int)&unk_10095920, 8, 2, 2);
    result = (v3 & (unsigned __int16)word_10095924[4 * v1]) != 0;
  }
  else
  {
    result = sub_1001FAA0(v4, 2) || sub_1001FD20(6) || sub_1001FD20(8) || sub_1001FAA0(v4, 12) || sub_1001FAA0(v4, 16);
  }
  return result;
}
// 10095924: using guessed type __int16 word_10095924[];

//----- (10019F60) --------------------------------------------------------
char __cdecl sub_10019F60(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 1005091E: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);

//----- (10019F80) --------------------------------------------------------
char sub_10019F80()
{
  char v0; // cl@1
  char result; // al@1

  v0 = *(_BYTE *)dword_1022D6E8;
  result = 0;
  if ( *(_BYTE *)dword_1022D6E8 == 37 || v0 == 3 || v0 == 35 || v0 == 36 || v0 == 40 || v0 == 47 )
    result = 1;
  return result;
}

//----- (10019FB0) --------------------------------------------------------
int __cdecl sub_10019FB0(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_1001B780("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_1001B780("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050924: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (1001A010) --------------------------------------------------------
char __thiscall sub_1001A010(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10019FB0(18, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1001A030) --------------------------------------------------------
char __thiscall sub_1001A030(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10019FB0(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1001A050) --------------------------------------------------------
int __thiscall sub_1001A050(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10019FB0(29, (char *)&v2);
  return (int)v2;
}

//----- (1001A070) --------------------------------------------------------
char __thiscall sub_1001A070(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10019FB0(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1001A090) --------------------------------------------------------
char __thiscall sub_1001A090(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10019FB0(37, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1001A0B0) --------------------------------------------------------
char __thiscall sub_1001A0B0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10019FB0(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1001A0D0) --------------------------------------------------------
BOOL sub_1001A0D0()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 1;
  sub_10019FB0(49, &v1);
  return v1 == 0;
}

//----- (1001A0F0) --------------------------------------------------------
int __cdecl sub_1001A0F0(char a1)
{
  return sub_10019FB0(73, &a1);
}

//----- (1001A100) --------------------------------------------------------
int __cdecl sub_1001A100(char a1)
{
  return sub_10019FB0(80, &a1);
}

//----- (1001A110) --------------------------------------------------------
int __cdecl sub_1001A110(char a1)
{
  return sub_10019FB0(92, &a1);
}

//----- (1001A120) --------------------------------------------------------
char __fastcall sub_1001A120(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  BYTE3(v2) = 0;
  if ( sub_1004E7C0(2018, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 2u) )
  {
    BYTE3(v2) = 0;
    sub_1004E8F0(2018, (int)&v2 + 3, 1);
    result = BYTE3(v2);
  }
  return result;
}

//----- (1001A170) --------------------------------------------------------
BOOL __cdecl sub_1001A170(char a1)
{
  int v1; // esi@1
  int v2; // esi@3
  int v3; // esi@3
  int v4; // esi@3
  int v5; // esi@3
  int v6; // esi@3
  int v7; // esi@3
  int v8; // esi@3
  int v10; // esi@4
  int v11; // esi@4
  int v12; // esi@4
  int v13; // esi@4
  int v14; // esi@4
  int v15; // esi@4
  int v16; // esi@4

  v1 = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v2 = (unsigned __int8)sub_1001FC40(11);
      v3 = (unsigned __int8)sub_1001FC40(12) + v2;
      v4 = (unsigned __int8)sub_1001FC40(13) + v3;
      v5 = (unsigned __int8)sub_1001FC40(28) + v4;
      v6 = (unsigned __int8)sub_1001FC40(29) + v5;
      v7 = (unsigned __int8)sub_1001FC40(34) + v6;
      v8 = (unsigned __int8)sub_10029100(0x1EDu) + v7;
      return (unsigned __int8)sub_1001FC70(19) + v8 == 1;
    }
  }
  else
  {
    v10 = (unsigned __int8)sub_1001FC40(5);
    v11 = (unsigned __int8)sub_1001FC40(6) + v10;
    v12 = (unsigned __int8)sub_1001FC40(7) + v11;
    v13 = (unsigned __int8)sub_1001FC40(26) + v12;
    v14 = (unsigned __int8)sub_1001FC40(27) + v13;
    v15 = (unsigned __int8)sub_1001FC40(33) + v14;
    v16 = (unsigned __int8)sub_10029100(0x1ECu) + v15;
    v1 = (unsigned __int8)sub_1001FC70(17) + v16;
  }
  return v1 == 1;
}

//----- (1001A270) --------------------------------------------------------
char __cdecl sub_1001A270(unsigned int a1)
{
  unsigned int v1; // ecx@1
  unsigned int v2; // ebx@1
  unsigned int v3; // ebx@1
  unsigned int v4; // eax@1
  unsigned __int8 v5; // bl@4
  char result; // al@4
  unsigned __int8 v7; // [sp+8h] [bp+4h]@1

  v1 = a1 / 0x3E8;
  v2 = a1 % 0x3E8;
  v7 = a1 % 0x3E8 / 0x64;
  v3 = -100 * v7 + v2;
  v4 = v3 / 0xA;
  if ( (unsigned __int8)v1 >= 8u || v7 >= 8u || (unsigned __int8)v4 >= 8u || (v5 = v3 - 10 * v4, result = 1, v5 >= 8u) )
    result = 0;
  return result;
}

//----- (1001A2E0) --------------------------------------------------------
char __cdecl sub_1001A2E0(char a1)
{
  char result; // al@1

  result = 0;
  if ( !a1 )
  {
    if ( sub_1001FC40(33) || sub_1001FC70(17) )
      return 1;
    return 0;
  }
  if ( a1 != 1 )
    return result;
  if ( !sub_1001FC40(34) && !sub_1001FC70(19) )
    return 0;
  return 1;
}

//----- (1001A330) --------------------------------------------------------
char __cdecl sub_1001A330(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_1001FC40(11);
  }
  else
  {
    result = sub_1001FC40(5);
  }
  return result;
}

//----- (1001A360) --------------------------------------------------------
BOOL __cdecl sub_1001A360(char a1)
{
  int v1; // esi@1
  int v2; // esi@3
  int v3; // esi@3
  char v4; // al@3
  int v5; // esi@4
  char v7; // [sp-10h] [bp-14h]@3

  v1 = 0;
  if ( !a1 )
  {
    v5 = (unsigned __int8)sub_1001FC40(6);
    v3 = (unsigned __int8)sub_1001FC40(7) + v5;
    v4 = sub_1001FC40(26);
    v7 = 27;
    goto LABEL_5;
  }
  if ( a1 == 1 )
  {
    v2 = (unsigned __int8)sub_1001FC40(12);
    v3 = (unsigned __int8)sub_1001FC40(13) + v2;
    v4 = sub_1001FC40(28);
    v7 = 29;
LABEL_5:
    v1 = (unsigned __int8)sub_1001FC40(v7) + (unsigned __int8)v4 + v3;
  }
  return v1 == 1;
}

//----- (1001A3D0) --------------------------------------------------------
char __cdecl sub_1001A3D0(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_10029100(0x1EDu);
  }
  else
  {
    result = sub_10029100(0x1ECu);
  }
  return result;
}

//----- (1001A400) --------------------------------------------------------
void sub_1001A400()
{
  dword_10236864 = -15;
}
// 10236864: using guessed type int dword_10236864;

//----- (1001A410) --------------------------------------------------------
char __cdecl sub_1001A410(char a1, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // edx@1
  int v5; // eax@1
  int v7; // [sp+0h] [bp-20h]@1
  int v8; // [sp+4h] [bp-1Ch]@1
  int v9; // [sp+8h] [bp-18h]@1
  int v10; // [sp+Ch] [bp-14h]@1
  int v11; // [sp+10h] [bp-10h]@1
  int v12; // [sp+14h] [bp-Ch]@1
  int v13; // [sp+18h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  LOBYTE(v8) = a1;
  v2 = *(_DWORD *)(a2 + 4);
  v9 = *(_DWORD *)a2;
  v3 = *(_DWORD *)(a2 + 8);
  v10 = v2;
  v4 = *(_DWORD *)(a2 + 12);
  v5 = *(_DWORD *)(a2 + 16);
  v11 = v3;
  LOWORD(v7) = -32759;
  v12 = v4;
  v13 = v5;
  return sub_10023A70((int)&v7);
}

//----- (1001A490) --------------------------------------------------------
char __usercall sub_1001A490@<al>(unsigned __int8 a1@<al>, _BYTE *a2)
{
  int v2; // ecx@1

  v2 = 0;
  while ( (a1 & (unsigned __int8)byte_100967F8[2 * v2]) != byte_100967F8[2 * v2] )
  {
    if ( ++v2 >= 5 )
      return 0;
  }
  *a2 = byte_100967F9[2 * v2];
  return 1;
}

//----- (1001A4C0) --------------------------------------------------------
char __usercall sub_1001A4C0@<al>(bool *a1@<esi>)
{
  bool v1; // bl@1
  char result; // al@2

  v1 = *a1 == 0;
  if ( (unsigned __int8)sub_1001A170(v1) )
  {
    *a1 = v1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001A4F0) --------------------------------------------------------
char __cdecl sub_1001A4F0(char a1)
{
  int v1; // ecx@0
  int v2; // edx@1
  __int64 v3; // rax@1
  int v5; // [sp+0h] [bp-1Ch]@1
  int v6; // [sp+4h] [bp-18h]@1
  __int64 v7; // [sp+8h] [bp-14h]@1
  int v8; // [sp+10h] [bp-Ch]@1
  __int16 v9; // [sp+14h] [bp-8h]@1

  v2 = *(_DWORD *)v1;
  v6 = 0;
  v7 = 0i64;
  v8 = 0;
  v5 = 0;
  v9 = 0;
  LOBYTE(v6) = a1;
  LODWORD(v3) = *(_DWORD *)(v1 + 4);
  *(int *)((char *)&v6 + 2) = v2;
  HIDWORD(v3) = *(_DWORD *)(v1 + 8);
  *(__int64 *)((char *)&v7 + 2) = v3;
  LODWORD(v3) = *(_DWORD *)(v1 + 12);
  LOWORD(v5) = -32758;
  *(int *)((char *)&v8 + 2) = v3;
  return sub_10023A70((int)&v5);
}

//----- (1001A560) --------------------------------------------------------
char __cdecl sub_1001A560(void *a1, int a2)
{
  unsigned __int8 v2; // al@3
  char v3; // al@6
  bool v4; // al@8
  bool v5; // zf@8
  char v6; // cl@8
  int v7; // eax@8
  unsigned __int8 v8; // al@18
  int v9; // ecx@18
  int v10; // edx@18
  char v11; // al@22
  char result; // al@32
  char v13; // [sp+Ah] [bp-4Eh]@1
  bool v14; // [sp+Bh] [bp-4Dh]@1
  int v15; // [sp+Ch] [bp-4Ch]@1
  int v16; // [sp+10h] [bp-48h]@1
  unsigned __int8 v17; // [sp+14h] [bp-44h]@13
  int v18; // [sp+18h] [bp-40h]@14
  char v19; // [sp+20h] [bp-38h]@5
  char v20; // [sp+23h] [bp-35h]@10
  char v21; // [sp+26h] [bp-32h]@8
  int v22; // [sp+4Ah] [bp-Eh]@6
  char v23; // [sp+52h] [bp-6h]@8

  *(_DWORD *)a1 = 0;
  *((_DWORD *)a1 + 1) = 0;
  *((_DWORD *)a1 + 2) = 0;
  *((_DWORD *)a1 + 3) = 0;
  v14 = 0;
  v13 = 0;
  v15 = 0;
  v16 = 0;
  if ( (unsigned __int8)a2 >= 2u )
    goto LABEL_25;
  if ( !sub_1001A3D0(a2) )
  {
    if ( !sub_1001A2E0(a2) )
    {
      if ( (unsigned __int8)a2 == 1 )
        v11 = sub_10010C50(1, 1221, a1);
      else
        v11 = sub_10010C50(1, 1209, a1);
      v13 = v11;
      goto LABEL_25;
    }
    if ( sub_1002B1A0(a2, 1, &v17)
      && sub_1003D440(v18, &v15)
      && sub_1003D440(HIWORD(v18), &v16)
      && sub_1001A490(v17, (_BYTE *)a1 + 3)
      && sub_1002B1A0(a2, 2, &v17) )
    {
      v8 = v17;
      v5 = (v17 & 0x80) == -128;
      v9 = (unsigned __int16)v15;
      *(_BYTE *)a1 = (v17 & 0x10) == 16;
      *((_BYTE *)a1 + 2) = v5;
      v10 = (unsigned __int16)v16;
      v13 = 1;
      *((_DWORD *)a1 + 3) = v9;
      *((_DWORD *)a1 + 2) = v10;
      if ( v8 & 2 )
        *((_BYTE *)a1 + 1) = 2;
      else
        *((_BYTE *)a1 + 1) = (v8 & 8) == 8;
      goto LABEL_25;
    }
LABEL_11:
    v13 = 0;
    goto LABEL_25;
  }
  v2 = sub_1001DC80(&a2, 1u, (int)&unk_100967E8, 4, 2, 0);
  if ( !sub_10029170((unsigned __int16)word_100967EA[2 * v2], &v13) || !v13 )
    goto LABEL_11;
  if ( !sub_100352D0(&v19) || (v3 = sub_1003D440(v22, &v15), v13 = 1, !v3) )
    v13 = 0;
  v4 = sub_10035320();
  v5 = v23 == 1;
  v6 = v21;
  *(_BYTE *)a1 = v4;
  v7 = (unsigned __int16)v15;
  *((_BYTE *)a1 + 3) = 0;
  *((_BYTE *)a1 + 2) = v6;
  *((_DWORD *)a1 + 3) = v7;
  *((_DWORD *)a1 + 2) = v7;
  if ( v5 )
    *((_BYTE *)a1 + 1) = 2;
  else
    *((_BYTE *)a1 + 1) = v20 == 0;
LABEL_25:
  if ( sub_10022F10((unsigned __int8 *)a1)
    || !sub_1001A270(*((_DWORD *)a1 + 2))
    || !sub_1001A270(*((_DWORD *)a1 + 3))
    || sub_1001A330(a2) && *((_BYTE *)a1 + 1) == 3 )
  {
    result = 0;
  }
  else
  {
    sub_1004E7C0(9241, (int)&v14, 1);
    if ( v14 != (*(_BYTE *)a1 == 1) )
    {
      v14 = *(_BYTE *)a1 == 1;
      sub_1004E8F0(9241, (int)&v14, 1);
    }
    result = v13;
  }
  return result;
}
// 100967EA: using guessed type __int16 word_100967EA[];

//----- (1001A810) --------------------------------------------------------
char __cdecl sub_1001A810(int a1, void *a2)
{
  char result; // al@2
  int v3; // esi@3
  void *v4; // ecx@5

  if ( (_BYTE)a1 )
  {
    result = a1 - 1;
    if ( (unsigned __int8)a1 != 1 )
      return result;
    v3 = 1212;
  }
  else
  {
    v3 = 1200;
  }
  sub_100106F0(1, v3, a2, 0, 2, 1);
  sub_100108A0(1, v3, 0xFFFFFFF);
  result = sub_1001A070(v4);
  if ( result == 4 )
    result = sub_1001A410(a1, (int)a2);
  return result;
}

//----- (1001A870) --------------------------------------------------------
char __cdecl sub_1001A870(int a1)
{
  int v1; // ecx@0
  char result; // al@1
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  result = a1;
  LOWORD(v3) = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    LOWORD(v3) = 12809;
    result = sub_1001A810(a1, &v3);
  }
  return result;
}

//----- (1001A8A0) --------------------------------------------------------
char __cdecl sub_1001A8A0(void *a1)
{
  int v1; // ecx@0
  int v2; // ST08_4@1

  v2 = v1;
  LOBYTE(v2) = sub_1001A120(v1);
  return sub_1001A560(a1, v2);
}

//----- (1001A8C0) --------------------------------------------------------
char __cdecl sub_1001A8C0(char a1)
{
  int v1; // ecx@0
  char v2; // bl@1
  __int16 v4; // [sp+4h] [bp-50h]@1
  int v5; // [sp+8h] [bp-4Ch]@1
  int v6; // [sp+Ch] [bp-48h]@1
  int v7; // [sp+10h] [bp-44h]@1
  int v8; // [sp+14h] [bp-40h]@1
  int v9; // [sp+18h] [bp-3Ch]@1
  char v10; // [sp+1Ch] [bp-38h]@3
  char v11; // [sp+20h] [bp-34h]@4

  v2 = 0;
  v4 = 0;
  LOBYTE(v5) = sub_1001A120(v1);
  LOBYTE(v4) = 32;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  if ( (unsigned __int8)v5 < 2u )
  {
    if ( sub_1001A3D0(v5) )
    {
      if ( sub_100352D0(&v10) )
      {
        v11 = a1;
        sub_10035270(&v10);
        return 1;
      }
    }
    else if ( sub_1001A8A0(&v6) )
    {
      if ( a1 == 1 )
      {
        v2 = 1;
        if ( BYTE1(v6) != 2 )
        {
          if ( sub_1001A2E0(v5) )
          {
            sub_1002B2F0(2, 2, 0);
            return 1;
          }
          HIBYTE(v4) = 1;
          sub_1001A810(v5, &v4);
        }
      }
      else if ( !sub_1001A2E0(v5) )
      {
        v2 = 1;
        HIBYTE(v4) = 0;
        sub_1001A810(v5, &v4);
      }
    }
  }
  return v2;
}

//----- (1001A9E0) --------------------------------------------------------
char __cdecl sub_1001A9E0(int a1, void *a2)
{
  char v2; // bl@1
  char v3; // al@3
  bool v4; // al@16
  char result; // al@19
  __int16 v6; // kr00_2@21
  char v7; // [sp+Ah] [bp-12h]@1
  char v8; // [sp+Bh] [bp-11h]@6
  int v9; // [sp+Ch] [bp-10h]@1
  int v10; // [sp+10h] [bp-Ch]@1
  int v11; // [sp+14h] [bp-8h]@1
  int v12; // [sp+18h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v2 = 0;
  v7 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
      goto LABEL_6;
    v2 = sub_10010C50(1, 1215, a2);
    v3 = sub_10010C50(1, 1221, &v9);
  }
  else
  {
    v2 = sub_10010C50(1, 1203, a2);
    v3 = sub_10010C50(1, 1209, &v9);
  }
  v7 = v3;
LABEL_6:
  v8 = sub_1001A330(a1);
  if ( sub_10022B70((int)a2)
    || !sub_1001A270(*((_WORD *)a2 + 6))
    || !sub_1001A270(*((_WORD *)a2 + 7))
    || *((_BYTE *)a2 + 11) >= 8u && !v8
    || *(_BYTE *)a2 == 3 && v8 )
  {
    v2 = 0;
  }
  v4 = v7 && !sub_10022F10((unsigned __int8 *)&v9);
  if ( v2 )
  {
    if ( v4 )
    {
      v6 = *(_WORD *)((char *)&v9 + 1);
      *((_WORD *)a2 + 6) = v12;
      *(_BYTE *)a2 = v6;
      *((_BYTE *)a2 + 1) = HIBYTE(v6);
    }
    result = v2;
  }
  else
  {
    sub_1001A870(a1);
    result = 0;
  }
  return result;
}

//----- (1001AB10) --------------------------------------------------------
bool __cdecl sub_1001AB10(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // edx@1
  int v4; // eax@1
  bool v5; // bl@1
  int v7; // esi@15
  void *v8; // ecx@18
  int v9; // [sp+8h] [bp-24h]@1
  int v10; // [sp+Ch] [bp-20h]@1
  int v11; // [sp+10h] [bp-1Ch]@1
  int v12; // [sp+14h] [bp-18h]@1
  int v13; // [sp+18h] [bp-14h]@1
  int v14; // [sp+1Ch] [bp-10h]@1
  int v15; // [sp+20h] [bp-Ch]@1
  int v16; // [sp+24h] [bp-8h]@1

  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(_DWORD *)(a2 + 8);
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v4 = *(_DWORD *)a2;
  v10 = v2;
  v11 = v3;
  v9 = v4;
  v5 = 0;
  v12 = *(_DWORD *)(a2 + 12);
  if ( sub_1001A9E0(a1, &v13) )
    BYTE3(v11) = BYTE3(v15);
  if ( sub_1001A270(*(_WORD *)(a2 + 12)) && sub_1001A270(*(_WORD *)(a2 + 14)) && (unsigned __int8)a1 < 2u )
  {
    if ( sub_1001A330(a1) )
      v5 = (unsigned __int8)v9 < 6u && (_BYTE)v9 != 3;
    else
      v5 = (unsigned __int8)v9 < 4u;
  }
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
      return 0;
    v7 = 1214;
  }
  else
  {
    v7 = 1202;
  }
  if ( v5 == 1 )
  {
    sub_100106F0(1, v7, &v9, 0, 16, 1);
    sub_100108A0(1, v7, 0xFFFFFFF);
    if ( sub_1001A070(v8) == 4 )
      sub_1001A4F0(a1);
    sub_1001A870(a1);
  }
  return v5;
}

//----- (1001AC60) --------------------------------------------------------
char __cdecl sub_1001AC60(unsigned __int8 a1)
{
  int v1; // ecx@0
  char v2; // bl@1
  char result; // al@18
  int v4; // esi@29
  char v5; // [sp+7h] [bp-4Dh]@19
  int v6; // [sp+8h] [bp-4Ch]@1
  int v7; // [sp+Ch] [bp-48h]@1
  int v8; // [sp+10h] [bp-44h]@1
  int v9; // [sp+14h] [bp-40h]@1
  int v10; // [sp+18h] [bp-3Ch]@1
  char v11; // [sp+1Ch] [bp-38h]@4
  char v12; // [sp+1Fh] [bp-35h]@10
  char v13; // [sp+24h] [bp-30h]@12
  char v14; // [sp+45h] [bp-Fh]@5
  char v15; // [sp+4Eh] [bp-6h]@9

  v2 = 0;
  LOBYTE(v6) = sub_1001A120(v1);
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( (unsigned __int8)v6 >= 2u )
    return v2;
  if ( sub_1001A3D0(v6) || sub_1001A2E0(v6) )
  {
    v2 = sub_100352D0(&v11);
    if ( v2 )
    {
      v14 = 0;
      if ( a1 )
      {
        if ( a1 == 1 )
        {
          v15 = 0;
          v12 = 0;
          goto LABEL_13;
        }
        if ( a1 != 2 )
        {
          v2 = 0;
LABEL_13:
          sub_10035270(&v11);
          goto LABEL_14;
        }
        v15 = 1;
      }
      else
      {
        v15 = 0;
        v12 = 1;
      }
      v13 = 1;
      goto LABEL_13;
    }
  }
LABEL_14:
  if ( !sub_1001A2E0(v6) )
  {
    if ( (a1 < 3u || a1 < 4u && (unsigned __int8)sub_1001A360(v6)) && sub_1001A9E0(v6, &v7) )
    {
      v2 = 1;
      LOBYTE(v7) = a1;
      sub_1001AB10(v6, (int)&v7);
      if ( a1 == 2 )
        sub_1001A8C0(0);
      if ( sub_1001A4C0((bool *)&v6) )
      {
        v4 = v6;
        if ( a1 < 3u || (unsigned __int8)sub_1001A360(v6) )
          sub_1001AB10(v4, (int)&v7);
      }
      sub_1004E8F0(2105, (int)&v7, 16);
    }
    return v2;
  }
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v5 = 0;
      sub_1002B2F0(2, 5, &v5);
      v5 = 1;
      sub_1002B2F0(2, 7, &v5);
      result = 1;
    }
    else if ( a1 == 2 )
    {
      v5 = 1;
      sub_1002B2F0(2, 5, &v5);
      v5 = 0;
      sub_1002B2F0(2, 7, &v5);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v5 = 0;
    sub_1002B2F0(2, 5, &v5);
    sub_1002B2F0(2, 7, &v5);
    result = 1;
  }
  return result;
}

//----- (1001AEC0) --------------------------------------------------------
void sub_1001AEC0()
{
  dword_10186B90 = -15;
}
// 10186B90: using guessed type int dword_10186B90;

//----- (1001AED0) --------------------------------------------------------
signed int sub_1001AED0()
{
  signed int result; // eax@3

  if ( (unsigned __int8)byte_10186B94 > 2u )
    sub_1001B780("..\\lib\\adl\\iop_ap_intf.c", 958, 0, 0);
  result = (unsigned __int8)byte_10186B94;
  if ( (unsigned __int8)byte_10186B94 >= 2u )
    result = 2;
  byte_10186B94 = result;
  return result;
}
// 10186B94: using guessed type char byte_10186B94;

//----- (1001AF10) --------------------------------------------------------
char __thiscall sub_1001AF10(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1004E8C0(3190, (int)&v2 + 3, 1);
  return BYTE3(v2);
}

//----- (1001AF30) --------------------------------------------------------
char __cdecl sub_1001AF30(char a1)
{
  char result; // al@2
  char v2; // [sp+2h] [bp-2h]@1
  char v3; // [sp+3h] [bp-1h]@1

  v3 = 1;
  v2 = 1;
  if ( a1 )
  {
    sub_1004E880(9420, &v2, 1, &v3);
    result = v2;
  }
  else
  {
    sub_1004E880(9419, &v2, 1, &v3);
    result = v2;
  }
  return result;
}

//----- (1001AF80) --------------------------------------------------------
char __thiscall sub_1001AF80(void *this)
{
  char result; // al@3
  unsigned int v2; // [sp-2h] [bp-4h]@1

  v2 = (unsigned int)this;
  if ( sub_10010C50(1, 43, (char *)&v2 + 3) && !sub_10020990((unsigned __int8 *)&v2 + 3) )
    result = BYTE3(v2);
  else
    result = 0;
  return result;
}

//----- (1001AFC0) --------------------------------------------------------
char __thiscall sub_1001AFC0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 2;
  sub_1004EC10(9860, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1001AFF0) --------------------------------------------------------
char sub_1001AFF0()
{
  char v1; // [sp+2h] [bp-2h]@1
  char v2; // [sp+3h] [bp-1h]@1

  v1 = 0;
  v2 = 0;
  sub_1004E880(6888, &v1, 1, &v2);
  return v1;
}

//----- (1001B020) --------------------------------------------------------
int __cdecl sub_1001B020(int a1)
{
  char v1; // cl@3
  char v2; // al@6
  int result; // eax@12

  result = 0;
  if ( !*(_BYTE *)a1 )
  {
    if ( *(_BYTE *)(a1 + 34) )
    {
      v1 = *(_BYTE *)(a1 + 7);
      if ( v1 == 3 || v1 == 4 || v1 == 13 )
      {
        v2 = *(_BYTE *)(a1 + 8);
        if ( !v2 || v2 == 1 || v2 == 7 || v2 == 8 || v2 == 9 || v2 == 10 )
          result = 1;
      }
    }
  }
  return result;
}

//----- (1001B070) --------------------------------------------------------
char sub_1001B070()
{
  char result; // al@1

  byte_10186B94 = 2;
  result = sub_1001FC70(4);
  if ( result )
  {
    byte_10186B94 = 0;
  }
  else
  {
    result = sub_1001FC70(7);
    if ( result )
      byte_10186B94 = 1;
  }
  return result;
}
// 10186B94: using guessed type char byte_10186B94;

//----- (1001B0B0) --------------------------------------------------------
char __cdecl sub_1001B0B0(char a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  char v4; // [sp+1h] [bp-1h]@1

  v4 = sub_10029030(v1);
  v2 = sub_1001DC80(&v4, 1u, (int)&unk_10097EE8, 4, 2, 0);
  return sub_1004E9B0((unsigned __int16)word_10097EEA[2 * v2], (int)&a1, 1);
}
// 10097EEA: using guessed type __int16 word_10097EEA[];

//----- (1001B0F0) --------------------------------------------------------
int __cdecl sub_1001B0F0(char a1)
{
  return sub_1004E8F0(9860, (int)&a1, 1);
}

//----- (1001B110) --------------------------------------------------------
double __cdecl sub_1001B110(char a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  void *v3; // ecx@1
  char v5; // [sp+4h] [bp-Ch]@2
  float v6; // [sp+8h] [bp-8h]@2

  v2 = sub_10029030(v1);
  if ( sub_1001AF10(v3) )
    goto LABEL_2;
  if ( a1 )
  {
    if ( v2 )
    {
      sub_1004E8C0(2015, (int)&v5, 12);
      return v6;
    }
    sub_1004E8C0(2101, (int)&v5, 12);
  }
  else
  {
    if ( !v2 )
    {
LABEL_2:
      sub_1004E8C0(2015, (int)&v5, 12);
      return v6;
    }
    sub_1004E8C0(2101, (int)&v5, 12);
  }
  return v6;
}

//----- (1001B190) --------------------------------------------------------
bool __usercall sub_1001B190@<al>(int a1@<eax>)
{
  signed int v1; // eax@17
  bool result; // al@19

  result = 0;
  if ( *(_BYTE *)(a1 + 2) < 3u
    && *(_BYTE *)(a1 + 10) < 3u
    && *(_BYTE *)a1 < 8u
    && *(_BYTE *)(a1 + 1) < 0xBu
    && *(_BYTE *)(a1 + 3) < 0xFu
    && *(_BYTE *)(a1 + 4) < 0xDu
    && *(_BYTE *)(a1 + 5) < 6u
    && *(_BYTE *)(a1 + 24) < 0xDu
    && *(_BYTE *)(a1 + 6) < 7u
    && *(_BYTE *)(a1 + 25) < 0xDu
    && *(_BYTE *)(a1 + 7) < 0xEu
    && *(_BYTE *)(a1 + 8) < 0xDu
    && *(_BYTE *)(a1 + 9) < 8u
    && *(_BYTE *)(a1 + 26) < 0xDu
    && *(_BYTE *)(a1 + 11) < 0x13u
    && *(_BYTE *)(a1 + 12) < 0xDu )
  {
    v1 = *(_DWORD *)(a1 + 20);
    if ( v1 >= 0 && v1 <= 357913941 )
      result = 1;
  }
  return result;
}

//----- (1001B200) --------------------------------------------------------
char __cdecl sub_1001B200(char *a1)
{
  char *v1; // edi@1
  char v2; // bl@1
  signed int v3; // ebp@1
  char *v4; // esi@1
  char v5; // al@2
  bool v6; // al@4
  char result; // al@13
  char v8; // dh@15
  bool v9; // al@16
  bool v10; // bl@20
  void *v11; // ecx@22
  char v12; // al@23
  int v13; // eax@23
  __int16 v14; // [sp+10h] [bp-88h]@1
  int v15; // [sp+14h] [bp-84h]@1
  char *v16; // [sp+18h] [bp-80h]@1
  char v17; // [sp+1Ch] [bp-7Ch]@27
  char v18; // [sp+20h] [bp-78h]@16
  char v19; // [sp+3Eh] [bp-5Ah]@29
  char v20; // [sp+58h] [bp-40h]@1
  char v21; // [sp+5Ch] [bp-3Ch]@19
  char v22; // [sp+7Ah] [bp-1Eh]@31

  v16 = a1;
  v15 = 3342386;
  v1 = 0;
  v2 = sub_1001AED0();
  v14 = 0;
  v3 = 1;
  v4 = &v20;
  do
  {
    v5 = sub_10010C50(1, *((_WORD *)&v15 + v3), v4);
    *((_BYTE *)&v14 + v3) = v5;
    v6 = v5 && !sub_10022E10((unsigned __int8 *)v4);
    *((_BYTE *)&v14 + v3) = v6;
    if ( v6 && *v4 == v2 )
      v1 = v4;
    --v3;
    v4 -= 60;
  }
  while ( v3 >= 0 );
  if ( !v1 )
    return 0;
  if ( v2 )
  {
    if ( v2 != 1 )
      return 0;
    goto LABEL_34;
  }
  v8 = HIBYTE(v14);
  if ( !(_BYTE)v14 || (v9 = sub_1001B190((int)&v18), LOBYTE(v14) = 1, !v9) )
    LOBYTE(v14) = 0;
  v10 = v8 && sub_1001B190((int)&v21);
  if ( sub_1001AFF0() )
  {
    v12 = sub_10029030(v11);
    LOBYTE(v15) = v12;
    v13 = (unsigned __int8)sub_1001AF30(v12) - 1;
    if ( v13 )
    {
      if ( v13 != 1 )
        return 0;
      goto LABEL_32;
    }
    if ( !(_BYTE)v14 )
      return 0;
LABEL_27:
    result = 1;
    qmemcpy(v16, &v17, 0x3Cu);
    return result;
  }
  if ( (_BYTE)v14 && (v19 || !v10 || !v22) )
    goto LABEL_27;
LABEL_32:
  if ( !v10 )
    return 0;
  v1 = &v20;
LABEL_34:
  result = 1;
  qmemcpy(v16, v1, 0x3Cu);
  return result;
}

//----- (1001B380) --------------------------------------------------------
void sub_1001B380()
{
  sub_1001B110(0);
}

//----- (1001B390) --------------------------------------------------------
int __cdecl sub_1001B390(int a1, int a2, int a3)
{
  byte_10236830 = 0;
  return nullsub_1(a1, a2, a3);
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10236830: using guessed type char byte_10236830;

//----- (1001B3A0) --------------------------------------------------------
void sub_1001B3A0()
{
  dword_10236860 = -15;
}
// 10236860: using guessed type int dword_10236860;

//----- (1001B3B0) --------------------------------------------------------
int sub_1001B3B0()
{
  int result; // eax@1

  result = 0;
  dword_10186B98 = -15;
  dword_1023685C = 0;
  dword_10236850 = 0;
  dword_10236854 = 0;
  dword_10236858 = 0;
  return result;
}
// 10186B98: using guessed type int dword_10186B98;
// 10236850: using guessed type int dword_10236850;
// 10236854: using guessed type int dword_10236854;
// 10236858: using guessed type int dword_10236858;
// 1023685C: using guessed type int dword_1023685C;

//----- (1001B3E0) --------------------------------------------------------
void sub_1001B3E0()
{
  dword_10236840 = -15;
}
// 10236840: using guessed type int dword_10236840;

//----- (1001B3F0) --------------------------------------------------------
signed int sub_1001B3F0()
{
  return sub_1004F6B0((int)&off_10097F7C);
}
// 10097F7C: using guessed type char *off_10097F7C;

//----- (1001B400) --------------------------------------------------------
signed int sub_1001B400()
{
  char v0; // bl@1
  signed int result; // eax@3

  v0 = 1;
  if ( (unsigned __int8)sub_1001B3F0() )
    v0 = *(_BYTE *)(dword_10236840 + 1456);
  result = (unsigned __int8)v0;
  if ( (unsigned __int8)v0 >= 8u )
    result = 1;
  return result;
}
// 10236840: using guessed type int dword_10236840;

//----- (1001B430) --------------------------------------------------------
char sub_1001B430()
{
  char v0; // bl@1

  v0 = 0;
  if ( (unsigned __int8)sub_1001B3F0() )
  {
    sub_1004E560(101, 10000);
    if ( !*(_BYTE *)(dword_10236840 + 1444)
      || !*(_BYTE *)(dword_10236840 + 1451)
      || (v0 = 1, *(_WORD *)(dword_10236840 + 1456) <= 1u)
      || *(float *)(dword_10236840 + 1480) <= 15.433242 )
    {
      v0 = 0;
    }
    sub_1004E540(101);
  }
  return v0;
}
// 10236840: using guessed type int dword_10236840;

//----- (1001B4A0) --------------------------------------------------------
int __thiscall sub_1001B4A0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10019FB0(46, (char *)&v2);
  return (int)v2;
}

//----- (1001B4C0) --------------------------------------------------------
bool __cdecl sub_1001B4C0(char a1)
{
  void *v1; // ecx@0
  bool result; // al@2
  void *v3; // ecx@4

  switch ( a1 )
  {
    case 5:
      result = sub_10020460(0) == 1;
      break;
    case 6:
      goto LABEL_3;
    case 9:
      if ( sub_1001B4A0(v1) & 3 || sub_1001A0B0(v3) == 1 )
        result = 1;
      else
LABEL_3:
        result = 0;
      break;
    case 8:
      result = sub_1001A0B0(v1) != 1;
      break;
    default:
      result = sub_1001A0B0(v1) == 1;
      break;
  }
  return result;
}

//----- (1001B530) --------------------------------------------------------
char *__cdecl sub_1001B530(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_1004E440();
  *(_DWORD *)(a5 + 596) = sub_1004E4B0();
  sub_1004E4D0((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_10020640(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_1003D500((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (1001B660) --------------------------------------------------------
char sub_1001B660()
{
  char result; // al@1

  result = 0;
  byte_10186B9C = 0;
  byte_10186B9D = 0;
  return result;
}
// 10186B9C: using guessed type char byte_10186B9C;
// 10186B9D: using guessed type char byte_10186B9D;

//----- (1001B670) --------------------------------------------------------
char __cdecl sub_1001B670(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_1001B530(-5, a1, a2, a4, a5);
  else
    sub_1001B530(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_100207A0((const char *)(a5 + 485), " DBGA", 100);
  sub_1004E4D0((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_10186B9C )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_10186B9D )
LABEL_15:
      result = sub_1004E510(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 1004ECE0: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 10186B9C: using guessed type char byte_10186B9C;
// 10186B9D: using guessed type char byte_10186B9D;

//----- (1001B770) --------------------------------------------------------
char __cdecl sub_1001B770(char a1)
{
  char result; // al@1

  result = a1 + byte_10186B9C;
  byte_10186B9C += a1;
  return result;
}
// 10186B9C: using guessed type char byte_10186B9C;

//----- (1001B780) --------------------------------------------------------
char __cdecl sub_1001B780(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_1001B670(a1, a2, a3, a4, (int)&v5);
}

//----- (1001B7F0) --------------------------------------------------------
char __cdecl sub_1001B7F0(char a1, _DWORD *a2)
{
  int v2; // eax@1
  char result; // al@2

  v2 = sub_1001DC80(&a1, 2u, (int)&unk_100E5DE2, 8, 415, -1);
  if ( v2 == -1 )
  {
    result = 0;
  }
  else
  {
    *a2 = *(&dword_100E5DE4 + 2 * v2);
    result = 1;
  }
  return result;
}

//----- (1001B830) --------------------------------------------------------
__int16 __usercall sub_1001B830@<ax>(int a1@<edi>, char a2)
{
  __int16 v2; // ax@1
  __int16 result; // ax@3

  v2 = sub_1001DC80(&a2, 2u, (int)&unk_100E6C58, 16, 18, -1);
  if ( v2 == -1 )
  {
LABEL_11:
    result = -1;
  }
  else
  {
    switch ( a1 )
    {
      case 1:
        result = word_100E6C5A[8 * v2];
        break;
      case 2:
        result = word_100E6C5E[8 * v2];
        break;
      case 4:
        result = word_100E6C5C[8 * v2];
        break;
      case 64:
        result = word_100E6C60[8 * v2];
        break;
      case 128:
        result = word_100E6C62[8 * v2];
        break;
      case 16:
        result = word_100E6C64[8 * v2];
        break;
      case 32:
        result = word_100E6C66[8 * v2];
        break;
      default:
        sub_10020770(byte_10186BA0, 0x64u, "Unrecognized LRU (%u) passed into alert processing.", a1);
        sub_1001B780("..\\lib\\adl\\sys_updt_alrt_data.c", 1037, 0, byte_10186BA0);
        goto LABEL_11;
    }
  }
  return result;
}
// 100E6C5A: using guessed type __int16 word_100E6C5A[];
// 100E6C5C: using guessed type __int16 word_100E6C5C[];
// 100E6C5E: using guessed type __int16 word_100E6C5E[];
// 100E6C60: using guessed type __int16 word_100E6C60[];
// 100E6C62: using guessed type __int16 word_100E6C62[];
// 100E6C64: using guessed type __int16 word_100E6C64[];
// 100E6C66: using guessed type __int16 word_100E6C66[];

//----- (1001B9D0) --------------------------------------------------------
__int16 __usercall sub_1001B9D0@<ax>(int a1@<ebx>, unsigned __int8 a2)
{
  void *v2; // ecx@1
  int v3; // eax@2
  int v4; // edi@2
  __int16 v5; // si@7
  __int16 v6; // ax@11
  __int16 v7; // si@11
  char v9; // [sp+8h] [bp-38h]@1

  memset(&v9, 0, 0x33u);
  if ( a2 )
  {
    v6 = sub_1001DC80(&a2, 1u, (int)&unk_100E6D78, 56, 9, -1);
    v7 = v6;
    if ( v6 == -1 )
    {
      v5 = -1;
      sub_10020770(byte_10186BA0, 0x64u, "Unrecognized key source (%u) for key stuck alert.", a2);
      sub_1001B780("..\\lib\\adl\\sys_updt_alrt_data.c", 1152, 0, byte_10186BA0);
    }
    else
    {
      if ( a1 )
        sub_10020640((int)&v9, &byte_100E6D7C[56 * v6], 51);
      v5 = word_100E6D7A[28 * v7];
    }
  }
  else
  {
    v3 = sub_1001B4A0(v2);
    v4 = v3;
    if ( a1 )
      sub_10019E30(v3, (int)&v9, 51);
    switch ( v4 )
    {
      case 1:
        v5 = 387;
        break;
      case 2:
        v5 = 389;
        break;
      case 4:
        v5 = 388;
        break;
      default:
        v5 = -1;
        sub_10020770(byte_10186BA0, 0x64u, "Unrecognized key source (%u) for key stuck alert.", v4);
        sub_1001B780("..\\lib\\adl\\sys_updt_alrt_data.c", 1116, 0, byte_10186BA0);
        break;
    }
  }
  if ( a1 )
    sub_10020640(a1, &v9, 51);
  return v5;
}
// 100E6D7A: using guessed type __int16 word_100E6D7A[];

//----- (1001BB30) --------------------------------------------------------
signed __int16 __usercall sub_1001BB30@<ax>(void *a1@<ecx>, signed __int16 a2@<bx>, const char *a3@<esi>)
{
  signed __int16 v3; // di@1
  void *v4; // ecx@4
  int v5; // eax@19
  char v7; // [sp+4h] [bp-38h]@2

  v3 = a2;
  if ( a3 )
    memset(&v7, 0, 0x33u);
  if ( a2 == 300 )
  {
    switch ( sub_1001B4A0(a1) )
    {
      case 1:
        v3 = 380;
        if ( !a3 )
          return v3;
        sub_100207A0(&v7, "PFD1", 51);
        break;
      case 4:
        v3 = 381;
        if ( !a3 )
          return v3;
        sub_100207A0(&v7, "MFD1", 51);
        break;
      case 2:
        v3 = 382;
        if ( !a3 )
          return v3;
        sub_100207A0(&v7, "PFD2", 51);
        break;
      case 64:
        v3 = 383;
        if ( !a3 )
          return v3;
        sub_100207A0(&v7, "GTC1", 51);
        break;
      case 128:
        v3 = 384;
        if ( !a3 )
          return v3;
        sub_100207A0(&v7, "GTC2", 51);
        break;
      case 16:
        v3 = 385;
        if ( !a3 )
          return v3;
        sub_100207A0(&v7, "GTC3", 51);
        break;
      case 32:
        v3 = 386;
        if ( !a3 )
          return v3;
        sub_100207A0(&v7, "GTC4", 51);
        break;
      default:
        v3 = -1;
        v5 = sub_1001B4A0(v4);
        sub_10020770(byte_10186BA0, 0x64u, "Unrecognized LRU (%u) passed into DB error alert processing.", v5);
        sub_1001B780("..\\lib\\adl\\sys_updt_alrt_data.c", 1286, 0, byte_10186BA0);
        break;
    }
  }
  if ( a3 )
    sub_100207A0(a3, &v7, 51);
  return v3;
}

//----- (1001BD80) --------------------------------------------------------
char __cdecl sub_1001BD80(signed __int16 a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  char result; // al@2
  char v4; // [sp+Ah] [bp-6h]@1
  char v5; // [sp+Bh] [bp-5h]@1
  int v6; // [sp+Ch] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = (unsigned __int16)sub_1001BB30(v1, a1, 0);
  v2 = sub_1001DC80(&v6, 2u, (int)&unk_100E5DE2, 8, 415, -1);
  if ( v2 < 0 )
  {
    sub_1001B780("..\\lib\\adl\\sys_updt_alrt_data.c", 152, 0, 0);
    result = 0;
  }
  else
  {
    sub_1004EC10(*(&dword_100E5DE4 + 2 * v2), &v4, 1, &v5);
    result = v4;
  }
  return result;
}

//----- (1001BE10) --------------------------------------------------------
int __cdecl sub_1001BE10(signed __int16 a1)
{
  void *v1; // ecx@1
  signed __int16 v2; // ax@1
  int v3; // esi@2
  int result; // eax@6
  char v5; // [sp+Ah] [bp-42h]@1
  char v6; // [sp+Bh] [bp-41h]@1
  int v7; // [sp+Ch] [bp-40h]@1
  int v8; // [sp+10h] [bp-3Ch]@1
  char v9; // [sp+14h] [bp-38h]@1

  memset(&v9, 0, 0x33u);
  v5 = 0;
  v6 = 0;
  v2 = sub_1001BB30(v1, a1, 0);
  v8 = (unsigned __int16)v2;
  if ( sub_1001B7F0(v2, &v7) )
  {
    v3 = v7;
    if ( !sub_1004EC10(v7, &v5, 1, &v6) && v5 )
    {
      v5 = 0;
      sub_1004E8F0(v3, (int)&v5, 1);
    }
  }
  else
  {
    sub_10020770(
      byte_10186BA0,
      0x64u,
      "An attempt to clear a system trigger was performed with an invalid trigger id (%u)",
      (unsigned __int16)a1);
    sub_1001B780("..\\lib\\adl\\sys_updt_alrt_data.c", 522, 0, byte_10186BA0);
  }
  result = (unsigned __int16)sub_1001DC80(&v8, 2u, (int)&unk_100E6AE0, 12, 32, -1);
  if ( (_WORD)result != -1 )
    result = sub_1004E8F0(dword_100E6ADC[3 * (signed __int16)result], (int)&v9, 51);
  return result;
}
// 100E6ADC: using guessed type int dword_100E6ADC[];

//----- (1001BF20) --------------------------------------------------------
int __cdecl sub_1001BF20(unsigned __int8 a1)
{
  __int16 v1; // ax@1

  v1 = sub_1001B9D0(0, a1);
  return sub_1001BE10(v1);
}

//----- (1001BF40) --------------------------------------------------------
char __cdecl sub_1001BF40(unsigned __int16 a1)
{
  int v1; // esi@2
  int v2; // eax@2
  char v4; // [sp+6h] [bp-6h]@1
  char v5; // [sp+7h] [bp-5h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v4 = 0;
  v5 = 1;
  if ( sub_1001B7F0(a1, &v6) )
  {
    v1 = v6;
    v2 = sub_1004EC10(v6, &v4, 1, &v5);
    if ( !v2 && !v4 )
    {
      v4 = 1;
      LOBYTE(v2) = sub_1004E8F0(v1, (int)&v4, 1);
    }
  }
  else
  {
    sub_10020770(
      byte_10186BA0,
      0x64u,
      "An attempt to set a system trigger was performed with an invalid trigger id (%u)",
      a1);
    LOBYTE(v2) = sub_1001B780("..\\lib\\adl\\sys_updt_alrt_data.c", 666, 0, byte_10186BA0);
  }
  return v2;
}

//----- (1001BFE0) --------------------------------------------------------
char __cdecl sub_1001BFE0(signed __int16 a1, _BYTE *a2)
{
  void *v2; // ecx@1
  __int16 v3; // si@1
  int v5; // [sp+Ch] [bp-3Ch]@1
  char v6; // [sp+10h] [bp-38h]@1

  memset(&v6, 0, 0x33u);
  v5 = (unsigned __int16)sub_1001BB30(v2, a1, &v6);
  v3 = sub_1001DC80(&v5, 2u, (int)&unk_100E6AE0, 12, 32, -1);
  if ( v3 != -1 && a2 )
  {
    sub_100207A0(&v6, a2, 51);
    sub_1004E8F0(dword_100E6ADC[3 * v3], (int)&v6, 51);
  }
  else
  {
    sub_1001B780("..\\lib\\adl\\sys_updt_alrt_data.c", 730, 0, 0);
  }
  return sub_1001BF40(v5);
}
// 100E6ADC: using guessed type int dword_100E6ADC[];

//----- (1001C0A0) --------------------------------------------------------
char __cdecl sub_1001C0A0(char a1, _BYTE *a2, unsigned __int8 a3)
{
  __int16 v3; // di@1
  char v5; // [sp+Ch] [bp-38h]@1

  memset(&v5, 0, 0x33u);
  v3 = sub_1001B9D0((int)&v5, a3);
  if ( a1 )
  {
    sub_100207A0(&v5, " multiple keys stuck.", 51);
  }
  else if ( a2 )
  {
    sub_100207A0(&v5, " ", 51);
    sub_100207A0(&v5, a2, 51);
    sub_100207A0(&v5, " key is stuck.", 51);
  }
  else
  {
    sub_1001B780("..\\lib\\adl\\sys_updt_alrt_data.c", 814, 0, 0);
  }
  return sub_1001BFE0(v3, &v5);
}

//----- (1001C160) --------------------------------------------------------
char __cdecl sub_1001C160(char a1, int a2)
{
  __int16 v2; // ax@1

  v2 = sub_1001B830(a2, a1);
  return sub_1001BF40(v2);
}

//----- (1001C180) --------------------------------------------------------
char __cdecl sub_1001C180(char a1)
{
  unsigned __int16 v1; // si@1
  __int16 v2; // ax@1

  v1 = -1;
  v2 = sub_1001DC80(&a1, 1u, (int)&unk_100E6F70, 4, 67, -1);
  if ( v2 != -1 )
    v1 = word_100E6F72[2 * v2];
  return sub_1001BF40(v1);
}
// 100E6F72: using guessed type __int16 word_100E6F72[];

//----- (1001C1C0) --------------------------------------------------------
char __cdecl sub_1001C1C0(int a1)
{
  char result; // al@1

  result = 0;
  if ( !a1 || *(_WORD *)a1 == -1 || !*(_BYTE *)(a1 + 2) || *(_BYTE *)(a1 + 127) & 0x40 || *(_WORD *)(a1 + 156) == -1 )
    result = 1;
  return result;
}

//----- (1001C1F0) --------------------------------------------------------
char sub_1001C1F0()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_1004E8C0(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 1001C1F0: using guessed type int var_1C[7];

//----- (1001C270) --------------------------------------------------------
char __cdecl sub_1001C270(int a1)
{
  unsigned int v1; // ebp@1
  char v2; // bl@1
  int v3; // esi@1
  signed int v4; // edi@1
  unsigned int v6; // [sp+10h] [bp-128h]@1
  char v7; // [sp+18h] [bp-120h]@2
  int v8; // [sp+38h] [bp-100h]@3
  char v9; // [sp+42h] [bp-F6h]@2

  v1 = 0;
  v2 = 1;
  v6 = 0;
  v3 = 18000;
  v4 = 16;
  do
  {
    v2 &= sub_1004E7C0(v3, (int)&v7, 284) == 0;
    if ( v9 )
      v6 += v8;
    else
      v1 += v8;
    ++v3;
    --v4;
  }
  while ( v4 );
  if ( v1 > 0x500000 || v6 > 0x80000000 )
  {
    v2 = 0;
    sub_10020640(a1, "Total log folder size exceeds limit", 36);
  }
  return v2;
}

//----- (1001C320) --------------------------------------------------------
bool sub_1001C320()
{
  unsigned int v0; // esi@1
  bool result; // al@4
  char v2; // [sp+8h] [bp-120h]@1
  __int16 v3; // [sp+24h] [bp-104h]@3

  memset(&v2, 0, 0x11Cu);
  v0 = 0;
  do
  {
    result = !sub_1004E7C0((int)(&byte_101DF220[37000 - (_DWORD)byte_101DF220] + v0), (int)&v2, 284) && v3 == -1;
    byte_101DF220[v0++] = result;
  }
  while ( v0 < 0x5C );
  byte_101E6948 = 1;
  return result;
}
// 101E6948: using guessed type char byte_101E6948;

//----- (1001C3C0) --------------------------------------------------------
char __cdecl sub_1001C3C0(unsigned int a1)
{
  char result; // al@4

  if ( !byte_101E6948 )
  {
    sub_1001B780(
      "..\\lib\\adl\\mon_cnfg_intf.c",
      1236,
      0,
      "Audio Message Is Continuous Array has NOT been initialized.  Initializing now.");
    sub_1001C320();
  }
  if ( a1 >= 0x5C )
    result = 0;
  else
    result = byte_101DF220[a1];
  return result;
}
// 101E6948: using guessed type char byte_101E6948;

//----- (1001C400) --------------------------------------------------------
double __fastcall sub_1001C400(int a1, int a2)
{
  int v2; // edx@1
  unsigned int v3; // eax@2
  float v6; // [sp+0h] [bp-4h]@1

  v6 = 0.0;
  if ( !sub_1001C1C0(a2) )
  {
    v3 = *(_DWORD *)(v2 + 128);
    if ( !v3 )
      return (float)(0.0 + 1.0);
    v6 = 1000.0 / (double)v3 + 0.0;
  }
  return v6;
}

//----- (1001C460) --------------------------------------------------------
void *__cdecl sub_1001C460(__int16 a1)
{
  unsigned int v1; // esi@2
  void *result; // eax@2
  int v3; // eax@3
  char *v4; // ebp@3
  bool v5; // zf@3
  __int16 v6; // bx@5
  int v7; // esi@10
  __int16 v8; // cx@10
  _WORD v9; // ax@10
  __int16 v10; // bp@13
  int v11; // esi@18
  char *v12; // ST30_4@18
  unsigned int v13; // esi@18
  unsigned int v14; // edi@18
  char v15; // al@18
  int v16; // ecx@18
  __int16 v17; // dx@18
  char v18; // al@18
  char v19; // al@18
  int v20; // edx@18
  int v21; // edx@18
  int v22; // [sp+8h] [bp-8h]@3
  int v23; // [sp+Ch] [bp-4h]@3

  if ( (unsigned __int16)a1 < 0x19Fu )
  {
    v22 = (unsigned __int16)(a1 + 2000);
    v3 = 8 * (unsigned __int16)sub_1001DC80(&v22, 2u, (int)&unk_100E5DE0, 8, 415, 0xFFFF);
    v4 = (char *)&unk_100E5DE2 + v3;
    v5 = a1 == *(_WORD *)((char *)&unk_100E5DE2 + v3);
    v23 = v3;
    if ( !v5 )
      sub_1001B780("..\\lib\\adl\\mon_cnfg_intf.c", 1441, 0, 0);
    v6 = 0;
    do
    {
      if ( !byte_10186C08[64 * (unsigned __int16)v6] )
        break;
      ++v6;
    }
    while ( (unsigned __int16)v6 < 0x258u );
    if ( v6 == 600 )
      v6 = a1;
    v7 = (unsigned __int16)v6 << 6;
    memset(&byte_10186C08[v7], 0, 0x40u);
    v8 = *(_WORD *)v4;
    byte_10186C08[v7] = 13;
    byte_10186C09[v7] = 0;
    *(__int16 *)((char *)&word_10186C0A + v7) = v8;
    *(__int16 *)((char *)&word_10186C0C + v7) = 0;
    *(int *)((char *)&dword_10186C10 + v7) = 512;
    byte_10186C14[v7] = 1;
    byte_10186C18[v7] = 4;
    byte_10186C1C[v7] = 1;
    byte_10186C20[v7] = 5;
    *(int *)((char *)&dword_10186C24 + v7) = 0;
    *(int *)((char *)&dword_10186C28 + v7) = 0;
    *(__int16 *)((char *)&word_10186C2C + v7) = 0;
    byte_10186C43[v7] = 0;
    *(int *)((char *)&dword_10186C44 + v7) = 0;
    v9 = sub_1001DC80(v4, 2u, (int)&unk_100E7080, 8, 415, 0xFFFF);
    if ( v9 == -1 )
      sub_1001B780("..\\lib\\adl\\mon_cnfg_intf.c", 1526, 0, 0);
    else
      sub_10020640((int)&unk_10186C2E + v7, *(_BYTE **)&off_100E7084[8 * v9], 21);
    v10 = 0;
    do
    {
      if ( LOWORD(dword_101A0A18[2 * (unsigned __int16)v10]) == -1 )
        break;
      ++v10;
    }
    while ( (unsigned __int16)v10 < 0x7D0u );
    if ( v10 == 2000 )
      v10 = a1;
    v11 = 2 * (unsigned __int16)v10;
    dword_101A0A18[v11] = 0;
    dword_101A0A1C[v11] = 0;
    v12 = (char *)&dword_100E5DE4 + v23;
    LOWORD(dword_101A0A18[v11]) = v6;
    HIWORD(dword_101A0A18[v11]) = -1;
    LOWORD(dword_101A0A1C[v11]) = -1;
    BYTE2(dword_101A0A1C[v11]) = sub_1001DC80(v12, 4u, (int)&unk_100E6AD8, 12, 32, 0xFFFF) != 0xFFFF ? 0x10 : 0;
    v13 = 160 * (unsigned __int16)a1;
    memset((char *)&unk_101B8120 + 160 * (unsigned __int16)a1, 0, 0x9Cu);
    v14 = 156 * (unsigned __int16)a1;
    *((_WORD *)&unk_101B8120 + 80 * (unsigned __int16)a1) = *(_WORD *)&aAhrs1Tas[v14];
    sub_10020640((int)&unk_101B8122 + v13, &aAhrs1Tas[v14 + 2], 31);
    sub_10020640((int)&unk_101B8141 + v13, &aAhrs1NotReceiv[v14], 51);
    sub_10020640((int)&unk_101B8174 + v13, &byte_100D614C[v14], 21);
    sub_10020640((int)&unk_101B8189 + v13, &byte_100D6161[v14], 21);
    v15 = byte_100D6177[v14];
    v16 = dword_100D6178[v14 / 4];
    byte_101B819E[v13] = byte_100D6176[v14];
    v17 = word_100D617C[v14 / 2];
    byte_101B819F[v13] = v15;
    v18 = byte_100D617E[v14];
    dword_101B81A0[v13 / 4] = v16;
    LOBYTE(v16) = byte_100D617F[v14];
    word_101B81A4[v13 / 2] = v17;
    LOBYTE(v17) = byte_100D6180[v14];
    byte_101B81A6[v13] = v18;
    v19 = byte_100D6181[v14];
    byte_101B81A7[v13] = v16;
    LOWORD(v16) = word_100D6182[v14 / 2];
    byte_101B81A8[v13] = v17;
    v20 = dword_100D6184[v14 / 4];
    byte_101B81A9[v13] = v19;
    word_101B81AA[v13 / 2] = v16;
    dword_101B81AC[v13 / 4] = v20;
    LOWORD(v16) = word_100D618C[v14 / 2];
    result = (void *)dword_100D6188[v14 / 4];
    v21 = dword_100D6190[v14 / 4];
    word_101B81BC[v13 / 2] = v10;
    dword_101B81B0[v13 / 4] = (int)result;
    word_101B81B4[v13 / 2] = v16;
    dword_101B81B8[v13 / 4] = v21;
  }
  else
  {
    v1 = 160 * (unsigned __int16)a1;
    result = memset((char *)&unk_101B8120 + v1, 0, 0xA0u);
    *(_WORD *)((char *)&unk_101B8120 + v1) = -1;
    word_101B81BC[v1 / 2] = -1;
  }
  return result;
}
// 1001C460: too many cbuild loops
// 100D6178: using guessed type int dword_100D6178[];
// 100D617C: using guessed type __int16 word_100D617C[];
// 100D6182: using guessed type __int16 word_100D6182[];
// 100D6184: using guessed type int dword_100D6184[];
// 100D6188: using guessed type int dword_100D6188[];
// 100D618C: using guessed type __int16 word_100D618C[];
// 100D6190: using guessed type int dword_100D6190[];
// 10186C0A: using guessed type __int16 word_10186C0A;
// 10186C0C: using guessed type __int16 word_10186C0C;
// 10186C10: using guessed type int dword_10186C10;
// 10186C24: using guessed type int dword_10186C24;
// 10186C28: using guessed type int dword_10186C28;
// 10186C2C: using guessed type __int16 word_10186C2C;
// 10186C44: using guessed type int dword_10186C44;
// 101A0A18: using guessed type int dword_101A0A18[];
// 101A0A1C: using guessed type int dword_101A0A1C[];
// 101B81A0: using guessed type int dword_101B81A0[];
// 101B81A4: using guessed type __int16 word_101B81A4[];
// 101B81AA: using guessed type __int16 word_101B81AA[];
// 101B81AC: using guessed type int dword_101B81AC[];
// 101B81B0: using guessed type int dword_101B81B0[];
// 101B81B4: using guessed type __int16 word_101B81B4[];
// 101B81B8: using guessed type int dword_101B81B8[];
// 101B81BC: using guessed type __int16 word_101B81BC[];

//----- (1001C7D0) --------------------------------------------------------
char __usercall sub_1001C7D0@<al>(unsigned __int16 a1@<ax>, int a2, char *a3)
{
  char result; // al@3
  int v4; // [sp+0h] [bp-4h]@1

  v4 = (unsigned __int16)(a1 + 2000);
  if ( sub_1001C1C0(a2 + 160 * a1) && sub_1001DC80(&v4, 2u, (int)&unk_100E7D78, 2, 60, 60) != 60 )
  {
    sprintf(a3, "Error:  TSO required system alert with alert id %i cannot be disabled.", (unsigned __int16)v4);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1001C840) --------------------------------------------------------
char __usercall sub_1001C840@<al>(int a1@<eax>, unsigned __int16 a2@<di>, char *a3@<esi>)
{
  char result; // al@2
  signed __int16 v4; // cx@8
  unsigned __int16 v5; // ax@14

  if ( *(_BYTE *)a1 < 0x12u )
  {
    if ( *(_BYTE *)(a1 + 1) < 5u )
    {
      if ( *(_BYTE *)(a1 + 16) >= 0xBu || *(_BYTE *)(a1 + 24) >= 0xBu )
      {
        sprintf(a3, "Invalid operation for trigger %i", a2);
        result = 0;
      }
      else
      {
        switch ( *(_BYTE *)a1 )
        {
          case 1:
            v4 = 793;
            goto LABEL_21;
          case 2:
            v4 = 472;
            goto LABEL_21;
          case 0xB:
            v4 = 741;
            goto LABEL_21;
          case 3:
            v4 = 836;
            goto LABEL_21;
          case 4:
            v4 = 3020;
            goto LABEL_21;
          case 5:
            v4 = 904;
            goto LABEL_21;
          case 0xA:
            v5 = *(_BYTE *)(a1 + 2);
            v4 = 31;
            goto LABEL_22;
          case 6:
          case 7:
          case 9:
            v4 = 2415;
            goto LABEL_21;
          case 8:
            v4 = 132;
            goto LABEL_21;
          case 0xD:
            v4 = 415;
            goto LABEL_21;
          case 0xC:
            v4 = -23470;
            goto LABEL_21;
          case 0xE:
          case 0xF:
            v4 = 4067;
            goto LABEL_21;
          case 0x11:
            v4 = 60;
LABEL_21:
            v5 = *(_WORD *)(a1 + 2);
LABEL_22:
            if ( v5 < (unsigned __int16)v4 )
              goto LABEL_24;
            sprintf(a3, "Invalid id for trigger %i", a2);
            result = 0;
            break;
          default:
LABEL_24:
            result = 1;
            break;
        }
      }
    }
    else
    {
      sprintf(a3, "Invalid data type for trigger %i", a2);
      result = 0;
    }
  }
  else
  {
    sprintf(a3, "Invalid source for trigger %i", a2);
    result = 0;
  }
  return result;
}

//----- (1001C980) --------------------------------------------------------
int sub_1001C980()
{
  int v0; // ebx@1
  int v1; // ebp@1
  void *v2; // eax@2
  signed int v3; // edx@2
  char *v4; // edi@3
  char *v5; // esi@3
  int v6; // ebx@5
  void *v7; // edx@6
  signed int v8; // ebp@6
  char *v9; // edi@7
  char *v10; // esi@7
  bool v11; // zf@8
  int v12; // esi@9
  int v13; // edi@9
  signed int v14; // ebx@9
  void *v15; // eax@10
  signed int v16; // edx@10
  int v17; // ecx@11
  int result; // eax@12
  signed int v19; // [sp+10h] [bp-8h]@1
  int v20; // [sp+10h] [bp-8h]@5
  signed int v21; // [sp+14h] [bp-4h]@5

  v0 = 0;
  v1 = 25000;
  v19 = 6;
  do
  {
    v2 = &unk_101E5048;
    v3 = 100;
    do
    {
      v4 = (char *)v2;
      v5 = &byte_10186C08[64 * (unsigned __int16)v0++];
      v2 = (char *)v2 + 64;
      --v3;
      qmemcpy(v4, v5, 0x40u);
    }
    while ( v3 );
    sub_1004E8F0(v1++, (int)&unk_101E5048, 6400);
    --v19;
  }
  while ( v19 );
  v6 = 0;
  v20 = 23000;
  v21 = 5;
  do
  {
    v7 = &unk_101B4298;
    v8 = 100;
    do
    {
      v9 = (char *)v7;
      v10 = (char *)&unk_101B8120 + 160 * (unsigned __int16)v6++;
      v7 = (char *)v7 + 160;
      --v8;
      qmemcpy(v9, v10, 0xA0u);
    }
    while ( v8 );
    sub_1004E8F0(v20, (int)&unk_101B4298, 16004);
    v11 = v21-- == 1;
    ++v20;
  }
  while ( !v11 );
  v12 = 0;
  v13 = 24000;
  v14 = 2;
  do
  {
    v15 = &unk_101DF280;
    v16 = 1000;
    do
    {
      v17 = dword_101A0A1C[2 * (unsigned __int16)v12];
      *(_DWORD *)v15 = dword_101A0A18[2 * (unsigned __int16)v12];
      *((_DWORD *)v15 + 1) = v17;
      ++v12;
      v15 = (char *)v15 + 8;
      --v16;
    }
    while ( v16 );
    result = sub_1004E8F0(v13++, (int)&unk_101DF280, 8000);
    --v14;
  }
  while ( v14 );
  return result;
}
// 101A0A18: using guessed type int dword_101A0A18[];
// 101A0A1C: using guessed type int dword_101A0A1C[];

//----- (1001CAD0) --------------------------------------------------------
void *sub_1001CAD0()
{
  char *v0; // eax@1
  signed int v1; // ecx@1
  int *v2; // eax@3
  signed int v3; // ecx@3
  __int16 v4; // si@5
  void *result; // eax@6

  memset(&unk_101B8120, 0, 0x13880u);
  memset(dword_101A0A18, 0, 0x3E80u);
  memset(byte_10186C08, 0, 0x9600u);
  v0 = byte_10186C08;
  v1 = 600;
  do
  {
    *v0 = 0;
    v0 += 64;
    --v1;
  }
  while ( v1 );
  v2 = dword_101A0A18;
  v3 = 2000;
  do
  {
    *(_WORD *)v2 = -1;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = 0;
  do
    result = sub_1001C460(v4++);
  while ( (unsigned __int16)v4 < 0x1F4u );
  return result;
}
// 101A0A18: using guessed type int dword_101A0A18[];

//----- (1001CB50) --------------------------------------------------------
char __cdecl sub_1001CB50(int a1, int a2, int a3, int a4, int a5, int a6, char *a7)
{
  unsigned __int16 v7; // cx@1
  signed __int16 v8; // dx@1
  int v9; // ebp@5
  int v10; // edi@6
  _WORD *v11; // eax@6
  unsigned __int16 v12; // ax@6
  char v13; // cl@14
  unsigned __int16 v14; // cx@17
  char result; // al@22
  unsigned __int16 v16; // ax@33
  __int16 v17; // cx@36
  unsigned __int16 v18; // ax@39
  _WORD *v19; // [sp+10h] [bp-4h]@6

  v7 = a4;
  v8 = 0;
  if ( (_WORD)a4 == -1 )
  {
LABEL_47:
    result = 1;
  }
  else
  {
    while ( 2 )
    {
      if ( ++*(_WORD *)a5 > 0x64u )
      {
        sprintf(a7, "Maximum number of nodes exceeded for alert %i", (unsigned __int16)a2);
LABEL_49:
        result = 0;
      }
      else
      {
        v9 = v7;
        if ( byte_1019E308[v7] )
        {
          sprintf(a7, "Reuse of nodes is not allowed: alert %i node %i", (unsigned __int16)a2, v7);
          result = 0;
        }
        else
        {
          v10 = a2;
          v11 = (_WORD *)(a1 + 160 * (unsigned __int16)a2);
          byte_1019E308[v7] = 1;
          v19 = v11;
          v12 = *v11;
          if ( v12 < 0x7D0u || v12 > 0x9C3u )
          {
            if ( v12 >= 0x3E8u && v12 <= 0x7CFu || v12 <= 0x3E7u )
              v8 = 1499;
          }
          else
          {
            v8 = 599;
          }
          if ( v12 != -1
            && (v13 = *(_BYTE *)(a3 + 8 * v7 + 6), v13 != 13)
            && v13 != 14
            && v13 != 12
            && (v14 = *(_WORD *)(a3 + 8 * v9), v14 > (unsigned __int16)v8)
            && v14 != -1 )
          {
            sprintf(a7, "Invalid trigger for alert %i node %i", (unsigned __int16)a2, (unsigned __int16)a4);
            result = 0;
          }
          else
          {
            switch ( *(_BYTE *)(a3 + 8 * v9 + 6) )
            {
              case 0xD:
              case 0xE:
                if ( *(_WORD *)(a3 + 8 * v9) >= 0x96Fu )
                {
                  sprintf(a7, "Invalid alert id for alert %i node %i", (unsigned __int16)a2, (unsigned __int16)a4);
                  result = 0;
                }
                else
                {
                  if ( *(_WORD *)(a3 + 8 * v9 + 2) == -1 )
                    goto LABEL_44;
                  sprintf(a7, "Alert node with children: alert %i node %i", (unsigned __int16)a2, (unsigned __int16)a4);
                  result = 0;
                }
                return result;
              case 0:
              case 0x10:
                if ( *(_BYTE *)(a3 + 8 * v9 + 6) == 16 && v12 != -1 && (v12 < 0x7D0u || v12 > 0x9C3u) )
                {
                  sprintf(a7, "Text nodes are only allowed for system alerts: alert %i", (unsigned __int16)a2);
                  result = 0;
                }
                else if ( *(_WORD *)(a3 + 8 * v9) == -1 )
                {
                  sprintf(a7, "Leaf node without trigger: alert %i node %i", (unsigned __int16)a2, (unsigned __int16)a4);
                  result = 0;
                }
                else
                {
                  if ( *(_WORD *)(a3 + 8 * v9 + 2) == -1 )
                  {
                    if ( sub_1001C840(a6 + (*(_WORD *)(a3 + 8 * v9) << 6), *(_WORD *)(a3 + 8 * v9), a7) )
                      goto LABEL_43;
                    sprintf(a7, "%s, used in alert %i node %i", a7, (unsigned __int16)a2, (unsigned __int16)a4);
                    goto LABEL_31;
                  }
                  sprintf(a7, "Leaf node with children: alert %i node %i", (unsigned __int16)a2, (unsigned __int16)a4);
                  result = 0;
                }
                return result;
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                if ( *(_WORD *)(a3 + 8 * v9) == -1 )
                {
                  v16 = *(_WORD *)(a3 + 8 * v9 + 2);
                  if ( v16 == -1 )
                  {
                    sprintf(
                      a7,
                      "No children for gate node: alert %i node %i",
                      (unsigned __int16)a2,
                      (unsigned __int16)a4);
                    result = 0;
                  }
                  else
                  {
                    if ( *(_WORD *)(a3 + 8 * v16 + 4) != -1 )
                      goto LABEL_44;
                    sprintf(
                      a7,
                      "Not enough children for gate node: alert %i node %i",
                      (unsigned __int16)a2,
                      (unsigned __int16)a4);
                    result = 0;
                  }
                }
                else
                {
                  sprintf(a7, "Gate node with trigger: alert %i node %i", (unsigned __int16)a2, (unsigned __int16)a4);
                  result = 0;
                }
                return result;
              case 7:
              case 9:
              case 0xA:
                v17 = *(_WORD *)(a3 + 8 * v9);
                if ( v17 == -1 )
                  goto LABEL_39;
                if ( *(_WORD *)(a3 + 8 * v9 + 2) != -1 )
                  goto LABEL_59;
                if ( v17 != -1 )
                  goto LABEL_42;
LABEL_39:
                v18 = *(_WORD *)(a3 + 8 * v9 + 2);
                if ( v18 == -1 || *(_WORD *)(a3 + 8 * v18 + 4) != -1 )
                {
LABEL_59:
                  sprintf(a7, "Incorrect input for node: alert %i node %i", (unsigned __int16)a2, (unsigned __int16)a4);
                  result = 0;
                }
                else
                {
                  if ( v17 == -1 )
                    goto LABEL_44;
LABEL_42:
                  if ( sub_1001C840(a6 + (*(_WORD *)(a3 + 8 * v9) << 6), *(_WORD *)(a3 + 8 * v9), a7) )
                  {
LABEL_43:
                    v10 = a2;
LABEL_44:
                    if ( (_WORD)a4 != v19[78]
                      && !(unsigned __int8)sub_1001CB50(a1, v10, a3, *(_WORD *)(a3 + 8 * v9 + 4), a5, a6, a7) )
                    {
                      goto LABEL_49;
                    }
                    v8 = 0;
                    a4 = *(_WORD *)(a3 + 8 * v9 + 2);
                    if ( *(_WORD *)(a3 + 8 * v9 + 2) != -1 )
                    {
                      v7 = *(_WORD *)(a3 + 8 * v9 + 2);
                      continue;
                    }
                    goto LABEL_47;
                  }
                  sprintf(a7, "%s, used in alert %i node %i", a7, (unsigned __int16)a2, (unsigned __int16)a4);
LABEL_31:
                  result = 0;
                }
                break;
              case 8:
              case 0xB:
              case 0xC:
              case 0xF:
              case 0x11:
                sprintf(
                  a7,
                  "Invalid use of ACK, cascade, inhibit, or log: alert %i node %i",
                  (unsigned __int16)a2,
                  (unsigned __int16)a4);
                return 0;
              default:
                sprintf(
                  a7,
                  "Invalid operation %i for alert %i node %i",
                  *(_BYTE *)(a3 + 8 * (unsigned __int16)a4 + 6),
                  (unsigned __int16)a2,
                  (unsigned __int16)a4);
                return 0;
            }
          }
        }
      }
      break;
    }
  }
  return result;
}

//----- (1001CF90) --------------------------------------------------------
int sub_1001CF90()
{
  unsigned int v1; // [sp+0h] [bp-4h]@1

  sub_1001CAD0();
  sub_1001C980();
  v1 = sub_1004E2C0((unsigned int *)"\aAHRS1 TAS", 64740, 0xFFFFFFFF);
  return sub_1004E8F0(6948, (int)&v1, 4);
}

//----- (1001CFD0) --------------------------------------------------------
char __usercall sub_1001CFD0@<al>(char *a1@<eax>, int a2@<ebx>, unsigned __int8 a3, int a4, int a5, int a6)
{
  char *v6; // esi@1
  int v7; // eax@1
  bool v8; // zf@1
  int v9; // edi@1
  char result; // al@3
  unsigned __int8 v11; // al@6
  unsigned __int8 v12; // al@8
  unsigned __int8 v13; // al@10
  unsigned __int16 v14; // ax@24
  unsigned int v15; // eax@27
  unsigned int v16; // ecx@29
  unsigned int v17; // eax@34
  unsigned __int8 v18; // al@40
  unsigned __int8 v19; // al@42
  unsigned __int16 v20; // ax@46
  signed __int16 v21; // dx@46
  signed __int16 v22; // cx@46
  int v23; // ebp@52
  __int16 v24; // ax@57
  unsigned __int16 v25; // ax@60
  int v26; // eax@62
  unsigned __int16 v27; // ax@70
  signed __int16 v28; // [sp+10h] [bp-10h]@46
  int v29; // [sp+14h] [bp-Ch]@48
  int v30; // [sp+18h] [bp-8h]@1
  unsigned int v31; // [sp+1Ch] [bp-4h]@24

  v6 = a1;
  v7 = 160 * (unsigned __int16)a5;
  v8 = *(_WORD *)(v7 + a4 + 156) == -1;
  v9 = v7 + a4;
  v30 = v7 + a4;
  if ( v8 )
  {
    if ( a3 != 2 )
      return 1;
  }
  else if ( a3 != 2 )
  {
    goto LABEL_6;
  }
  if ( *(_WORD *)v9 == -2 )
    return 1;
LABEL_6:
  v11 = *(_BYTE *)(v9 + 126);
  if ( v11 >= 5u )
  {
    sprintf(v6, "Invalid level %i for alert %i", v11, (unsigned __int16)a5);
    return 0;
  }
  v12 = *(_BYTE *)(v9 + 136);
  if ( v12 >= 0x5Cu && v12 != -1 || (v13 = *(_BYTE *)(v9 + 137), v13 >= 0x5Cu) && v13 != -1 )
  {
    sprintf(v6, "Invalid audio message for alert %i", (unsigned __int16)a5);
    return 0;
  }
  if ( a3 && *(_BYTE *)(v9 + 127) & 0x20 && sub_1001C3C0(v13) )
  {
    sprintf(
      v6,
      "Invalid Continuous Clear Audio for alert %i ( aud msg = %i )",
      (unsigned __int16)a5 + (unsigned __int16)word_10099858[6 * a3],
      *(_BYTE *)(v9 + 137));
    return 0;
  }
  if ( *(_BYTE *)(v9 + 135) & 4 && (*(_BYTE *)(v9 + 126) != 3 || !(*(_BYTE *)(v9 + 127) & 5)) )
  {
    sprintf(
      v6,
      "Invalid Alert Clear Flags.  Hide-on-View is only valid for Viewable Messages.  Alert: %i",
      (unsigned __int16)a5);
    return 0;
  }
  if ( !sub_1001C1C0(v9) && *(_WORD *)v9 > (unsigned __int16)word_1009985A[6 * a3] )
  {
    sprintf(v6, "Invalid alert id. Id out of bounds. Alert: %i ID: %i", (unsigned __int16)a5, *(_WORD *)v9);
    return 0;
  }
  v14 = *(_WORD *)v9;
  v31 = 12 * a3;
  if ( v14 != (unsigned __int16)a5 + (unsigned __int16)word_10099858[v31 / 2] && v14 != -1 )
  {
    sprintf(v6, "Invalid alert id. Id mismatch. Alert: %i ID: %i", (unsigned __int16)a5, v14);
    return 0;
  }
  v15 = *(_DWORD *)(v9 + 140);
  if ( v15 && v15 < 0xC8 || (v16 = *(_DWORD *)(v9 + 144)) != 0 && v16 < 0xC8 )
  {
    sprintf(v6, "Invalid debounce time. Must be greater than or equal to %i. Alert: %i", 200, (unsigned __int16)a5);
    return 0;
  }
  if ( v15 % 0xC8 || *(_DWORD *)(v9 + 144) % 0xC8u )
  {
    sprintf(v6, "Invalid debounce time. Not multiple of %i. Alert: %i", 200, (unsigned __int16)a5);
    return 0;
  }
  v17 = *(_DWORD *)(v9 + 128);
  if ( v17 && v17 < 0xC8 )
  {
    sprintf(v6, "Invalid update period time. Must be greater than or equal to %i. Alert: %i", 200, (unsigned __int16)a5);
    return 0;
  }
  if ( v17 % 0xC8 )
  {
    sprintf(v6, "Invalid update period time. Not multiple of %i. Alert: %i", 200, (unsigned __int16)a5);
    return 0;
  }
  if ( !a3 )
  {
    v18 = *(_BYTE *)(v9 + 127);
    if ( v18 & 0x37 )
    {
      sub_10020770(v6, 0x64u, "Invalid CMC alert Notification. Alert: %i, Notification: %i", (unsigned __int16)a5, v18);
      return 0;
    }
    v19 = *(_BYTE *)(v9 + 134);
    if ( v19 )
    {
      sub_10020770(
        v6,
        0x64u,
        "Acknowledgements restricted for CMC alerts. Alert: %i, Acknowledgement: %i",
        (unsigned __int16)a5,
        v19);
      return 0;
    }
    goto LABEL_46;
  }
  if ( a3 == 2 && !sub_1001C7D0(a5, a4, v6) )
    return 0;
LABEL_46:
  v20 = *(_WORD *)(v9 + 156);
  v21 = -1;
  v22 = -1;
  v28 = -1;
  if ( v20 != -1 )
  {
    v22 = *(_WORD *)(a2 + 8 * v20 + 4);
    v28 = *(_WORD *)(a2 + 8 * v20 + 4);
  }
  v29 = 0;
  if ( v22 == -1 )
    return sub_1001CB50(a4, a5, a2, *(_WORD *)(v9 + 156), (int)&v29, a6, v6);
  while ( 2 )
  {
    if ( (unsigned __int16)++v29 > 0x64u )
    {
      sprintf(v6, "Maximum number of nodes exceeded for alert %i", (unsigned __int16)a5);
      return 0;
    }
    v23 = (unsigned __int16)v22;
    if ( byte_1019E308[(unsigned __int16)v22] )
    {
      sprintf(v6, "Reuse of nodes is not allowed: alert %i node %i", (unsigned __int16)a5, (unsigned __int16)v22);
      return 0;
    }
    byte_1019E308[(unsigned __int16)v22] = 1;
    switch ( *(_BYTE *)(a2 + 8 * (unsigned __int16)v22 + 6) )
    {
      case 0xC:
        if ( *(_WORD *)(a2 + 8 * (unsigned __int16)v22 + 2) == v21 )
        {
          if ( *(_WORD *)(a2 + 8 * (unsigned __int16)v22) < 0x96Fu )
            goto LABEL_73;
          sprintf(v6, "Invalid alert id: alert %i node %i", (unsigned __int16)a5, (unsigned __int16)v22);
          result = 0;
        }
        else
        {
          sprintf(v6, "Cascade node with children: alert %i node %i", (unsigned __int16)a5, (unsigned __int16)v22);
          result = 0;
        }
        return result;
      case 8:
      case 0xB:
      case 0xF:
        v24 = *(_WORD *)(a2 + 8 * (unsigned __int16)v22);
        if ( v24 == v21 )
          goto LABEL_60;
        if ( *(_WORD *)(a2 + 8 * (unsigned __int16)v22 + 2) != v21 )
          goto LABEL_78;
        if ( v24 == v21 )
        {
LABEL_60:
          v25 = *(_WORD *)(a2 + 8 * (unsigned __int16)v22 + 2);
          if ( v25 == v21 || *(_WORD *)(a2 + 8 * v25 + 4) != v21 )
          {
LABEL_78:
            sprintf(
              v6,
              "Incorrect input for ACK/inhibit: alert %i node %i",
              (unsigned __int16)a5,
              (unsigned __int16)v22);
            return 0;
          }
        }
        v26 = *(_WORD *)(a2 + 8 * (unsigned __int16)v22 + 2);
        if ( (_WORD)v26 != v21 )
        {
          if ( !sub_1001CB50(a4, a5, a2, v26, (int)&v29, a6, v6) )
            return 0;
          v21 = -1;
        }
        if ( *(_WORD *)(a2 + 8 * v23) == v21 )
          goto LABEL_73;
        if ( sub_1001C840(a6 + (*(_WORD *)(a2 + 8 * v23) << 6), *(_WORD *)(a2 + 8 * v23), v6) )
        {
          v9 = v30;
          goto LABEL_72;
        }
        sprintf(v6, "%s, used in alert %i node %i", v6, (unsigned __int16)a5, (unsigned __int16)v28);
        result = 0;
        break;
      case 0x11:
        if ( *(_WORD *)(a2 + 8 * (unsigned __int16)v22 + 2) == v21 )
        {
          if ( *(_WORD *)(v9 + 132) )
          {
            v27 = *(_WORD *)(a2 + 8 * (unsigned __int16)v22);
            if ( v27 != v21 && v27 <= (unsigned __int16)word_1009985E[v31 / 2] )
            {
LABEL_72:
              v21 = -1;
LABEL_73:
              v28 = *(_WORD *)(a2 + 8 * v23 + 4);
              if ( *(_WORD *)(a2 + 8 * v23 + 4) != v21 )
              {
                v22 = *(_WORD *)(a2 + 8 * v23 + 4);
                continue;
              }
              return sub_1001CB50(a4, a5, a2, *(_WORD *)(v9 + 156), (int)&v29, a6, v6);
            }
            sprintf(
              v6,
              "Trigger ID %i is out of range for LOG node %i.",
              *(_WORD *)(a2 + 8 * (unsigned __int16)v22),
              (unsigned __int16)v22);
            result = 0;
          }
          else
          {
            sprintf(
              v6,
              "Log folder not selected for alert %i using LOG node %i.",
              (unsigned __int16)a5,
              (unsigned __int16)v22);
            result = 0;
          }
        }
        else
        {
          sprintf(v6, "Log node with children: alert %i node %i", (unsigned __int16)a5, (unsigned __int16)v22);
          result = 0;
        }
        break;
      default:
        sprintf(v6, "Invalid root node sibling: alert %i node %i", (unsigned __int16)a5, (unsigned __int16)v22);
        result = 0;
        break;
    }
    return result;
  }
}
// 10099858: using guessed type __int16 word_10099858[];
// 1009985A: using guessed type __int16 word_1009985A[];
// 1009985E: using guessed type __int16 word_1009985E[];

//----- (1001D5D0) --------------------------------------------------------
bool __cdecl sub_1001D5D0(int a1, int a2, int a3, int a4, char *a5, char a6)
{
  char v6; // bl@1
  unsigned __int8 v7; // cl@1
  int v8; // edx@4
  unsigned int v9; // eax@4
  signed int v10; // ebp@4
  int v11; // edi@6
  int v12; // eax@7
  int v13; // esi@9
  char *v14; // ebp@9
  char v15; // al@9
  int v16; // ecx@9
  double v17; // st7@13
  bool result; // al@16
  int v19; // esi@20
  int v20; // ecx@24
  double v21; // st7@24
  char v22; // [sp+26h] [bp-12h]@1
  char v23; // [sp+27h] [bp-11h]@1
  float v24; // [sp+28h] [bp-10h]@1
  float v25; // [sp+2Ch] [bp-Ch]@4
  signed int v26; // [sp+30h] [bp-8h]@4

  v24 = 0.0;
  v22 = 0;
  v6 = 1;
  v23 = 0;
  memset(byte_1019E308, 0, 0x2710u);
  v7 = a1;
  if ( (_BYTE)a1 && (_BYTE)a1 != 1 && (_BYTE)a1 != 2 )
  {
    sprintf(a5, "Invalid alert class %i.", (unsigned __int8)a1);
    result = 0;
  }
  else
  {
    v8 = (unsigned __int8)a1;
    v9 = 12 * (unsigned __int8)a1;
    v10 = (unsigned __int16)word_1009985C[v9 / 2];
    v25 = flt_10099860[v9 / 4];
    v26 = (unsigned __int16)word_1009985C[v9 / 2];
    if ( (_BYTE)a1 != 1 && (_BYTE)a1 )
    {
      v11 = 0;
      if ( v10 > 0 )
      {
        v12 = 0;
        while ( 1 )
        {
          v13 = 160 * v12;
          v14 = (char *)(160 * v12 + a3);
          v15 = sub_1001CFD0(a5, a4, v7, a3, v11, a2);
          LOBYTE(v16) = v15 == 0;
          v22 |= v15 == 0;
          if ( a6 && (!v15 || *(_WORD *)v14 == -2) )
          {
            sub_1001C460(v11);
            v23 = 1;
            v14 = (char *)&unk_101B8120 + v13;
          }
          v17 = sub_1001C400(v16, (int)v14);
          v12 = (unsigned __int16)++v11;
          v24 = v17 + v24;
          if ( (unsigned __int16)v11 >= v26 )
            break;
          v7 = a1;
        }
      }
      if ( v25 < (double)v24
        && (sprintf(a5, "Num alerts/sec %f exceeds max alerts/sec %f for SYS alerts.  Re-defaulting.", v24, v25),
            v22 = 1,
            a6) )
      {
        sub_1001CAD0();
        sub_1001C980();
        result = 0;
      }
      else
      {
        if ( v23 )
          sub_1001C980();
        result = v22 == 0;
      }
    }
    else
    {
      v19 = 0;
      if ( v10 <= 0 )
      {
LABEL_27:
        if ( v25 < (double)v24 )
        {
          sprintf(a5, "Num alerts/sec %f exceeds max alerts/sec %f for alert class %i.", v24, v25, v8);
          return 0;
        }
      }
      else
      {
        while ( v6 )
        {
          v6 = sub_1001CFD0(a5, a4, v7, a3, v19, a2);
          v21 = sub_1001C400(v20, a3 + 160 * (unsigned int)(unsigned __int16)v19++);
          v24 = v21 + v24;
          if ( (unsigned __int16)v19 >= v10 )
          {
            if ( !v6 )
              break;
            v8 = (unsigned __int8)a1;
            goto LABEL_27;
          }
          v7 = a1;
        }
      }
      result = v6;
    }
  }
  return result;
}
// 1009985C: using guessed type __int16 word_1009985C[];
// 10099860: using guessed type float flt_10099860[];

//----- (1001D810) --------------------------------------------------------
bool __cdecl sub_1001D810(int a1, char *a2)
{
  int v2; // ebp@1
  int v3; // ebx@2
  void *v4; // eax@3
  signed int v5; // edx@3
  const void *v6; // esi@4
  char *v7; // edi@4
  int v8; // ebp@6
  void *v9; // edx@7
  signed int v10; // ebx@7
  const void *v11; // esi@8
  char *v12; // edi@8
  int v13; // esi@10
  int v14; // edi@10
  signed int v15; // ebx@10
  void *v16; // eax@11
  signed int v17; // edx@11
  int v18; // ecx@12
  int v19; // ebp@12
  int v20; // ebx@16
  void *v21; // eax@17
  signed int v22; // edx@17
  const void *v23; // esi@18
  char *v24; // edi@18
  int v25; // ebp@20
  void *v26; // edx@21
  signed int v27; // ebx@21
  const void *v28; // esi@22
  char *v29; // edi@22
  int v30; // esi@24
  int v31; // edi@24
  signed int v32; // ebx@24
  void *v33; // eax@25
  signed int v34; // edx@25
  int v35; // ecx@26
  int v36; // ebp@26
  unsigned int v37; // eax@29
  int v38; // ebx@31
  void *v39; // eax@32
  signed int v40; // edx@32
  const void *v41; // esi@33
  char *v42; // edi@33
  int v43; // esi@35
  int v44; // ebp@35
  void *v45; // edx@37
  signed int v46; // ebx@37
  const void *v47; // esi@38
  char *v48; // edi@38
  int v49; // esi@40
  int v50; // edi@40
  signed int v51; // ebx@40
  void *v52; // eax@41
  signed int v53; // edx@41
  int v54; // ecx@42
  int v55; // ebp@42
  int v57; // [sp+10h] [bp-10h]@6
  int v58; // [sp+10h] [bp-10h]@20
  unsigned __int8 v59; // [sp+10h] [bp-10h]@29
  signed int v60; // [sp+14h] [bp-Ch]@2
  signed int v61; // [sp+14h] [bp-Ch]@6
  signed int v62; // [sp+14h] [bp-Ch]@16
  signed int v63; // [sp+14h] [bp-Ch]@20
  signed int v64; // [sp+14h] [bp-Ch]@31
  signed int v65; // [sp+14h] [bp-Ch]@35
  int v66; // [sp+18h] [bp-8h]@1
  int v67; // [sp+1Ch] [bp-4h]@35

  v2 = 0;
  v66 = 0;
  memset(byte_10186C08, 0, 0x17700u);
  memset(&unk_101B8120, 0, 0x27100u);
  memset(dword_101A0A18, 0, 0x13880u);
  memset(&unk_101B4298, 0, 0x3E84u);
  memset(&unk_101DF280, 0, 0x1F40u);
  memset(&unk_101E5048, 0, 0x1900u);
  if ( (_BYTE)a1 == 1 )
  {
    v3 = 13000;
    v60 = 15;
    do
    {
      sub_1004E7C0(v3, (int)&unk_101E5048, 6400);
      v4 = &unk_101E5048;
      v5 = 100;
      do
      {
        v6 = v4;
        v7 = &byte_10186C08[64 * (unsigned __int16)v2++];
        v4 = (char *)v4 + 64;
        --v5;
        qmemcpy(v7, v6, 0x40u);
      }
      while ( v5 );
      ++v3;
      --v60;
    }
    while ( v60 );
    v8 = 0;
    v57 = 12000;
    v61 = 10;
    do
    {
      sub_1004E7C0(v57, (int)&unk_101B4298, 16004);
      v9 = &unk_101B4298;
      v10 = 100;
      do
      {
        v11 = v9;
        v12 = (char *)&unk_101B8120 + 160 * (unsigned __int16)v8++;
        v9 = (char *)v9 + 160;
        --v10;
        qmemcpy(v12, v11, 0xA0u);
      }
      while ( v10 );
      ++v57;
      --v61;
    }
    while ( v61 );
    v13 = 0;
    v14 = 21000;
    v15 = 10;
    do
    {
      sub_1004E7C0(v14, (int)&unk_101DF280, 8000);
      v16 = &unk_101DF280;
      v17 = 1000;
      do
      {
        v18 = (unsigned __int16)v13;
        dword_101A0A18[2 * v18] = *(_DWORD *)v16;
        v19 = *((_DWORD *)v16 + 1);
        ++v13;
        v16 = (char *)v16 + 8;
        --v17;
        dword_101A0A1C[2 * v18] = v19;
      }
      while ( v17 );
      ++v14;
      --v15;
    }
    while ( v15 );
  }
  else if ( (_BYTE)a1 )
  {
    v59 = 1;
    sub_1004E7C0(6948, (int)&v66, 4);
    v37 = sub_1004E2C0((unsigned int *)"\aAHRS1 TAS", 64740, 0xFFFFFFFF);
    if ( v66 != v37 )
      v59 = 0;
    v38 = 25000;
    v64 = 6;
    do
    {
      sub_1004EA20(v38, v59);
      sub_1004E7C0(v38, (int)&unk_101E5048, 6400);
      v39 = &unk_101E5048;
      v40 = 100;
      do
      {
        v41 = v39;
        v42 = &byte_10186C08[64 * (unsigned __int16)v2++];
        v39 = (char *)v39 + 64;
        --v40;
        qmemcpy(v42, v41, 0x40u);
      }
      while ( v40 );
      ++v38;
      --v64;
    }
    while ( v64 );
    v43 = 23000;
    v44 = 0;
    v65 = 23000;
    v67 = 5;
    while ( 1 )
    {
      sub_1004EA20(v43, v59);
      sub_1004E7C0(v43, (int)&unk_101B4298, 16004);
      v45 = &unk_101B4298;
      v46 = 100;
      do
      {
        v47 = v45;
        v48 = (char *)&unk_101B8120 + 160 * (unsigned __int16)v44++;
        v45 = (char *)v45 + 160;
        --v46;
        qmemcpy(v48, v47, 0xA0u);
      }
      while ( v46 );
      ++v65;
      if ( !--v67 )
        break;
      v43 = v65;
    }
    v49 = 0;
    v50 = 24000;
    v51 = 2;
    do
    {
      sub_1004EA20(v50, v59);
      sub_1004E7C0(v50, (int)&unk_101DF280, 8000);
      v52 = &unk_101DF280;
      v53 = 1000;
      do
      {
        v54 = (unsigned __int16)v49;
        dword_101A0A18[2 * v54] = *(_DWORD *)v52;
        v55 = *((_DWORD *)v52 + 1);
        ++v49;
        v52 = (char *)v52 + 8;
        --v53;
        dword_101A0A1C[2 * v54] = v55;
      }
      while ( v53 );
      ++v50;
      --v51;
    }
    while ( v51 );
  }
  else
  {
    v20 = 15000;
    v62 = 15;
    do
    {
      sub_1004E7C0(v20, (int)&unk_101E5048, 6400);
      v21 = &unk_101E5048;
      v22 = 100;
      do
      {
        v23 = v21;
        v24 = &byte_10186C08[64 * (unsigned __int16)v2++];
        v21 = (char *)v21 + 64;
        --v22;
        qmemcpy(v24, v23, 0x40u);
      }
      while ( v22 );
      ++v20;
      --v62;
    }
    while ( v62 );
    v25 = 0;
    v58 = 14000;
    v63 = 10;
    do
    {
      sub_1004E7C0(v58, (int)&unk_101B4298, 16004);
      v26 = &unk_101B4298;
      v27 = 100;
      do
      {
        v28 = v26;
        v29 = (char *)&unk_101B8120 + 160 * (unsigned __int16)v25++;
        v26 = (char *)v26 + 160;
        --v27;
        qmemcpy(v29, v28, 0xA0u);
      }
      while ( v27 );
      ++v58;
      --v63;
    }
    while ( v63 );
    v30 = 0;
    v31 = 22000;
    v32 = 10;
    do
    {
      sub_1004E7C0(v31, (int)&unk_101DF280, 8000);
      v33 = &unk_101DF280;
      v34 = 1000;
      do
      {
        v35 = (unsigned __int16)v30;
        dword_101A0A18[2 * v35] = *(_DWORD *)v33;
        v36 = *((_DWORD *)v33 + 1);
        ++v30;
        v33 = (char *)v33 + 8;
        --v34;
        dword_101A0A1C[2 * v35] = v36;
      }
      while ( v34 );
      ++v31;
      --v32;
    }
    while ( v32 );
  }
  return sub_1001D5D0(a1, (int)byte_10186C08, (int)&unk_101B8120, (int)dword_101A0A18, a2, 1);
}
// 101A0A18: using guessed type int dword_101A0A18[];
// 101A0A1C: using guessed type int dword_101A0A1C[];

//----- (1001DC80) --------------------------------------------------------
int __cdecl sub_1001DC80(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (1001DE10) --------------------------------------------------------
int __cdecl sub_1001DE10(_DWORD *a1, unsigned int a2, int a3, int a4, int a5)
{
  int v5; // edx@1
  int result; // eax@1
  int v7; // ebx@1
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  unsigned int v21; // edx@23
  char *i; // ecx@23
  int v23; // [sp+20h] [bp+14h]@1

  v5 = a5;
  result = a5 - 1;
  v7 = a3 + a4 * (a5 - 1);
  v23 = a5 - 1;
  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && v5 > 0 )
  {
    if ( result > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v23;
        if ( v20 )
        {
          v7 -= a4;
          result = v23 - 1;
          v23 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a2;
    for ( i = (char *)v7; v21 >= 4; i += 4 )
    {
      if ( *(_DWORD *)&i[(_DWORD)a1 - v7] != *(_DWORD *)i )
        break;
      v21 -= 4;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001DF30) --------------------------------------------------------
char __cdecl sub_1001DF30(char a1)
{
  return byte_1009B1E1[2 * sub_1001DC80(&a1, 1u, (int)&unk_1009B1E0, 2, 17, 16)];
}

//----- (1001DF60) --------------------------------------------------------
char __cdecl sub_1001DF60(char a1)
{
  return byte_1009B205[2 * sub_1001DC80(&a1, 1u, (int)&unk_1009B204, 2, 17, 16)];
}

//----- (1001DF90) --------------------------------------------------------
char __cdecl sub_1001DF90(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1001DFB0) --------------------------------------------------------
char __cdecl sub_1001DFB0(char a1, void *a2)
{
  return sub_10010C50(6, (unsigned __int16)word_1009B1B4[(unsigned __int8)a1], a2);
}
// 1009B1B4: using guessed type __int16 word_1009B1B4[];

//----- (1001DFD0) --------------------------------------------------------
char __cdecl sub_1001DFD0(char a1, int a2, int a3, int a4, int a5)
{
  void *v5; // ecx@0
  char v6; // al@1
  char result; // al@3
  char v8; // [sp+4h] [bp-40h]@3
  char v9; // [sp+26h] [bp-1Eh]@4

  v6 = sub_1001A070(v5);
  if ( (v6 == 1 || v6 == 4) != 1 || sub_1001DF30(a1) != 2 || (result = sub_1001B200(&v8)) == 0 || v9 )
    result = sub_1001FFF0(a2, a3, a4, a5);
  return result;
}
// 1001FFF0: using guessed type _DWORD __cdecl sub_1001FFF0(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1001E050) --------------------------------------------------------
char __cdecl sub_1001E050(int a1)
{
  a1 = *(_BYTE *)(a1 + 4);
  return sub_100106F0(1, 43, &a1, 0, 1, 1);
}

//----- (1001E070) --------------------------------------------------------
char __cdecl sub_1001E070(int a1, char a2)
{
  int v2; // edi@1
  char v3; // bl@1
  int v4; // ST38_4@1
  void *v5; // ecx@1
  int v6; // ebp@1
  void *v7; // ecx@1
  void *v8; // ecx@1
  void *v9; // ecx@2
  int v10; // eax@38
  int v11; // esi@39
  int v12; // eax@39
  int v13; // eax@42
  int v14; // eax@45
  char v15; // al@56
  bool v17; // zf@64
  char v18; // [sp+Fh] [bp-91h]@1
  int v19; // [sp+10h] [bp-90h]@1
  bool v20; // [sp+17h] [bp-89h]@1
  int v21; // [sp+18h] [bp-88h]@1
  int v22; // [sp+1Ch] [bp-84h]@1
  int v23; // [sp+20h] [bp-80h]@1
  int v24; // [sp+24h] [bp-7Ch]@39
  int v25; // [sp+28h] [bp-78h]@39
  char v26; // [sp+2Ch] [bp-74h]@1
  char v27; // [sp+2Dh] [bp-73h]@57
  __int16 v28; // [sp+2Eh] [bp-72h]@57
  int v29; // [sp+30h] [bp-70h]@57
  char v30; // [sp+5Ch] [bp-44h]@57
  char v31; // [sp+60h] [bp-40h]@1

  v2 = 0;
  v21 = 0;
  memset(&v31, 0, 0x3Cu);
  v23 = 2;
  v3 = 0;
  v22 = (unsigned __int16)a1;
  v4 = j_HWM_pvg_hsdb_get_lrus_online();
  memset(&v26, 0, 0x32u);
  v6 = sub_1001B4A0(v5);
  v19 = v6 | v4;
  v20 = sub_1003D530(v7);
  v18 = sub_1003D560(v8);
  if ( a2 == 4 )
  {
    sub_1004E880(9129, &v21, 2, &v23);
    if ( !sub_10019E90(v9) )
    {
      v3 = 1;
      if ( (_WORD)v22 == 32
        || (_WORD)v22 == 81
        || (_WORD)v22 == 80
        || (_WORD)v22 == 78
        || (_WORD)v22 == 79
        || v21 & 0xC
        && (v22 & 0x2000
         || (_WORD)v22 == 33
         || (_WORD)v22 == 73
         || (_WORD)v22 == 34
         || (_WORD)v22 == 61
         || (_WORD)v22 == 62
         || (_WORD)v22 == 37
         || (_WORD)v22 == 66
         || (_WORD)v22 == 67
         || (_WORD)v22 == 82) )
      {
        return 0;
      }
    }
  }
  else
  {
    if ( a2 == 12 )
    {
      if ( v6 == 4 && v19 & 1 )
        return 1;
      return 0;
    }
    if ( a2 == 16 )
    {
      if ( v6 == 4 && v19 & 2 )
        return 1;
      return 0;
    }
    if ( a2 == 6 || a2 == 8 )
    {
      sub_1004E880(9129, &v21, 2, &v23);
      switch ( (unsigned __int16)v22 )
      {
        case 0x23u:
        case 0x24u:
        case 0x26u:
        case 0x36u:
        case 0x3Fu:
        case 0x40u:
        case 0x5Bu:
        case 0x5Cu:
          if ( v6 != 4 || !(v19 & 1) )
            goto LABEL_69;
          v3 = 1;
          v2 = 1;
          goto LABEL_56;
        case 0x25u:
        case 0x42u:
        case 0x43u:
          if ( v20 )
            goto LABEL_89;
          v17 = v6 == 4;
          goto LABEL_87;
        case 0x22u:
        case 0x3Du:
        case 0x3Eu:
          if ( !v18 && (v6 != 4 || !(v19 & 1) || v20) )
            goto LABEL_69;
          goto LABEL_89;
        case 0x52u:
          if ( v6 != 1 )
          {
            v3 = v19 & 1;
            if ( (_WORD)v21 == 8 )
              v3 &= v18 | (v20 == 0);
            goto LABEL_70;
          }
          if ( (_WORD)v21 == 8 && v18 )
            return 1;
          goto LABEL_85;
        case 0x1Cu:
        case 0x1Du:
        case 0x1Eu:
        case 0x1Fu:
        case 0x2Du:
        case 0x2Eu:
        case 0x2Fu:
        case 0x30u:
        case 0x31u:
        case 0x32u:
        case 0x33u:
        case 0x34u:
        case 0x35u:
        case 0x3Cu:
        case 0x46u:
        case 0x47u:
        case 0x48u:
          if ( v6 == 1 && v19 & 4 )
            goto LABEL_81;
          goto LABEL_69;
        default:
          if ( v6 == 1 )
          {
            if ( (_WORD)v21 == 2 && v19 & 4 )
LABEL_81:
              v3 = 1;
            else
LABEL_85:
              v3 = 0;
          }
          else
          {
            v17 = (_WORD)v21 == 16;
LABEL_87:
            if ( v17 && v19 & 1 )
LABEL_89:
              v3 = 1;
            else
LABEL_69:
              v3 = 0;
LABEL_70:
            if ( v6 == 4 && v3 == 1 )
            {
              v2 = 1;
              goto LABEL_56;
            }
          }
          break;
      }
    }
    else if ( a2 == 3 || a2 == 5 || a2 == 13 || a2 == 14 || a2 == 15 || a2 == 17 )
    {
      if ( sub_1001B200(&v31) )
        sub_1001B020((int)&v31);
      v10 = sub_1001DC80(&v22, 2u, (int)&unk_1009B148, 12, 9, 9);
      if ( v10 == 9 )
      {
        v3 = 0;
        if ( !sub_1001FAA0(2, a2) && !(v19 & 4) )
          v2 = 2;
      }
      else
      {
        v11 = 3 * v10;
        LOBYTE(v25) = sub_10019650(dword_1009B14C[3 * v10]);
        LOBYTE(v24) = sub_10019650(dword_1009B150[v11]);
        v12 = dword_1009B14C[v11];
        if ( v6 != v12 )
        {
          if ( v12 & v19 )
          {
            v3 = 1;
            if ( !sub_1001FAA0(v25, a2) )
            {
              v13 = dword_1009B150[v11];
              if ( v6 == v13 || !(v13 & v19) )
                v2 = dword_1009B14C[v11];
            }
          }
          else
          {
            v14 = dword_1009B150[v11];
            if ( v6 != v14 )
            {
              if ( v14 & v19 )
              {
                v3 = 1;
                if ( !sub_1001FAA0(v24, a2) )
                  v2 = dword_1009B150[v11];
              }
            }
          }
        }
      }
      if ( (_WORD)v22 == 36 )
        v3 = 1;
      if ( v2 && v2 != v6 )
      {
LABEL_56:
        v15 = sub_10019650(v2);
        if ( !sub_1001FAA0(v15, a2) )
        {
          v26 = 120;
          v27 = 1;
          v28 = 4;
          v30 = a2;
          v29 = a1;
          sub_100106F0(6, 232, &v26, 1, 50, 1);
          sub_100108A0(6, 232, v2);
        }
      }
    }
  }
  return v3;
}
// 1004ECB0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1009B14C: using guessed type int dword_1009B14C[];
// 1009B150: using guessed type int dword_1009B150[];

//----- (1001E520) --------------------------------------------------------
int __usercall sub_1001E520@<eax>(char a1@<al>, char a2@<cl>)
{
  char v2; // bl@1
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // ebx@2
  int result; // eax@2
  int v7; // ebx@3

  v2 = a2;
  if ( sub_1001DF30(a1) == 2 )
  {
    LOBYTE(v4) = v2;
    BYTE1(v4) = v2;
    word_101E695C = 0;
    v5 = v4 << 16;
    LOWORD(v5) = v4;
    result = v5;
    dword_101E6960 = v5;
    dword_101E6964 = v5;
    dword_101E6968 = v5;
    dword_101E696C = v5;
    word_101E6970 = v4;
  }
  else
  {
    LOBYTE(v3) = v2;
    BYTE1(v3) = v2;
    v7 = v3 << 16;
    LOWORD(v7) = v3;
    result = v7;
    dword_101E6954 = v7;
    dword_101E6958 = v7;
  }
  return result;
}
// 101E6954: using guessed type int dword_101E6954;
// 101E6958: using guessed type int dword_101E6958;
// 101E695C: using guessed type __int16 word_101E695C;
// 101E6960: using guessed type int dword_101E6960;
// 101E6964: using guessed type int dword_101E6964;
// 101E6968: using guessed type int dword_101E6968;
// 101E696C: using guessed type int dword_101E696C;
// 101E6970: using guessed type __int16 word_101E6970;

//----- (1001E580) --------------------------------------------------------
char __usercall sub_1001E580@<al>(int a1@<esi>, char a2, char a3)
{
  char v3; // al@1
  __int16 v4; // cx@1
  char v5; // dl@1
  char v7; // [sp+0h] [bp-30h]@1
  __int16 v8; // [sp+22h] [bp-Eh]@1
  char v9; // [sp+24h] [bp-Ch]@1
  char v10; // [sp+26h] [bp-Ah]@1
  char v11; // [sp+27h] [bp-9h]@1
  char v12; // [sp+28h] [bp-8h]@1
  char v13; // [sp+29h] [bp-7h]@1

  memset(&v7, 0, 0x2Cu);
  v3 = *(_BYTE *)(a1 + 2);
  v9 = (v3 != 0) + 2;
  v4 = *(_WORD *)a1;
  v11 = a3;
  v5 = *(_BYTE *)(a1 + 3);
  v8 = v4;
  v10 = v3;
  v12 = v5;
  v13 = a2;
  return sub_1003D590(&v7);
}

//----- (1001E5F0) --------------------------------------------------------
BOOL __cdecl sub_1001E5F0(unsigned __int8 a1, char a2)
{
  int v2; // ebp@1
  void *v3; // ecx@1
  int v4; // ebp@1
  char *v5; // edi@1
  _WORD *v6; // ebx@1
  char v8; // [sp+13h] [bp-11h]@2
  char v9; // [sp+14h] [bp-10h]@1
  int v10; // [sp+18h] [bp-Ch]@1
  int v11; // [sp+1Ch] [bp-8h]@1
  char v12[4]; // [sp+20h] [bp-4h]@4

  v11 = 0;
  v10 = 0;
  v2 = j_HWM_pvg_hsdb_get_lrus_online();
  v4 = sub_1001B4A0(v3) | v2;
  v9 = 0;
  v5 = (char *)&word_101E6974 + 3 * a1;
  v6 = &unk_1009B1C4;
  do
  {
    *v5 = 0;
    v8 = sub_1001FB70(v9, a2);
    if ( v8 != 2 )
    {
      ++v10;
      if ( sub_100194B0(v9) & v4
        && sub_10010C50(2, *v6, v12)
        && !sub_10020A40((int)v12)
        && v12[(unsigned __int8)v8] == 2 )
      {
        ++v11;
      }
      else
      {
        *v5 = 1;
      }
    }
    v6 += 6;
    ++v5;
    ++v9;
  }
  while ( (unsigned __int8)v9 < 3u );
  return v11 < v10;
}
// 1004ECB0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 101E6974: using guessed type __int16 word_101E6974;
// 1001E5F0: using guessed type char var_4[4];

//----- (1001E6C0) --------------------------------------------------------
__int16 __cdecl sub_1001E6C0(int a1, char a2)
{
  _DWORD *v2; // edi@1
  int v3; // eax@1
  char v4; // bl@1
  char v5; // bl@1
  void *v6; // ecx@1
  int v7; // eax@1
  void *v8; // ecx@1
  int v9; // eax@5
  __int16 v10; // cx@5
  char v11; // bl@7
  bool v12; // zf@10
  unsigned int v13; // esi@18
  int v14; // eax@33
  __int16 *v15; // ecx@33
  char v17; // [sp+Fh] [bp-49h]@3
  int v18; // [sp+10h] [bp-48h]@5
  int v19; // [sp+14h] [bp-44h]@1
  int v20; // [sp+18h] [bp-40h]@5
  int v21; // [sp+1Ch] [bp-3Ch]@1
  int v22; // [sp+20h] [bp-38h]@1
  __int16 v23; // [sp+24h] [bp-34h]@1
  __int16 v24; // [sp+26h] [bp-32h]@1
  __int16 v25; // [sp+28h] [bp-30h]@1
  __int16 v26; // [sp+2Ah] [bp-2Eh]@1
  __int16 v27; // [sp+2Ch] [bp-2Ch]@1
  __int16 v28; // [sp+2Eh] [bp-2Ah]@1
  __int16 v29; // [sp+30h] [bp-28h]@1
  __int16 v30; // [sp+32h] [bp-26h]@1
  __int16 v31; // [sp+34h] [bp-24h]@1
  __int16 v32; // [sp+36h] [bp-22h]@1
  __int16 v33; // [sp+38h] [bp-20h]@1
  __int16 v34; // [sp+3Ah] [bp-1Eh]@1
  __int16 v35; // [sp+3Ch] [bp-1Ch]@1
  __int16 v36; // [sp+3Eh] [bp-1Ah]@1
  __int16 v37; // [sp+40h] [bp-18h]@1
  __int16 v38; // [sp+44h] [bp-14h]@1
  __int16 v39; // [sp+46h] [bp-12h]@1
  __int16 v40; // [sp+48h] [bp-10h]@1
  __int16 v41; // [sp+4Ah] [bp-Eh]@1
  __int16 v42; // [sp+4Ch] [bp-Ch]@1
  __int16 v43; // [sp+4Eh] [bp-Ah]@1
  __int16 v44; // [sp+50h] [bp-8h]@1
  __int16 v45; // [sp+52h] [bp-6h]@1
  __int16 v46; // [sp+54h] [bp-4h]@1
  int v47; // [sp+5Ch] [bp+4h]@1
  char v48; // [sp+5Ch] [bp+4h]@1
  char v49; // [sp+60h] [bp+8h]@18

  v45 = 62;
  v36 = 62;
  v2 = (_DWORD *)a1;
  v40 = 37;
  v25 = 37;
  v31 = 37;
  v3 = *(_WORD *)a1;
  v44 = 57;
  v35 = 57;
  v4 = *(_BYTE *)(a1 + 3);
  v23 = 81;
  v24 = 81;
  v38 = 40;
  v39 = 34;
  v41 = 56;
  v42 = 61;
  v43 = 66;
  v46 = 67;
  v26 = 80;
  v27 = 34;
  v28 = 80;
  v29 = 40;
  v30 = 34;
  v32 = 56;
  v33 = 61;
  v34 = 66;
  v37 = 67;
  v22 = 2;
  v19 = v3;
  v5 = v4 & 1;
  v47 = j_HWM_pvg_hsdb_get_lrus_online();
  v7 = sub_1001B4A0(v6);
  v8 = (void *)(v7 | v47);
  v21 = v7 | v47;
  dword_101E6950 = 0;
  v48 = 1;
  if ( sub_1001B4A0(v8) == 1 || !(v21 & 1) || (v17 = 0, !sub_1001FAA0(1, a2)) )
    v17 = 1;
  sub_1004EC10(9129, &v20, 2, &v22);
  v9 = sub_1001DC80(&v19, 2u, (int)&unk_1009B228, 12, 6, 6);
  v10 = v20;
  v18 = (unsigned __int16)v20;
  if ( v5 && v17 )
  {
    v11 = a2;
    if ( a2 == 4 || a2 == 8 )
    {
      switch ( (unsigned __int16)v19 )
      {
        case 0x4Eu:
        case 0x4Fu:
          v13 = 12 * v9;
          v48 = 0;
          v49 = sub_10019650(dword_1009B22C[3 * v9]);
          if ( v21 & dword_1009B22C[v13 / 4] && sub_1001FAA0(v49, v11) )
            v18 = (unsigned __int16)word_1009B230[v13 / 2];
          v10 = v20;
          goto LABEL_22;
        case 0x5Bu:
        case 0x5Eu:
          v48 = 0;
          v18 = (unsigned __int16)word_1009B230[6 * v9];
          goto LABEL_22;
        case 0x50u:
        case 0x51u:
          v48 = 0;
          if ( a2 == 4 )
          {
            v18 = v20 & 3 | (unsigned __int16)(~(_WORD)v20 & word_1009B230[6 * v9]);
          }
          else
          {
            v18 = (unsigned __int16)word_1009B230[6 * v9];
            if ( (_WORD)v20 != (_WORD)v18 )
              goto LABEL_23;
            v18 = 2;
          }
LABEL_22:
          if ( (_WORD)v18 == v10 )
            break;
LABEL_23:
          sub_1004E9B0(9129, (int)&v18, 2);
          break;
        default:
          v18 = (unsigned __int16)v20;
          break;
      }
    }
    else
    {
      switch ( (unsigned __int16)v19 )
      {
        case 0x51u:
          v12 = (v20 & 4) == 0;
          goto LABEL_11;
        case 0x50u:
          v12 = (v20 & 8) == 0;
LABEL_11:
          if ( v12 )
            v48 = 0;
          v18 = (unsigned __int16)word_1009B230[6 * v9];
          goto LABEL_22;
        case 0x5Bu:
        case 0x5Eu:
          v18 = (unsigned __int16)word_1009B230[6 * v9];
          v48 = 0;
          goto LABEL_22;
        default:
          v18 = (unsigned __int16)v20;
          break;
      }
    }
  }
  else
  {
    v11 = a2;
  }
  if ( v11 == 4 )
  {
    v14 = sub_1001DC80(v2, 2u, (int)&v38, 6, 3, -1);
    v15 = &v38;
  }
  else if ( v11 == 8 )
  {
    v14 = sub_1001DC80(v2, 2u, (int)&v29, 6, 3, -1);
    v15 = &v29;
  }
  else
  {
    v14 = sub_1001DC80(v2, 2u, (int)&v23, 6, 2, -1);
    v15 = &v23;
  }
  if ( v14 != -1 && v48 == 1 )
  {
    if ( v18 & 4 )
    {
      v14 *= 3;
      *(_WORD *)v2 = v15[v14 + 2];
    }
    else if ( v18 & 8 )
    {
      LOWORD(v14) = v15[3 * v14 + 1];
      *(_WORD *)v2 = v14;
    }
  }
  return v14;
}
// 1004ECB0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1009B22C: using guessed type int dword_1009B22C[];
// 1009B230: using guessed type __int16 word_1009B230[];
// 101E6950: using guessed type int dword_101E6950;

//----- (1001EA70) --------------------------------------------------------
char __usercall sub_1001EA70@<al>(int a1@<esi>)
{
  int v1; // eax@1
  void *v2; // ecx@1
  char v3; // bl@2
  char result; // al@3

  v1 = sub_1001DC80((_DWORD *)a1, 2u, (int)&unk_1009B270, 4, 3, 2);
  if ( byte_1009B272[4 * v1] == 2 )
  {
    result = 0;
  }
  else
  {
    v3 = byte_1009B272[4 * v1];
    if ( sub_1001AFC0(v2) == v3 )
    {
      result = 1;
    }
    else
    {
      sub_1001B0F0(v3);
      *(_BYTE *)(a1 + 3) |= 1u;
      result = 0;
    }
  }
  return result;
}

//----- (1001EAC0) --------------------------------------------------------
char __usercall sub_1001EAC0@<al>(char a1@<bl>, unsigned __int8 a2, int a3)
{
  char result; // al@1
  int *v4; // esi@1
  char *v5; // ebp@1
  signed int v6; // [sp+Ch] [bp-38h]@1
  char v7; // [sp+10h] [bp-34h]@1
  char v8; // [sp+11h] [bp-33h]@3
  __int16 v9; // [sp+12h] [bp-32h]@3
  int v10; // [sp+14h] [bp-30h]@3
  char v11; // [sp+40h] [bp-4h]@3

  memset(&v7, 0, 0x32u);
  result = a2;
  v4 = (int *)&unk_1009B1C0;
  v5 = (char *)&word_101E6974 + 3 * a2;
  v6 = 3;
  do
  {
    if ( *v5 )
    {
      v7 = 120;
      v8 = 1;
      v9 = 4;
      v11 = a1;
      v10 = a3;
      sub_100106F0(6, 232, &v7, 1, 50, 1);
      result = sub_100108A0(6, 232, *v4);
    }
    ++v5;
    v4 += 3;
    --v6;
  }
  while ( v6 );
  return result;
}
// 101E6974: using guessed type __int16 word_101E6974;

//----- (1001EB50) --------------------------------------------------------
int __cdecl sub_1001EB50(unsigned __int8 a1, char a2)
{
  int v2; // eax@1
  int result; // eax@7
  int v4; // [sp+4h] [bp-8h]@1
  int v5; // [sp+8h] [bp-4h]@1

  v2 = a1;
  *(__int16 *)((char *)&word_101E6974 + 3 * v2) = 0;
  v5 = 2;
  v4 = 0;
  byte_101E6976[3 * v2] = 0;
  if ( a2 == 4 || a2 == 6 || a2 == 8 )
  {
    if ( sub_1001BD80(111) )
    {
      sub_1004EC10(9129, &v4, 2, &v5);
      v4 &= 0xFFF3u;
      sub_1004E9B0(9129, (int)&v4, 2);
    }
    else
    {
      dword_101E6950 = sub_1004E4B0();
    }
  }
  result = sub_1001E520(a2, 0);
  byte_101E694C = 0;
  return result;
}
// 101E694C: using guessed type char byte_101E694C;
// 101E6950: using guessed type int dword_101E6950;
// 101E6974: using guessed type __int16 word_101E6974;

//----- (1001EBF0) --------------------------------------------------------
char __cdecl sub_1001EBF0(char a1, char a2, int a3, char a4)
{
  char result; // al@8
  bool v5; // zf@9

  if ( a4 )
  {
    sub_1001E580((int)&a3, a1, a2);
    if ( (unsigned __int8)sub_1001E5F0(a1, a2) )
      sub_1001EAC0(a2, a1, a3);
  }
  if ( a2 == 4 || a2 == 6 || a2 == 8 )
    sub_1001E6C0((int)&a3, a2);
  result = sub_1001EA70((int)&a3);
  if ( !result )
  {
    v5 = sub_1001E070(a3, a2) == 0;
    result = BYTE2(a3);
    if ( v5 || !(BYTE3(a3) & 1) && !BYTE2(a3) )
      result = sub_100200D0(a2, a3, SBYTE2(a3), SBYTE3(a3), 0);
  }
  return result;
}

//----- (1001EC90) --------------------------------------------------------
char __cdecl sub_1001EC90(int a1, char a2)
{
  unsigned int v2; // eax@1
  void *v3; // ecx@4
  void *v4; // ecx@4
  char v5; // dl@16
  char v6; // bl@16
  int *v7; // edi@16
  _BYTE *v8; // esi@16
  bool v9; // zf@19
  bool v10; // zf@21
  void *v11; // ecx@39
  int *v12; // edi@42
  _BYTE *v13; // esi@42
  char v14; // al@44
  unsigned __int8 v15; // al@46
  unsigned __int8 v16; // al@46
  bool v17; // cl@49
  unsigned __int8 v18; // al@51
  __int16 v19; // dx@51
  unsigned __int8 v20; // al@56
  unsigned __int8 v21; // al@58
  int v22; // edx@60
  unsigned __int8 v23; // al@64
  void *v24; // ecx@75
  int v26; // [sp-18h] [bp-C0h]@12
  char *v27; // [sp-14h] [bp-BCh]@12
  char *v28; // [sp-Ch] [bp-B4h]@12
  char v29; // [sp+Bh] [bp-9Dh]@43
  int v30; // [sp+Ch] [bp-9Ch]@1
  __int16 v31; // [sp+10h] [bp-98h]@1
  unsigned __int8 v32; // [sp+17h] [bp-91h]@42
  char v33; // [sp+18h] [bp-90h]@1
  char v34; // [sp+19h] [bp-8Fh]@1
  char v35; // [sp+1Ah] [bp-8Eh]@1
  char v36; // [sp+1Bh] [bp-8Dh]@1
  int v37; // [sp+1Ch] [bp-8Ch]@1
  unsigned __int16 v38; // [sp+20h] [bp-88h]@10
  int v39; // [sp+24h] [bp-84h]@1
  int v40; // [sp+28h] [bp-80h]@16
  char v41; // [sp+2Ch] [bp-7Ch]@1
  char v42; // [sp+30h] [bp-78h]@47
  char v43; // [sp+31h] [bp-77h]@50
  char v44; // [sp+33h] [bp-75h]@48
  char v45; // [sp+34h] [bp-74h]@49
  char v46; // [sp+35h] [bp-73h]@56
  char v47; // [sp+36h] [bp-72h]@58
  char v48; // [sp+37h] [bp-71h]@42
  char v49; // [sp+38h] [bp-70h]@44
  char v50; // [sp+39h] [bp-6Fh]@46
  char v51; // [sp+3Dh] [bp-6Bh]@45
  char v52; // [sp+48h] [bp-60h]@57
  char v53; // [sp+49h] [bp-5Fh]@59
  bool v54; // [sp+68h] [bp-40h]@1
  char v55; // [sp+6Ch] [bp-3Ch]@78

  memset(&v41, 0, 0x3Cu);
  v30 = 0;
  v31 = 0;
  v35 = 0;
  v37 = 0;
  memset(&v54, 0, 0x3Cu);
  v33 = 0;
  v34 = 0;
  v39 = 2;
  sub_1004E7C0(9110, (int)&v36, 1);
  LOBYTE(v2) = (v36 & 3) != 0;
  BYTE2(v37) = (v36 & 3) != 0;
  v54 = (v36 & 3) != 0;
  switch ( a2 )
  {
    case 4:
      if ( !dword_101E6950 || (v2 = sub_1004E4B0() - dword_101E6950, v2 >= 0x2710) )
      {
        dword_101E6950 = 0;
        sub_1001E5F0(a1, a2);
        if ( sub_1001A070(v3) != 2
          || sub_1001B4A0(v4) == 1
          || (LOBYTE(v2) = a1, *((_BYTE *)&word_101E6974 + 3 * (unsigned __int8)a1 + 1)) )
        {
          sub_1004EC10(9129, &v37, 2, &v39);
          LOBYTE(v2) = sub_1001DFD0(a2, a1, 30977, (int)&v37, 4);
        }
      }
      return v2;
    case 6:
    case 8:
      sub_1001DFD0(a2, a1, 30977, (int)&v37, 4);
      if ( BYTE2(v37) )
      {
        LOBYTE(v2) = sub_1001E520(a2, -1);
        return v2;
      }
      sub_1004EC10(9129, &v38, 2, &v39);
      if ( a2 != 6 )
        goto LABEL_16;
      if ( v38 & 4 )
      {
        v28 = &v35;
        v27 = &v33;
        v26 = 9117;
      }
      else
      {
        if ( !(v38 & 8) )
          goto LABEL_16;
        v28 = &v35;
        v27 = &v34;
        v26 = 9116;
      }
      sub_1004E880(v26, v27, 1, v28);
LABEL_16:
      v5 = v33;
      v6 = v34;
      v7 = &dword_101E6954;
      v8 = &unk_1009B034;
      v40 = 8;
      do
      {
        LOBYTE(v2) = *v8;
        if ( *v8 == a2 || (_BYTE)v2 == 19 )
        {
          v9 = (v38 & *((_WORD *)v8 - 1)) == 0;
          LOWORD(v30) = *((_WORD *)v8 - 2);
          LOBYTE(v2) = !v9;
          switch ( (unsigned __int16)v30 )
          {
            case 1u:
              if ( v9 )
                goto LABEL_32;
              v10 = v5 == 0;
              goto LABEL_30;
            case 2u:
              if ( v9 || v5 != 1 )
                goto LABEL_32;
              LOBYTE(v2) = 1;
              break;
            case 3u:
              if ( v9 || v6 )
                goto LABEL_32;
              LOBYTE(v2) = 1;
              break;
            case 4u:
              if ( v9 )
                goto LABEL_32;
              v10 = v6 == 1;
LABEL_30:
              if ( !v10 )
LABEL_32:
                LOBYTE(v2) = 0;
              else
                LOBYTE(v2) = 1;
              break;
            default:
              break;
          }
          v9 = *(_BYTE *)v7 == (_BYTE)v2;
          BYTE2(v30) = v2;
          if ( !v9 )
          {
            sub_1001DFD0(a2, a1, 30983, (int)&v30, 6);
            LOBYTE(v2) = BYTE2(v30);
            v5 = v33;
            v6 = v34;
            *(_BYTE *)v7 = BYTE2(v30);
          }
        }
        v8 += 6;
        v7 = (int *)((char *)v7 + 1);
        --v40;
      }
      while ( v40 );
      return v2;
    case 9:
    case 0xA:
    case 0xB:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x11:
      if ( v36 & 3 || byte_101E694C )
      {
        sub_1001DFD0(a2, a1, 30977, (int)&v37, 4);
        sub_1001E520(a2, -1);
        LOBYTE(v2) = v54;
        byte_101E694C = v54;
      }
      else if ( sub_1001B200(&v41) )
      {
        if ( (unsigned __int16)word_101E695C >= 0x12u )
          word_101E695C = 0;
        LOBYTE(v11) = v48;
        v32 = 0;
        v12 = &dword_101E6960;
        v13 = &unk_1009B07A;
        while ( 2 )
        {
          LOWORD(v30) = *((_WORD *)v13 - 1);
          HIWORD(v30) = 17920;
          v31 = 1000;
          v29 = 13;
          switch ( (unsigned __int16)v30 )
          {
            case 8u:
              v14 = (_BYTE)v11 == 2;
              BYTE2(v30) = (_BYTE)v11 == 2;
              v29 = v49;
              goto LABEL_63;
            case 0x13u:
              v14 = v51;
              BYTE2(v30) = v51;
              goto LABEL_63;
            case 9u:
            case 0xAu:
            case 0x15u:
              v15 = sub_1001DC80(&v50, 1u, (int)&unk_1009B108, 4, 8, 7);
              BYTE2(v30) = word_1009B10A[2 * v15] == (_WORD)v30;
              v16 = sub_1001DC80(&v48, 1u, (int)&unk_1009B128, 4, 8, 7);
              v11 = (void *)v16;
              v9 = word_1009B12A[2 * v16] == (_WORD)v30;
              v14 = v9 | BYTE2(v30);
              BYTE2(v30) |= v9;
              v29 = v49;
              goto LABEL_63;
            case 0xBu:
              v14 = v42 == 1 || v42 == 6;
              BYTE2(v30) = v42 == 1 || v42 == 6;
              goto LABEL_63;
            case 0xCu:
              v14 = (_BYTE)v11 != 0 || v44 != 0;
              BYTE2(v30) = (_BYTE)v11 != 0 || v44 != 0;
              goto LABEL_63;
            case 0x12u:
              v17 = (_BYTE)v11 == 13;
              v14 = v17 && v44 == 14;
              BYTE2(v30) = v17 && v44 == 14;
              v29 = v45;
              goto LABEL_63;
            case 0xDu:
              v14 = v43 == 1;
              BYTE2(v30) = v43 == 1;
              goto LABEL_63;
            case 0xEu:
            case 0xFu:
            case 0x10u:
            case 0x14u:
              v18 = sub_1001DC80(&v44, 1u, (int)&unk_1009B0E8, 4, 8, 7);
              v11 = (void *)v18;
              v19 = word_1009B0EA[2 * v18];
              v29 = v45;
              v14 = v19 == (_WORD)v30;
              BYTE2(v30) = v19 == (_WORD)v30;
              goto LABEL_63;
            case 0x19u:
              v14 = sub_1001AF80(v11) == 1;
              BYTE2(v30) = v14;
              goto LABEL_63;
            case 0x1Bu:
              v14 = sub_1001AF80(v11) == 2;
              BYTE2(v30) = v14;
              goto LABEL_63;
            case 0x1Cu:
              v14 = sub_1001AFC0(v11) == 1;
              BYTE2(v30) = v14;
              goto LABEL_63;
            case 0x1Du:
              v14 = sub_1001AFC0(v11) == 0;
              BYTE2(v30) = v14;
              goto LABEL_63;
            default:
              v20 = sub_1001DC80(&v46, 1u, (int)&unk_1009B0CC, 4, 3, 2);
              if ( word_1009B0CE[2 * v20] == (_WORD)v30 )
              {
                BYTE2(v30) = 1;
                v29 = v52;
              }
              v21 = sub_1001DC80(&v47, 1u, (int)&unk_1009B0D8, 4, 4, 3);
              if ( word_1009B0DA[2 * v21] == (_WORD)v30 )
              {
                BYTE2(v30) = 1;
                v29 = v53;
              }
              v22 = (unsigned __int8)sub_1001DC80(&v44, 1u, (int)&unk_1009B0E8, 4, 8, 7);
              if ( word_1009B0EA[2 * v22] == (_WORD)v30 )
              {
                BYTE2(v30) = 1;
                v29 = v45;
LABEL_64:
                v23 = sub_1001DC80(&v29, 1u, (int)&unk_1009B0C0, 2, 6, 6);
                if ( v23 == 6 )
                {
                  v14 = BYTE2(v30);
                }
                else
                {
                  v14 = *v13 & byte_1009B0C1[2 * v23];
                  BYTE2(v30) = v14;
                }
                goto LABEL_67;
              }
              v14 = BYTE2(v30);
LABEL_63:
              if ( v14 == 1 )
                goto LABEL_64;
LABEL_67:
              if ( *(_BYTE *)v12 != v14 || (LOWORD(v11) = v32, v32 == word_101E695C) && v14 != 2 )
              {
                sub_1001DFD0(a2, a1, 30983, (int)&v30, 6);
                *(_BYTE *)v12 = BYTE2(v30);
              }
              LOBYTE(v11) = v48;
              LOBYTE(v2) = v32 + 1;
              v13 += 4;
              v12 = (int *)((char *)v12 + 1);
              if ( ++v32 < 0x12u )
                continue;
              ++word_101E695C;
              break;
          }
          break;
        }
      }
      else
      {
        LOBYTE(v2) = sub_1001E520(a2, 0);
        word_101E695C = 0;
      }
      return v2;
    case 3:
      if ( sub_1001A070((void *)(unsigned __int8)a2) == 2 || (LOBYTE(v2) = sub_1001B200(&v41), (_BYTE)v2) )
      {
        if ( sub_1001A070(v24) != 2 )
          qmemcpy(&v55, &v42, 0x38u);
        LOBYTE(v2) = sub_1001DFD0(a2, a1, 30977, (int)&v54, 60);
      }
      return v2;
    default:
      return v2;
  }
}
// 1009B0CE: using guessed type __int16 word_1009B0CE[];
// 1009B0DA: using guessed type __int16 word_1009B0DA[];
// 1009B0EA: using guessed type __int16 word_1009B0EA[];
// 1009B10A: using guessed type __int16 word_1009B10A[];
// 1009B12A: using guessed type __int16 word_1009B12A[];
// 101E694C: using guessed type char byte_101E694C;
// 101E6950: using guessed type int dword_101E6950;
// 101E6954: using guessed type int dword_101E6954;
// 101E695C: using guessed type __int16 word_101E695C;
// 101E6960: using guessed type int dword_101E6960;
// 101E6974: using guessed type __int16 word_101E6974;

//----- (1001F3B0) --------------------------------------------------------
char __cdecl sub_1001F3B0(unsigned __int8 a1)
{
  char v2; // [sp+0h] [bp-2Ch]@1

  memset(&v2, 0, 0x2Cu);
  return sub_100106F0(6, (unsigned __int16)word_1009B7B2[8 * a1], &v2, 0, 44, 0);
}
// 1009B7B2: using guessed type __int16 word_1009B7B2[];

//----- (1001F3F0) --------------------------------------------------------
char __cdecl sub_1001F3F0(unsigned __int8 a1)
{
  int v1; // ecx@0
  int v2; // ST04_4@1
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v1;
  v2 = (unsigned __int16)word_1009B7B4[8 * a1];
  v4 = 0;
  return sub_100106F0(6, v2, &v4, 0, 4, 0);
}
// 1009B7B4: using guessed type __int16 word_1009B7B4[];

//----- (1001F420) --------------------------------------------------------
char __cdecl sub_1001F420(char a1, void *a2)
{
  return sub_10010C50(6, (unsigned __int16)word_1009B7B2[8 * (unsigned __int8)a1], a2);
}
// 1009B7B2: using guessed type __int16 word_1009B7B2[];

//----- (1001F440) --------------------------------------------------------
char __cdecl sub_1001F440(char a1, void *a2)
{
  return sub_10010C50(6, (unsigned __int16)word_1009B7B4[8 * (unsigned __int8)a1], a2);
}
// 1009B7B4: using guessed type __int16 word_1009B7B4[];

//----- (1001F460) --------------------------------------------------------
bool __cdecl sub_1001F460(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_1004E7C0(dword_1009B7B8[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 1009B7B8: using guessed type int dword_1009B7B8[];

//----- (1001F4A0) --------------------------------------------------------
bool __cdecl sub_1001F4A0(unsigned __int8 a1, _DWORD *a2)
{
  bool result; // al@1
  char v3; // [sp+0h] [bp-30h]@1
  int v4; // [sp+2Ch] [bp-4h]@1

  result = sub_1004E7C0(dword_1009B7B8[4 * a1], (int)&v3, 48) == 0;
  *a2 = v4;
  return result;
}
// 1009B7B8: using guessed type int dword_1009B7B8[];

//----- (1001F4E0) --------------------------------------------------------
char __cdecl sub_1001F4E0(int a1, unsigned __int8 a2)
{
  char v2; // bl@1
  char result; // al@1
  int v4; // [sp+4h] [bp-8h]@1
  int v5; // [sp+8h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v2 = sub_10010C50(6, a1, &v4);
  result = v2 | sub_1001F4A0(a2, &v5);
  if ( result )
  {
    if ( v4 == v5 )
    {
      result = sub_1001BE10(word_1009B7A8[a2]);
    }
    else
    {
      result = sub_1001BD80(word_1009B7A8[a2]);
      if ( !result )
        result = sub_1001BF40(word_1009B7A8[a2]);
    }
  }
  return result;
}
// 1009B7A8: using guessed type __int16 word_1009B7A8[];

//----- (1001F570) --------------------------------------------------------
char __cdecl sub_1001F570(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1001DF90(a1);
  if ( a2 )
    result = sub_1001F460(v6, (char *)a5);
  else
    result = sub_1001F420(v6, a5);
  return result;
}

//----- (1001F5B0) --------------------------------------------------------
char __cdecl sub_1001F5B0(char a1, char a2, char *a3, char *a4)
{
  char *v4; // ebp@1
  int v5; // edi@1
  int v6; // esi@1
  char v7; // bl@1
  int v8; // eax@1
  int v9; // esi@5
  char v10; // al@11
  unsigned __int8 v11; // al@26
  bool v12; // cf@26
  bool v13; // zf@26
  char v15[4]; // [sp+10h] [bp-58h]@9
  char v16[24]; // [sp+14h] [bp-54h]@22
  char v17[56]; // [sp+2Ch] [bp-3Ch]@33

  v4 = a4;
  v5 = 904;
  v6 = 1000;
  v7 = 0;
  v8 = sub_1001DC80(&a1, 1u, (int)&unk_1009C648, 4, 8, 8);
  if ( v8 < 8 )
    v5 = (unsigned __int16)word_1009C64A[2 * v8];
  switch ( a1 )
  {
    case 3:
    case 4:
    case 5:
      if ( a2 )
        v9 = (unsigned __int8)*a3 + 2;
      else
        v9 = (unsigned __int8)*a3;
      if ( (unsigned __int16)v5 < 0x388u && v9 < 4 && sub_10010C50(2, v5, v15) == 1 && !sub_10020A40((int)v15) )
      {
        v10 = v15[v9];
        goto LABEL_36;
      }
      return v7;
    case 6:
    case 7:
      if ( a2 )
      {
        if ( a2 == 1 )
        {
          v6 = (unsigned __int8)*a3 + 8;
        }
        else if ( a2 == 2 )
        {
          if ( (unsigned __int8)*a3 < 8u )
            v6 = (unsigned __int8)*a3 + 13;
        }
        else
        {
          v6 = (unsigned __int8)*a3 + 21;
        }
      }
      else
      {
        v6 = (unsigned __int8)*a3;
      }
      if ( (unsigned __int16)v5 < 0x388u && v6 < 23 && sub_10010C50(2, v5, v16) == 1 && !sub_10020BF0((int)v16) )
      {
        *v4 = v16[v6];
        goto LABEL_37;
      }
      return v7;
    case 0x19:
    case 0x1A:
    case 0x2B:
      if ( a2 == 2 )
      {
        v11 = *a3;
        if ( (unsigned __int8)*a3 < 0x10u )
          goto LABEL_31;
        v12 = v11 < 0x28u;
        v13 = v11 == 40;
      }
      else
      {
        v11 = *a3;
        v12 = (unsigned __int8)*a3 < 0x10u;
        v13 = *a3 == 16;
      }
      if ( v12 || v13 )
        v6 = v11;
LABEL_31:
      if ( (unsigned __int16)v5 < 0x388u && v6 < 56 && sub_10010C50(2, v5, v17) == 1 && !sub_100213A0((int)v17) )
      {
        v10 = v17[v6];
LABEL_36:
        *v4 = v10;
LABEL_37:
        v7 = 1;
      }
      return v7;
    default:
      return v7;
  }
}
// 1009C64A: using guessed type __int16 word_1009C64A[];
// 1001F5B0: using guessed type char var_58[4];
// 1001F5B0: using guessed type char var_54[24];
// 1001F5B0: using guessed type char var_3C[56];

//----- (1001F7C0) --------------------------------------------------------
int __thiscall sub_1001F7C0(void *this)
{
  int v1; // esi@1

  v1 = sub_1001A050(this);
  return v1 & ~j_HWM_pvg_hsdb_get_lrus_online();
}
// 1004ECB0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (1001F7E0) --------------------------------------------------------
char __thiscall sub_1001F7E0(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_101E6980 = sub_1001A070(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_101E6988, 0, 0x1540u);
  memset(&unk_101E7EC8, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_101E6988;
  do
  {
    sub_10019280(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_101E7EC8 );
  v3 = 0;
  v4 = &unk_101E7EC8;
  do
  {
    result = sub_10019300(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)&unk_101E9878 );
  return result;
}
// 101E6980: using guessed type int dword_101E6980;

//----- (1001F870) --------------------------------------------------------
char __cdecl sub_1001F870(char a1)
{
  char v1; // bp@1
  int v2; // edi@1
  void *v3; // esi@1
  unsigned __int8 v4; // cl@3
  int v5; // eax@4
  char v7; // [sp+13h] [bp-5h]@1
  int v8; // [sp+14h] [bp-4h]@1

  v7 = 0;
  v8 = sub_1004E6D0(86, 10);
  memset(&unk_101E7EC8, 0, 0x19B0u);
  v1 = 0;
  v2 = 0;
  v3 = &unk_101E7EC8;
  do
  {
    if ( v7 )
      break;
    sub_10019300(v1, (int)v3);
    v4 = 0;
    while ( 1 )
    {
      v5 = 8 * (v2 + v4);
      if ( byte_101E8238[v5] == a1 || byte_101E8239[v5] == a1 )
        break;
      if ( ++v4 >= 0x10u )
        goto LABEL_9;
    }
    v7 = 1;
LABEL_9:
    v3 = (char *)v3 + 2192;
    ++v1;
    v2 += 274;
  }
  while ( (signed int)v3 < (signed int)&unk_101E9878 );
  sub_1004E6A0(v8, 86);
  return v7;
}

//----- (1001F920) --------------------------------------------------------
char __cdecl sub_1001F920(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_101E6980 != 1379255385;
  v7 = 0;
  v8 = dword_101E6980 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_1004E6D0(86, 10);
      memset((char *)&unk_101E6988 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10019280(a1, (int)&unk_101E6988 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_101E6C60[v6] == a2 || byte_101E6C61[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_1004E6A0(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E6980: using guessed type int dword_101E6980;

//----- (1001F9E0) --------------------------------------------------------
char __cdecl sub_1001F9E0(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_101E6980 != 1379255385;
  v7 = 0;
  v8 = dword_101E6980 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_1004E6D0(86, 10);
      memset((char *)&unk_101E6988 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10019280(a1, (int)&unk_101E6988 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 8 * (340 * (unsigned __int8)a1 + v5);
      if ( byte_101E6C80[v6] == a2 || byte_101E6C81[v6] == a2 )
        break;
      if ( ++v5 >= 5u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_1004E6A0(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E6980: using guessed type int dword_101E6980;

//----- (1001FAA0) --------------------------------------------------------
char __cdecl sub_1001FAA0(char a1, char a2)
{
  unsigned __int8 v2; // bl@1
  unsigned __int8 v4; // [sp+8h] [bp-8h]@1
  char v5; // [sp+Ch] [bp-4h]@2

  v2 = 0;
  v4 = 0;
  while ( 1 )
  {
    sub_10019A40(a1, v4, (int)&v5);
    if ( v5 == a2 )
      break;
    v4 = ++v2;
    if ( v2 >= 2u )
      return 0;
  }
  return 1;
}

//----- (1001FAF0) --------------------------------------------------------
char __cdecl sub_1001FAF0(char a1, unsigned __int8 *a2, _BYTE *a3)
{
  _BYTE *v3; // ebp@1
  char result; // al@1
  void *v5; // esi@1
  unsigned int v6; // edi@1
  unsigned __int8 v7; // bl@4
  char v8; // [sp+13h] [bp-1h]@1

  v3 = a3;
  result = 0;
  v8 = 0;
  *a3 = 49;
  v5 = &unk_1009CBD4;
  v6 = 0;
  do
  {
    if ( result )
      break;
    if ( *((_BYTE *)v5 + 1) == a1 )
    {
      v7 = 0;
      LOBYTE(a3) = 0;
      while ( !sub_1001F920((int)a3, *(_BYTE *)v5) )
      {
        LOBYTE(a3) = ++v7;
        if ( v7 >= 2u )
          goto LABEL_9;
      }
      *a2 = v7;
      v8 = 1;
      *v3 = *(_BYTE *)v5;
LABEL_9:
      result = v8;
    }
    v6 += 2;
    v5 = (char *)v5 + 2;
  }
  while ( v6 < 0x18 );
  return result;
}

//----- (1001FB70) --------------------------------------------------------
char __cdecl sub_1001FB70(char a1, char a2)
{
  unsigned __int8 v2; // bl@1
  unsigned __int8 v4; // [sp+8h] [bp-8h]@1
  char v5; // [sp+Ch] [bp-4h]@2

  v2 = 0;
  v4 = 0;
  while ( 1 )
  {
    sub_10019A40(a1, v4, (int)&v5);
    if ( v5 == a2 )
      break;
    v4 = ++v2;
    if ( v2 >= 2u )
      return 2;
  }
  return v2;
}

//----- (1001FBC0) --------------------------------------------------------
char __cdecl sub_1001FBC0(char a1, unsigned __int8 *a2, _BYTE *a3)
{
  _BYTE *v3; // ebp@1
  char result; // al@1
  void *v5; // esi@1
  unsigned int v6; // edi@1
  unsigned __int8 v7; // bl@4
  char v8; // [sp+13h] [bp-1h]@1

  v3 = a3;
  result = 0;
  v8 = 0;
  *a3 = 49;
  v5 = &unk_1009CBA4;
  v6 = 0;
  do
  {
    if ( result )
      break;
    if ( *((_BYTE *)v5 + 1) == a1 )
    {
      v7 = 0;
      LOBYTE(a3) = 0;
      while ( !sub_1001F920((int)a3, *(_BYTE *)v5) )
      {
        LOBYTE(a3) = ++v7;
        if ( v7 >= 2u )
          goto LABEL_9;
      }
      *a2 = v7;
      v8 = 1;
      *v3 = *(_BYTE *)v5;
LABEL_9:
      result = v8;
    }
    v6 += 2;
    v5 = (char *)v5 + 2;
  }
  while ( v6 < 8 );
  return result;
}

//----- (1001FC40) --------------------------------------------------------
char __cdecl sub_1001FC40(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1001F920(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (1001FC70) --------------------------------------------------------
char __cdecl sub_1001FC70(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1001F9E0(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (1001FCA0) --------------------------------------------------------
char __cdecl sub_1001FCA0(char a1, unsigned __int8 *a2, _BYTE *a3)
{
  _BYTE *v3; // ebp@1
  char result; // al@1
  void *v5; // esi@1
  unsigned int v6; // edi@1
  unsigned __int8 v7; // bl@4
  char v8; // [sp+13h] [bp-1h]@1

  v3 = a3;
  result = 0;
  v8 = 0;
  *a3 = 49;
  v5 = &unk_1009CBAC;
  v6 = 0;
  do
  {
    if ( result )
      break;
    if ( *((_BYTE *)v5 + 1) == a1 )
    {
      v7 = 0;
      LOBYTE(a3) = 0;
      while ( !sub_1001F920((int)a3, *(_BYTE *)v5) )
      {
        LOBYTE(a3) = ++v7;
        if ( v7 >= 2u )
          goto LABEL_9;
      }
      *a2 = v7;
      v8 = 1;
      *v3 = *(_BYTE *)v5;
LABEL_9:
      result = v8;
    }
    v6 += 2;
    v5 = (char *)v5 + 2;
  }
  while ( v6 < 8 );
  return result;
}

//----- (1001FD20) --------------------------------------------------------
char __cdecl sub_1001FD20(char a1)
{
  char result; // al@1
  unsigned __int8 v2; // bl@1
  char v3; // [sp+8h] [bp-4h]@1

  result = 0;
  v2 = 0;
  v3 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1001FAA0(v3, a1);
    v3 = ++v2;
  }
  while ( v2 < 3u );
  return result;
}

//----- (1001FD60) --------------------------------------------------------
char __cdecl sub_1001FD60(char a1, _BYTE *a2)
{
  int v2; // esi@1

  *a2 = 19;
  v2 = 0;
  while ( a1 != 3 && a1 != byte_1009CBB5[2 * v2] || !sub_1001FD20(byte_1009CBB4[2 * v2]) )
  {
    if ( (unsigned int)++v2 >= 0xF )
      return 0;
  }
  *a2 = byte_1009CBB4[2 * v2];
  return 1;
}

//----- (1001FDB0) --------------------------------------------------------
int *sub_1001FDB0()
{
  int *result; // eax@1

  result = dword_101E9C88;
  do
  {
    *((_BYTE *)result - 4) = 2;
    *result = 0;
    result[1] = 1036;
    result[2] = (int)(result - 260);
    result += 522;
  }
  while ( (signed int)result < (signed int)&unk_101EACD8 );
  return result;
}
// 101E9C88: using guessed type int dword_101E9C88[];

//----- (1001FDF0) --------------------------------------------------------
char __cdecl sub_1001FDF0(char a1, int a2, _DWORD *a3)
{
  unsigned __int16 v3; // ax@2
  unsigned __int16 v4; // di@13

  *a3 = 0;
  if ( !*(_BYTE *)a2 )
  {
    LOBYTE(v3) = a1;
    if ( a1 == 16 )
    {
      *(_BYTE *)a2 = 1;
      goto LABEL_12;
    }
    *(_BYTE *)(*(_DWORD *)(a2 + 12) + *(_DWORD *)(a2 + 4)) = a1;
LABEL_11:
    ++*(_DWORD *)(a2 + 4);
LABEL_12:
    if ( *a3 != 2 )
      return v3;
    goto LABEL_13;
  }
  LOBYTE(v3) = *(_BYTE *)a2 - 1;
  if ( *(_BYTE *)a2 != 1 )
  {
    if ( a1 != 16 )
      return v3;
    *(_BYTE *)a2 = 1;
    goto LABEL_12;
  }
  LOBYTE(v3) = a1;
  if ( a1 != 3 )
  {
    *(_BYTE *)(*(_DWORD *)(a2 + 12) + *(_DWORD *)(a2 + 4)) = a1;
    *(_BYTE *)a2 = 0;
    goto LABEL_11;
  }
  *a3 = 2;
LABEL_13:
  v4 = *(_BYTE *)(*(_DWORD *)(a2 + 12) + 2) + (*(_BYTE *)(*(_DWORD *)(a2 + 12) + 3) << 8);
  v3 = sub_1004E220(*(_BYTE **)(a2 + 12), *(_DWORD *)(a2 + 4), 0xFFFFu, 2);
  if ( v3 || *(_DWORD *)(a2 + 4) != v4 + 6 )
    *a3 = 3;
  return v3;
}

//----- (1001FEA0) --------------------------------------------------------
int __usercall sub_1001FEA0@<eax>(_BYTE *a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>)
{
  _BYTE *v3; // esi@1
  int i; // edi@1

  v3 = a1;
  for ( i = (unsigned __int16)a2; (_WORD)a2; ++v3 )
  {
    if ( *v3 == 16 )
    {
      *a3++ = 16;
      ++i;
    }
    *a3 = *v3;
    a2 += 0xFFFF;
    ++a3;
  }
  return i;
}

//----- (1001FEE0) --------------------------------------------------------
signed int __cdecl sub_1001FEE0(int a1, int a2, _BYTE *a3, int a4)
{
  unsigned __int16 v4; // ax@1
  int v5; // ebx@1
  __int16 v6; // ax@1
  int v7; // esi@1
  int v8; // eax@1
  int v9; // edi@1
  unsigned __int16 v10; // ax@1
  unsigned __int16 v11; // ax@1
  int v12; // edi@1

  v4 = __ROL2__(a2, 8);
  a2 = v4;
  sub_1004E560(94, 60000);
  v5 = a1;
  v6 = a2;
  v7 = 2088 * (unsigned __int8)a1;
  byte_101E9C94[v7] = 16;
  byte_101E9C95[v7] = v6;
  byte_101E9C96[v7] = HIBYTE(v6);
  v8 = sub_1001FEA0(&a4, 2, &byte_101E9C97[v7]);
  v9 = sub_1001FEA0(a3, a4, &byte_101E9C94[v7 + 3] + v8) + v8 + 3;
  v10 = sub_1004E220(&a2, 2, 0xFFFFu, 2);
  v11 = sub_1004E220(&a4, 2, v10, 2);
  a1 = sub_1004E220(a3, (unsigned __int16)a4, v11, 2);
  v12 = sub_1001FEA0(&a1, 2, &byte_101E9C94[v7] + v9) + v9;
  *(&byte_101E9C94[v7] + v12++) = 16;
  *(&byte_101E9C94[v7] + v12) = 3;
  j_HWM_pvg_put_uart(v5, &byte_101E9C94[v7], v12 + 1);
  sub_1004E540(94);
  return 1;
}
// 1004ECF0: using guessed type int __cdecl j_HWM_pvg_put_uart(_DWORD, _DWORD, _DWORD);

//----- (10020000) --------------------------------------------------------
bool __cdecl sub_10020000(int a1, char *a2)
{
  unsigned int v2; // ebp@2
  int v3; // ebx@3
  bool result; // al@5
  unsigned __int16 v5; // dx@6
  int v6; // [sp+Ch] [bp-Ch]@1
  int v7; // [sp+10h] [bp-8h]@3
  int v8; // [sp+14h] [bp-4h]@6

  if ( j_HWM_pvg_get_uart(a1, &v6, 1) )
  {
    v2 = 2088 * (unsigned __int8)a1;
    while ( 1 )
    {
      sub_1001FDF0(v6, (int)&byte_101E9C84[v2], &v7);
      v3 = v7;
      if ( v7 )
        break;
      if ( !j_HWM_pvg_get_uart(a1, &v6, 1) )
        goto LABEL_5;
    }
    HIBYTE(v5) = byte_101E9879[v2];
    LOBYTE(v5) = *((_BYTE *)&unk_101E9878 + v2);
    qmemcpy(a2, (char *)&unk_101E9878 + v2, 0x40Cu);
    v8 = v5;
    if ( v3 == 3 )
      sub_1001FFF0(a1, 5376, &v8, 2);
    byte_101E9C84[v2] = 2;
    dword_101E9C88[v2 / 4] = 0;
    result = v3 == 2;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}
// 1001FFF0: using guessed type _DWORD __cdecl sub_1001FFF0(_DWORD, _DWORD, _DWORD, _DWORD);
// 1004EC90: using guessed type int __cdecl j_HWM_pvg_get_uart(_DWORD, _DWORD, _DWORD);
// 101E9C88: using guessed type int dword_101E9C88[];

//----- (100200D0) --------------------------------------------------------
char __cdecl sub_100200D0(char a1, __int16 a2, char a3, char a4, char a5)
{
  char v5; // bl@1
  int v6; // eax@6
  __int16 v7; // si@7
  unsigned __int8 v9; // [sp+7h] [bp-3Dh]@1
  int v10; // [sp+8h] [bp-3Ch]@1
  __int16 v11[2]; // [sp+Ch] [bp-38h]@1
  char v12[4]; // [sp+10h] [bp-34h]@1
  int v13; // [sp+14h] [bp-30h]@1
  char v14[4]; // [sp+18h] [bp-2Ch]@1
  int v15; // [sp+1Ch] [bp-28h]@1
  int v16; // [sp+20h] [bp-24h]@1
  int v17; // [sp+24h] [bp-20h]@1
  int v18; // [sp+28h] [bp-1Ch]@1
  int v19; // [sp+2Ch] [bp-18h]@1
  char v20; // [sp+30h] [bp-14h]@15

  v10 = 0;
  *(_DWORD *)v11 = 0;
  *(_DWORD *)v12 = 0;
  v13 = 0;
  v14[0] = sub_1001DF30(a1);
  v9 = sub_1001DC80(&a1, 1u, (int)&unk_1009DB30, 4, 16, 16);
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  sub_1001DFB0(v14[0], &v15);
  v5 = a4;
  if ( !(BYTE2(v15) & 1) && !(a4 & 2) && word_101EA8C8 != -256 )
  {
    word_101EA8C8 = -256;
    sub_1001BF20(v12[2]);
  }
  if ( a5 )
  {
    LOWORD(v10) = -32767;
    v12[3] = 1;
    sub_1004E5C0(7, (int)&v10, 20, 1);
    word_101EA8C8 = -256;
    LOBYTE(v6) = sub_1001BF20(v12[2]);
  }
  else
  {
    v7 = a2;
    if ( a2 & 0x2000 )
    {
      v11[0] = a2 & 0x2000;
      *(_WORD *)v12 = a2 & 0xDFFF;
    }
    else
    {
      v11[0] = a2;
      *(_WORD *)v12 = a2;
    }
    LOBYTE(v11[1]) = a3;
    LOWORD(v10) = (a3 != 0) - 0x7FFF;
    v12[2] = sub_1001DF60(a1);
    HIBYTE(v11[1]) = v5 & 1;
    if ( v5 & 2 )
    {
      LOBYTE(v6) = word_101EA8C8;
      if ( v7 != word_101EA8C8 && word_101EA8C8 != -1 )
      {
        if ( word_101EA8C8 == -256 )
        {
          if ( sub_1003D6D0(v11[0], *(__int16 *)v12, v12[2], &v20) )
            word_101EA8C8 = v7;
        }
        else
        {
          word_101EA8C8 = -1;
        }
        LOBYTE(v6) = sub_1001C0A0(word_101EA8C8 == -1, &v20, v12[2]);
      }
    }
    else
    {
      v6 = sub_1001DC80((_DWORD *)v11, 2u, (int)&unk_1009DB70, 4, 101, 101);
      if ( v6 != 101 && (unsigned __int16)word_1009DB32[2 * v9] & (unsigned __int16)word_1009DB72[2 * v6] )
      {
        if ( v11[0] == 47
          || v11[0] == 48
          || v11[0] == 49
          || v11[0] == 50
          || v11[0] == 51
          || v11[0] == 52
          || v11[0] == 53
          || v11[0] == 46 )
        {
          sub_1001A100(SHIBYTE(v11[1]));
        }
        LOBYTE(v6) = sub_1004E5C0(7, (int)&v10, 20, 1);
      }
    }
  }
  return v6;
}
// 1009DB32: using guessed type __int16 word_1009DB32[];
// 1009DB72: using guessed type __int16 word_1009DB72[];
// 101EA8C8: using guessed type __int16 word_101EA8C8;

//----- (10020350) --------------------------------------------------------
char __cdecl sub_10020350(char a1, void *a2)
{
  int v2; // eax@2
  char result; // al@11
  char *v4; // eax@12
  signed int v5; // ecx@12

  switch ( a1 )
  {
    case 0:
      v2 = 247;
      break;
    case 2:
      v2 = 248;
      break;
    case 3:
      v2 = 1732;
      break;
    case 4:
      v2 = 1733;
      break;
    case 5:
      v2 = 2279;
      break;
    case 6:
      v2 = 2280;
      break;
    default:
      v2 = 246;
      break;
  }
  if ( !sub_10010C50(1, v2, a2) || sub_100222A0((int)a2) )
  {
    memset(a2, 0, 0xCCCu);
    v4 = (char *)a2 + 26;
    v5 = 14;
    do
    {
      *v4 = 15;
      v4 += 232;
      --v5;
    }
    while ( v5 );
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10020400) --------------------------------------------------------
char __cdecl sub_10020400(char a1)
{
  bool v1; // zf@1
  char result; // al@1
  char v3; // [sp+4h] [bp-CD0h]@1
  char v4; // [sp+10h] [bp-CC4h]@1

  memset(&v3, 0, 0xCCCu);
  v1 = sub_10020350(a1, &v3) == 0;
  result = v4;
  if ( v1 )
    result = 0;
  return result;
}

//----- (10020460) --------------------------------------------------------
char __cdecl sub_10020460(char a1)
{
  bool v1; // zf@1
  char result; // al@1
  char v3; // [sp+4h] [bp-CD0h]@1
  char v4; // [sp+11h] [bp-CC3h]@1

  memset(&v3, 0, 0xCCCu);
  v1 = sub_10020350(a1, &v3) == 0;
  result = v4;
  if ( v1 )
    result = 3;
  return result;
}

//----- (100204C0) --------------------------------------------------------
char *__cdecl sub_100204C0(char *a1)
{
  char *v1; // esi@1
  signed int v2; // edi@1
  char *result; // eax@2
  char v4; // [sp+Ch] [bp-5BCh]@1
  char v5; // [sp+1Ch] [bp-5ACh]@1
  char v6[720]; // [sp+24h] [bp-5A4h]@2
  char v7[16]; // [sp+2F4h] [bp-2D4h]@1
  char v8[704]; // [sp+304h] [bp-2C4h]@2

  sub_1004E7C0(6120, (int)&v4, 744);
  sub_1004E7C0(6466, (int)v7, 720);
  strncpy(a1, &v4, 0x10u);
  strncpy(a1 + 16, &v5, 8u);
  v1 = a1 + 40;
  v2 = 0;
  do
  {
    strncpy(v1 - 16, &v6[v2], 0x10u);
    strncpy(v1, &v1[&v4 - a1], 8u);
    strncpy(v1 + 704, &v7[v2], 0x10u);
    result = strncpy(v1 + 720, &v8[v2], 8u);
    v2 += 24;
    v1 += 24;
  }
  while ( v2 < 720 );
  return result;
}
// 100204C0: using guessed type char var_2D4[16];
// 100204C0: using guessed type char var_5A4[720];
// 100204C0: using guessed type char var_2C4[704];

//----- (100205B0) --------------------------------------------------------
char __cdecl sub_100205B0(int a1, int a2, int *a3)
{
  int v3; // edx@4
  int v4; // esi@4
  char result; // al@4
  unsigned __int8 v6; // cl@6

  if ( a1 && a2 > 0 && a3 )
  {
    v3 = 0;
    v4 = 0;
    result = 1;
    if ( a2 <= 0 )
    {
LABEL_18:
      *a3 = v3;
    }
    else
    {
      while ( result )
      {
        v6 = *(_BYTE *)(v4 + a1);
        if ( v6 < 0x30u || v6 > 0x39u )
        {
          if ( v6 < 0x41u || v6 > 0x46u )
          {
            if ( v6 < 0x61u || v6 > 0x66u )
              result = 0;
            else
              v3 = 16 * v3 + v6 - 87;
          }
          else
          {
            v3 = 16 * v3 + v6 - 55;
          }
        }
        else
        {
          v3 = 16 * v3 + v6 - 48;
        }
        if ( ++v4 >= a2 )
        {
          if ( !result )
            return result;
          goto LABEL_18;
        }
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10020640) --------------------------------------------------------
int __cdecl sub_10020640(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (10020690) --------------------------------------------------------
signed int __cdecl sub_10020690(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebp@1
  _BYTE *v4; // ebx@2
  _BYTE *v5; // edi@2
  int v6; // esi@3
  int v7; // eax@3
  signed int result; // eax@7

  v3 = a3;
  if ( a3 <= 0 )
  {
LABEL_7:
    result = -2;
  }
  else
  {
    v4 = a2;
    v5 = a1;
    while ( 1 )
    {
      v6 = tolower(*v5++);
      v7 = tolower(*v4++);
      if ( v6 > v7 )
        return 1;
      if ( v6 < v7 )
        return -1;
      if ( !v6 )
        break;
      if ( --v3 <= 0 )
        goto LABEL_7;
    }
    result = 0;
  }
  return result;
}

//----- (10020700) --------------------------------------------------------
int __cdecl sub_10020700(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (10020730) --------------------------------------------------------
int __cdecl sub_10020730(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10020770) --------------------------------------------------------
int sub_10020770(char *a1, size_t a2, char *a3, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, a3);
  result = sub_10020730(a1, a2, a3, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (100207A0) --------------------------------------------------------
int __cdecl sub_100207A0(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_10020640((int)&a1[v3], a2, a3 - v3);
}

//----- (100207E0) --------------------------------------------------------
int __cdecl sub_100207E0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 0xDu, 0xDu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10020810) --------------------------------------------------------
int __cdecl sub_10020810(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 8u, 8u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10020840) --------------------------------------------------------
int __cdecl sub_10020840(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 9u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10020870) --------------------------------------------------------
int __cdecl sub_10020870(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 8u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100208A0) --------------------------------------------------------
int __cdecl sub_100208A0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 0xBu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100208D0) --------------------------------------------------------
int __cdecl sub_100208D0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 6u, 6u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10020900) --------------------------------------------------------
int __cdecl sub_10020900(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 7u, 7u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10020930) --------------------------------------------------------
int __cdecl sub_10020930(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 0xFu, 0xFu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10020960) --------------------------------------------------------
int __cdecl sub_10020960(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 0xEu, 0xEu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10020990) --------------------------------------------------------
int __cdecl sub_10020990(unsigned __int8 *a1)
{
  return sub_1003D220(a1, 0, 3u, 3u, 0);
}

//----- (100209B0) --------------------------------------------------------
int __cdecl sub_100209B0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 0x13u, 0x13u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100209E0) --------------------------------------------------------
int __cdecl sub_100209E0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 2u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10020A10) --------------------------------------------------------
int __cdecl sub_10020A10(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 3u, 3u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10020A40) --------------------------------------------------------
int __cdecl sub_10020A40(int a1)
{
  signed int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  do
  {
    result = sub_1003D220((unsigned __int8 *)(v1 + a1), 0, 4u, 0, 0);
    if ( result )
      break;
    ++v1;
  }
  while ( v1 < 4 );
  return result;
}

//----- (10020A70) --------------------------------------------------------
unsigned int __cdecl sub_10020A70(char *a1)
{
  return sub_1003D0B0(a1, -100, 100, 0, 0);
}

//----- (10020A90) --------------------------------------------------------
int __cdecl sub_10020A90(unsigned __int8 *a1)
{
  return sub_1003D220(a1, 0, 2u, 0, 0);
}

//----- (10020AB0) --------------------------------------------------------
int __cdecl sub_10020AB0(_BYTE *a1)
{
  return sub_1003D310(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (10020AD0) --------------------------------------------------------
int __cdecl sub_10020AD0(unsigned __int8 *a1)
{
  return sub_1003D220(a1, 0, 1u, 1u, 0);
}

//----- (10020AF0) --------------------------------------------------------
int __cdecl sub_10020AF0(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D270(a1, 0, 0x31Cu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10020B20) --------------------------------------------------------
int __cdecl sub_10020B20(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D270(a1, 0, 0x147u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10020B50) --------------------------------------------------------
int __cdecl sub_10020B50(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 3u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10020B80) --------------------------------------------------------
signed int __cdecl sub_10020B80(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1003D270(a1, 0, 0xFFFFu, 180, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10020BB0) --------------------------------------------------------
int __cdecl sub_10020BB0(int a1, int a2)
{
  int result; // eax@1

  result = sub_1003CFC0(a1, 0.0, 0.01567, COERCE_INT(0.0), a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10020BF0) --------------------------------------------------------
int __cdecl sub_10020BF0(int a1)
{
  signed int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  do
  {
    result = sub_1003D220((unsigned __int8 *)(v1 + a1), 0, 4u, 0, 0);
    if ( result )
      break;
    ++v1;
  }
  while ( v1 < 23 );
  return result;
}

//----- (10020C20) --------------------------------------------------------
unsigned int __cdecl sub_10020C20(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_1003CE20((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_1003D220((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_1003CE20((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D0B0((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D220((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D220((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D0B0((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10020F50) --------------------------------------------------------
unsigned int __cdecl sub_10020F50(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_1003CE20((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D0B0((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D0B0((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D0B0((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D0B0((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D0B0((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D0B0((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D0B0((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D0B0((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D0B0((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D0B0((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D0B0((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D0B0((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D0B0((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (100213A0) --------------------------------------------------------
int __cdecl sub_100213A0(int a1)
{
  signed int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  do
  {
    result = sub_1003D220((unsigned __int8 *)(v1 + a1), 0, 4u, 0, 0);
    if ( result )
      break;
    ++v1;
  }
  while ( v1 < 56 );
  return result;
}

//----- (100213D0) --------------------------------------------------------
unsigned int __cdecl sub_100213D0(_BYTE *a1)
{
  return sub_1003D100(a1, -1, 5, -1, 0);
}

//----- (100213F0) --------------------------------------------------------
int __cdecl sub_100213F0(unsigned __int8 *a1)
{
  return sub_1003D220(a1, 0, 5u, 0, 0);
}

//----- (10021410) --------------------------------------------------------
int __cdecl sub_10021410(unsigned __int8 *a1)
{
  return sub_1003D220(a1, 0, 4u, 2u, 0);
}

//----- (10021430) --------------------------------------------------------
int __cdecl sub_10021430(_BYTE *a1)
{
  return sub_1003D310(a1, 0, 2u, 0, 0);
}

//----- (10021450) --------------------------------------------------------
int __cdecl sub_10021450(int a1)
{
  return sub_1003CFC0(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (100214A0) --------------------------------------------------------
int __cdecl sub_100214A0(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_10021450((int)(a1 + 4));
  if ( !result )
    result = sub_10021410(a1);
  return result;
}

//----- (100214C0) --------------------------------------------------------
int __cdecl sub_100214C0(int a1)
{
  int result; // eax@1

  result = sub_100213F0((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_100213F0((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_100213F0((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_10023480((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_1003CE20((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_1003CE20((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_1003CE20((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_1003CE20((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10021550) --------------------------------------------------------
unsigned int __cdecl sub_10021550(int a1)
{
  unsigned int result; // eax@1

  result = sub_100213D0((_BYTE *)a1);
  if ( !result )
    result = sub_100213D0((_BYTE *)(a1 + 4));
  return result;
}

//----- (10021570) --------------------------------------------------------
signed int __cdecl sub_10021570(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_1003CE20((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_1003CE20((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (100215C0) --------------------------------------------------------
unsigned int __cdecl sub_100215C0(int a1)
{
  unsigned int result; // eax@1

  result = sub_100213D0((_BYTE *)a1);
  if ( !result )
  {
    result = sub_100213D0((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_100213D0((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_100213D0((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_1003CE20((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (10021620) --------------------------------------------------------
int __cdecl sub_10021620(_BYTE *a1)
{
  return sub_1003D310(a1, 0, 0x20u, 2u, 0);
}

//----- (10021640) --------------------------------------------------------
unsigned int __cdecl sub_10021640(_BYTE *a1)
{
  return sub_1003D100(a1, -1, 4, -1, 0);
}

//----- (10021660) --------------------------------------------------------
int __cdecl sub_10021660(unsigned __int8 *a1)
{
  return sub_1003D220(a1, 0, 9u, 0, 0);
}

//----- (10021680) --------------------------------------------------------
int __cdecl sub_10021680(_BYTE *a1)
{
  return sub_1003D310(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (100216A0) --------------------------------------------------------
int __cdecl sub_100216A0(_BYTE *a1)
{
  return sub_1003D270(a1, 0, 0xFFFu, 640, 0);
}

//----- (100216C0) --------------------------------------------------------
int __cdecl sub_100216C0(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D270(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10021700) --------------------------------------------------------
int __cdecl sub_10021700(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_10034010((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_100216C0((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100216C0((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033E80((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100216C0((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10021790) --------------------------------------------------------
int __cdecl sub_10021790(int a1)
{
  int result; // eax@1

  result = sub_1003D220((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_1003D220((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (100217C0) --------------------------------------------------------
int __cdecl sub_100217C0(unsigned __int8 *a1)
{
  return sub_1003D220(a1, 0, 3u, 1u, 0);
}

//----- (100217E0) --------------------------------------------------------
unsigned int __cdecl sub_100217E0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1003D100((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_1003D100((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (10021810) --------------------------------------------------------
int __cdecl sub_10021810(int a1)
{
  int result; // eax@1

  result = sub_1003CFC0(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_1003CFC0(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_1003CFC0(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_1003CFC0(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_1003CFC0(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (10021900) --------------------------------------------------------
int __cdecl sub_10021900(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_1003CE20((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_1003D220((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_100217E0(a1 + 36);
        if ( !result )
        {
          result = sub_1003CFC0(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_10021810(a1 + 8);
            if ( !result )
            {
              result = sub_100217E0(a1 + 28);
              if ( !result )
              {
                result = sub_1003D270((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_10020A90((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_10021790(a1 + 57);
                    if ( !result )
                    {
                      result = sub_1003CE20((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_100217C0((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (10021A10) --------------------------------------------------------
int __cdecl sub_10021A10(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 7u, 3u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10021A40) --------------------------------------------------------
int __cdecl sub_10021A40(int a1)
{
  int v1; // edi@1
  signed int v2; // esi@1
  int result; // eax@2

  v1 = a1;
  v2 = 0;
  do
  {
    result = sub_1003CE00(v1);
    if ( result )
      break;
    ++v2;
    v1 += 232;
  }
  while ( v2 < 14 );
  return result;
}

//----- (10021A70) --------------------------------------------------------
unsigned int __cdecl sub_10021A70(void *a1, int a2)
{
  unsigned int result; // eax@1

  result = sub_1003D1C0(a1, 0x14u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10021AA0) --------------------------------------------------------
int __cdecl sub_10021AA0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 0x1Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10021AD0) --------------------------------------------------------
int __cdecl sub_10021AD0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 0x64u, 0x2Au, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10021B00) --------------------------------------------------------
signed int __cdecl sub_10021B00(int a1, int a2)
{
  signed int v2; // ebx@1
  signed int result; // eax@9

  v2 = 0;
  if ( sub_10033CF0((unsigned __int8 *)(a1 + 15), a2) == 1 )
    v2 = 1;
  if ( sub_10033CF0((unsigned __int8 *)(a1 + 34), a2) == 1 )
    v2 = 1;
  if ( sub_10033CF0((unsigned __int8 *)(a1 + 38), a2) == 1 )
    v2 = 1;
  if ( sub_10033CF0((unsigned __int8 *)(a1 + 36), a2) == 1 )
    v2 = 1;
  result = sub_1003CE20((_BYTE *)(a1 + 33), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10020810((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100207E0((unsigned __int8 *)(a1 + 48), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10020870((unsigned __int8 *)(a1 + 46), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100207E0((unsigned __int8 *)(a1 + 47), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033A70((unsigned __int8 *)(a1 + 45), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10020840((unsigned __int8 *)(a1 + 44), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100207E0((unsigned __int8 *)(a1 + 28), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10020B50((unsigned __int8 *)(a1 + 51), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100208A0((unsigned __int8 *)(a1 + 31), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_100235F0((_BYTE *)(a1 + 20), a2) == 1 )
    v2 = 1;
  result = sub_10033640((unsigned __int8 *)(a1 + 50), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100207E0((unsigned __int8 *)(a1 + 24), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100208D0((unsigned __int8 *)(a1 + 5), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100207E0((unsigned __int8 *)(a1 + 25), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10020900((unsigned __int8 *)(a1 + 6), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100207E0((unsigned __int8 *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10020930((unsigned __int8 *)(a1 + 3), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0(a1 + 40, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100207E0((unsigned __int8 *)(a1 + 26), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10020810((unsigned __int8 *)(a1 + 9), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100207E0((unsigned __int8 *)(a1 + 8), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10020960((unsigned __int8 *)(a1 + 7), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100208A0((unsigned __int8 *)(a1 + 1), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10020A10((unsigned __int8 *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10020A10((unsigned __int8 *)(a1 + 10), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 37), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100209B0((unsigned __int8 *)(a1 + 11), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100207E0((unsigned __int8 *)(a1 + 12), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)(a1 + 32), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033640((unsigned __int8 *)(a1 + 49), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0(a1 + 16, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10020A10((unsigned __int8 *)(a1 + 35), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10022010) --------------------------------------------------------
int __cdecl sub_10022010(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D310(a1, 0, 0x3FFFFu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10022040) --------------------------------------------------------
signed int __cdecl sub_10022040(_BYTE *a1, int a2)
{
  signed int v2; // ebx@1
  signed int result; // eax@1

  v2 = 0;
  result = sub_1003CE20(a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0((int)(a1 + 4), -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (100220B0) --------------------------------------------------------
int __cdecl sub_100220B0(unsigned __int8 *a1)
{
  return sub_1003D220(a1, 0, 0x64u, 0x64u, 0);
}

//----- (10022110) --------------------------------------------------------
int __cdecl sub_10022110(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_1003CE20((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_100220B0((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (10022120) --------------------------------------------------------
int __cdecl sub_10022120(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 3u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10022150) --------------------------------------------------------
int __cdecl sub_10022150(unsigned __int8 *a1)
{
  return sub_1003D220(a1, 0, 6u, 2u, 0);
}

//----- (10022170) --------------------------------------------------------
int __cdecl sub_10022170(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 6u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100221A0) --------------------------------------------------------
int __cdecl sub_100221A0(unsigned __int8 *a1)
{
  return sub_1003D220(a1, 0, 8u, 0, 0);
}

//----- (100221C0) --------------------------------------------------------
signed int __cdecl sub_100221C0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1003D310(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100221F0) --------------------------------------------------------
int __cdecl sub_100221F0(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_1003D220((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_1003D220((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (100222A0) --------------------------------------------------------
int __cdecl sub_100222A0(int a1)
{
  int result; // eax@1

  result = sub_1003CD10((_BYTE *)(a1 + 3272));
  if ( !result )
  {
    result = sub_1003CD10((_BYTE *)(a1 + 3274));
    if ( !result )
    {
      result = sub_10033FB0((unsigned __int8 *)(a1 + 14));
      if ( !result )
      {
        result = sub_10022290(a1 + 24);
        if ( !result )
        {
          result = sub_10033FB0((unsigned __int8 *)(a1 + 15));
          if ( !result )
          {
            result = sub_10033E60((unsigned __int8 *)(a1 + 12));
            if ( !result )
              result = sub_10033FB0((unsigned __int8 *)(a1 + 13));
          }
        }
      }
    }
  }
  return result;
}
// 10022290: using guessed type _DWORD __cdecl sub_10022290(_DWORD);

//----- (10022320) --------------------------------------------------------
unsigned int __cdecl sub_10022320(int a1)
{
  unsigned int result; // eax@1

  result = sub_10020A70((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_10020A70((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_10020A70((char *)a1);
      if ( !result )
        result = sub_10020A70((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (10022360) --------------------------------------------------------
unsigned int __cdecl sub_10022360(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_10022320(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_10020A90((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_10020AD0((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (100223B0) --------------------------------------------------------
int __cdecl sub_100223B0(int a1)
{
  int result; // eax@1

  result = sub_10020AB0((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_1003D270((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (100223E0) --------------------------------------------------------
int __cdecl sub_100223E0(int a1, int a2)
{
  signed int v2; // ebp@1
  signed int v3; // esi@1
  int result; // eax@2

  v2 = 0;
  v3 = 0;
  do
  {
    result = sub_10021AD0((unsigned __int8 *)(v3 + a1), a2);
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 12 );
  return v2;
}

//----- (10022420) --------------------------------------------------------
signed int __cdecl sub_10022420(int a1)
{
  signed int result; // eax@1
  int v2; // edi@23
  int v3; // [sp+10h] [bp-10h]@5
  int v4; // [sp+10h] [bp-10h]@21

  result = sub_1003CFC0(a1 + 36, -1500.0, 60000.0, COERCE_INT(0.0), 0);
  if ( !result )
  {
    result = sub_1003CFC0(a1 + 40, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_1003CE20((_BYTE *)a1, 0, 0);
      if ( !result )
      {
        result = sub_1003CE20((_BYTE *)(a1 + 1), 0, 0);
        if ( !result )
        {
          result = sub_1003CFC0(a1 + 44, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
          if ( !result )
          {
            result = sub_1003CE70(a1 + 48, -1.0e25, 1.0e25, v3, COERCE_UNSIGNED_INT64(0.0) >> 32, 0);
            if ( !result )
            {
              result = sub_1003CFC0(a1 + 56, 0.0, 2000.0, COERCE_INT(0.0), 0);
              if ( !result )
              {
                result = sub_1003CFC0(a1 + 60, -6.2831855, 6.2831855, COERCE_INT(0.0), 0);
                if ( !result )
                {
                  result = sub_10021390(a1 + 64);
                  if ( !result )
                  {
                    result = sub_1003CFC0(a1 + 84, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
                    if ( !result )
                    {
                      result = sub_1003CFC0(a1 + 88, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
                      if ( !result )
                      {
                        result = sub_1003CFC0(a1 + 92, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
                        if ( !result )
                        {
                          result = sub_1003D270((_BYTE *)(a1 + 32), 0, 8u, 0, 0);
                          if ( !result )
                          {
                            result = sub_1003CFC0(a1 + 96, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
                            if ( !result )
                            {
                              result = sub_1003CFC0(a1 + 100, -1500.0, 60000.0, COERCE_INT(0.0), 0);
                              if ( !result )
                              {
                                result = sub_1003CFC0(a1 + 104, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
                                if ( !result )
                                {
                                  result = sub_10023590(a1 + 108);
                                  if ( !result )
                                  {
                                    result = sub_1003CE20((_BYTE *)(a1 + 2), 0, 0);
                                    if ( !result )
                                    {
                                      result = sub_1003CE20((_BYTE *)(a1 + 3), 0, 0);
                                      if ( !result )
                                      {
                                        result = sub_1003CE20((_BYTE *)(a1 + 4), 0, 0);
                                        if ( !result )
                                        {
                                          result = sub_1003D270((_BYTE *)(a1 + 34), 0, 7u, 0, 0);
                                          if ( !result )
                                          {
                                            result = sub_1003CE70(
                                                       a1 + 76,
                                                       0.0,
                                                       604800.0,
                                                       v4,
                                                       COERCE_UNSIGNED_INT64(0.0) >> 32,
                                                       0);
                                            if ( !result )
                                            {
                                              v2 = 0;
                                              while ( 1 )
                                              {
                                                result = sub_1003CE20((_BYTE *)(a1 + v2 + 20), 0, 0);
                                                if ( result )
                                                  break;
                                                if ( ++v2 >= 12 )
                                                {
                                                  result = sub_10023590(a1 + 124);
                                                  if ( !result )
                                                  {
                                                    result = sub_1003CFC0(
                                                               a1 + 152,
                                                               -9.9999996e24,
                                                               9.9999996e24,
                                                               COERCE_INT(0.0),
                                                               0);
                                                    if ( !result )
                                                    {
                                                      result = sub_10021390(a1 + 140);
                                                      if ( !result )
                                                        result = sub_1003CE20((_BYTE *)(a1 + 5), 0, 0);
                                                    }
                                                  }
                                                  return result;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 10021390: using guessed type _DWORD __cdecl sub_10021390(_DWORD);

//----- (100227F0) --------------------------------------------------------
unsigned int __cdecl sub_100227F0(void *a1, int a2)
{
  signed int v2; // esi@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_1003D1C0(a1, 0x3Cu, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_10033EF0((_BYTE *)a1 + 60, a2) == 1 )
    v2 = 1;
  return v2;
}

//----- (10022830) --------------------------------------------------------
int __cdecl sub_10022830(int a1)
{
  int result; // eax@1

  result = sub_10021430((_BYTE *)a1);
  if ( !result )
    result = sub_10021680((_BYTE *)(a1 + 4));
  return result;
}

//----- (10022860) --------------------------------------------------------
unsigned int __cdecl sub_10022860(int a1)
{
  unsigned int result; // eax@1

  result = sub_100213D0((_BYTE *)a1);
  if ( !result )
  {
    result = sub_100213D0((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_10021640((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (10022890) --------------------------------------------------------
unsigned int __cdecl sub_10022890(int a1)
{
  unsigned int result; // eax@1

  result = sub_100213D0((_BYTE *)a1);
  if ( !result )
    result = sub_10021660((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (100228B0) --------------------------------------------------------
unsigned int __cdecl sub_100228B0(int a1)
{
  unsigned int result; // eax@1

  result = sub_100213D0((_BYTE *)a1);
  if ( !result )
  {
    result = sub_1003D220((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_10021640((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (100228F0) --------------------------------------------------------
void __cdecl __noreturn sub_100228F0(int a1)
{
  exit(a1 + 4);
}

//----- (10022A60) --------------------------------------------------------
signed int __cdecl sub_10022A60(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_10033CF0((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_10033EF0((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_10033CF0((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (10022AB0) --------------------------------------------------------
unsigned int __cdecl sub_10022AB0(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_1003CE20((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D1C0((void *)(a1 + 4), 8u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10021A10((unsigned __int8 *)(a1 + 1), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10022B20) --------------------------------------------------------
int __cdecl sub_10022B20(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_10022010((_BYTE *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10022040((_BYTE *)(a1 + 4), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10022B70) --------------------------------------------------------
int __cdecl sub_10022B70(int a1)
{
  int result; // eax@1

  result = sub_1003D270((_BYTE *)(a1 + 12), 0, 0x1E61u, 1200, 0);
  if ( !result )
  {
    result = sub_10022150((unsigned __int8 *)a1);
    if ( !result )
    {
      result = sub_100221A0((unsigned __int8 *)(a1 + 11));
      if ( !result )
      {
        result = sub_1003CE20((_BYTE *)(a1 + 1), 0, 0);
        if ( !result )
          result = sub_1003D270((_BYTE *)(a1 + 14), 0, 0x1E61u, 1200, 0);
      }
    }
  }
  return result;
}

//----- (10022BE0) --------------------------------------------------------
int __cdecl sub_10022BE0(_BYTE *a1, int a2)
{
  return sub_1003D310(a1, 0, 0x1FEu, 0, a2);
}

//----- (10022C00) --------------------------------------------------------
int __usercall sub_10022C00@<eax>(unsigned __int8 *a1@<eax>, int a2@<edi>)
{
  unsigned __int8 *v2; // esi@1
  signed int v3; // ebx@1
  int result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  result = sub_100209E0(a1, v5);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( *v2 == 1 )
    result = sub_10022B20((int)(v2 + 4), a2);
  else
    result = sub_10021B00((int)(v2 + 4), a2);
  if ( result != 1 && !result )
    result = v3;
  return result;
}

//----- (10022C50) --------------------------------------------------------
signed int __usercall sub_10022C50@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_10022A60(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_1003D220((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_1003CE20((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_10020F50(v2 + 5, a2);
    else
      result = sub_10020C20(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_100221C0((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (10022D20) --------------------------------------------------------
int __usercall sub_10022D20@<eax>(unsigned __int8 *a1@<eax>, int a2@<esi>)
{
  unsigned __int8 *v2; // edi@1
  signed int v3; // ebx@1
  int result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  result = sub_10022120(a1, v5);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10022170(v2 + 1, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20(v2 + 2, 0, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033640(v2 + 3, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D310(v2 + 8, 0, 0x1E61u, 0x4B0u, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D310(v2 + 12, 0, 0x1E61u, 0x4B0u, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10022BE0(v2 + 4, a2);
  if ( result != 1 && !result )
    result = v3;
  return result;
}

//----- (10022E10) --------------------------------------------------------
int __cdecl sub_10022E10(unsigned __int8 *a1)
{
  return sub_10022C00(a1, 0);
}

//----- (10022E20) --------------------------------------------------------
signed int __cdecl sub_10022E20(_BYTE *a1, int a2)
{
  signed int v2; // ebx@1
  signed int result; // eax@1

  v2 = 0;
  result = sub_1003CE20(a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100223E0((int)(a1 + 4), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10022E70) --------------------------------------------------------
unsigned int __cdecl sub_10022E70(int a1, int a2)
{
  signed int v2; // edi@1
  unsigned int result; // eax@1
  int v4; // esi@4
  signed int v5; // [sp+Ch] [bp-4h]@1

  v2 = 0;
  v5 = 0;
  result = sub_10021A70((void *)(a1 + 44), a2);
  if ( result == 1 )
  {
    v5 = 1;
  }
  else if ( result )
  {
    return result;
  }
  v4 = a1;
  do
  {
    result = sub_10022AB0(v4, a2);
    if ( result == 1 )
    {
      v5 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v2;
    v4 += 12;
  }
  while ( v2 < 2 );
  result = sub_10021A70((void *)(a1 + 24), a2);
  if ( result == 1 )
  {
    v5 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10021A70((void *)(a1 + 64), a2);
  if ( result == 1 )
  {
    result = 1;
  }
  else if ( !result )
  {
    result = v5;
  }
  return result;
}

//----- (10022F10) --------------------------------------------------------
int __cdecl sub_10022F10(unsigned __int8 *a1)
{
  return sub_10022D20(a1, 0);
}

//----- (10022F20) --------------------------------------------------------
signed int __cdecl sub_10022F20(int a1)
{
  return sub_10022C50(a1, 0);
}

//----- (10022F30) --------------------------------------------------------
unsigned int __cdecl sub_10022F30(int a1, int a2)
{
  signed int v2; // esi@1
  unsigned int result; // eax@2
  signed int v4; // esi@14
  _BYTE *v5; // esi@19
  signed int v6; // edi@19
  _BYTE *v7; // esi@23
  signed int v8; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v8 = 0;
  do
  {
    result = sub_1003CE20((_BYTE *)(v2 + a1 + 63), 0, a2);
    if ( result == 1 )
    {
      v8 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v2;
  }
  while ( v2 < 16 );
  if ( sub_10033CF0((unsigned __int8 *)(a1 + 238), a2) == 1 )
    v8 = 1;
  result = sub_10022E70(a1 + 90, a2);
  if ( result == 1 )
  {
    v8 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)a1, 1, a2);
  if ( result == 1 )
  {
    v8 = 1;
  }
  else if ( result )
  {
    return result;
  }
  v4 = 0;
  do
  {
    result = sub_10021AA0((unsigned __int8 *)(v4 + a1 + 88), a2);
    if ( result == 1 )
    {
      v8 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v4;
  }
  while ( v4 < 2 );
  v5 = (_BYTE *)(a1 + 80);
  v6 = 4;
  do
  {
    if ( sub_10020B80(v5, a2) == 1 )
      v8 = 1;
    v5 += 2;
    --v6;
  }
  while ( v6 );
  v7 = (_BYTE *)(a1 + 174);
  do
  {
    result = sub_10022E20(v7, a2);
    if ( result == 1 )
    {
      v8 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v6;
    v7 += 16;
  }
  while ( v6 < 4 );
  return v8;
}

//----- (10023050) --------------------------------------------------------
char __cdecl sub_10023050(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (10023090) --------------------------------------------------------
char __cdecl sub_10023090(char a1)
{
  char result; // al@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 7;
    }
    else
    {
      sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 648, 0, 0);
      result = 67;
    }
  }
  else
  {
    result = 6;
  }
  return result;
}

//----- (100230D0) --------------------------------------------------------
signed int __cdecl sub_100230D0(char a1)
{
  signed int result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 512;
    }
    else
    {
      sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 699, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = 256;
  }
  return result;
}

//----- (10023110) --------------------------------------------------------
char __cdecl sub_10023110(char a1)
{
  char result; // al@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 6;
    }
    else
    {
      sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 750, 0, 0);
      result = -80;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10023150) --------------------------------------------------------
char __cdecl sub_10023150(int a1)
{
  char result; // al@3

  if ( a1 == 256 )
  {
    result = 0;
  }
  else if ( a1 == 512 )
  {
    result = 1;
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 800, 0, 0);
    result = 2;
  }
  return result;
}

//----- (10023190) --------------------------------------------------------
char __cdecl sub_10023190(char a1)
{
  return sub_10019890((int)&unk_1009FD10, a1, 0x33u);
}

//----- (100231B0) --------------------------------------------------------
char __cdecl sub_100231B0(char a1)
{
  return sub_10019890((int)&unk_1009FD78, a1, 0x31u);
}

//----- (100231D0) --------------------------------------------------------
char __cdecl sub_100231D0(char a1)
{
  return sub_10019890((int)&unk_1009FDDC, a1, 0x1Du);
}

//----- (100231F0) --------------------------------------------------------
char __cdecl sub_100231F0(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_10023190(a1);
  if ( v2 == -80 )
    result = 67;
  else
    result = sub_100237E0(v2);
  return result;
}

//----- (10023220) --------------------------------------------------------
char __cdecl sub_10023220(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_100231B0(a1);
  if ( v2 == -80 )
    result = 67;
  else
    result = sub_100237E0(v2);
  return result;
}

//----- (10023250) --------------------------------------------------------
char __cdecl sub_10023250(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_100231D0(a1);
  if ( v2 == -80 )
  {
    result = 57;
    if ( a1 != 4 )
      result = 67;
  }
  else
  {
    result = sub_100237E0(v2);
  }
  return result;
}

//----- (10023290) --------------------------------------------------------
int __cdecl sub_10023290(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 1004EEA0: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (10023300) --------------------------------------------------------
bool __cdecl sub_10023300(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_10019900(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_100A0390[(unsigned __int8)v4](v3) )
    {
      sub_10023290((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_10023800(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_1000FF80(2) )
    result = 0;
  else
    result = sub_10010C50(2, v5, a2) == 1 && !sub_10023740(a2);
  return result;
}
// 100A0390: using guessed type int (__cdecl *off_100A0390[3])(char);

//----- (100233C0) --------------------------------------------------------
char __cdecl sub_100233C0(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_10023300(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_100237E0(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (10023480) --------------------------------------------------------
int __cdecl sub_10023480(unsigned __int8 *a1)
{
  return sub_1003D220(a1, 0, 0, 0, 0);
}

//----- (100234A0) --------------------------------------------------------
unsigned int __cdecl sub_100234A0(void *a1)
{
  return sub_1003D1C0(a1, 0x20u, 0);
}

//----- (100234C0) --------------------------------------------------------
unsigned int __cdecl sub_100234C0(void *a1)
{
  return sub_1003D1C0(a1, 0x1Cu, 0);
}

//----- (100234E0) --------------------------------------------------------
unsigned int __cdecl sub_100234E0(void *a1)
{
  return sub_1003D1C0(a1, 0x10u, 0);
}

//----- (10023500) --------------------------------------------------------
unsigned int __cdecl sub_10023500(void *a1)
{
  return sub_1003D1C0(a1, 0xCu, 0);
}

//----- (10023520) --------------------------------------------------------
unsigned int __cdecl sub_10023520(void *a1)
{
  return sub_1003D1C0(a1, 8u, 0);
}

//----- (10023540) --------------------------------------------------------
int __cdecl sub_10023540(int a1)
{
  int result; // eax@1

  result = sub_1003D220((unsigned __int8 *)(a1 + 1), 1u, 0x1Fu, 1u, 0);
  if ( !result )
  {
    result = sub_1003D220((unsigned __int8 *)a1, 1u, 0xCu, 1u, 0);
    if ( !result )
      result = sub_1003D270((_BYTE *)(a1 + 2), 0x7C6u, 0xFFFFu, 1990, 0);
  }
  return result;
}

//----- (10023590) --------------------------------------------------------
int __cdecl sub_10023590(int a1)
{
  int result; // eax@1

  result = sub_1003CE70(
             a1,
             -3.1415926535898,
             3.1415926535898,
             COERCE_UNSIGNED_INT64(0.0),
             COERCE_UNSIGNED_INT64(0.0) >> 32,
             0);
  if ( !result )
    result = sub_1003CE70(
               a1 + 8,
               -6.2831853071796,
               6.2831853071796,
               COERCE_UNSIGNED_INT64(0.0),
               COERCE_UNSIGNED_INT64(0.0) >> 32,
               0);
  return result;
}

//----- (100235F0) --------------------------------------------------------
signed int __cdecl sub_100235F0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1003D100(a1, 2147483648, 0x7FFFFFFF, 0x7FFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10023620) --------------------------------------------------------
int __cdecl sub_10023620(int a1)
{
  int v1; // edi@1
  signed int v2; // esi@1
  int result; // eax@2

  v1 = a1;
  v2 = 0;
  do
  {
    result = sub_1003CFC0(v1, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
    if ( result )
      break;
    ++v2;
    v1 += 4;
  }
  while ( v2 < 3 );
  return result;
}

//----- (10023670) --------------------------------------------------------
int __cdecl sub_10023670(void *a1)
{
  int result; // eax@1

  result = sub_100234A0((char *)a1 + 64);
  if ( !result )
  {
    result = sub_100234A0((char *)a1 + 128);
    if ( !result )
    {
      result = sub_10023520((char *)a1 + 120);
      if ( !result )
      {
        result = sub_100234C0((char *)a1 + 36);
        if ( !result )
        {
          result = sub_10023540((int)a1 + 168);
          if ( !result )
          {
            result = sub_10023540((int)a1 + 160);
            if ( !result )
            {
              result = sub_10023540((int)a1 + 164);
              if ( !result )
              {
                result = sub_100234E0(a1);
                if ( !result )
                {
                  result = sub_10023500((char *)a1 + 96);
                  if ( !result )
                  {
                    result = sub_10023500((char *)a1 + 24);
                    if ( !result )
                      result = sub_10023520((char *)a1 + 16);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10023740) --------------------------------------------------------
unsigned int __cdecl sub_10023740(void *a1)
{
  unsigned int result; // eax@1

  result = sub_100234A0((char *)a1 + 64);
  if ( !result )
  {
    result = sub_100234C0((char *)a1 + 36);
    if ( !result )
    {
      result = sub_100234E0(a1);
      if ( !result )
      {
        result = sub_10023500((char *)a1 + 96);
        if ( !result )
        {
          result = sub_10023500((char *)a1 + 24);
          if ( !result )
            result = sub_10023520((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (100237A0) --------------------------------------------------------
int __cdecl sub_100237A0(char a1)
{
  return sub_1001DC80(&a1, 2u, (int)word_100A03C0, 6, 177, 176);
}
// 100A03C0: using guessed type __int16 word_100A03C0[];

//----- (100237D0) --------------------------------------------------------
signed int __fastcall sub_100237D0(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (100237E0) --------------------------------------------------------
char __cdecl sub_100237E0(unsigned __int8 a1)
{
  return byte_100A03C4[6 * sub_100237D0(a1)];
}

//----- (10023800) --------------------------------------------------------
__int16 __cdecl sub_10023800(unsigned __int8 a1)
{
  return word_100A03C0[3 * sub_100237D0(a1)];
}
// 100A03C0: using guessed type __int16 word_100A03C0[];

//----- (10023820) --------------------------------------------------------
char __cdecl sub_10023820(int a1, void *a2)
{
  int v2; // ecx@3
  char result; // al@4
  int v4; // ecx@5
  int v5; // eax@5
  bool v6; // zf@9

  if ( a1 && a2 )
  {
    v2 = *(_DWORD *)(a1 + 20);
    if ( v2 >= 0 )
    {
      memcpy_0(a2, (const void *)(*(_DWORD *)(a1 + 4) + v2 * *(_DWORD *)(a1 + 12)), *(_DWORD *)(a1 + 12));
      v4 = *(_DWORD *)(a1 + 8);
      v5 = *(_DWORD *)(a1 + 20) + 1;
      if ( v5 < v4 )
      {
        if ( v5 < 0 )
          v5 += v4;
      }
      else
      {
        v5 -= v4;
      }
      v6 = v5 == *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 20) = v5;
      if ( v6 )
        *(_DWORD *)(a1 + 20) = -1;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10023890) --------------------------------------------------------
int __cdecl sub_10023890(int a1)
{
  int result; // eax@2
  int v2; // edx@3
  int v3; // ecx@4

  if ( a1 && (v2 = *(_DWORD *)(a1 + 20), v2 >= 0) )
  {
    v3 = *(_DWORD *)(a1 + 16);
    if ( v3 <= v2 )
      result = v3 + *(_DWORD *)(a1 + 8) - v2;
    else
      result = v3 - v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100238C0) --------------------------------------------------------
char __cdecl sub_100238C0(int a1, void *a2)
{
  int v2; // eax@3
  int v3; // edx@3
  int v4; // ecx@5
  int v5; // eax@5
  int v6; // ecx@12
  int v7; // eax@12
  char result; // al@13

  if ( a1 && a2 )
  {
    v2 = *(_DWORD *)(a1 + 20);
    v3 = *(_DWORD *)(a1 + 16);
    if ( v2 == v3 )
    {
      if ( !(*(_BYTE *)a1 & 1) )
        return 0;
      v4 = *(_DWORD *)(a1 + 8);
      v5 = v2 + 1;
      if ( v5 < v4 )
      {
        if ( v5 < 0 )
          v5 += v4;
      }
      else
      {
        v5 -= v4;
      }
      *(_DWORD *)(a1 + 20) = v5;
    }
    if ( *(_DWORD *)(a1 + 20) < 0 )
      *(_DWORD *)(a1 + 20) = v3;
    memcpy_0((void *)(*(_DWORD *)(a1 + 4) + v3 * *(_DWORD *)(a1 + 12)), a2, *(_DWORD *)(a1 + 12));
    v6 = *(_DWORD *)(a1 + 8);
    v7 = *(_DWORD *)(a1 + 16) + 1;
    if ( v7 < v6 )
    {
      if ( v7 < 0 )
        v7 += v6;
      *(_DWORD *)(a1 + 16) = v7;
      result = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 16) = v7 - v6;
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10023950) --------------------------------------------------------
char __cdecl sub_10023950(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_1001DC80((_DWORD *)a2, 2u, (int)&unk_100A0848, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_100A084C[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_1004E5F0(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_1004E440();
        sub_10020770(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_1001B780("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 100A084C: using guessed type int dword_100A084C[];

//----- (10023A70) --------------------------------------------------------
char __cdecl sub_10023A70(int a1)
{
  return sub_10023950(34, a1);
}

//----- (10023A80) --------------------------------------------------------
char __cdecl sub_10023A80(int a1)
{
  return sub_10023950(28, a1);
}

//----- (10023A90) --------------------------------------------------------
char __cdecl sub_10023A90(int a1)
{
  return sub_10023950(29, a1);
}

//----- (10023AA0) --------------------------------------------------------
char __cdecl sub_10023AA0(int a1)
{
  return sub_10023950(30, a1);
}

//----- (10023AB0) --------------------------------------------------------
char __cdecl sub_10023AB0(int a1)
{
  return sub_10023950(32, a1);
}

//----- (10023AC0) --------------------------------------------------------
char __cdecl sub_10023AC0(int a1)
{
  return sub_10023950(31, a1);
}

//----- (10023AD0) --------------------------------------------------------
int __cdecl sub_10023AD0(int *a1)
{
  int result; // eax@1

  result = sub_1003F930((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_1004E4B0();
    result = sub_1003F770();
  }
  return result;
}

//----- (10023B00) --------------------------------------------------------
char __usercall sub_10023B00@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_1004E560(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_100242C0("%i %i\r\n", 13, v2);
    sub_10030970(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_100A0EC0, (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    v5 = sub_1004E540(*(_DWORD *)(a1 + 4));
    v6 = sub_100242C0("%i %i\r\n", 14, v5);
    sub_10030970(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_100A0EBC, (int)v6);
    result = 1;
  }
  else
  {
    sub_1001B780(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}

//----- (10023BA0) --------------------------------------------------------
int __cdecl sub_10023BA0(const char *a1)
{
  int result; // eax@1

  result = sub_1003DA90();
  if ( a1 )
    result = sub_1003F960(dword_101EA8D0[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 101EA8D0: using guessed type int dword_101EA8D0[];

//----- (10023BE0) --------------------------------------------------------
char __cdecl sub_10023BE0(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_1003F8B0((char *)a1 + 4);
  v1 = sub_10018CF0();
  sub_1003F850((int)v1, 0, 0);
  dword_101EA8D0[sub_1003DA90()] = (int)a1;
  v2 = sub_100407F0((int)sub_10023BA0);
  return sub_10030360(v2);
}
// 101EA8D0: using guessed type int dword_101EA8D0[];

//----- (10023C30) --------------------------------------------------------
signed int __cdecl sub_10023C30(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_1004E4B0();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_1004E640(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_1004E4B0() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_1004E660(&v23);
          }
          while ( sub_1004E4B0() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_1004E490(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_1004E4D0((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_100242C0("The %s task is loaded.", &v24);
            sub_10030970(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_100242C0("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_10030970(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_100242C0("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_10030970(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_100242C0(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_10030970(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_1004E420(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_100242C0("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_10030970(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_100242C0("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_10030970(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_10030970(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_1004E510(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_100407F0((int)sub_10023BA0);
        sub_10030A40((int)v15);
        v16 = sub_10041BC0((int)sub_10023BA0);
        sub_10030A40((int)v16);
        v17 = sub_10041BC0((int)sub_10023BA0);
        sub_10030360(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_100407F0((int)sub_10023BA0);
        sub_10030A40((int)v18);
        v19 = sub_10041BC0((int)sub_10023BA0);
        sub_10030A40((int)v19);
        v20 = sub_100407F0((int)sub_10023BA0);
        sub_10030360(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_10023B00(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (10023FD0) --------------------------------------------------------
char **sub_10023FD0()
{
  return off_100A0EA8;
}
// 100A0EA8: using guessed type char *off_100A0EA8[3];

//----- (10023FE0) --------------------------------------------------------
#error "10023FE5: call analysis failed (funcsize=51)"

//----- (10024010) --------------------------------------------------------
signed int sub_10024010()
{
  signed int result; // eax@1

  result = -15;
  dword_1023683C = -15;
  dword_10236838 = -15;
  return result;
}
// 10236838: using guessed type int dword_10236838;
// 1023683C: using guessed type int dword_1023683C;

//----- (10024020) --------------------------------------------------------
char *__cdecl sub_10024020(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  char *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_10041C70("CFG_ActDir", (int)&byte_100647C9);
      v10 = sub_10041C70("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_10041C70("CFG_ExpDir", (int)&byte_100647C9);
      v10 = sub_10041C70("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_10041C70("CFG_ActDir", (int)&byte_100647C9);
      break;
    case 4:
      v10 = sub_10041C70("CFG_ExpDir", (int)&byte_100647C9);
      break;
    default:
      v10 = &byte_100647C9;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = "/", v14) )
    v15 = &byte_100647C9;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 10024020: using guessed type char var_104[256];

//----- (100241A0) --------------------------------------------------------
int sub_100241A0()
{
  return dword_101EF4D8[sub_1003DA90()];
}
// 101EF4D8: using guessed type int dword_101EF4D8[];

//----- (100241B0) --------------------------------------------------------
const char *__cdecl sub_100241B0(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_100A1E80[a1];
  return result;
}
// 100A1E80: using guessed type char *off_100A1E80[7];

//----- (100241D0) --------------------------------------------------------
int __cdecl sub_100241D0(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_100309B0(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (10024280) --------------------------------------------------------
int __cdecl sub_10024280(int a1)
{
  int result; // eax@1

  result = sub_1003DA90();
  dword_101F15E4[result] = a1;
  return result;
}
// 101F15E4: using guessed type int dword_101F15E4[];

//----- (100242A0) --------------------------------------------------------
int __cdecl sub_100242A0(int a1)
{
  int result; // eax@1

  result = sub_1003DA90();
  dword_101EF4D8[result] = a1;
  return result;
}
// 101EF4D8: using guessed type int dword_101EF4D8[];

//----- (100242C0) --------------------------------------------------------
char *sub_100242C0(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_1003DA90() << 8;
  _vsnprintf(&byte_101EA8E8[v1], 0x100u, a1, va);
  result = &byte_101EA8E8[v1];
  byte_101EA9E6[v1] = 42;
  byte_101EA9E7[v1] = 0;
  return result;
}

//----- (10024300) --------------------------------------------------------
char *__usercall sub_10024300@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_100A1E94[a1 & 1];
  else
    result = off_100A1E8C[a2];
  return result;
}
// 100A1E8C: using guessed type char *off_100A1E8C[4];
// 100A1E94: using guessed type char *off_100A1E94[2];

//----- (10024320) --------------------------------------------------------
char __usercall sub_10024320@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  const char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_1003DA90();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_100241A0() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_101F2BD8[v6];
      v12 = dword_101F2BEC[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_101EF4EC[v6];
      v12 = dword_101F15D0[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 101EF4EC: using guessed type int dword_101EF4EC[];
// 101F15D0: using guessed type int dword_101F15D0[];
// 101F2BD8: using guessed type int dword_101F2BD8[];
// 101F2BEC: using guessed type int dword_101F2BEC[];

//----- (10024500) --------------------------------------------------------
int sub_10024500()
{
  nullsub_1("..\\lib\\utf\\utf_verify.c", "2370", "UTF_NO_BITMAP_CMP was defined. Bitmap comparison not supported");
  return 0;
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);

//----- (10024520) --------------------------------------------------------
int sub_10024520()
{
  return nullsub_1(
           "..\\lib\\utf\\utf_verify.c",
           "2396",
           "UTF_NO_BITMAP_CMP was defined. Bitmap comparison not supported");
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);

//----- (10024540) --------------------------------------------------------
int __cdecl sub_10024540(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_1003DA90();
  dword_101F15D0[result] = a1;
  if ( a2 >= 0 )
  {
    dword_101EF4EC[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_100242C0(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_10030970(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_101EF4EC[result] = 8;
  }
  return result;
}
// 101EF4EC: using guessed type int dword_101EF4EC[];
// 101F15D0: using guessed type int dword_101F15D0[];

//----- (100245A0) --------------------------------------------------------
int __cdecl sub_100245A0(int a1)
{
  return sub_10024540(0, a1);
}

//----- (100245B0) --------------------------------------------------------
int __cdecl sub_100245B0(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_1003DA90();
  dword_101F2BEC[result] = a1;
  if ( a2 >= 0 )
  {
    dword_101F2BD8[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_100242C0(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_10030970(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_101F2BD8[result] = 8;
  }
  return result;
}
// 101F2BD8: using guessed type int dword_101F2BD8[];
// 101F2BEC: using guessed type int dword_101F2BEC[];

//----- (10024610) --------------------------------------------------------
int __cdecl sub_10024610(int a1)
{
  return sub_100245B0(0, a1);
}

//----- (10024620) --------------------------------------------------------
bool __cdecl sub_10024620(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_1003E9F0() )
    v8 = v8 == 0;
  v9 = off_100A1E64[a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_100A1E54[v8 != 0];
  v19 = off_100A1E5C[a1];
  v18 = v10;
  v21 = sub_10024300(0, a6);
  v22 = sub_10024300(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_10041FC0();
  sub_10030880(7, (int)&v14, v11);
  sub_10041FD0(v12);
  return v8;
}
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];

//----- (10024760) --------------------------------------------------------
bool __cdecl sub_10024760(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  unsigned __int8 v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  bool v16; // [sp+1Bh] [bp-5Dh]@2
  char v17; // [sp+1Fh] [bp-59h]@25
  unsigned int v18; // [sp+20h] [bp-58h]@1
  char *v19; // [sp+3Ch] [bp-3Ch]@28
  int v20; // [sp+40h] [bp-38h]@28
  int v21; // [sp+44h] [bp-34h]@28
  int v22; // [sp+48h] [bp-30h]@28
  char *v23; // [sp+4Ch] [bp-2Ch]@28
  char *v24; // [sp+50h] [bp-28h]@28
  const char *v25; // [sp+54h] [bp-24h]@28
  const char *v26; // [sp+58h] [bp-20h]@28
  const char *v27; // [sp+5Ch] [bp-1Ch]@28
  char *v28; // [sp+60h] [bp-18h]@28
  int v29; // [sp+64h] [bp-14h]@29
  char v30; // [sp+68h] [bp-10h]@25

  v8 = sub_1003DA90();
  v18 = 9;
  switch ( a2 )
  {
    case 0:
      v16 = a6 == a7;
      break;
    case 1:
      v16 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 4:
      v16 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_38;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v16 = 1;
      if ( a6 > v10 )
LABEL_38:
        v16 = 0;
      v18 = 10;
      break;
    default:
LABEL_22:
      v16 = 0;
      break;
  }
  if ( sub_1003E9F0() )
    v16 = v16 == 0;
  sub_10024320((int)&v30, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_101EB8D8[v11], 0x400u, &v30, a6);
  byte_101EBCD6[v11] = 42;
  byte_101EBCD7[v11] = 0;
  v17 = sub_10024320((int)&v30, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_101EBCD8[v11], 0x400u, &v30, a7);
  byte_101EC0D6[v11] = 42;
  byte_101EC0D7[v11] = 0;
  if ( v18 <= 9 )
  {
    v12 = &byte_101EC0D8[v11];
    byte_101EC0D8[v11] = 0;
  }
  else
  {
    v17 = sub_10024320((int)&v30, "%c", 3, 0xCu, 0.0);
    v12 = &byte_101EC0D8[v11];
    _snprintf(&byte_101EC0D8[v11], 0x400u, &v30, 0);
    byte_101EC4D6[v11] = 42;
    byte_101EC4D7[v11] = 0;
  }
  v19 = off_100A1E64[a2];
  v21 = a4;
  v22 = a5;
  v20 = a3;
  v25 = "char";
  v26 = &byte_101EB8D8[v11];
  v27 = &byte_101EBCD8[v11];
  v13 = off_100A1E5C[a1];
  v23 = off_100A1E54[v16 != 0];
  v24 = v13;
  v28 = v12;
  if ( a8 )
  {
    v29 = a8;
    v18 = 11;
  }
  v14 = sub_10041FC0();
  sub_10030880(7, (int)&v19, v18);
  if ( v17 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 && !strcmp(v26, v27) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10030970(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10041FD0(v14);
  return v16;
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];

//----- (10024B10) --------------------------------------------------------
bool __cdecl sub_10024B10(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  bool v20; // [sp+27h] [bp-61h]@10
  char v21; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v22; // [sp+2Ch] [bp-5Ch]@8
  char *v23; // [sp+4Ch] [bp-3Ch]@37
  int v24; // [sp+50h] [bp-38h]@37
  int v25; // [sp+54h] [bp-34h]@37
  int v26; // [sp+58h] [bp-30h]@37
  char *v27; // [sp+5Ch] [bp-2Ch]@37
  char *v28; // [sp+60h] [bp-28h]@37
  const char *v29; // [sp+64h] [bp-24h]@37
  const char *v30; // [sp+68h] [bp-20h]@37
  const char *v31; // [sp+6Ch] [bp-1Ch]@37
  char *v32; // [sp+70h] [bp-18h]@37
  int v33; // [sp+74h] [bp-14h]@38
  char v34; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_1003DA90();
  v22 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 1:
      v20 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v20 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_47;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_47:
        v20 = 0;
        v22 = 10;
      }
      else
      {
        v20 = 1;
        v22 = 10;
      }
      break;
    default:
LABEL_18:
      v20 = 0;
      break;
  }
  if ( sub_1003E9F0() )
    v20 = v20 == 0;
  sub_10024320((int)&v34, (char *)&unk_100A2178, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_101EB8D8[v12], 0x400u, &v34);
  byte_101EBCD6[v12] = 42;
  byte_101EBCD7[v12] = 0;
  v21 = sub_10024320((int)&v34, (char *)&unk_100A2178, 3, 0xCu, a7);
  _snprintf(&byte_101EBCD8[v12], 0x400u, &v34, a7);
  byte_101EC0D6[v12] = 42;
  byte_101EC0D7[v12] = 0;
  if ( v22 <= 9 )
  {
    v13 = &byte_101EC0D8[v12];
    byte_101EC0D8[v12] = 0;
  }
  else
  {
    v13 = &byte_101EC0D8[v12];
    v21 = sub_10024320((int)&v34, (char *)&unk_100A2178, 3, 0xCu, v10);
    _snprintf(&byte_101EC0D8[v12], 0x400u, &v34, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_101EC4D6[v12] = 42;
    byte_101EC4D7[v12] = 0;
  }
  v23 = off_100A1E64[a2];
  v26 = a5;
  v25 = a4;
  v24 = a3;
  v29 = "double";
  v30 = &byte_101EB8D8[v12];
  v32 = v13;
  v17 = off_100A1E5C[a1];
  v27 = off_100A1E54[v20 != 0];
  v28 = v17;
  v31 = &byte_101EBCD8[v12];
  if ( a9 )
  {
    v33 = a9;
    v22 = 11;
  }
  v18 = sub_10041FC0();
  sub_10030880(7, (int)&v23, v22);
  if ( v21 && a6 != a7 && fabs(a6 - a7) > v10 && !strcmp(v30, v31) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10030970(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10041FD0(v18);
  return v20;
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];

//----- (10024F60) --------------------------------------------------------
bool __cdecl sub_10024F60(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  bool v25; // [sp+1Bh] [bp-59h]@10
  char v26; // [sp+1Fh] [bp-55h]@35
  unsigned int v27; // [sp+20h] [bp-54h]@8
  float v28; // [sp+24h] [bp-50h]@8
  char *v29; // [sp+38h] [bp-3Ch]@38
  int v30; // [sp+3Ch] [bp-38h]@38
  int v31; // [sp+40h] [bp-34h]@38
  int v32; // [sp+44h] [bp-30h]@38
  char *v33; // [sp+48h] [bp-2Ch]@38
  char *v34; // [sp+4Ch] [bp-28h]@38
  const char *v35; // [sp+50h] [bp-24h]@38
  const char *v36; // [sp+54h] [bp-20h]@38
  const char *v37; // [sp+58h] [bp-1Ch]@38
  char *v38; // [sp+5Ch] [bp-18h]@38
  int v39; // [sp+60h] [bp-14h]@39
  char v40; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v28 = v13;
  v14 = v28;
  v15 = a6;
  v16 = sub_1003DA90();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_48;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_48:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_32:
      v25 = 0;
      break;
  }
  if ( sub_1003E9F0() )
    v25 = v25 == 0;
  sub_10024320((int)&v40, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_101EB8D8[v20], 0x400u, &v40);
  byte_101EBCD6[v20] = 42;
  byte_101EBCD7[v20] = 0;
  v26 = sub_10024320((int)&v40, "%f", 3, 0xCu, a7);
  _snprintf(&byte_101EBCD8[v20], 0x400u, &v40, a7);
  byte_101EC0D6[v20] = 42;
  byte_101EC0D7[v20] = 0;
  if ( v27 <= 9 )
  {
    v21 = &byte_101EC0D8[v20];
    byte_101EC0D8[v20] = 0;
  }
  else
  {
    v21 = &byte_101EC0D8[v20];
    v26 = sub_10024320((int)&v40, "%f", 3, 0xCu, v28);
    _snprintf(&byte_101EC0D8[v20], 0x400u, &v40, v28);
    byte_101EC4D6[v20] = 42;
    byte_101EC4D7[v20] = 0;
  }
  v29 = off_100A1E64[a2];
  v32 = a5;
  v31 = a4;
  v30 = a3;
  v35 = "float";
  v36 = &byte_101EB8D8[v20];
  v37 = &byte_101EBCD8[v20];
  v38 = v21;
  v22 = off_100A1E54[v25 != 0];
  v34 = off_100A1E5C[a1];
  v33 = v22;
  if ( a9 )
  {
    v39 = a9;
    v27 = 11;
  }
  v23 = sub_10041FC0();
  sub_10030880(7, (int)&v29, v27);
  if ( v26 && a7 != a6 && v28 < fabs(a6 - a7) && !strcmp(v36, v37) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10030970(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10041FD0(v23);
  return v25;
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];

//----- (10025420) --------------------------------------------------------
bool __cdecl sub_10025420(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  void *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_1003DA90();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003E9F0() )
    v17 = v17 == 0;
  sub_10024320((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101EB8D8[v12], 0x400u, &v31, a6);
  byte_101EBCD6[v12] = 42;
  byte_101EBCD7[v12] = 0;
  v18 = sub_10024320((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_101EBCD8[v12], 0x400u, &v31, a7);
  byte_101EC0D6[v12] = 42;
  byte_101EC0D7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101EC0D8[v12];
    byte_101EC0D8[v12] = 0;
  }
  else
  {
    v18 = sub_10024320((int)&v31, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_101EC0D8[v12];
    _snprintf(&byte_101EC0D8[v12], 0x400u, &v31, a8);
    byte_101EC4D6[v12] = 42;
    byte_101EC4D7[v12] = 0;
  }
  v20 = off_100A1E64[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = &unk_100A21C4;
  v27 = &byte_101EB8D8[v12];
  v28 = &byte_101EBCD8[v12];
  v29 = v13;
  v14 = off_100A1E54[v17 != 0];
  v25 = off_100A1E5C[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10041FC0();
  sub_10030880(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10030970(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10041FD0(v15);
  return v17;
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];

//----- (100257E0) --------------------------------------------------------
bool __cdecl sub_100257E0(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1003DA90();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_37;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v17 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003E9F0() )
    v17 = v17 == 0;
  sub_10024320((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101EB8D8[v12], 0x400u, &v31, a6);
  byte_101EBCD6[v12] = 42;
  byte_101EBCD7[v12] = 0;
  v18 = sub_10024320((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_101EBCD8[v12], 0x400u, &v31, a7);
  byte_101EC0D6[v12] = 42;
  byte_101EC0D7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101EC0D8[v12];
    byte_101EC0D8[v12] = 0;
  }
  else
  {
    v13 = &byte_101EC0D8[v12];
    v18 = sub_10024320((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_101EC0D8[v12], 0x400u, &v31, a8);
    byte_101EC4D6[v12] = 42;
    byte_101EC4D7[v12] = 0;
  }
  v20 = off_100A1E64[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_101EB8D8[v12];
  v21 = a3;
  v26 = "sint16";
  v28 = &byte_101EBCD8[v12];
  v29 = v13;
  v14 = off_100A1E5C[a1];
  v24 = off_100A1E54[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10041FC0();
  sub_10030880(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10030970(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10041FD0(v15);
  return v17;
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];

//----- (10025BE0) --------------------------------------------------------
bool __cdecl sub_10025BE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_1003DA90();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003E9F0() )
    v17 = v17 == 0;
  sub_10024320((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101EB8D8[v12], 0x400u, &v31, a6);
  byte_101EBCD6[v12] = 42;
  byte_101EBCD7[v12] = 0;
  v18 = sub_10024320((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_101EBCD8[v12], 0x400u, &v31, a7);
  byte_101EC0D6[v12] = 42;
  byte_101EC0D7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101EC0D8[v12];
    byte_101EC0D8[v12] = 0;
  }
  else
  {
    v18 = sub_10024320((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_101EC0D8[v12];
    _snprintf(&byte_101EC0D8[v12], 0x400u, &v31, a8);
    byte_101EC4D6[v12] = 42;
    byte_101EC4D7[v12] = 0;
  }
  v20 = off_100A1E64[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "sint32";
  v27 = &byte_101EB8D8[v12];
  v28 = &byte_101EBCD8[v12];
  v29 = v13;
  v14 = off_100A1E54[v17 != 0];
  v25 = off_100A1E5C[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10041FC0();
  sub_10030880(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10030970(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10041FD0(v15);
  return v17;
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];

//----- (10025FA0) --------------------------------------------------------
bool __cdecl sub_10025FA0(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  bool v18; // [sp+1Bh] [bp-5Dh]@3
  char v19; // [sp+1Fh] [bp-59h]@37
  unsigned int v20; // [sp+20h] [bp-58h]@1
  int v21; // [sp+30h] [bp-48h]@1
  char *v22; // [sp+3Ch] [bp-3Ch]@40
  int v23; // [sp+40h] [bp-38h]@40
  int v24; // [sp+44h] [bp-34h]@40
  int v25; // [sp+48h] [bp-30h]@40
  char *v26; // [sp+4Ch] [bp-2Ch]@40
  char *v27; // [sp+50h] [bp-28h]@40
  const char *v28; // [sp+54h] [bp-24h]@40
  const char *v29; // [sp+58h] [bp-20h]@40
  const char *v30; // [sp+5Ch] [bp-1Ch]@40
  char *v31; // [sp+60h] [bp-18h]@40
  int v32; // [sp+64h] [bp-14h]@41
  char v33; // [sp+68h] [bp-10h]@37

  v21 = sub_1003DA90();
  v20 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 1:
      v18 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v18 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v18 = 0;
      }
      else
      {
        v18 = 1;
      }
LABEL_35:
      if ( sub_1003E9F0() )
        v18 = v18 == 0;
      sub_10024320((int)&v33, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v21;
      _snprintf(&byte_101EB8D8[3072 * v21], 0x400u, &v33, a6);
      byte_101EBCD6[v13] = 42;
      byte_101EBCD7[v13] = 0;
      v19 = sub_10024320((int)&v33, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_101EBCD8[3072 * v21], 0x400u, &v33, a7);
      byte_101EC0D6[v13] = 42;
      byte_101EC0D7[v13] = 0;
      if ( v20 <= 9 )
      {
        v14 = &byte_101EC0D8[v13];
        byte_101EC0D8[v13] = 0;
      }
      else
      {
        v19 = sub_10024320((int)&v33, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_101EC0D8[v13];
        _snprintf(&byte_101EC0D8[v13], 0x400u, &v33, a8);
        byte_101EC4D6[v13] = 42;
        byte_101EC4D7[v13] = 0;
      }
      v22 = off_100A1E64[a2];
      v24 = a4;
      v25 = a5;
      v23 = a3;
      v28 = "sint64";
      v29 = &byte_101EB8D8[3072 * v21];
      v30 = &byte_101EBCD8[3072 * v21];
      v15 = off_100A1E5C[a1];
      v26 = off_100A1E54[v18 != 0];
      v27 = v15;
      v31 = v14;
      if ( a9 )
      {
        v32 = a9;
        v20 = 11;
      }
      v16 = sub_10041FC0();
      sub_10030880(7, (int)&v22, v20);
      if ( v19 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v29, v30) )
      {
        nullsub_1(
          a3,
          a4,
          "Test definition error: Floating point values differ by less than the floating point output precision. The outp"
          "ut can not accurately represent the difference between the actual and expected values in this test case.");
        sub_10030970(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_10041FD0(v16);
      return v18;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v18 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_50;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_50:
        v18 = 0;
        v20 = 10;
      }
      else
      {
        v18 = 1;
        v20 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];

//----- (100264E0) --------------------------------------------------------
bool __cdecl sub_100264E0(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1003DA90();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_37;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v17 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003E9F0() )
    v17 = v17 == 0;
  sub_10024320((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101EB8D8[v12], 0x400u, &v31, a6);
  byte_101EBCD6[v12] = 42;
  byte_101EBCD7[v12] = 0;
  v18 = sub_10024320((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_101EBCD8[v12], 0x400u, &v31, a7);
  byte_101EC0D6[v12] = 42;
  byte_101EC0D7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101EC0D8[v12];
    byte_101EC0D8[v12] = 0;
  }
  else
  {
    v13 = &byte_101EC0D8[v12];
    v18 = sub_10024320((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_101EC0D8[v12], 0x400u, &v31, a8);
    byte_101EC4D6[v12] = 42;
    byte_101EC4D7[v12] = 0;
  }
  v20 = off_100A1E64[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_101EB8D8[v12];
  v21 = a3;
  v26 = "sint8";
  v28 = &byte_101EBCD8[v12];
  v29 = v13;
  v14 = off_100A1E5C[a1];
  v24 = off_100A1E54[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10041FC0();
  sub_10030880(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10030970(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10041FD0(v15);
  return v17;
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];

//----- (100268C0) --------------------------------------------------------
bool __cdecl sub_100268C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_1003DA90();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003E9F0() )
    v17 = v17 == 0;
  sub_10024320((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101EB8D8[v12], 0x400u, &v31, a6);
  byte_101EBCD6[v12] = 42;
  byte_101EBCD7[v12] = 0;
  v18 = sub_10024320((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_101EBCD8[v12], 0x400u, &v31, a7);
  byte_101EC0D6[v12] = 42;
  byte_101EC0D7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101EC0D8[v12];
    byte_101EC0D8[v12] = 0;
  }
  else
  {
    v18 = sub_10024320((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_101EC0D8[v12];
    _snprintf(&byte_101EC0D8[v12], 0x400u, &v31, a8);
    byte_101EC4D6[v12] = 42;
    byte_101EC4D7[v12] = 0;
  }
  v20 = off_100A1E64[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "long int";
  v27 = &byte_101EB8D8[v12];
  v28 = &byte_101EBCD8[v12];
  v29 = v13;
  v14 = off_100A1E54[v17 != 0];
  v25 = off_100A1E5C[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10041FC0();
  sub_10030880(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10030970(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10041FD0(v15);
  return v17;
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];

//----- (10026C80) --------------------------------------------------------
bool __cdecl sub_10026C80(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1003DA90();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003E9F0() )
    v17 = v17 == 0;
  sub_10024320((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101EB8D8[v12], 0x400u, &v31, a6);
  byte_101EBCD6[v12] = 42;
  byte_101EBCD7[v12] = 0;
  v18 = sub_10024320((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_101EBCD8[v12], 0x400u, &v31, a7);
  byte_101EC0D6[v12] = 42;
  byte_101EC0D7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101EC0D8[v12];
    byte_101EC0D8[v12] = 0;
  }
  else
  {
    v18 = sub_10024320((int)&v31, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_101EC0D8[v12];
    _snprintf(&byte_101EC0D8[v12], 0x400u, &v31, a8);
    byte_101EC4D6[v12] = 42;
    byte_101EC4D7[v12] = 0;
  }
  v20 = off_100A1E64[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned int";
  v29 = v13;
  v14 = off_100A1E54[v17 != 0];
  v25 = off_100A1E5C[a1];
  v24 = v14;
  v27 = &byte_101EB8D8[v12];
  v28 = &byte_101EBCD8[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10041FC0();
  sub_10030880(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10030970(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10041FD0(v15);
  return v17;
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];

//----- (10027020) --------------------------------------------------------
bool __cdecl sub_10027020(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1003DA90();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_37;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003E9F0() )
    v17 = v17 == 0;
  sub_10024320((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101EB8D8[v12], 0x400u, &v31, a6);
  byte_101EBCD6[v12] = 42;
  byte_101EBCD7[v12] = 0;
  v18 = sub_10024320((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_101EBCD8[v12], 0x400u, &v31, a7);
  byte_101EC0D6[v12] = 42;
  byte_101EC0D7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101EC0D8[v12];
    byte_101EC0D8[v12] = 0;
  }
  else
  {
    v13 = &byte_101EC0D8[v12];
    v18 = sub_10024320((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_101EC0D8[v12], 0x400u, &v31, a8);
    byte_101EC4D6[v12] = 42;
    byte_101EC4D7[v12] = 0;
  }
  v20 = off_100A1E64[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_101EB8D8[v12];
  v21 = a3;
  v26 = "uint16";
  v28 = &byte_101EBCD8[v12];
  v29 = v13;
  v14 = off_100A1E5C[a1];
  v24 = off_100A1E54[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10041FC0();
  sub_10030880(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10030970(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10041FD0(v15);
  return v17;
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];

//----- (10027420) --------------------------------------------------------
bool __cdecl sub_10027420(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1003DA90();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003E9F0() )
    v17 = v17 == 0;
  sub_10024320((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101EB8D8[v12], 0x400u, &v31, a6);
  byte_101EBCD6[v12] = 42;
  byte_101EBCD7[v12] = 0;
  v18 = sub_10024320((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_101EBCD8[v12], 0x400u, &v31, a7);
  byte_101EC0D6[v12] = 42;
  byte_101EC0D7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101EC0D8[v12];
    byte_101EC0D8[v12] = 0;
  }
  else
  {
    v18 = sub_10024320((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_101EC0D8[v12];
    _snprintf(&byte_101EC0D8[v12], 0x400u, &v31, a8);
    byte_101EC4D6[v12] = 42;
    byte_101EC4D7[v12] = 0;
  }
  v20 = off_100A1E64[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "uint32";
  v29 = v13;
  v14 = off_100A1E54[v17 != 0];
  v25 = off_100A1E5C[a1];
  v24 = v14;
  v27 = &byte_101EB8D8[v12];
  v28 = &byte_101EBCD8[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10041FC0();
  sub_10030880(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10030970(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10041FD0(v15);
  return v17;
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];

//----- (100277C0) --------------------------------------------------------
bool __cdecl sub_100277C0(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  bool v19; // [sp+18h] [bp-64h]@3
  char v20; // [sp+27h] [bp-55h]@36
  unsigned int v21; // [sp+28h] [bp-54h]@1
  int v22; // [sp+2Ch] [bp-50h]@1
  char *v23; // [sp+2Ch] [bp-50h]@36
  char *v24; // [sp+40h] [bp-3Ch]@39
  int v25; // [sp+44h] [bp-38h]@39
  int v26; // [sp+48h] [bp-34h]@39
  int v27; // [sp+4Ch] [bp-30h]@39
  char *v28; // [sp+50h] [bp-2Ch]@39
  char *v29; // [sp+54h] [bp-28h]@39
  const char *v30; // [sp+58h] [bp-24h]@39
  const char *v31; // [sp+5Ch] [bp-20h]@39
  const char *v32; // [sp+60h] [bp-1Ch]@39
  char *v33; // [sp+64h] [bp-18h]@39
  int v34; // [sp+68h] [bp-14h]@40
  char v35; // [sp+6Ch] [bp-10h]@36

  v22 = sub_1003DA90();
  v21 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 1:
      v19 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v19 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
LABEL_34:
      if ( sub_1003E9F0() )
        v19 = v19 == 0;
      sub_10024320((int)&v35, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v22;
      v14 = &byte_101EB8D8[3072 * v22];
      _snprintf(&byte_101EB8D8[3072 * v22], 0x400u, &v35, a6);
      byte_101EBCD6[v13] = 42;
      byte_101EBCD7[v13] = 0;
      v20 = sub_10024320((int)&v35, "%I64u", 6, 0xCu, (double)a7);
      v23 = &byte_101EBCD8[3072 * v22];
      _snprintf(&byte_101EBCD8[v13], 0x400u, &v35, a7);
      byte_101EC0D6[v13] = 42;
      byte_101EC0D7[v13] = 0;
      if ( v21 <= 9 )
      {
        v15 = &byte_101EC0D8[v13];
        byte_101EC0D8[v13] = 0;
      }
      else
      {
        v20 = sub_10024320((int)&v35, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_101EC0D8[v13];
        _snprintf(&byte_101EC0D8[v13], 0x400u, &v35, a8);
        byte_101EC4D6[v13] = 42;
        byte_101EC4D7[v13] = 0;
      }
      v24 = off_100A1E64[a2];
      v27 = a5;
      v26 = a4;
      v33 = v15;
      v25 = a3;
      v30 = "uint64";
      v31 = v14;
      v16 = off_100A1E5C[a1];
      v28 = off_100A1E54[v19 != 0];
      v29 = v16;
      v32 = v23;
      if ( a9 )
      {
        v34 = a9;
        v21 = 11;
      }
      v17 = sub_10041FC0();
      sub_10030880(7, (int)&v24, v21);
      if ( v20 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v31, v32) )
      {
        nullsub_1(
          a3,
          a4,
          "Test definition error: Floating point values differ by less than the floating point output precision. The outp"
          "ut can not accurately represent the difference between the actual and expected values in this test case.");
        sub_10030970(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_10041FD0(v17);
      return v19;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_49;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_49:
        v19 = 0;
        v21 = 10;
      }
      else
      {
        v19 = 1;
        v21 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];

//----- (10027DA0) --------------------------------------------------------
bool __cdecl sub_10027DA0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1003DA90();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_37;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003E9F0() )
    v17 = v17 == 0;
  sub_10024320((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101EB8D8[v12], 0x400u, &v31, a6);
  byte_101EBCD6[v12] = 42;
  byte_101EBCD7[v12] = 0;
  v18 = sub_10024320((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_101EBCD8[v12], 0x400u, &v31, a7);
  byte_101EC0D6[v12] = 42;
  byte_101EC0D7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101EC0D8[v12];
    byte_101EC0D8[v12] = 0;
  }
  else
  {
    v13 = &byte_101EC0D8[v12];
    v18 = sub_10024320((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_101EC0D8[v12], 0x400u, &v31, a8);
    byte_101EC4D6[v12] = 42;
    byte_101EC4D7[v12] = 0;
  }
  v20 = off_100A1E64[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_101EB8D8[v12];
  v21 = a3;
  v26 = "uint8";
  v28 = &byte_101EBCD8[v12];
  v29 = v13;
  v14 = off_100A1E5C[a1];
  v24 = off_100A1E54[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10041FC0();
  sub_10030880(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10030970(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10041FD0(v15);
  return v17;
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];

//----- (10028190) --------------------------------------------------------
bool __cdecl sub_10028190(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_1003DA90();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_1003E9F0() )
    v17 = v17 == 0;
  sub_10024320((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101EB8D8[v12], 0x400u, &v31, a6);
  byte_101EBCD6[v12] = 42;
  byte_101EBCD7[v12] = 0;
  v18 = sub_10024320((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_101EBCD8[v12], 0x400u, &v31, a7);
  byte_101EC0D6[v12] = 42;
  byte_101EC0D7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101EC0D8[v12];
    byte_101EC0D8[v12] = 0;
  }
  else
  {
    v18 = sub_10024320((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_101EC0D8[v12];
    _snprintf(&byte_101EC0D8[v12], 0x400u, &v31, a8);
    byte_101EC4D6[v12] = 42;
    byte_101EC4D7[v12] = 0;
  }
  v20 = off_100A1E64[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned long int";
  v29 = v13;
  v14 = off_100A1E54[v17 != 0];
  v25 = off_100A1E5C[a1];
  v24 = v14;
  v27 = &byte_101EB8D8[v12];
  v28 = &byte_101EBCD8[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10041FC0();
  sub_10030880(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10030970(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10041FD0(v15);
  return v17;
}
// 1001DC70: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];

//----- (10028530) --------------------------------------------------------
int sub_10028530()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_1003DA90();
  sub_10024280(1);
  sub_10024610(-1);
  result = sub_100245A0(-1);
  dword_101EF4D8[v0] = 0;
  return result;
}
// 101EF4D8: using guessed type int dword_101EF4D8[];

//----- (10028560) --------------------------------------------------------
BOOL __usercall sub_10028560@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_1003DA90();
  sub_10042000((int)&v13);
  sub_10042000((int)&v14);
  sub_10042000((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_10042C50((int (__cdecl *)(unsigned int))sub_10024500, v7, (int)&v13) )
  {
    if ( sub_10042C50((int (__cdecl *)(unsigned int))sub_10024500, a2, (int)&v14) )
    {
      v9 = sub_10042AC0(
             dword_101F15E4[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_10024500,
             (void (__cdecl *)(_DWORD))sub_10024520,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_10042EF0((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_100420D0((void (__cdecl *)(_DWORD))sub_10024520, (int)&v12);
  sub_100420D0((void (__cdecl *)(_DWORD))sub_10024520, (int)&v13);
  sub_100420D0((void (__cdecl *)(_DWORD))sub_10024520, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 101F15E4: using guessed type int dword_101F15E4[];

//----- (100286D0) --------------------------------------------------------
bool __usercall sub_100286D0@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_1003DA90();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_1003E9F0() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_10026C80(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_1003E9F0() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_101EB8D8[3072 * v24], 0x400u, "%s", v9);
  byte_101EBCD6[v15] = 42;
  byte_101EBCD7[v15] = 0;
  _snprintf(&byte_101EBCD8[3072 * v24], 0x400u, "%s", v22);
  v16 = off_100A1E64[a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_101EC0D6[v15] = 42;
  v17 = off_100A1E54[v14 != 0];
  v18 = off_100A1E5C[a3];
  byte_101EC0D7[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_101EB8D8[3072 * v24];
  v34 = &byte_101EBCD8[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_10041FC0();
  sub_10030880(7, (int)&v26, v19);
  sub_10041FD0(v20);
  return v14;
}
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];

//----- (10028940) --------------------------------------------------------
char __cdecl sub_10028940(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  unsigned int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_1003DA90();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_101F15E4[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_101F2C00[v10];
  sub_10024020(a3, 1, a6, 0x230u, &byte_101F2C00[v10]);
  v27 = &byte_101EF500[v10];
  sub_10024020(a3, 2, a7, 0x230u, &byte_101EF500[v10]);
  v24 = &byte_101F0AE0[v10];
  sub_10024020(a3, 3, a6, 0x230u, &byte_101F0AE0[v10]);
  v26 = &byte_101F15F8[v10];
  sub_10024020(a3, 4, a7, 0x230u, &byte_101F15F8[v10]);
  _snprintf(&byte_101F20E8[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_101F20E8[v10];
  byte_101F2317[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_10024020(a3, 0, v25, 560 - (v11 - &byte_101F20E8[v10 + 1]), &byte_101F20E8[v10] + v11 - &byte_101F20E8[v10 + 1]);
  v13 = &byte_101F20E8[v10];
  byte_101F2317[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_101F20E4[v10] + v13 - &byte_101F20E8[v10 + 1]) = 0;
  sub_10024020(a3, 1, (int)&byte_101F20E8[v10], 0x230u, &byte_101EADE8[v10]);
  sub_10024020(a3, 1, (int)&byte_101F20E8[v10], 0x230u, &byte_101EFFF0[v10]);
  v15 = sub_10028560(v22, v27, v21, a2 == 1, (int)&byte_101EADE8[v10], (const char **)&v22);
  if ( sub_1003E9F0() )
    v15 = v15 == 0;
  v30 = off_100A1E64[a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_100A1E5C[a1];
  v34 = off_100A1E54[v15 != 0];
  v17 = dword_101F15E4[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_10041FC0();
  sub_10030880(7, (int)&v30, v18);
  sub_10041FD0(v19);
  return v15;
}
// 100A1E54: using guessed type char *off_100A1E54[18];
// 100A1E5C: using guessed type char *off_100A1E5C[16];
// 100A1E64: using guessed type char *off_100A1E64[14];
// 101F15E4: using guessed type int dword_101F15E4[];

//----- (10028C40) --------------------------------------------------------
bool __cdecl sub_10028C40(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_10025420(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (10028CF0) --------------------------------------------------------
bool __cdecl sub_10028CF0(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_100286D0(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (10028D30) --------------------------------------------------------
char __cdecl sub_10028D30(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10028D70) --------------------------------------------------------
char __cdecl sub_10028D70(unsigned __int8 a1)
{
  int v1; // ecx@0
  char result; // al@1
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  result = 0;
  BYTE3(v3) = 0;
  if ( a1 < 4u )
  {
    sub_1004E840(dword_100A2344[a1], (int)&v3 + 3, 1);
    result = BYTE3(v3);
  }
  return result;
}
// 100A2344: using guessed type int dword_100A2344[];

//----- (10028DA0) --------------------------------------------------------
__int16 __usercall sub_10028DA0@<ax>(unsigned __int8 a1@<al>)
{
  return word_100A2358[a1];
}
// 100A2358: using guessed type __int16 word_100A2358[];

//----- (10028DB0) --------------------------------------------------------
char __cdecl sub_10028DB0(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_10028DA0(a1);
    if ( sub_10010C80(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (10028E80) --------------------------------------------------------
char __cdecl sub_10028E80(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_10028D30(a1);
  if ( a3 != 11 )
  {
    sub_1001B780("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_10028DB0(v7, a5);
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10028F00) --------------------------------------------------------
int __cdecl sub_10028F00(char a1)
{
  return 9190 - (a1 != 1);
}

//----- (10028F10) --------------------------------------------------------
int __usercall sub_10028F10@<eax>(char *a1@<eax>, char a2@<cl>)
{
  return sub_100302F0(a2, a1);
}

//----- (10028F20) --------------------------------------------------------
char __usercall sub_10028F20@<al>(char a1@<bl>, char a2)
{
  int v2; // eax@1
  char result; // al@2
  char *v4; // ecx@3
  unsigned __int8 v5; // [sp+4h] [bp-8Ch]@1
  char v6; // [sp+5h] [bp-8Bh]@2
  char v7[68]; // [sp+48h] [bp-48h]@1

  memset(&v5, 0, 0x43u);
  memset(v7, 0, 0x43u);
  sub_10028F10((char *)&v5, a2);
  v2 = sub_10028F00(a1);
  if ( sub_1004E7C0(v2, (int)v7, 67) )
  {
    result = a1 == 1;
  }
  else
  {
    result = v7[v5];
    if ( v6 != 67 )
    {
      v4 = &v6;
      do
        ++v4;
      while ( *v4 != 67 );
    }
  }
  return result;
}
// 10028F20: using guessed type char var_48[68];

//----- (10028FE0) --------------------------------------------------------
char __cdecl sub_10028FE0(char a1, char a2)
{
  return sub_10028F20(a1, a2);
}

//----- (10029000) --------------------------------------------------------
char __cdecl sub_10029000(char a1)
{
  char result; // al@1

  result = sub_100302C0();
  if ( result == 2 )
    result = byte_100A2E14[8 * sub_1001DC80(&a1, 4u, (int)&unk_100A2E10, 8, 7, 7)];
  return result;
}

//----- (10029030) --------------------------------------------------------
char __thiscall sub_10029030(void *this)
{
  char v1; // al@1

  v1 = sub_1001B4A0(this);
  return sub_10029000(v1);
}

//----- (10029040) --------------------------------------------------------
char sub_10029040()
{
  char result; // al@1
  void *v1; // ecx@1
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 0;
  result = sub_100302D0();
  if ( result == 3 )
  {
    v2 = sub_1001B4A0(v1);
    result = byte_100A2DDC[8 * sub_1001DC80(&v2, 4u, (int)&unk_100A2DD8, 8, 7, 7)];
  }
  return result;
}

//----- (10029080) --------------------------------------------------------
bool __cdecl sub_10029080(int a1, void *a2, int a3)
{
  unsigned __int16 v3; // ax@2
  bool result; // al@5
  char v5[4]; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5[0] = -1;
  v6 = 0;
  result = 0;
  if ( sub_10042F30(a1, a3, v5, &v6) == 1 )
  {
    v3 = sub_1000FF80(v5[0]);
    if ( (unsigned __int16)v6 < v3 && sub_10010C50(v5[0], v6, a2) && !sub_1003CE20(a2, 0, 0) )
      result = 1;
  }
  return result;
}

//----- (10029100) --------------------------------------------------------
char __cdecl sub_10029100(unsigned __int16 a1)
{
  char result; // al@3
  char v2; // [sp+Bh] [bp-9h]@3
  int v3; // [sp+Ch] [bp-8h]@1
  int v4; // [sp+10h] [bp-4h]@1

  LOBYTE(v4) = 7;
  v3 = 0;
  if ( sub_10042F30(a1, 0, &v4, &v3) != 1 && sub_10042F30(a1, 1u, &v4, &v3) != 1
    || (result = sub_100102E0(v4, v3, &v2), result != 1)
    || v2 != 1 )
  {
    result = 0;
  }
  return result;
}

//----- (10029170) --------------------------------------------------------
bool __cdecl sub_10029170(int a1, void *a2)
{
  void *v2; // ecx@0
  int v3; // ST0C_4@1

  v3 = (int)v2;
  LOBYTE(v3) = sub_10029030(v2) != 0;
  return sub_10029080(a1, a2, v3);
}

//----- (100291A0) --------------------------------------------------------
signed int __usercall sub_100291A0@<eax>(unsigned __int8 a1@<al>, void *a2@<edi>, unsigned int a3@<esi>)
{
  signed int result; // eax@2
  int v4; // edx@6

  if ( dword_100EDD94[6 * a1] & 8 )
  {
    result = sub_1004F240(a3, 0, 2);
    if ( result >= 0 )
    {
      result = j_FIL_vfs_crc32(a3, 0, result, a2);
      if ( !result )
        return 0;
    }
  }
  else
  {
    result = sub_1004F0F0(a3, -4, -1, 2);
    if ( v4 > 0 || v4 >= 0 )
    {
      if ( sub_1004F020(a3, a2, 4) != 4 )
        return -16;
      return 0;
    }
  }
  return result;
}
// 1004EF70: using guessed type int __cdecl j_FIL_vfs_crc32(_DWORD, _DWORD, _DWORD, _DWORD);
// 100EDD94: using guessed type int dword_100EDD94[];

//----- (10029210) --------------------------------------------------------
int __usercall sub_10029210@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int result; // eax@2

  if ( a3 )
    result = j_FIL_vfs_ioctl(a2, 103, a1, 48);
  else
    result = j_FIL_vfs_ioctl(a2, 102, a1, 48);
  return result;
}
// 1004EFA0: using guessed type int __cdecl j_FIL_vfs_ioctl(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10029240) --------------------------------------------------------
signed int __usercall sub_10029240@<eax>(int a1@<edi>, unsigned __int8 a2, int a3)
{
  unsigned int v3; // esi@1
  int v4; // ebx@1
  signed int result; // eax@3
  int v6; // ebx@7
  int v7; // esi@11
  __int16 v8; // ax@16
  int v9; // [sp+8h] [bp-38h]@4
  int v10; // [sp+Ch] [bp-34h]@7

  v3 = j_FIL_vfs_open(off_100A3038[a3], 4, 0);
  v4 = sub_10043010(a2);
  if ( v3 >= 0xFFFFFFC2 || !v3 )
    return v3;
  if ( j_FIL_vfs_crc32(v3, v4, v4 + 913, &v9) || v9 )
  {
    sub_1004EF10(v3);
    return -14;
  }
  if ( sub_1004F060(v3, (void *)a1, 913, v4, 0) == 913 )
    v6 = sub_10029210((int)&v10, v3, 0);
  else
    v6 = -16;
  sub_1004EF10(v3);
  if ( v6 )
    return v6;
  v7 = __ROR4__(~v10, 1);
  if ( sub_1004E2C0((unsigned int *)a1, 913, 0xFFFFFFFF)
    || *(_DWORD *)(a1 + 4) != 1984443034
    || *(_WORD *)a1 != 1
    || *(_DWORD *)(a1 + 16) != v7 && *(_WORD *)(a1 + 85) > 0 )
  {
    return -14;
  }
  v8 = *(_WORD *)(a1 + 2);
  if ( v8 && v8 != -190 )
    result = -31;
  else
    result = 0;
  return result;
}
// 1004EF70: using guessed type int __cdecl j_FIL_vfs_crc32(_DWORD, _DWORD, _DWORD, _DWORD);
// 1004F010: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100A3038: using guessed type char *off_100A3038[8];

//----- (100293A0) --------------------------------------------------------
int __usercall sub_100293A0@<eax>(int a1@<ebx>, int a2, int a3)
{
  int result; // eax@1
  char v4; // si@4
  int v5; // ecx@5
  unsigned __int8 v6; // [sp+4h] [bp-3CCh]@3
  int v7; // [sp+8h] [bp-3C8h]@1
  char v8; // [sp+38h] [bp-398h]@4
  int v9; // [sp+48h] [bp-388h]@5
  unsigned int v10; // [sp+89h] [bp-347h]@5
  char v11; // [sp+8Dh] [bp-343h]@5
  unsigned int v12; // [sp+3C1h] [bp-Fh]@5
  unsigned int v13; // [sp+3C5h] [bp-Bh]@5

  result = sub_10029210((int)&v7, a3, 0);
  if ( !result && v7 != a1 )
  {
    v6 = 0;
    do
    {
      v4 = sub_10043010(v6);
      if ( !sub_10029240((int)&v8, v6, a2) )
      {
        v5 = __ROR4__(~a1, 1);
        v9 = v5;
        v10 = sub_1004E2C0((unsigned int *)&v8, 81, 0xFFFFFFFF);
        v12 = sub_1004E2C0((unsigned int *)&v11, 820, 0xFFFFFFFF);
        v13 = sub_1004E2C0((unsigned int *)&v8, 909, 0xFFFFFFFF);
        sub_1004F1A0(a3, (int)&v8, 913, v4);
      }
      ++v6;
    }
    while ( v6 < 0xDu );
    v7 = a1;
    result = sub_10029210((int)&v7, a3, 1);
  }
  return result;
}

//----- (100294D0) --------------------------------------------------------
signed int __usercall sub_100294D0@<eax>(void *a1@<eax>, unsigned __int8 a2@<bl>, int a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v5; // ebp@1
  int v6; // eax@2
  int v7; // edi@2
  signed int result; // eax@4

  v3 = (int)a1;
  memset(a1, 0, 0x391u);
  v4 = dword_100EDD84[6 * a2];
  v5 = dword_100EDD88[6 * a2];
  if ( sub_10029240(v3, a2, a3) || (v6 = v4 & *(_DWORD *)(v3 + 8), v7 = v5 & *(_DWORD *)(v3 + 12), v6 != v4) || v7 != v5 )
    result = -15;
  else
    result = 0;
  return result;
}
// 100EDD84: using guessed type int dword_100EDD84[];
// 100EDD88: using guessed type int dword_100EDD88[];

//----- (10029530) --------------------------------------------------------
unsigned int __usercall sub_10029530@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, unsigned __int8 a5)
{
  int v5; // edi@1
  int v6; // esi@1
  int v7; // eax@1
  _DWORD *v8; // ecx@2
  unsigned int result; // eax@6
  signed int v10; // ebp@8
  int v11; // eax@8
  unsigned int v12; // edi@22
  unsigned int v13; // ebx@24
  int v14; // ebp@26
  int v15; // ebx@30
  unsigned int v16; // ebx@33
  int v17; // ecx@33
  int v18; // esi@33
  signed int v19; // [sp+8h] [bp-3C0h]@20
  unsigned int v20; // [sp+Ch] [bp-3BCh]@1
  char v21; // [sp+10h] [bp-3B8h]@33
  int v22; // [sp+20h] [bp-3A8h]@33
  int v23; // [sp+24h] [bp-3A4h]@33
  char v24; // [sp+30h] [bp-398h]@25

  v5 = a2;
  v6 = a1;
  v20 = sub_10043010(a5);
  v7 = 0;
  if ( v5 <= 0 )
  {
LABEL_5:
    if ( *(_WORD *)(v6 + 85) > 0 )
    {
      v10 = 0;
      v11 = v6 + 93;
      while ( *(_DWORD *)(v11 - 4) )
      {
        if ( !*(_DWORD *)v11 )
        {
          ++v10;
          break;
        }
        if ( !*(_DWORD *)(v11 + 4) )
        {
          v10 += 2;
          break;
        }
        if ( !*(_DWORD *)(v11 + 8) )
        {
          v10 += 3;
          break;
        }
        if ( !*(_DWORD *)(v11 + 12) )
        {
          v10 += 4;
          break;
        }
        v10 += 5;
        v11 += 20;
        if ( v10 >= 200 )
          return -15;
      }
      v19 = v10;
      if ( v10 >= 200 || *(_DWORD *)(v6 + 4 * v10 + 89) )
        return -15;
      result = j_FIL_vfs_open(off_100A3038[a4], 6, 0);
      v12 = result;
      if ( result < 0xFFFFFFC2 && result )
      {
        v13 = sub_1004F140(result);
        if ( v13 < v20 )
        {
          memset(&v24, 0, 0x391u);
          do
          {
            v14 = 913;
            if ( v20 - v13 <= 0x391 )
              v14 = v20 - v13;
            sub_1004F1A0(v12, (int)&v24, v14, v13);
            v13 += v14;
          }
          while ( v13 < v20 );
          v10 = v19;
        }
        v15 = sub_100293A0(a3, a4, v12);
        if ( v15 )
        {
          sub_1004EF10(v12);
          result = v15;
        }
        else
        {
          v16 = j_FIL_vfs_open(off_100A3048[a4], 4, 0);
          v22 = 0;
          v23 = 0;
          sub_1004F1F0(v16, (unsigned int)&v21);
          sub_1004EF50(v16);
          v17 = __ROR4__(~a3, 1);
          *(_DWORD *)(v6 + 51) = v22;
          *(_DWORD *)(v6 + 16) = v17;
          *(_DWORD *)(v6 + 4 * v10 + 89) = a3;
          --*(_WORD *)(v6 + 85);
          *(_DWORD *)(v6 + 81) = sub_1004E2C0((unsigned int *)v6, 81, 0xFFFFFFFF);
          *(_DWORD *)(v6 + 905) = sub_1004E2C0((unsigned int *)(v6 + 85), 820, 0xFFFFFFFF);
          *(_DWORD *)(v6 + 909) = sub_1004E2C0((unsigned int *)v6, 909, 0xFFFFFFFF);
          v18 = sub_1004F1A0(v12, v6, 913, v20) != 913 ? 0xFFFFFFF0 : 0;
          sub_1004EF10(v12);
          j_FIL_vfs_sync_all();
          result = v18;
        }
      }
    }
    else
    {
      result = -15;
    }
  }
  else
  {
    v8 = (_DWORD *)(v6 + 89);
    while ( *v8 != a3 )
    {
      ++v7;
      ++v8;
      if ( v7 >= v5 )
        goto LABEL_5;
    }
    result = 0;
  }
  return result;
}
// 1004F010: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1004F160: using guessed type int j_FIL_vfs_sync_all(void);
// 100A3038: using guessed type char *off_100A3038[8];
// 100A3048: using guessed type char *off_100A3048[4];

//----- (100297D0) --------------------------------------------------------
signed int __cdecl sub_100297D0(unsigned __int8 a1, unsigned int a2)
{
  void *v2; // ecx@2
  signed int result; // eax@4
  unsigned int v4; // ebp@5
  bool v5; // zf@5
  _DWORD *v6; // ecx@7
  signed int v7; // edx@8
  unsigned int v8; // esi@11
  int v9; // edi@11
  unsigned int v10; // eax@16
  int v11; // eax@20
  int v12; // [sp+8h] [bp-3CCh]@6
  char *v13; // [sp+Ch] [bp-3C8h]@18
  int v14; // [sp+10h] [bp-3C4h]@5
  int v15; // [sp+14h] [bp-3C0h]@2
  int v16; // [sp+18h] [bp-3BCh]@32
  char v17; // [sp+1Ch] [bp-3B8h]@18
  int v18; // [sp+2Ch] [bp-3A8h]@29
  int v19; // [sp+30h] [bp-3A4h]@30
  char v20; // [sp+3Ch] [bp-398h]@19
  int v21; // [sp+50h] [bp-384h]@22
  int v22; // [sp+6Fh] [bp-365h]@29

  if ( a1 >= 0xDu || sub_1004E7C0(6103, (int)&v15, 8) )
    return -15;
  if ( sub_1001A070(v2) == 8 )
    return 0;
  v4 = 0;
  v5 = (dword_100EDD94[6 * a1] & 1) == 0;
  v14 = 3 * a1;
  if ( !v5 )
  {
    result = sub_100291A0(a1, &v12, a2);
    if ( result )
      return result;
    v6 = (_DWORD *)dword_100A3090[2 * a1];
    if ( v6 )
    {
      v7 = (unsigned __int16)word_100A3094[4 * a1];
      if ( v7 > 0 )
      {
        do
        {
          if ( v12 == *v6 )
            return 0;
          ++result;
          ++v6;
        }
        while ( result < v7 );
      }
    }
  }
  v8 = -15;
  v9 = 0;
  while ( v8 )
  {
    if ( v4 < 0xFFFFFFC2 && v4 )
      sub_1004EF10(v4);
    v10 = j_FIL_vfs_open(off_100A3048[v9], 4, 0);
    v4 = v10;
    if ( v10 < 0xFFFFFFC2 && v10 )
    {
      v13 = &v17;
      j_FIL_vfs_ioctl(v10, 106, &v13, 4);
    }
    if ( !sub_100294D0(&v20, a1, v9) )
    {
      v11 = dword_100EDD94[2 * v14];
      if ( !(v11 & 1) )
        goto LABEL_28;
      if ( a1 )
      {
        if ( v21 == v12 )
          goto LABEL_28;
      }
      else if ( (_BYTE)v21 == 1 && *(int *)((char *)&v21 + 2) == v12 )
      {
LABEL_28:
        if ( v11 & 2 && (v22 != v18 || 0 != v19) )
          sub_1001B780("..\\lib\\acl\\utl\\utl_feat_unlock.c", 587, 0, 0);
        v8 = sub_10029530((int)&v20, 200, v15 + v16, v9, a1);
        goto LABEL_33;
      }
    }
    v8 = -15;
LABEL_33:
    if ( ++v9 >= 4 )
    {
      if ( v8 )
        goto LABEL_37;
      break;
    }
  }
  if ( dword_100EDD94[2 * v14] & 4 )
  {
    v13 = (char *)1;
    v8 = j_FIL_vfs_ioctl(v4, 105, &v13, 4);
  }
LABEL_37:
  if ( v4 < 0xFFFFFFC2 )
  {
    if ( v4 )
      sub_1004EF10(v4);
  }
  return v8;
}
// 100297D0: too many cbuild loops
// 1004EFA0: using guessed type int __cdecl j_FIL_vfs_ioctl(_DWORD, _DWORD, _DWORD, _DWORD);
// 1004F010: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100A3048: using guessed type char *off_100A3048[4];
// 100A3090: using guessed type int dword_100A3090[];
// 100A3094: using guessed type __int16 word_100A3094[];

//----- (10029A20) --------------------------------------------------------
char __cdecl sub_10029A20(char *a1, char a2, int a3, int a4)
{
  int v4; // eax@7
  int v6; // [sp+8h] [bp-Ch]@1
  int v7; // [sp+Ch] [bp-8h]@1
  float v8; // [sp+10h] [bp-4h]@1

  v8 = 0.0;
  v7 = 0;
  v6 = 0;
  if ( a1 && a3 )
  {
    switch ( a2 )
    {
      case 0:
        if ( (unsigned int)a4 < 1
          || sub_10052ABC((int)a1, (int)"%lu", (unsigned int)&v6) != 1
          || (unsigned int)v6 > 0xFF )
        {
          goto LABEL_46;
        }
        *(_BYTE *)a3 = v6;
        LOBYTE(v4) = 1;
        break;
      case 1:
        if ( (unsigned int)a4 < 2
          || sub_10052ABC((int)a1, (int)"%lu", (unsigned int)&v6) != 1
          || (unsigned int)v6 > 0xFFFF )
        {
          goto LABEL_46;
        }
        *(_WORD *)a3 = v6;
        LOBYTE(v4) = 1;
        break;
      case 2:
        if ( (unsigned int)a4 < 4 || *a1 == 45 || sub_10052ABC((int)a1, (int)"%lu", (unsigned int)&v6) != 1 )
          goto LABEL_46;
        *(_DWORD *)a3 = v6;
        LOBYTE(v4) = 1;
        break;
      case 8:
        if ( (unsigned int)a4 < 4 || !*a1 || strlen(a1) > 8 || !sub_100205B0((int)a1, strlen(a1), &v7) )
          goto LABEL_46;
        *(_DWORD *)a3 = v7;
        LOBYTE(v4) = 1;
        break;
      case 9:
        if ( (unsigned int)a4 < 4 || *a1 == 45 || sub_10052ABC((int)a1, (int)"%lu", (unsigned int)&v6) != 1 )
          goto LABEL_46;
        if ( v6 )
        {
          *(_DWORD *)a3 |= v6;
          LOBYTE(v4) = 1;
        }
        else
        {
          *(_DWORD *)a3 = 0;
          LOBYTE(v4) = 1;
        }
        break;
      case 3:
        if ( (unsigned int)a4 < 1
          || strlen(a1) > 4
          || sub_10052ABC((int)a1, (int)"%ld", (unsigned int)&v6) != 1
          || (unsigned int)(v6 + 128) > 0xFF )
        {
          goto LABEL_46;
        }
        *(_BYTE *)a3 = v6;
        LOBYTE(v4) = 1;
        break;
      case 4:
        if ( (unsigned int)a4 < 2
          || strlen(a1) > 6
          || sub_10052ABC((int)a1, (int)"%ld", (unsigned int)&v6) != 1
          || (unsigned int)(v6 + 0x8000) > 0xFFFF )
        {
          goto LABEL_46;
        }
        *(_WORD *)a3 = v6;
        LOBYTE(v4) = 1;
        break;
      case 5:
        if ( (unsigned int)a4 < 4 || sub_10052ABC((int)a1, (int)"%ld", (unsigned int)&v6) != 1 || (*a1 == 45) != v6 < 0 )
          goto LABEL_46;
        *(_DWORD *)a3 = v6;
        LOBYTE(v4) = 1;
        break;
      case 6:
        if ( (unsigned int)a4 < 4 )
          goto LABEL_46;
        v4 = sub_10052ABC((int)a1, (int)"%f", (unsigned int)&v8);
        if ( v4 != 1 )
          goto LABEL_46;
        *(float *)a3 = v8;
        break;
      case 7:
        if ( strlen(a1) >= a4 )
          goto LABEL_46;
        sub_10020640(a3, a1, a4);
        LOBYTE(v4) = 1;
        break;
      default:
LABEL_46:
        sub_1001B780("..\\lib\\adl\\iop_cnfg_ini_file_intf.c", 358, 0, a1);
        LOBYTE(v4) = 0;
        break;
    }
  }
  else
  {
    sub_1001B780("..\\lib\\adl\\iop_cnfg_ini_file_intf.c", 141, 0, 0);
    LOBYTE(v4) = 0;
  }
  return v4;
}

//----- (10029DD0) --------------------------------------------------------
bool __cdecl sub_10029DD0(int a1, char *a2, int a3, int a4, int a5)
{
  char *v5; // edi@1
  char v6; // al@2
  char v7; // bl@3
  unsigned int v8; // eax@3
  signed int v10; // edi@6
  char *i; // esi@8
  signed int v12; // eax@19
  int v13; // edi@25
  signed int v14; // esi@25
  char *v15; // eax@34
  unsigned int v16; // esi@36
  char *v17; // eax@51
  unsigned int v18; // ecx@52
  int v19; // [sp+10h] [bp-220h]@1
  unsigned int v20; // [sp+14h] [bp-21Ch]@3
  int v21; // [sp+18h] [bp-218h]@1
  int v22; // [sp+20h] [bp-210h]@1
  int v23; // [sp+28h] [bp-208h]@1
  char v24[256]; // [sp+2Ch] [bp-204h]@6
  char v25[256]; // [sp+12Bh] [bp-105h]@1
  char v26; // [sp+12Ch] [bp-104h]@1

  v19 = 0;
  v21 = 0;
  v23 = 0;
  v22 = 0;
  strcpy(&v26, (const char *)a3);
  v5 = v25;
  do
    v6 = (v5++)[1];
  while ( v6 );
  *(_WORD *)v5 = 61;
  v7 = 0;
  v8 = j_FIL_vfs_open(a1, 4, 1809);
  v20 = v8;
  if ( v8 >= 0xFFFFFFC2 || !v8 )
    return 0;
  v10 = sub_1004F060(v8, v24, 254, 0, 0);
  if ( v10 > 0 )
  {
    do
    {
      if ( v7 == 2 )
        break;
      v24[v10] = 0;
      for ( i = strchr(v24, 91); i; i = strchr(i + 1, 91) )
      {
        if ( v7 == 2 )
          break;
        if ( v7 )
        {
          if ( v7 == 1 )
          {
            v7 = 2;
            v21 = v19 + i - v24;
          }
          else
          {
            sub_1001B780("..\\lib\\adl\\iop_ini_parser_utl.c", 253, 0, 0);
          }
        }
        else if ( !strncmp(i + 1, a2, strlen(a2)) && i[strlen(a2) + 1] == 93 )
        {
          v7 = 1;
          v23 = v19 + i - v24;
        }
      }
      if ( v10 <= (signed int)(strlen(a2) + 1) )
      {
        v19 += v10;
        v12 = sub_1004F060(v20, v24, 254, v19, (unsigned __int64)v19 >> 32);
      }
      else
      {
        v19 = v19 + v10 - strlen(a2) - 1;
        v12 = sub_1004F060(v20, v24, 254, v19, (unsigned __int64)v19 >> 32);
      }
      v10 = v12;
    }
    while ( v12 > 0 );
    if ( v7 == 1 )
    {
      v21 = v19;
      v7 = 2;
    }
    else if ( v7 != 2 )
    {
      goto LABEL_47;
    }
    v13 = v23;
    v14 = sub_1004F060(v20, v24, 254, v23, (unsigned __int64)v23 >> 32);
    if ( v14 > 0 )
    {
      while ( 1 )
      {
        if ( v13 > v21 || v7 == 4 || v7 == 5 )
          goto LABEL_47;
        if ( v14 + v13 <= v21 )
          v24[v14] = 0;
        else
          v24[v21 - v13] = 0;
        if ( v7 == 2 )
          break;
        if ( v7 == 3 )
        {
          v15 = strchr(v24, 13);
          if ( v15 || (v15 = strchr(v24, 10)) != 0 )
          {
            v16 = (unsigned int)&v15[v13 - v22 - (_DWORD)v24];
            if ( v16 >= a5 )
            {
              v7 = 5;
              sub_1001B780("..\\lib\\adl\\iop_ini_parser_utl.c", 437, 0, a2);
            }
            else if ( sub_1004F060(v20, (void *)a4, v16, v22, (unsigned __int64)v22 >> 32) == v16 )
            {
              v7 = 4;
              *(_BYTE *)(v16 + a4) = 0;
            }
            else
            {
              v7 = 5;
              sub_1001B780("..\\lib\\adl\\iop_ini_parser_utl.c", 430, 0, a2);
            }
            goto LABEL_46;
          }
          if ( !sub_1004F060(v20, v24, 254, v14 + v13, (unsigned __int64)(v14 + v13) >> 32) )
          {
            if ( v14 > (unsigned int)a5 )
            {
              v7 = 5;
              sub_1001B780("..\\lib\\adl\\iop_ini_parser_utl.c", 505, 0, a2);
            }
            else if ( sub_1004F060(v20, (void *)a4, v14, v22, (unsigned __int64)v22 >> 32) == v14 )
            {
              v7 = 4;
              *(_BYTE *)(a4 + v14) = 0;
            }
            else
            {
              v7 = 5;
              sub_1001B780("..\\lib\\adl\\iop_ini_parser_utl.c", 498, 0, a2);
            }
          }
LABEL_45:
          v13 += v14;
        }
LABEL_46:
        v14 = sub_1004F060(v20, v24, 254, v13, (unsigned __int64)v13 >> 32);
        if ( v14 <= 0 )
          goto LABEL_47;
      }
      v17 = strstr(v24, &v26);
      if ( v17 )
      {
        v7 = 3;
        v18 = (unsigned int)&v17[strlen(&v26) - (_DWORD)v24];
        v22 = v13 + v18;
        v13 += v18;
        goto LABEL_46;
      }
      if ( v14 > (signed int)strlen(&v26) )
      {
        v13 += v14 - strlen(&v26);
        goto LABEL_46;
      }
      goto LABEL_45;
    }
  }
LABEL_47:
  sub_1004EF10(v20);
  return v7 == 4;
}
// 1004F010: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10029DD0: using guessed type char var_204[256];

//----- (1002A280) --------------------------------------------------------
BOOL sub_1002A280()
{
  return j_FIL_vfs_delete("/mnt/sys_nand0/cnfg_rgn.bin") == 0;
}
// 1004EF80: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (1002A2A0) --------------------------------------------------------
char __cdecl sub_1002A2A0(char a1, __int16 a2, unsigned int *a3, unsigned int a4, char a5)
{
  char result; // al@1
  signed int v6; // edi@3
  int v7; // esi@6

  result = 0;
  if ( (unsigned int)a3 < 0xFFFFFFC2 )
  {
    if ( a3 )
    {
      v6 = a4;
      if ( a4 > 4 )
      {
        if ( a5 )
          v6 = a4 - 4;
        v7 = sub_1004E2C0(a3, v6, 0xFFFFFFFF);
        sub_100125F0(a1, a2, v7);
        result = 1;
        if ( a5 )
          *(unsigned int *)((char *)a3 + v6) = v7;
      }
    }
  }
  return result;
}

//----- (1002A300) --------------------------------------------------------
char __cdecl sub_1002A300(char a1, __int16 a2, unsigned int a3, int a4, int a5)
{
  char v5; // bl@1
  unsigned int v6; // eax@1
  unsigned int v7; // esi@1
  int v8; // ebx@6
  signed int v9; // eax@6
  char result; // al@9

  v5 = 0;
  v6 = j_FIL_vfs_open("/mnt/sys_nand0/cnfg_rgn.bin", 10, 0);
  v7 = v6;
  if ( v6 < 0xFFFFFFC2 && v6 && a3 < 0xFFFFFFC2 && a3 )
  {
    if ( !a4 )
      return v5;
    v8 = j_FIL_vfs_write(v6, a3, a4);
    v9 = sub_1004EF10(v7);
    if ( v8 == a4 && !v9 )
    {
      v5 = 1;
      sub_100146F0("/mnt/sys_nand0/cnfg_rgn.bin", 0, a4, a1, a2, a5);
      return v5;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1004F010: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1004F190: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1002A3A0) --------------------------------------------------------
char __cdecl sub_1002A3A0(char *a1)
{
  unsigned __int8 v1; // bl@1
  char v3; // [sp+8h] [bp-120h]@1
  __int16 v4; // [sp+20h] [bp-108h]@2

  memset(&v3, 0, 0x11Cu);
  v1 = 0;
  while ( 1 )
  {
    sub_10019240(v1, (int)&v3);
    if ( v4 == 17 )
      break;
    if ( ++v1 >= 0x5Cu )
      return 1;
  }
  sprintf(a1, "Audio Message %i invalid, requesting LRU = MON ALERT.", v1);
  return 0;
}

//----- (1002A440) --------------------------------------------------------
char __cdecl sub_1002A440(char a1)
{
  char v1; // bl@1
  int v2; // eax@1
  char result; // al@2
  signed int v4; // ecx@3
  char *v5; // esi@3
  int v6; // edi@6
  int v7; // eax@6
  signed int v8; // [sp+4h] [bp-18Ch]@3
  char *v9; // [sp+8h] [bp-188h]@3
  int v10; // [sp+Ch] [bp-184h]@1
  int v11; // [sp+10h] [bp-180h]@6
  int v12; // [sp+38h] [bp-158h]@8
  char v13; // [sp+128h] [bp-68h]@9

  v1 = 1;
  memset(&v10, 0, 0x11Cu);
  v2 = sub_1001DC80(&a1, 1u, (int)&unk_100A3DD0, 3, 5, -1);
  if ( v2 >= 0 )
  {
    v4 = (unsigned __int8)byte_100A3DD1[3 * v2];
    v8 = v4;
    v9 = (char *)&unk_100A3DD2 + 3 * v2;
    v5 = (char *)&unk_100A3A78 + 12 * v4;
    while ( v4 < (unsigned __int8)*v9 )
    {
      v6 = (unsigned __int8)*(v5 - 8);
      sub_1002A390(v6, &v10);
      v7 = *((_DWORD *)v5 - 1);
      if ( v11 != v7 || v10 != (unsigned __int8)*(v5 - 8) || v12 != *(_DWORD *)v5 )
      {
        v1 = 0;
        _snprintf(
          &v13,
          0x64u,
          "TAWS rqrd msg id %d, class %d and clip %d don't match cnfgrd msg id %d, class %d and clip %d",
          v6,
          v7,
          *(_DWORD *)v5,
          v10,
          v11,
          v12);
        sub_1001B780("..\\lib\\adl\\iop_aud_msg_cnfg_intf.c", 566, 0, &v13);
      }
      ++v8;
      v5 += 12;
      if ( !v1 )
        break;
      v4 = v8;
    }
    result = v1;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 1002A390: using guessed type _DWORD __cdecl sub_1002A390(_DWORD, _DWORD);

//----- (1002A580) --------------------------------------------------------
char sub_1002A580()
{
  unsigned __int8 v0; // bl@1
  char v2; // [sp+8h] [bp-4h]@1

  v0 = 0;
  v2 = 0;
  while ( !sub_1002A7A0(v2) || sub_1002A440(v2) )
  {
    v2 = ++v0;
    if ( v0 >= 6u )
      return 1;
  }
  return 0;
}

//----- (1002A5D0) --------------------------------------------------------
char __cdecl sub_1002A5D0(int a1, char a2)
{
  char v2; // bl@1
  int v3; // eax@1
  char result; // al@2
  char *v5; // ecx@3
  signed int v6; // ecx@3
  char *v7; // edi@3
  int v8; // eax@6
  int v9; // edx@6
  int v10; // ecx@9
  unsigned __int16 v11; // dx@12
  unsigned __int16 v12; // si@12
  unsigned __int16 v13; // dx@14
  unsigned __int16 v14; // si@14
  signed int v15; // [sp+8h] [bp-74h]@3
  char *v16; // [sp+Ch] [bp-70h]@3
  char *v17; // [sp+10h] [bp-6Ch]@3
  char v18; // [sp+14h] [bp-68h]@7

  v2 = 1;
  v3 = sub_1001DC80(&a2, 1u, (int)&unk_100A3DD0, 3, 5, -1);
  if ( v3 >= 0 )
  {
    v5 = &byte_100A3DD1[3 * v3];
    v17 = v5;
    v6 = (unsigned __int8)*v5;
    v15 = v6;
    v16 = (char *)&unk_100A3DD2 + 3 * v3;
    v7 = (char *)&unk_100A3A74 + 12 * v6;
    while ( v6 < (unsigned __int8)*v16 )
    {
      v8 = (unsigned __int8)*(v7 - 4);
      v9 = a1 + 24 * v8;
      if ( *(_DWORD *)(v9 + 4220) == *(_DWORD *)v7 )
      {
        if ( v15 > (unsigned __int8)*v17 )
        {
          v10 = (unsigned __int8)*(v7 - 16);
          if ( *(v7 - 3) == 1 )
          {
            v13 = *(_WORD *)(v9 + 4228);
            v14 = *(_WORD *)(a1 + 24 * v10 + 4228);
            if ( v13 != v14 )
            {
              v2 = 0;
              _snprintf(
                &v18,
                0x64u,
                "audio message id %d relative priority error - %d vs %d, should be =",
                v8,
                v13,
                v14);
              sub_1001B780("..\\lib\\adl\\iop_aud_msg_cnfg_intf.c", 775, 0, &v18);
            }
          }
          else if ( *(v7 - 3) == 2 )
          {
            v11 = *(_WORD *)(v9 + 4228);
            v12 = *(_WORD *)(a1 + 24 * v10 + 4228);
            if ( v11 <= v12 )
            {
              v2 = 0;
              _snprintf(
                &v18,
                0x64u,
                "audio message id %d relative priority error - %d vs %d, should be <",
                v8,
                v11,
                v12);
              sub_1001B780("..\\lib\\adl\\iop_aud_msg_cnfg_intf.c", 801, 0, &v18);
            }
          }
          else
          {
            sub_1001B780("..\\lib\\adl\\iop_aud_msg_cnfg_intf.c", 817, 1, 0);
          }
        }
      }
      else
      {
        v2 = 0;
        _snprintf(
          &v18,
          0x64u,
          "TAWS audio class for msg id %d should be %d, the cnfgrd audio classs is %d",
          v8,
          *(_DWORD *)v7,
          *(_DWORD *)(v9 + 4220));
        sub_1001B780("..\\lib\\adl\\iop_aud_msg_cnfg_intf.c", 729, 0, &v18);
      }
      ++v15;
      v7 += 12;
      if ( !v2 )
        break;
      v6 = v15;
    }
    result = v2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002A7A0) --------------------------------------------------------
char __cdecl sub_1002A7A0(char a1)
{
  int v1; // eax@1
  char result; // al@2
  int v3; // [sp+4h] [bp-8h]@1
  unsigned int v4; // [sp+8h] [bp-4h]@1

  v3 = 0;
  sub_1004E880(6429, &v4, 4, &v3);
  v1 = sub_1001DC80(&a1, 1u, (int)&unk_100A4678, 12, 6, -1);
  if ( v1 <= -1 )
    result = 0;
  else
    result = (v4 >> dword_100A4680[3 * v1]) & 1;
  return result;
}
// 100A4680: using guessed type int dword_100A4680[];

//----- (1002A800) --------------------------------------------------------
__int16 *__cdecl sub_1002A800(char a1, unsigned __int16 a2)
{
  char *v2; // eax@1
  signed int v3; // ecx@1
  unsigned __int8 v4; // bl@3
  char v5; // cl@6
  int v6; // eax@6
  unsigned __int16 *v7; // esi@25
  int v8; // edi@25
  int v9; // eax@29
  unsigned __int16 *v10; // esi@32
  int v11; // edi@32
  int v12; // eax@36
  char v14; // [sp+8h] [bp-224h]@3
  char v15; // [sp+9h] [bp-223h]@3
  unsigned __int8 v16; // [sp+Ah] [bp-222h]@3
  char v17; // [sp+Bh] [bp-221h]@26
  unsigned __int16 v18; // [sp+Ch] [bp-220h]@26
  char v19[4]; // [sp+10h] [bp-21Ch]@3
  char v20; // [sp+14h] [bp-218h]@4
  char v21[20]; // [sp+15h] [bp-217h]@8
  char v22; // [sp+29h] [bp-203h]@9
  __int16 v23; // [sp+2Ch] [bp-200h]@13
  __int16 v24; // [sp+2Eh] [bp-1FEh]@15
  __int16 v25[100]; // [sp+98h] [bp-194h]@3
  __int16 v26[100]; // [sp+160h] [bp-CCh]@3

  v2 = byte_101F36F2;
  v3 = 203;
  do
  {
    *((_WORD *)v2 - 1) = a2;
    *v2 = 3;
    v2 += 4;
    --v3;
  }
  while ( v3 );
  v4 = 0;
  v14 = 0;
  v16 = 0;
  v15 = 0;
  memset(v26, 0, 0xC8u);
  memset(v25, 0, 0xC8u);
  v19[0] = 0;
  do
  {
    if ( !sub_10043070(v19[0], &v20) )
      goto LABEL_20;
    if ( v20 )
    {
LABEL_9:
      ++v15;
      if ( v22 )
      {
        if ( v22 == 1 )
        {
          if ( !v23 )
            goto LABEL_20;
          v25[v4] = v23;
LABEL_19:
          ++v4;
          goto LABEL_20;
        }
        if ( v22 != 2 )
          goto LABEL_20;
      }
      else if ( v24 )
      {
        v26[v16++] = v24;
      }
      if ( !v23 )
        goto LABEL_20;
      v25[v4] = v23;
      goto LABEL_19;
    }
    v5 = 0;
    v6 = 0;
    while ( v5 )
    {
      v5 = v21[v6++];
      if ( v5 != *(&byte_100647C9 + v6) )
        goto LABEL_9;
    }
LABEL_20:
    ++v19[0];
  }
  while ( v19[0] < 0x64u );
  if ( v15 )
  {
    if ( !a1 )
    {
      word_101F36F0[0] = 6;
      byte_101F36F2[0] = 1;
      word_101F36F4 = 10;
      byte_101F36F6 = 1;
      v14 = 2;
    }
    if ( v4 )
    {
      v7 = (unsigned __int16 *)v25;
      v8 = v4;
      do
      {
        if ( sub_10042F90(*v7, 0, &v17, &v18) == 1 && v17 == a1 && v18 < a2 )
        {
          v9 = 2 * (unsigned __int8)v14;
          word_101F36F0[v9] = v18;
          byte_101F36F2[v9 * 2] = 1;
          ++v14;
        }
        ++v7;
        --v8;
      }
      while ( v8 );
    }
    if ( v16 )
    {
      v10 = (unsigned __int16 *)v26;
      v11 = v16;
      do
      {
        if ( sub_10042F30(*v10, 0, &v17, &v18) == 1 && v17 == a1 && v18 < a2 )
        {
          v12 = 2 * (unsigned __int8)v14;
          word_101F36F0[v12] = v18;
          byte_101F36F2[v12 * 2] = 1;
          ++v14;
        }
        ++v10;
        --v11;
      }
      while ( v11 );
    }
  }
  return word_101F36F0;
}
// 101F36F0: using guessed type __int16 word_101F36F0[];
// 101F36F4: using guessed type __int16 word_101F36F4;
// 101F36F6: using guessed type char byte_101F36F6;
// 1002A800: using guessed type __int16 var_CC[100];
// 1002A800: using guessed type __int16 var_194[100];
// 1002A800: using guessed type char var_217[20];

//----- (1002AA70) --------------------------------------------------------
int __cdecl sub_1002AA70(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100A5D10 + a1);
        break;
      case 0:
        result = (int)*(&off_100A5D1C + a1);
        break;
      case 1:
        result = (int)*(&off_100A5D28 + a1);
        break;
      case 2:
        result = (int)*(&off_100A5D34 + a1);
        break;
      case 3:
        result = (int)*(&off_100A5D40 + a1);
        break;
      case 5:
        result = (int)*(&off_100A5D4C + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 100A5D10: using guessed type void *off_100A5D10;
// 100A5D1C: using guessed type void *off_100A5D1C;
// 100A5D28: using guessed type void *off_100A5D28;
// 100A5D34: using guessed type void *off_100A5D34;
// 100A5D40: using guessed type void *off_100A5D40;
// 100A5D4C: using guessed type void *off_100A5D4C;

//----- (1002AAF0) --------------------------------------------------------
int __cdecl sub_1002AAF0(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100A5C80 + a1);
        break;
      case 0:
        result = (int)*(&off_100A5C8C + a1);
        break;
      case 1:
        result = (int)*(&off_100A5C98 + a1);
        break;
      case 2:
        result = (int)*(&off_100A5CA4 + a1);
        break;
      case 3:
        result = (int)*(&off_100A5CB0 + a1);
        break;
      case 5:
        result = (int)*(&off_100A5CBC + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 100A5C80: using guessed type void *off_100A5C80;
// 100A5C8C: using guessed type void *off_100A5C8C;
// 100A5C98: using guessed type void *off_100A5C98;
// 100A5CA4: using guessed type void *off_100A5CA4;
// 100A5CB0: using guessed type void *off_100A5CB0;
// 100A5CBC: using guessed type void *off_100A5CBC;

//----- (1002AB70) --------------------------------------------------------
int __cdecl sub_1002AB70(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100A5D58 + a1);
        break;
      case 0:
        result = (int)*(&off_100A5D64 + a1);
        break;
      case 1:
        result = (int)*(&off_100A5D70 + a1);
        break;
      case 2:
        result = (int)*(&off_100A5D7C + a1);
        break;
      case 3:
        result = (int)*(&off_100A5D88 + a1);
        break;
      case 5:
        result = (int)*(&off_100A5D94 + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 100A5D58: using guessed type void *off_100A5D58;
// 100A5D64: using guessed type void *off_100A5D64;
// 100A5D70: using guessed type void *off_100A5D70;
// 100A5D7C: using guessed type void *off_100A5D7C;
// 100A5D88: using guessed type void *off_100A5D88;
// 100A5D94: using guessed type void *off_100A5D94;

//----- (1002ABF0) --------------------------------------------------------
void *__cdecl sub_1002ABF0(unsigned __int8 a1, char a2)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = *(&off_100A5CC8 + a1);
        break;
      case 0:
        result = *(&off_100A5CD4 + a1);
        break;
      case 1:
        result = *(&off_100A5CE0 + a1);
        break;
      case 2:
        result = *(&off_100A5CEC + a1);
        break;
      case 3:
        result = *(&off_100A5CF8 + a1);
        break;
      case 5:
        result = &unk_100A505C;
        break;
      default:
        return result;
    }
  }
  return result;
}
// 100A5CC8: using guessed type void *off_100A5CC8;
// 100A5CD4: using guessed type void *off_100A5CD4;
// 100A5CE0: using guessed type void *off_100A5CE0;
// 100A5CEC: using guessed type void *off_100A5CEC;
// 100A5CF8: using guessed type void *off_100A5CF8;

//----- (1002AC70) --------------------------------------------------------
int __cdecl sub_1002AC70(char a1)
{
  return sub_1001DC80(&a1, 1u, (int)&unk_100A5DA0, 28, 12, 11);
}

//----- (1002AC90) --------------------------------------------------------
int __cdecl sub_1002AC90(char a1)
{
  return sub_1001DC80(&a1, 1u, (int)&unk_100A5710, 16, 11, 11);
}

//----- (1002ACB0) --------------------------------------------------------
int __cdecl sub_1002ACB0(char a1)
{
  return sub_1001DC80(&a1, 1u, (int)&unk_100A57C0, 64, 19, 19);
}

//----- (1002ACD0) --------------------------------------------------------
void *__cdecl sub_1002ACD0(char a1, unsigned __int8 a2, char a3)
{
  void *v3; // esi@1
  unsigned __int8 v4; // al@3
  void *result; // eax@4

  v3 = 0;
  if ( a2 >= 3u || (unsigned __int8)a1 > 0x3Fu )
  {
    result = 0;
  }
  else
  {
    v4 = sub_1002AC70(a1);
    switch ( a3 )
    {
      case 6:
        result = &unk_100A5048;
        break;
      case 0:
        result = *(&off_100A5DA4 + a2 + 7 * v4);
        break;
      case 1:
        result = *(&off_100A5DB0 + a2 + 7 * v4);
        break;
      case 2:
        result = &unk_100A5054;
        break;
      case 3:
        result = &unk_100A5058;
        break;
      case 5:
        v3 = &unk_100A505C;
        goto LABEL_10;
      default:
LABEL_10:
        result = v3;
        break;
    }
  }
  return result;
}
// 100A5DA4: using guessed type void *off_100A5DA4;
// 100A5DB0: using guessed type void *off_100A5DB0;

//----- (1002AD90) --------------------------------------------------------
void *__cdecl sub_1002AD90(unsigned __int8 a1, char a2, char a3)
{
  void *v3; // esi@1
  int v4; // eax@3
  void *result; // eax@4

  v3 = 0;
  if ( a1 >= 3u || (unsigned __int8)a2 >= 0xBu )
  {
    result = 0;
  }
  else
  {
    v4 = sub_1002AC90(a2);
    switch ( a3 )
    {
      case 6:
        result = *(&off_100A5714 + a1 + 4 * v4);
        break;
      case 0:
        result = &unk_100A504C;
        break;
      case 1:
        result = &unk_100A5050;
        break;
      case 2:
        result = &unk_100A5054;
        break;
      case 3:
        result = &unk_100A5058;
        break;
      case 5:
        v3 = &unk_100A505C;
        goto LABEL_10;
      default:
LABEL_10:
        result = v3;
        break;
    }
  }
  return result;
}
// 100A5714: using guessed type void *off_100A5714;

//----- (1002AE30) --------------------------------------------------------
char __cdecl sub_1002AE30(char a1)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 0x13u )
    result = byte_100A57C1[64 * sub_1002ACB0(a1)];
  else
    result = 16;
  return result;
}

//----- (1002AE50) --------------------------------------------------------
char __cdecl sub_1002AE50(char a1)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 0x13u )
    result = byte_100A57C3[64 * sub_1002ACB0(a1)];
  else
    result = 4;
  return result;
}

//----- (1002AE70) --------------------------------------------------------
char __cdecl sub_1002AE70(char a1)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 0x13u )
    result = byte_100A57C2[64 * sub_1002ACB0(a1)];
  else
    result = 5;
  return result;
}

//----- (1002AE90) --------------------------------------------------------
void *__cdecl sub_1002AE90(unsigned __int8 a1, char a2, char a3)
{
  void *v3; // esi@1
  int v4; // eax@3
  void *result; // eax@4

  v3 = 0;
  if ( a1 >= 3u || (unsigned __int8)a2 >= 0x13u )
  {
    result = 0;
  }
  else
  {
    v4 = sub_1002ACB0(a2);
    switch ( a3 )
    {
      case 6:
        result = *(&off_100A57C4 + a1 + 16 * v4);
        break;
      case 0:
        result = *(&off_100A57D0 + a1 + 16 * v4);
        break;
      case 1:
        result = *(&off_100A57DC + a1 + 16 * v4);
        break;
      case 2:
        result = *(&off_100A57E8 + a1 + 16 * v4);
        break;
      case 3:
        result = *(&off_100A57F4 + a1 + 16 * v4);
        break;
      case 5:
        v3 = &unk_100A505C;
        goto LABEL_10;
      default:
LABEL_10:
        result = v3;
        break;
    }
  }
  return result;
}
// 100A57C4: using guessed type void *off_100A57C4;
// 100A57D0: using guessed type void *off_100A57D0;
// 100A57DC: using guessed type void *off_100A57DC;
// 100A57E8: using guessed type void *off_100A57E8;
// 100A57F4: using guessed type void *off_100A57F4;

//----- (1002AF60) --------------------------------------------------------
char sub_1002AF60()
{
  return 1;
}

//----- (1002AF70) --------------------------------------------------------
int __cdecl sub_1002AF70(char a1)
{
  return sub_1001DC80(&a1, 1u, (int)byte_100A5EF8, 8, 2, 2);
}

//----- (1002AF90) --------------------------------------------------------
char __cdecl sub_1002AF90(unsigned __int8 a1)
{
  char result; // al@1

  result = 67;
  if ( a1 < 2u )
    result = byte_100A5EF8[8 * a1];
  return result;
}

//----- (1002AFB0) --------------------------------------------------------
BOOL __cdecl sub_1002AFB0(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_10009740(a1);
  return sub_10010C50(0, 604, a2) && sub_100105A0(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (1002B010) --------------------------------------------------------
int __usercall sub_1002B010@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_1002AF70(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_100A5EFC[2 * v1];
  return result;
}
// 100A5EFC: using guessed type int dword_100A5EFC[];

//----- (1002B040) --------------------------------------------------------
BOOL __cdecl sub_1002B040(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1002B010(a1);
  return sub_1004E7C0(v2, a2, 16) == 0;
}

//----- (1002B070) --------------------------------------------------------
int __cdecl sub_1002B070(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_1002B040(a1, (int)a5);
  else
    result = sub_1002AFB0(a1, a5);
  return result;
}

//----- (1002B0A0) --------------------------------------------------------
char __cdecl sub_1002B0A0(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_10010C80(1, 1947, a1, (int)&v3);
}

//----- (1002B0C0) --------------------------------------------------------
BOOL __cdecl sub_1002B0C0(int a1)
{
  return sub_1004E7C0(6792, a1, 284) == 0;
}

//----- (1002B0E0) --------------------------------------------------------
char __cdecl sub_1002B0E0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_1002B0C0((int)a5);
  else
    result = sub_1002B0A0(a5);
  return result;
}

//----- (1002B110) --------------------------------------------------------
bool __cdecl sub_1002B110(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_1001DC80(&a2, 4u, (int)&dword_100A6D70, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_1004E7C0((unsigned __int16)word_100A6D74[a1 + 6 * v3], a3, (unsigned __int16)word_100A6D78[6 * v3]) == 0;
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 100A6D70: using guessed type int dword_100A6D70;
// 100A6D74: using guessed type __int16 word_100A6D74[];
// 100A6D78: using guessed type __int16 word_100A6D78[];

//----- (1002B1A0) --------------------------------------------------------
bool __cdecl sub_1002B1A0(char a1, char a2, void *a3)
{
  int v3; // eax@1
  int v4; // esi@3
  void *v5; // edi@3
  int (__cdecl *v6)(void *, _DWORD); // esi@4
  bool result; // al@6

  v3 = sub_1001DC80(&a1, 1u, (int)&unk_100A6DAC, 8, 2, 2);
  if ( v3 >= 2 || (unsigned __int8)a2 >= 3u )
  {
    result = 0;
  }
  else
  {
    v4 = (unsigned __int8)a2;
    v5 = a3;
    result = 0;
    if ( sub_10010C50(0, (unsigned __int16)word_100A6DAE[(unsigned __int8)a2 + 4 * v3], a3) )
    {
      v6 = (int (__cdecl *)(void *, _DWORD))dword_100A6DBC[v4];
      if ( !v6 || !v6(v5, 0) )
        result = 1;
    }
  }
  return result;
}
// 100A6DAE: using guessed type __int16 word_100A6DAE[];
// 100A6DBC: using guessed type int dword_100A6DBC[];

//----- (1002B220) --------------------------------------------------------
char __usercall sub_1002B220@<al>(void *a1@<eax>, int a2)
{
  sub_100106F0(0, 417, a1, 0, 20, 1);
  return sub_100108A0(0, 417, a2);
}

//----- (1002B250) --------------------------------------------------------
bool __cdecl sub_1002B250(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_1003D3C0(a1);
  v6 = sub_1001DC80(&a3, 1u, (int)&unk_100A6D94, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_1001DC80(&dword_100A6D98[2 * v6], 4u, (int)&dword_100A6D70, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_100A6D78[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_1002B110(v11, *(int *)((char *)&dword_100A6D70 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100A6D70: using guessed type int dword_100A6D70;
// 100A6D78: using guessed type __int16 word_100A6D78[];

//----- (1002B2F0) --------------------------------------------------------
char __cdecl sub_1002B2F0(int a1, char a2, void *a3)
{
  void *v3; // esi@1
  int v4; // eax@1
  __int16 v5; // cx@3
  void *v6; // ecx@7
  signed int v7; // esi@9
  int v9; // [sp+4h] [bp-18h]@5
  int v10; // [sp+8h] [bp-14h]@5
  int v11; // [sp+Ch] [bp-10h]@5
  int v12; // [sp+10h] [bp-Ch]@5
  int v13; // [sp+14h] [bp-8h]@5

  v3 = a3;
  v4 = sub_1001DC80(&a2, 1u, (int)&unk_100A6DC8, 4, 9, -1);
  if ( v4 >= 0 && (unsigned __int8)a1 <= 2u )
  {
    v5 = word_100A6DCA[2 * v4];
    if ( !v5 || v3 )
    {
      v9 = 0;
      v10 = 0;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      BYTE1(v9) = 45;
      BYTE2(v9) = a2;
      LOBYTE(v9) = a1;
      LOWORD(v10) = v5;
      if ( v5 )
        memcpy(&v11, v3, (unsigned __int16)v5);
      sub_1002B220(&v9, 0xFFFFFFF);
      LOBYTE(v4) = sub_1001A070(v6);
      if ( (_BYTE)v4 == 4 )
      {
        if ( (unsigned __int8)a1 < 2u )
        {
          LOBYTE(v4) = sub_1001A410(a1, (int)&v9);
        }
        else
        {
          v7 = 0;
          do
          {
            LOBYTE(v4) = sub_1001A2E0(v7);
            if ( (_BYTE)v4 )
              LOBYTE(v4) = sub_1001A410(v7, (int)&v9);
            ++v7;
          }
          while ( v7 < 2 );
        }
      }
    }
  }
  return v4;
}
// 100A6DCA: using guessed type __int16 word_100A6DCA[];

//----- (1002B410) --------------------------------------------------------
bool __cdecl sub_1002B410(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_1004E7C0((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (1002B450) --------------------------------------------------------
signed int __usercall sub_1002B450@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (1002B470) --------------------------------------------------------
bool __cdecl sub_1002B470(char a1, void *a2)
{
  int v2; // esi@1
  bool result; // al@5
  void *v4; // ecx@6
  int v5; // [sp+Ch] [bp-28h]@4
  char v6; // [sp+10h] [bp-24h]@2
  int v7; // [sp+24h] [bp-10h]@3
  __int16 v8; // [sp+28h] [bp-Ch]@8
  int v9; // [sp+2Ch] [bp-8h]@8

  v2 = sub_1002B450(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2
    && sub_100105A0(1, 0x6ACu, (int)&v6)
    && v7 == v2
    && sub_10010C80(1, 1708, a2, (int)&v5) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_1002B410(a1, a2);
  }
  else
  {
    v9 = sub_1001B4A0(v4);
    v8 = 1708;
    sub_100106F0(1, 0, &v8, 0, 8, 1);
    sub_100108A0(1, 0, v2);
    result = 0;
  }
  return result;
}
// 1004ECB0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1004ED00: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1002B560) --------------------------------------------------------
bool __cdecl sub_1002B560(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_1002B410(a1, a5);
  else
    result = sub_1002B470(a1, a5);
  return result;
}

//----- (1002B590) --------------------------------------------------------
BOOL __cdecl sub_1002B590(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (1002B5A0) --------------------------------------------------------
BOOL __usercall sub_1002B5A0@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_1002B590(a1) && *v2 < 3u && a2 == 24;
}

//----- (1002B5D0) --------------------------------------------------------
bool __cdecl sub_1002B5D0(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_1002B590(a1) )
    {
      v6 = 10 * v5;
      if ( sub_100233C0((unsigned __int8)byte_100A81B0[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_10010C50(1, (unsigned __int16)word_100A81A8[v6], &Tm.tm_mon) || sub_10022360((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_100431D0(a1, &v15) || v15 != dword_100A81C8[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_10010C50(1, (unsigned __int16)word_100A81AC[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 100A81A8: using guessed type __int16 word_100A81A8[];
// 100A81AC: using guessed type __int16 word_100A81AC[];
// 100A81C8: using guessed type int dword_100A81C8[];

//----- (1002B780) --------------------------------------------------------
bool __cdecl sub_1002B780(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_1002B590(a1) )
    result = sub_1004E7C0((unsigned __int16)word_100A81B2[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 100A81B2: using guessed type __int16 word_100A81B2[];

//----- (1002B7C0) --------------------------------------------------------
bool __cdecl sub_1002B7C0(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_10043120(a1);
  if ( !(unsigned __int8)sub_1002B5A0(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_1002B5D0(v9, a3, *a4, (int)a5);
  if ( sub_100233C0((unsigned __int8)byte_100A81B0[20 * v6], (bool *)&v8) && v8 && sub_1002B780(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 1002B7C0: using guessed type int var_20[7];

//----- (1002B8B0) --------------------------------------------------------
char sub_1002B8B0()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_10010C50(1, 1309, &v1) )
    sub_100228F0((int)&v1);
  return 0;
}

//----- (1002B950) --------------------------------------------------------
BOOL __cdecl sub_1002B950(int a1, int a2)
{
  return sub_1004E7C0(6455, a2, 252) == 0;
}

//----- (1002B970) --------------------------------------------------------
char __cdecl sub_1002B970(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1002B950(a1, a5);
  }
  else
  {
    result = sub_1002B8B0();
  }
  return result;
}

//----- (1002B9B0) --------------------------------------------------------
char __cdecl sub_1002B9B0(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_101F6AC0, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_1001B780("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_10019300(a1, (int)byte_101F6AC0);
    v3 = 4 * a2 - 64;
    v4 = byte_101F6AC1[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_101F6AC0[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (1002BA50) --------------------------------------------------------
bool __cdecl sub_1002BA50(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_101F6AC0, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_1001B780("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_10019300(a1, (int)byte_101F6AC0);
    v3 = (char *)&unk_101F6B60 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (1002BAD0) --------------------------------------------------------
char __cdecl sub_1002BAD0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_101F6AC0, 0, 0x890u);
  sub_10019300(a1, (int)byte_101F6AC0);
  if ( a2 > 0x10u )
  {
    sub_1001B780("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_101F6E30[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_101F6E34[2 * a2];
    result = 1;
  }
  return result;
}
// 101F6E30: using guessed type int dword_101F6E30[];
// 101F6E34: using guessed type int dword_101F6E34[];

//----- (1002BB40) --------------------------------------------------------
char __cdecl sub_1002BB40(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_10010C50(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_10010C50(0, 572, a2);
    }
    else
    {
      sub_1001B780("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_10010C50(0, 226, a2);
  }
  return result;
}

//----- (1002BBC0) --------------------------------------------------------
char __cdecl sub_1002BBC0(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_101F6AC0, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_1001B780("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1002BB40(a1, byte_101F6AC0);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_101F6AC1[v4];
    *(_BYTE *)a3 = byte_101F6AC0[v4];
  }
  return result;
}

//----- (1002BC40) --------------------------------------------------------
char __cdecl sub_1002BC40(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_101F6AC0, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_1001B780("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1002BB40(a1, byte_101F6AC0);
    v4 = (char *)&unk_101F6B60 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (1002BCC0) --------------------------------------------------------
char __cdecl sub_1002BCC0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_101F6AC0, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_1002BB40(a1, byte_101F6AC0);
    *(_DWORD *)a3 = dword_101F6E30[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_101F6E34[2 * a2];
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 101F6E30: using guessed type int dword_101F6E30[];
// 101F6E34: using guessed type int dword_101F6E34[];

//----- (1002BD30) --------------------------------------------------------
char __cdecl sub_1002BD30(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1003D600(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_1002BAD0(v6, *a4, a5);
    else
      result = sub_1002BCC0(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_1002B9B0(v6, *a4, a5);
    else
      result = sub_1002BBC0(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_1001B780("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_1002BA50(v6, *a4, a5);
    else
      result = sub_1002BC40(v6, *a4, a5);
  }
  return result;
}

//----- (1002BE40) --------------------------------------------------------
BOOL sub_1002BE40()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_10023300(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (1002BEA0) --------------------------------------------------------
char __cdecl sub_1002BEA0(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_10010C50(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_1002BE40() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_10021900((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (1002BF90) --------------------------------------------------------
BOOL __cdecl sub_1002BF90(int a1, int a2)
{
  return sub_1004E7C0(6200, a2, 60) == 0;
}

//----- (1002BFB0) --------------------------------------------------------
char __cdecl sub_1002BFB0(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1002BF90(a1, (int)a5);
  }
  else
  {
    result = sub_1002BEA0(a1, a5);
  }
  return result;
}

//----- (1002BFF0) --------------------------------------------------------
char __cdecl sub_1002BFF0(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_10010C50(2, 284, &v6) || sub_10022110((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (1002C0A0) --------------------------------------------------------
BOOL __cdecl sub_1002C0A0(int a1, int a2)
{
  return sub_1004E7C0(6169, a2, 40) == 0;
}

//----- (1002C0C0) --------------------------------------------------------
char __cdecl sub_1002C0C0(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1002C0A0(a1, a5);
  }
  else
  {
    result = sub_1002BFF0(a1, a5);
  }
  return result;
}

//----- (1002C100) --------------------------------------------------------
char __cdecl sub_1002C100(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_10010C50(2, 363, a1);
}

//----- (1002C120) --------------------------------------------------------
char __cdecl sub_1002C120(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_1004E7C0(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (1002C270) --------------------------------------------------------
bool __thiscall sub_1002C270(void *this)
{
  return (sub_1001A050(this) & 0x8000) == 0x8000;
}

//----- (1002C290) --------------------------------------------------------
char __cdecl sub_1002C290(unsigned __int8 a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-208h]@1
  char v3[453]; // [sp+3Fh] [bp-1C9h]@2

  if ( sub_1004E7C0(6444, (int)&v2, 514) == 0 )
    result = v3[a1];
  else
    result = 0;
  return result;
}
// 1002C290: using guessed type char var_1C9[453];

//----- (1002C300) --------------------------------------------------------
char __cdecl sub_1002C300(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_1002C120(a5);
      else
        result = sub_1002C100(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_1002C120(&unk_101F7350);
      else
        v7 = sub_1002C100(&unk_101F7350);
      v8 = v7;
      memcpy(a5, (char *)&unk_101F7350 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_1002C120(&unk_101F7350);
      else
        v9 = sub_1002C100(&unk_101F7350);
      v10 = v9;
      memcpy(a5, (char *)&unk_101FA258 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_1002C120(&unk_101F7350);
      else
        v11 = sub_1002C100(&unk_101F7350);
      v12 = v11;
      memcpy(a5, (char *)&unk_101FA758 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_1002C120(&unk_101F7350);
      else
        v13 = sub_1002C100(&unk_101F7350);
      v14 = v13;
      memcpy(a5, &unk_101FA800, a6);
      result = v14;
      break;
    default:
      sub_1001B780("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1002C4A0) --------------------------------------------------------
bool __cdecl sub_1002C4A0(unsigned __int8 a1)
{
  bool result; // al@2
  int v2; // [sp+4h] [bp-40Ch]@1
  char v3; // [sp+8h] [bp-408h]@2
  int v4; // [sp+408h] [bp-8h]@2

  if ( sub_10012670(a1, 67, &v2) )
  {
    sub_1004E8C0(6943, (int)&v3, 1028);
    result = v2 == v4;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002C530) --------------------------------------------------------
char __cdecl sub_1002C530(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10043800(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10043600(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10043680(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10043700(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_10043780(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (1002C640) --------------------------------------------------------
int __cdecl sub_1002C640(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001DC80(&a1, 1u, (int)&unk_100AC9A8, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_1001B780("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_100AC9AC[2 * v1];
  }
  return result;
}
// 100AC9AC: using guessed type int dword_100AC9AC[];

//----- (1002C690) --------------------------------------------------------
char __cdecl sub_1002C690(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_10019350(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_1004E7C0(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_10019370((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (1002C800) --------------------------------------------------------
int __usercall sub_1002C800@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_1002C690(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 1002C800: using guessed type int var_2C[10];

//----- (1002C840) --------------------------------------------------------
int __usercall sub_1002C840@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_1002C690(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 1002C840: using guessed type int var_14[4];

//----- (1002C880) --------------------------------------------------------
signed int sub_1002C880()
{
  return sub_1004F6B0((int)&off_100AD858);
}
// 100AD858: using guessed type char *off_100AD858;

//----- (1002C890) --------------------------------------------------------
char __cdecl sub_1002C890(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_1002C880() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_10236864 + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_10236864 + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_10236864);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10236864: using guessed type int dword_10236864;

//----- (1002C8F0) --------------------------------------------------------
char __cdecl sub_1002C8F0(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_1002C880() )
  {
    if ( (sub_1001A330(a1)
       || *(_BYTE *)(dword_10236864 + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_10236864 + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_10236864 + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10236864 + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10236864 + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10236864 + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10236864 + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10236864 + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10236864 + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10236864 + 176))
      && *(_BYTE *)(dword_10236864 + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_10236864 + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_10236864 + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_10236864 + 162) )
    {
      qmemcpy(a2, (const void *)(dword_10236864 + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10236864: using guessed type int dword_10236864;

//----- (1002CA10) --------------------------------------------------------
char __cdecl sub_1002CA10(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_1002C880() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_10236864 + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_10236864 + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_10236864 + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_10236864 + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_10236864);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10236864: using guessed type int dword_10236864;

//----- (1002CA90) --------------------------------------------------------
char __cdecl sub_1002CA90(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_1001B780("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_1002C840(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_1002CA10(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_1001B780("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_1002C800(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_1002C890(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_1001B780("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_1002C690(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_1002C8F0(v6, a5);
        }
      }
      else
      {
        sub_1001B780("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_1001B780("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1002CC40) --------------------------------------------------------
char __cdecl sub_1002CC40(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_1001B780("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_10010C80(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_10010C80(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_10022F20((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_101FA828, (char *)&v6 + 1, 0x20u);
      byte_101FA820 = 1;
      byte_101FA821 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_101FA848, (char *)&v6 + 1, 0x20u);
    byte_101FA821 = 1;
    byte_101FA822 = 1;
    return result;
  }
  return 0;
}
// 101FA820: using guessed type char byte_101FA820;
// 101FA821: using guessed type char byte_101FA821;
// 101FA822: using guessed type char byte_101FA822;

//----- (1002CD70) --------------------------------------------------------
char __cdecl sub_1002CD70(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_100192B0(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_1001B780("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (1002CDF0) --------------------------------------------------------
bool __cdecl sub_1002CDF0(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_101FA820 == 0;
    qmemcpy(a1, &unk_101FA828, 0x40u);
    result = !v1 && byte_101FA822;
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 101FA820: using guessed type char byte_101FA820;
// 101FA822: using guessed type char byte_101FA822;

//----- (1002CE40) --------------------------------------------------------
char __cdecl sub_1002CE40(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_1001B780("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_1001FC40(15);
    v3 = 555;
  }
  else
  {
    result = sub_1001FC40(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_101FA821 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_100106F0(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 1004ED00: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 101FA821: using guessed type char byte_101FA821;

//----- (1002CF20) --------------------------------------------------------
__int16 __usercall sub_1002CF20@<ax>(unsigned __int8 a1@<al>)
{
  return word_100AD978[a1];
}
// 100AD978: using guessed type __int16 word_100AD978[];

//----- (1002CF30) --------------------------------------------------------
char __cdecl sub_1002CF30(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  unsigned int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_1002CF20(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_100106F0(1, v3, &v5, 1, (v5 >> 16) + 4, 1);
  return sub_100108A0(1, v3, 0xFFFFFFF);
}

//----- (1002CFC0) --------------------------------------------------------
char __cdecl sub_1002CFC0(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_1001B780("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_101FA821 != 0 ? 25 : 11;
      sub_1002CF30(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_1002CF30(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 101FA821: using guessed type char byte_101FA821;

//----- (1002D080) --------------------------------------------------------
bool __cdecl sub_1002D080(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_1002CD70(a1, (int)a5);
    return 1;
  }
  if ( byte_101FA821 )
  {
    if ( sub_1002CC40(a1, &v6, 1) )
    {
LABEL_14:
      byte_101FA823 = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_101FA823 >= 5u )
    {
      byte_101FA820 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_1002CC40(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_101FA823 >= 5u )
    {
      byte_101FA822 = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_1002CD70(a1, (int)&v6);
    sub_1002CE40(a1, (int)&v6);
  }
  sub_1002CFC0(a1, 11);
  return sub_1002CDF0(a5);
}
// 1004ED00: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 101FA820: using guessed type char byte_101FA820;
// 101FA821: using guessed type char byte_101FA821;
// 101FA822: using guessed type char byte_101FA822;
// 101FA823: using guessed type char byte_101FA823;

//----- (1002D180) --------------------------------------------------------
int __cdecl sub_1002D180(char a1, void *a2)
{
  _BYTE *v2; // esi@3
  char v3; // al@3

  if ( a1 )
  {
    if ( a1 != 1 )
      return 0;
    v2 = a2;
    v3 = sub_10010C50(6, 14, a2);
  }
  else
  {
    v2 = a2;
    v3 = sub_10010C50(6, 11, a2);
  }
  if ( v3 && v2[24] )
    return 1;
  return 0;
}

//----- (1002D1C0) --------------------------------------------------------
char __thiscall sub_1002D1C0(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_101FA868 = sub_1001A070(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_101FA870, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_101FA870;
  do
  {
    result = sub_10019280(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 101FA868: using guessed type int dword_101FA868;

//----- (1002D230) --------------------------------------------------------
char __usercall sub_1002D230@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_10010C20(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_10010C20(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (1002D270) --------------------------------------------------------
void *__usercall sub_1002D270@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_101FA868 == 1379255385 )
    goto LABEL_4;
  v4 = sub_1004E6D0(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_101FA870 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_10019280(a1, (int)&unk_101FA870 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy(a4, (char *)&unk_101FA870 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2, (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_101FA868 != 1379255385 )
    result = (void *)sub_1004E6A0(v4, 86);
  return result;
}
// 101FA868: using guessed type int dword_101FA868;

//----- (1002D310) --------------------------------------------------------
char __cdecl sub_1002D310(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_1002D230(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (1002D350) --------------------------------------------------------
bool __cdecl sub_1002D350(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_1002D270(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (1002D3B0) --------------------------------------------------------
char __cdecl sub_1002D3B0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_1002D230(a2, 1, a3, a1);
  return result;
}

//----- (1002D3F0) --------------------------------------------------------
char __cdecl sub_1002D3F0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_1002D270(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (1002D420) --------------------------------------------------------
char __cdecl sub_1002D420(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_1002D230(a2 + 10, 1, a3, a1);
  return result;
}

//----- (1002D460) --------------------------------------------------------
char __cdecl sub_1002D460(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_1002D270(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (1002D4A0) --------------------------------------------------------
char __cdecl sub_1002D4A0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_1002D230(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (1002D4E0) --------------------------------------------------------
bool __cdecl sub_1002D4E0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_1002D270(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (1002D530) --------------------------------------------------------
char __cdecl sub_1002D530(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_1002D230(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (1002D570) --------------------------------------------------------
bool __cdecl sub_1002D570(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_1002D270(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (1002D5B0) --------------------------------------------------------
char __cdecl sub_1002D5B0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_1002D230(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (1002D5F0) --------------------------------------------------------
bool __cdecl sub_1002D5F0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_1002D270(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (1002D630) --------------------------------------------------------
char __cdecl sub_1002D630(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1002D230(1229, 1, a2, a1);
  return result;
}

//----- (1002D660) --------------------------------------------------------
char __cdecl sub_1002D660(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1002D270(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (1002D690) --------------------------------------------------------
char __cdecl sub_1002D690(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1002D230(1212, 16, a2, a1);
  return result;
}

//----- (1002D6C0) --------------------------------------------------------
char __cdecl sub_1002D6C0(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1002D270(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002D6F0) --------------------------------------------------------
char __cdecl sub_1002D6F0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1002D230(2400, 65, a2, a1);
  return result;
}

//----- (1002D720) --------------------------------------------------------
char __cdecl sub_1002D720(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1002D270(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002D750) --------------------------------------------------------
char __cdecl sub_1002D750(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_1002D230(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (1002D790) --------------------------------------------------------
char __cdecl sub_1002D790(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_1002D270(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (1002D7E0) --------------------------------------------------------
char __cdecl sub_1002D7E0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_1002D230(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (1002D820) --------------------------------------------------------
char __cdecl sub_1002D820(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_1002D270(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (1002D850) --------------------------------------------------------
char __cdecl sub_1002D850(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1002D230(22, 1, a2, a1);
  return result;
}

//----- (1002D880) --------------------------------------------------------
char __cdecl sub_1002D880(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1002D230(832, 4, a2, a1);
  return result;
}

//----- (1002D8B0) --------------------------------------------------------
char __cdecl sub_1002D8B0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1002D270(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (1002D8E0) --------------------------------------------------------
char __cdecl sub_1002D8E0(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10023050(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_1002D790(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_1002D750(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_1002D820(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_1002D7E0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_1002D350(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002D310(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_1002D570(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002D530(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_1002D5F0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002D5B0(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_1002D3F0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002D3B0(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_1002D460(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002D420(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_1002D850(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_1002D6C0(v6, a5);
        else
          result = sub_1002D690(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_1002D4E0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002D4A0(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1002D720(v6, a5);
        else
          result = sub_1002D6F0(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1002D660(v6, a5);
        else
          result = sub_1002D630(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1002D8B0(v6, a5);
        else
          result = sub_1002D880(v6, a5);
        break;
      default:
        sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 1004ED00: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1002DC80) --------------------------------------------------------
BOOL __cdecl sub_1002DC80(int a1)
{
  return sub_1004E7C0(6468, a1, 288) == 0;
}

//----- (1002DCA0) --------------------------------------------------------
char __cdecl sub_1002DCA0(int a1)
{
  char v1; // bl@1
  char v3; // [sp+4h] [bp-144h]@2
  char v4; // [sp+10h] [bp-138h]@2
  char v5; // [sp+24h] [bp-124h]@1
  char v6; // [sp+30h] [bp-118h]@2

  v1 = sub_1002DC80((int)&v5);
  if ( v1 )
  {
    sub_10020640((int)&v3, &v5, 12);
    sub_10020640((int)&v4, &v6, 20);
    sub_100106F0(2, 378, &v3, 0, 32, 1);
    sub_100108A0(2, 378, a1);
  }
  return v1;
}

//----- (1002DD30) --------------------------------------------------------
int __cdecl sub_1002DD30(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0x33u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_100B2664 + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_100B266C + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_100B2674 + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_100B267C + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_100B2684 + a1 + 11 * a2);
        break;
      default:
        sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 189, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 100B2664: using guessed type void *off_100B2664;
// 100B266C: using guessed type void *off_100B266C;
// 100B2674: using guessed type void *off_100B2674;
// 100B267C: using guessed type void *off_100B267C;
// 100B2684: using guessed type void *off_100B2684;

//----- (1002DE00) --------------------------------------------------------
int __cdecl sub_1002DE00(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  unsigned __int8 v4; // cl@2
  int result; // eax@8
  int v6; // [sp-Ch] [bp-7Ch]@13
  char v7; // [sp-8h] [bp-78h]@13
  char v8; // [sp+8h] [bp-68h]@6

  if ( a1 >= 2u || (v4 = a2, a2 >= 0xAu) || a3 >= 4u )
  {
LABEL_22:
    result = 0;
  }
  else if ( a3 == 1 )
  {
    if ( !a2 )
    {
      _snprintf(&v8, 0x64u, "INVALID CONFIG: anlg_in chnl %d - format %d", 0, 1);
      sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 265, 0, &v8);
      v4 = 0;
    }
    switch ( a4 )
    {
      case 6:
        result = (int)*(&off_100B2F28 + a1 + 10 * v4);
        break;
      case 0:
        result = (int)*(&off_100B2F30 + a1 + 10 * v4);
        break;
      case 1:
        result = (int)*(&off_100B2F38 + a1 + 10 * v4);
        break;
      case 2:
        result = (int)*(&off_100B2F40 + a1 + 10 * v4);
        break;
      case 3:
        result = (int)*(&off_100B2F48 + a1 + 10 * v4);
        break;
      default:
        v7 = 0;
        v6 = 292;
        goto LABEL_21;
    }
  }
  else
  {
    switch ( a4 )
    {
      case 6:
        result = (int)*(&off_100B30B8 + a1 + 10 * a3);
        break;
      case 0:
        result = (int)*(&off_100B30C0 + a1 + 10 * a3);
        break;
      case 1:
        result = (int)*(&off_100B30C8 + a1 + 10 * a3);
        break;
      case 2:
        result = (int)*(&off_100B30D0 + a1 + 10 * a3);
        break;
      case 3:
        result = (int)*(&off_100B30D8 + a1 + 10 * a3);
        break;
      default:
        v7 = 0;
        v6 = 322;
LABEL_21:
        sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", v6, v7, 0);
        goto LABEL_22;
    }
  }
  return result;
}
// 100B2F28: using guessed type void *off_100B2F28;
// 100B2F30: using guessed type void *off_100B2F30;
// 100B2F38: using guessed type void *off_100B2F38;
// 100B2F40: using guessed type void *off_100B2F40;
// 100B2F48: using guessed type void *off_100B2F48;
// 100B30B8: using guessed type void *off_100B30B8;
// 100B30C0: using guessed type void *off_100B30C0;
// 100B30C8: using guessed type void *off_100B30C8;
// 100B30D0: using guessed type void *off_100B30D0;
// 100B30D8: using guessed type void *off_100B30D8;

//----- (1002E0A0) --------------------------------------------------------
int __cdecl sub_1002E0A0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0xBu )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_100B3158 + a1 + 10 * a2);
        break;
      case 0:
        result = (int)*(&off_100B3160 + a1 + 10 * a2);
        break;
      case 1:
        result = (int)*(&off_100B3168 + a1 + 10 * a2);
        break;
      case 2:
        result = (int)*(&off_100B3170 + a1 + 10 * a2);
        break;
      case 3:
        result = (int)*(&off_100B3178 + a1 + 10 * a2);
        break;
      default:
        sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 407, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 100B3158: using guessed type void *off_100B3158;
// 100B3160: using guessed type void *off_100B3160;
// 100B3168: using guessed type void *off_100B3168;
// 100B3170: using guessed type void *off_100B3170;
// 100B3178: using guessed type void *off_100B3178;

//----- (1002E170) --------------------------------------------------------
int __cdecl sub_1002E170(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 8u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_100B3314 + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_100B331C + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_100B3324 + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_100B332C + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_100B3334 + a1 + 11 * a2);
        break;
      default:
        sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 606, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 100B3314: using guessed type void *off_100B3314;
// 100B331C: using guessed type void *off_100B331C;
// 100B3324: using guessed type void *off_100B3324;
// 100B332C: using guessed type void *off_100B332C;
// 100B3334: using guessed type void *off_100B3334;

//----- (1002E240) --------------------------------------------------------
int __cdecl sub_1002E240(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 3u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_100B3470 + a1 + 10 * a2);
        break;
      case 0:
        result = (int)*(&off_100B3478 + a1 + 10 * a2);
        break;
      case 1:
        result = (int)*(&off_100B3480 + a1 + 10 * a2);
        break;
      case 2:
        result = (int)*(&off_100B3488 + a1 + 10 * a2);
        break;
      case 3:
        result = (int)*(&off_100B3490 + a1 + 10 * a2);
        break;
      default:
        sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 689, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 100B3470: using guessed type void *off_100B3470;
// 100B3478: using guessed type void *off_100B3478;
// 100B3480: using guessed type void *off_100B3480;
// 100B3488: using guessed type void *off_100B3488;
// 100B3490: using guessed type void *off_100B3490;

//----- (1002E310) --------------------------------------------------------
int __cdecl sub_1002E310(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100B34E8 + a1);
        break;
      case 0:
        result = (int)*(&off_100B34F0 + a1);
        break;
      case 1:
        result = (int)*(&off_100B34F8 + a1);
        break;
      case 2:
        result = (int)*(&off_100B3500 + a1);
        break;
      case 3:
        result = (int)*(&off_100B3508 + a1);
        break;
      default:
        sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 768, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 100B34E8: using guessed type void *off_100B34E8;
// 100B34F0: using guessed type void *off_100B34F0;
// 100B34F8: using guessed type void *off_100B34F8;
// 100B3500: using guessed type void *off_100B3500;
// 100B3508: using guessed type void *off_100B3508;

//----- (1002E3A0) --------------------------------------------------------
int __cdecl sub_1002E3A0(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100B3510 + a1);
        break;
      case 0:
        result = (int)*(&off_100B3518 + a1);
        break;
      case 1:
        result = (int)*(&off_100B3520 + a1);
        break;
      case 2:
        result = (int)*(&off_100B3528 + a1);
        break;
      case 3:
        result = (int)*(&off_100B3530 + a1);
        break;
      default:
        sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 847, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 100B3510: using guessed type void *off_100B3510;
// 100B3518: using guessed type void *off_100B3518;
// 100B3520: using guessed type void *off_100B3520;
// 100B3528: using guessed type void *off_100B3528;
// 100B3530: using guessed type void *off_100B3530;

//----- (1002E430) --------------------------------------------------------
int __cdecl sub_1002E430(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100B3538 + a1);
        break;
      case 0:
        result = (int)*(&off_100B3540 + a1);
        break;
      case 1:
        result = (int)*(&off_100B3548 + a1);
        break;
      case 2:
        result = (int)*(&off_100B3550 + a1);
        break;
      case 3:
        result = (int)*(&off_100B3558 + a1);
        break;
      default:
        sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 927, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 100B3538: using guessed type void *off_100B3538;
// 100B3540: using guessed type void *off_100B3540;
// 100B3548: using guessed type void *off_100B3548;
// 100B3550: using guessed type void *off_100B3550;
// 100B3558: using guessed type void *off_100B3558;

//----- (1002E4C0) --------------------------------------------------------
char __cdecl sub_1002E4C0(unsigned __int8 a1)
{
  char result; // al@2

  if ( a1 < 0x31u )
  {
    result = byte_100B3560[44 * a1];
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 968, 0, 0);
    result = 16;
  }
  return result;
}

//----- (1002E4F0) --------------------------------------------------------
char __cdecl sub_1002E4F0(unsigned __int8 a1)
{
  char result; // al@2

  if ( a1 < 0x31u )
  {
    result = byte_100B3562[44 * a1];
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1004, 0, 0);
    result = 4;
  }
  return result;
}

//----- (1002E520) --------------------------------------------------------
char __cdecl sub_1002E520(unsigned __int8 a1)
{
  char result; // al@2

  if ( a1 < 0x31u )
  {
    result = byte_100B3561[44 * a1];
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1038, 0, 0);
    result = 5;
  }
  return result;
}

//----- (1002E550) --------------------------------------------------------
int __cdecl sub_1002E550(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0x31u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_100B3564 + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_100B356C + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_100B3574 + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_100B357C + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_100B3584 + a1 + 11 * a2);
        break;
      default:
        sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1118, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 100B3564: using guessed type void *off_100B3564;
// 100B356C: using guessed type void *off_100B356C;
// 100B3574: using guessed type void *off_100B3574;
// 100B357C: using guessed type void *off_100B357C;
// 100B3584: using guessed type void *off_100B3584;

//----- (1002E620) --------------------------------------------------------
char __cdecl sub_1002E620(unsigned __int8 a1)
{
  char result; // al@2

  if ( a1 < 0x1Du )
  {
    result = byte_100B3DD0[44 * a1];
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1158, 0, 0);
    result = 16;
  }
  return result;
}

//----- (1002E650) --------------------------------------------------------
char __cdecl sub_1002E650(unsigned __int8 a1)
{
  char result; // al@2

  if ( a1 < 0x1Du )
  {
    result = byte_100B3DD2[44 * a1];
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1194, 0, 0);
    result = 4;
  }
  return result;
}

//----- (1002E680) --------------------------------------------------------
char __cdecl sub_1002E680(unsigned __int8 a1)
{
  char result; // al@2

  if ( a1 < 0x1Du )
  {
    result = byte_100B3DD1[44 * a1];
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1228, 0, 0);
    result = 5;
  }
  return result;
}

//----- (1002E6B0) --------------------------------------------------------
int __cdecl sub_1002E6B0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0x1Du )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_100B3DD4 + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_100B3DDC + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_100B3DE4 + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_100B3DEC + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_100B3DF4 + a1 + 11 * a2);
        break;
      default:
        sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1308, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 100B3DD4: using guessed type void *off_100B3DD4;
// 100B3DDC: using guessed type void *off_100B3DDC;
// 100B3DE4: using guessed type void *off_100B3DE4;
// 100B3DEC: using guessed type void *off_100B3DEC;
// 100B3DF4: using guessed type void *off_100B3DF4;

//----- (1002E780) --------------------------------------------------------
int __cdecl sub_1002E780(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100B42F4 + a1);
        break;
      case 0:
        result = (int)*(&off_100B42FC + a1);
        break;
      case 1:
        result = (int)*(&off_100B4304 + a1);
        break;
      case 2:
        result = (int)*(&off_100B430C + a1);
        break;
      case 3:
        result = (int)*(&off_100B4314 + a1);
        break;
      default:
        sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1466, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 100B42F4: using guessed type void *off_100B42F4;
// 100B42FC: using guessed type void *off_100B42FC;
// 100B4304: using guessed type void *off_100B4304;
// 100B430C: using guessed type void *off_100B430C;
// 100B4314: using guessed type void *off_100B4314;

//----- (1002E810) --------------------------------------------------------
int __cdecl sub_1002E810(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100B431C + a1);
        break;
      case 0:
        result = (int)*(&off_100B4324 + a1);
        break;
      case 1:
        result = (int)*(&off_100B432C + a1);
        break;
      case 2:
        result = (int)*(&off_100B4334 + a1);
        break;
      case 3:
        result = (int)*(&off_100B433C + a1);
        break;
      default:
        sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1545, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 100B431C: using guessed type void *off_100B431C;
// 100B4324: using guessed type void *off_100B4324;
// 100B432C: using guessed type void *off_100B432C;
// 100B4334: using guessed type void *off_100B4334;
// 100B433C: using guessed type void *off_100B433C;

//----- (1002E8A0) --------------------------------------------------------
int __cdecl sub_1002E8A0(int a1, unsigned __int8 a2, char a3)
{
  int result; // eax@3

  if ( a2 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = *(_DWORD *)(a1 + 4 * a2);
        break;
      case 0:
        result = *(_DWORD *)(a1 + 4 * a2 + 8);
        break;
      case 1:
        result = *(_DWORD *)(a1 + 4 * a2 + 16);
        break;
      case 2:
        result = *(_DWORD *)(a1 + 4 * a2 + 24);
        break;
      case 3:
        result = *(_DWORD *)(a1 + 4 * a2 + 32);
        break;
      default:
        sub_1001B780("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1627, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}

//----- (1002E940) --------------------------------------------------------
int __cdecl sub_1002E940(unsigned __int8 a1, char a2)
{
  return sub_1002E8A0((int)&off_100B436C, a1, a2);
}
// 100B436C: using guessed type void *off_100B436C;

//----- (1002E960) --------------------------------------------------------
int __cdecl sub_1002E960(unsigned __int8 a1, char a2)
{
  return sub_1002E8A0((int)&off_100B4344, a1, a2);
}
// 100B4344: using guessed type void *off_100B4344;

//----- (1002E980) --------------------------------------------------------
char __cdecl sub_1002E980(char a1)
{
  char result; // al@3

  if ( a1 == 46 )
  {
    result = 0;
  }
  else if ( a1 == 47 )
  {
    result = 1;
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\iop\\grs\\iop_grs_cnfg_intf.c", 121, 0, 0);
    result = 2;
  }
  return result;
}

//----- (1002E9C0) --------------------------------------------------------
bool __cdecl sub_1002E9C0(unsigned __int8 a1, unsigned int a2)
{
  bool result; // al@4

  if ( a1 < 2u && a2 < 0xFFFFFFC2 && a2 )
  {
    result = sub_1004E7C0((unsigned __int16)word_100B4414[a1], a2, 144) == 0;
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\iop\\grs\\iop_grs_cnfg_intf.c", 229, 0, 0);
    result = 0;
  }
  return result;
}
// 100B4414: using guessed type __int16 word_100B4414[];

//----- (1002EA20) --------------------------------------------------------
char __cdecl sub_1002EA20(unsigned __int8 a1, int *a2, const void *a3)
{
  char result; // al@6
  unsigned int v4; // [sp+10h] [bp-98h]@6
  char v5; // [sp+14h] [bp-94h]@6

  if ( a1 < 2u && (unsigned int)a2 < 0xFFFFFFC2 && a2 && (unsigned int)a3 < 0xFFFFFFC2 && a3 )
  {
    memset(&v4, 0, 0x94u);
    v4 = *a2;
    qmemcpy(&v5, a3, 0x90u);
    sub_100106F0(6, (unsigned __int16)word_100B4418[a1], &v4, 1, (v4 >> 16) + 4, 1);
    result = sub_100108A0(6, (unsigned __int16)word_100B4418[a1], 0xFFFFFFF);
  }
  else
  {
    result = sub_1001B780("..\\lib\\acl\\iop\\grs\\iop_grs_cnfg_intf.c", 315, 0, 0);
  }
  return result;
}
// 100B4418: using guessed type __int16 word_100B4418[];

//----- (1002EAE0) --------------------------------------------------------
bool __cdecl sub_1002EAE0(unsigned __int8 a1, unsigned int a2)
{
  bool result; // al@4

  if ( a1 < 2u && a2 < 0xFFFFFFC2 && a2 )
  {
    result = sub_1004E8F0((unsigned __int16)word_100B4414[a1], a2, 144) == 0;
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\iop\\grs\\iop_grs_cnfg_intf.c", 364, 0, 0);
    result = 0;
  }
  return result;
}
// 100B4414: using guessed type __int16 word_100B4414[];

//----- (1002EB40) --------------------------------------------------------
char __cdecl sub_1002EB40(char a1, _BYTE *a2, _BYTE *a3, char a4)
{
  _BYTE *v4; // eax@2

  if ( a1 == 1 )
  {
    v4 = a2;
    *v4 |= a4;
  }
  else
  {
    LOBYTE(v4) = a1 - 2;
    if ( a1 == 2 )
    {
      *a2 = a4;
      if ( a4 )
      {
        LOBYTE(v4) = *a3 == 0;
        *a2 = (_BYTE)v4;
      }
      else
      {
        LOBYTE(v4) = (_BYTE)a3;
        *a3 = 1;
      }
    }
  }
  return (unsigned int)v4;
}

//----- (1002EB80) --------------------------------------------------------
char __thiscall sub_1002EB80(void *this)
{
  char result; // al@2

  switch ( sub_1001B4A0(this) )
  {
    case 4:
    case 128:
      result = 1;
      break;
    case 2:
    case 16:
      result = 2;
      break;
    case 32:
      result = 3;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (1002EC40) --------------------------------------------------------
void __usercall sub_1002EC40(unsigned __int16 a1@<bx>, unsigned __int16 *a2@<edi>, int a3, int a4, char a5, int a6)
{
  int v6; // esi@2
  int v7; // eax@3

  if ( a2 )
  {
    v6 = 0;
    if ( *a2 < a1 )
    {
      v7 = (int)a2;
      do
      {
        if ( *(_WORD *)(a6 + 2 * *(_WORD *)v7) < a1 )
          sub_1002EB40(
            *(_BYTE *)(v7 + 2),
            (_BYTE *)(a3 + *(_WORD *)(a6 + 2 * *(_WORD *)v7)),
            (_BYTE *)(*(_WORD *)v7 + a4),
            a5);
        v7 = (int)&a2[2 * ++v6];
      }
      while ( a2[2 * v6] < a1 );
    }
  }
}

//----- (1002ECA0) --------------------------------------------------------
char __cdecl sub_1002ECA0(char a1)
{
  void *v1; // ecx@0
  char result; // al@2
  bool v3; // zf@3
  void *v4; // [sp-2h] [bp-4h]@1

  v4 = v1;
  BYTE3(v4) = 1;
  if ( sub_1001A070(v1) == 2 )
  {
    result = 1;
  }
  else
  {
    v3 = (unsigned __int8)sub_10009800(a1, (char *)&v4 + 3) == 1;
    result = 1;
    if ( v3 )
      result = BYTE3(v4);
  }
  return result;
}
// 10009800: using guessed type _DWORD __cdecl sub_10009800(char, _DWORD);

//----- (1002ECE0) --------------------------------------------------------
char __usercall sub_1002ECE0@<al>(void *a1@<ecx>, int a2@<esi>)
{
  char v2; // bl@1
  char v3; // al@1

  v2 = 0;
  v3 = sub_1001A070(a1);
  if ( v3 == 2 || v3 == 4 )
  {
    if ( j_HWM_pvg_read_reg(1) )
    {
      v2 = 1;
      memset((void *)a2, 0, 0x74u);
      *(_DWORD *)(a2 + 108) = 5;
      *(_DWORD *)(a2 + 112) = 15;
    }
  }
  return v2;
}
// 1004ED00: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1002ED20) --------------------------------------------------------
char __cdecl sub_1002ED20(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ebp@1
  int v6; // esi@1
  signed int v7; // edi@1
  void *v8; // eax@3
  __int16 v9; // cx@8
  __int16 v10; // cx@11
  __int16 v11; // cx@14
  __int16 v12; // cx@17
  int v13; // esi@23
  signed int v14; // edi@23
  void *v15; // eax@25
  __int16 v16; // cx@30
  __int16 v17; // cx@33
  __int16 v18; // cx@36
  __int16 v19; // cx@39
  void *v20; // ecx@45
  int v21; // eax@45
  char v22; // si@46
  signed int v23; // eax@46
  void *v24; // ecx@46
  int v25; // ST18_4@48
  int v26; // ST10_4@48
  unsigned __int16 *v27; // eax@48
  int v28; // ST18_4@48
  int v29; // ST10_4@48
  unsigned __int16 *v30; // eax@48
  int v31; // ecx@48
  int v32; // ST18_4@49
  int v33; // ST10_4@49
  unsigned __int16 *v34; // eax@49
  int v35; // ST18_4@51
  int v36; // ST10_4@51
  unsigned __int16 *v37; // eax@51
  char v38; // al@52
  char v39; // bp@52
  signed int v40; // ecx@52
  char v41; // al@53
  int v42; // ST18_4@54
  int v43; // ST10_4@54
  int v44; // ST0C_4@54
  unsigned __int16 *v45; // eax@54
  char v46; // al@55
  int v47; // ST18_4@56
  int v48; // ST10_4@56
  int v49; // ST0C_4@56
  unsigned __int16 *v50; // eax@56
  signed int v51; // ebp@58
  char v52; // di@60
  char v53; // al@60
  int v54; // ST18_4@60
  char v55; // ST14_1@60
  int v56; // ST10_4@60
  int v57; // ST0C_4@60
  unsigned __int16 *v58; // eax@60
  signed int v59; // edi@66
  void *v60; // ecx@66
  int i; // edi@67
  unsigned __int16 v62; // ax@68
  char v63; // al@75
  char v64; // al@75
  int v65; // ST18_4@75
  char v66; // ST14_1@75
  int v67; // ST10_4@75
  unsigned __int16 *v68; // eax@75
  char result; // al@75
  char v70; // [sp+13h] [bp-49h]@62
  int v71; // [sp+14h] [bp-48h]@1
  int v72; // [sp+18h] [bp-44h]@1
  int v73; // [sp+1Ch] [bp-40h]@1
  int v74; // [sp+20h] [bp-3Ch]@1
  int v75; // [sp+24h] [bp-38h]@52
  unsigned __int16 v76; // [sp+28h] [bp-34h]@62
  int v77; // [sp+2Ch] [bp-30h]@1
  int v78; // [sp+30h] [bp-2Ch]@52
  int v79; // [sp+34h] [bp-28h]@45
  int v80; // [sp+38h] [bp-24h]@60
  int v81; // [sp+3Ch] [bp-20h]@1
  int v82; // [sp+40h] [bp-1Ch]@1
  int v83; // [sp+44h] [bp-18h]@1
  int v84; // [sp+48h] [bp-14h]@1
  int v85; // [sp+4Ch] [bp-10h]@1
  int v86; // [sp+50h] [bp-Ch]@1

  v5 = a3;
  v73 = a4;
  v74 = a3;
  v72 = a5;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v84 = 0;
  v85 = 0;
  v86 = 0;
  memset(word_101FC850, 0, 0xFA0u);
  v6 = 0;
  v71 = -1;
  v77 = 0;
  v7 = 0;
  do
  {
    if ( sub_1004E7C0(v7 + 12000, (int)&unk_101FD7F0, 16004) )
    {
      v6 += 100;
    }
    else
    {
      v8 = &unk_101FD87A;
      do
      {
        if ( *((char *)v8 - 136) && *(_WORD *)v8 )
        {
          word_101FC850[v6] = *(_WORD *)v8;
          v71 = v6;
        }
        if ( *((_BYTE *)v8 + 24) )
        {
          v9 = *((_WORD *)v8 + 80);
          if ( v9 )
          {
            word_101FC852[v6] = v9;
            v71 = v6 + 1;
          }
        }
        if ( *((_BYTE *)v8 + 184) )
        {
          v10 = *((_WORD *)v8 + 160);
          if ( v10 )
          {
            word_101FC854[v6] = v10;
            v71 = v6 + 2;
          }
        }
        if ( *((_BYTE *)v8 + 344) )
        {
          v11 = *((_WORD *)v8 + 240);
          if ( v11 )
          {
            word_101FC856[v6] = v11;
            v71 = v6 + 3;
          }
        }
        if ( *((_BYTE *)v8 + 504) )
        {
          v12 = *((_WORD *)v8 + 320);
          if ( v12 )
          {
            word_101FC858[v6] = v12;
            v71 = v6 + 4;
          }
        }
        v8 = (char *)v8 + 800;
        v6 += 5;
      }
      while ( (signed int)v8 < (signed int)&unk_102016FA );
    }
    ++v7;
  }
  while ( v7 < 10 );
  v13 = 0;
  v14 = 0;
  do
  {
    if ( sub_1004E7C0(v14 + 14000, (int)&unk_101FD7F0, 16004) )
    {
      v13 += 100;
    }
    else
    {
      v15 = &unk_101FD87A;
      do
      {
        if ( *((char *)v15 - 136) && *(_WORD *)v15 )
        {
          word_101FD020[v13] = *(_WORD *)v15;
          v71 = v13 + 1000;
        }
        if ( *((_BYTE *)v15 + 24) )
        {
          v16 = *((_WORD *)v15 + 80);
          if ( v16 )
          {
            word_101FD022[v13] = v16;
            v71 = v13 + 1001;
          }
        }
        if ( *((_BYTE *)v15 + 184) )
        {
          v17 = *((_WORD *)v15 + 160);
          if ( v17 )
          {
            word_101FD024[v13] = v17;
            v71 = v13 + 1002;
          }
        }
        if ( *((_BYTE *)v15 + 344) )
        {
          v18 = *((_WORD *)v15 + 240);
          if ( v18 )
          {
            word_101FD026[v13] = v18;
            v71 = v13 + 1003;
          }
        }
        if ( *((_BYTE *)v15 + 504) )
        {
          v19 = *((_WORD *)v15 + 320);
          if ( v19 )
          {
            word_101FD028[v13] = v19;
            v71 = v13 + 1004;
          }
        }
        v15 = (char *)v15 + 800;
        v13 += 5;
      }
      while ( (signed int)v15 < (signed int)&unk_102016FA );
    }
    ++v14;
  }
  while ( v14 < 10 );
  sub_10019330((int)&v77);
  v21 = sub_1001B4A0(v20);
  v77 |= v21;
  LOBYTE(v79) = 0;
  do
  {
    v22 = v79;
    v23 = sub_100194B0(v79);
    if ( v23 & v77 || sub_1001A070(v24) == 4 )
    {
      v25 = v72;
      v26 = v73;
      v27 = (unsigned __int16 *)sub_1002AAF0(v22, a1);
      sub_1002EC40(a2, v27, v5, v26, 1, v25);
      v28 = v72;
      v29 = v73;
      v30 = (unsigned __int16 *)sub_1002ACD0(*(_BYTE *)dword_1022D6E8, v22, a1);
      sub_1002EC40(a2, v30, v5, v29, 1, v28);
      if ( (unsigned __int8)sub_100438A0(v31) )
      {
        v32 = v72;
        v33 = v73;
        v34 = (unsigned __int16 *)sub_1002AA70(v22, a1);
        sub_1002EC40(a2, v34, v5, v33, 1, v32);
      }
      if ( sub_1003D870() )
      {
        v35 = v72;
        v36 = v73;
        v37 = (unsigned __int16 *)sub_1002AB70(v22, a1);
        sub_1002EC40(a2, v37, v5, v36, 1, v35);
      }
      v38 = sub_100193D0(v22);
      LOBYTE(v75) = sub_1002ECA0(v38);
      sub_10019260(v22, (int)&v81);
      v39 = v75;
      v40 = 0;
      v78 = 0;
      do
      {
        v41 = *((_BYTE *)&v84 + 4 * v40);
        if ( v41 )
        {
          v42 = v72;
          v43 = v73;
          v44 = v74;
          v45 = (unsigned __int16 *)sub_1002AE90(v22, v41, a1);
          sub_1002EC40(a2, v45, v44, v43, v39, v42);
          v40 = v78;
        }
        v46 = *((_BYTE *)&v84 + 4 * v40 + 1);
        if ( v46 )
        {
          v47 = v72;
          v48 = v73;
          v49 = v74;
          v50 = (unsigned __int16 *)sub_1002AE90(v22, v46, a1);
          sub_1002EC40(a2, v50, v49, v48, v39, v47);
          v40 = v78;
        }
        v78 = ++v40;
      }
      while ( v40 <= 1 );
      v51 = 0;
      do
      {
        if ( *((_BYTE *)&v82 + 4 * v51 + 1) )
        {
          LOBYTE(v80) = *((_BYTE *)&v82 + 4 * v51 + 1);
          v52 = v80;
          v53 = sub_10019910(v80);
          LOBYTE(v75) = sub_1002ECA0(v53);
          v54 = v72;
          v55 = v75;
          v56 = v73;
          v57 = v74;
          v58 = (unsigned __int16 *)sub_1002AD90(v22, v52, a1);
          sub_1002EC40(a2, v58, v57, v56, v55, v54);
        }
        ++v51;
      }
      while ( v51 < 2 );
      if ( sub_10042F30(HIWORD(v86), 0, &v70, &v76) == 1 && v70 == a1 && v76 < a2 )
        *(_BYTE *)(*(_WORD *)(v72 + 2 * v76) + v74) = v75;
      v59 = sub_100194B0(v22);
      if ( sub_1001B4A0(v60) == v59 )
      {
        for ( i = 0; i <= v71; ++i )
        {
          v62 = word_101FC850[i];
          if ( v62 && sub_10042F90(v62, 0, &v70, &v76) == 1 && v70 == a1 && v76 < a2 )
            *(_BYTE *)(*(_WORD *)(v72 + 2 * v76) + v74) = v75;
        }
      }
      v5 = v74;
    }
    v63 = sub_100193D0(v22);
    v64 = sub_1002ECA0(v63);
    v65 = v72;
    LOBYTE(v75) = v64;
    v66 = v64;
    v67 = v73;
    v68 = (unsigned __int16 *)sub_1002ABF0(v22, a1);
    sub_1002EC40(a2, v68, v5, v67, v66, v65);
    result = v79 + 1;
    LOBYTE(v79) = v79 + 1;
  }
  while ( (unsigned __int8)v79 < 3u );
  return result;
}
// 101FC850: using guessed type __int16 word_101FC850[];
// 101FC852: using guessed type __int16 word_101FC852[];
// 101FC854: using guessed type __int16 word_101FC854[];
// 101FC856: using guessed type __int16 word_101FC856[];
// 101FC858: using guessed type __int16 word_101FC858[];
// 101FD020: using guessed type __int16 word_101FD020[];
// 101FD022: using guessed type __int16 word_101FD022[];
// 101FD024: using guessed type __int16 word_101FD024[];
// 101FD026: using guessed type __int16 word_101FD026[];
// 101FD028: using guessed type __int16 word_101FD028[];

//----- (1002F2A0) --------------------------------------------------------
void __cdecl sub_1002F2A0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  char v5; // ST0C_1@2
  int *v6; // eax@2
  int v7; // [sp+0h] [bp-8h]@1
  int v8; // [sp+4h] [bp-4h]@1

  LOBYTE(v8) = sub_1002ECA0(31);
  sub_10019330((int)&v7);
  if ( v7 & 0x8000 )
  {
    v5 = v8;
    v6 = sub_10043BB0(a1);
    sub_1002EC40(a2, (unsigned __int16 *)v6, a3, a4, v5, a5);
  }
}

//----- (1002F300) --------------------------------------------------------
void __cdecl sub_1002F300(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  void *v5; // ecx@0
  char v6; // ST0C_1@2
  unsigned __int16 *v7; // eax@2

  if ( sub_10043C10(v5) )
  {
    v6 = sub_1002ECA0(17);
    v7 = (unsigned __int16 *)sub_100438D0(a1);
    sub_1002EC40(a2, v7, a3, a4, v6, a5);
  }
}

//----- (1002F350) --------------------------------------------------------
void __cdecl sub_1002F350(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ecx@0
  void *v6; // ecx@1
  bool v7; // al@5
  char v8; // ST0C_1@7
  unsigned __int16 *v9; // eax@7
  int v10; // [sp+0h] [bp-4h]@1

  v10 = v5;
  sub_10019330((int)&v10);
  if ( v10 & 0x1000000 || sub_1001A070(v6) == 4 )
  {
    v7 = sub_1002ECA0(50) && sub_1002ECA0(62);
    v8 = v7;
    v9 = (unsigned __int16 *)sub_10043C30(a1);
    sub_1002EC40(a2, v9, a3, a4, v8, a5);
  }
}

//----- (1002F3D0) --------------------------------------------------------
char __cdecl sub_1002F3D0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  char v6; // bp@3
  signed int v7; // eax@3
  void *v8; // ecx@3
  char v9; // al@6
  char v10; // ST18_1@6
  int v11; // ST14_4@6
  unsigned __int16 *v12; // eax@6
  int v13; // ecx@6
  char v14; // ST18_1@7
  int v15; // ST14_4@7
  unsigned __int16 *v16; // eax@7
  char v17; // ST18_1@7
  int v18; // ST14_4@7
  unsigned __int16 *v19; // eax@7
  int v20; // eax@8
  void *v21; // ecx@8
  char v22; // al@9
  char v23; // al@12
  char v24; // ST18_1@14
  int v25; // ST14_4@14
  unsigned __int16 *v26; // eax@14
  unsigned __int16 *v27; // eax@17
  char v28; // al@22
  char v29; // ST18_1@24
  int v30; // ST14_4@24
  unsigned __int16 *v31; // eax@24
  char v32; // ST18_1@25
  int v33; // ST14_4@25
  unsigned __int16 *v34; // eax@25
  signed int v35; // ecx@25
  unsigned __int8 v36; // al@26
  char v37; // ST18_1@27
  int v38; // ST14_4@27
  unsigned __int16 *v39; // eax@27
  signed int v40; // eax@29
  char v41; // ST18_1@31
  int v42; // ST14_4@31
  unsigned __int16 *v43; // eax@31
  unsigned __int16 *v44; // edi@33
  unsigned __int16 *v45; // edi@39
  __int16 *v46; // ecx@45
  char v47; // ST18_1@48
  int v48; // ST14_4@48
  unsigned __int16 *v49; // eax@48
  unsigned __int8 v50; // al@49
  char v51; // ST18_1@52
  int v52; // ST14_4@52
  unsigned __int16 *v53; // eax@52
  __int16 *v54; // eax@55
  int v55; // edi@55
  bool v56; // cf@55
  int v57; // eax@57
  _BYTE *v58; // esi@61
  unsigned __int8 v59; // di@62
  char v60; // al@62
  char v61; // ST18_1@62
  int v62; // ST14_4@62
  int v63; // ST10_4@62
  unsigned __int16 *v64; // eax@62
  _BYTE *v65; // esi@63
  unsigned __int8 v66; // di@64
  char v67; // al@64
  char v68; // ST18_1@64
  int v69; // ST14_4@64
  int v70; // ST10_4@64
  unsigned __int16 *v71; // eax@64
  unsigned __int8 v72; // di@65
  char v73; // al@65
  char v74; // ST18_1@65
  int v75; // ST14_4@65
  int v76; // ST10_4@65
  unsigned __int16 *v77; // eax@65
  char *v78; // eax@67
  unsigned __int8 v79; // di@68
  char v80; // al@68
  char v81; // al@68
  int v82; // esi@72
  char v83; // ST18_1@72
  int v84; // ST14_4@72
  int v85; // ST10_4@72
  unsigned __int16 *v86; // eax@72
  unsigned __int8 v87; // di@73
  char v88; // al@73
  char v89; // al@73
  char v90; // ST18_1@77
  int v91; // ST14_4@77
  unsigned __int16 *v92; // eax@77
  char result; // al@79
  int v94; // [sp-10h] [bp-D8h]@17
  int v95; // [sp-Ch] [bp-D4h]@17
  char v96; // [sp-8h] [bp-D0h]@17
  int v97; // [sp-4h] [bp-CCh]@17
  char v98; // [sp+17h] [bp-B1h]@1
  int v99; // [sp+18h] [bp-B0h]@12
  int v100; // [sp+1Ch] [bp-ACh]@6
  int v101; // [sp+20h] [bp-A8h]@1
  int v102; // [sp+24h] [bp-A4h]@25
  __int16 *v103; // [sp+28h] [bp-A0h]@45
  int v104; // [sp+2Ch] [bp-9Ch]@1
  int v105; // [sp+30h] [bp-98h]@1
  unsigned int v106; // [sp+34h] [bp-94h]@68
  unsigned int v107; // [sp+38h] [bp-90h]@64
  char *v108; // [sp+3Ch] [bp-8Ch]@1
  unsigned __int16 v109[2]; // [sp+40h] [bp-88h]@56
  int v110; // [sp+44h] [bp-84h]@1
  int v111; // [sp+48h] [bp-80h]@1
  unsigned int v112; // [sp+4Ch] [bp-7Ch]@62
  char v113; // [sp+50h] [bp-78h]@1
  unsigned int v114; // [sp+BCh] [bp-Ch]@16
  char v115; // [sp+C0h] [bp-8h]@10

  v5 = a3;
  v101 = a4;
  v104 = a3;
  v98 = 0;
  v111 = 0;
  v105 = 0;
  memset(&v113, 0, 0x74u);
  sub_10019330((int)&v111);
  LOBYTE(v110) = 0;
  v108 = ":#;<";
  while ( 1 )
  {
    v6 = v110;
    v7 = sub_100230D0(v110);
    if ( !(v7 & v111) )
    {
      if ( sub_1001A070(v8) != 4 )
        goto LABEL_79;
      v5 = v104;
    }
    v9 = sub_10023090(v6);
    LOBYTE(v100) = sub_1002ECA0(v9);
    memset(byte_101FBDB0, 0, 0xAA0u);
    sub_10019280(v6, (int)byte_101FBDB0);
    v10 = v100;
    v11 = v101;
    v12 = (unsigned __int16 *)sub_1002E430(v6, a1);
    sub_1002EC40(a2, v12, v5, v11, v10, a5);
    if ( (unsigned __int8)sub_100438A0(v13) )
    {
      v14 = v100;
      v15 = v101;
      v16 = (unsigned __int16 *)sub_1002E960(v6, a1);
      sub_1002EC40(a2, v16, v5, v15, v14, a5);
      v17 = v100;
      v18 = v101;
      v19 = (unsigned __int16 *)sub_1002E940(v6, a1);
      sub_1002EC40(a2, v19, v5, v18, v17, a5);
    }
    LOBYTE(v20) = sub_10023110(v6);
    if ( sub_10023300(v20, &v113) || (v22 = sub_1002ECE0(v21, (int)&v113), v5 = v104, v22) )
    {
      if ( v115 & 1 )
      {
        if ( !(_BYTE)v100 || (v23 = sub_1002ECA0(*(v108 - 1)), LOBYTE(v99) = 1, !v23) )
          LOBYTE(v99) = 0;
        v24 = v99;
        v25 = v101;
        v26 = (unsigned __int16 *)sub_1002E310(v6, a1);
        sub_1002EC40(a2, v26, v5, v25, v24, a5);
      }
      if ( v115 & 2 )
      {
        if ( v114 >= 3 )
        {
          v97 = a5;
          v96 = v100;
          v95 = v101;
          v94 = v5;
          v27 = (unsigned __int16 *)sub_1002E810(v6, a1);
        }
        else
        {
          v97 = a5;
          v96 = v100;
          v95 = v101;
          v94 = v5;
          v27 = (unsigned __int16 *)sub_1002E3A0(v6, a1);
        }
        sub_1002EC40(a2, v27, v94, v95, v96, v97);
      }
      if ( v115 & 8 )
      {
        if ( !(_BYTE)v100 || (v28 = sub_1002ECA0(*v108), LOBYTE(v99) = 1, !v28) )
          LOBYTE(v99) = 0;
        v29 = v99;
        v30 = v101;
        v31 = (unsigned __int16 *)sub_1002E780(v6, a1);
        sub_1002EC40(a2, v31, v5, v30, v29, a5);
      }
    }
    v32 = v100;
    v33 = v101;
    v34 = (unsigned __int16 *)sub_1002E240(v6, byte_101FC27C, a1);
    sub_1002EC40(a2, v34, v5, v33, v32, a5);
    v102 = 0;
    v35 = 0;
    do
    {
      v36 = byte_101FBDB0[v35];
      if ( v36 )
      {
        v37 = v100;
        v38 = v101;
        v39 = (unsigned __int16 *)sub_1002DE00(v6, v102, v36, a1);
        sub_1002EC40(a2, v39, v5, v38, v37, a5);
        v35 = v102;
      }
      v102 = ++v35;
    }
    while ( v35 < 10 );
    v40 = 0;
    v102 = 0;
    do
    {
      if ( byte_101FBDBA[v40] == 1 )
      {
        v41 = v100;
        v42 = v101;
        v43 = (unsigned __int16 *)sub_1002E0A0(v6, v102, a1);
        sub_1002EC40(a2, v43, v5, v42, v41, a5);
        v40 = v102;
      }
      v102 = ++v40;
    }
    while ( v40 < 11 );
    v44 = (unsigned __int16 *)&unk_101FBDF6;
    do
    {
      if ( sub_10042F30(*v44, v6, &v98, &v105) == 1 && v98 == a1 && (unsigned __int16)v105 < a2 )
        *(_BYTE *)(*(_WORD *)(a5 + 2 * (unsigned __int16)v105) + v5) = v100;
      v44 += 6;
    }
    while ( (signed int)v44 < (signed int)&unk_101FBFE2 );
    v45 = (unsigned __int16 *)&unk_101FBFE2;
    do
    {
      if ( sub_10042F90(*v45, v6, &v98, &v105) == 1 && v98 == a1 && (unsigned __int16)v105 < a2 )
        *(_BYTE *)(*(_WORD *)(a5 + 2 * (unsigned __int16)v105) + v5) = v100;
      v45 += 2;
    }
    while ( (signed int)v45 < (signed int)&unk_101FC08A );
    v46 = (__int16 *)&unk_101FC0D0;
    v102 = 0;
    v103 = (__int16 *)&unk_101FC0D0;
    do
    {
      if ( *(_BYTE *)v46 == 3 )
      {
        LOWORD(v102) = v46[1] | v102;
      }
      else
      {
        v47 = v100;
        v48 = v101;
        v49 = (unsigned __int16 *)sub_1002E170(v6, *(_BYTE *)v46, a1);
        sub_1002EC40(a2, v49, v5, v48, v47, a5);
        v46 = v103;
      }
      v50 = *((_BYTE *)v46 + 1);
      if ( v50 != *(_BYTE *)v46 )
      {
        if ( v50 == 3 )
        {
          LOWORD(v102) = v46[1] | v102;
        }
        else
        {
          v51 = v100;
          v52 = v101;
          v53 = (unsigned __int16 *)sub_1002E170(v6, v50, a1);
          sub_1002EC40(a2, v53, v5, v52, v51, a5);
          v46 = v103;
        }
      }
      v46 += 8;
      v103 = v46;
    }
    while ( (signed int)v46 < (signed int)&unk_101FC0F0 );
    if ( (_WORD)v102 )
    {
      v54 = (__int16 *)sub_1002E170(v6, 3u, a1);
      v55 = 0;
      v56 = (unsigned __int16)*v54 < a2;
      v103 = v54;
      if ( v56 )
      {
        do
        {
          v105 = (unsigned __int16)*v54;
          if ( !sub_1003D4A0(a1, *v54, v109)
            || (v57 = sub_1001DC80((_DWORD *)v109, 2u, (int)"<", 4, 12, 12), v57 >= 12)
            || ((unsigned __int16)v102 & (unsigned __int16)word_100B4976[2 * v57]) != 0 )
          {
            *(_BYTE *)(*(_WORD *)(a5 + 2 * (unsigned __int16)v105) + v5) = v100;
          }
          v54 = &v103[2 * ++v55];
        }
        while ( (unsigned __int16)v103[2 * v55] < a2 );
      }
    }
    v58 = &unk_101FBDC9;
    do
    {
      LOBYTE(v112) = *v58;
      v59 = v112;
      v60 = sub_100231F0(v112);
      LOBYTE(v99) = sub_1002ECA0(v60);
      v61 = v99;
      v62 = v101;
      v63 = v104;
      v64 = (unsigned __int16 *)sub_1002DD30(v6, v59, a1);
      sub_1002EC40(a2, v64, v63, v62, v61, a5);
      v58 += 4;
    }
    while ( (signed int)v58 <= (signed int)&unk_101FBDF1 );
    v65 = &unk_101FC089;
    do
    {
      LOBYTE(v107) = *(v65 - 1);
      v66 = v107;
      v67 = sub_10023220(v107);
      LOBYTE(v99) = sub_1002ECA0(v67);
      v68 = v99;
      v69 = v101;
      v70 = v104;
      v71 = (unsigned __int16 *)sub_1002E550(v6, v66, a1);
      sub_1002EC40(a2, v71, v70, v69, v68, a5);
      if ( (_BYTE)v107 != *v65 )
      {
        LOBYTE(v107) = *v65;
        v72 = v107;
        v73 = sub_10023220(v107);
        LOBYTE(v99) = sub_1002ECA0(v73);
        v74 = v99;
        v75 = v101;
        v76 = v104;
        v77 = (unsigned __int16 *)sub_1002E550(v6, v72, a1);
        sub_1002EC40(a2, v77, v76, v75, v74, a5);
      }
      v65 += 4;
    }
    while ( (signed int)v65 < (signed int)&unk_101FC0A9 );
    v78 = (char *)&unk_101FC0A9;
    v103 = (__int16 *)&unk_101FC0A9;
    do
    {
      LOBYTE(v106) = *(v78 - 1);
      v79 = v106;
      v80 = sub_10023250(v106);
      v81 = sub_1002ECA0(v80);
      LOBYTE(v99) = v81;
      if ( (_BYTE)v106 == 4 )
      {
        if ( !(_BYTE)v100 || (LOBYTE(v99) = 1, !v81) )
          LOBYTE(v99) = 0;
      }
      v82 = v104;
      v83 = v99;
      v84 = v101;
      v85 = v104;
      v86 = (unsigned __int16 *)sub_1002E6B0(v6, v79, a1);
      sub_1002EC40(a2, v86, v85, v84, v83, a5);
      if ( (_BYTE)v106 != *(_BYTE *)v103 )
      {
        LOBYTE(v106) = *(_BYTE *)v103;
        v87 = v106;
        v88 = sub_10023250(v106);
        v89 = sub_1002ECA0(v88);
        LOBYTE(v99) = v89;
        if ( (_BYTE)v106 == 4 )
        {
          if ( !(_BYTE)v100 || (LOBYTE(v99) = 1, !v89) )
            LOBYTE(v99) = 0;
        }
        v90 = v99;
        v91 = v101;
        v92 = (unsigned __int16 *)sub_1002E6B0(v6, v87, a1);
        sub_1002EC40(a2, v92, v82, v91, v90, a5);
      }
      v78 = (char *)(v103 + 4);
      v103 += 4;
    }
    while ( (signed int)v103 < (signed int)&unk_101FC0D1 );
LABEL_79:
    v108 += 2;
    result = v110 + 1;
    LOBYTE(v110) = v110 + 1;
    if ( (unsigned __int8)v110 >= 2u )
      return result;
    v5 = v104;
  }
}
// 100B4976: using guessed type __int16 word_100B4976[];
// 101FC27C: using guessed type char byte_101FC27C;

//----- (1002FB80) --------------------------------------------------------
void __cdecl sub_1002FB80(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  void *v5; // ecx@1
  void *v6; // ecx@2
  bool v7; // al@5
  char v8; // ST0C_1@7
  unsigned __int16 *v9; // eax@7
  bool v10; // al@12
  char v11; // ST0C_1@14
  unsigned __int16 *v12; // eax@14
  int v13; // [sp+10h] [bp-4h]@1

  sub_10019330((int)&v13);
  if ( v13 & 0x10000 || sub_1001A070(v5) == 4 )
  {
    v7 = sub_1002ECA0(36) && sub_1002ECA0(60);
    v8 = v7;
    v9 = (unsigned __int16 *)sub_10035200(a1);
    sub_1002EC40(a2, v9, a3, a4, v8, a5);
  }
  if ( v13 & 0x20000 || sub_1001A070(v6) == 4 )
  {
    v10 = sub_1002ECA0(37) && sub_1002ECA0(61);
    v11 = v10;
    v12 = (unsigned __int16 *)sub_10035200(a1);
    sub_1002EC40(a2, v12, a3, a4, v11, a5);
  }
}

//----- (1002FC60) --------------------------------------------------------
char __cdecl sub_1002FC60(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // eax@2
  void *v6; // ecx@2
  char v7; // al@4
  char v8; // ST10_1@4
  unsigned __int16 *v9; // eax@4
  char result; // al@5
  unsigned __int8 v11; // [sp+10h] [bp-8h]@1
  int v12; // [sp+14h] [bp-4h]@1

  sub_10019330((int)&v12);
  v11 = 0;
  do
  {
    v5 = sub_10043D10(v11);
    if ( v5 & v12 || sub_1001A070(v6) == 4 )
    {
      v7 = sub_1002AF90(v11);
      v8 = sub_1002ECA0(v7);
      v9 = (unsigned __int16 *)sub_10043C90(v11, a1);
      sub_1002EC40(a2, v9, a3, a4, v8, a5);
    }
    result = v11++ + 1;
  }
  while ( v11 < 2u );
  return result;
}

//----- (1002FCF0) --------------------------------------------------------
char __cdecl sub_1002FCF0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  char v5; // si@2
  signed int v6; // eax@2
  char v7; // al@3
  char v8; // ST14_1@3
  unsigned __int16 *v9; // eax@3
  int v10; // ecx@3
  char v11; // ST14_1@4
  unsigned __int16 *v12; // eax@4
  unsigned __int16 *v13; // edi@5
  unsigned __int16 *v14; // eax@12
  unsigned __int16 *v15; // eax@14
  unsigned __int8 v16; // al@14
  unsigned __int16 *v17; // eax@15
  char result; // al@17
  char v19; // [sp+13h] [bp-1Dh]@6
  unsigned __int16 v20; // [sp+14h] [bp-1Ch]@6
  int v21; // [sp+18h] [bp-18h]@14
  unsigned __int8 *v22; // [sp+1Ch] [bp-14h]@11
  int v23; // [sp+20h] [bp-10h]@3
  int v24; // [sp+24h] [bp-Ch]@1
  int v25; // [sp+28h] [bp-8h]@1
  int v26; // [sp+2Ch] [bp-4h]@12

  sub_10019330((int)&v25);
  LOBYTE(v24) = 0;
  do
  {
    v5 = v24;
    v6 = sub_1003D680(v24);
    if ( v6 & v25 )
    {
      memset(&unk_10201678, 0, 0x890u);
      sub_10019300(v5, (int)&unk_10201678);
      v7 = sub_1003D640(v5);
      LOBYTE(v23) = sub_1002ECA0(v7);
      v8 = v23;
      v9 = (unsigned __int16 *)sub_10043E00(v5, a1);
      sub_1002EC40(a2, v9, a3, a4, v8, a5);
      if ( (unsigned __int8)sub_100438A0(v10) )
      {
        v11 = v23;
        v12 = (unsigned __int16 *)sub_10044000(v5, a1);
        sub_1002EC40(a2, v12, a3, a4, v11, a5);
      }
      v13 = (unsigned __int16 *)&unk_1020171A;
      do
      {
        if ( sub_10042F30(*v13, v5, &v19, &v20) == 1 && v19 == a1 && v20 < a2 )
          *(_BYTE *)(*(_WORD *)(a5 + 2 * v20) + a3) = v23;
        v13 += 8;
      }
      while ( (signed int)v13 < (signed int)&unk_102019EA );
      v22 = (unsigned __int8 *)&unk_10201679;
      do
      {
        LOBYTE(v26) = *v22;
        v14 = (unsigned __int16 *)sub_10043D30(v5, v26, a1);
        sub_1002EC40(a2, v14, a3, a4, 1, a5);
        v22 += 4;
      }
      while ( (signed int)v22 <= (signed int)&unk_10201715 );
      v22 = (unsigned __int8 *)&unk_102019E9;
      do
      {
        LOBYTE(v21) = *(v22 - 1);
        v15 = (unsigned __int16 *)sub_10043E90(v5, v21, a1);
        sub_1002EC40(a2, v15, a3, a4, 1, a5);
        v16 = *v22;
        if ( (_BYTE)v21 != *v22 )
        {
          LOBYTE(v21) = *v22;
          v17 = (unsigned __int16 *)sub_10043E90(v5, v16, a1);
          sub_1002EC40(a2, v17, a3, a4, 1, a5);
        }
        v22 += 8;
      }
      while ( (signed int)v22 < (signed int)&unk_10201A69 );
    }
    result = v24 + 1;
    LOBYTE(v24) = v24 + 1;
  }
  while ( (unsigned __int8)v24 < 3u );
  return result;
}

//----- (1002FF00) --------------------------------------------------------
char __cdecl sub_1002FF00(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  void *v5; // ecx@1
  int v6; // eax@1
  void *v7; // ecx@1
  signed int v8; // eax@2
  void *v9; // ecx@2
  void *v10; // ecx@3
  char v11; // al@4
  unsigned __int16 *v12; // eax@4
  char v13; // ST10_1@4
  unsigned __int16 *v14; // eax@4
  __int16 *v15; // eax@4
  int v16; // ecx@4
  unsigned __int16 *v17; // eax@5
  unsigned __int16 *v18; // eax@7
  int v19; // eax@9
  char v21; // [sp+13h] [bp-Dh]@1
  char v22; // [sp+14h] [bp-Ch]@1
  int v23; // [sp+18h] [bp-8h]@1
  int v24; // [sp+1Ch] [bp-4h]@4

  sub_10019330((int)&v23);
  v6 = sub_1001B4A0(v5);
  v23 |= v6;
  v21 = sub_1001A070(v7);
  v22 = 3;
  do
  {
    v8 = sub_100194B0(v22);
    if ( v8 & v23 || sub_1001A070(v9) == 4 )
    {
      v11 = sub_100193D0(v22);
      LOBYTE(v24) = sub_1002ECA0(v11);
      v12 = (unsigned __int16 *)sub_10044080(a1);
      sub_1002EC40(a2, v12, a3, a4, 1, a5);
      v13 = v24;
      v14 = (unsigned __int16 *)sub_10044140(v22, a1);
      sub_1002EC40(a2, v14, a3, a4, v13, a5);
      v15 = sub_1002A800(a1, a2);
      sub_1002EC40(a2, (unsigned __int16 *)v15, a3, a4, 1, a5);
      if ( (unsigned __int8)sub_100438A0(v16) )
      {
        v17 = (unsigned __int16 *)sub_10044020(a1);
        sub_1002EC40(a2, v17, a3, a4, 1, a5);
      }
      if ( sub_1003D870() )
      {
        v18 = (unsigned __int16 *)sub_100440E0(a1);
        sub_1002EC40(a2, v18, a3, a4, 1, a5);
      }
    }
    ++v22;
  }
  while ( (unsigned __int8)v22 < 7u );
  LOBYTE(v19) = v21;
  if ( v21 == 2 || v21 == 8 )
  {
    LOBYTE(v19) = a1;
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        LOBYTE(v19) = sub_1001B4A0(v10);
        if ( v19 & 0xF0 )
        {
          *(_BYTE *)(*(_WORD *)(a5 + 492) + a3) = 1;
          *(_BYTE *)(*(_WORD *)(a5 + 496) + a3) = 1;
          v19 = *(_WORD *)(a5 + 494);
          *(_BYTE *)(v19 + a3) = 1;
        }
      }
    }
    else
    {
      *(_BYTE *)(*(_WORD *)(a5 + 980) + a3) = 1;
      *(_BYTE *)(*(_WORD *)(a5 + 982) + a3) = 1;
      *(_BYTE *)(*(_WORD *)(a5 + 1178) + a3) = 1;
      v19 = *(_WORD *)(a5 + 1180);
      *(_BYTE *)(v19 + a3) = 1;
    }
  }
  else if ( !a1 )
  {
    *(_BYTE *)(*(_WORD *)(a5 + 980) + a3) = sub_1002ECA0(40);
    *(_BYTE *)(*(_WORD *)(a5 + 982) + a3) = sub_1002ECA0(41);
    *(_BYTE *)(*(_WORD *)(a5 + 1178) + a3) = sub_1002ECA0(51);
    LOBYTE(v19) = sub_1002ECA0(52);
    *(_BYTE *)(*(_WORD *)(a5 + 1180) + a3) = v19;
  }
  return v19;
}

//----- (10030120) --------------------------------------------------------
void __cdecl sub_10030120(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ecx@0
  void *v6; // ecx@1
  char v7; // ST0C_1@3
  unsigned __int16 *v8; // eax@3
  int v9; // [sp+0h] [bp-4h]@1

  v9 = v5;
  sub_10019330((int)&v9);
  if ( v9 & 0x4000 || sub_1001A070(v6) == 4 )
  {
    v7 = sub_1002ECA0(32);
    v8 = (unsigned __int16 *)sub_100441E0(a1);
    sub_1002EC40(a2, v8, a3, a4, v7, a5);
  }
}

//----- (10030180) --------------------------------------------------------
void __cdecl sub_10030180(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ecx@0
  void *v6; // ecx@1
  char v7; // ST0C_1@3
  unsigned __int16 *v8; // eax@3
  int v9; // [sp+0h] [bp-4h]@1

  v9 = v5;
  sub_10019330((int)&v9);
  if ( v9 & 0x400 || sub_1001A070(v6) == 4 )
  {
    v7 = sub_1002ECA0(19);
    v8 = (unsigned __int16 *)sub_10044240(a1);
    sub_1002EC40(a2, v8, a3, a4, v7, a5);
  }
}

//----- (100301E0) --------------------------------------------------------
void *__usercall sub_100301E0@<eax>(void *a1@<ebx>, const void *a2@<edi>, int a3@<esi>, int a4)
{
  void *result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0
  int v6; // [sp+4h] [bp-8h]@0

  result = (void *)sub_1004E7C0(a4, v5, v6);
  if ( result )
  {
    sub_1004E8F0(a4, (int)a2, a3);
    result = memcpy(a1, a2, (unsigned __int16)a3);
  }
  return result;
}

//----- (10030210) --------------------------------------------------------
char sub_10030210()
{
  char v1; // [sp+Fh] [bp-1h]@1

  sub_100301E0(&v1, &unk_100B49D2, 1, 2119);
  return v1;
}

//----- (10030240) --------------------------------------------------------
char __cdecl sub_10030240(int a1)
{
  char v1; // bl@1
  int v2; // esi@1
  int v3; // eax@1

  v1 = 0;
  v2 = j_HWM_pvg_hsdb_get_lrus_online();
  j_HWM_pvg_hsdb_set_sim_lrus_online(0);
  v3 = j_HWM_pvg_hsdb_get_lrus_online();
  if ( (a1 & v3) == a1 )
    v1 = 1;
  j_HWM_pvg_hsdb_set_sim_lrus_online(v2 - v3);
  return v1;
}
// 1004ECB0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 1004ECD0: using guessed type int __cdecl j_HWM_pvg_hsdb_set_sim_lrus_online(_DWORD);

//----- (10030280) --------------------------------------------------------
bool __cdecl sub_10030280(unsigned __int8 a1)
{
  char v2; // [sp+4h] [bp-4h]@1

  return sub_10009C90(0x33u, a1, (float *)&v2) == 1 || sub_10009C90(0x34u, a1, (float *)&v2) == 1;
}

//----- (100302C0) --------------------------------------------------------
char sub_100302C0()
{
  return 2;
}

//----- (100302D0) --------------------------------------------------------
char sub_100302D0()
{
  return 3;
}

//----- (100302E0) --------------------------------------------------------
char sub_100302E0()
{
  return 0;
}

//----- (100302F0) --------------------------------------------------------
int __cdecl sub_100302F0(char a1, char *a2)
{
  int result; // eax@1
  char *v3; // edi@2
  char *v4; // esi@3
  int v5; // edi@3

  result = sub_1001DC80(&a1, 1u, (int)&unk_100B4A98, 68, 4, 4);
  if ( result < 4 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = (char *)&unk_100B4A99 + 68 * result;
      qmemcpy(a2, v4, 0x40u);
      v4 += 64;
      v5 = (int)(v3 + 64);
      *(_WORD *)v5 = *(_WORD *)v4;
      *(_BYTE *)(v5 + 2) = v4[2];
    }
  }
  return result;
}

//----- (10030360) --------------------------------------------------------
char __cdecl sub_10030360(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_1003E9D0() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_10041C70("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_1003F770() )
          v7 = 0;
      }
      v5 = sub_10041C70("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_1003F770() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (10030470) --------------------------------------------------------
char __cdecl sub_10030470(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (100304A0) --------------------------------------------------------
bool __cdecl sub_100304A0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (100304D0) --------------------------------------------------------
bool __cdecl sub_100304D0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (10030500) --------------------------------------------------------
bool __cdecl sub_10030500(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (10030530) --------------------------------------------------------
bool __cdecl sub_10030530(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (10030560) --------------------------------------------------------
bool __cdecl sub_10030560(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (10030590) --------------------------------------------------------
bool __cdecl sub_10030590(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (100305D0) --------------------------------------------------------
bool __cdecl sub_100305D0(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (10030610) --------------------------------------------------------
bool __cdecl sub_10030610(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (10030640) --------------------------------------------------------
bool __cdecl sub_10030640(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (10030670) --------------------------------------------------------
char __cdecl sub_10030670(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (100306A0) --------------------------------------------------------
bool __cdecl sub_100306A0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (100306D0) --------------------------------------------------------
bool __cdecl sub_100306D0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (10030700) --------------------------------------------------------
bool __cdecl sub_10030700(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (10030730) --------------------------------------------------------
bool __cdecl sub_10030730(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (10030760) --------------------------------------------------------
bool __cdecl sub_10030760(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_100B5AD8, 9u);
}

//----- (10030790) --------------------------------------------------------
bool __cdecl sub_10030790(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (100307C0) --------------------------------------------------------
bool __cdecl sub_100307C0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (100307F0) --------------------------------------------------------
bool __cdecl sub_100307F0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (10030820) --------------------------------------------------------
bool __cdecl sub_10030820(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (10030850) --------------------------------------------------------
bool __cdecl sub_10030850(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (10030880) --------------------------------------------------------
int __cdecl sub_10030880(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_1003E9D0() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (100308F0) --------------------------------------------------------
int __cdecl sub_100308F0(int a1, char a2)
{
  return sub_10030880(a1, (int)&a2, 1);
}

//----- (10030910) --------------------------------------------------------
int __cdecl sub_10030910(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_10030880(a1, (int)&v4, 2);
}

//----- (10030940) --------------------------------------------------------
int __cdecl sub_10030940(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_10030880(a1, (int)&v5, 3);
}

//----- (10030970) --------------------------------------------------------
int __cdecl sub_10030970(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_10030880(a1, (int)&v6, 4);
}

//----- (100309B0) --------------------------------------------------------
int __cdecl sub_100309B0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_10030880(a1, (int)&v7, 5);
}

//----- (100309F0) --------------------------------------------------------
int __cdecl sub_100309F0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_10030880(a1, (int)&v8, 6);
}

//----- (10030A40) --------------------------------------------------------
char __cdecl sub_10030A40(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_1003E9D0();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (10030A70) --------------------------------------------------------
char __cdecl sub_10030A70(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (10030A80) --------------------------------------------------------
char __cdecl sub_10030A80(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  char *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = "/", v3) )
          v11 = &byte_100647C9;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_100442E0(v16) )
        sub_100442C0((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_100442F0((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 100442E0: using guessed type _DWORD __cdecl sub_100442E0(_DWORD);
// 10030A80: using guessed type char var_104[255];

//----- (10030C00) --------------------------------------------------------
signed int __cdecl sub_10030C00(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (10030C40) --------------------------------------------------------
signed int __cdecl sub_10030C40(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (10030CE0) --------------------------------------------------------
char __cdecl sub_10030CE0(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (10030D40) --------------------------------------------------------
char __cdecl sub_10030D40(int a1, void (__cdecl *a2)(int))
{
  char result; // al@6

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( a2 )
      a2(a1);
    sub_100442A0(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return result;
}

//----- (10030DB0) --------------------------------------------------------
char *__cdecl sub_10030DB0(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_10201F10, v1, v2);
  *(&byte_10201F10 + v2) = 0;
  return &byte_10201F10;
}

//----- (10030E50) --------------------------------------------------------
int __cdecl sub_10030E50(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (10030EC0) --------------------------------------------------------
bool __cdecl sub_10030EC0(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_10052ABC(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_10052ABC(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (10030F50) --------------------------------------------------------
char __cdecl sub_10030F50(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (10031000) --------------------------------------------------------
char __cdecl sub_10031000(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (10031010) --------------------------------------------------------
char __cdecl sub_10031010(int a1, void (__cdecl *a2)(int))
{
  char v2; // bl@1

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 324) > 0 || *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    v2 = 1;
    if ( a2 )
      a2(a1);
  }
  if ( *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    sub_100442A0(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    v2 = 1;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return v2;
}

//----- (10031090) --------------------------------------------------------
int (__cdecl *__cdecl sub_10031090(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_10044370((int)a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}

//----- (100310E0) --------------------------------------------------------
signed int __cdecl sub_100310E0(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@1

  sub_10031010(a1, a2);
  result = 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (10031130) --------------------------------------------------------
unsigned int __cdecl sub_10031130(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (10031150) --------------------------------------------------------
int __cdecl sub_10031150(int a1)
{
  return a1 | 1;
}

//----- (10031160) --------------------------------------------------------
bool __cdecl sub_10031160(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (10031230) --------------------------------------------------------
int __cdecl sub_10031230(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (10031250) --------------------------------------------------------
int __cdecl sub_10031250(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_10031230(a1 + 20);
  return result;
}

//----- (10031290) --------------------------------------------------------
bool __cdecl sub_10031290(int a1)
{
  unsigned int v1; // esi@2
  unsigned int v2; // ecx@5
  bool result; // al@11

  result = a1
        && (v1 = *(_DWORD *)(a1 + 116), v1 < 0xFFFFFFC2)
        && v1
        && *(_DWORD *)a1 != -1
        && ((v2 = *(_DWORD *)(a1 + 120), *(_DWORD *)a1 + 22 <= v2)
         && *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 20) + 22 <= v2
         || !v2
         || *(_DWORD *)(a1 + 4) != v1)
        && *(_DWORD *)(a1 + 8) == 101010256
        && *(_WORD *)(a1 + 14) == *(_WORD *)(a1 + 12);
  return result;
}

//----- (100312F0) --------------------------------------------------------
signed int __cdecl sub_100312F0(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_1004F060(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_1004F060(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (100313B0) --------------------------------------------------------
signed int __cdecl sub_100313B0(int a1, int a2, int a3)
{
  int v3; // esi@3
  signed int result; // eax@9

  if ( sub_1004F060(*(_DWORD *)(a1 + 116), (void *)a3, 30, *(_DWORD *)(a2 + 42), 0) != 30 )
    goto LABEL_13;
  if ( *(_BYTE *)(a2 + 8) & 8 )
  {
    v3 = *(_DWORD *)(a2 + 42) + *(_DWORD *)(a2 + 20) + sub_10031250(0, a3);
    sub_1004F060(*(_DWORD *)(a1 + 116), (void *)(a3 + 14), 12, v3, 0);
    if ( *(_DWORD *)(a3 + 14) != *(_DWORD *)(a2 + 16) )
      sub_1004F060(*(_DWORD *)(a1 + 116), (void *)(a3 + 14), 12, v3 + 4, 0);
  }
  if ( *(_DWORD *)a3 != 67324752
    || *(_DWORD *)(a3 + 18) != *(_DWORD *)(a2 + 20)
    || *(_DWORD *)(a3 + 14) != *(_DWORD *)(a2 + 16)
    || *(_WORD *)(a3 + 26) != *(_WORD *)(a2 + 28) )
  {
LABEL_13:
    result = -15;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10031460) --------------------------------------------------------
int __cdecl sub_10031460(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10031480) --------------------------------------------------------
signed int __cdecl sub_10031480(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebp@1
  _BYTE *v4; // edi@2
  _BYTE *v5; // ebx@2
  int v6; // esi@3
  signed int result; // eax@5
  int v8; // [sp+1Ch] [bp+Ch]@3

  v3 = a3;
  if ( a3 )
  {
    v4 = a2;
    v5 = a1;
    while ( 1 )
    {
      v6 = *v5;
      --v3;
      v8 = tolower(*v4++);
      ++v5;
      if ( tolower(v6) != v8 )
        break;
      if ( !v3 )
        goto LABEL_5;
    }
    result = 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (100314E0) --------------------------------------------------------
int __usercall sub_100314E0@<eax>(int a1@<esi>, int a2, char a3)
{
  int v3; // ebp@1
  int v4; // edi@2
  int v5; // ebx@2
  int v6; // ebp@5
  int v7; // eax@5
  int v8; // ST04_4@5
  int v10; // [sp+Ch] [bp-4h]@4
  int v11; // [sp+18h] [bp+8h]@4

  v3 = a2;
  if ( a3 )
  {
    v4 = a2;
    v3 = *(_DWORD *)(a1 + 116);
    v5 = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 116);
    v5 = *(_DWORD *)(a1 + 120);
  }
  v11 = *(_DWORD *)(a1 + 24);
  sub_1004F140(v3);
  v10 = sub_1004EFB0(v4, v5, v3, v11, *(_DWORD *)(a1 + 20));
  if ( !v10 )
  {
    *(_DWORD *)(a1 + 24) = v5;
    *(_DWORD *)(a1 + 4) = v4;
    *(_DWORD *)(a1 + 120) = v11;
    v6 = sub_1004F170(v3, v11, 0);
    v7 = *(_DWORD *)(a1 + 24);
    v8 = v5 + *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 36) = v7;
    v10 = sub_1004F170(v4, v8, 0) | v6;
  }
  *(_DWORD *)(a1 + 120) = sub_1004F140(*(_DWORD *)(a1 + 116));
  return v10;
}

//----- (100315F0) --------------------------------------------------------
int __usercall sub_100315F0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_10048120(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_1004F140(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_1004F170(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 1004F190: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100316A0) --------------------------------------------------------
signed int __usercall sub_100316A0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_1004F1A0(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_10048570((void *)(v2 + 555), v7);
  }
  else
  {
    sub_100312F0(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_1004F060(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_1004F060(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_10048440(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_1004F1A0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_1004F1A0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (10031870) --------------------------------------------------------
char __usercall sub_10031870@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_100480D0(a2, a3, a1 + 212);
}

//----- (10031880) --------------------------------------------------------
int __usercall sub_10031880@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_100315F0(result + 148, result);
  return result;
}

//----- (100318A0) --------------------------------------------------------
char __usercall sub_100318A0@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (100318C0) --------------------------------------------------------
int __usercall sub_100318C0@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  int result; // eax@1

  v2 = sub_1004E2A0(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_1004E2A0(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (10031900) --------------------------------------------------------
int __cdecl sub_10031900(unsigned int a1)
{
  int i; // ebx@1
  int v2; // edi@1
  signed int v3; // eax@1
  signed int v4; // ebp@1
  int result; // eax@2
  int v6; // esi@7
  int v7; // ebx@9
  int v8; // eax@10
  unsigned int v9; // ecx@11
  int *v10; // edx@11
  char *v11; // esi@11
  int v12; // edi@15
  int v13; // ecx@16
  _BYTE *v14; // edx@16
  _BYTE *v15; // esi@16
  int v16; // ecx@18
  _BYTE *v17; // edx@18
  _BYTE *v18; // esi@18
  _BYTE *v19; // edx@20
  _BYTE *v20; // esi@20
  signed int v21; // ecx@22
  signed int v22; // [sp+Ch] [bp-9Ch]@1
  int v23; // [sp+10h] [bp-98h]@7
  signed int v24; // [sp+14h] [bp-94h]@1
  int v25; // [sp+18h] [bp-90h]@1
  int v26; // [sp+20h] [bp-88h]@1
  char v27[128]; // [sp+24h] [bp-84h]@9

  i = 65557;
  v2 = 0;
  v22 = 65557;
  v25 = 0;
  v26 = 101010256;
  v3 = sub_1004F140(a1);
  v4 = v3;
  v24 = v3;
  if ( v3 >= 0 )
  {
    if ( (unsigned int)v3 >= 0x10015 )
      goto LABEL_7;
    v22 = v3;
    if ( v3 > 0 )
    {
      for ( i = v3; ; i = v22 )
      {
LABEL_7:
        v6 = v2 + 128;
        v23 = v2 + 128;
        if ( v2 + 128 > i )
        {
          v6 = i;
          v23 = i;
        }
        v7 = v6 - v2;
        if ( sub_1004F060(a1, v27, v6 - v2, v4 - v6, 0) != v6 - v2 )
          break;
        v8 = v7 - 4;
        if ( v7 - 4 >= 0 )
        {
          while ( 1 )
          {
            v9 = 4;
            v10 = &v26;
            v11 = &v27[v8];
            do
            {
              if ( *(_DWORD *)v11 != *v10 )
                goto LABEL_15;
              v9 -= 4;
              ++v10;
              v11 += 4;
            }
            while ( v9 >= 4 );
            if ( !v9 )
            {
LABEL_24:
              v21 = 0;
              goto LABEL_25;
            }
LABEL_15:
            v12 = (unsigned __int8)*v11 - *(_BYTE *)v10;
            if ( (unsigned __int8)*v11 == *(_BYTE *)v10 )
            {
              v13 = v9 - 1;
              v14 = (char *)v10 + 1;
              v15 = v11 + 1;
              if ( !v13 )
                goto LABEL_24;
              v12 = *v15 - *v14;
              if ( *v15 == *v14 )
              {
                v16 = v13 - 1;
                v17 = v14 + 1;
                v18 = v15 + 1;
                if ( !v16 )
                  goto LABEL_24;
                v12 = *v18 - *v17;
                if ( *v18 == *v17 )
                {
                  v19 = v17 + 1;
                  v20 = v18 + 1;
                  if ( v16 == 1 )
                    goto LABEL_24;
                  v12 = *v20 - *v19;
                  if ( *v20 == *v19 )
                    goto LABEL_24;
                }
              }
            }
            v21 = 1;
            if ( v12 <= 0 )
              v21 = -1;
LABEL_25:
            if ( !v21 )
              return v24 + v8 - v23;
            if ( --v8 < 0 )
            {
              v4 = v24;
              v2 = v25;
              v6 = v23;
              break;
            }
          }
        }
        v2 = v2 + v7 - 3;
        v25 = v2;
        if ( v6 >= v22 )
          break;
      }
    }
    result = -1;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 10031900: using guessed type char var_84[128];

//----- (10031AB0) --------------------------------------------------------
int __fastcall sub_10031AB0(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (10031AD0) --------------------------------------------------------
int __usercall sub_10031AD0@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_DWORD *)(a2 + 732) = result;
  ++*(_DWORD *)(result + 124);
  return result;
}

//----- (10031AE0) --------------------------------------------------------
int __usercall sub_10031AE0@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_1004F240(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_1004F170(v4, v3, 0);
}
// 1004F190: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10031B20) --------------------------------------------------------
signed int __usercall sub_10031B20@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_10031AB0(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_1004E2C0(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_10031870(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_1004A4D0(a2 + 28, 4);
      else
        v22 = sub_1004A4D0(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_10031870(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 1004F190: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10031D30) --------------------------------------------------------
int __cdecl sub_10031D30(void *a1)
{
  unsigned int v1; // ecx@2
  unsigned int v2; // eax@4
  int v3; // edi@4
  int v4; // edi@7
  int result; // eax@8

  if ( a1 && (v1 = *((_DWORD *)a1 + 29), v1 < 0xFFFFFFC2) && v1 )
  {
    v2 = *((_DWORD *)a1 + 1);
    v3 = 0;
    if ( v1 != v2 && v2 < 0xFFFFFFC2 )
    {
      if ( v2 )
      {
        v4 = sub_100314E0((int)a1, v2, 0);
        v3 = sub_10031AE0((int)a1) | v4;
      }
    }
    sub_1004EF10(*((_DWORD *)a1 + 29));
    memset(a1, 0, 0x80u);
    result = v3;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10031D90) --------------------------------------------------------
int __cdecl sub_10031D90(int a1, int a2, void *a3, int a4)
{
  unsigned int v4; // eax@3
  signed int v5; // edi@5
  unsigned int v6; // eax@6
  int v8; // eax@11
  int v9; // eax@17

  memset(a3, 0, 0x80u);
  *((_DWORD *)a3 + 8) = -1;
  *((_DWORD *)a3 + 9) = -1;
  *((_BYTE *)a3 + 48) = 0;
  if ( a4 )
    sub_10020640((int)a3 + 48, (_BYTE *)a4, 64);
  *((_BYTE *)a3 + 112) = 3;
  v4 = j_FIL_vfs_open(a1, a2, 0);
  *((_DWORD *)a3 + 29) = v4;
  if ( v4 >= 0xFFFFFFC2 || !v4 )
  {
    v5 = v4;
    if ( !v4 )
      return v5;
LABEL_6:
    v6 = *((_DWORD *)a3 + 29);
    if ( v6 < 0xFFFFFFC2 )
    {
      if ( v6 )
        sub_1004EF10(*((_DWORD *)a3 + 29));
    }
    memset(a3, 0, 0x80u);
    return v5;
  }
  *((_DWORD *)a3 + 1) = v4;
  v8 = sub_1004F140(v4);
  *((_DWORD *)a3 + 30) = v8;
  if ( v8 < 0 )
  {
LABEL_12:
    v5 = -15;
    goto LABEL_6;
  }
  if ( v8 || !(a2 & 2) )
  {
    v9 = sub_10031900(*((_DWORD *)a3 + 29));
    *(_DWORD *)a3 = v9;
    if ( v9 == -1 || (unsigned int)(v9 + 22) > *((_DWORD *)a3 + 30) )
      goto LABEL_12;
    sub_1004F060(*((_DWORD *)a3 + 1), (char *)a3 + 8, 22, v9, 0);
    if ( !sub_10031290((int)a3) )
    {
      v5 = -15;
      goto LABEL_6;
    }
  }
  else
  {
    *((_DWORD *)a3 + 2) = 101010256;
  }
  return 0;
}
// 1004F010: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10031E90) --------------------------------------------------------
signed int __cdecl sub_10031E90(int a1, unsigned __int64 a2)
{
  unsigned int v2; // eax@3
  signed int v3; // esi@3
  unsigned int v4; // ebp@4
  int v5; // edx@8
  void *v6; // eax@9
  unsigned __int16 v7; // si@10
  unsigned __int16 v8; // cx@10
  void *v9; // ecx@17
  unsigned __int16 v10; // ax@19
  signed int result; // eax@24
  int v12; // ecx@25
  int v13; // [sp+8h] [bp-4h]@4

  if ( sub_10031290(a1) && a2 < *(_WORD *)(a1 + 16) )
  {
    v2 = *(_DWORD *)(a1 + 32);
    v3 = -15;
    if ( (unsigned int)a2 < v2 )
    {
      v4 = *(_DWORD *)(a1 + 24);
      v13 = 0;
LABEL_5:
      while ( v4 < *(_DWORD *)(a1 + 120) )
      {
        v3 = sub_1004F060(*(_DWORD *)(a1 + 4), (void *)(HIDWORD(a2) + 4), 46, v4, 0);
        if ( v3 != 46 || *(_DWORD *)(HIDWORD(a2) + 4) != 33639248 )
        {
          v12 = *(_DWORD *)(a1 + 24);
          *(_DWORD *)(a1 + 32) = 0;
          *(_DWORD *)(a1 + 36) = v12;
          v3 = -15;
          break;
        }
        v5 = a1;
        *(_DWORD *)(a1 + 32) = v13;
        *(_DWORD *)(a1 + 36) = v4;
        if ( v13 == (_DWORD)a2 )
        {
          v6 = *(void **)(HIDWORD(a2) + 52);
          v3 = 0;
          *(_DWORD *)HIDWORD(a2) = v4;
          *(_WORD *)(HIDWORD(a2) + 58) = -1;
          if ( v6 )
          {
            v7 = *(_WORD *)(HIDWORD(a2) + 56);
            v8 = *(_WORD *)(HIDWORD(a2) + 32);
            if ( v7 <= v8 )
            {
              sub_10020640((int)v6, &byte_100647C9, v7);
              v5 = a1;
              v3 = -15;
            }
            else if ( sub_1004F060(*(_DWORD *)(a1 + 4), v6, v8, v4 + 46, 0) == *(_WORD *)(HIDWORD(a2) + 32) )
            {
              v5 = a1;
              *(_WORD *)(HIDWORD(a2) + 58) = *(_WORD *)(HIDWORD(a2) + 32);
              v3 = 0;
              *(_BYTE *)(*(_WORD *)(HIDWORD(a2) + 32) + *(_DWORD *)(HIDWORD(a2) + 52)) = 0;
            }
            else
            {
              v5 = a1;
              v3 = -15;
              *(_BYTE *)(*(_WORD *)(HIDWORD(a2) + 32) + *(_DWORD *)(HIDWORD(a2) + 52)) = 0;
            }
          }
          else
          {
            *(_WORD *)(HIDWORD(a2) + 58) = -1;
          }
          v9 = *(void **)(HIDWORD(a2) + 60);
          *(_WORD *)(HIDWORD(a2) + 66) = -1;
          if ( v9 )
          {
            if ( !v3 )
            {
              v10 = *(_WORD *)(HIDWORD(a2) + 34);
              if ( *(_WORD *)(HIDWORD(a2) + 64) < v10
                || sub_1004F060(*(_DWORD *)(v5 + 4), v9, v10, *(_WORD *)(HIDWORD(a2) + 32) + v4 + 46, 0) != *(_WORD *)(HIDWORD(a2) + 34) )
              {
                v3 = -15;
              }
              else
              {
                v3 = 0;
                *(_WORD *)(HIDWORD(a2) + 66) = *(_WORD *)(HIDWORD(a2) + 34);
              }
            }
          }
        }
        v4 += sub_10031230(HIDWORD(a2) + 4);
        if ( ++v13 > (unsigned int)a2 )
          return v3;
      }
    }
    else
    {
      v4 = *(_DWORD *)(a1 + 36);
      v13 = *(_DWORD *)(a1 + 32);
      if ( v2 <= (unsigned int)a2 )
        goto LABEL_5;
    }
    result = v3;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10032090) --------------------------------------------------------
signed int __cdecl sub_10032090(int a1, int a2)
{
  return sub_100313B0(*(_DWORD *)(a1 + 732), a1 + 20, a2);
}

//----- (100320B0) --------------------------------------------------------
int __cdecl sub_100320B0(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_10031880(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_1003D500(&v23);
    sub_1003D9C0((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_10031250(v1, (int)&v24);
  v13 = sub_1004F140(v31);
  if ( v3 == v31 )
  {
    result = sub_1004EFB0(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_1004F240(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_1004EFB0(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_1004F240(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_10031230(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_10031AE0(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_1004F140(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 1004F190: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10032320) --------------------------------------------------------
int __cdecl sub_10032320(void *a1, int a2, char a3)
{
  _BYTE *v3; // eax@1
  char *v4; // edi@3
  int result; // eax@4

  memset(a1, 0, 0x2E0u);
  *((_DWORD *)a1 + 17) = *(_DWORD *)(a2 + 4);
  *((_WORD *)a1 + 36) = *(_WORD *)(a2 + 8);
  *((_DWORD *)a1 + 19) = *(_DWORD *)(a2 + 16);
  *((_WORD *)a1 + 40) = *(_WORD *)(a2 + 20);
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *((_DWORD *)a1 + 24) = *(_DWORD *)(a2 + 24);
  *((_DWORD *)a1 + 25) = *(_DWORD *)(a2 + 28);
  *((_DWORD *)a1 + 26) = 0;
  *((_DWORD *)a1 + 27) = 0;
  sub_10031460((int)a1 + 116);
  v3 = *(_BYTE **)(a2 + 12);
  if ( v3 )
    sub_10020640((int)a1 + 148, v3, 64);
  v4 = (char *)a1 + 116;
  if ( a3 )
    result = sub_1004A790(
               (int)v4,
               *(_BYTE *)(a2 + 44),
               8,
               -*(_DWORD *)(a2 + 40),
               *(_DWORD *)(a2 + 48),
               0,
               *(_DWORD *)(a2 + 32),
               *(_DWORD *)(a2 + 36));
  else
    result = sub_1004C0F0((int)v4, -*(_DWORD *)(a2 + 40), *(_DWORD *)(a2 + 32), *(_DWORD *)(a2 + 36));
  return result;
}

//----- (100323F0) --------------------------------------------------------
signed int __cdecl sub_100323F0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_1004F240(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_10031B20(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10032490) --------------------------------------------------------
int __usercall sub_10032490@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_100318A0(a1);
  *v3 ^= v2;
  return sub_100318C0(v1, *v3);
}

//----- (100324B0) --------------------------------------------------------
int __usercall sub_100324B0@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_10032490(a2);
  return result;
}

//----- (100324E0) --------------------------------------------------------
signed int __usercall sub_100324E0@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_100318C0(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_1004F060(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (10032550) --------------------------------------------------------
int __cdecl sub_10032550(int a1, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // ebx@4
  int v5; // esi@6
  int result; // eax@11
  signed int v7; // [sp+8h] [bp-F4h]@6
  char v8; // [sp+Ch] [bp-F0h]@4
  char *v9; // [sp+40h] [bp-BCh]@4
  __int16 v10; // [sp+44h] [bp-B8h]@4
  unsigned __int16 v11; // [sp+46h] [bp-B6h]@8
  char v12; // [sp+50h] [bp-ACh]@4

  v3 = a2;
  if ( sub_10031290(a1) && a2 && *a2 )
  {
    memset(&v8, 0, 0x44u);
    v9 = &v12;
    v10 = 168;
    v4 = strlen(a2);
    strchr(a2, 92);
    if ( *a2 == 47 )
    {
      v3 = a2 + 1;
      --v4;
    }
    v5 = a3;
    v7 = -24;
    if ( a3 < (unsigned int)*(_WORD *)(a1 + 16) )
    {
      while ( sub_10031E90(a1, __PAIR__(&v8, v5)) || v4 != v11 || sub_10031480(v3, &v12, v4) )
      {
        if ( ++v5 >= (unsigned int)*(_WORD *)(a1 + 16) )
          return -24;
      }
      v7 = v5;
    }
    result = v7;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (100326C0) --------------------------------------------------------
signed int __cdecl sub_100326C0(int a1)
{
  signed int result; // eax@5

  if ( a1 && *(_DWORD *)(a1 + 732) )
  {
    --*(_DWORD *)(*(_DWORD *)(a1 + 732) + 124);
    if ( *(_BYTE *)(a1 + 8) )
      exit_1(a1);
    sub_1004B5C0(a1 + 116);
    result = 0;
    *(_DWORD *)a1 = -858993460;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10032720) --------------------------------------------------------
char __usercall sub_10032720@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_10048080(a1, a2, a3 + 212);
  else
    result = sub_100324B0(a2, a3 + 148);
  return result;
}

//----- (10032750) --------------------------------------------------------
signed int __usercall sub_10032750@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_100316A0(v3, v1);
  else
    result = sub_100324E0(v3, v1);
  return result;
}

//----- (10032780) --------------------------------------------------------
BOOL __usercall sub_10032780@<eax>(int a1@<ebx>, int a2)
{
  int v2; // ebp@1
  unsigned int v3; // esi@1
  int v4; // edi@1
  char v6; // [sp+10h] [bp+4h]@2

  v2 = a2;
  v3 = 0;
  v4 = a2 + 148;
  do
  {
    v6 = *(_BYTE *)(a1 + v3 + 76);
    sub_10032490(v4);
    ++v3;
  }
  while ( v3 < 0xC );
  return *(_BYTE *)(v2 + 39) == v6;
}

//----- (100327C0) --------------------------------------------------------
signed int __cdecl sub_100327C0(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_10031460(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_1004C1E0(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_10032750(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10032810) --------------------------------------------------------
signed int __cdecl sub_10032810(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_1004F060(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_10032720(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_1004F060(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_10048120(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_10031AB0(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_1004D5A0(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_1004E2C0(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_1004E2C0(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (10032A00) --------------------------------------------------------
bool __usercall sub_10032A00@<al>(int a1@<eax>)
{
  int v1; // ecx@4
  int v2; // edx@4
  int v3; // eax@4
  signed int v4; // ecx@6
  int v5; // eax@2

  if ( *(_WORD *)(a1 + 30) != 99 )
    return sub_10032780(a1 + 148, a1);
  v5 = a1 + 148;
  v1 = v5 + 543;
  v2 = v5 + 571;
  v3 = *(_BYTE *)(v5 + 571) - *(_BYTE *)(v5 + 543);
  if ( v3 || (v3 = *(_BYTE *)(v2 + 1) - *(_BYTE *)(v1 + 1), *(_BYTE *)(v2 + 1) != *(_BYTE *)(v1 + 1)) )
  {
    v4 = 1;
    if ( v3 <= 0 )
      return 0;
  }
  else
  {
    v4 = 0;
  }
  return v4 == 0;
}

//----- (10032A30) --------------------------------------------------------
int __cdecl sub_10032A30(int a1, int a2, char a3, void *a4, int a5)
{
  int result; // eax@6
  unsigned __int64 v6; // ST04_8@7
  char v7; // [sp+8h] [bp-54h]@8
  int v8; // [sp+28h] [bp-34h]@4
  int v9; // [sp+34h] [bp-28h]@4

  if ( !sub_10031290(a1) || !a4 || a3 & 2 )
    return -15;
  qmemcpy(&v8, (const void *)a5, 0x34u);
  if ( !v9 )
    v9 = a1 + 48;
  result = sub_10032320(a4, (int)&v8, 0);
  if ( !result )
  {
    HIDWORD(v6) = (char *)a4 + 16;
    LODWORD(v6) = a2;
    if ( sub_10031E90(a1, v6) )
      return -15;
    sub_10031AD0(a1, (int)a4);
    if ( sub_10032090((int)a4, (int)&v7) )
    {
      sub_1004D5C0((unsigned int)a4);
      return -15;
    }
    *((_DWORD *)a4 + 21) = *(_DWORD *)((char *)a4 + 62) + sub_10031250((int)a4, (int)&v7);
    *((_DWORD *)a4 + 3) = a2;
    sub_100327C0((unsigned int)a4);
    if ( !(*((_BYTE *)a4 + 28) & 1) || sub_10032A00((int)a4) )
    {
      result = sub_10031150((int)a4);
    }
    else
    {
      sub_100326C0((int)a4);
      result = -34;
    }
  }
  return result;
}

//----- (10032B40) --------------------------------------------------------
signed int __cdecl sub_10032B40(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_10032810(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_10031160(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10032BA0) --------------------------------------------------------
signed int __cdecl sub_10032BA0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_100327C0(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_10031460(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_100327C0(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_10032B40(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (10032D30) --------------------------------------------------------
int __cdecl sub_10032D30(int a1, char *a2, int a3, void *a4, int a5)
{
  int result; // eax@10
  bool v6; // zf@11
  int v7; // ST0C_4@16
  int v8; // eax@16
  int v9; // [sp+Ch] [bp-34h]@5
  int v10; // [sp+18h] [bp-28h]@5
  char v11; // [sp+38h] [bp-8h]@11

  if ( sub_10031290(a1) && a2 && a4 && a5 )
  {
    qmemcpy(&v9, (const void *)a5, 0x34u);
    if ( !v10 )
      v10 = a1 + 48;
    *((_DWORD *)a4 + 1) = a3;
    if ( a3 & 8 )
    {
      if ( *(_WORD *)(a1 + 16) >= 0xFFFFu || *(_WORD *)(a1 + 18) >= 0xFFFFu )
      {
        result = -22;
      }
      else
      {
        result = sub_10032320(a4, (int)&v9, 1);
        if ( !result )
        {
          *((_DWORD *)a4 + 1) = a3;
          *((_BYTE *)a4 + 8) = 1;
          *((_DWORD *)a4 + 183) = a1;
          *((_DWORD *)a4 + 3) = *(_WORD *)(a1 + 16);
          *((_DWORD *)a4 + 22) = -1;
          *((_WORD *)a4 + 12) = 20;
          *((_WORD *)a4 + 13) = 20;
          *((_DWORD *)a4 + 5) = 33639248;
          *((_WORD *)a4 + 14) = 0;
          *((_WORD *)a4 + 16) = 0;
          *((_WORD *)a4 + 17) = 0;
          *((_DWORD *)a4 + 9) = 0;
          *((_DWORD *)a4 + 10) = 0;
          *((_DWORD *)a4 + 11) = 0;
          v6 = v11 == 0;
          *((_WORD *)a4 + 24) = strlen(a2);
          *((_WORD *)a4 + 25) = 0;
          *((_WORD *)a4 + 26) = 0;
          *((_WORD *)a4 + 27) = 0;
          *((_WORD *)a4 + 28) = 0;
          *(_DWORD *)((char *)a4 + 58) = 0;
          if ( v6 )
            *((_WORD *)a4 + 15) = 0;
          else
            *((_WORD *)a4 + 15) = 8;
          if ( *(_BYTE *)a4 & 4 )
          {
            *(_WORD *)((char *)a4 + 689) = *((_WORD *)a4 + 15);
            *((_WORD *)a4 + 15) = 99;
            *((_WORD *)a4 + 14) = 1;
          }
          *(_DWORD *)((char *)a4 + 62) = *(_DWORD *)(a1 + 120);
          *((_DWORD *)a4 + 21) = *(_DWORD *)((char *)a4 + 62) + sub_10031250((int)a4, 0);
          sub_10031AD0(a1, (int)a4);
          v7 = *(_DWORD *)((char *)a4 + 62);
          v8 = sub_10031250((int)a4, 0);
          sub_1004F1A0(*(_DWORD *)(a1 + 116), *((_DWORD *)a4 + 24), v8, v7);
          if ( *((_BYTE *)a4 + 28) & 1 )
            sub_10032750((int)a4);
          result = sub_10031150((int)a4);
        }
      }
    }
    else
    {
      *((_BYTE *)a4 + 8) = 0;
      result = sub_10032550(a1, a2, 0);
      if ( result >= 0 )
        result = sub_10032A30(a1, result, a3, a4, (int)&v9);
    }
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10032F20) --------------------------------------------------------
char __cdecl sub_10032F20(unsigned __int8 a1, signed int *a2, int a3, _BYTE *a4)
{
  unsigned __int8 v4; // cl@1
  _BYTE *v5; // ebp@1
  int v6; // esi@1
  int v7; // eax@1
  signed int *v8; // edi@1
  char v9; // al@2
  char v10; // al@2
  void *v11; // ecx@2
  char v12; // al@2
  char v13; // al@2
  void *v14; // ecx@2
  char v15; // ST14_1@2
  char v16; // al@2
  void *v17; // ecx@3
  char v18; // al@5
  signed int v19; // eax@5
  unsigned __int8 v20; // al@65
  int v21; // eax@66
  int v22; // ecx@66
  int v24; // [sp-Ch] [bp-30h]@16
  char v25; // [sp-8h] [bp-2Ch]@16
  int v26; // [sp+13h] [bp-11h]@6
  char v27; // [sp+17h] [bp-Dh]@3
  char v28; // [sp+18h] [bp-Ch]@2
  int v29; // [sp+1Ch] [bp-8h]@2

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = a1;
  v8 = a2;
  *a2 = 0;
  *(_DWORD *)v6 = 0;
  *v5 = 7;
  switch ( v7 )
  {
    case 15:
    case 16:
    case 127:
      v9 = sub_100237E0(v4);
      v10 = sub_1001DF90(v9);
      sub_1001FD60(v10, (_BYTE *)v6);
      v12 = sub_10019900(v11);
      v13 = sub_100193D0(v12);
      v14 = (void *)*(_BYTE *)v6;
      v15 = *(_BYTE *)v6;
      LOBYTE(v29) = v13;
      v16 = sub_10019900(v14);
      v28 = sub_1001FB70(v16, v15);
      if ( v28 != 2 && sub_1001F5B0(v29, 0, &v28, &v27) && v27 == 2 )
      {
        v18 = sub_10019900(v17);
        v19 = sub_100194B0(v18);
        *v8 = v19;
        *v5 = 1;
      }
      else
      {
        LOBYTE(v26) = 0;
        while ( 1 )
        {
          LOBYTE(v29) = sub_100193D0(v26);
          v28 = sub_1001FB70(v26, *(_BYTE *)v6);
          if ( v28 != 2 && sub_1001F5B0(v29, 0, &v28, &v27) && v27 == 2 )
            break;
          LOBYTE(v19) = v26 + 1;
          LOBYTE(v26) = v26 + 1;
          if ( (unsigned __int8)v26 >= 3u )
            return v19;
        }
        v19 = sub_100194B0(v26);
        *v8 = v19;
        *v5 = 1;
      }
      break;
    case 17:
    case 31:
    case 32:
    case 33:
      LOBYTE(v26) = 2;
      LOBYTE(v19) = sub_1001FCA0(0, (unsigned __int8 *)&v26, (_BYTE *)v6);
      if ( (_BYTE)v19 )
      {
        *v8 = 256;
        *v5 = 1;
      }
      if ( (_BYTE)v26 )
      {
        v25 = 0;
        v24 = 565;
        goto LABEL_72;
      }
      break;
    case 18:
    case 35:
    case 36:
    case 37:
      LOBYTE(v26) = 2;
      LOBYTE(v19) = sub_1001FCA0(1, (unsigned __int8 *)&v26, (_BYTE *)v6);
      if ( (_BYTE)v19 )
      {
        *v8 = 512;
        *v5 = 1;
      }
      if ( (_BYTE)v26 != 1 )
      {
        v25 = 0;
        v24 = 582;
        goto LABEL_72;
      }
      break;
    case 19:
    case 30:
      LOBYTE(v26) = 2;
      LOBYTE(v19) = sub_1001FBC0(0, (unsigned __int8 *)&v26, (_BYTE *)v6);
      if ( (_BYTE)v19 )
      {
        *v8 = 256;
        *v5 = 1;
      }
      if ( (unsigned __int8)v26 >= 2u )
      {
        v25 = 0;
        v24 = 597;
        goto LABEL_72;
      }
      break;
    case 20:
    case 34:
      LOBYTE(v26) = 2;
      LOBYTE(v19) = sub_1001FBC0(1, (unsigned __int8 *)&v26, (_BYTE *)v6);
      if ( (_BYTE)v19 )
      {
        *v8 = 512;
        *v5 = 1;
      }
      if ( (unsigned __int8)v26 >= 2u )
      {
        v25 = 0;
        v24 = 612;
        goto LABEL_72;
      }
      break;
    case 21:
      LOBYTE(v26) = 2;
      LOBYTE(v19) = sub_1001FCA0(0, (unsigned __int8 *)&v26, (_BYTE *)v6);
      if ( (_BYTE)v19 )
      {
        *v8 = 256;
        *v5 = 1;
      }
      if ( (_BYTE)v26 )
      {
        v25 = 0;
        v24 = 626;
        goto LABEL_72;
      }
      break;
    case 22:
      LOBYTE(v26) = 2;
      LOBYTE(v19) = sub_1001FCA0(1, (unsigned __int8 *)&v26, (_BYTE *)v6);
      if ( (_BYTE)v19 )
      {
        *v8 = 512;
        *v5 = 1;
      }
      if ( (_BYTE)v26 != 1 )
      {
        v25 = 0;
        v24 = 640;
        goto LABEL_72;
      }
      break;
    case 23:
    case 115:
    case 116:
    case 117:
    case 118:
      LOBYTE(v26) = 2;
      LOBYTE(v19) = sub_1001FAF0(0, (unsigned __int8 *)&v26, (_BYTE *)v6);
      if ( (_BYTE)v19 )
      {
        *v8 = 256;
        *v5 = 1;
      }
      else
      {
        LOBYTE(v19) = sub_1001F9E0(0, 17);
        if ( (_BYTE)v19 )
        {
          *v8 = 256;
          *v5 = 2;
          *(_BYTE *)v6 = 17;
          return v19;
        }
      }
      if ( (_BYTE)v26 )
      {
        v25 = 0;
        v24 = 665;
        goto LABEL_72;
      }
      break;
    case 24:
    case 119:
    case 120:
    case 121:
    case 122:
      LOBYTE(v26) = 2;
      LOBYTE(v19) = sub_1001FAF0(1, (unsigned __int8 *)&v26, (_BYTE *)v6);
      if ( (_BYTE)v19 )
      {
        *v8 = 512;
        *v5 = 1;
      }
      else
      {
        LOBYTE(v19) = sub_1001F9E0(1, 19);
        if ( (_BYTE)v19 )
        {
          *v8 = 512;
          *v5 = 2;
          *(_BYTE *)v6 = 19;
          return v19;
        }
      }
      if ( (_BYTE)v26 != 1 )
      {
        v25 = 0;
        v24 = 691;
        goto LABEL_72;
      }
      break;
    case 27:
      *v5 = 2;
      LOBYTE(v19) = sub_1001FC70(1);
      if ( (_BYTE)v19 == 1 )
      {
        *v8 = 256;
        *(_BYTE *)v6 = 1;
      }
      else
      {
        LOBYTE(v19) = sub_1001F870(16);
        if ( (_BYTE)v19 == 1 )
        {
          *v8 = 4096;
          *(_BYTE *)v6 = 16;
        }
      }
      break;
    case 28:
      *v5 = 2;
      LOBYTE(v19) = sub_1001FC70(2);
      if ( (_BYTE)v19 == 1 )
      {
        *v8 = 256;
        *(_BYTE *)v6 = 2;
      }
      else
      {
        LOBYTE(v19) = sub_1001F870(17);
        if ( (_BYTE)v19 == 1 )
        {
          *v8 = 4096;
          *(_BYTE *)v6 = 17;
        }
      }
      break;
    case 29:
      *v5 = 2;
      LOBYTE(v19) = sub_1001FC70(3);
      if ( (_BYTE)v19 == 1 )
      {
        *v8 = 256;
        *(_BYTE *)v6 = 3;
      }
      else
      {
        LOBYTE(v19) = sub_1001F870(18);
        if ( (_BYTE)v19 == 1 )
        {
          *v8 = 4096;
          *(_BYTE *)v6 = 18;
        }
      }
      break;
    case 134:
      *v5 = 2;
      LOBYTE(v19) = sub_1001FC70(21);
      if ( (_BYTE)v19 == 1 )
      {
        *v8 = 256;
        *(_BYTE *)v6 = 21;
      }
      else
      {
        LOBYTE(v19) = sub_1001F870(19);
        if ( (_BYTE)v19 == 1 )
        {
          *v8 = 4096;
          *(_BYTE *)v6 = 19;
        }
      }
      break;
    default:
      v20 = sub_1001DC80(&a1, 1u, (int)&unk_100B6160, 12, 176, 176);
      LOBYTE(v26) = v20;
      if ( v20 >= 0xB0u )
      {
        v25 = 0;
        v24 = 848;
LABEL_72:
        LOBYTE(v19) = sub_1001B780("..\\lib\\adl\\iop_lru_utl.c", v24, v25, 0);
      }
      else
      {
        v21 = 6 * v20;
        v22 = dword_100B6164[2 * v21 / 4u];
        v19 = 2 * v21;
        *v8 = v22;
        LOBYTE(v22) = byte_100B6168[v19];
        *v5 = v22;
        switch ( (unsigned __int8)v22 )
        {
          case 0u:
            *(_DWORD *)v6 = *(int *)((char *)dword_100B6164 + v19);
            break;
          case 2u:
            *(_BYTE *)v6 = byte_100B6169[v19];
            *(_BYTE *)(v6 + 1) = byte_100B616A[v19];
            break;
          case 1u:
            LOBYTE(v19) = byte_100B6169[v19];
            *(_BYTE *)v6 = v19;
            break;
          default:
            v25 = 0;
            v24 = 841;
            goto LABEL_72;
          case 4u:
          case 5u:
          case 6u:
            return v19;
        }
      }
      break;
  }
  return v19;
}
// 100B6164: using guessed type int dword_100B6164[];

//----- (10033610) --------------------------------------------------------
unsigned int __cdecl sub_10033610(void *a1, int a2)
{
  unsigned int result; // eax@1

  result = sub_1003D1C0(a1, 0x1Fu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10033640) --------------------------------------------------------
int __cdecl sub_10033640(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 5u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10033670) --------------------------------------------------------
signed int __cdecl sub_10033670(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1003D270(a1, 0, 0xFFFFu, 30, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100336A0) --------------------------------------------------------
unsigned int __cdecl sub_100336A0(void *a1, int a2)
{
  unsigned int result; // eax@1

  result = sub_1003D1C0(a1, 0x16u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100336D0) --------------------------------------------------------
unsigned int __cdecl sub_100336D0(void *a1, int a2)
{
  void *v2; // esi@1
  signed int v3; // ebp@1
  signed int v4; // edi@1
  unsigned int result; // eax@2

  v2 = a1;
  v3 = 0;
  v4 = 0;
  do
  {
    result = sub_100336A0(v2, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v4;
    v2 = (char *)v2 + 22;
  }
  while ( v4 < 2 );
  return v3;
}

//----- (10033710) --------------------------------------------------------
signed int __cdecl sub_10033710(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1003D220(a1, 0, 0xFFu, 0xFFu, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10033740) --------------------------------------------------------
int __cdecl sub_10033740(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 6u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10033770) --------------------------------------------------------
int __cdecl sub_10033770(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_1003D220((unsigned __int8 *)(a1 + 24), 0, 9u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0(a1 + 16, -1.0, 1.0, COERCE_INT(-1.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0(a1 + 4, -9.8999998e24, 9.8999998e24, COERCE_INT(0.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0(a1, -9.8999998e24, 9.8999998e24, COERCE_INT(0.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0(a1 + 20, -1.0, 1.0, COERCE_INT(-1.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0(a1 + 8, -9.8999998e24, 9.8999998e24, COERCE_INT(9.8999998e24), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0(a1 + 12, -9.8999998e24, 9.8999998e24, COERCE_INT(9.8999998e24), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (100338F0) --------------------------------------------------------
int __cdecl sub_100338F0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 2u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10033920) --------------------------------------------------------
int __cdecl sub_10033920(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D270(a1, 0, 0x2Du, 11, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10033950) --------------------------------------------------------
int __cdecl sub_10033950(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_1003CFC0(a1 + 12, -9.8999998e24, 9.8999998e24, COERCE_INT(9.8999998e24), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0(a1 + 8, -9.8999998e24, 9.8999998e24, COERCE_INT(9.8999998e24), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0(a1, -9.8999998e24, 9.8999998e24, COERCE_INT(9.8999998e24), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0(a1 + 4, -9.8999998e24, 9.8999998e24, COERCE_INT(9.8999998e24), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10033A40) --------------------------------------------------------
int __cdecl sub_10033A40(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 0x16u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10033A70) --------------------------------------------------------
int __cdecl sub_10033A70(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 0x14u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10033AA0) --------------------------------------------------------
unsigned int __cdecl sub_10033AA0(void *a1, int a2)
{
  unsigned int result; // eax@1

  result = sub_1003D1C0(a1, 7u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10033AD0) --------------------------------------------------------
unsigned int __cdecl sub_10033AD0(void *a1, int a2)
{
  unsigned int result; // eax@1

  result = sub_1003D1C0(a1, 0x10u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10033B00) --------------------------------------------------------
int __cdecl sub_10033B00(int a1, int a2)
{
  signed int v2; // esi@1
  int result; // eax@1
  _BYTE *v4; // esi@7
  signed int v5; // edi@7
  signed int v6; // edi@17
  int v7; // esi@17
  signed int v8; // edi@25
  int v9; // esi@25
  signed int v10; // [sp+20h] [bp-4h]@1

  v2 = 0;
  v10 = 0;
  result = sub_1003D220((unsigned __int8 *)a1, 0, 0xAu, 0, a2);
  if ( result == 1 )
  {
    v10 = 1;
  }
  else if ( result )
  {
    return result;
  }
  do
  {
    if ( sub_1003D220((unsigned __int8 *)(v2 + a1 + 92), 0, 0xFFu, 0, a2) == 1 )
      v10 = 1;
    ++v2;
  }
  while ( v2 < 10 );
  v4 = (_BYTE *)(a1 + 52);
  v5 = 10;
  do
  {
    if ( sub_1003D310(v4, 0, 0xFFFFFFFF, 0, a2) == 1 )
      v10 = 1;
    v4 += 4;
    --v5;
  }
  while ( v5 );
  result = sub_1003CFC0(a1 + 8, -9.8999998e24, 9.8999998e24, COERCE_INT(0.0), a2);
  if ( result == 1 )
  {
    v10 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0(a1 + 4, -9.8999998e24, 9.8999998e24, COERCE_INT(0.0), a2);
  if ( result == 1 )
  {
    v10 = 1;
  }
  else if ( result )
  {
    return result;
  }
  v6 = 0;
  v7 = a1 + 104;
  do
  {
    result = sub_1003CFC0(v7, -9.8999998e24, 9.8999998e24, COERCE_INT(9.8999998e24), a2);
    if ( result == 1 )
    {
      v10 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v6;
    v7 += 4;
  }
  while ( v6 < 10 );
  result = sub_10033AD0((void *)(a1 + 144), a2);
  if ( result == 1 )
  {
    v10 = 1;
  }
  else if ( result )
  {
    return result;
  }
  v8 = 0;
  v9 = a1 + 12;
  do
  {
    result = sub_1003CFC0(v9, -9.8999998e24, 9.8999998e24, COERCE_INT(9.8999998e24), a2);
    if ( result == 1 )
    {
      v10 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v8;
    v9 += 4;
  }
  while ( v8 < 10 );
  return v10;
}

//----- (10033CC0) --------------------------------------------------------
int __cdecl sub_10033CC0(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D270(a1, 0, 0xCC8u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10033CF0) --------------------------------------------------------
signed int __cdecl sub_10033CF0(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1003D220(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10033D20) --------------------------------------------------------
int __cdecl sub_10033D20(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 0x64u, 0x19u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10033D50) --------------------------------------------------------
signed int __cdecl sub_10033D50(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_10033CF0((unsigned __int8 *)(a1 + 2), a2) == 1 )
    v2 = 1;
  if ( sub_10033CF0((unsigned __int8 *)(a1 + 1), a2) == 1 )
    v2 = 1;
  v3 = sub_10033CF0((unsigned __int8 *)a1, a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (10033DA0) --------------------------------------------------------
int __cdecl sub_10033DA0(void *a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_10033610(a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CE20((_BYTE *)a1 + 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10033DF0) --------------------------------------------------------
unsigned int __cdecl sub_10033DF0(void *a1, int a2)
{
  unsigned int result; // eax@1

  result = sub_1003D1C0(a1, 0xDu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10033E20) --------------------------------------------------------
int __cdecl sub_10033E20(int a1, int a2)
{
  int result; // eax@1

  result = sub_1003CFC0(a1, 0.0, 9.8999998e24, COERCE_INT(9.8999998e24), a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10033E60) --------------------------------------------------------
int __cdecl sub_10033E60(unsigned __int8 *a1)
{
  return sub_1003D220(a1, 0, 0x7Fu, 0, 0);
}

//----- (10033E80) --------------------------------------------------------
int __cdecl sub_10033E80(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10033EB0) --------------------------------------------------------
int __cdecl sub_10033EB0(int a1, int a2)
{
  int result; // eax@1

  result = sub_1003CFC0(a1, -1000000000.0, 1000000000.0, COERCE_INT(-1000000000.0), a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10033EF0) --------------------------------------------------------
signed int __cdecl sub_10033EF0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1003D270(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10033F20) --------------------------------------------------------
int __cdecl sub_10033F20(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_10033950(a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033950(a1 + 16, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033950(a1 + 32, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10033F80) --------------------------------------------------------
unsigned int __cdecl sub_10033F80(void *a1, int a2)
{
  unsigned int result; // eax@1

  result = sub_1003D1C0(a1, 0x40u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10033FB0) --------------------------------------------------------
int __cdecl sub_10033FB0(unsigned __int8 *a1)
{
  return sub_1003D220(a1, 0, 3u, 0, 0);
}

//----- (10033FD0) --------------------------------------------------------
int __cdecl sub_10033FD0(int a1, int a2)
{
  int result; // eax@1

  result = sub_1003CFC0(a1, 0.0, 9.8999998e24, COERCE_INT(0.0), a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10034010) --------------------------------------------------------
signed int __cdecl sub_10034010(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1003D310(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10034040) --------------------------------------------------------
int __cdecl sub_10034040(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_10033740((unsigned __int8 *)(a1 + 9), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_1003D270((_BYTE *)a1, 0, 0xFFFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_1003CFC0(a1 + 4, -9.8999998e24, 9.8999998e24, COERCE_INT(9.8999998e24), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033A40((unsigned __int8 *)(a1 + 8), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (100340E0) --------------------------------------------------------
int __cdecl sub_100340E0(int a1, int a2)
{
  int result; // eax@1

  result = sub_1003CFC0(a1, 0.0, 5000000.0, COERCE_INT(0.0), a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10034120) --------------------------------------------------------
int __cdecl sub_10034120(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_1003D220((unsigned __int8 *)(a1 + 5), 0, 6u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0(a1 + 8, -9.8999998e24, 9.8999998e24, COERCE_INT(1.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033AA0((void *)(a1 + 12), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0(a1 + 20, -1.0, 1.0, COERCE_INT(-1.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0(a1 + 24, -1.0, 1.0, COERCE_INT(-1.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003D220((unsigned __int8 *)(a1 + 4), 0, 0x14u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0(a1, -9.8999998e24, 9.8999998e24, COERCE_INT(0.0), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10034270) --------------------------------------------------------
int __cdecl sub_10034270(int a1, int a2)
{
  int result; // eax@1

  result = sub_1003CFC0(a1, -9.8999998e24, 9.8999998e24, COERCE_INT(9.8999998e24), a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100342B0) --------------------------------------------------------
signed int __cdecl sub_100342B0(_BYTE *a1, int a2)
{
  signed int result; // eax@1

  result = sub_1003CE20(a1, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100342E0) --------------------------------------------------------
unsigned int __cdecl sub_100342E0(void *a1, int a2)
{
  unsigned int result; // eax@1

  result = sub_1003D1C0(a1, 0xBu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10034310) --------------------------------------------------------
int __cdecl sub_10034310(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_10034270(a1 + 8, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10034270(a1 + 12, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10034270(a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10034270(a1 + 4, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10034390) --------------------------------------------------------
unsigned int __cdecl sub_10034390(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_10034270(a1 + 16, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10034270(a1 + 20, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033E20(a1 + 24, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033E20(a1 + 28, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100342B0((_BYTE *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100342E0((void *)(a1 + 1), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10034450) --------------------------------------------------------
int __cdecl sub_10034450(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D220(a1, 0, 4u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10034480) --------------------------------------------------------
signed int __usercall sub_10034480@<eax>(void *a1@<eax>, int a2@<esi>)
{
  void *v2; // edi@1
  signed int result; // eax@1
  _BYTE *v4; // ebx@3
  int v5; // [sp+0h] [bp-8h]@0

  v2 = a1;
  result = sub_1003D1C0(a1, 0x15u, v5);
  if ( !result || a2 == 2 )
  {
    v4 = (char *)v2 + 21;
    result = sub_10034450((unsigned __int8 *)v2 + 21, a2);
    if ( !result || a2 == 2 )
    {
      sub_10033670((_BYTE *)v2 + 22, a2);
      result = sub_1003CE20((_BYTE *)v2 + 58, 0, a2);
      if ( !result || a2 == 2 )
      {
        switch ( *v4 )
        {
          case 0:
            result = sub_10020B20((_BYTE *)v2 + 24, a2);
            if ( !result || a2 == 2 )
            {
              result = sub_10020AF0((_BYTE *)v2 + 26, a2);
              goto LABEL_16;
            }
            break;
          case 1:
            result = sub_10020B20((_BYTE *)v2 + 24, a2);
            if ( !result )
            {
              result = sub_1004D6C0((_BYTE *)v2 + 26, a2);
              goto LABEL_16;
            }
            break;
          case 2:
            result = sub_10020B20((_BYTE *)v2 + 24, a2);
            if ( !result )
            {
              result = sub_1003D1C0((char *)v2 + 26, 0x1Fu, a2);
              goto LABEL_16;
            }
            break;
          case 3:
            goto LABEL_18;
          default:
            result = sub_10033640((unsigned __int8 *)v2 + 24, a2);
LABEL_16:
            if ( !result || a2 == 2 )
            {
LABEL_18:
              if ( *((_BYTE *)v2 + 58) )
              {
                sub_10033710((unsigned __int8 *)v2 + 64, a2);
                result = sub_10033710((unsigned __int8 *)v2 + 65, a2);
                if ( *v4 == 3 )
                  result = -4;
              }
              else
              {
                result = sub_1003D1C0((char *)v2 + 68, 0x1Fu, a2);
                if ( !result || a2 == 2 )
                  result = sub_1003D1C0((char *)v2 + 99, 0x1Fu, a2);
              }
            }
            break;
        }
      }
    }
  }
  return result;
}

//----- (100345E0) --------------------------------------------------------
unsigned int __cdecl sub_100345E0(void *a1, int a2)
{
  void *v2; // esi@1
  signed int v3; // ebp@1
  signed int v4; // edi@1
  unsigned int result; // eax@2

  v2 = a1;
  v3 = 0;
  v4 = 0;
  do
  {
    result = sub_10033DF0(v2, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v4;
    v2 = (char *)v2 + 13;
  }
  while ( v4 < 40 );
  return v3;
}

//----- (10034620) --------------------------------------------------------
unsigned int __cdecl sub_10034620(void *a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_10033610(a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_1003D220((unsigned __int8 *)a1 + 31, 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  return v2;
}

//----- (10034670) --------------------------------------------------------
signed int __cdecl sub_10034670(void *a1, int a2)
{
  return sub_10034480(a1, a2);
}

//----- (10034680) --------------------------------------------------------
int __cdecl sub_10034680(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_10034270(a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10034270(a1 + 4, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (100346D0) --------------------------------------------------------
int __cdecl sub_100346D0(int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // esi@1
  int result; // eax@2
  signed int v5; // edi@6
  int v6; // esi@6
  signed int v7; // edi@11
  int v8; // esi@11
  signed int v9; // edi@16
  int v10; // esi@16
  signed int v11; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v11 = 0;
  v3 = a1 + 160;
  do
  {
    result = sub_10034680(v3, a2);
    if ( result == 1 )
    {
      v11 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v2;
    v3 += 8;
  }
  while ( v2 < 10 );
  v5 = 0;
  v6 = a1 + 240;
  do
  {
    result = sub_10034680(v6, a2);
    if ( result == 1 )
    {
      v11 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v5;
    v6 += 8;
  }
  while ( v5 < 10 );
  v7 = 0;
  v8 = a1;
  do
  {
    result = sub_10034680(v8, a2);
    if ( result == 1 )
    {
      v11 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v7;
    v8 += 8;
  }
  while ( v7 < 10 );
  v9 = 0;
  v10 = a1 + 80;
  do
  {
    result = sub_10034680(v10, a2);
    if ( result == 1 )
    {
      v11 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v9;
    v10 += 8;
  }
  while ( v9 < 10 );
  return v11;
}

//----- (100347A0) --------------------------------------------------------
int __cdecl sub_100347A0(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_10034270(a1 + 8, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10034270(a1 + 4, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033FD0(a1, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10034800) --------------------------------------------------------
unsigned int __cdecl sub_10034800(void *a1, int a2)
{
  unsigned int result; // eax@1

  result = sub_10033AA0(a1, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10034830) --------------------------------------------------------
int __cdecl sub_10034830(void *a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_1003D220((unsigned __int8 *)a1 + 32, 0, 9u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0((int)a1 + 24, -1.0, 1.0, COERCE_INT(-1.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033AD0(a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0((int)a1 + 28, -1.0, 1.0, COERCE_INT(-1.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0((int)a1 + 16, -9.8999998e24, 9.8999998e24, COERCE_INT(9.8999998e24), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003CFC0((int)a1 + 20, -9.8999998e24, 9.8999998e24, COERCE_INT(9.8999998e24), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10034950) --------------------------------------------------------
int __cdecl sub_10034950(unsigned __int8 *a1, int a2)
{
  signed int v2; // ebp@1
  int result; // eax@1
  signed int v4; // edi@4
  int v5; // esi@4

  v2 = 0;
  result = sub_1003D220(a1, 0, 0x32u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  v4 = 0;
  v5 = (int)(a1 + 4);
  do
  {
    result = sub_10034120(v5, a2);
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v4;
    v5 += 28;
  }
  while ( v4 < 50 );
  return v2;
}

//----- (100349B0) --------------------------------------------------------
int __cdecl sub_100349B0(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_10033CC0((_BYTE *)(a1 + 14), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033D20((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033D20((unsigned __int8 *)(a1 + 1), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_10033D50(a1 + 5, a2) == 1 )
    v2 = 1;
  if ( sub_10033D50(a1 + 8, a2) == 1 )
    v2 = 1;
  if ( sub_10033D50(a1 + 11, a2) == 1 )
    v2 = 1;
  if ( sub_10033D50(a1 + 2, a2) == 1 )
    v2 = 1;
  return v2;
}

//----- (10034A70) --------------------------------------------------------
unsigned int __cdecl sub_10034A70(void *a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@3

  v2 = 0;
  if ( sub_10033EF0((_BYTE *)a1 + 64, a2) == 1 )
    v2 = 1;
  result = sub_10033F80(a1, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10034AB0) --------------------------------------------------------
unsigned int __cdecl sub_10034AB0(void *a1, int a2)
{
  void *v2; // esi@1
  signed int v3; // ebp@1
  signed int v4; // edi@1
  unsigned int result; // eax@2

  v2 = a1;
  v3 = 0;
  v4 = 0;
  do
  {
    result = sub_10034A70(v2, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v4;
    v2 = (char *)v2 + 66;
  }
  while ( v4 < 4 );
  return v3;
}

//----- (10034AF0) --------------------------------------------------------
int __cdecl sub_10034AF0(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@5

  v2 = 0;
  if ( sub_10034010((_BYTE *)(a1 + 12), a2) == 1 )
    v2 = 1;
  if ( sub_10034010((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_1003D270((_BYTE *)(a1 + 2), 0, 0x3E8u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_10033EF0((_BYTE *)(a1 + 4), a2) == 1 )
    v2 = 1;
  result = sub_1004D680((_BYTE *)a1, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10034B80) --------------------------------------------------------
int __cdecl sub_10034B80(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_10033740((unsigned __int8 *)(a1 + 1), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033DA0((void *)(a1 + 88), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033F20(a1 + 40, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100208A0((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10034830((void *)(a1 + 4), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10034C20) --------------------------------------------------------
int __cdecl sub_10034C20(unsigned __int8 *a1, int a2)
{
  signed int v2; // edi@1
  int v3; // esi@1
  int result; // eax@2
  signed int v5; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v5 = 0;
  v3 = (int)(a1 + 4);
  do
  {
    result = sub_10034B80(v3, a2);
    if ( result == 1 )
    {
      v5 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v2;
    v3 += 120;
  }
  while ( v2 < 50 );
  result = sub_1003D220(a1, 0, 0x32u, 0, a2);
  if ( result != 1 && !result )
    result = v5;
  return result;
}

//----- (10034C90) --------------------------------------------------------
int __cdecl sub_10034C90(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_100340E0(a1 + 4, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100340E0(a1, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10034CE0) --------------------------------------------------------
unsigned int __cdecl sub_10034CE0(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_10034310(a1 + 28, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10034270(a1 + 16, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10034270(a1 + 20, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033E20(a1 + 24, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100342B0((_BYTE *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100342E0((void *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_10033EF0((_BYTE *)(a1 + 44), a2) == 1 )
    v2 = 1;
  result = sub_100342B0((_BYTE *)(a1 + 1), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10034DD0) --------------------------------------------------------
int __cdecl sub_10034DD0(int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // esi@1
  int result; // eax@2
  signed int v5; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v5 = 0;
  v3 = a1;
  do
  {
    result = sub_100347A0(v3, a2);
    if ( result == 1 )
    {
      v5 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v2;
    v3 += 12;
  }
  while ( v2 < 50 );
  result = sub_10033EB0(a1 + 608, a2);
  if ( result == 1 )
  {
    v5 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033E20(a1 + 612, a2);
  if ( result == 1 )
  {
    v5 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033EB0(a1 + 600, a2);
  if ( result == 1 )
  {
    v5 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033E20(a1 + 604, a2);
  if ( result == 1 )
  {
    v5 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033E20(a1 + 616, a2);
  if ( result == 1 )
  {
    v5 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033E20(a1 + 620, a2);
  if ( result == 1 )
  {
    result = 1;
  }
  else if ( !result )
  {
    result = v5;
  }
  return result;
}

//----- (10034EE0) --------------------------------------------------------
int __cdecl sub_10034EE0(int a1, int a2)
{
  signed int v2; // ebp@1
  void *v3; // edi@1
  int result; // eax@2
  signed int v5; // edi@17
  signed int v6; // ebp@22
  int v7; // edi@22
  signed int v8; // [sp+20h] [bp-4h]@1

  v2 = 0;
  v8 = 0;
  v3 = (void *)(a1 + 1576);
  do
  {
    result = sub_10034620(v3, a2);
    if ( result == 1 )
    {
      v8 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v2;
    v3 = (char *)v3 + 35;
  }
  while ( v2 < 4 );
  result = sub_10033F20(a1 + 92, a2);
  if ( result == 1 )
  {
    v8 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_1003D270((_BYTE *)(a1 + 76), 0, 0xFFFFu, 0, a2) == 1 )
    v8 = 1;
  result = sub_10034040(a1 + 80, a2);
  if ( result == 1 )
  {
    v8 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033A70((unsigned __int8 *)(a1 + 72), a2);
  if ( result == 1 )
  {
    v8 = 1;
  }
  else if ( result )
  {
    return result;
  }
  v5 = 0;
  do
  {
    result = sub_1003CE20((_BYTE *)(a1 + v5 + 1716), 0, a2);
    if ( result == 1 )
    {
      v8 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v5;
  }
  while ( v5 < 4 );
  v6 = 0;
  v7 = a1 + 1720;
  do
  {
    result = sub_1003CFC0(v7, -9.8999998e24, 9.8999998e24, COERCE_INT(0.0), a2);
    if ( result == 1 )
    {
      v8 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v6;
    v7 += 4;
  }
  while ( v6 < 4 );
  result = sub_10034800((void *)(a1 + 1736), a2);
  if ( result == 1 )
  {
    v8 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10034800((void *)(a1 + 1743), a2);
  if ( result == 1 )
  {
    v8 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033DA0((void *)(a1 + 1544), a2);
  if ( result == 1 )
  {
    v8 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10034830((void *)(a1 + 36), a2);
  if ( result == 1 )
  {
    v8 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033A40((unsigned __int8 *)(a1 + 73), a2);
  if ( result == 1 )
  {
    v8 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033920((_BYTE *)(a1 + 78), a2);
  if ( result == 1 )
  {
    v8 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_10033CF0((unsigned __int8 *)(a1 + 74), a2) == 1 )
    v8 = 1;
  result = sub_10034950((unsigned __int8 *)(a1 + 140), a2);
  if ( result == 1 )
  {
    v8 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10034830((void *)a1, a2);
  if ( result == 1 )
  {
    result = 1;
  }
  else if ( !result )
  {
    result = v8;
  }
  return result;
}

//----- (10035150) --------------------------------------------------------
int __cdecl sub_10035150(int a1, int a2)
{
  int v2; // esi@1
  signed int v3; // ebp@1
  signed int v4; // edi@1
  int result; // eax@2

  v2 = a1;
  v3 = 0;
  v4 = 0;
  do
  {
    result = sub_10034AF0(v2, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v4;
    v2 += 16;
  }
  while ( v4 < 32 );
  return v3;
}

//----- (10035190) --------------------------------------------------------
signed int __cdecl sub_10035190(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1003D270(a1, 0, 0xFFFFu, -1, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100351C0) --------------------------------------------------------
signed int __cdecl sub_100351C0(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@3
  signed int result; // eax@3

  v2 = 0;
  if ( sub_10035190((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_10035190((_BYTE *)a1, a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (10035200) --------------------------------------------------------
void *__cdecl sub_10035200(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_100B7838;
        break;
      case 0:
        result = &unk_100B783C;
        break;
      case 1:
        result = &unk_100B7840;
        break;
      case 2:
        result = &unk_100B78C8;
        break;
      case 3:
        result = &unk_100B793C;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (10035260) --------------------------------------------------------
void sub_10035260()
{
  dword_10202010 = -15;
}
// 10202010: using guessed type int dword_10202010;

//----- (10035270) --------------------------------------------------------
char __cdecl sub_10035270(const void *a1)
{
  char result; // al@2
  __int16 v2; // [sp+4h] [bp-3Ch]@1
  char v3; // [sp+8h] [bp-38h]@2

  LOBYTE(v2) = 0;
  if ( a1 )
  {
    v2 = -32714;
    qmemcpy(&v3, a1, 0x34u);
    result = sub_10023A90((int)&v2);
  }
  return result;
}

//----- (100352C0) --------------------------------------------------------
signed int sub_100352C0()
{
  return sub_1004F6B0((int)&off_100B79FC);
}
// 100B79FC: using guessed type char *off_100B79FC;

//----- (100352D0) --------------------------------------------------------
char __cdecl sub_100352D0(void *a1)
{
  char v1; // bl@1

  v1 = 0;
  if ( a1 && (unsigned __int8)sub_100352C0() == 1 && !sub_1004E560(37, 100) )
  {
    qmemcpy(a1, (const void *)(dword_10202010 + 8), 0x34u);
    v1 = 1;
    sub_1004E540(37);
  }
  return v1;
}
// 10202010: using guessed type int dword_10202010;

//----- (10035320) --------------------------------------------------------
bool sub_10035320()
{
  char v0; // bl@1
  unsigned int v2; // [sp+4h] [bp-4h]@1

  v0 = sub_1003D500((char *)&v2);
  return (unsigned __int8)sub_100352C0() && v0 && v2 < *(_DWORD *)(dword_10202010 + 60) + 18;
}
// 10202010: using guessed type int dword_10202010;

//----- (10035360) --------------------------------------------------------
signed int __cdecl sub_10035360(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_10202015 = 1;
    byte_10202014 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_10202014 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_10202015 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 10202014: using guessed type char byte_10202014;
// 10202015: using guessed type char byte_10202015;

//----- (100353C0) --------------------------------------------------------
bool __cdecl sub_100353C0(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_10030940(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_100CF608, (int)"failing_subroutine( depth-1 )");
    sub_100353C0(a1 - 1);
    exit_0(14);
  }
  return sub_10028CF0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (10035430) --------------------------------------------------------
int sub_10035430()
{
  const char *v0; // eax@1

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_10202014 )
  {
    sub_10028CF0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_10030940(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_100353C0(1);
    exit_0(14);
  }
  return sub_10030970(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 10202014: using guessed type char byte_10202014;

//----- (10035750) --------------------------------------------------------
char sub_10035750()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10202014 )
  {
    v2 = 0;
    do
    {
      if ( off_100B867C[v2] )
      {
        sub_10024020((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100B8684[v2 * 4], 0x100u, &v11);
        sub_10024020((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100B867C[v2], 0x100u, &v12);
        sub_10044390(&v12, &v11);
      }
      if ( byte_100B8678[v2 * 4] )
      {
        sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = off_100B8680[v2];
        v4 = *(char **)&off_100B8684[v2 * 4];
        v5 = sub_100242C0(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100B8684[v2 * 4],
               off_100B8680[v2]);
        v6 = sub_10028940(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_10024620(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"731",
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = off_100B8680[v2];
        v8 = *(char **)&off_100B8684[v2 * 4];
        v9 = sub_100242C0(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100B8684[v2 * 4],
               off_100B8680[v2]);
        v10 = sub_10028940(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_10024620(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"741",
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"704",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100B867C: using guessed type char *off_100B867C[3];
// 100B8680: using guessed type char *off_100B8680[2];
// 10202014: using guessed type char byte_10202014;

//----- (10035970) --------------------------------------------------------
char sub_10035970()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10202014 )
  {
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_10024620(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"777",
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_10024620(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_10024620(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_10024620(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"782",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"784", 2, 2);
    v4 = sub_10024620(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_10024620(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"788", 2, 2);
    v5 = sub_10024620(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_10024620(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"790",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10202014: using guessed type char byte_10202014;

//----- (10035B70) --------------------------------------------------------
char sub_10035B70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B870C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_100B8709[v2 * 4];
        v4 = byte_100B8708[v2 * 4];
        v5 = sub_100242C0(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + dword_100B870C[v2])],
               (&off_100B8710)[v2 * 4]);
        v6 = sub_10024760(
               0,
               *(&dword_100B865C + dword_100B870C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_100242C0(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100B870C[v2]],
               (&off_100B8710)[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B870C: using guessed type int dword_100B870C[];
// 100B8710: using guessed type char *off_100B8710;
// 10202014: using guessed type char byte_10202014;

//----- (10035CF0) --------------------------------------------------------
char sub_10035CF0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B8990[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100B8988[v2 / 8];
        v4 = dbl_100B8980[v2 / 8];
        v5 = dbl_100B8978[v2 / 8];
        v6 = sub_100242C0(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               *(_DWORD *)&off_100B8994[v2]);
        v7 = sub_10024B10(
               0,
               *(&dword_100B865C + dword_100B8990[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100B8990[v2 / 4]],
               *(_DWORD *)&off_100B8994[v2]);
        LOBYTE(v0) = sub_10024620(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B8978: using guessed type double dbl_100B8978[];
// 100B8980: using guessed type double dbl_100B8980[];
// 100B8988: using guessed type double dbl_100B8988[];
// 100B8990: using guessed type int dword_100B8990[];
// 10202014: using guessed type char byte_10202014;

//----- (10035E70) --------------------------------------------------------
char sub_10035E70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B95A4[v2];
      if ( v0 != 6 )
      {
        v3 = flt_100B95A0[v2];
        v4 = flt_100B959C[v2];
        v5 = flt_100B9598[v2];
        v6 = sub_100242C0(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               *(_DWORD *)&off_100B95A8[v2 * 4]);
        v7 = sub_10024F60(
               0,
               *(&dword_100B865C + dword_100B95A4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100B95A4[v2]],
               *(_DWORD *)&off_100B95A8[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B9598: using guessed type float flt_100B9598[];
// 100B959C: using guessed type float flt_100B959C[];
// 100B95A0: using guessed type float flt_100B95A0[];
// 100B95A4: using guessed type int dword_100B95A4[];
// 10202014: using guessed type char byte_10202014;

//----- (10035FE0) --------------------------------------------------------
char sub_10035FE0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10202014 )
  {
    sub_10028C40(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_10035FE0,
      (int)sub_10035FE0,
      (int)"This test is expected to fail");
    sub_10028C40(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_10035FE0,
      0,
      (int)"This test is expected to fail");
    result = sub_10028C40(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10035FE0,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10202014: using guessed type char byte_10202014;

//----- (100360E0) --------------------------------------------------------
char sub_100360E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100B9D4C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B9D48[v2];
        v4 = dword_100B9D44[v2];
        v5 = dword_100B9D40[v2];
        v6 = sub_100242C0(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               (&off_100B9D50)[v2 * 4]);
        v7 = sub_10025420(
               0,
               *(&dword_100B865C + dword_100B9D4C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100B9D4C[v2]],
               (&off_100B9D50)[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B9D40: using guessed type int dword_100B9D40[];
// 100B9D44: using guessed type int dword_100B9D44[];
// 100B9D48: using guessed type int dword_100B9D48[];
// 100B9D4C: using guessed type int dword_100B9D4C[];
// 100B9D50: using guessed type char *off_100B9D50;
// 10202014: using guessed type char byte_10202014;

//----- (10036240) --------------------------------------------------------
char sub_10036240()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100BA4E0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100BA4DC[v2 / 2];
        v4 = word_100BA4DA[v2 / 2];
        v5 = word_100BA4D8[v2 / 2];
        v6 = sub_100242C0(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               (&off_100BA4E4)[v2]);
        v7 = sub_100257E0(
               0,
               *(&dword_100B865C + dword_100BA4E0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100BA4E0[v2 / 4]],
               (&off_100BA4E4)[v2]);
        LOBYTE(v0) = sub_10024620(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100BA4D8: using guessed type __int16 word_100BA4D8[];
// 100BA4DA: using guessed type __int16 word_100BA4DA[];
// 100BA4DC: using guessed type __int16 word_100BA4DC[];
// 100BA4E0: using guessed type int dword_100BA4E0[];
// 100BA4E4: using guessed type char *off_100BA4E4;
// 10202014: using guessed type char byte_10202014;

//----- (100363A0) --------------------------------------------------------
char sub_100363A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100BAAF4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100BAAF0[v2];
        v4 = dword_100BAAEC[v2];
        v5 = dword_100BAAE8[v2];
        v6 = sub_100242C0(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               *(_DWORD *)&off_100BAAF8[v2 * 4]);
        v7 = sub_10025BE0(
               0,
               *(&dword_100B865C + dword_100BAAF4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100BAAF4[v2]],
               *(_DWORD *)&off_100BAAF8[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100BAAE8: using guessed type int dword_100BAAE8[];
// 100BAAEC: using guessed type int dword_100BAAEC[];
// 100BAAF0: using guessed type int dword_100BAAF0[];
// 100BAAF4: using guessed type int dword_100BAAF4[];
// 10202014: using guessed type char byte_10202014;

//----- (10036500) --------------------------------------------------------
char sub_10036500()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100BB298[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100BB294[v2];
        LODWORD(v3) = dword_100BB290[v2];
        HIDWORD(v4) = dword_100BB28C[v2];
        LODWORD(v4) = dword_100BB288[v2];
        HIDWORD(v5) = dword_100BB284[v2];
        LODWORD(v5) = dword_100BB280[v2];
        v6 = sub_100242C0(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               *(_DWORD *)&off_100BB29C[v2 * 4]);
        v7 = sub_10025FA0(
               0,
               *(&dword_100B865C + dword_100BB298[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100BB298[v2]],
               *(_DWORD *)&off_100BB29C[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100BB280: using guessed type int dword_100BB280[];
// 100BB284: using guessed type int dword_100BB284[];
// 100BB288: using guessed type int dword_100BB288[];
// 100BB28C: using guessed type int dword_100BB28C[];
// 100BB290: using guessed type int dword_100BB290[];
// 100BB294: using guessed type int dword_100BB294[];
// 100BB298: using guessed type int dword_100BB298[];
// 10202014: using guessed type char byte_10202014;

//----- (10036670) --------------------------------------------------------
char sub_10036670()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100BBEA4[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100BBEA2[v2 * 4];
        v4 = byte_100BBEA1[v2 * 4];
        v5 = byte_100BBEA0[v2 * 4];
        v6 = sub_100242C0(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               (&off_100BBEA8)[v2 * 4]);
        v7 = sub_100264E0(
               0,
               *(&dword_100B865C + dword_100BBEA4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100BBEA4[v2]],
               (&off_100BBEA8)[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100BBEA4: using guessed type int dword_100BBEA4[];
// 100BBEA8: using guessed type char *off_100BBEA8;
// 10202014: using guessed type char byte_10202014;

//----- (100367D0) --------------------------------------------------------
char sub_100367D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100BC33C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100BC338[v2];
        v4 = dword_100BC334[v2];
        v5 = dword_100BC330[v2];
        v6 = sub_100242C0(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               (&off_100BC340)[v2 * 4]);
        v7 = sub_100268C0(
               0,
               *(&dword_100B865C + dword_100BC33C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100BC33C[v2]],
               (&off_100BC340)[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100BC330: using guessed type int dword_100BC330[];
// 100BC334: using guessed type int dword_100BC334[];
// 100BC338: using guessed type int dword_100BC338[];
// 100BC33C: using guessed type int dword_100BC33C[];
// 100BC340: using guessed type char *off_100BC340;
// 10202014: using guessed type char byte_10202014;

//----- (10036930) --------------------------------------------------------
char sub_10036930()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10202014 )
  {
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_10028CF0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           &byte_100647C9,
           (int)"This test is expected to fail");
    sub_10024620(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_10028CF0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           &byte_100647C9,
           "a",
           (int)"This test is expected to fail");
    sub_10024620(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_10028CF0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           &byte_100647C9,
           &byte_100647C9,
           (int)"This test is expected to fail");
    sub_10024620(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_10028CF0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_10024620(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10202014: using guessed type char byte_10202014;

//----- (10036B50) --------------------------------------------------------
char sub_10036B50()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100BCAD4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100BCAD0[v2];
        v4 = dword_100BCACC[v2];
        v5 = dword_100BCAC8[v2];
        v6 = sub_100242C0(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               *(_DWORD *)&off_100BCAD8[v2 * 4]);
        v7 = sub_10026C80(
               0,
               *(&dword_100B865C + dword_100BCAD4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100BCAD4[v2]],
               *(_DWORD *)&off_100BCAD8[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100BCAC8: using guessed type int dword_100BCAC8[];
// 100BCACC: using guessed type int dword_100BCACC[];
// 100BCAD0: using guessed type int dword_100BCAD0[];
// 100BCAD4: using guessed type int dword_100BCAD4[];
// 10202014: using guessed type char byte_10202014;

//----- (10036CB0) --------------------------------------------------------
char sub_10036CB0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100BCE40[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100BCE3C[v2 / 2];
        v4 = word_100BCE3A[v2 / 2];
        v5 = word_100BCE38[v2 / 2];
        v6 = sub_100242C0(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               (&off_100BCE44)[v2]);
        v7 = sub_10027020(
               0,
               *(&dword_100B865C + dword_100BCE40[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100BCE40[v2 / 4]],
               (&off_100BCE44)[v2]);
        LOBYTE(v0) = sub_10024620(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100BCE38: using guessed type __int16 word_100BCE38[];
// 100BCE3A: using guessed type __int16 word_100BCE3A[];
// 100BCE3C: using guessed type __int16 word_100BCE3C[];
// 100BCE40: using guessed type int dword_100BCE40[];
// 100BCE44: using guessed type char *off_100BCE44;
// 10202014: using guessed type char byte_10202014;

//----- (10036E10) --------------------------------------------------------
char sub_10036E10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100BD104[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100BD100[v2];
        v4 = dword_100BD0FC[v2];
        v5 = dword_100BD0F8[v2];
        v6 = sub_100242C0(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               *(_DWORD *)&off_100BD108[v2 * 4]);
        v7 = sub_10027420(
               0,
               *(&dword_100B865C + dword_100BD104[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100BD104[v2]],
               *(_DWORD *)&off_100BD108[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100BD0F8: using guessed type int dword_100BD0F8[];
// 100BD0FC: using guessed type int dword_100BD0FC[];
// 100BD100: using guessed type int dword_100BD100[];
// 100BD104: using guessed type int dword_100BD104[];
// 10202014: using guessed type char byte_10202014;

//----- (10036F70) --------------------------------------------------------
char sub_10036F70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100BD480[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100BD47C[v2];
        LODWORD(v3) = dword_100BD478[v2];
        HIDWORD(v4) = dword_100BD474[v2];
        LODWORD(v4) = dword_100BD470[v2];
        HIDWORD(v5) = dword_100BD46C[v2];
        LODWORD(v5) = dword_100BD468[v2];
        v6 = sub_100242C0(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               (&off_100BD484)[v2 * 4]);
        v7 = sub_100277C0(
               0,
               *(&dword_100B865C + dword_100BD480[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100BD480[v2]],
               (&off_100BD484)[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100BD468: using guessed type int dword_100BD468[];
// 100BD46C: using guessed type int dword_100BD46C[];
// 100BD470: using guessed type int dword_100BD470[];
// 100BD474: using guessed type int dword_100BD474[];
// 100BD478: using guessed type int dword_100BD478[];
// 100BD47C: using guessed type int dword_100BD47C[];
// 100BD480: using guessed type int dword_100BD480[];
// 100BD484: using guessed type char *off_100BD484;
// 10202014: using guessed type char byte_10202014;

//----- (100370E0) --------------------------------------------------------
char sub_100370E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100BD9EC[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100BD9EA[v2 * 4];
        v4 = byte_100BD9E9[v2 * 4];
        v5 = byte_100BD9E8[v2 * 4];
        v6 = sub_100242C0(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               (&off_100BD9F0)[v2 * 4]);
        v7 = sub_10027DA0(
               0,
               *(&dword_100B865C + dword_100BD9EC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100BD9EC[v2]],
               (&off_100BD9F0)[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100BD9EC: using guessed type int dword_100BD9EC[];
// 100BD9F0: using guessed type char *off_100BD9F0;
// 10202014: using guessed type char byte_10202014;

//----- (10037240) --------------------------------------------------------
char sub_10037240()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100BDC04[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100BDC00[v2];
        v4 = dword_100BDBFC[v2];
        v5 = dword_100BDBF8[v2];
        v6 = sub_100242C0(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               *(_DWORD *)&off_100BDC08[v2 * 4]);
        v7 = sub_10028190(
               0,
               *(&dword_100B865C + dword_100BDC04[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100BDC04[v2]],
               *(_DWORD *)&off_100BDC08[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100BDBF8: using guessed type int dword_100BDBF8[];
// 100BDBFC: using guessed type int dword_100BDBFC[];
// 100BDC00: using guessed type int dword_100BDC00[];
// 100BDC04: using guessed type int dword_100BDC04[];
// 10202014: using guessed type char byte_10202014;

//----- (100373A0) --------------------------------------------------------
char sub_100373A0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10202014 )
  {
    v2 = 0;
    do
    {
      if ( off_100BDF6C[v2] )
      {
        sub_10024020((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100BDF74[v2 * 4], 0x100u, &v11);
        sub_10024020((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100BDF6C[v2], 0x100u, &v12);
        sub_10044390(&v12, &v11);
      }
      if ( byte_100BDF68[v2 * 4] )
      {
        sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = off_100BDF70[v2];
        v4 = *(char **)&off_100BDF74[v2 * 4];
        v5 = sub_100242C0(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100BDF74[v2 * 4],
               off_100BDF70[v2]);
        v6 = sub_10028940(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_10024620(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = off_100BDF70[v2];
        v8 = *(char **)&off_100BDF74[v2 * 4];
        v9 = sub_100242C0(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100BDF74[v2 * 4],
               off_100BDF70[v2]);
        v10 = sub_10028940(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_10024620(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100BDF6C: using guessed type char *off_100BDF6C[3];
// 100BDF70: using guessed type char *off_100BDF70[2];
// 10202014: using guessed type char byte_10202014;

//----- (100375C0) --------------------------------------------------------
char sub_100375C0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_10202014 )
  {
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_10024620(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_10024620(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_10024620(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_10024620(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_10024620(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_10024620(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_10024620(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_10024620(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10202014: using guessed type char byte_10202014;

//----- (100377C0) --------------------------------------------------------
char sub_100377C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100BDFFC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_100BDFF9[v2 * 4];
        v4 = byte_100BDFF8[v2 * 4];
        v5 = sub_100242C0(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + dword_100BDFFC[v2])],
               (&off_100BE000)[v2 * 4]);
        v6 = sub_10024760(
               1,
               *(&dword_100B865C + dword_100BDFFC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_100242C0(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100BDFFC[v2]],
               (&off_100BE000)[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100BDFFC: using guessed type int dword_100BDFFC[];
// 100BE000: using guessed type char *off_100BE000;
// 10202014: using guessed type char byte_10202014;

//----- (10037940) --------------------------------------------------------
char sub_10037940()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100BE280[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100BE278[v2 / 8];
        v4 = dbl_100BE270[v2 / 8];
        v5 = dbl_100BE268[v2 / 8];
        v6 = sub_100242C0(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               (&off_100BE284)[v2]);
        v7 = sub_10024B10(
               1,
               *(&dword_100B865C + dword_100BE280[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100BE280[v2 / 4]],
               (&off_100BE284)[v2]);
        LOBYTE(v0) = sub_10024620(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100BE268: using guessed type double dbl_100BE268[];
// 100BE270: using guessed type double dbl_100BE270[];
// 100BE278: using guessed type double dbl_100BE278[];
// 100BE280: using guessed type int dword_100BE280[];
// 100BE284: using guessed type char *off_100BE284;
// 10202014: using guessed type char byte_10202014;

//----- (10037AC0) --------------------------------------------------------
char sub_10037AC0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100BEE94[v2];
      if ( v0 != 6 )
      {
        v3 = flt_100BEE90[v2];
        v4 = flt_100BEE8C[v2];
        v5 = flt_100BEE88[v2];
        v6 = sub_100242C0(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               *(_DWORD *)&off_100BEE98[v2 * 4]);
        v7 = sub_10024F60(
               1,
               *(&dword_100B865C + dword_100BEE94[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100BEE94[v2]],
               *(_DWORD *)&off_100BEE98[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100BEE88: using guessed type float flt_100BEE88[];
// 100BEE8C: using guessed type float flt_100BEE8C[];
// 100BEE90: using guessed type float flt_100BEE90[];
// 100BEE94: using guessed type int dword_100BEE94[];
// 10202014: using guessed type char byte_10202014;

//----- (10037C30) --------------------------------------------------------
char sub_10037C30()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10202014 )
  {
    sub_10028C40(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_10037C30,
      (int)sub_10037C30,
      0);
    sub_10028C40(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_10037C30,
      0,
      0);
    result = sub_10028C40(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10037C30,
               0);
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10202014: using guessed type char byte_10202014;

//----- (10037D20) --------------------------------------------------------
char sub_10037D20()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100BF62C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100BF628[v2];
        v4 = dword_100BF624[v2];
        v5 = dword_100BF620[v2];
        v6 = sub_100242C0(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               (&off_100BF630)[v2 * 4]);
        v7 = sub_10025420(
               1,
               *(&dword_100B865C + dword_100BF62C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100BF62C[v2]],
               (&off_100BF630)[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100BF620: using guessed type int dword_100BF620[];
// 100BF624: using guessed type int dword_100BF624[];
// 100BF628: using guessed type int dword_100BF628[];
// 100BF62C: using guessed type int dword_100BF62C[];
// 100BF630: using guessed type char *off_100BF630;
// 10202014: using guessed type char byte_10202014;

//----- (10037E80) --------------------------------------------------------
char sub_10037E80()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100BFDC0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100BFDBC[v2 / 2];
        v4 = word_100BFDBA[v2 / 2];
        v5 = word_100BFDB8[v2 / 2];
        v6 = sub_100242C0(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               (&off_100BFDC4)[v2]);
        v7 = sub_100257E0(
               1,
               *(&dword_100B865C + dword_100BFDC0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100BFDC0[v2 / 4]],
               (&off_100BFDC4)[v2]);
        LOBYTE(v0) = sub_10024620(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100BFDB8: using guessed type __int16 word_100BFDB8[];
// 100BFDBA: using guessed type __int16 word_100BFDBA[];
// 100BFDBC: using guessed type __int16 word_100BFDBC[];
// 100BFDC0: using guessed type int dword_100BFDC0[];
// 100BFDC4: using guessed type char *off_100BFDC4;
// 10202014: using guessed type char byte_10202014;

//----- (10037FE0) --------------------------------------------------------
char sub_10037FE0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100C03D4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100C03D0[v2];
        v4 = dword_100C03CC[v2];
        v5 = dword_100C03C8[v2];
        v6 = sub_100242C0(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               *(_DWORD *)&off_100C03D8[v2 * 4]);
        v7 = sub_10025BE0(
               1,
               *(&dword_100B865C + dword_100C03D4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100C03D4[v2]],
               *(_DWORD *)&off_100C03D8[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100C03C8: using guessed type int dword_100C03C8[];
// 100C03CC: using guessed type int dword_100C03CC[];
// 100C03D0: using guessed type int dword_100C03D0[];
// 100C03D4: using guessed type int dword_100C03D4[];
// 10202014: using guessed type char byte_10202014;

//----- (10038140) --------------------------------------------------------
char sub_10038140()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100C0B78[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100C0B74[v2];
        LODWORD(v3) = dword_100C0B70[v2];
        HIDWORD(v4) = dword_100C0B6C[v2];
        LODWORD(v4) = dword_100C0B68[v2];
        HIDWORD(v5) = dword_100C0B64[v2];
        LODWORD(v5) = dword_100C0B60[v2];
        v6 = sub_100242C0(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               *(_DWORD *)&off_100C0B7C[v2 * 4]);
        v7 = sub_10025FA0(
               1,
               *(&dword_100B865C + dword_100C0B78[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100C0B78[v2]],
               *(_DWORD *)&off_100C0B7C[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100C0B60: using guessed type int dword_100C0B60[];
// 100C0B64: using guessed type int dword_100C0B64[];
// 100C0B68: using guessed type int dword_100C0B68[];
// 100C0B6C: using guessed type int dword_100C0B6C[];
// 100C0B70: using guessed type int dword_100C0B70[];
// 100C0B74: using guessed type int dword_100C0B74[];
// 100C0B78: using guessed type int dword_100C0B78[];
// 10202014: using guessed type char byte_10202014;

//----- (100382B0) --------------------------------------------------------
char sub_100382B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100C1784[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100C1782[v2 * 4];
        v4 = byte_100C1781[v2 * 4];
        v5 = byte_100C1780[v2 * 4];
        v6 = sub_100242C0(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               (&off_100C1788)[v2 * 4]);
        v7 = sub_100264E0(
               1,
               *(&dword_100B865C + dword_100C1784[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100C1784[v2]],
               (&off_100C1788)[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100C1784: using guessed type int dword_100C1784[];
// 100C1788: using guessed type char *off_100C1788;
// 10202014: using guessed type char byte_10202014;

//----- (10038410) --------------------------------------------------------
char sub_10038410()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100C1C1C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100C1C18[v2];
        v4 = dword_100C1C14[v2];
        v5 = dword_100C1C10[v2];
        v6 = sub_100242C0(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               (&off_100C1C20)[v2 * 4]);
        v7 = sub_100268C0(
               1,
               *(&dword_100B865C + dword_100C1C1C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100C1C1C[v2]],
               (&off_100C1C20)[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100C1C10: using guessed type int dword_100C1C10[];
// 100C1C14: using guessed type int dword_100C1C14[];
// 100C1C18: using guessed type int dword_100C1C18[];
// 100C1C1C: using guessed type int dword_100C1C1C[];
// 100C1C20: using guessed type char *off_100C1C20;
// 10202014: using guessed type char byte_10202014;

//----- (10038570) --------------------------------------------------------
char sub_10038570()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10202014 )
  {
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_10028CF0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           &byte_100647C9,
           0);
    sub_10024620(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_10028CF0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           &byte_100647C9,
           "a",
           0);
    sub_10024620(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_10028CF0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           &byte_100647C9,
           &byte_100647C9,
           0);
    sub_10024620(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_10028CF0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_10024620(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10202014: using guessed type char byte_10202014;

//----- (10038770) --------------------------------------------------------
char sub_10038770()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100C23B4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100C23B0[v2];
        v4 = dword_100C23AC[v2];
        v5 = dword_100C23A8[v2];
        v6 = sub_100242C0(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               *(_DWORD *)&off_100C23B8[v2 * 4]);
        v7 = sub_10026C80(
               1,
               *(&dword_100B865C + dword_100C23B4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100C23B4[v2]],
               *(_DWORD *)&off_100C23B8[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100C23A8: using guessed type int dword_100C23A8[];
// 100C23AC: using guessed type int dword_100C23AC[];
// 100C23B0: using guessed type int dword_100C23B0[];
// 100C23B4: using guessed type int dword_100C23B4[];
// 10202014: using guessed type char byte_10202014;

//----- (100388D0) --------------------------------------------------------
char sub_100388D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100C2720[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100C271C[v2 / 2];
        v4 = word_100C271A[v2 / 2];
        v5 = word_100C2718[v2 / 2];
        v6 = sub_100242C0(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               (&off_100C2724)[v2]);
        v7 = sub_10027020(
               1,
               *(&dword_100B865C + dword_100C2720[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100C2720[v2 / 4]],
               (&off_100C2724)[v2]);
        LOBYTE(v0) = sub_10024620(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100C2718: using guessed type __int16 word_100C2718[];
// 100C271A: using guessed type __int16 word_100C271A[];
// 100C271C: using guessed type __int16 word_100C271C[];
// 100C2720: using guessed type int dword_100C2720[];
// 100C2724: using guessed type char *off_100C2724;
// 10202014: using guessed type char byte_10202014;

//----- (10038A30) --------------------------------------------------------
char sub_10038A30()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100C29E4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100C29E0[v2];
        v4 = dword_100C29DC[v2];
        v5 = dword_100C29D8[v2];
        v6 = sub_100242C0(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               *(_DWORD *)&off_100C29E8[v2 * 4]);
        v7 = sub_10027420(
               1,
               *(&dword_100B865C + dword_100C29E4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100C29E4[v2]],
               *(_DWORD *)&off_100C29E8[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100C29D8: using guessed type int dword_100C29D8[];
// 100C29DC: using guessed type int dword_100C29DC[];
// 100C29E0: using guessed type int dword_100C29E0[];
// 100C29E4: using guessed type int dword_100C29E4[];
// 10202014: using guessed type char byte_10202014;

//----- (10038B90) --------------------------------------------------------
char sub_10038B90()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100C2D60[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100C2D5C[v2];
        LODWORD(v3) = dword_100C2D58[v2];
        HIDWORD(v4) = dword_100C2D54[v2];
        LODWORD(v4) = dword_100C2D50[v2];
        HIDWORD(v5) = dword_100C2D4C[v2];
        LODWORD(v5) = dword_100C2D48[v2];
        v6 = sub_100242C0(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               (&off_100C2D64)[v2 * 4]);
        v7 = sub_100277C0(
               1,
               *(&dword_100B865C + dword_100C2D60[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100C2D60[v2]],
               (&off_100C2D64)[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100C2D48: using guessed type int dword_100C2D48[];
// 100C2D4C: using guessed type int dword_100C2D4C[];
// 100C2D50: using guessed type int dword_100C2D50[];
// 100C2D54: using guessed type int dword_100C2D54[];
// 100C2D58: using guessed type int dword_100C2D58[];
// 100C2D5C: using guessed type int dword_100C2D5C[];
// 100C2D60: using guessed type int dword_100C2D60[];
// 100C2D64: using guessed type char *off_100C2D64;
// 10202014: using guessed type char byte_10202014;

//----- (10038D00) --------------------------------------------------------
char sub_10038D00()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100C32CC[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100C32CA[v2 * 4];
        v4 = byte_100C32C9[v2 * 4];
        v5 = byte_100C32C8[v2 * 4];
        v6 = sub_100242C0(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               (&off_100C32D0)[v2 * 4]);
        v7 = sub_10027DA0(
               1,
               *(&dword_100B865C + dword_100C32CC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100C32CC[v2]],
               (&off_100C32D0)[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100C32CC: using guessed type int dword_100C32CC[];
// 100C32D0: using guessed type char *off_100C32D0;
// 10202014: using guessed type char byte_10202014;

//----- (10038E60) --------------------------------------------------------
char sub_10038E60()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10202014 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100C34E4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100C34E0[v2];
        v4 = dword_100C34DC[v2];
        v5 = dword_100C34D8[v2];
        v6 = sub_100242C0(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * *(&dword_100B865C + v0)],
               *(_DWORD *)&off_100C34E8[v2 * 4]);
        v7 = sub_10028190(
               1,
               *(&dword_100B865C + dword_100C34E4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_100242C0(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100C34E4[v2]],
               *(_DWORD *)&off_100C34E8[v2 * 4]);
        LOBYTE(v0) = sub_10024620(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100C34D8: using guessed type int dword_100C34D8[];
// 100C34DC: using guessed type int dword_100C34DC[];
// 100C34E0: using guessed type int dword_100C34E0[];
// 100C34E4: using guessed type int dword_100C34E4[];
// 10202014: using guessed type char byte_10202014;

//----- (10038FC0) --------------------------------------------------------
char sub_10038FC0()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_10202015 )
  {
    sub_10028CF0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_10025420(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_10025420(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_10025420(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_10025420(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_10025420(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_10025420(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_10025420(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_10025420(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_10025420(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_10025420(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_10030970(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_10025420(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_1003E9F0() )
      v1 = 3;
    sub_10025420(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_1003E9F0();
    sub_10025420(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_10030970(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_10025420(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10202015: using guessed type char byte_10202015;

//----- (10039560) --------------------------------------------------------
char sub_10039560()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10202015 )
  {
    v2 = 0;
    do
    {
      if ( off_100C384C[v2] )
      {
        sub_10024020((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100C3854[v2 * 4], 0x100u, &v13);
        sub_10024020((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100C384C[v2], 0x100u, &v14);
        sub_10044390(&v14, &v13);
      }
      if ( byte_100C3848[v2 * 4] )
      {
        sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = off_100C3850[v2];
        v4 = *(char **)&off_100C3854[v2 * 4];
        v5 = sub_100242C0(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100C3854[v2 * 4],
               off_100C3850[v2]);
        v12 = 1;
        v11 = sub_10028940(
                0,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2114",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = off_100C3850[v2];
        v7 = *(char **)&off_100C3854[v2 * 4];
        v8 = sub_100242C0(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100C3854[v2 * 4],
               off_100C3850[v2]);
        v12 = 1;
        v11 = sub_10028940(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2123",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_10024620(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C384C: using guessed type char *off_100C384C[3];
// 100C3850: using guessed type char *off_100C3850[2];
// 10202015: using guessed type char byte_10202015;

//----- (10039770) --------------------------------------------------------
char sub_10039770()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10202015 )
  {
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_10024620(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_10024620(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_10024620(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_10024620(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_10024620(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_10024620(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_10024620(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_10024620(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10202015: using guessed type char byte_10202015;

//----- (10039960) --------------------------------------------------------
char sub_10039960()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100C389C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_100C3899[v2 * 4];
        v4 = byte_100C3898[v2 * 4];
        v5 = sub_100242C0(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * dword_100C389C[v2]],
               (&off_100C38A0)[v2 * 4]);
        v6 = sub_10024760(0, dword_100C389C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_100242C0(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100C389C[v2]],
               (&off_100C38A0)[v2 * 4]);
        LOBYTE(v0) = sub_10024620(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100C389C: using guessed type int dword_100C389C[];
// 100C38A0: using guessed type char *off_100C38A0;
// 10202015: using guessed type char byte_10202015;

//----- (10039AD0) --------------------------------------------------------
char sub_10039AD0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_100C3B18[v2 / 2];
      v4 = dbl_100C3B10[v2 / 2];
      v5 = dbl_100C3B08[v2 / 2];
      v6 = sub_100242C0(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100C3B20[v2]],
             (&off_100C3B24)[v2 * 4]);
      v7 = sub_10024B10(0, dword_100C3B20[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100C3B20[v2]],
             (&off_100C3B24)[v2 * 4]);
      result = sub_10024620(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C3B08: using guessed type double dbl_100C3B08[];
// 100C3B10: using guessed type double dbl_100C3B10[];
// 100C3B18: using guessed type double dbl_100C3B18[];
// 100C3B20: using guessed type int dword_100C3B20[];
// 100C3B24: using guessed type char *off_100C3B24;
// 10202015: using guessed type char byte_10202015;

//----- (10039C40) --------------------------------------------------------
char sub_10039C40()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_100C4730[v2];
      v4 = flt_100C472C[v2];
      v5 = flt_100C4728[v2];
      v6 = sub_100242C0(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100C4734[v2]],
             *(_DWORD *)&off_100C4738[v2 * 4]);
      v7 = sub_10024F60(0, dword_100C4734[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100C4734[v2]],
             *(_DWORD *)&off_100C4738[v2 * 4]);
      result = sub_10024620(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C4728: using guessed type float flt_100C4728[];
// 100C472C: using guessed type float flt_100C472C[];
// 100C4730: using guessed type float flt_100C4730[];
// 100C4734: using guessed type int dword_100C4734[];
// 10202015: using guessed type char byte_10202015;

//----- (10039DA0) --------------------------------------------------------
char sub_10039DA0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10202015 )
  {
    sub_10028C40(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_10039DA0,
      (int)sub_10039DA0,
      0);
    sub_10028C40(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_10039DA0,
      0,
      0);
    result = sub_10028C40(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10039DA0,
               0);
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10202015: using guessed type char byte_10202015;

//----- (10039E90) --------------------------------------------------------
char sub_10039E90()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_100C4EC8[v2];
      v4 = dword_100C4EC4[v2];
      v5 = dword_100C4EC0[v2];
      v6 = sub_100242C0(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100C4ECC[v2]],
             (&off_100C4ED0)[v2 * 4]);
      v7 = sub_10025420(0, dword_100C4ECC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100C4ECC[v2]],
             (&off_100C4ED0)[v2 * 4]);
      result = sub_10024620(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C4EC0: using guessed type int dword_100C4EC0[];
// 100C4EC4: using guessed type int dword_100C4EC4[];
// 100C4EC8: using guessed type int dword_100C4EC8[];
// 100C4ECC: using guessed type int dword_100C4ECC[];
// 100C4ED0: using guessed type char *off_100C4ED0;
// 10202015: using guessed type char byte_10202015;

//----- (10039FF0) --------------------------------------------------------
char sub_10039FF0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_100C565C[v2 / 2];
      v4 = word_100C565A[v2 / 2];
      v5 = word_100C5658[v2 / 2];
      v6 = sub_100242C0(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100C5660[v2 / 4]],
             (&off_100C5664)[v2]);
      v7 = sub_100257E0(
             0,
             dword_100C5660[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100C5660[v2 / 4]],
             (&off_100C5664)[v2]);
      result = sub_10024620(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C5658: using guessed type __int16 word_100C5658[];
// 100C565A: using guessed type __int16 word_100C565A[];
// 100C565C: using guessed type __int16 word_100C565C[];
// 100C5660: using guessed type int dword_100C5660[];
// 100C5664: using guessed type char *off_100C5664;
// 10202015: using guessed type char byte_10202015;

//----- (1003A150) --------------------------------------------------------
char sub_1003A150()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_100C5C70[v2];
      v4 = dword_100C5C6C[v2];
      v5 = dword_100C5C68[v2];
      v6 = sub_100242C0(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100C5C74[v2]],
             *(_DWORD *)&off_100C5C78[v2 * 4]);
      v7 = sub_10025BE0(0, dword_100C5C74[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100C5C74[v2]],
             *(_DWORD *)&off_100C5C78[v2 * 4]);
      result = sub_10024620(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C5C68: using guessed type int dword_100C5C68[];
// 100C5C6C: using guessed type int dword_100C5C6C[];
// 100C5C70: using guessed type int dword_100C5C70[];
// 100C5C74: using guessed type int dword_100C5C74[];
// 10202015: using guessed type char byte_10202015;

//----- (1003A2B0) --------------------------------------------------------
char sub_1003A2B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_100C6414[v2];
      LODWORD(v3) = dword_100C6410[v2];
      HIDWORD(v4) = dword_100C640C[v2];
      LODWORD(v4) = dword_100C6408[v2];
      HIDWORD(v5) = dword_100C6404[v2];
      LODWORD(v5) = dword_100C6400[v2];
      v6 = sub_100242C0(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100C6418[v2]],
             *(_DWORD *)&off_100C641C[v2 * 4]);
      v7 = sub_10025FA0(0, dword_100C6418[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100C6418[v2]],
             *(_DWORD *)&off_100C641C[v2 * 4]);
      result = sub_10024620(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C6400: using guessed type int dword_100C6400[];
// 100C6404: using guessed type int dword_100C6404[];
// 100C6408: using guessed type int dword_100C6408[];
// 100C640C: using guessed type int dword_100C640C[];
// 100C6410: using guessed type int dword_100C6410[];
// 100C6414: using guessed type int dword_100C6414[];
// 100C6418: using guessed type int dword_100C6418[];
// 10202015: using guessed type char byte_10202015;

//----- (1003A420) --------------------------------------------------------
char sub_1003A420()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_100C7022[v2 * 4];
      v4 = byte_100C7021[v2 * 4];
      v5 = byte_100C7020[v2 * 4];
      v6 = sub_100242C0(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100C7024[v2]],
             (&off_100C7028)[v2 * 4]);
      v7 = sub_100264E0(0, dword_100C7024[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100C7024[v2]],
             (&off_100C7028)[v2 * 4]);
      result = sub_10024620(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C7024: using guessed type int dword_100C7024[];
// 100C7028: using guessed type char *off_100C7028;
// 10202015: using guessed type char byte_10202015;

//----- (1003A580) --------------------------------------------------------
char sub_1003A580()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_100C74B8[v2];
      v4 = dword_100C74B4[v2];
      v5 = dword_100C74B0[v2];
      v6 = sub_100242C0(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100C74BC[v2]],
             (&off_100C74C0)[v2 * 4]);
      v7 = sub_100268C0(0, dword_100C74BC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100C74BC[v2]],
             (&off_100C74C0)[v2 * 4]);
      result = sub_10024620(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C74B0: using guessed type int dword_100C74B0[];
// 100C74B4: using guessed type int dword_100C74B4[];
// 100C74B8: using guessed type int dword_100C74B8[];
// 100C74BC: using guessed type int dword_100C74BC[];
// 100C74C0: using guessed type char *off_100C74C0;
// 10202015: using guessed type char byte_10202015;

//----- (1003A6E0) --------------------------------------------------------
char sub_1003A6E0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10202015 )
  {
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_10028CF0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           &byte_100647C9,
           &byte_100647C9,
           0);
    sub_10024620(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_10028CF0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_10024620(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_10028CF0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           &byte_100647C9,
           0);
    sub_10024620(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_10028CF0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_10024620(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10202015: using guessed type char byte_10202015;

//----- (1003A8E0) --------------------------------------------------------
char sub_1003A8E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_100C7C50[v2];
      v4 = dword_100C7C4C[v2];
      v5 = dword_100C7C48[v2];
      v6 = sub_100242C0(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100C7C54[v2]],
             *(_DWORD *)&off_100C7C58[v2 * 4]);
      v7 = sub_10026C80(0, dword_100C7C54[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100C7C54[v2]],
             *(_DWORD *)&off_100C7C58[v2 * 4]);
      result = sub_10024620(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C7C48: using guessed type int dword_100C7C48[];
// 100C7C4C: using guessed type int dword_100C7C4C[];
// 100C7C50: using guessed type int dword_100C7C50[];
// 100C7C54: using guessed type int dword_100C7C54[];
// 10202015: using guessed type char byte_10202015;

//----- (1003AA40) --------------------------------------------------------
char sub_1003AA40()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_100C7FBC[v2 / 2];
      v4 = word_100C7FBA[v2 / 2];
      v5 = word_100C7FB8[v2 / 2];
      v6 = sub_100242C0(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100C7FC0[v2 / 4]],
             (&off_100C7FC4)[v2]);
      v7 = sub_10027020(
             0,
             dword_100C7FC0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100C7FC0[v2 / 4]],
             (&off_100C7FC4)[v2]);
      result = sub_10024620(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C7FB8: using guessed type __int16 word_100C7FB8[];
// 100C7FBA: using guessed type __int16 word_100C7FBA[];
// 100C7FBC: using guessed type __int16 word_100C7FBC[];
// 100C7FC0: using guessed type int dword_100C7FC0[];
// 100C7FC4: using guessed type char *off_100C7FC4;
// 10202015: using guessed type char byte_10202015;

//----- (1003ABA0) --------------------------------------------------------
char sub_1003ABA0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_100C8280[v2];
      v4 = dword_100C827C[v2];
      v5 = dword_100C8278[v2];
      v6 = sub_100242C0(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100C8284[v2]],
             *(_DWORD *)&off_100C8288[v2 * 4]);
      v7 = sub_10027420(0, dword_100C8284[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100C8284[v2]],
             *(_DWORD *)&off_100C8288[v2 * 4]);
      result = sub_10024620(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C8278: using guessed type int dword_100C8278[];
// 100C827C: using guessed type int dword_100C827C[];
// 100C8280: using guessed type int dword_100C8280[];
// 100C8284: using guessed type int dword_100C8284[];
// 10202015: using guessed type char byte_10202015;

//----- (1003AD00) --------------------------------------------------------
char sub_1003AD00()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_100C85FC[v2];
      LODWORD(v3) = dword_100C85F8[v2];
      HIDWORD(v4) = dword_100C85F4[v2];
      LODWORD(v4) = dword_100C85F0[v2];
      HIDWORD(v5) = dword_100C85EC[v2];
      LODWORD(v5) = dword_100C85E8[v2];
      v6 = sub_100242C0(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100C8600[v2]],
             (&off_100C8604)[v2 * 4]);
      v7 = sub_100277C0(0, dword_100C8600[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100C8600[v2]],
             (&off_100C8604)[v2 * 4]);
      result = sub_10024620(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C85E8: using guessed type int dword_100C85E8[];
// 100C85EC: using guessed type int dword_100C85EC[];
// 100C85F0: using guessed type int dword_100C85F0[];
// 100C85F4: using guessed type int dword_100C85F4[];
// 100C85F8: using guessed type int dword_100C85F8[];
// 100C85FC: using guessed type int dword_100C85FC[];
// 100C8600: using guessed type int dword_100C8600[];
// 100C8604: using guessed type char *off_100C8604;
// 10202015: using guessed type char byte_10202015;

//----- (1003AE70) --------------------------------------------------------
char sub_1003AE70()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_100C8B6A[v2 * 4];
      v4 = byte_100C8B69[v2 * 4];
      v5 = byte_100C8B68[v2 * 4];
      v6 = sub_100242C0(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100C8B6C[v2]],
             (&off_100C8B70)[v2 * 4]);
      v7 = sub_10027DA0(0, dword_100C8B6C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100C8B6C[v2]],
             (&off_100C8B70)[v2 * 4]);
      result = sub_10024620(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C8B6C: using guessed type int dword_100C8B6C[];
// 100C8B70: using guessed type char *off_100C8B70;
// 10202015: using guessed type char byte_10202015;

//----- (1003AFD0) --------------------------------------------------------
char sub_1003AFD0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_100C8D80[v2];
      v4 = dword_100C8D7C[v2];
      v5 = dword_100C8D78[v2];
      v6 = sub_100242C0(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100C8D84[v2]],
             *(_DWORD *)&off_100C8D88[v2 * 4]);
      v7 = sub_10028190(0, dword_100C8D84[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100C8D84[v2]],
             *(_DWORD *)&off_100C8D88[v2 * 4]);
      result = sub_10024620(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C8D78: using guessed type int dword_100C8D78[];
// 100C8D7C: using guessed type int dword_100C8D7C[];
// 100C8D80: using guessed type int dword_100C8D80[];
// 100C8D84: using guessed type int dword_100C8D84[];
// 10202015: using guessed type char byte_10202015;

//----- (1003B130) --------------------------------------------------------
char sub_1003B130()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10202015 )
  {
    v2 = 0;
    do
    {
      if ( off_100C90EC[v2] )
      {
        sub_10024020((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100C90F4[v2 * 4], 0x100u, &v13);
        sub_10024020((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_100C90EC[v2], 0x100u, &v14);
        sub_10044390(&v14, &v13);
      }
      if ( byte_100C90E8[v2 * 4] )
      {
        sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = off_100C90F0[v2];
        v4 = *(char **)&off_100C90F4[v2 * 4];
        v5 = sub_100242C0(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100C90F4[v2 * 4],
               off_100C90F0[v2]);
        v12 = 1;
        v11 = sub_10028940(
                1,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2745",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = off_100C90F0[v2];
        v7 = *(char **)&off_100C90F4[v2 * 4];
        v8 = sub_100242C0(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100C90F4[v2 * 4],
               off_100C90F0[v2]);
        v12 = 1;
        v11 = sub_10028940(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2754",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_10024620(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C90EC: using guessed type char *off_100C90EC[3];
// 100C90F0: using guessed type char *off_100C90F0[2];
// 10202015: using guessed type char byte_10202015;

//----- (1003B340) --------------------------------------------------------
char sub_1003B340()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10202015 )
  {
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_10024620(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_10024620(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_10024620(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_10024620(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_10024620(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_10024620(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_10024620(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_10024620(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10202015: using guessed type char byte_10202015;

//----- (1003B530) --------------------------------------------------------
char sub_1003B530()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      v0 = dword_100C913C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_100C9139[v2 * 4];
        v4 = byte_100C9138[v2 * 4];
        v5 = sub_100242C0(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100B8640[4 * dword_100C913C[v2]],
               (&off_100C9140)[v2 * 4]);
        v6 = sub_10024760(1, dword_100C913C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_100242C0(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100B8640[4 * dword_100C913C[v2]],
               (&off_100C9140)[v2 * 4]);
        LOBYTE(v0) = sub_10024620(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10030970(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100C913C: using guessed type int dword_100C913C[];
// 100C9140: using guessed type char *off_100C9140;
// 10202015: using guessed type char byte_10202015;

//----- (1003B6A0) --------------------------------------------------------
char sub_1003B6A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_100C93B8[v2 / 2];
      v4 = dbl_100C93B0[v2 / 2];
      v5 = dbl_100C93A8[v2 / 2];
      v6 = sub_100242C0(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100C93C0[v2]],
             (&off_100C93C4)[v2 * 4]);
      v7 = sub_10024B10(1, dword_100C93C0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100C93C0[v2]],
             (&off_100C93C4)[v2 * 4]);
      result = sub_10024620(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C93A8: using guessed type double dbl_100C93A8[];
// 100C93B0: using guessed type double dbl_100C93B0[];
// 100C93B8: using guessed type double dbl_100C93B8[];
// 100C93C0: using guessed type int dword_100C93C0[];
// 100C93C4: using guessed type char *off_100C93C4;
// 10202015: using guessed type char byte_10202015;

//----- (1003B810) --------------------------------------------------------
char sub_1003B810()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_100C9FD0[v2];
      v4 = flt_100C9FCC[v2];
      v5 = flt_100C9FC8[v2];
      v6 = sub_100242C0(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100C9FD4[v2]],
             *(_DWORD *)&off_100C9FD8[v2 * 4]);
      v7 = sub_10024F60(1, dword_100C9FD4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100C9FD4[v2]],
             *(_DWORD *)&off_100C9FD8[v2 * 4]);
      result = sub_10024620(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C9FC8: using guessed type float flt_100C9FC8[];
// 100C9FCC: using guessed type float flt_100C9FCC[];
// 100C9FD0: using guessed type float flt_100C9FD0[];
// 100C9FD4: using guessed type int dword_100C9FD4[];
// 10202015: using guessed type char byte_10202015;

//----- (1003B970) --------------------------------------------------------
char sub_1003B970()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10202015 )
  {
    sub_10028C40(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_1003B970,
      (int)sub_1003B970,
      0);
    sub_10028C40(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_1003B970,
      0,
      0);
    result = sub_10028C40(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1003B970,
               0);
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10202015: using guessed type char byte_10202015;

//----- (1003BA60) --------------------------------------------------------
char sub_1003BA60()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_100CA768[v2];
      v4 = dword_100CA764[v2];
      v5 = dword_100CA760[v2];
      v6 = sub_100242C0(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100CA76C[v2]],
             (&off_100CA770)[v2 * 4]);
      v7 = sub_10025420(1, dword_100CA76C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100CA76C[v2]],
             (&off_100CA770)[v2 * 4]);
      result = sub_10024620(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100CA760: using guessed type int dword_100CA760[];
// 100CA764: using guessed type int dword_100CA764[];
// 100CA768: using guessed type int dword_100CA768[];
// 100CA76C: using guessed type int dword_100CA76C[];
// 100CA770: using guessed type char *off_100CA770;
// 10202015: using guessed type char byte_10202015;

//----- (1003BBC0) --------------------------------------------------------
char sub_1003BBC0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_100CAEFC[v2 / 2];
      v4 = word_100CAEFA[v2 / 2];
      v5 = word_100CAEF8[v2 / 2];
      v6 = sub_100242C0(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100CAF00[v2 / 4]],
             (&off_100CAF04)[v2]);
      v7 = sub_100257E0(
             1,
             dword_100CAF00[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100CAF00[v2 / 4]],
             (&off_100CAF04)[v2]);
      result = sub_10024620(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100CAEF8: using guessed type __int16 word_100CAEF8[];
// 100CAEFA: using guessed type __int16 word_100CAEFA[];
// 100CAEFC: using guessed type __int16 word_100CAEFC[];
// 100CAF00: using guessed type int dword_100CAF00[];
// 100CAF04: using guessed type char *off_100CAF04;
// 10202015: using guessed type char byte_10202015;

//----- (1003BD20) --------------------------------------------------------
char sub_1003BD20()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_100CB510[v2];
      v4 = dword_100CB50C[v2];
      v5 = dword_100CB508[v2];
      v6 = sub_100242C0(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100CB514[v2]],
             *(_DWORD *)&off_100CB518[v2 * 4]);
      v7 = sub_10025BE0(1, dword_100CB514[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100CB514[v2]],
             *(_DWORD *)&off_100CB518[v2 * 4]);
      result = sub_10024620(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100CB508: using guessed type int dword_100CB508[];
// 100CB50C: using guessed type int dword_100CB50C[];
// 100CB510: using guessed type int dword_100CB510[];
// 100CB514: using guessed type int dword_100CB514[];
// 10202015: using guessed type char byte_10202015;

//----- (1003BE80) --------------------------------------------------------
char sub_1003BE80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_100CBCB4[v2];
      LODWORD(v3) = dword_100CBCB0[v2];
      HIDWORD(v4) = dword_100CBCAC[v2];
      LODWORD(v4) = dword_100CBCA8[v2];
      HIDWORD(v5) = dword_100CBCA4[v2];
      LODWORD(v5) = dword_100CBCA0[v2];
      v6 = sub_100242C0(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100CBCB8[v2]],
             *(_DWORD *)&off_100CBCBC[v2 * 4]);
      v7 = sub_10025FA0(1, dword_100CBCB8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100CBCB8[v2]],
             *(_DWORD *)&off_100CBCBC[v2 * 4]);
      result = sub_10024620(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100CBCA0: using guessed type int dword_100CBCA0[];
// 100CBCA4: using guessed type int dword_100CBCA4[];
// 100CBCA8: using guessed type int dword_100CBCA8[];
// 100CBCAC: using guessed type int dword_100CBCAC[];
// 100CBCB0: using guessed type int dword_100CBCB0[];
// 100CBCB4: using guessed type int dword_100CBCB4[];
// 100CBCB8: using guessed type int dword_100CBCB8[];
// 10202015: using guessed type char byte_10202015;

//----- (1003BFF0) --------------------------------------------------------
char sub_1003BFF0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_100CC8C2[v2 * 4];
      v4 = byte_100CC8C1[v2 * 4];
      v5 = byte_100CC8C0[v2 * 4];
      v6 = sub_100242C0(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100CC8C4[v2]],
             (&off_100CC8C8)[v2 * 4]);
      v7 = sub_100264E0(1, dword_100CC8C4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100CC8C4[v2]],
             (&off_100CC8C8)[v2 * 4]);
      result = sub_10024620(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100CC8C4: using guessed type int dword_100CC8C4[];
// 100CC8C8: using guessed type char *off_100CC8C8;
// 10202015: using guessed type char byte_10202015;

//----- (1003C150) --------------------------------------------------------
char sub_1003C150()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_100CCD58[v2];
      v4 = dword_100CCD54[v2];
      v5 = dword_100CCD50[v2];
      v6 = sub_100242C0(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100CCD5C[v2]],
             (&off_100CCD60)[v2 * 4]);
      v7 = sub_100268C0(1, dword_100CCD5C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100CCD5C[v2]],
             (&off_100CCD60)[v2 * 4]);
      result = sub_10024620(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100CCD50: using guessed type int dword_100CCD50[];
// 100CCD54: using guessed type int dword_100CCD54[];
// 100CCD58: using guessed type int dword_100CCD58[];
// 100CCD5C: using guessed type int dword_100CCD5C[];
// 100CCD60: using guessed type char *off_100CCD60;
// 10202015: using guessed type char byte_10202015;

//----- (1003C2B0) --------------------------------------------------------
char sub_1003C2B0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10030970(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_100241B0(0);
  sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_10030970(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10202015 )
  {
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_10028CF0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           &byte_100647C9,
           &byte_100647C9,
           0);
    sub_10024620(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_10028CF0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_10024620(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_10028CF0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           &byte_100647C9,
           0);
    sub_10024620(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_10028CF0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_10024620(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10202015: using guessed type char byte_10202015;

//----- (1003C4B0) --------------------------------------------------------
char sub_1003C4B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_100CD4F0[v2];
      v4 = dword_100CD4EC[v2];
      v5 = dword_100CD4E8[v2];
      v6 = sub_100242C0(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100CD4F4[v2]],
             *(_DWORD *)&off_100CD4F8[v2 * 4]);
      v7 = sub_10026C80(1, dword_100CD4F4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100CD4F4[v2]],
             *(_DWORD *)&off_100CD4F8[v2 * 4]);
      result = sub_10024620(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100CD4E8: using guessed type int dword_100CD4E8[];
// 100CD4EC: using guessed type int dword_100CD4EC[];
// 100CD4F0: using guessed type int dword_100CD4F0[];
// 100CD4F4: using guessed type int dword_100CD4F4[];
// 10202015: using guessed type char byte_10202015;

//----- (1003C610) --------------------------------------------------------
char sub_1003C610()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_100CD85C[v2 / 2];
      v4 = word_100CD85A[v2 / 2];
      v5 = word_100CD858[v2 / 2];
      v6 = sub_100242C0(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100CD860[v2 / 4]],
             (&off_100CD864)[v2]);
      v7 = sub_10027020(
             1,
             dword_100CD860[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100CD860[v2 / 4]],
             (&off_100CD864)[v2]);
      result = sub_10024620(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100CD858: using guessed type __int16 word_100CD858[];
// 100CD85A: using guessed type __int16 word_100CD85A[];
// 100CD85C: using guessed type __int16 word_100CD85C[];
// 100CD860: using guessed type int dword_100CD860[];
// 100CD864: using guessed type char *off_100CD864;
// 10202015: using guessed type char byte_10202015;

//----- (1003C770) --------------------------------------------------------
char sub_1003C770()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_100CDB20[v2];
      v4 = dword_100CDB1C[v2];
      v5 = dword_100CDB18[v2];
      v6 = sub_100242C0(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100CDB24[v2]],
             *(_DWORD *)&off_100CDB28[v2 * 4]);
      v7 = sub_10027420(1, dword_100CDB24[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100CDB24[v2]],
             *(_DWORD *)&off_100CDB28[v2 * 4]);
      result = sub_10024620(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100CDB18: using guessed type int dword_100CDB18[];
// 100CDB1C: using guessed type int dword_100CDB1C[];
// 100CDB20: using guessed type int dword_100CDB20[];
// 100CDB24: using guessed type int dword_100CDB24[];
// 10202015: using guessed type char byte_10202015;

//----- (1003C8D0) --------------------------------------------------------
char sub_1003C8D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_100CDE9C[v2];
      LODWORD(v3) = dword_100CDE98[v2];
      HIDWORD(v4) = dword_100CDE94[v2];
      LODWORD(v4) = dword_100CDE90[v2];
      HIDWORD(v5) = dword_100CDE8C[v2];
      LODWORD(v5) = dword_100CDE88[v2];
      v6 = sub_100242C0(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100CDEA0[v2]],
             (&off_100CDEA4)[v2 * 4]);
      v7 = sub_100277C0(1, dword_100CDEA0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100CDEA0[v2]],
             (&off_100CDEA4)[v2 * 4]);
      result = sub_10024620(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100CDE88: using guessed type int dword_100CDE88[];
// 100CDE8C: using guessed type int dword_100CDE8C[];
// 100CDE90: using guessed type int dword_100CDE90[];
// 100CDE94: using guessed type int dword_100CDE94[];
// 100CDE98: using guessed type int dword_100CDE98[];
// 100CDE9C: using guessed type int dword_100CDE9C[];
// 100CDEA0: using guessed type int dword_100CDEA0[];
// 100CDEA4: using guessed type char *off_100CDEA4;
// 10202015: using guessed type char byte_10202015;

//----- (1003CA40) --------------------------------------------------------
char sub_1003CA40()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_100CE40A[v2 * 4];
      v4 = byte_100CE409[v2 * 4];
      v5 = byte_100CE408[v2 * 4];
      v6 = sub_100242C0(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100CE40C[v2]],
             (&off_100CE410)[v2 * 4]);
      v7 = sub_10027DA0(1, dword_100CE40C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100CE40C[v2]],
             (&off_100CE410)[v2 * 4]);
      result = sub_10024620(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100CE40C: using guessed type int dword_100CE40C[];
// 100CE410: using guessed type char *off_100CE410;
// 10202015: using guessed type char byte_10202015;

//----- (1003CBA0) --------------------------------------------------------
char sub_1003CBA0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10202015 )
  {
    sub_10030970(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_100241B0(0);
    sub_10030970(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_10030970(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_100242A0(0);
    v2 = 0;
    do
    {
      sub_100241D0((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_100CE620[v2];
      v4 = dword_100CE61C[v2];
      v5 = dword_100CE618[v2];
      v6 = sub_100242C0(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100B8640[4 * dword_100CE624[v2]],
             *(_DWORD *)&off_100CE628[v2 * 4]);
      v7 = sub_10028190(1, dword_100CE624[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_100242C0(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100B8640[4 * dword_100CE624[v2]],
             *(_DWORD *)&off_100CE628[v2 * 4]);
      result = sub_10024620(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10030970(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100CE618: using guessed type int dword_100CE618[];
// 100CE61C: using guessed type int dword_100CE61C[];
// 100CE620: using guessed type int dword_100CE620[];
// 100CE624: using guessed type int dword_100CE624[];
// 10202015: using guessed type char byte_10202015;

//----- (1003CD00) --------------------------------------------------------
char **sub_1003CD00()
{
  return off_100B9D2C;
}
// 100B9D2C: using guessed type char *off_100B9D2C[3];

//----- (1003CD10) --------------------------------------------------------
int __cdecl sub_1003CD10(_BYTE *a1)
{
  return sub_1003D270(a1, 0, 0x2710u, 5000, 0);
}

//----- (1003CD30) --------------------------------------------------------
int __cdecl sub_1003CD30(unsigned __int8 *a1)
{
  return sub_1003D220(a1, 0, 5u, 5u, 0);
}

//----- (1003CD50) --------------------------------------------------------
int __cdecl sub_1003CD50(unsigned __int8 *a1)
{
  return sub_1003D220(a1, 0, 6u, 0, 0);
}

//----- (1003CD70) --------------------------------------------------------
int __cdecl sub_1003CD70(unsigned __int8 *a1)
{
  return sub_1003D220(a1, 0, 0xEu, 1u, 0);
}

//----- (1003CD90) --------------------------------------------------------
int __cdecl sub_1003CD90(unsigned __int8 *a1)
{
  return sub_1003D220(a1, 0, 1u, 0, 0);
}

//----- (1003CDC0) --------------------------------------------------------
int __cdecl sub_1003CDC0(int a1)
{
  int result; // eax@1

  result = sub_1003CD30((unsigned __int8 *)a1);
  if ( !result )
  {
    result = sub_1003CDB0(a1 + 12);
    if ( !result )
    {
      result = sub_1003CD90((unsigned __int8 *)(a1 + 1));
      if ( !result )
        result = sub_1003CD70((unsigned __int8 *)(a1 + 2));
    }
  }
  return result;
}
// 1003CDB0: using guessed type _DWORD __cdecl sub_1003CDB0(_DWORD);

//----- (1003CE00) --------------------------------------------------------
int __cdecl sub_1003CE00(int a1)
{
  int result; // eax@1

  result = sub_10023670((void *)(a1 + 28));
  if ( !result )
    result = sub_1003CDC0(a1);
  return result;
}

//----- (1003CE20) --------------------------------------------------------
signed int __cdecl sub_1003CE20(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (1003CE70) --------------------------------------------------------
int __cdecl sub_1003CE70(int a1, double a2, double a3, int a4, int a5, int a6)
{
  int result; // eax@1
  int v7; // edx@20
  unsigned __int64 v8; // rax@21
  int v9; // esi@21
  double v10; // [sp+4h] [bp-8h]@2

  result = -4;
  if ( a1 & 3 || (unsigned int)&v10 & 3 )
  {
    LOBYTE(v10) = *(_BYTE *)a1;
    BYTE1(v10) = *(_BYTE *)(a1 + 1);
    BYTE2(v10) = *(_BYTE *)(a1 + 2);
    BYTE3(v10) = *(_BYTE *)(a1 + 3);
    BYTE4(v10) = *(_BYTE *)(a1 + 4);
    BYTE5(v10) = *(_BYTE *)(a1 + 5);
    BYTE6(v10) = *(_BYTE *)(a1 + 6);
    BYTE7(v10) = *(_BYTE *)(a1 + 7);
  }
  else
  {
    v10 = *(double *)a1;
  }
  if ( a6 && a6 != 1
    || ((HIDWORD(v10) & 0x7FF00000) != 2146435072 ? (a2 <= v10 ? (v10 <= a3 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a6 != 1) )
  {
    if ( a6 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || a1 & 3 )
  {
    LODWORD(v8) = a4;
    v9 = a5;
    *(_BYTE *)(a1 + 1) = BYTE1(a4);
    *(_BYTE *)(a1 + 2) = __PAIR__((unsigned int)v9, (unsigned int)v8) >> 16;
    HIDWORD(v8) = a5;
    *(_BYTE *)a1 = v8;
    *(_BYTE *)(a1 + 3) = v8 >> 24;
    LOBYTE(v8) = BYTE2(a5);
    *(_BYTE *)(a1 + 4) = BYTE4(v8);
    BYTE4(v8) = BYTE3(a5);
    *(_BYTE *)(a1 + 6) = v8;
    *(_BYTE *)(a1 + 5) = BYTE5(v8);
    *(_BYTE *)(a1 + 7) = BYTE4(v8);
    result = 1;
  }
  else
  {
    v7 = a5;
    *(_DWORD *)a1 = a4;
    result = 1;
    *(_DWORD *)(a1 + 4) = v7;
  }
  return result;
}

//----- (1003CFC0) --------------------------------------------------------
int __cdecl sub_1003CFC0(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (1003D0B0) --------------------------------------------------------
unsigned int __cdecl sub_1003D0B0(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (1003D100) --------------------------------------------------------
unsigned int __cdecl sub_1003D100(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (1003D1C0) --------------------------------------------------------
unsigned int __cdecl sub_1003D1C0(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_10020700(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (1003D220) --------------------------------------------------------
int __cdecl sub_1003D220(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (1003D270) --------------------------------------------------------
int __cdecl sub_1003D270(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (1003D310) --------------------------------------------------------
int __cdecl sub_1003D310(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (1003D3C0) --------------------------------------------------------
char __cdecl sub_1003D3C0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_1001B780("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (1003D440) --------------------------------------------------------
char __cdecl sub_1003D440(unsigned __int16 a1, _WORD *a2)
{
  unsigned int v2; // ebx@2
  _WORD *v3; // edi@2
  char result; // al@2
  signed __int16 v5; // cx@2
  __int16 v6; // si@2
  __int16 v7; // dx@3

  if ( sub_100216A0(&a1) )
  {
    result = 0;
  }
  else
  {
    v2 = a1;
    v3 = a2;
    result = 1;
    *a2 = 0;
    v5 = 1;
    v6 = 0;
    do
    {
      v7 = v5 * (v2 & 7);
      v5 *= 10;
      v2 >>= 3;
      v6 += v7;
    }
    while ( (unsigned __int16)v5 <= 0x3E8u );
    *v3 = v6;
  }
  return result;
}

//----- (1003D4A0) --------------------------------------------------------
char __cdecl sub_1003D4A0(char a1, __int16 a2, unsigned __int16 *a3)
{
  char result; // al@1
  int v4; // ecx@3
  unsigned __int16 v5; // si@5

  result = 0;
  if ( a3 )
  {
    *a3 = 0;
    while ( 1 )
    {
      v4 = 2 * *a3;
      if ( word_100D3552[v4] == a2 && byte_100D3550[v4 * 2] == a1 )
        break;
      v5 = *a3 + 1;
      *a3 = v5;
      if ( v5 >= 0x1D8u )
        return result;
    }
    result = 1;
  }
  return result;
}
// 100D3552: using guessed type __int16 word_100D3552[];

//----- (1003D500) --------------------------------------------------------
char __cdecl sub_1003D500(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_10019FB0(13, (char *)&v3 + 3);
  sub_10019FB0(12, a1);
  return BYTE3(v3);
}

//----- (1003D530) --------------------------------------------------------
bool __thiscall sub_1003D530(void *this)
{
  void *v1; // ecx@1
  void *v2; // ecx@3

  return sub_1001A0B0(this) == 2 && sub_1001B4A0(v1) == 4 && (sub_10019F80() || sub_1001A030(v2) == 2);
}

//----- (1003D560) --------------------------------------------------------
char __thiscall sub_1003D560(void *this)
{
  void *v1; // ecx@1
  void *v2; // ecx@2
  char result; // al@3

  if ( sub_1001A0B0(this) == 2 )
  {
    if ( sub_1001B4A0(v1) == 4 )
      result = sub_1001A030(v2) == 2;
    else
      result = sub_10019F80();
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003D590) --------------------------------------------------------
char __cdecl sub_1003D590(const void *a1)
{
  __int16 v2; // [sp+8h] [bp-52Ch]@1
  char v3; // [sp+Ch] [bp-528h]@1

  memset(&v2, 0, 0x528u);
  v2 = -32724;
  qmemcpy(&v3, a1, 0x2Cu);
  return sub_10023AC0((int)&v2);
}

//----- (1003D600) --------------------------------------------------------
char __cdecl sub_1003D600(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_1001B780("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (1003D640) --------------------------------------------------------
char __cdecl sub_1003D640(char a1)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 26;
    }
    else if ( a1 == 2 )
    {
      result = 43;
    }
    else
    {
      sub_1001B780("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 259, 0, 0);
      result = 67;
    }
  }
  else
  {
    result = 25;
  }
  return result;
}

//----- (1003D680) --------------------------------------------------------
signed int __cdecl sub_1003D680(char a1)
{
  signed int result; // eax@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 0x2000;
    }
    else if ( a1 == 2 )
    {
      result = 0x80000;
    }
    else
    {
      sub_1001B780("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 317, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = 4096;
  }
  return result;
}

//----- (1003D6D0) --------------------------------------------------------
bool __cdecl sub_1003D6D0(__int16 a1, __int16 a2, char a3, char *a4)
{
  int v4; // esi@1
  bool v5; // zf@1
  unsigned __int8 v7; // al@6
  char v8; // cl@7
  char *v9; // [sp-8h] [bp-10h]@17
  char v10; // [sp+7h] [bp-1h]@6

  v4 = sub_1001DC80(&a1, 2u, (int)&unk_100E89A0, 62, 77, 76);
  v5 = v4 == 76;
  if ( v4 == 76 )
    return !v5;
  if ( a3 != 1 )
  {
    if ( a3 == 2 )
    {
      sub_1001FD60(2, &v10);
      v7 = sub_1001DC80(&v10, 1u, (int)&unk_100E897C, 2, 16, 15);
      sub_10020640((int)a4, &aComXfer[62 * v4] + 15 * (unsigned __int8)byte_100E897D[2 * v7], 15);
      return v4 != 76;
    }
    if ( a3 != 4 )
    {
      sub_10020640((int)a4, &aComXfer[62 * v4], 15);
      return v4 != 76;
    }
  }
  sub_1001FD60(0, &v10);
  v8 = byte_100E897D[2 * (unsigned __int8)sub_1001DC80(&v10, 1u, (int)&unk_100E897C, 2, 16, 15)];
  if ( a1 != 0x2000 )
    goto LABEL_19;
  if ( (unsigned __int16)a2 >= 0x41u && (unsigned __int16)a2 <= 0x5Au
    || (unsigned __int16)a2 >= 0x30u && (unsigned __int16)a2 <= 0x39u
    || a2 == 43
    || a2 == 45 )
  {
LABEL_16:
    if ( a2 != 32 )
    {
      sub_10020770(a4, 0xFu, "'%c'", (unsigned __int16)a2);
      return v4 != 76;
    }
    goto LABEL_17;
  }
  if ( a2 != 32 )
  {
    if ( a2 == 46 )
      goto LABEL_16;
LABEL_19:
    v9 = &aComXfer[62 * v4] + 15 * (unsigned __int8)v8;
    goto LABEL_20;
  }
LABEL_17:
  v9 = "SPC";
LABEL_20:
  sub_10020640((int)a4, v9, 15);
  v5 = v4 == 76;
  return !v5;
}

//----- (1003D870) --------------------------------------------------------
char sub_1003D870()
{
  return *((_BYTE *)dword_1022D6E8 + 33316);
}

//----- (1003D880) --------------------------------------------------------
int __cdecl sub_1003D880(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= LOWORD((&off_100EB904)[2 * *(_BYTE *)a1 + 2]) );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - LOBYTE((&off_100EB904)[2 * *(_BYTE *)a1 + 2]);
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}
// 100EB904: using guessed type char *;

//----- (1003D970) --------------------------------------------------------
__int16 __cdecl sub_1003D970(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (1003D9C0) --------------------------------------------------------
__int16 __cdecl sub_1003D9C0(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_1003D970((int)&v5, *a1);
  sub_1003D880((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (1003DA40) --------------------------------------------------------
char *__cdecl sub_1003DA40(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = &byte_100647C9;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (1003DA90) --------------------------------------------------------
int sub_1003DA90()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_1004E440();
  result = 0;
  while ( 1 )
  {
    v3 = dword_1020203C[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_1020203C[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 1020203C: using guessed type int dword_1020203C[];

//----- (1003DAD0) --------------------------------------------------------
int __cdecl sub_1003DAD0(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1003DB40) --------------------------------------------------------
signed int __cdecl sub_1003DB40(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1003DBE0) --------------------------------------------------------
int __usercall sub_1003DBE0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_1003DB40(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003DC10) --------------------------------------------------------
signed int __usercall sub_1003DC10@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_1003DB40((_BYTE *)a3, (int)(&off_100EBE38)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_100EBE3C[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_10052ABC(a3, (int)"%ld", (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_10052ABC(a3, (int)"%lu", (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_10052ABC(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 100EBE38: using guessed type char *off_100EBE38;

//----- (1003DDE0) --------------------------------------------------------
char *__usercall sub_1003DDE0@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, " ", 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (1003DE40) --------------------------------------------------------
int __usercall sub_1003DE40@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_1003DB40((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003DED0) --------------------------------------------------------
int __usercall sub_1003DED0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_1003DBE0(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (1003DF20) --------------------------------------------------------
char **__usercall sub_1003DF20@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_1003DA40(v6);
      if ( !sub_1003DB40((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (1003DF80) --------------------------------------------------------
const char *__usercall sub_1003DF80@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (1003DFA0) --------------------------------------------------------
int __usercall sub_1003DFA0@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_10202028[sub_1003DA90()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10202028: using guessed type int dword_10202028[];

//----- (1003DFE0) --------------------------------------------------------
int __usercall sub_1003DFE0@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_1003DC10(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (1003E070) --------------------------------------------------------
int __usercall sub_1003E070@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (1003E1C0) --------------------------------------------------------
int __usercall sub_1003E1C0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_100308F0(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_1003EAA0(v3, v6, 0);
        v7 = -*v3;
        sub_100308F0(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_100308F0(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_100EBAF0);
      sub_1004D730(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_100EBAF0);
      sub_100308F0(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (1003E260) --------------------------------------------------------
int __usercall sub_1003E260@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (1003E2A0) --------------------------------------------------------
char *__cdecl sub_1003E2A0(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_1003DDE0(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_1003DDE0(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_1003DDE0(result, v5, (int)&v20);
      v10 = &byte_100647C9;
    }
    LOBYTE(v9) = 0;
    sub_1003DDE0(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_1003DDE0(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_1003DDE0(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_1003DDE0(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_10030880(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 1003E2A0: using guessed type int var_61C[6];

//----- (1003E450) --------------------------------------------------------
int __usercall sub_1003E450@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_1003DA40((char **)a1);
  result = sub_10030910(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_100EBAF0);
  return result;
}

//----- (1003E480) --------------------------------------------------------
int __usercall sub_1003E480@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_100EBAF0);
  v2 = (unsigned int)sub_1003DA40((char **)a1);
  return sub_100308F0(10, v2);
}

//----- (1003E4B0) --------------------------------------------------------
void __cdecl sub_1003E4B0(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_1003DA40(v5);
            v7 = sub_1003DA40((char **)v3);
            if ( !sub_1003DAD0(v7, (int)v6) )
            {
              v8 = sub_1003DA40((char **)v3);
              sub_100309B0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_1003DA40((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_1003DA40((char **)v3);
        sub_100309B0(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_1003DF80(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_100242C0("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_1003DA40((char **)v3);
            sub_100309F0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_1003DAD0(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_1003DF80(v18);
                  v25 = sub_100242C0("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_1003DA40((char **)v3);
                  sub_100309F0(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_1003DA40((char **)v3);
                  sub_100309F0(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_1003DA40((char **)v3);
              sub_100309F0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_1003DA40((char **)v3);
              sub_100309F0(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_1003DA40((char **)v3);
              sub_100309F0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_1003E4B0(*(_DWORD *)(v3 + 8) + v11 + 8, v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_1003DA40((char **)v3);
            sub_100309F0(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_1003DA40((char **)v3);
            sub_100309F0(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_1003DA40((char **)v3);
          sub_100309F0(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_1003DA40((char **)v3);
        sub_100309F0(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_1003DA40(a2);
      sub_100309B0(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (1003E920) --------------------------------------------------------
int sub_1003E920()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_10202028[sub_1003DA90()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_1003E4B0(i, 0, &v2);
  }
  return v2;
}
// 10202028: using guessed type int dword_10202028[];

//----- (1003E970) --------------------------------------------------------
void *sub_1003E970()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_10202028[0] = 0;
  dword_1020202C = 0;
  dword_10202030 = 0;
  dword_10202034 = 0;
  dword_10202038 = 0;
  result = &unk_10202050;
  dword_1020203C[0] = -1;
  dword_10202040 = -1;
  dword_10202044 = -1;
  dword_10202048 = -1;
  dword_1020204C = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_1003E260((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 10202028: using guessed type int dword_10202028[];
// 1020202C: using guessed type int dword_1020202C;
// 10202030: using guessed type int dword_10202030;
// 10202034: using guessed type int dword_10202034;
// 10202038: using guessed type int dword_10202038;
// 1020203C: using guessed type int dword_1020203C[];
// 10202040: using guessed type int dword_10202040;
// 10202044: using guessed type int dword_10202044;
// 10202048: using guessed type int dword_10202048;
// 1020204C: using guessed type int dword_1020204C;

//----- (1003E9D0) --------------------------------------------------------
char *sub_1003E9D0()
{
  return (char *)&unk_10202050 + 56 * sub_1003DA90();
}

//----- (1003E9F0) --------------------------------------------------------
char sub_1003E9F0()
{
  return sub_1003E9D0()[33];
}

//----- (1003EA00) --------------------------------------------------------
char __cdecl sub_1003EA00(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_1003E9D0();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_10030470(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (1003EA40) --------------------------------------------------------
int *__usercall sub_1003EA40@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_1003E9D0() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_1003DB40((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (1003EA90) --------------------------------------------------------
char **sub_1003EA90()
{
  return &off_100EBEA0;
}
// 100EBEA0: using guessed type char *off_100EBEA0;

//----- (1003EAA0) --------------------------------------------------------
int __cdecl sub_1003EAA0(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_10028530();
  v3 = sub_1003E9D0();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_1003E920();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_1003E450(a2);
    if ( a3 )
    {
      v7 = sub_1003E1C0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_1003E1C0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_1003E480(a2);
        return v7;
      }
    }
    sub_1003E480(a2);
    result = v7;
  }
  return result;
}

//----- (1003EB50) --------------------------------------------------------
int __cdecl sub_1003EB50(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_1003DDE0(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_1003DDE0(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_1003DDE0(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_10030880(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_1003DDE0(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_1003DDE0(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_1003DDE0(v14, "group-begin", (int)&v29);
          sub_10030880(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_1003DA40(v15);
          sub_1003EB50(v16[2], v16[3], v16[4], v17, a4);
          sub_1003DA40(v16);
          v18 = sub_1003E2A0((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_1003DDE0(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_1003DDE0(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_1003DDE0(v20, "group-end", (int)&v29);
          result = sub_10030880(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_1003DDE0(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_1003DDE0(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_1003DDE0(v21, a4, (int)&v28);
          v23 = &byte_100647C9;
        }
        LOBYTE(v22) = 0;
        v24 = sub_1003DDE0(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_1003DDE0(v24, *(const char **)v5, (int)&v30);
        result = sub_10030880(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 1003EB50: using guessed type int var_414[4];

//----- (1003ED60) --------------------------------------------------------
char *__usercall sub_1003ED60@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_1003DDE0(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_1003DDE0(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_10030880(2, (int)v11, 2);
  if ( a6 )
  {
    sub_1003EB50(a3, (int)a4, a5, a2, 0);
    result = sub_1003E2A0(a3, a4, a5, 0);
  }
  return result;
}
// 1003ED60: using guessed type int var_20C[2];

//----- (1003EE20) --------------------------------------------------------
char *__cdecl sub_1003EE20(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_10202028[sub_1003DA90()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_1003DA40((char **)v2);
    sub_1003ED60("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_1003E9D0() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_1003ED60(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 10202028: using guessed type int dword_10202028[];

//----- (1003EEC0) --------------------------------------------------------
int *__cdecl sub_1003EEC0(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_10202028[sub_1003DA90()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_1003DA40(v2);
      if ( !sub_1003DB40(a1, (int)v4) )
      {
        v5 = sub_1003DA40(v3);
        sub_1003ED60("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_1003E9D0();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_1003DB40(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_1003ED60(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 10202028: using guessed type int dword_10202028[];

//----- (1003EF80) --------------------------------------------------------
int __usercall sub_1003EF80@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_1003DFA0(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_1003EAA0((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_1003DFA0(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_1003EAA0((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_1003E450(v5);
        sub_1003E1C0(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_1003E480(v8);
          v10 = sub_1003DFA0(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (1003F0E0) --------------------------------------------------------
signed int __usercall sub_1003F0E0@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_10202028[sub_1003DA90()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_1003EAA0((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 10202028: using guessed type int dword_10202028[];

//----- (1003F150) --------------------------------------------------------
int __cdecl sub_1003F150(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_1003E9D0();
  switch ( a1 )
  {
    case 9:
      sub_100308F0(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_1003DB40((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_1003DB40(v6, (int)"-q") )
            {
              sub_1003EEC0(v6);
              v9 = sub_1003E920();
              sub_100308F0(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_1003EE20(0);
              v8 = sub_1003E920();
              sub_100308F0(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_1003EE20(1);
            v7 = sub_1003E920();
            sub_100308F0(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_10030970(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_100308F0(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_1003EE20(0);
        v4 = sub_1003E920();
        sub_100308F0(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_100308F0(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_10202028[sub_1003DA90()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_1003F150 )
              v12(2, (int)&unk_100EBAF0);
          }
        }
      }
      sub_10028530();
      v3[34] = 0;
      return 0;
    case 3:
      sub_100308F0(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_10202028[sub_1003DA90()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_10030970(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_1003EF80((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_10030970(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_1003F0E0((int)v3);
    case 14:
      exit_0(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_10030970(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_1003F150 )
          v15(3, (int)&unk_100EBAF0);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 1003F150: using guessed type int __cdecl sub_1003F150(int, int);
// 10202028: using guessed type int dword_10202028[];

//----- (1003F430) --------------------------------------------------------
char **sub_1003F430()
{
  return off_100EBC94;
}
// 100EBC94: using guessed type char *off_100EBC94[3];

//----- (1003F440) --------------------------------------------------------
int __usercall sub_1003F440@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_1003DED0(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_1003DFE0(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_1003F430();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (1003F530) --------------------------------------------------------
int __cdecl sub_1003F530(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_1003E9D0();
  *a1 = 0;
  v4 = sub_100242C0("Processing command '%s'", v2);
  sub_10030970(3, (int)&unk_100B5AD8, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_1003E070(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_1003EF80((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_1003F0E0((int)v3);
    v11 = 0;
    v6 = sub_1003DA90();
    v7 = sub_1003DF20((int (**)(void))dword_10202028[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_1003DE40((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_1003DE40((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_1003EAA0(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_1003EAA0(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_1003F440(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_1003EA40(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_1003F440(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_1003F430();
        result = sub_1003F440(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 10202028: using guessed type int dword_10202028[];
// 1003F530: using guessed type char var_2D4[720];

//----- (1003F770) --------------------------------------------------------
int sub_1003F770()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_1003F530(&v4);
  if ( !sub_1003E9D0()[32] )
    sub_100308F0(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_100242C0("%s %i, %s", "Command status:", v0, &v4);
    sub_10030970(3, (int)&unk_100B5AD8, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_100242C0("%s %i", "Command status:", v0);
    sub_10030970(3, (int)&unk_100B5AD8, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (1003F850) --------------------------------------------------------
int __cdecl sub_1003F850(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_10202028[sub_1003DA90()] = a1;
  sub_1003E9D0()[32] = a3;
  sub_10028530();
  sub_10041E30(a2);
  v3 = sub_1003EA90();
  sub_10030360(v3);
  return sub_1003F770();
}
// 10202028: using guessed type int dword_10202028[];

//----- (1003F8A0) --------------------------------------------------------
int __cdecl sub_1003F8A0(int a1)
{
  return a1 + 9;
}

//----- (1003F8B0) --------------------------------------------------------
int __cdecl sub_1003F8B0(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_1004E440();
  memset(a1, 0, 0xDCu);
  sub_10020770((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_1003F8A0(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_1004D740((int)a1, (int)v3);
}

//----- (1003F930) --------------------------------------------------------
int __cdecl sub_1003F930(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_1004D950(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (1003F960) --------------------------------------------------------
signed int __cdecl sub_1003F960(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_10050320(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_1004E4B0();
    }
    else if ( v6 != -57 || (unsigned int)(sub_1004E4B0() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_1004D740(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (1003F980) --------------------------------------------------------
const char *__cdecl sub_1003F980(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (1003F9C0) --------------------------------------------------------
char __cdecl sub_1003F9C0(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  char *v7; // eax@11
  int v8; // ecx@12
  int v9; // ST44_4@13
  bool v10; // zf@18
  signed int v11; // edx@24
  const char *v12; // eax@32
  _BYTE *v13; // eax@39
  int v14; // eax@44
  bool v15; // sf@44
  char v16; // cl@45
  char *v17; // eax@50
  int v18; // edx@52
  int v19; // edi@53
  unsigned int v20; // eax@53
  const char *v21; // ecx@53
  _DWORD *v22; // edx@53
  int v23; // esi@57
  int v24; // eax@58
  _BYTE *v25; // ecx@58
  _BYTE *v26; // edx@58
  int v27; // eax@60
  _BYTE *v28; // ecx@60
  _BYTE *v29; // edx@60
  _BYTE *v30; // ecx@62
  _BYTE *v31; // edx@62
  signed int v32; // eax@64
  signed int v33; // edi@73
  int v34; // esi@74
  int v35; // ecx@76
  int v36; // edx@82
  int v37; // eax@83
  int *v38; // eax@106
  char *v39; // ebx@106
  char *v40; // edi@109
  char *v41; // esi@112
  char *v42; // eax@114
  int v43; // ST30_4@123
  const char *v44; // eax@142
  const char *v45; // eax@148
  char *v47; // [sp-14h] [bp-340h]@69
  char v48; // [sp+12h] [bp-31Ah]@24
  char v49; // [sp+13h] [bp-319h]@21
  signed int v50; // [sp+18h] [bp-314h]@52
  char *v51; // [sp+18h] [bp-314h]@94
  char *v52; // [sp+1Ch] [bp-310h]@97
  char *v53; // [sp+20h] [bp-30Ch]@103
  char *v54; // [sp+24h] [bp-308h]@45
  char v55[508]; // [sp+28h] [bp-304h]@11
  char v56; // [sp+224h] [bp-108h]@44
  char v57; // [sp+227h] [bp-105h]@11
  char v58; // [sp+228h] [bp-104h]@123
  char v59; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v4 = sub_1003DA90();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_10202170 + 580 * v4;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v5) = sub_100310E0((int)v6, 0);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_10031090((int)v6, "Resetting test status\r\n");
      return v5;
    case 1:
      LOBYTE(v5) = sub_10030C00((int)v6);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_10031090((int)v6, "Clearing test status\r\n");
      return v5;
    case 11:
      LOBYTE(v5) = sub_100310E0((int)v6, 0);
      return v5;
    case 4:
      sub_10030A80((int)v6, *a2);
      if ( v6[577] && !v6[578] )
      {
        v7 = sub_10030DB0((char *)a2[1]);
        _snprintf(v55, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v7);
        v57 = 0;
        sub_10031090((int)v6, v55);
      }
      LOBYTE(v5) = 0;
      v8 = (int)&v6[16 * *(_DWORD *)v6 + 4];
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      return v5;
    case 5:
      v9 = *a2;
      LOBYTE(v5) = sub_10030A70((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 6:
      LOBYTE(v5) = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8] = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4] = 0;
      v10 = v6[577] == 0;
      *((_DWORD *)v6 + 143) = 0;
      if ( !v10 && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_10031090((int)v6, v55);
      }
      return v5;
    case 7:
      v49 = sub_10030470((int)a2, a3);
      if ( !v49 && !v6[577] )
        goto LABEL_83;
      if ( v6[578] )
        goto LABEL_81;
      v11 = 0;
      v48 = 0;
      if ( a3 > 7 )
        v11 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v11 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v11 += strlen((const char *)a2[3]);
      if ( v11 > 100 )
        v48 = 1;
      v12 = sub_1003F980((int)v6, (unsigned __int8)v49);
      _snprintf(v55, 0x200u, "%s ", v12);
      v57 = 0;
      sub_10031090((int)v6, v55);
      if ( a3 > 7 )
      {
        _snprintf(v55, 0x200u, " ACT: %-17s", a2[7]);
        v57 = 0;
        sub_10031090((int)v6, v55);
        if ( v48 )
          sub_10031090((int)v6, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v55, 0x200u, " EXP: %-17s", a2[8]);
        v57 = 0;
        sub_10031090((int)v6, v55);
        if ( v48 )
          sub_10031090((int)v6, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v13 = (_BYTE *)a2[9];
        if ( v13 )
        {
          if ( *v13 )
          {
            if ( memcmp((const void *)a2[9], "0", 2u) )
            {
              _snprintf(v55, 0x200u, " TOL: %-17s", a2[9]);
              v57 = 0;
              sub_10031090((int)v6, v55);
              if ( v48 )
                sub_10031090((int)v6, "\r\n     ");
            }
          }
        }
      }
      v14 = _snprintf(v55, 0x1FCu, " %s", a2[3]);
      v15 = v14 < 0;
      v56 = 0;
      if ( v14 > 0 )
      {
        do
        {
          v16 = (char)(&v54)[v14 + 3];
          if ( v16 != 10 && v16 != 13 )
            break;
          LOBYTE((&v54)[4 * --v14 + 13]) = 0;
        }
        while ( v14 > 0 );
        v15 = v14 < 0;
      }
      if ( !v15 )
      {
        v17 = &v55[v14];
        *(_WORD *)v17 = 2573;
        v17[2] = 0;
      }
      sub_10031090((int)v6, v55);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v18 = 10;
      v50 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v19 = v3[v18];
        v20 = 6;
        v21 = "Info: ";
        v22 = (_DWORD *)v3[v18];
        do
        {
          if ( *v22 != *(_DWORD *)v21 )
            goto LABEL_57;
          v20 -= 4;
          v21 += 4;
          ++v22;
        }
        while ( v20 >= 4 );
        if ( !v20 )
          goto LABEL_67;
LABEL_57:
        v23 = *(_BYTE *)v22 - *v21;
        if ( *(_BYTE *)v22 == *v21 )
        {
          v24 = v20 - 1;
          v25 = v21 + 1;
          v26 = (char *)v22 + 1;
          if ( !v24
            || (v23 = *v26 - *v25, *v26 == *v25)
            && ((v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, !v27)
             || (v23 = *v29 - *v28, *v29 == *v28)
             && ((v30 = v28 + 1, v31 = v29 + 1, v27 == 1) || (v23 = *v31 - *v30, *v31 == *v30))) )
          {
            v3 = a2;
LABEL_67:
            v32 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v32 = 1;
        if ( v23 <= 0 )
          v32 = -1;
LABEL_68:
        if ( v32 )
        {
          _snprintf(v55, 0x200u, "      Post Analysis: %s\r\n", v19);
          v47 = v55;
        }
        else
        {
          _snprintf(v55, 0x200u, "      Compare Info: %s\r\n", v19 + 6);
          v47 = v55;
        }
        v57 = 0;
        sub_10031090((int)v6, v47);
        v18 = v50++ + 1;
      }
      while ( v50 < (signed int)a3 );
LABEL_72:
      if ( v6[309] )
      {
        v33 = 0;
        if ( *((_DWORD *)v6 + 143) > 0 )
        {
          v34 = (int)(v6 + 336);
          do
          {
            if ( v33 >= 20 )
              break;
            v35 = *(_DWORD *)(v34 - 4);
            if ( *(_DWORD *)(v34 + 4) )
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v33, v35, *(_DWORD *)v34, *(_DWORD *)(v34 + 4));
            else
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s\r\n", v33, v35, *(_DWORD *)v34);
            v57 = 0;
            sub_10031090((int)v6, v55);
            ++v33;
            v34 += 12;
          }
          while ( v33 < *((_DWORD *)v6 + 143) );
        }
        _snprintf(v55, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v57 = 0;
        sub_10031090((int)v6, v55);
      }
LABEL_81:
      if ( v49 )
      {
        v36 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v36 + 4];
        v5 = (int)&v6[v36 + 4];
      }
      else
      {
LABEL_83:
        v37 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v37 + 8];
        v5 = (int)&v6[v37 + 8];
      }
      return v5;
    case 9:
      LOBYTE(v5) = sub_10030CE0((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 3:
      LOBYTE(v5) = sub_10030790((const void **)a2, a3);
      if ( !(_BYTE)v5 && !v6[578] )
      {
        if ( v6[577]
          || sub_10030850((const void **)a2, a3)
          || (LOBYTE(v5) = sub_100306A0((const void **)a2, a3), (_BYTE)v5) )
        {
          if ( a3 <= 8 )
            v51 = &byte_100647C9;
          else
            v51 = (char *)a2[8];
          if ( a3 <= 7 )
            v52 = &byte_100647C9;
          else
            v52 = (char *)a2[7];
          if ( a3 <= 6 )
            v54 = &byte_100647C9;
          else
            v54 = (char *)a2[6];
          if ( a3 <= 5 )
            v53 = &byte_100647C9;
          else
            v53 = (char *)a2[5];
          if ( a3 <= 4 )
          {
            v38 = a2;
            v39 = &byte_100647C9;
          }
          else
          {
            v38 = a2;
            v39 = (char *)a2[4];
          }
          if ( a3 <= 3 )
            v40 = &byte_100647C9;
          else
            v40 = (char *)v38[3];
          if ( a3 )
            v41 = (char *)*v38;
          else
            v41 = &byte_100647C9;
          v10 = sub_10030760((const void **)a2, a3) == 0;
          v42 = &byte_100647C9;
          if ( v10 )
            v42 = "   ";
          _snprintf(v55, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v42, v41, v40, v39, v53, v54, v52, v51);
          v57 = 0;
          LOBYTE(v5) = (unsigned int)sub_10031090((int)v6, v55);
        }
      }
      return v5;
    case 2:
      if ( v6[578] )
        return v5;
      if ( sub_100304A0((const void **)a2, a3) )
      {
        dword_10202168 = 2;
        sub_10031090((int)v6, (const char *)&word_100ED4C4);
        sub_10031090((int)v6, "   Command Format:\r\n");
        sub_10031090(
          (int)v6,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_10031090(
          (int)v6,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_10031090(
          (int)v6,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_10031090(
          (int)v6,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_10031090((int)v6, "                                         strings depending upon the command\r\n");
        sub_10031090((int)v6, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_10031090(
          (int)v6,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_10031090(
          (int)v6,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_10031090((int)v6, (const char *)&word_100ED4C4);
        sub_10031090((int)v6, "   Notes:\r\n");
        sub_10031090((int)v6, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_10031090((int)v6, (const char *)&word_100ED4C4);
        sub_10031090(
          (int)v6,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_10031090(
          (int)v6,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_10031090(
          (int)v6,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_10031090((int)v6, "       the suite name and the test case or test suite command.\r\n");
        sub_10031090((int)v6, (const char *)&word_100ED4C4);
        sub_10031090(
          (int)v6,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_10031090(
          (int)v6,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_10031090((int)v6, "       without a test suite name.\r\n");
        sub_10031090((int)v6, (const char *)&word_100ED4C4);
        sub_10031090((int)v6, "   Examples:\r\n");
        sub_10031090(
          (int)v6,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_10031090((int)v6, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_10031090(
          (int)v6,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_10031090(
          (int)v6,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_10031090(
          (int)v6,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_10031090(
          (int)v6,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_10031090(
          (int)v6,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_10031090(
          (int)v6,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_10031090((int)v6, (const char *)&word_100ED4C4);
        sub_10031090((int)v6, "   Command                                 Description\r\n");
        LOBYTE(v5) = (unsigned int)sub_10031090(
                                     (int)v6,
                                     "   --------------------------------        --------------------------------\r\n");
        return v5;
      }
      if ( sub_10030530((const void **)a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_10031090((int)v6, (const char *)&word_100ED4C4);
        return v5;
      }
      if ( sub_10030500((const void **)a2, a3) )
      {
        _snprintf(&v58, 0x100u, "%s %s", a2[3], a2[4]);
        v43 = a2[5];
        v59 = 0;
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_10202168,
          &byte_100647C9,
          &v58,
          6 - dword_10202168,
          " ",
          v43);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_10031090((int)v6, v55);
        return v5;
      }
      if ( sub_10030560((const void **)a2, a3) )
      {
        LOBYTE(v5) = sub_10030590((int)a2, a3);
        if ( (_BYTE)v5 )
        {
          dword_10202168 += 2;
          return v5;
        }
        if ( sub_100305D0((int)a2, a3) )
        {
          LOBYTE(v5) = 2;
          if ( dword_10202168 < 2 )
            dword_10202168 = 0;
          else
            dword_10202168 -= 2;
          return v5;
        }
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_10202168,
          &byte_100647C9,
          a2[2],
          6 - dword_10202168,
          " ",
          a2[2]);
LABEL_134:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_10031090((int)v6, v55);
        return v5;
      }
      if ( sub_100304D0((const void **)a2, a3) )
      {
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_10202168,
          &byte_100647C9,
          a2[3],
          6 - dword_10202168,
          " ",
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_10030640((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_10031090((int)v6, v55);
      }
      else if ( sub_10030610((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_10031090((int)v6, v55);
      }
      else
      {
        LOBYTE(v5) = (unsigned int)sub_10031090((int)v6, "Unknown test help event\r\n");
      }
      return v5;
    case 8:
      if ( v6[577] && !v6[578] )
      {
        v44 = sub_1003F980((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        _snprintf(v55, 0x200u, "\r\n   Test Case Results: %s\r\n", v44);
        v57 = 0;
        sub_10031090((int)v6, v55);
        _snprintf(v55, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8]);
        v57 = 0;
        sub_10031090((int)v6, v55);
        _snprintf(v55, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        v57 = 0;
        sub_10031090((int)v6, v55);
      }
      v5 = (int)&v6[16 * *(_DWORD *)v6];
      if ( *(_DWORD *)(v5 + 4) )
        ++*(_DWORD *)(v5 + 12);
      else
        ++*(_DWORD *)(v5 + 16);
      return v5;
    case 10:
      if ( v6[577] && !v6[578] )
      {
        v45 = sub_1003F980((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        _snprintf(v55, 0x200u, "\r\nTest Suite Results: %s\r\n", v45);
        v57 = 0;
        sub_10031090((int)v6, v55);
        _snprintf(v55, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v6[16 * (*(_DWORD *)v6 + 1)]);
        v57 = 0;
        sub_10031090((int)v6, v55);
        _snprintf(v55, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        v57 = 0;
        sub_10031090((int)v6, v55);
      }
      LOBYTE(v5) = sub_10030D40((int)v6, 0);
      return v5;
    case 12:
      LOBYTE(v5) = sub_10031010((int)v6, 0);
      return v5;
    case 13:
      if ( a3 >= 2 )
      {
        v5 = *((_DWORD *)v6 + 143);
        if ( v5 < 20 )
        {
          *(_DWORD *)&v6[12 * v5 + 332] = *a2;
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143) + 28)] = a2[1];
          v5 = 3 * *((_DWORD *)v6 + 143);
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143))++ + 340] = a2[2];
        }
      }
      return v5;
    case 14:
      --*((_DWORD *)v6 + 143);
      return v5;
    default:
      if ( !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_10031090((int)v6, "Unknown test event\r\n");
      return v5;
  }
}
// 100ED4C4: using guessed type __int16 word_100ED4C4;
// 10202168: using guessed type int dword_10202168;
// 1003F9C0: using guessed type char var_304[508];

//----- (10040770) --------------------------------------------------------
signed int __cdecl sub_10040770(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_10202170 + 580 * sub_1003DA90();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_10030C40(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (100407F0) --------------------------------------------------------
char **__cdecl sub_100407F0(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_10202170 + 580 * sub_1003DA90();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_10030E50((int)v1, a1, (int)".txt");
  return &off_100EC890;
}
// 100EC890: using guessed type char *off_100EC890;

//----- (10040830) --------------------------------------------------------
int (__cdecl *__cdecl sub_10040830(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_1003DA90();
  return sub_10031090((int)&unk_10202CC8 + 1812 * v1, a1);
}

//----- (10040850) --------------------------------------------------------
const char *sub_10040850()
{
  return "See version control for test execution date";
}

//----- (10040860) --------------------------------------------------------
__int64 sub_10040860()
{
  return 0i64;
}

//----- (10040870) --------------------------------------------------------
const char *sub_10040870()
{
  return "Not Available";
}

//----- (10040880) --------------------------------------------------------
int __usercall sub_10040880@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (100408D0) --------------------------------------------------------
signed int __cdecl sub_100408D0(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1003DA90();
  return sub_10030C40(a1, a2, (int)&unk_10202CC8 + 1812 * v2);
}

//----- (10040A20) --------------------------------------------------------
int __usercall sub_10040A20@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  int v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_1004DA30((int)&a2[151 * (*a2 + 1)], (int)sub_10040830, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_10040860();
  v4 = sub_10041C70("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_1004DE80((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_10041C70("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_1004DE80((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_1004DE80((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_1004DE00((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_1004DC90((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_10041C70("CFG_OutputTestRevision", (int)"False");
  if ( !sub_1003DB40(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_1004DED0((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_1004DED0((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_1004DE00((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_1004DE00((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_1004DED0((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_10030DB0(v3);
  sub_1004DED0((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_1004DD80((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_10041C30(i, &v15, &v16); ++i )
  {
    sub_1004DE00((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_1004DED0((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_1004DED0((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_1004DD80((int)&a2[151 * (*a2 + 1)]);
  }
  sub_1004DD80((int)&a2[151 * (*a2 + 1)]);
  sub_1004DE00((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_1004DC90((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = (int)&a2[4 * *a2 + 1];
  *(_DWORD *)v14 = 0;
  *(_DWORD *)(v14 + 4) = 0;
  *(_DWORD *)(v14 + 8) = 0;
  *(_DWORD *)(v14 + 12) = 0;
  return result;
}
// 10040A20: using guessed type char var_103[253];

//----- (10040DA0) --------------------------------------------------------
char __cdecl sub_10040DA0(int a1, const void **a2, unsigned int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  char *v5; // ebp@1
  const char *v6; // ebx@3
  int v7; // esi@4
  int v8; // ST14_4@5
  int v9; // eax@12
  const char *v10; // eax@13
  const char *v11; // eax@15
  int v12; // ST14_4@17
  int v13; // ecx@29
  const void *v14; // ST24_4@43
  int v15; // ST04_4@44
  _BYTE *v16; // eax@87
  _BYTE *v17; // eax@94
  _BYTE *v18; // eax@100
  int v19; // ST20_4@104
  unsigned int v20; // esi@105
  _DWORD *v21; // edx@106
  unsigned int v22; // eax@106
  const char *v23; // ecx@106
  int v24; // esi@110
  int v25; // eax@111
  _BYTE *v26; // ecx@111
  _BYTE *v27; // edx@111
  int v28; // eax@113
  _BYTE *v29; // ecx@113
  _BYTE *v30; // edx@113
  _BYTE *v31; // ecx@115
  _BYTE *v32; // edx@115
  bool v33; // zf@117
  bool v34; // sf@117
  signed int v35; // eax@117
  const char *v36; // eax@129
  const char *v37; // eax@131
  const char *v39; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v40; // [sp-Ch] [bp-120h]@73
  char v41; // [sp+9h] [bp-10Bh]@46
  char v42; // [sp+Ah] [bp-10Ah]@46
  char v43; // [sp+Bh] [bp-109h]@46
  char *v44; // [sp+Ch] [bp-108h]@91
  signed int v45; // [sp+Ch] [bp-108h]@105
  char v46[255]; // [sp+10h] [bp-104h]@5
  char v47; // [sp+10Fh] [bp-5h]@44

  v3 = sub_1003DA90();
  LOBYTE(v4) = a1;
  v5 = (char *)&unk_10202CC8 + 1812 * v3;
  switch ( a1 )
  {
    case 3:
      if ( sub_100307F0(a2, a3) )
      {
        v6 = (const char *)a2[3];
        do
        {
          v4 = sub_10040880(", \t", (int)v6);
          v7 = v4;
          if ( v4 )
          {
            strncpy(v46, v6, v4);
            v8 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
            v46[v7] = 0;
            sub_1004DE00(v8, (int)"Req");
            sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"id", (unsigned __int8 *)v46);
            LOBYTE(v4) = (unsigned int)sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
            v6 += v7;
          }
          else
          {
            ++v6;
          }
        }
        while ( *v6 );
      }
      else if ( sub_100307C0(a2, a3) )
      {
        if ( sub_10030F50((int)v5, 3, 1, 0) )
          sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        v9 = *((_DWORD *)v5 + 146);
        if ( v9 > 0 )
        {
          *((_DWORD *)v5 + 146) = v9 - 1;
          sub_1004DE00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
          v10 = "true";
          if ( *((_DWORD *)v5 + 144) <= 0 )
            v10 = "false";
          sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v10);
          v11 = "true";
          if ( *((_DWORD *)v5 + 145) <= 0 )
            v11 = "false";
          sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v11);
          sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          v12 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          *((_DWORD *)v5 + 144) = 0;
          *((_DWORD *)v5 + 145) = 0;
          sub_1004DD80(v12);
          sub_1004DE00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        }
        LOBYTE(v4) = (unsigned int)sub_1004DC90(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10030700(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_1004DED0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 146);
      }
      else if ( sub_10030820(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_1004DED0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10030790(a2, a3) )
      {
        if ( sub_10030F50((int)v5, 3, 1, 0) )
          sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_10030EC0((int)a2, a3, (int)v5);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_1004DE00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      }
      else if ( sub_10030730(a2, a3) )
      {
        sub_1004DE00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Results");
        v13 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_1004DC90(v13, (int)"success", (unsigned __int8 *)"0");
          sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_1004DC90(v13, (int)"success", (unsigned __int8 *)"1");
        }
        if ( v5[309] )
        {
          sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_10030F50((int)v5, 3, 0, 0);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = (unsigned int)sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      else
      {
        LOBYTE(v4) = sub_100306D0(a2, a3);
        if ( (_BYTE)v4 )
        {
          if ( !sub_10031000((int)v5) )
            sub_1004DE00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
          sub_1004DED0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v4) = sub_10030F50((int)v5, 3, 0, 1);
          if ( (_BYTE)v4 )
            LOBYTE(v4) = (unsigned int)sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      return v4;
    case 4:
      LOBYTE(v4) = sub_10030A80((int)v5, (int)*a2);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_10040A20((char *)a2[1], v5, (int)*a2);
      return v4;
    case 5:
      v14 = *a2;
      LOBYTE(v4) = sub_10030A70((int)v5);
      if ( !(_BYTE)v4 )
      {
        sub_1004DE00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        _snprintf(v46, 0x100u, "Test Group: %s", *a2);
        v15 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        v47 = 0;
        sub_1004DED0(v15, (int)"Method", (unsigned __int8 *)v46);
        LOBYTE(v4) = (unsigned int)sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      return v4;
    case 6:
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      LOBYTE(v4) = sub_1004DE00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
      return v4;
    case 7:
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v42 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v43 = 1;
LABEL_55:
        v41 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v5 + 146) )
      {
        sub_1004DED0(
          (int)&v5[604 * (*(_DWORD *)v5 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_1004DED0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v5 + 146);
      }
      if ( !sub_10031000((int)v5) )
        sub_1004DE00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      if ( sub_10030670((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_1004DE00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction");
          sub_1004DD30((int)&v5[604 * (*(_DWORD *)v5 + 1)], (unsigned __int8 *)a2[3]);
          sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
        ++*((_DWORD *)v5 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_1004DED0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 144);
      }
      sub_1004DE00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Compare");
      if ( sub_10030470((int)a2, a3) )
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 4];
        sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 8];
        sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v41 )
      {
        sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v43 )
        {
          sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v40 = (unsigned __int8 *)"true";
        v39 = "strict";
      }
      else
      {
        v40 = (unsigned __int8 *)a2[6];
        v39 = "datatype";
      }
      sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)v39, v40);
LABEL_77:
      if ( v5[309] )
      {
        sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_1004DE00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Actual");
        if ( v42 )
          sub_1004DCE0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v42 )
        {
          sub_1004DE00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Expected");
          sub_1004DCE0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          if ( a3 > 9 )
          {
            v16 = a2[9];
            if ( v16 )
            {
              if ( *v16 )
              {
                sub_1004DE00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Tolerance");
                sub_1004DCE0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v41 )
          {
            v44 = "!";
            if ( memcmp(*a2, "NE", 3u) )
              v44 = &byte_100647C9;
            if ( a3 > 9 && (v17 = a2[9]) != 0 && *v17 && memcmp(a2[9], "0", 2u) )
              _snprintf(v46, 0x100u, "%s%s+/-%s", v44, a2[8], a2[9]);
            else
              _snprintf(v46, 0x100u, "%s%s", v44, a2[8]);
          }
          else if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 )
          {
            _snprintf(v46, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v46, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v19 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          v47 = 0;
          sub_1004DE00(v19, (int)"Expected");
          sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)v46);
          sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      v20 = 10;
      v45 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_10030F50((int)v5, 8, 1, 0) )
        sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      sub_1004DE00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
      v36 = "true";
      if ( *((_DWORD *)v5 + 144) <= 0 )
        v36 = "false";
      sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v36);
      v37 = "true";
      if ( *((_DWORD *)v5 + 145) <= 0 )
        v37 = "false";
      sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v37);
      sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      LOBYTE(v4) = (unsigned int)sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      return v4;
    case 9:
      LOBYTE(v4) = sub_10030CE0((int)v5);
      return v4;
    case 10:
      LOBYTE(v4) = sub_10030D40((int)v5, (void (__cdecl *)(int))sub_10040900);
      return v4;
    case 0:
    case 11:
      sub_100310E0((int)v5, (void (__cdecl *)(int))sub_10040900);
      goto LABEL_139;
    case 1:
      sub_10030C00((int)v5);
      goto LABEL_139;
    case 12:
      sub_10031010((int)v5, (void (__cdecl *)(int))sub_10040900);
LABEL_139:
      LOBYTE(v4) = 0;
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      return v4;
    default:
      return v4;
  }
  do
  {
    v21 = a2[v20];
    v22 = 6;
    v23 = "Info: ";
    do
    {
      if ( *v21 != *(_DWORD *)v23 )
        goto LABEL_110;
      v22 -= 4;
      v23 += 4;
      ++v21;
    }
    while ( v22 >= 4 );
    if ( !v22 )
      goto LABEL_120;
LABEL_110:
    v24 = *(_BYTE *)v21 - *v23;
    if ( *(_BYTE *)v21 == *v23 )
    {
      v25 = v22 - 1;
      v26 = v23 + 1;
      v27 = (char *)v21 + 1;
      if ( !v25
        || (v24 = *v27 - *v26, *v27 == *v26)
        && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
         || (v24 = *v30 - *v29, *v30 == *v29)
         && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
      {
        v20 = v45;
LABEL_120:
        v35 = 0;
        goto LABEL_121;
      }
    }
    v33 = v24 == 0;
    v34 = v24 < 0;
    v20 = v45;
    v35 = 1;
    if ( v34 || v33 )
      v35 = -1;
LABEL_121:
    if ( v35 )
    {
      sub_1004DE00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"PostAnalysis");
      sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"note", (unsigned __int8 *)a2[v20]);
      sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    else
    {
      sub_1004DE00((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"CompareInfo");
      sub_1004DC90((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v20] + 6);
      sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    v45 = ++v20;
  }
  while ( v20 < a3 );
LABEL_125:
  sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  LOBYTE(v4) = sub_10030F50((int)v5, 7, 0, 1);
  if ( (_BYTE)v4 )
    LOBYTE(v4) = (unsigned int)sub_1004DD80((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  return v4;
}
// 10040900: using guessed type int sub_10040900();
// 10040DA0: using guessed type char var_104[255];

//----- (10041BC0) --------------------------------------------------------
char **__cdecl sub_10041BC0(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_10202CC8 + 1812 * sub_1003DA90();
  *((_DWORD *)v1 + 146) = 0;
  sub_10030E50((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_1004DA30(v2, (int)sub_10040830, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_100ED620;
}
// 100ED620: using guessed type char *off_100ED620;

//----- (10041C30) --------------------------------------------------------
char __cdecl sub_10041C30(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_10205038[592 * a1]) || byte_10205088[v3]) )
  {
    *a2 = &byte_10205038[v3];
    *a3 = &byte_10205088[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10041C70) --------------------------------------------------------
char *__cdecl sub_10041C70(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_10205038;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_10205088[592 * v2];
}

//----- (10041CE0) --------------------------------------------------------
char *__usercall sub_10041CE0@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (10041D10) --------------------------------------------------------
void __cdecl sub_10041D10(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_10041C70(v2 + 3, (int)&byte_100647C9);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_10041D10(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (10041DD0) --------------------------------------------------------
void __cdecl sub_10041DD0(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  char *v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  char *v8; // edx@4
  char v9; // cl@5

  if ( dword_10205030 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_10205030;
    v4 = (char *)(&byte_10205038[592 * dword_10205030] - a1);
    do
    {
      v5 = *v2;
      v2[(_DWORD)v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_10205088[v3];
    v8 = (char *)(&byte_10205088[v3] - a2);
    do
    {
      v9 = *v6;
      v6[(_DWORD)v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_10041D10(v7);
    ++dword_10205030;
  }
}
// 10205030: using guessed type int dword_10205030;

//----- (10041E30) --------------------------------------------------------
void *__cdecl sub_10041E30(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  char *v4; // edi@4
  char *v5; // esi@4
  char *v6; // eax@4
  const char *v7; // esi@6
  const char *v8; // ebx@6
  char *v9; // edi@6
  char *v10; // eax@6
  char v11; // [sp+4h] [bp-204h]@3

  result = memset(byte_10205038, 0, 0x73A0u);
  dword_10205030 = 0;
  if ( a1 )
  {
    v2 = sub_100442F0(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_100444D0((int)&v11, 512, v2) )
      {
        do
        {
          sub_10041CE0(&v11);
          v4 = strstr(&v11, word_100A3160);
          v5 = strstr(&v11, "<Var name=\"");
          v6 = strstr(&v11, " value=\"");
          if ( v5 && v6 )
          {
            v7 = v5 + 11;
            v8 = v6 + 8;
            v9 = strchr(v7, 34);
            v10 = strchr(v8, 34);
            if ( v9 )
            {
              if ( v10 )
              {
                *v9 = 0;
                *v10 = 0;
                sub_10041DD0((char *)v7, (char *)v8);
              }
            }
          }
          else if ( v4 && !strpbrk(&v11, "<>") )
          {
            *v4 = 0;
            sub_10041DD0(&v11, v4 + 1);
          }
        }
        while ( sub_100444D0((int)&v11, 512, v3) );
      }
      result = (void *)sub_100442A0(v3);
    }
    else
    {
      result = (void *)sub_100309F0(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 10205030: using guessed type int dword_10205030;

//----- (10041FC0) --------------------------------------------------------
int sub_10041FC0()
{
  return 0;
}

//----- (10041FD0) --------------------------------------------------------
void __cdecl sub_10041FD0(int a1)
{
  if ( a1 > 0 )
    exit_0(14);
}

//----- (10042000) --------------------------------------------------------
int __cdecl sub_10042000(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10042020) --------------------------------------------------------
bool __cdecl sub_10042020(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (10042050) --------------------------------------------------------
void *__cdecl sub_10042050(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (10042090) --------------------------------------------------------
unsigned int __usercall sub_10042090@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (100420B0) --------------------------------------------------------
int __usercall sub_100420B0@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (100420D0) --------------------------------------------------------
char __cdecl sub_100420D0(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_10042020(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_10042000(a2);
  }
  return result;
}

//----- (10042100) --------------------------------------------------------
signed int __cdecl sub_10042100(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  int v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = (int)a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( *(_DWORD *)(v5 + 4) )
      {
        do
        {
          v10 = sub_10042090(v5, v7, v9);
          v11 = (_BYTE *)sub_10042090(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_10042090(a4, v7, v9);
            sub_100420B0(v16, (int)&unk_100EDAEC);
          }
          ++v9;
        }
        while ( v9 < *(_DWORD *)(v5 + 4) );
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (100421E0) --------------------------------------------------------
void __cdecl sub_100421E0(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_10042090((int)v3, v4, v6);
          v8 = sub_10042090(a2, v4, v6);
          v9 = sub_10042090(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (10042290) --------------------------------------------------------
void *__usercall sub_10042290@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  int v34; // [sp+14h] [bp-Ch]@1
  int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_10042090(a1, v31, v4);
      v6 = sub_10042090(a2, 0, 0);
      sub_100420B0(v5, v6);
      v7 = sub_10042090(a1, v33, v4);
      v8 = sub_10042090(a2, *(_DWORD *)a2 - 1, 0);
      sub_100420B0(v7, v8);
      v9 = sub_10042090(a1, v31, v34 - v4 - 1);
      v10 = sub_10042090(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_100420B0(v9, v10);
      v11 = sub_10042090(a1, v33, v34 - v4 - 1);
      v12 = sub_10042090(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_100420B0(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_10042090(a2, 0, 1);
    v16 = (void *)sub_10042090(a1, v13, a3 + 1);
    memcpy(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_10042090(a1, a3 + i, v18);
      v20 = sub_10042090(a2, i, 0);
      sub_100420B0(v19, v20);
      v21 = sub_10042090(a1, i + a3, v34 - v18 - 1);
      v22 = sub_10042090(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_100420B0(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_10042090(a2, i, 1);
    v25 = (void *)sub_10042090(a1, a3 + i, a3 + 1);
    memcpy(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_10042090(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_10042090(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (10042510) --------------------------------------------------------
void __cdecl sub_10042510(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_10042090(a1, v2, v4);
          v6 = sub_10042090(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (100425E0) --------------------------------------------------------
char __cdecl sub_100425E0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_10042020(a1);
  if ( result )
  {
    result = sub_10042020(a4);
    if ( result )
    {
      sub_100420D0(a3, a4);
      sub_10042050(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (10042650) --------------------------------------------------------
int __usercall sub_10042650@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_10042050(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_10042290((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_10042090((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_10042090(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_100420D0((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_100425E0(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (100429B0) --------------------------------------------------------
int __usercall sub_100429B0@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_10042050(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_100421E0(v8, a3, (int)&v16);
  sub_10042050(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_10042650(9u, v7, (int)&v16, (int)&unk_100EDAC8, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_10042090((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_10042090(a6, v9, v11);
            sub_100420B0(v13, (int)&unk_100EDAEC);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_100420D0(a5, (int)&v15);
  sub_100420D0(a5, (int)&v16);
  return v10;
}

//----- (10042AC0) --------------------------------------------------------
int __cdecl sub_10042AC0(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_10042050(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_10042510(a3, a8);
  if ( a1 )
    result = sub_100429B0(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_10042100((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (10042C50) --------------------------------------------------------
char __cdecl sub_10042C50(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  char *v6; // ebp@11
  int v7; // esi@11
  unsigned int v8; // ebx@11
  int v9; // edi@11
  char result; // al@20
  char v11; // [sp+8h] [bp-40h]@14
  unsigned int v12; // [sp+Ch] [bp-3Ch]@5
  __int16 v13; // [sp+10h] [bp-38h]@6
  int v14; // [sp+1Ah] [bp-2Eh]@8
  char v15; // [sp+20h] [bp-28h]@9
  int v16; // [sp+24h] [bp-24h]@11
  unsigned int v17; // [sp+28h] [bp-20h]@11
  unsigned __int16 v18; // [sp+2Eh] [bp-1Ah]@10
  char v19; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_100442F0((int)a2, 0);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        if ( sub_10044350(&v13, 14, v4) == 14
          && v13 == 19778
          && v14 == 54
          && sub_10044350(&v15, 40, v5) == 40
          && v18 == 24 )
        {
          sub_10042050(v17, v16, 24, a1, a3);
          v6 = *(char **)(a3 + 12);
          v7 = v16 * (((unsigned int)v18 + 7) >> 3);
          v8 = 0;
          v9 = -(v16 * (((unsigned int)v18 + 7) >> 3)) & 3;
          v19 = 1;
          if ( v17 )
          {
            while ( sub_10044350(v6, v7, v12) == v7 && (!v9 || sub_10044350(&v11, v9, v12) == v9) )
            {
              ++v8;
              v6 += v7;
              if ( v8 >= v17 )
                goto LABEL_18;
            }
            v19 = 0;
          }
LABEL_18:
          v3 = v19;
          v5 = v12;
        }
        sub_100442A0(v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10042DA0) --------------------------------------------------------
char __usercall sub_10042DA0@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@1
  unsigned int v10; // ebx@1
  int v12; // [sp+10h] [bp-40h]@4
  int v13; // [sp+14h] [bp-3Ch]@4
  __int16 v14; // [sp+18h] [bp-38h]@1
  int v15; // [sp+1Ah] [bp-36h]@1
  __int16 v16; // [sp+1Eh] [bp-32h]@1
  __int16 v17; // [sp+20h] [bp-30h]@1
  int v18; // [sp+22h] [bp-2Eh]@1
  int v19; // [sp+28h] [bp-28h]@1
  int v20; // [sp+2Ch] [bp-24h]@1
  unsigned int v21; // [sp+30h] [bp-20h]@1
  __int16 v22; // [sp+34h] [bp-1Ch]@1
  __int16 v23; // [sp+36h] [bp-1Ah]@1
  int v24; // [sp+38h] [bp-18h]@1
  int v25; // [sp+3Ch] [bp-14h]@1
  int v26; // [sp+40h] [bp-10h]@1
  int v27; // [sp+44h] [bp-Ch]@1
  int v28; // [sp+48h] [bp-8h]@1
  int v29; // [sp+4Ch] [bp-4h]@1
  char v30; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v25 = v8;
  v15 = v8 + 54;
  v16 = 0;
  v17 = 0;
  v29 = 0;
  v28 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v14 = 19778;
  v18 = 54;
  v19 = 40;
  v23 = a2;
  v21 = v5;
  v20 = a1;
  v22 = 1;
  v9 = sub_100442F0(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_10044370((int)&v14, 14, v9) == 14 && sub_10044370((int)&v19, 40, v10) == 40 )
    {
      v30 = 1;
      v12 = a4;
      v13 = 0;
      if ( v5 )
      {
        while ( sub_10044370(v12, v6, v10) == v6 && (!v7 || sub_10044370((int)&unk_100EDC90, v7, v10) == v7) )
        {
          v12 += v6;
          if ( ++v13 >= v5 )
          {
            sub_100442A0(v10);
            return 1;
          }
        }
        v30 = 0;
      }
    }
    sub_100442A0(v10);
  }
  return v30;
}

//----- (10042EF0) --------------------------------------------------------
char __cdecl sub_10042EF0(int a1, int a2)
{
  char result; // al@2

  if ( sub_10042020(a1) )
    result = sub_10042DA0(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (10042F30) --------------------------------------------------------
char __cdecl sub_10042F30(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x319u )
  {
    sub_1001B780("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 115, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_100FC160[8 * a1];
  *a4 = word_100FC162[a2 + 4 * a1];
  return 1;
}
// 100FC162: using guessed type __int16 word_100FC162[];

//----- (10042F90) --------------------------------------------------------
char __cdecl sub_10042F90(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x145u )
  {
    sub_1001B780("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 320, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_100FDA28[16 * a1];
  *a4 = word_100FDA30[a2 + 8 * a1];
  return 1;
}
// 100FDA30: using guessed type __int16 word_100FDA30[];

//----- (10042FF0) --------------------------------------------------------
char __cdecl sub_10042FF0(unsigned __int8 a1)
{
  char result; // al@1

  result = 0;
  if ( a1 < 0xFu )
    result = byte_100EDD8C[24 * a1];
  return result;
}

//----- (10043010) --------------------------------------------------------
int __cdecl sub_10043010(unsigned __int8 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 0xFu )
    result = 913 * (unsigned __int8)sub_10042FF0(a1);
  return result;
}

//----- (10043030) --------------------------------------------------------
bool __thiscall sub_10043030(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  return !sub_1004E7C0(6569, (int)&v2 + 3, 1) && (BYTE3(v2) == 4 || BYTE3(v2) == 2 || BYTE3(v2) == 5);
}

//----- (10043070) --------------------------------------------------------
char __cdecl sub_10043070(char a1, void *a2)
{
  void *v3; // ecx@3
  char v4; // al@5

  if ( sub_1004E7C0((unsigned __int8)a1 + 36000, (int)a2, 132) )
    return 0;
  v3 = a2;
  if ( !a2 || *(_BYTE *)a2 )
  {
LABEL_8:
    if ( *((_BYTE *)a2 + 21) == 4 )
    {
      if ( *((_BYTE *)a2 + 24) == 1 )
      {
        if ( !sub_10043030(v3) )
        {
          sub_1001B780("..\\lib\\adl\\sys_utl_airframe_tests.c", 206, 0, 0);
          memset(a2, 0, 0x84u);
        }
      }
      else if ( *((_BYTE *)a2 + 24) == 3 && !*((_BYTE *)a2 + 58) )
      {
        *((_DWORD *)a2 + 15) |= 0x200u;
        return 1;
      }
    }
  }
  else
  {
    v4 = 0;
    while ( v4 )
    {
      v4 = *((_BYTE *)v3 + 1);
      v3 = (char *)v3 + 1;
      if ( v4 != *((_BYTE *)v3 + &byte_100647C9 - (_BYTE *)a2) )
        goto LABEL_8;
    }
  }
  return 1;
}

//----- (10043120) --------------------------------------------------------
char __cdecl sub_10043120(char a1)
{
  return byte_100EF601[2 * (unsigned __int8)sub_1001DC80(&a1, 1u, (int)&unk_100EF600, 2, 4, 3)];
}

//----- (10043150) --------------------------------------------------------
char __cdecl sub_10043150(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_10010C50(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_1001B780("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_1004D6F0(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_10010C50(1, 538, a2);
  }
  if ( !v4 || sub_100223B0((int)v3) )
    return 0;
  return 1;
}

//----- (100431D0) --------------------------------------------------------
int __cdecl sub_100431D0(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_10043150(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (10043220) --------------------------------------------------------
signed int __cdecl sub_10043220(unsigned __int8 a1)
{
  void *v1; // ecx@0
  bool v2; // dl@2
  unsigned __int8 v3; // cl@2
  signed int v4; // ebp@8
  void *v5; // ecx@8
  unsigned __int8 v6; // bl@9
  signed int result; // eax@14
  int v8; // [sp+8h] [bp-250h]@0
  char v9[68]; // [sp+Ch] [bp-24Ch]@9
  char v10; // [sp+50h] [bp-208h]@2
  char v11[2]; // [sp+A8h] [bp-1B0h]@5
  char v12[426]; // [sp+AAh] [bp-1AEh]@4

  if ( sub_1002C270(v1) )
  {
    v2 = sub_1004E7C0(6444, (int)&v10, 514) == 0;
    v3 = 0;
    while ( !v2 || !v12[12 * v3] || !(a1 & (unsigned __int8)v11[v3]) )
    {
      if ( ++v3 >= 2u )
        goto LABEL_7;
    }
    result = 0x8000;
  }
  else
  {
LABEL_7:
    LOBYTE(v8) = 0;
    while ( 1 )
    {
      v4 = sub_100230D0(v8);
      if ( (v4 & sub_1001A050(v5)) == v4 )
        break;
LABEL_13:
      LOBYTE(v8) = v8 + 1;
      if ( (unsigned __int8)v8 >= 2u )
        return 0;
    }
    sub_1002D720(v8, v9);
    v6 = 0;
    while ( !sub_1001F920(v8, byte_100EF685[2 * v6]) || !(a1 & (unsigned __int8)v9[12 * v6]) )
    {
      if ( ++v6 >= 2u )
        goto LABEL_13;
    }
    result = v4;
  }
  return result;
}
// 10043220: using guessed type char var_1AE[426];
// 10043220: using guessed type char var_1B0[2];
// 10043220: using guessed type char var_24C[68];

//----- (10043350) --------------------------------------------------------
char __cdecl sub_10043350(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // eax@1
  int v4; // [sp+8h] [bp-250h]@0
  char v5[68]; // [sp+Ch] [bp-24Ch]@7
  char v6; // [sp+50h] [bp-208h]@1
  char v7[2]; // [sp+A8h] [bp-1B0h]@5
  char v8[426]; // [sp+AAh] [bp-1AEh]@4

  memset(&v6, 0, 0x202u);
  v2 = sub_10043220(a2);
  if ( v2 == 256 || v2 == 512 )
  {
    LOBYTE(v4) = sub_10023150(v2);
    sub_1002D720(v4, v5);
    if ( sub_1001F920(v4, byte_100EF685[2 * a1]) && (a2 & (unsigned __int8)v5[12 * a1]) == a2 )
      return 1;
  }
  else if ( v2 == 0x8000 )
  {
    sub_1004E7C0(6444, (int)&v6, 514);
    if ( v8[12 * a1] )
    {
      if ( (a2 & (unsigned __int8)v7[a1]) == a2 )
        return 1;
    }
  }
  return 0;
}
// 10043350: using guessed type char var_1AE[426];
// 10043350: using guessed type char var_1B0[2];
// 10043350: using guessed type char var_24C[68];

//----- (10043480) --------------------------------------------------------
int __cdecl sub_10043480(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_100EFE94[2 * sub_1001DC80(&a1, 1u, (int)&unk_100EFE90, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_100EFED4[2 * sub_1001DC80(&a2, 1u, (int)&unk_100EFED0, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_100EFF04[2 * sub_1001DC80(&a2, 1u, (int)&unk_100EFF00, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_100EFEAC[2 * sub_1001DC80(&a2, 1u, (int)&unk_100EFEA8, 8, 5, 5)];
  }
  return result;
}
// 100EFE94: using guessed type int dword_100EFE94[];
// 100EFEAC: using guessed type int dword_100EFEAC[];
// 100EFED4: using guessed type int dword_100EFED4[];
// 100EFF04: using guessed type int dword_100EFF04[];

//----- (10043530) --------------------------------------------------------
bool __usercall sub_10043530@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_100FF6C7[44 * a1] - (unsigned __int8)byte_100FF6C2[44 * a1];
}

//----- (10043560) --------------------------------------------------------
char __usercall sub_10043560@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_10043530(a1, a4, a5) )
  {
    v6 = a3
       + sub_10043480(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_100FF6C2[44 * a1] - (unsigned __int8)byte_100FF6C7[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_10043480(a1, a4);
    memcpy(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (10043600) --------------------------------------------------------
char __cdecl sub_10043600(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002C640(a1);
  sub_1004E840(v5, (int)&v7, 3684);
  return sub_10043560(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (10043680) --------------------------------------------------------
char __cdecl sub_10043680(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002C640(a1);
  sub_1004E840(v5, (int)&v7, 3684);
  return sub_10043560(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (10043700) --------------------------------------------------------
char __cdecl sub_10043700(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002C640(a1);
  sub_1004E840(v5, (int)&v7, 3684);
  return sub_10043560(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (10043780) --------------------------------------------------------
char __cdecl sub_10043780(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002C640(a1);
  sub_1004E840(v5, (int)&v7, 3684);
  return sub_10043560(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (10043800) --------------------------------------------------------
char __cdecl sub_10043800(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_1001B780("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (100438A0) --------------------------------------------------------
BOOL __fastcall sub_100438A0(int a1)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = a1;
  return sub_10009790(6, 1, 27, 0, (int)&v2, 4) && v2 & 1;
}

//----- (100438D0) --------------------------------------------------------
void *__cdecl sub_100438D0(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_100F01C4;
      break;
    case 0:
      result = &unk_100F01C8;
      break;
    case 1:
      result = &unk_100F01CC;
      break;
    case 2:
      result = &unk_100F01D8;
      break;
    case 3:
      result = &unk_100F01D4;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10043920) --------------------------------------------------------
char sub_10043920()
{
  signed int v0; // esi@1
  char result; // al@11

  qmemcpy(dword_1020CA78, &unk_100F0290, 0x5Cu);
  v0 = 23;
  if ( sub_1002C290(0) == 1 )
  {
    dword_1020CAD4 = 65569;
    dword_1020CAD8 = 65910;
    dword_1020CADC = 65909;
    dword_1020CAE0 = 65912;
    dword_1020CAE4 = 65914;
    dword_1020CAE8 = 65913;
    dword_1020CAEC = 65578;
    dword_1020CAF0 = 65852;
    dword_1020CAF4 = 65908;
    dword_1020CAF8 = 65898;
    v0 = 33;
  }
  if ( sub_1002C290(7u) == 1 || sub_1002C290(8u) == 1 )
    dword_1020CA78[v0++] = 65635;
  if ( sub_10043350(0, 4u) || sub_10043350(1u, 4u) )
  {
    dword_1020CA78[v0] = 65951;
    dword_1020CA7C[v0] = 65952;
    dword_1020CA80[v0] = 65950;
    dword_1020CA84[v0] = 65949;
    dword_1020CA88[v0] = 65953;
    v0 += 5;
  }
  if ( sub_1002C290(2u) == 1 )
  {
    dword_1020CA78[v0] = 65906;
    dword_1020CA7C[v0] = 65905;
    dword_1020CA80[v0] = 65907;
    dword_1020CA84[v0] = 65912;
    dword_1020CA88[v0] = 65914;
    dword_1020CA8C[v0] = 65913;
    dword_1020CA90[v0] = 65578;
    dword_1020CA94[v0] = 65569;
    dword_1020CA98[v0] = 65944;
    dword_1020CA9C[v0] = 65945;
    dword_1020CAA0[v0] = 65946;
    dword_1020CAA4[v0] = 65947;
    dword_1020CAA8[v0] = 65954;
    v0 += 13;
  }
  result = sub_1004DF70(1);
  if ( result )
  {
    dword_1020CA78[v0] = 65569;
    dword_1020CA7C[v0] = 65944;
    dword_1020CA80[v0] = 65945;
    dword_1020CA84[v0] = 65946;
    dword_1020CA88[v0] = 65947;
    result = 122;
    dword_1020CA8C[v0] = 65954;
    dword_1020CA90[v0] = 65912;
    dword_1020CA94[v0] = 65914;
    dword_1020CA98[v0] = 65913;
    dword_1020CA9C[v0] = 65578;
    v0 += 10;
  }
  LOWORD(dword_1020CA78[v0]) = 904;
  BYTE2(dword_1020CA78[v0]) = 3;
  return result;
}
// 1020CA78: using guessed type int dword_1020CA78[];
// 1020CA7C: using guessed type int dword_1020CA7C[];
// 1020CA80: using guessed type int dword_1020CA80[];
// 1020CA84: using guessed type int dword_1020CA84[];
// 1020CA88: using guessed type int dword_1020CA88[];
// 1020CA8C: using guessed type int dword_1020CA8C[];
// 1020CA90: using guessed type int dword_1020CA90[];
// 1020CA94: using guessed type int dword_1020CA94[];
// 1020CA98: using guessed type int dword_1020CA98[];
// 1020CA9C: using guessed type int dword_1020CA9C[];
// 1020CAA0: using guessed type int dword_1020CAA0[];
// 1020CAA4: using guessed type int dword_1020CAA4[];
// 1020CAA8: using guessed type int dword_1020CAA8[];
// 1020CAD4: using guessed type int dword_1020CAD4;
// 1020CAD8: using guessed type int dword_1020CAD8;
// 1020CADC: using guessed type int dword_1020CADC;
// 1020CAE0: using guessed type int dword_1020CAE0;
// 1020CAE4: using guessed type int dword_1020CAE4;
// 1020CAE8: using guessed type int dword_1020CAE8;
// 1020CAEC: using guessed type int dword_1020CAEC;
// 1020CAF0: using guessed type int dword_1020CAF0;
// 1020CAF4: using guessed type int dword_1020CAF4;
// 1020CAF8: using guessed type int dword_1020CAF8;

//----- (10043BB0) --------------------------------------------------------
int *__cdecl sub_10043BB0(char a1)
{
  int *result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = (int *)&unk_100F01C4;
      break;
    case 0:
      result = (int *)&unk_100F0280;
      break;
    case 1:
      result = (int *)&unk_100F01CC;
      break;
    case 2:
      sub_10043920();
      result = dword_1020CA78;
      break;
    case 3:
      result = (int *)&unk_100F0384;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 1020CA78: using guessed type int dword_1020CA78[];

//----- (10043C10) --------------------------------------------------------
bool __thiscall sub_10043C10(void *this)
{
  return (sub_1001A050(this) & 0x800) == 2048;
}

//----- (10043C30) --------------------------------------------------------
void *__cdecl sub_10043C30(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_100F0410;
        break;
      case 0:
        result = &unk_100F0414;
        break;
      case 1:
        result = &unk_100F0418;
        break;
      case 2:
        result = &unk_100F046C;
        break;
      case 3:
        result = &unk_100F0490;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (10043C90) --------------------------------------------------------
int __cdecl sub_10043C90(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a2 >= 7 || a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100F0558 + a1);
        break;
      case 0:
        result = (int)*(&off_100F0560 + a1);
        break;
      case 1:
        result = (int)*(&off_100F0568 + a1);
        break;
      case 2:
        result = (int)*(&off_100F0570 + a1);
        break;
      case 3:
        result = (int)*(&off_100F0578 + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 100F0558: using guessed type void *off_100F0558;
// 100F0560: using guessed type void *off_100F0560;
// 100F0568: using guessed type void *off_100F0568;
// 100F0570: using guessed type void *off_100F0570;
// 100F0578: using guessed type void *off_100F0578;

//----- (10043D10) --------------------------------------------------------
int __cdecl sub_10043D10(unsigned __int8 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 2u )
    result = dword_100F0580[a1];
  return result;
}
// 100F0580: using guessed type int dword_100F0580[];

//----- (10043D30) --------------------------------------------------------
int __cdecl sub_10043D30(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 3u || a2 >= 0x23u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_100F2A04 + a1 + 16 * a2);
        break;
      case 0:
        result = (int)*(&off_100F2A10 + a1 + 16 * a2);
        break;
      case 1:
        result = (int)*(&off_100F2A1C + a1 + 16 * a2);
        break;
      case 2:
        result = (int)*(&off_100F2A28 + a1 + 16 * a2);
        break;
      case 3:
        result = (int)*(&off_100F2A34 + a1 + 16 * a2);
        break;
      default:
        sub_1001B780("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 209, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 100F2A04: using guessed type void *off_100F2A04;
// 100F2A10: using guessed type void *off_100F2A10;
// 100F2A1C: using guessed type void *off_100F2A1C;
// 100F2A28: using guessed type void *off_100F2A28;
// 100F2A34: using guessed type void *off_100F2A34;

//----- (10043E00) --------------------------------------------------------
int __cdecl sub_10043E00(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 3u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_100F2988 + a1);
        break;
      case 0:
        result = (int)*(&off_100F2994 + a1);
        break;
      case 1:
        result = (int)*(&off_100F29A0 + a1);
        break;
      case 2:
        result = (int)*(&off_100F29AC + a1);
        break;
      case 3:
        result = (int)*(&off_100F29B8 + a1);
        break;
      default:
        sub_1001B780("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 313, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 100F2988: using guessed type void *off_100F2988;
// 100F2994: using guessed type void *off_100F2994;
// 100F29A0: using guessed type void *off_100F29A0;
// 100F29AC: using guessed type void *off_100F29AC;
// 100F29B8: using guessed type void *off_100F29B8;

//----- (10043E90) --------------------------------------------------------
int __cdecl sub_10043E90(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 3u || a2 >= 0x21u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_100F32C4 + a1 + 16 * a2);
        break;
      case 0:
        result = (int)*(&off_100F32D0 + a1 + 16 * a2);
        break;
      case 1:
        result = (int)*(&off_100F32DC + a1 + 16 * a2);
        break;
      case 2:
        result = (int)*(&off_100F32E8 + a1 + 16 * a2);
        break;
      case 3:
        result = (int)*(&off_100F32F4 + a1 + 16 * a2);
        break;
      default:
        sub_1001B780("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 504, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 100F32C4: using guessed type void *off_100F32C4;
// 100F32D0: using guessed type void *off_100F32D0;
// 100F32DC: using guessed type void *off_100F32DC;
// 100F32E8: using guessed type void *off_100F32E8;
// 100F32F4: using guessed type void *off_100F32F4;

//----- (10043F60) --------------------------------------------------------
int __cdecl sub_10043F60(int a1, unsigned __int8 a2, char a3)
{
  int result; // eax@3

  if ( a2 >= 3u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = *(_DWORD *)(a1 + 4 * a2);
        break;
      case 0:
        result = *(_DWORD *)(a1 + 4 * a2 + 12);
        break;
      case 1:
        result = *(_DWORD *)(a1 + 4 * a2 + 24);
        break;
      case 2:
        result = *(_DWORD *)(a1 + 4 * a2 + 36);
        break;
      case 3:
        result = *(_DWORD *)(a1 + 4 * a2 + 48);
        break;
      default:
        sub_1001B780("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 583, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}

//----- (10044000) --------------------------------------------------------
int __cdecl sub_10044000(unsigned __int8 a1, char a2)
{
  return sub_10043F60((int)&off_100F29C4, a1, a2);
}
// 100F29C4: using guessed type void *off_100F29C4;

//----- (10044020) --------------------------------------------------------
void *__cdecl sub_10044020(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_100F3B30;
      break;
    case 0:
      result = &unk_100F3B34;
      break;
    case 1:
      result = &unk_100F3D38;
      break;
    case 2:
      result = &unk_100F3B3C;
      break;
    case 3:
      result = &unk_100F3B40;
      break;
    case 5:
      result = &unk_100F3B44;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10044080) --------------------------------------------------------
void *__cdecl sub_10044080(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_100F3B48;
      break;
    case 0:
      result = &unk_100F3B74;
      break;
    case 1:
      result = &unk_100F3B98;
      break;
    case 2:
      result = &unk_100F3BC8;
      break;
    case 3:
      result = &unk_100F3C40;
      break;
    case 5:
      result = &unk_100F3B44;
      break;
    default:
      return result;
  }
  return result;
}

//----- (100440E0) --------------------------------------------------------
void *__cdecl sub_100440E0(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_100F3B30;
      break;
    case 0:
      result = &unk_100F3D44;
      break;
    case 1:
      result = &unk_100F3B38;
      break;
    case 2:
      result = &unk_100F3D58;
      break;
    case 3:
      result = &unk_100F3B40;
      break;
    case 5:
      result = &unk_100F3B44;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10044140) --------------------------------------------------------
int __cdecl sub_10044140(char a1, char a2)
{
  int result; // eax@1
  char v3; // cl@2

  result = 0;
  switch ( a1 )
  {
    case 3:
      v3 = 0;
      break;
    case 4:
      v3 = 1;
      break;
    case 5:
      v3 = 2;
      break;
    default:
      if ( a1 != 6 )
        return 0;
      v3 = 3;
      break;
  }
  switch ( a2 )
  {
    case 6:
      result = (int)*(&off_100F3D68 + (unsigned __int8)v3);
      break;
    case 0:
      result = (int)*(&off_100F3D78 + (unsigned __int8)v3);
      break;
    case 1:
      result = (int)*(&off_100F3D88 + (unsigned __int8)v3);
      break;
    case 2:
      result = (int)*(&off_100F3D98 + (unsigned __int8)v3);
      break;
    case 3:
      result = (int)*(&off_100F3DA8 + (unsigned __int8)v3);
      break;
    case 5:
      result = (int)*(&off_100F3DB8 + (unsigned __int8)v3);
      break;
    default:
      return result;
  }
  return result;
}
// 100F3D68: using guessed type void *off_100F3D68;
// 100F3D78: using guessed type void *off_100F3D78;
// 100F3D88: using guessed type void *off_100F3D88;
// 100F3D98: using guessed type void *off_100F3D98;
// 100F3DA8: using guessed type void *off_100F3DA8;
// 100F3DB8: using guessed type void *off_100F3DB8;

//----- (100441E0) --------------------------------------------------------
void *__cdecl sub_100441E0(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_100F3DC8;
        break;
      case 0:
        result = &unk_100F3DCC;
        break;
      case 1:
        result = &unk_100F3E00;
        break;
      case 2:
        result = &unk_100F3E30;
        break;
      case 3:
        result = &unk_100F3E70;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (10044240) --------------------------------------------------------
void *__cdecl sub_10044240(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_100F3E98;
        break;
      case 0:
        result = &unk_100F3E9C;
        break;
      case 1:
        result = &unk_100F3EB8;
        break;
      case 2:
        result = &unk_100F3EFC;
        break;
      case 3:
        result = &unk_100F3F10;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (100442A0) --------------------------------------------------------
BOOL __cdecl sub_100442A0(unsigned int a1)
{
  j_FIL_vfs_clean_invalidate_cache(a1);
  return sub_1004EF10(a1) == 0;
}
// 1004EF00: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);

//----- (100442C0) --------------------------------------------------------
BOOL __cdecl sub_100442C0(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 1004EF80: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (100442F0) --------------------------------------------------------
unsigned int __cdecl sub_100442F0(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 1004F010: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10044350) --------------------------------------------------------
signed int __cdecl sub_10044350(void *a1, int a2, unsigned int a3)
{
  return sub_1004F020(a3, a1, a2);
}

//----- (10044370) --------------------------------------------------------
int __cdecl sub_10044370(int a1, int a2, int a3)
{
  return j_FIL_vfs_write(a3, a1, a2);
}
// 1004F190: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10044390) --------------------------------------------------------
char __cdecl sub_10044390(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  unsigned int v4; // ebp@7
  int v5; // esi@8
  bool i; // zf@8
  char v8; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_100442F0((int)a1, 0);
    if ( v3 )
    {
      v4 = sub_100442F0((int)a2, 1);
      if ( v4 )
      {
        v5 = sub_10044350(&v8, 512, v3);
        for ( i = v5 == 0; v5 > 0; i = v5 == 0 )
        {
          v5 -= sub_10044370((int)&v8, v5, v4);
          if ( !v5 )
            v5 = sub_10044350(&v8, 512, v3);
        }
        v2 = i;
        sub_100442A0(v4);
      }
      sub_100442A0(v3);
    }
    return v2;
  }
  return 1;
}

//----- (100444D0) --------------------------------------------------------
int __cdecl sub_100444D0(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_10044350(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (10044550) --------------------------------------------------------
signed int __usercall sub_10044550@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_100F4BA0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_100F3FA0[2 * (unsigned __int8)v68] ^ dword_100F43A0[2 * BYTE1(v65)] ^ dword_100F47A0[2 * (unsigned __int8)(v66 >> 16)] ^ dword_100F4BA0[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_100F4BA0[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_100F4BA0[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_100F4BA0[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_100F4BA0[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_100F4BA0[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_100F4BA0[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_100F4BA0[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_100F4BA0[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_100F4FA0[(unsigned __int8)v57] ^ dword_100F5BA0[v58 >> 24] ^ dword_100F53A0[BYTE1(v59)] ^ dword_100F57A0[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_100F4FA0[(unsigned __int8)v59] ^ dword_100F57A0[(unsigned __int8)(v58 >> 16)] ^ dword_100F5BA0[v57 >> 24] ^ dword_100F53A0[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_100F4FA0[(unsigned __int8)v60] ^ dword_100F53A0[BYTE1(v58)] ^ dword_100F57A0[(unsigned __int8)(v57 >> 16)] ^ dword_100F5BA0[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_100F4FA0[(unsigned __int8)v58] ^ dword_100F53A0[BYTE1(v57)] ^ dword_100F57A0[(unsigned __int8)(v59 >> 16)] ^ dword_100F5BA0[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100F4BA0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_100F4BA0[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100F4BA0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100F4BA0[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100F4BA0[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100F3FA0[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100F43A0[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100F47A0[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100F4BA0[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 100F4FA0: using guessed type int dword_100F4FA0[];
// 100F53A0: using guessed type int dword_100F53A0[];
// 100F57A0: using guessed type int dword_100F57A0[];
// 100F5BA0: using guessed type int dword_100F5BA0[];

//----- (10045600) --------------------------------------------------------
int __usercall sub_10045600@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_10044550(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (10045660) --------------------------------------------------------
signed int __usercall sub_10045660@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_100F5BA0[(unsigned __int8)v9] ^ dword_100F4FA0[BYTE1(v9)] ^ dword_100F53A0[(unsigned __int8)(v9 >> 16)] ^ dword_100F57A0[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_100F5BA0[(unsigned __int8)v129] ^ dword_100F4FA0[BYTE1(v129)] ^ dword_100F53A0[(unsigned __int8)(v129 >> 16)] ^ dword_100F57A0[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_100F5BA0[(unsigned __int8)v133] ^ dword_100F4FA0[BYTE1(v133)] ^ dword_100F53A0[(unsigned __int8)(v133 >> 16)] ^ dword_100F57A0[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_100F5BA0[(unsigned __int8)v137] ^ dword_100F4FA0[BYTE1(v137)] ^ dword_100F53A0[(unsigned __int8)(v137 >> 16)] ^ dword_100F57A0[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_100F5BA0[(unsigned __int8)v141] ^ dword_100F4FA0[BYTE1(v141)] ^ dword_100F53A0[(unsigned __int8)(v141 >> 16)] ^ dword_100F57A0[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_100F5BA0[(unsigned __int8)v145] ^ dword_100F4FA0[BYTE1(v145)] ^ dword_100F53A0[(unsigned __int8)(v145 >> 16)] ^ dword_100F57A0[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_100F5BA0[(unsigned __int8)v149] ^ dword_100F4FA0[BYTE1(v149)] ^ dword_100F53A0[(unsigned __int8)(v149 >> 16)] ^ dword_100F57A0[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_100F5BA0[(unsigned __int8)v153] ^ dword_100F4FA0[BYTE1(v153)] ^ dword_100F53A0[(unsigned __int8)(v153 >> 16)] ^ dword_100F57A0[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_100F5BA0[(unsigned __int8)v157] ^ dword_100F4FA0[BYTE1(v157)] ^ dword_100F53A0[(unsigned __int8)(v157 >> 16)] ^ dword_100F57A0[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_100F5BA0[(unsigned __int8)v161] ^ dword_100F4FA0[BYTE1(v161)] ^ dword_100F53A0[(unsigned __int8)(v161 >> 16)] ^ dword_100F57A0[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_100F5BA0[(unsigned __int8)v77] ^ dword_100F4FA0[BYTE1(v77)] ^ dword_100F53A0[(unsigned __int8)(v77 >> 16)] ^ dword_100F57A0[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_100F5BA0[(unsigned __int8)v82] ^ dword_100F4FA0[BYTE1(v82)] ^ dword_100F53A0[(unsigned __int8)(v82 >> 16)] ^ dword_100F57A0[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_100F5BA0[(unsigned __int8)v89] ^ dword_100F4FA0[BYTE1(v89)] ^ dword_100F53A0[(unsigned __int8)(v89 >> 16)] ^ dword_100F57A0[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_100F5BA0[(unsigned __int8)v94] ^ dword_100F4FA0[BYTE1(v94)] ^ dword_100F53A0[(unsigned __int8)(v94 >> 16)] ^ dword_100F57A0[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_100F5BA0[(unsigned __int8)v100] ^ dword_100F4FA0[BYTE1(v100)] ^ dword_100F53A0[(unsigned __int8)(v100 >> 16)] ^ dword_100F57A0[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_100F5BA0[(unsigned __int8)v100] ^ dword_100F4FA0[BYTE1(v100)] ^ dword_100F53A0[(unsigned __int8)(v100 >> 16)] ^ dword_100F57A0[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_100F5BA0[(unsigned __int8)v108] ^ dword_100F4FA0[BYTE1(v108)] ^ dword_100F53A0[(unsigned __int8)(v108 >> 16)] ^ dword_100F57A0[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_100F5BA0[(unsigned __int8)v114] ^ dword_100F4FA0[BYTE1(v114)] ^ dword_100F53A0[(unsigned __int8)(v114 >> 16)] ^ dword_100F57A0[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_100F5BA0[(unsigned __int8)v120] ^ dword_100F4FA0[BYTE1(v120)] ^ dword_100F53A0[(unsigned __int8)(v120 >> 16)] ^ dword_100F57A0[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_100F5BA0[(unsigned __int8)v19] ^ dword_100F4FA0[BYTE1(v19)] ^ dword_100F53A0[(unsigned __int8)(v19 >> 16)] ^ dword_100F57A0[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_100F4FA0[(unsigned __int8)v23] ^ dword_100F53A0[BYTE1(v23)] ^ dword_100F57A0[(unsigned __int8)(v23 >> 16)] ^ dword_100F5BA0[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_100F5BA0[(unsigned __int8)v26] ^ dword_100F4FA0[BYTE1(v26)] ^ dword_100F53A0[(unsigned __int8)(v26 >> 16)] ^ dword_100F57A0[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_100F4FA0[(unsigned __int8)v31] ^ dword_100F53A0[BYTE1(v31)] ^ dword_100F57A0[(unsigned __int8)(v31 >> 16)] ^ dword_100F5BA0[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_100F5BA0[(unsigned __int8)v35] ^ dword_100F4FA0[BYTE1(v35)] ^ dword_100F53A0[(unsigned __int8)(v35 >> 16)] ^ dword_100F57A0[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_100F4FA0[(unsigned __int8)v41] ^ dword_100F53A0[BYTE1(v41)] ^ dword_100F57A0[(unsigned __int8)(v41 >> 16)] ^ dword_100F5BA0[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_100F5BA0[(unsigned __int8)v43] ^ dword_100F4FA0[BYTE1(v43)] ^ dword_100F53A0[(unsigned __int8)(v43 >> 16)] ^ dword_100F57A0[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_100F4FA0[(unsigned __int8)v47] ^ dword_100F53A0[BYTE1(v47)] ^ dword_100F57A0[(unsigned __int8)(v47 >> 16)] ^ dword_100F5BA0[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_100F5BA0[(unsigned __int8)v52] ^ dword_100F4FA0[BYTE1(v52)] ^ dword_100F53A0[(unsigned __int8)(v52 >> 16)] ^ dword_100F57A0[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_100F4FA0[(unsigned __int8)v58] ^ dword_100F53A0[BYTE1(v58)] ^ dword_100F57A0[(unsigned __int8)(v58 >> 16)] ^ dword_100F5BA0[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_100F5BA0[(unsigned __int8)v60] ^ dword_100F4FA0[BYTE1(v60)] ^ dword_100F53A0[(unsigned __int8)(v60 >> 16)] ^ dword_100F57A0[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_100F4FA0[(unsigned __int8)v66] ^ dword_100F53A0[BYTE1(v66)] ^ dword_100F57A0[(unsigned __int8)(v66 >> 16)] ^ dword_100F5BA0[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_100F5BA0[(unsigned __int8)v69] ^ dword_100F4FA0[BYTE1(v69)] ^ dword_100F53A0[(unsigned __int8)(v69 >> 16)] ^ dword_100F57A0[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 100F4FA0: using guessed type int dword_100F4FA0[];
// 100F53A0: using guessed type int dword_100F53A0[];
// 100F57A0: using guessed type int dword_100F57A0[];
// 100F5BA0: using guessed type int dword_100F5BA0[];

//----- (100463E0) --------------------------------------------------------
void *__usercall sub_100463E0@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (10046400) --------------------------------------------------------
unsigned int __cdecl sub_10046400(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_1004E4B0();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 1004E500: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (10046460) --------------------------------------------------------
int __usercall sub_10046460@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = 271733878;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (100464A0) --------------------------------------------------------
int __usercall sub_100464A0@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (10047BC0) --------------------------------------------------------
unsigned int __usercall sub_10047BC0@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_100F5FC8[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_100F5FD8[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_100464A0(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_100464A0(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 100F5FC8: using guessed type int dword_100F5FC8[];
// 100F5FD8: using guessed type int dword_100F5FD8[];

//----- (10047CC0) --------------------------------------------------------
void *__usercall sub_10047CC0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  int v3; // ebp@1
  size_t v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (int)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*(_DWORD *)(v3 + 4);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy((void *)(v5 + v3 + 28), v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_100464A0(v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy((void *)(v5 + v3 + 28), v9, v4);
}

//----- (10047D40) --------------------------------------------------------
void *__usercall sub_10047D40@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_10047BC0(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_10046460(v3 + 64);
    result = sub_10047CC0(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_10047CC0(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (10047DE0) --------------------------------------------------------
int __usercall sub_10047DE0@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_10047D40(a1, 0, 0);
  sub_10047BC0(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_10046460(a1 + 64);
  sub_10047CC0(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_10047CC0(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_10047BC0(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy((void *)a2, &v5, a3);
  return result;
}

//----- (10047EA0) --------------------------------------------------------
int __usercall sub_10047EA0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_10046460(a2 + 64);
    sub_10047CC0(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_10047CC0(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (10047F00) --------------------------------------------------------
int __usercall sub_10047F00@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  int v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = (int)&a1[v1];
    memcpy(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy(&v19[v6], a1, 64 - v6);
    sub_100464A0((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *(_DWORD *)(v8 + 4) = v9;
    v12 = v18;
    *(_DWORD *)(v8 + 8) = result;
    v1 += 20;
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(v8 + 16) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 10047F00: using guessed type char var_40[64];

//----- (10047FC0) --------------------------------------------------------
int __usercall sub_10047FC0@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_10047F00((char *)a1);
  return sub_10047F00(v8);
}

//----- (10048080) --------------------------------------------------------
char __cdecl sub_10048080(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10047D40(a3 + 296, a2, a1);
    sub_10045600(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100480D0) --------------------------------------------------------
char __cdecl sub_100480D0(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10045600(a3, (int)a1, a2);
    sub_10047D40(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10048120) --------------------------------------------------------
bool __cdecl sub_10048120(int a1, int a2)
{
  if ( a2 )
    sub_10047DE0(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (10048150) --------------------------------------------------------
int __usercall sub_10048150@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_100463E0(&v24);
  sub_10047EA0(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_10047D40((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_10047D40((int)&v23, v12, (char *)&v31);
          sub_10047DE0((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 10048150: using guessed type char var_14[16];

//----- (10048360) --------------------------------------------------------
int __usercall sub_10048360@<eax>(void *a1@<eax>, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1

  v2 = (int)a1;
  memset(a1, 0, 0x210u);
  *(_DWORD *)(v2 + 524) = a2;
  sub_10047FC0(v2);
  v3 = 20;
  do
  {
    sub_10047F00((char *)v2);
    --v3;
  }
  while ( v3 );
  return sub_10047FC0(v2);
}

//----- (100483B0) --------------------------------------------------------
char *__cdecl sub_100483B0(int a1, int a2)
{
  void *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = (char *)v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_10047FC0(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (10048440) --------------------------------------------------------
signed int __cdecl sub_10048440(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_10048150(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_10045660(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_100463E0((void *)(a6 + 296));
      sub_10047EA0(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 10048440: using guessed type char var_40[8];
// 10048440: using guessed type __int16 var_38[26];

//----- (10048570) --------------------------------------------------------
bool __cdecl sub_10048570(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_10048360(&v4, (int)sub_10046400);
  if ( v2 )
    sub_100483B0(a2, (int)&v4);
  return v2;
}

//----- (100485F0) --------------------------------------------------------
BOOL __usercall sub_100485F0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_100F67E0[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_100F66E0[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_100F65E0[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (10048690) --------------------------------------------------------
int __usercall sub_10048690@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (10048720) --------------------------------------------------------
unsigned int __fastcall sub_10048720(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (10048740) --------------------------------------------------------
int __usercall sub_10048740@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (100487D0) --------------------------------------------------------
int __usercall sub_100487D0@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_100F67E0[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_100F67E0[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_100F5FE8[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_100F68E0[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_100F66E0[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_100F65E0[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_100F6070[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_100F6958[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 100F5FE8: using guessed type int dword_100F5FE8[];
// 100F6070: using guessed type int dword_100F6070[];
// 100F68E0: using guessed type int dword_100F68E0[];
// 100F6958: using guessed type int dword_100F6958[];

//----- (10048C50) --------------------------------------------------------
int __usercall sub_10048C50@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_10048740(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (10048D00) --------------------------------------------------------
void *__usercall sub_10048D00@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (10048D60) --------------------------------------------------------
int __usercall sub_10048D60@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (10048F30) --------------------------------------------------------
signed int __usercall sub_10048F30@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_10048720(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (10048FB0) --------------------------------------------------------
_WORD *__fastcall sub_10048FB0(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (10049020) --------------------------------------------------------
signed int __usercall sub_10049020@<eax>(int a1@<esi>)
{
  int v1; // ecx@1
  int v2; // edx@1
  int v3; // eax@1
  int v4; // edx@1
  signed int result; // eax@1

  v1 = *(_DWORD *)(a1 + 5764);
  v2 = *(_DWORD *)(a1 + 5736);
  *(_DWORD *)(a1 + 5744) = 2 * *(_DWORD *)(a1 + 5748);
  *(_WORD *)(v2 + 2 * v1 - 2) = 0;
  memset(*(void **)(a1 + 5736), 0, 2 * *(_DWORD *)(a1 + 5764) - 2);
  v3 = 6 * *(_BYTE *)(a1 + 5784);
  *(_DWORD *)(a1 + 5700) = (unsigned __int16)word_100F69D2[6 * *(_BYTE *)(a1 + 5784)];
  *(_DWORD *)(a1 + 5704) = (unsigned __int16)word_100F69D0[v3];
  *(_DWORD *)(a1 + 5708) = (unsigned __int16)word_100F69D4[v3];
  v4 = (unsigned __int16)word_100F69D6[v3];
  result = 2;
  *(_DWORD *)(a1 + 5680) = 0;
  *(_DWORD *)(a1 + 5664) = 0;
  *(_DWORD *)(a1 + 5688) = 0;
  *(_DWORD *)(a1 + 5676) = 0;
  *(_DWORD *)(a1 + 5760) = 0;
  *(_DWORD *)(a1 + 5696) = v4;
  *(_DWORD *)(a1 + 5692) = 2;
  *(_DWORD *)(a1 + 5668) = 2;
  return result;
}
// 100F69D0: using guessed type __int16 word_100F69D0[];
// 100F69D2: using guessed type __int16 word_100F69D2[];
// 100F69D4: using guessed type __int16 word_100F69D4[];
// 100F69D6: using guessed type __int16 word_100F69D6[];

//----- (100490E0) --------------------------------------------------------
unsigned int __usercall sub_100490E0@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (10049290) --------------------------------------------------------
unsigned int __usercall sub_10049290@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (10049360) --------------------------------------------------------
int __usercall sub_10049360@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (10049410) --------------------------------------------------------
int __usercall sub_10049410@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (10049450) --------------------------------------------------------
unsigned int __usercall sub_10049450@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_1004B4C0(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100494B0) --------------------------------------------------------
signed int __usercall sub_100494B0@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (10049590) --------------------------------------------------------
int __usercall sub_10049590@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (10049B30) --------------------------------------------------------
_WORD *__fastcall sub_10049B30(int a1, int a2)
{
  *(_DWORD *)(a2 + 5628) = a2 + 2936;
  *(_DWORD *)(a2 + 5652) = a2 + 5472;
  *(_DWORD *)(a2 + 5636) = &off_100F6B84;
  *(_DWORD *)(a2 + 5640) = a2 + 5228;
  *(_DWORD *)(a2 + 5648) = &off_100F6B98;
  *(_DWORD *)(a2 + 5660) = &unk_100F6BAC;
  *(_WORD *)(a2 + 2924) = 0;
  *(_DWORD *)(a2 + 2932) = 0;
  *(_DWORD *)(a2 + 2928) = 8;
  return sub_10048FB0(a2 + 5228, a2);
}
// 100F6B84: using guessed type void *off_100F6B84;
// 100F6B98: using guessed type void *off_100F6B98;

//----- (10049B90) --------------------------------------------------------
signed int __cdecl sub_10049B90(int a1)
{
  int v1; // esi@2
  int v2; // eax@3
  int v3; // ecx@5
  signed int result; // eax@5

  if ( a1 && (v1 = *(_DWORD *)(a1 + 24)) != 0 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(v1 + 5808) = *(_DWORD *)(v1 + 5800);
    v2 = *(_DWORD *)(v1 + 5780);
    *(_DWORD *)(v1 + 5812) = 0;
    if ( v2 < 0 )
      *(_DWORD *)(v1 + 5780) = -v2;
    *(_DWORD *)(v1 + 5788) = *(_DWORD *)(v1 + 5780) != 0 ? 42 : 113;
    *(_DWORD *)(a1 + 28) = sub_1004B4C0(0, 0, 0);
    *(_DWORD *)(v1 + 5792) = 0;
    sub_10049B30(v3, v1);
    sub_10049020(v1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10049C20) --------------------------------------------------------
int __usercall sub_10049C20@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_10048690(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_10048690(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_10048690(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (10049E60) --------------------------------------------------------
int __usercall sub_10049E60@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_10048C50(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_10048C50(a1, a3, a4);
  }
  return result;
}

//----- (10049F00) --------------------------------------------------------
signed int __usercall sub_10049F00@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_10049360(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_10049360(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_10049360(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_10048D60(a1, a2);
  return sub_10048F30(a1, v16, v5);
}

//----- (1004A0E0) --------------------------------------------------------
unsigned int __usercall sub_1004A0E0@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_10049450(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (1004A220) --------------------------------------------------------
int __usercall sub_1004A220@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_100F605C[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_10049590(a1, a1 + 2936, a2 - 1);
  return sub_10049590(v24, v24 + 5228, a3 - 1);
}

//----- (1004A4D0) --------------------------------------------------------
signed int __cdecl sub_1004A4D0(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_10049410(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_10049410(v9, *(_WORD *)(a1 + 30));
      sub_10049410(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_1004B4C0(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_10048D00(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_100F69D8 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_10049C20(v2);
    }
    else
    {
      sub_10049E60(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_10048D00(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_10049410(v2, *(_WORD *)(a1 + 30));
    sub_10049410(v13, *(_WORD *)(a1 + 28));
    sub_10048D00(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100F69D8: using guessed type int (__cdecl *off_100F69D8)(int, int);

//----- (1004A790) --------------------------------------------------------
signed int __cdecl sub_1004A790(int a1, unsigned __int8 a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8)
{
  signed int v8; // edx@1
  int v9; // eax@5
  unsigned int v10; // edi@12
  signed int v11; // ebp@12
  signed int v12; // eax@12
  int v13; // ebp@14
  int v14; // esi@14
  int v15; // esi@14
  int v16; // esi@14
  signed int result; // eax@14

  v8 = 1;
  if ( a1 && a7 )
  {
    if ( a2 == -1 )
      a2 = 6;
    v9 = a4;
    if ( a4 < 0 )
    {
      v8 = 0;
      v9 = -a4;
      a4 = -a4;
    }
    if ( (unsigned int)(a5 - 1) > 7 || a3 != 8 || (unsigned int)(v9 - 9) > 6 || a2 > 9u || a6 > 3u )
    {
      result = -2;
    }
    else
    {
      v10 = 1 << (a5 + 6);
      v11 = 1 << v9;
      v12 = 1 << (a5 + 7);
      if ( (signed int)(2 * (v12 + 2 * (v10 + v11) + 2908)) > a8 || a7 & 3 )
      {
        result = -4;
      }
      else
      {
        *(_DWORD *)(a1 + 24) = a7;
        *(_DWORD *)(a7 + 5780) = v8;
        *(_DWORD *)(a7 + 5764) = v12;
        *(_DWORD *)(a7 + 5752) = a4;
        *(_DWORD *)(a7 + 5768) = a5 + 7;
        *(_DWORD *)(a7 + 5772) = v12 - 1;
        *(_DWORD *)(a7 + 5756) = v11 - 1;
        *(_DWORD *)(a7 + 5748) = v11;
        *(_DWORD *)(a7 + 5740) = a7 + 5816;
        v13 = 2 * v11;
        v14 = v13 + a7 + 5816;
        *(_DWORD *)(a7 + 5732) = v14;
        v15 = v13 + v14;
        *(_DWORD *)(a7 + 5776) = (a5 + 9) / 3u;
        *(_DWORD *)(a7 + 5736) = v15;
        v16 = v15 + 2 * (1 << (a5 + 7));
        *(_DWORD *)(a7 + 5804) = 4 * v10;
        *(_DWORD *)(a7 + 5716) = v10 + v16 + 2 * v10;
        *(_DWORD *)(a7 + 5712) = v16 + 2 * (v10 >> 1);
        *(_DWORD *)(a7 + 5724) = v10;
        *(_DWORD *)(a7 + 5800) = v16;
        *(_BYTE *)(a7 + 5784) = a2;
        *(_BYTE *)(a7 + 5796) = a6;
        *(_BYTE *)(a7 + 5720) = 8;
        result = sub_10049B90(a1);
      }
    }
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1004A940) --------------------------------------------------------
signed int __usercall sub_1004A940@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_100494B0(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_100494B0(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_10049F00(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_100F605C[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100F605B[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100F605A[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100F6059[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (1004AA10) --------------------------------------------------------
_WORD *__usercall sub_1004AA10@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_10049F00(a2, a2 + 5628);
  sub_10049F00(v4, v4 + 5640);
  v8 = sub_1004A940(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_10049E60(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_100487D0(v4, (int)&unk_100F60E8, (int)&unk_100F6568);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_1004A220(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_100487D0(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_10048FB0(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_10048740(v4);
  return result;
}

//----- (1004AC30) --------------------------------------------------------
signed int __cdecl sub_1004AC30(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_1004A0E0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_100490E0(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_10049290(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_100485F0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_100485F0(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_1004AA10(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10048D00(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_1004AA10(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10048D00(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1004AF40) --------------------------------------------------------
signed int __cdecl sub_1004AF40(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_1004A0E0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_100490E0(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_10049290(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_100485F0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_1004AA10(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_10048D00(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_100485F0(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_1004AA10(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_10048D00(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_100485F0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_1004AA10(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10048D00(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (1004B350) --------------------------------------------------------
signed int __cdecl sub_1004B350(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_1004A0E0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_1004AA10(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_10048D00(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_1004AA10(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10048D00(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_1004AA10(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10048D00(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1004B4C0) --------------------------------------------------------
int __cdecl sub_1004B4C0(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  int result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = v4 | (v5 << 16);
  }
  else
  {
    result = (int)(a2 + 1);
  }
  return result;
}

//----- (1004B5C0) --------------------------------------------------------
signed int __cdecl sub_1004B5C0(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1004B5E0) --------------------------------------------------------
signed int __usercall sub_1004B5E0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 1004B5E0: using guessed type int var_78[14];
// 1004B5E0: using guessed type int var_3C[15];

//----- (1004BA80) --------------------------------------------------------
int (__cdecl *__usercall sub_1004BA80@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (1004BAD0) --------------------------------------------------------
int __usercall sub_1004BAD0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (1004BAF0) --------------------------------------------------------
signed int __cdecl sub_1004BAF0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_100F6BC0[a1];
  v51 = dword_100F6BC0[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_100F6BC0[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_100F6BC0[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_100F6BC0[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_100F6BC0[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 100F6BC0: using guessed type int dword_100F6BC0[];

//----- (1004BEA0) --------------------------------------------------------
int __usercall sub_1004BEA0@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (1004BFE0) --------------------------------------------------------
signed int __usercall sub_1004BFE0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_1004B5E0(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (1004C030) --------------------------------------------------------
signed int __usercall sub_1004C030@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_1004B5E0(a7, a6, a4, 257, (int)&unk_100F6C58, (int)&unk_100F6CD8, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_1004B5E0(a8, &a6[a4], a5, 0, (int)&unk_100F6D58, (int)&unk_100F6DD0, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004C0D0) --------------------------------------------------------
int __usercall sub_1004C0D0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_100F6E48;
  *a4 = &unk_100F7E48;
  return 0;
}

//----- (1004C0F0) --------------------------------------------------------
signed int __cdecl sub_1004C0F0(int a1, int a2, int a3, int a4)
{
  int v4; // ecx@1
  signed int v5; // ebx@1

  v4 = a2;
  v5 = 0;
  if ( a2 < 0 )
  {
    v5 = 1;
    v4 = -a2;
  }
  if ( (1 << v4) + 14152 <= a4 && !(a3 & 3) )
  {
    *(_DWORD *)(a1 + 24) = a3;
    *(_DWORD *)(a3 + 16) = v4;
    *(_DWORD *)(a3 + 12) = v5;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)(a3 + 20) = a3 + 24;
    *(_DWORD *)(a3 + 14128) = a3 + 14152;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14108) = (1 << v4) + *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14104);
    **(_BYTE **)(a3 + 20) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1428) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1424) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14124) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1420) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14112) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14116) = 0;
    if ( *(_DWORD *)(a3 + 12) )
      *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14120) = 0;
    else
      *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14120) = sub_1004B4C0;
    sub_1004BA80(0, *(_DWORD *)(a3 + 20), a1);
    JUMPOUT(&loc_1004BFA0);
  }
  return -4;
}

//----- (1004C1E0) --------------------------------------------------------
signed int __cdecl sub_1004C1E0(int a1)
{
  signed int result; // eax@2
  int v2; // ecx@3
  int v3; // esi@3

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    v3 = *(_DWORD *)(v2 + 20);
    *(_BYTE *)v2 = *(_DWORD *)(v2 + 12) != 0 ? 7 : 0;
    sub_1004BA80(0, v3, a1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1004C1F0) --------------------------------------------------------
int __usercall sub_1004C1F0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_1004BAF0(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100F6BC0[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_100F6BC0[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100F6BC0[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_100F6BC0[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_1004BEA0(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_1004BEA0(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_1004BEA0(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_1004BEA0(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 100F6BC0: using guessed type int dword_100F6BC0[];

//----- (1004C890) --------------------------------------------------------
int __usercall sub_1004C890@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_1004C0D0(&v67, &v69, &v66, &v68);
          sub_1004BAD0(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_1004BEA0(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_100F6C08[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_100F6C08[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_1004BFE0(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_1004C030(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_1004BAD0(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_1004C1F0(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_1004BEA0(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_1004BEA0(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_1004BEA0(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_100F6BC0[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_100F6BC0[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_1004BEA0(v7, v3, v58);
}
// 100F6BC0: using guessed type int dword_100F6BC0[];
// 100F6C08: using guessed type int dword_100F6C08[];

//----- (1004D270) --------------------------------------------------------
signed int __usercall sub_1004D270@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_1004C890(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_1004BA80((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (1004D5A0) --------------------------------------------------------
signed int __cdecl sub_1004D5A0(int a1, int a2)
{
  return sub_1004D270(a1, a2);
}

//----- (1004D5C0) --------------------------------------------------------
signed int __cdecl sub_1004D5C0(unsigned int a1)
{
  int v1; // eax@1

  v1 = sub_10031130(a1);
  return sub_100326C0(v1);
}

//----- (1004D600) --------------------------------------------------------
signed int __cdecl sub_1004D600(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_10031130(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_10032BA0(v4, a4, 0) == a4 )
      result = sub_10032B40(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (1004D660) --------------------------------------------------------
signed int __cdecl sub_1004D660(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_10031130(a1);
  return sub_10032BA0(v3, a2, a3);
}

//----- (1004D680) --------------------------------------------------------
int __cdecl sub_1004D680(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D270(a1, 0, 0xA452u, -23470, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004D6C0) --------------------------------------------------------
int __cdecl sub_1004D6C0(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1003D270(a1, 0, 0xFE2u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1004D6F0) --------------------------------------------------------
bool __cdecl sub_1004D6F0(void *a1)
{
  char v1; // cl@1

  v1 = sub_10010C50(1, 1946, a1);
  *((_DWORD *)a1 + 1) /= 0x3E8u;
  return v1 && !sub_100223B0((int)a1);
}

//----- (1004D730) --------------------------------------------------------
int __cdecl sub_1004D730(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (1004D740) --------------------------------------------------------
int __cdecl sub_1004D740(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 10050290: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 100502A0: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 100502B0: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 100502C0: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 10050370: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (1004D880) --------------------------------------------------------
char __usercall sub_1004D880@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy_0((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy_0((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (1004D950) --------------------------------------------------------
signed int __cdecl sub_1004D950(_DWORD *a1, char *a2)
{
  int v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = (int)a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *(_DWORD *)v2;
    v10 = *(_DWORD *)v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_100502D0(*(_DWORD *)(v2 + 4), (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_1004D880(v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)(v2 + 30), (char)a1);
          v3 = v10;
          *a2 = v8;
          *(_DWORD *)(v2 + 24) += v6;
        }
        else
        {
          v7 = *(_DWORD *)(v2 + 4);
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_1004D740(v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 10050380: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (1004DA30) --------------------------------------------------------
int __cdecl sub_1004DA30(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (1004DA50) --------------------------------------------------------
int (__cdecl *__usercall sub_1004DA50@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (1004DA60) --------------------------------------------------------
int __usercall sub_1004DA60@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (1004DC90) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004DC90(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1004DA50(a1, (int)" ");
  sub_1004DA50(a1, a2);
  sub_1004DA50(a1, (int)&unk_100FC144);
  v3 = sub_1004DA60(a3, a1);
  sub_1004DA50(a1, v3);
  return sub_1004DA50(a1, (int)&unk_100FC140);
}

//----- (1004DCE0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004DCE0(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1004DA50(a1, (int)" ");
  sub_1004DA50(a1, a2);
  sub_1004DA50(a1, (int)&unk_100FC14C);
  v3 = sub_1004DA60(a3, a1);
  sub_1004DA50(a1, v3);
  return sub_1004DA50(a1, (int)&unk_100FC148);
}

//----- (1004DD30) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004DD30(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_1004DA50(a1, (int)&unk_100FC150);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_1004DA60(a2, a1);
    result = sub_1004DA50(a1, v3);
  }
  return result;
}

//----- (1004DD80) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004DD80(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_100FC158;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_1004DA50(a1, dword_100FC0AC[(signed int)result]);
      sub_1004DA50(a1, (int)&unk_100FC154);
      sub_1004DA50(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_100FC150;
    }
    result = sub_1004DA50(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_1004DA50(a1, (int)&word_100ED4C4);
  }
  return result;
}
// 100ED4C4: using guessed type __int16 word_100ED4C4;
// 100FC0AC: using guessed type int dword_100FC0AC[];

//----- (1004DE00) --------------------------------------------------------
int __cdecl sub_1004DE00(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_1004DA50(a1, (int)&unk_100FC150);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_1004DA50(a1, (int)(&off_100FC0B0)[2 * (*(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84))]);
  sub_1004DA50(a1, (int)&unk_100FC15C);
  sub_1004DA50(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}
// 100FC0B0: using guessed type __int16 *off_100FC0B0;

//----- (1004DE80) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004DE80(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_1004DA60(a2, a1);
    sub_1004DA50(a1, v3);
    result = sub_1004DA50(a1, (int)&word_100ED4C4);
  }
  else
  {
    sub_1004DA50(a1, (int)a2);
    result = sub_1004DA50(a1, (int)&word_100ED4C4);
  }
  return result;
}
// 100ED4C4: using guessed type __int16 word_100ED4C4;

//----- (1004DED0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004DED0(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_1004DE00(a1, a2);
  if ( a3 && *a3 )
    sub_1004DD30(a1, a3);
  return sub_1004DD80(a1);
}

//----- (1004DF10) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004DF10(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_1004DED0(a1, a2, (unsigned __int8 *)&v4);
}

//----- (1004DF70) --------------------------------------------------------
char __cdecl sub_1004DF70(char a1)
{
  void *v1; // ecx@0
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      sub_1004E840(6470, (int)&a1, 1);
      result = a1 && sub_10043220(2u);
    }
    else if ( a1 == 2 )
    {
      result = sub_1001FC70(14);
    }
    else
    {
      sub_1001B780("..\\lib\\adl\\iop_dl_wx_intf_a.c", 475, 1, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_10043C10(v1);
  }
  return result;
}

//----- (1004DFF0) --------------------------------------------------------
int __cdecl sub_1004DFF0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)a1 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (1004E000) --------------------------------------------------------
int (*__usercall sub_1004E000@<eax>(int a1@<eax>, double *a2@<ecx>, int a3@<edi>, int a4@<esi>, int a5, int a6, char a7, double a8, int a9))(void)
{
  double *v9; // ebx@1
  int (*v10)(void); // eax@4
  double v11; // st7@6
  int (*result)(void); // eax@7

  v9 = a2;
  if ( a5 == a1 + 1 )
  {
    if ( !*(_BYTE *)a4 )
    {
      *(_BYTE *)a4 = 1;
      if ( *(_DWORD *)(a3 + 40) )
      {
        v10 = *(int (**)(void))(a3 + 44);
        if ( v10 )
          *(_DWORD *)(a4 + 4) = v10();
      }
    }
    goto LABEL_6;
  }
  if ( a5 != a1 || !*(_BYTE *)a4 || a7 )
  {
LABEL_6:
    v11 = a8;
    goto LABEL_7;
  }
  v11 = *(double *)(a4 + 12);
LABEL_7:
  result = (int (*)(void))a6;
  if ( a5 >= (unsigned int)a6 )
  {
    *v9 = *(double *)(a3 + 16) * v11
        + *(double *)(a3 + 24) * *(double *)(a4 + 12)
        + *(double *)(a3 + 32) * *(double *)(a4 + 20)
        - *(double *)(a4 + 28) * *(double *)a3
        - *(double *)(a3 + 8) * *(double *)(a4 + 36);
    *(double *)(a4 + 20) = *(double *)(a4 + 12);
    *(double *)(a4 + 12) = v11;
    *(double *)(a4 + 36) = *(double *)(a4 + 28);
    *(double *)(a4 + 28) = *v9;
  }
  if ( (a5 == a6 || !*(_BYTE *)a4) && !a7 )
    result = (int (*)(void))sub_1004DFF0(a4);
  *(_BYTE *)a9 = 0;
  if ( *(_BYTE *)a4 )
  {
    if ( !*(_DWORD *)(a3 + 40)
      || (result = *(int (**)(void))(a3 + 44)) != 0
      && (result = (int (*)(void))(result() - *(_DWORD *)(a4 + 4)), (unsigned int)result >= *(_DWORD *)(a3 + 40)) )
    {
      *(_BYTE *)a9 = 1;
    }
  }
  return result;
}

//----- (1004E0D0) --------------------------------------------------------
int __usercall sub_1004E0D0@<eax>(int result@<eax>, _DWORD *a2@<edi>, unsigned int a3@<esi>, char a4)
{
  unsigned int v4; // ecx@3

  *(_DWORD *)(result + 8) >>= 1;
  if ( a4 )
    *(_DWORD *)(result + 8) |= 1 << a3;
  *a2 = 0;
  v4 = 0;
  do
  {
    if ( (1 << v4) & *(_DWORD *)(result + 8) )
      ++*a2;
    ++v4;
  }
  while ( v4 <= a3 );
  return result;
}

//----- (1004E110) --------------------------------------------------------
int (*__cdecl sub_1004E110(char a1, double a2, int a3, int a4, int a5, int a6))(void)
{
  int v6; // eax@1
  int v7; // ecx@1
  int v9; // [sp+18h] [bp-4h]@1

  v6 = sub_1004E0D0(a4, &v9, 5u, a1);
  v7 = v9;
  if ( v9 == 1 )
  {
    if ( a1 )
      *(double *)(v6 + 20) = a2;
  }
  else if ( v9 == 2 )
  {
    if ( a1 )
    {
      *(double *)(v6 + 12) = a2;
      *(double *)(v6 + 36) = 0.0;
    }
  }
  else if ( v9 == 3 && a1 )
  {
    *(double *)(v6 + 28) = 0.0;
    *(double *)(v6 + 20) = *(double *)(v6 + 12);
    *(double *)(v6 + 12) = a2;
  }
  return sub_1004E000(5, (double *)a6, a3, v6, v7, 4, a1, a2, a5);
}

//----- (1004E1A0) --------------------------------------------------------
int (*__cdecl sub_1004E1A0(char a1, double a2, int a3, int a4, int a5, int a6))(void)
{
  int v6; // eax@1
  int v7; // ecx@1
  int v9; // [sp+18h] [bp-4h]@1

  v6 = sub_1004E0D0(a4, &v9, 4u, a1);
  v7 = v9;
  if ( v9 == 1 )
  {
    if ( a1 )
    {
      *(double *)(v6 + 20) = a2;
      *(double *)(v6 + 36) = a2;
    }
  }
  else if ( v9 == 2 && a1 )
  {
    *(double *)(v6 + 12) = a2;
    *(double *)(v6 + 28) = (*(double *)(v6 + 20) + a2) * 0.5;
  }
  return sub_1004E000(4, (double *)a6, a3, v6, v7, 3, a1, a2, a5);
}

//----- (1004E220) --------------------------------------------------------
unsigned __int16 __cdecl sub_1004E220(_BYTE *a1, int a2, unsigned __int16 a3, char a4)
{
  _BYTE *v4; // ecx@1
  int v5; // esi@2
  unsigned __int16 result; // ax@3
  __int16 v7; // bx@4
  unsigned int v8; // edx@4
  int v9; // edx@6
  int v10; // esi@8

  v4 = a1;
  if ( a4 == 1 )
  {
    v5 = a2;
    if ( a2 )
    {
      result = a3;
      do
      {
        LOBYTE(v7) = 0;
        HIBYTE(v7) = result;
        v8 = *v4 ^ ((unsigned int)result >> 8);
        --v5;
        ++v4;
        result = word_10101078[v8] ^ v7;
      }
      while ( v5 );
      return result;
    }
    return a3;
  }
  v9 = a2;
  if ( !a2 )
    return a3;
  result = a3;
  do
  {
    v10 = (unsigned __int8)result ^ *v4;
    --v9;
    ++v4;
    result = word_10101278[v10] ^ HIBYTE(result);
  }
  while ( v9 );
  return result;
}
// 10101078: using guessed type __int16 word_10101078[];
// 10101278: using guessed type __int16 word_10101278[];

//----- (1004E2A0) --------------------------------------------------------
int __cdecl sub_1004E2A0(unsigned __int8 a1, unsigned int a2)
{
  return dword_10101478[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 10101478: using guessed type int dword_10101478[];

//----- (1004E2C0) --------------------------------------------------------
unsigned int __cdecl sub_1004E2C0(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_10101478[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_10101478[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_10101478[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_10101478[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_10101478[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_10101478[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_10101478[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_10101478[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_10101478[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_10101478[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 10101478: using guessed type int dword_10101478[];

//----- (1004E3F0) --------------------------------------------------------
double __cdecl sub_1004E3F0(float a1)
{
  float v2; // [sp+4h] [bp+4h]@1

  v2 = pow(a1 / 101325.0, 0.190228059887886);
  return (float)((1.0 - v2) * -44330.765625);
}

//----- (1004E420) --------------------------------------------------------
int __cdecl sub_1004E420(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 1005092A: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (1004E440) --------------------------------------------------------
int sub_1004E440()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050930: using guessed type int TSK_pvg_get_id(void);

//----- (1004E460) --------------------------------------------------------
int __cdecl sub_1004E460(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050936: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (1004E490) --------------------------------------------------------
__int16 __cdecl sub_1004E490(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 1005093C: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (1004E4B0) --------------------------------------------------------
int sub_1004E4B0()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050942: using guessed type int TSK_pvg_get_timer(void);

//----- (1004E4D0) --------------------------------------------------------
int __cdecl sub_1004E4D0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050948: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1004E510) --------------------------------------------------------
int __cdecl sub_1004E510(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050954: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1004E540) --------------------------------------------------------
int __cdecl sub_1004E540(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 1005095A: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (1004E560) --------------------------------------------------------
int __cdecl sub_1004E560(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050960: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (1004E590) --------------------------------------------------------
int __cdecl sub_1004E590(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_evnt(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050966: using guessed type int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD);

//----- (1004E5C0) --------------------------------------------------------
int __cdecl sub_1004E5C0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_send_msg(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 1005096C: using guessed type int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1004E5F0) --------------------------------------------------------
int __cdecl sub_1004E5F0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050972: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (1004E620) --------------------------------------------------------
int __cdecl sub_1004E620(int a1)
{
  SYS_enter_krnl();
  TSK_pvg_set_proc_status(a1);
  return SYS_exit_krnl();
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050978: using guessed type int __cdecl TSK_pvg_set_proc_status(_DWORD);

//----- (1004E640) --------------------------------------------------------
int __cdecl sub_1004E640(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 1005097E: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (1004E660) --------------------------------------------------------
int __cdecl sub_1004E660(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_1004E440();
    sub_1004E4D0((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050984: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (1004E6A0) --------------------------------------------------------
int __cdecl sub_1004E6A0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_1004E540(a2);
  return result;
}
// 1006411C: using guessed type void *tsk_app_hdr_ptr;

//----- (1004E6D0) --------------------------------------------------------
int __cdecl sub_1004E6D0(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_1004E560(a1, a2);
  return result;
}
// 1006411C: using guessed type void *tsk_app_hdr_ptr;

//----- (1004E6F0) --------------------------------------------------------
int __cdecl sub_1004E6F0(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = 0;
  result = 42066;
  while ( dword_101056B8[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xA5 )
      return result;
  }
  return dword_101056BC[2 * v1];
}
// 101056B8: using guessed type int dword_101056B8[];
// 101056BC: using guessed type int dword_101056BC[];

//----- (1004E740) --------------------------------------------------------
unsigned int __cdecl sub_1004E740(unsigned int a1)
{
  unsigned int result; // eax@1

  result = 43;
  if ( a1 < 0xA452 )
    result = (unsigned __int16)a1 / 0x3E8u;
  return result;
}

//----- (1004E770) --------------------------------------------------------
int __cdecl sub_1004E770(int a1, int a2, int a3)
{
  return reg_tag_dflt(a1 | 0x20000, a2, a3, 0);
}
// 10050990: using guessed type int __cdecl reg_tag_dflt(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1004E7C0) --------------------------------------------------------
int __cdecl sub_1004E7C0(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 100509A8: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1004E7E0) --------------------------------------------------------
int __cdecl sub_1004E7E0(int a1, int a2, __int16 a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+8h] [bp-8h]@1

  v7 = 0;
  *(_DWORD *)a5 = 0;
  LOWORD(v7) = a3;
  *(_DWORD *)(a5 + 4) = -1;
  return reg_read_from_xml(a1, &v6, a4, a2, v7, a5);
}
// 100509AE: using guessed type int __cdecl reg_read_from_xml(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1004E840) --------------------------------------------------------
char __cdecl sub_1004E840(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_1004E7C0(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_1001B780("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (1004E880) --------------------------------------------------------
int __cdecl sub_1004E880(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_1004E7C0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (1004E8C0) --------------------------------------------------------
int __cdecl sub_1004E8C0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_1004E7C0(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (1004E8F0) --------------------------------------------------------
int __cdecl sub_1004E8F0(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 100509B4: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1004E910) --------------------------------------------------------
int __cdecl sub_1004E910(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@2
  int result; // eax@4
  int v6; // [sp+10h] [bp-4h]@1

  v6 = sub_1004E8F0(a1, a2, a3);
  v3 = 0;
  if ( (unsigned __int8)sub_1004FD00() )
  {
    v4 = sub_1004E6F0(a1);
    if ( v4 != 42066 )
      v3 = sub_1004E8F0(v4, a2, a3);
  }
  result = v6;
  if ( !v6 )
    result = v3;
  return result;
}
// 1004FD00: using guessed type int sub_1004FD00(void);

//----- (1004E970) --------------------------------------------------------
int __cdecl sub_1004E970(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_1004E910(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    sub_1001B780("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1742, 1, 0);
    result = v4;
  }
  return result;
}

//----- (1004E9B0) --------------------------------------------------------
char __cdecl sub_1004E9B0(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_1004E8F0(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_1001B780("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1826, 1, 0);
  return v3;
}

//----- (1004EA20) --------------------------------------------------------
int __cdecl sub_1004EA20(int a1, unsigned __int8 a2)
{
  int result; // eax@2
  int v3; // [sp+4h] [bp-10h]@1
  int v4; // [sp+8h] [bp-Ch]@1
  int v5; // [sp+Ch] [bp-8h]@1

  memset(&unk_1021A2C8, 0, 0x5800u);
  v3 = 0;
  v4 = 0;
  v5 = 0;
  if ( a2 >= 3u )
    return -31;
  j_reg_get_tag_hdr(&v3, a1, a1);
  if ( HIWORD(v5) > 0x5800u )
    return -47;
  if ( !a2 )
    goto LABEL_8;
  if ( a2 != 2 )
  {
    if ( a2 == 1 && !(_BYTE)v3 )
      goto LABEL_8;
    return 0;
  }
  if ( !(_BYTE)v3 )
    return 0;
LABEL_8:
  sub_1004FFD0(a1, &unk_1021A2C8);
  if ( (unsigned __int16)a1 / 0x3E8u == 6 )
    result = sub_1004E910(a1, (int)&unk_1021A2C8, *(int *)((char *)&v5 + 2));
  else
    result = sub_1004E8F0(a1, (int)&unk_1021A2C8, *(int *)((char *)&v5 + 2));
  return result;
}
// 1004E790: using guessed type int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD);

//----- (1004EB00) --------------------------------------------------------
char __cdecl sub_1004EB00(int a1, _DWORD *a2, int a3, int a4, int a5, unsigned int a6)
{
  char v6; // dl@1
  int v7; // ecx@2
  unsigned int v8; // ebp@4
  unsigned int v9; // esi@5
  char v10; // dl@5
  unsigned int v11; // eax@5
  int v12; // ecx@6
  int v13; // eax@13
  bool v14; // zf@18
  int v16; // [sp+0h] [bp-20h]@1
  int v17; // [sp+4h] [bp-1Ch]@2
  int v18; // [sp+8h] [bp-18h]@13
  int v19; // [sp+Ch] [bp-14h]@2
  unsigned int v20; // [sp+10h] [bp-10h]@4
  char v21; // [sp+14h] [bp-Ch]@13
  int v22; // [sp+18h] [bp-8h]@14
  char v23; // [sp+30h] [bp+10h]@4
  char v24; // [sp+30h] [bp+10h]@13

  v6 = 0;
  v16 = 0;
  if ( a4 )
  {
    v7 = a3 + 4;
    v17 = a3 + 4;
    v19 = a4;
    do
    {
      if ( *(_DWORD *)(v7 - 4) == a1 )
      {
        v23 = 1;
        v20 = *(_DWORD *)(v7 + 4) - *(_DWORD *)v7;
        v8 = 0;
        do
        {
          v9 = v8 + *(_DWORD *)v7;
          v10 = 0;
          v11 = 0;
          if ( a6 )
          {
            v12 = a5;
            while ( !v10 )
            {
              if ( *(_DWORD *)v12 == a1 && *(_DWORD *)(v12 + 4) == v9 )
                v10 = 1;
              ++v11;
              v12 += 10;
              if ( v11 >= a6 )
              {
                if ( v10 )
                  break;
                goto LABEL_13;
              }
            }
          }
          else
          {
LABEL_13:
            v13 = j_reg_get_tag_hdr(&v21, v9, v9);
            v24 = v21 & (v13 == 1) & v23;
            v18 = 0;
            if ( !sub_1004FD10(v9, (unsigned int *)&v16, &v18) )
              v16 = v22;
            v23 = (v18 == 0) & v24;
            *a2 += v16;
          }
          v7 = v17;
          ++v8;
        }
        while ( v8 <= v20 );
        v6 = v23;
      }
      v7 += 12;
      v14 = v19-- == 1;
      v17 = v7;
    }
    while ( !v14 );
  }
  return v6;
}
// 1004E790: using guessed type int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD);

//----- (1004EC10) --------------------------------------------------------
int __cdecl sub_1004EC10(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_1004E7C0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    sub_1004E8F0(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (1004ED20) --------------------------------------------------------
int sub_1004ED20()
{
  int result; // eax@2

  if ( sub_10050390() )
    result = j_HWM_pvg_get_anlg_outp(4);
  else
    result = j_HWM_pvg_get_anlg_outp(0);
  return result;
}
// 1004EC70: using guessed type int __cdecl j_HWM_pvg_get_anlg_outp(_DWORD);

//----- (1004ED40) --------------------------------------------------------
int __cdecl sub_1004ED40(int a1, int a2)
{
  int v2; // esi@1
  unsigned int v3; // eax@8
  unsigned int v4; // ecx@8
  int v5; // esi@9
  int v6; // eax@14
  int v7; // esi@15
  int v8; // eax@18
  int v9; // esi@19
  unsigned int v10; // eax@22
  unsigned int v11; // ecx@22
  int v12; // esi@23

  v2 = 0;
  if ( *(_BYTE *)(a1 + 2) )
    v2 = 16;
  if ( *(_BYTE *)(a2 + 2) )
    v2 |= 0x20u;
  if ( !v2 )
  {
    if ( *(_DWORD *)(a1 + 144) != *(_DWORD *)(a2 + 144) )
      v2 = 2;
    v3 = *(_DWORD *)(a1 + 8);
    v4 = *(_DWORD *)(a2 + 8);
    if ( v3 != v4 )
    {
      v5 = v2 | 2;
      if ( v3 <= v4 )
        v2 = v5 | 0x80;
      else
        v2 = v5 | 0x40;
    }
    if ( strncmp((const char *)(a1 + 28), (const char *)(a2 + 28), 0x10u) )
      v2 |= 2u;
    v6 = strncmp((const char *)(a1 + 44), (const char *)(a2 + 44), 8u);
    if ( v6 )
    {
      v7 = v2 | 2;
      if ( v6 <= 0 )
        v2 = v7 | 8;
      else
        v2 = v7 | 4;
    }
    v8 = strncmp((const char *)(a1 + 148), (const char *)(a2 + 148), 8u);
    if ( v8 )
    {
      v9 = v2 | 2;
      if ( v8 <= 0 )
        v2 = v9 | 8;
      else
        v2 = v9 | 4;
    }
    v10 = *(_BYTE *)(a2 + 189) | ((*(_BYTE *)(a2 + 188) | (*(_WORD *)(a2 + 190) << 8)) << 8);
    v11 = *(_BYTE *)(a1 + 189) | ((*(_BYTE *)(a1 + 188) | (*(_WORD *)(a1 + 190) << 8)) << 8);
    if ( v11 != v10 )
    {
      v12 = v2 | 2;
      if ( v11 > v10 )
        return v12 | 4;
      v2 = v12 | 8;
    }
  }
  return v2;
}

//----- (1004EE60) --------------------------------------------------------
char __cdecl sub_1004EE60(char a1)
{
  unsigned __int16 v1; // ax@1
  char result; // al@2

  v1 = sub_1001DC80(&a1, 2u, (int)&unk_101028C8, 4, 76, 76);
  if ( v1 >= 0x4Cu )
    result = 3;
  else
    result = byte_101028CA[4 * v1];
  return result;
}

//----- (1004EEB0) --------------------------------------------------------
void __cdecl sub_1004EEB0(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_100503B0(a1, a2);
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050A14: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (1004EEE0) --------------------------------------------------------
int __cdecl sub_1004EEE0(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_set(a1, a2);
  return SYS_exit_krnl();
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050A1A: using guessed type int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD);

//----- (1004EF10) --------------------------------------------------------
signed int __cdecl sub_1004EF10(unsigned int a1)
{
  signed int result; // eax@4
  int v2; // eax@8
  int v3; // edx@9

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_16;
  if ( (a1 & 3) == 1 )
    return sub_1004D5C0(a1);
  if ( a1 && (a1 & 3) == 2 )
  {
    v2 = 0;
    if ( !dword_1022CB30 )
      goto LABEL_11;
    while ( 1 )
    {
      v3 = dword_1022CB38[v2];
      if ( *(_DWORD *)v3 == a1 )
        break;
      if ( ++v2 >= (unsigned int)dword_1022CB30 )
        goto LABEL_11;
    }
    if ( v2 != -1 )
    {
      sub_100503E0(
        v2,
        *(_DWORD *)(dword_1022CB38[v2] + 12),
        *(_DWORD *)(v3 + 16),
        *(_BYTE *)(v3 + 32),
        *(_WORD *)(v3 + 20),
        *(_DWORD *)(v3 + 4));
      result = sub_1004EF10(a1 & 0xFFFFFFFC);
    }
    else
    {
LABEL_11:
      result = -6;
    }
  }
  else
  {
LABEL_16:
    result = FIL_vfs_close();
  }
  return result;
}
// 10050A26: using guessed type int FIL_vfs_close(void);
// 1022CB30: using guessed type int dword_1022CB30;
// 1022CB38: using guessed type int dword_1022CB38[];

//----- (1004EF50) --------------------------------------------------------
signed int __cdecl sub_1004EF50(unsigned int a1)
{
  signed int result; // eax@3

  if ( a1 < 0xFFFFFFC2 && a1 )
    result = sub_1004EF10(a1);
  else
    result = -6;
  return result;
}

//----- (1004EFB0) --------------------------------------------------------
int __cdecl sub_1004EFB0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 10050A44: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1004F020) --------------------------------------------------------
signed int __cdecl sub_1004F020(unsigned int a1, void *a2, int a3)
{
  unsigned int v3; // eax@4
  signed int result; // eax@4
  int v5; // eax@7

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v3 = sub_10031130(a1);
    return sub_10032B40(v3, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v5 = sub_1004F240(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_10050780(a1, a2, a3, v5, (unsigned __int64)v5 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 10050A56: using guessed type int FIL_vfs_read(void);

//----- (1004F060) --------------------------------------------------------
signed int __cdecl sub_1004F060(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_1004D600(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_10050780(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 10050A5C: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1004F0F0) --------------------------------------------------------
signed int __cdecl sub_1004F0F0(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_1004D660(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 10050A68: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1004F140) --------------------------------------------------------
__int64 __cdecl sub_1004F140(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 10050A6E: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (1004F170) --------------------------------------------------------
int __cdecl sub_1004F170(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 10050A7A: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (1004F1A0) --------------------------------------------------------
int __cdecl sub_1004F1A0(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 10050A86: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1004F1C0) --------------------------------------------------------
char __cdecl sub_1004F1C0(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_1004EF10(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1004F010: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1004F1F0) --------------------------------------------------------
int __cdecl sub_1004F1F0(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // esi@1
  int result; // eax@3
  unsigned int v4; // ST00_4@4

  v2 = a2;
  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1;
    a1 = a2;
    result = j_FIL_vfs_ioctl(v4, 106, &a1, 4);
    if ( !result )
      return result;
  }
  else
  {
    result = -6;
  }
  *(_DWORD *)v2 = 0;
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  *(_DWORD *)(v2 + 24) = 0;
  *(_DWORD *)(v2 + 28) = 0;
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 20) = 0;
  return result;
}
// 1004EFA0: using guessed type int __cdecl j_FIL_vfs_ioctl(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1004F240) --------------------------------------------------------
signed int __cdecl sub_1004F240(unsigned int a1, int a2, int a3)
{
  return sub_1004F0F0(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (1004F260) --------------------------------------------------------
int __cdecl sub_1004F260(int a1, int a2, int a3)
{
  return sub_1004F170(a1, a2, a3);
}

//----- (1004F2B0) --------------------------------------------------------
int __cdecl sub_1004F2B0(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_1001B780("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_1001B780("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 100508D0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (1004F310) --------------------------------------------------------
signed int __cdecl sub_1004F310(int a1)
{
  unsigned int v1; // eax@1
  signed int result; // eax@3

  v1 = **(_DWORD **)(a1 + 16);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    if ( *(_BYTE *)(v1 - 3) || *(_BYTE *)(a1 + 4) & 8 )
    {
      if ( *(_BYTE *)(a1 + 4) & 1 )
      {
        *(_BYTE *)(v1 - 3) = 0;
        result = 1;
      }
      else
      {
        sub_1001B780("..\\lib\\acl\\kernel\\mem_usr_share.c", 474, 1, 0);
        result = 0;
      }
    }
    else
    {
      sub_1001B780("..\\lib\\acl\\kernel\\mem_usr_share.c", 465, 1, 0);
      result = 1;
    }
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\kernel\\mem_usr_share.c", 455, 1, 0);
    result = 0;
  }
  return result;
}

//----- (1004F390) --------------------------------------------------------
int __usercall sub_1004F390@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  char v3; // ST28_1@2
  unsigned int v4; // eax@5
  char *v5; // edi@9
  char v6; // al@10
  unsigned int v7; // eax@12
  char v8; // ST28_1@12
  signed int v9; // ebx@15
  int v10; // eax@19
  int result; // eax@47
  unsigned int v12; // [sp+Ch] [bp-98h]@1
  int v13; // [sp+14h] [bp-90h]@29
  char v14; // [sp+1Dh] [bp-87h]@30
  char v15; // [sp+1Fh] [bp-85h]@9
  char v16; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v12 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
    v3 = 4;
  }
  else
  {
    strncpy(&v16, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v5 = &v15;
      do
        v6 = (v5++)[1];
      while ( v6 );
      *(_DWORD *)v5 = 7368052;
    }
    v12 = j_FIL_vfs_open(*a1, 6, 1809);
    v7 = j_FIL_vfs_open(&v16, 14, 1809);
    v2 = v7;
    v8 = 6;
    if ( v7 >= 0xFFFFFFC2 || !v7 )
    {
      sub_1001B780("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v9 = sub_1004F240(v7, 0, 2);
    if ( v9 < 0 )
    {
      sub_1001B780("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_1001B780("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v10 = (int)(a1[2] + 12);
    if ( v9 < v10 && sub_1004F260(v2, v10, (unsigned __int64)v10 >> 32) < 0 )
    {
      sub_1001B780("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v4 = ((int (__cdecl *)(unsigned int, _DWORD, const char *, _DWORD))j_FIL_vfs_mmap)(v2, 0, a1[2] + 12, 0);
    v1 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v4 + 9) || *(_BYTE *)(v4 + 8) != 56 )
        {
          sub_1004F2B0((int)a1, v4 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v4 + 4) = sub_1004E4B0();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v12 < 0xFFFFFFC2 && v12 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_1004F020(v12, &v13, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v13;
          v14 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_1004F1A0(v12, (int)&v13, 12, 0) != 12 )
          {
            sub_1001B780("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v16, *a1) )
        sub_1001B780("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_1001B780("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_1004EF10(v2);
LABEL_42:
  if ( v12 < 0xFFFFFFC2 && v12 )
    sub_1004EF10(v12);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 1004F000: using guessed type int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1004F010: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1004F0E0: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (1004F690) --------------------------------------------------------
int __usercall sub_1004F690@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 100508D0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (1004F6B0) --------------------------------------------------------
signed int __cdecl sub_1004F6B0(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_1001B780("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_1004E6D0(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_1004E6A0(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_1004F690(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_1004F390((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_1004E6A0(v6, 81);
  return (unsigned __int8)v2;
}

//----- (1004F780) --------------------------------------------------------
int __cdecl sub_1004F780(LONG Value)
{
  char v1; // al@1
  int result; // eax@3
  int v3; // edi@3
  unsigned __int32 v4; // eax@5
  int v5; // ebx@5

  v1 = *(_BYTE *)(Value + 4);
  if ( v1 & 2 || !(v1 & 1) )
  {
    sub_1001B780("..\\lib\\acl\\kernel\\mem_usr_share.c", 360, 1, 0);
    result = 0;
  }
  else
  {
    result = sub_1004F390((const char **)Value);
    v3 = result;
    if ( (unsigned int)result < 0xFFFFFFC2 && result )
    {
      v4 = InterlockedExchange(*(volatile LONG **)(Value + 16), result);
      v5 = v4;
      if ( v4 < 0xFFFFFFC2 && v4 )
      {
        if ( *(_DWORD *)(Value + 8) < 0 )
          sub_1001B780("..\\lib\\acl\\kernel\\mem_usr_share.c", 388, 0, 0);
        sub_1004F690(*(_DWORD *)(Value + 8), v5);
      }
      result = v3;
    }
  }
  return result;
}

//----- (1004F830) --------------------------------------------------------
char __cdecl sub_1004F830(int a1, char a2)
{
  signed int v2; // ecx@1
  char result; // al@3
  signed int v4; // esi@5
  unsigned __int8 v5; // al@6
  int v6; // ecx@7
  signed int v7; // [sp+Ch] [bp+8h]@2
  signed int v8; // [sp+Ch] [bp+8h]@5

  v2 = 0;
  if ( a2 == 1 )
  {
    v4 = 0;
    v8 = 0;
    do
    {
      v4 += 15;
      ++v2;
      v5 = (signed int)((double)v8 + 0.5);
      *(_BYTE *)(a1 + 2 * v2 - 2) = v5;
      result = (signed int)((double)v5 * 1.5 + 0.5);
      *(_BYTE *)(a1 + 2 * v2 - 1) = result;
      v8 = v4;
    }
    while ( v4 < 60 );
    *(_BYTE *)(a1 + 2 * v2) = 78;
    *(_BYTE *)(a1 + 2 * v2 + 1) = 78;
    v6 = v2 + 1;
    *(_BYTE *)(a1 + 2 * v6) = 82;
    *(_BYTE *)(a1 + 2 * v6 + 1) = 0;
  }
  else
  {
    v7 = 0;
    do
    {
      ++v2;
      result = (signed int)((double)v7 * 20.0 + 0.5);
      *(_BYTE *)(a1 + 2 * v2 - 2) = result;
      *(_BYTE *)(a1 + 2 * v2 - 1) = result;
      v7 = v2;
    }
    while ( v2 < 6 );
  }
  return result;
}

//----- (1004F930) --------------------------------------------------------
char __cdecl sub_1004F930(int a1)
{
  signed int v1; // edi@1
  int v2; // esi@1
  char result; // al@2

  v1 = 0;
  v2 = a1 + 16;
  do
  {
    sub_1004F830(v2 - 14, 0);
    result = sub_1004F830(v2, v1 == 1);
    *(_WORD *)(v2 - 16) = 14;
    *(_BYTE *)(v2 - 2) = 2;
    *(_BYTE *)(v2 - 1) = 0;
    *(_BYTE *)(v2 + 14) = 0;
    *(_WORD *)(v2 + 12) = v1++ == 1 ? 0 : 2000;
    v2 += 32;
  }
  while ( v1 < 2 );
  return result;
}

//----- (1004F9A0) --------------------------------------------------------
int __cdecl sub_1004F9A0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_1001B4A0(v1);
  a1 = v2;
  v3 = sub_1001DC80(&a1, 4u, (int)&unk_10103498, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1010349C[2 * v3];
}
// 1010349C: using guessed type int dword_1010349C[];

//----- (1004F9E0) --------------------------------------------------------
int __cdecl sub_1004F9E0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_1001B4A0(v1);
  a1 = v2;
  v3 = sub_1001DC80(&a1, 4u, (int)&unk_101034D0, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_101034D4[2 * v3];
}
// 101034D4: using guessed type int dword_101034D4[];

//----- (1004FA20) --------------------------------------------------------
int __cdecl sub_1004FA20(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_1001B4A0(v1);
  a1 = v2;
  v3 = sub_1001DC80(&a1, 4u, (int)&unk_10103508, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1010350C[2 * v3];
}
// 1010350C: using guessed type int dword_1010350C[];

//----- (1004FA60) --------------------------------------------------------
int __cdecl sub_1004FA60(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_1001B4A0(v1);
  a1 = v2;
  v3 = sub_1001DC80(&a1, 4u, (int)&unk_10103540, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_10103544[2 * v3];
}
// 10103544: using guessed type int dword_10103544[];

//----- (1004FAA0) --------------------------------------------------------
int __cdecl sub_1004FAA0(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_1004F9E0(a4);
    result = sub_1004E7C0(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_1004E7C0(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_1004F9A0(a4);
      result = sub_1004E7C0(v6, a3, 6);
    }
  }
  return result;
}

//----- (1004FB10) --------------------------------------------------------
int __cdecl sub_1004FB10(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_1004FA60(a3);
    result = sub_1004E7C0(v4, a1, 64);
    if ( result == -7 )
    {
      sub_1004E640(100);
      v5 = sub_1004FA60(a3);
      result = sub_1004E7C0(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_1004FA20(a3);
    result = sub_1004E7C0(v6, a2, 8);
    if ( result == -7 )
    {
      sub_1004E640(100);
      v7 = sub_1004FA20(a3);
      result = sub_1004E7C0(v7, a2, 8);
    }
  }
  return result;
}

//----- (1004FBB0) --------------------------------------------------------
int __cdecl sub_1004FBB0(int a1, char a2)
{
  int result; // eax@1
  __int16 v3; // dx@1
  __int16 v4; // cx@1
  __int16 v5; // dx@1
  __int16 v6; // cx@1
  __int16 v7; // dx@1
  __int16 v8; // cx@1
  __int16 v9; // dx@1
  __int16 v10; // cx@1
  __int16 v11; // dx@1
  __int16 v12; // cx@1
  int v13; // [sp+0h] [bp-Ch]@1
  int v14; // [sp+4h] [bp-8h]@1
  int v15; // [sp+8h] [bp-4h]@1

  v13 = 0;
  v14 = 0;
  v15 = 0;
  sub_1004F830((int)&v13, a2);
  result = a1;
  v3 = 10 * (unsigned __int8)v13;
  *(_WORD *)(a1 + 2) = 10 * BYTE1(v13);
  v4 = BYTE3(v13);
  *(_WORD *)a1 = v3;
  v5 = 10 * BYTE2(v13);
  *(_WORD *)(a1 + 6) = 10 * v4;
  v6 = v14;
  *(_WORD *)(a1 + 4) = v5;
  v7 = (unsigned __int8)v6;
  *(_WORD *)(a1 + 10) = 10 * HIBYTE(v6);
  v8 = BYTE3(v14);
  *(_WORD *)(a1 + 8) = 10 * v7;
  v9 = 10 * BYTE2(v14);
  *(_WORD *)(a1 + 14) = 10 * v8;
  v10 = v15;
  *(_WORD *)(a1 + 12) = v9;
  *(_WORD *)(a1 + 16) = 10 * (unsigned __int8)v10;
  v11 = BYTE2(v15);
  *(_WORD *)(a1 + 18) = 10 * HIBYTE(v10);
  v12 = 10 * BYTE3(v15);
  *(_WORD *)(a1 + 20) = 10 * v11;
  *(_WORD *)(a1 + 22) = v12;
  return result;
}

//----- (1004FC80) --------------------------------------------------------
int __cdecl sub_1004FC80(int a1)
{
  signed int v1; // edi@1
  int v2; // esi@1
  int result; // eax@2

  v1 = 0;
  v2 = a1 + 28;
  do
  {
    sub_1004FBB0(v2 - 24, v1 == 1);
    result = sub_1004FBB0(v2, v1 == 1);
    *(_WORD *)(v2 - 26) = 10000;
    *(_WORD *)(v2 - 28) = 0;
    ++v1;
    v2 += 52;
  }
  while ( v1 < 2 );
  return result;
}

//----- (1004FCD0) --------------------------------------------------------
int __cdecl sub_1004FCD0(char a1)
{
  int result; // eax@1
  int v2; // ecx@1

  result = -1;
  v2 = 0;
  while ( byte_10103AB0[8 * v2] != a1 )
  {
    if ( (unsigned int)++v2 >= 8 )
      return result;
  }
  return dword_10103AB4[2 * v2];
}
// 10103AB4: using guessed type int dword_10103AB4[];

//----- (1004FD10) --------------------------------------------------------
char __cdecl sub_1004FD10(unsigned int a1, unsigned int *a2, int *a3)
{
  int *v3; // edi@4
  int *v4; // edi@5
  int *v5; // edi@6
  int *v7; // edi@11
  int *v8; // edi@12
  int *v9; // esi@13
  unsigned int *v10; // [sp-18h] [bp-E94h]@4
  signed int v11; // [sp-14h] [bp-E90h]@4
  int v12; // [sp+14h] [bp-E68h]@1
  int v13; // [sp+18h] [bp-E64h]@6
  int v14; // [sp+1Ch] [bp-E60h]@6
  char v15; // [sp+20h] [bp-E5Ch]@6
  char v16; // [sp+22h] [bp-E5Ah]@6
  char v17; // [sp+23h] [bp-E59h]@6
  char v18; // [sp+25h] [bp-E57h]@6
  char v19; // [sp+27h] [bp-E55h]@6
  char v20; // [sp+28h] [bp-E54h]@6
  char v21; // [sp+29h] [bp-E53h]@6
  int v22; // [sp+2Ch] [bp-E50h]@6
  int v23; // [sp+37h] [bp-E45h]@5
  int v24; // [sp+40h] [bp-E3Ch]@12
  int v25; // [sp+F0h] [bp-D8Ch]@13
  int v26; // [sp+E70h] [bp-Ch]@11
  int v27; // [sp+E74h] [bp-8h]@11

  memset(&v12, 0, 0xE64u);
  *_errno() = 0;
  if ( a1 > 0x183A )
  {
    if ( a1 == 6455 )
    {
      v9 = _errno();
      *v9 = sub_1004E7C0(6455, (int)&v12, 252);
      v25 = 0;
      v11 = 252;
LABEL_14:
      v10 = (unsigned int *)&v12;
      goto LABEL_15;
    }
    if ( a1 != 6649 )
    {
      if ( a1 != 6655 )
        return 0;
      goto LABEL_11;
    }
LABEL_12:
    v8 = _errno();
    *v8 = sub_1004E7C0(a1, (int)&v12, 48);
    v11 = 48;
    v24 = 0;
    v10 = (unsigned int *)&v12;
    goto LABEL_15;
  }
  if ( a1 >= 0x1839 )
    goto LABEL_12;
  switch ( a1 )
  {
    case 0x17D9u:
    case 0x17DAu:
      v3 = _errno();
      v11 = 36;
      *v3 = sub_1004E7C0(a1, (int)&v12, 36);
      v12 = 0;
      v10 = (unsigned int *)&v12;
      goto LABEL_15;
    case 0x1819u:
      v4 = _errno();
      *v4 = sub_1004E7C0(a1, (int)&v12, 40);
      v11 = 40;
      v23 = 0;
      v10 = (unsigned int *)&v12;
      goto LABEL_15;
    case 0x17CDu:
    case 0x17CEu:
      v5 = _errno();
      *v5 = sub_1004E7C0(a1, (int)&v12, 60);
      v12 = 0;
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v22 = 0;
      v18 = 0;
      v21 = 0;
      v19 = 0;
      v20 = 0;
      v11 = 60;
      goto LABEL_14;
    default:
      return 0;
    case 0x1776u:
    case 0x1777u:
    case 0x1778u:
      break;
  }
LABEL_11:
  v7 = _errno();
  *v7 = sub_1004E7C0(a1, (int)&v12, 3684);
  v11 = 3684;
  v26 = 0;
  v27 = 0;
  v10 = (unsigned int *)&v12;
LABEL_15:
  *a2 = sub_1004E2C0(v10, v11, 0xFFFFFFFF);
  *a3 = *_errno();
  return 1;
}

//----- (1004FFD0) --------------------------------------------------------
int __cdecl sub_1004FFD0(int a1, void *a2)
{
  unsigned int v2; // eax@2
  unsigned int v3; // eax@5
  unsigned int v4; // eax@8
  unsigned int v5; // eax@11
  int v6; // ebp@16
  unsigned int v8; // [sp+Ch] [bp-9Ch]@1
  char v9; // [sp+10h] [bp-98h]@16
  int v10; // [sp+1Ah] [bp-8Eh]@16
  char v11; // [sp+20h] [bp-88h]@14

  v8 = 0;
  switch ( (unsigned __int16)a1 / 0x3E8u )
  {
    case 0xCu:
    case 0xEu:
      memset(word_10228C28, 0, 0x3E84u);
      v2 = 0;
      do
      {
        word_10228C28[v2] = -1;
        word_10228CC4[v2] = -1;
        v2 += 80;
      }
      while ( v2 < 8000 );
      memcpy(a2, word_10228C28, 0x3E84u);
      break;
    case 0x17u:
      memset(word_10228C28, 0, 0x3E84u);
      v3 = 0;
      do
      {
        word_10228C28[v3] = -2;
        word_10228CC4[v3] = -1;
        v3 += 80;
      }
      while ( v3 < 8000 );
      memcpy(a2, word_10228C28, 0x3E84u);
      v8 = sub_1004E2C0((unsigned int *)"\aAHRS1 TAS", 64740, 0xFFFFFFFF);
      sub_1004E8F0(6948, (int)&v8, 4);
      break;
    case 0x15u:
    case 0x16u:
    case 0x18u:
      memset(word_10226CE8, 0, 0x1F40u);
      v4 = 0;
      do
      {
        byte_10226CEE[v4 * 2] = 18;
        word_10226CE8[v4] = -1;
        word_10226CEA[v4] = -1;
        word_10226CEC[v4] = -1;
        v4 += 4;
      }
      while ( v4 < 4000 );
      memcpy(a2, word_10226CE8, 0x1F40u);
      break;
    case 0xDu:
    case 0xFu:
    case 0x19u:
      memset(byte_102252C8, 0, 0x1900u);
      v5 = 0;
      do
      {
        byte_102252C8[v5 * 2] = 0;
        word_102252CA[v5] = -1;
        v5 += 32;
      }
      while ( v5 < 3200 );
      memcpy(a2, byte_102252C8, 0x1900u);
      break;
    case 0x24u:
      memset(&v11, 0, 0x84u);
      sub_10034670(&v11, 2);
      qmemcpy(a2, &v11, 0x84u);
      break;
    case 0x12u:
      memset(&unk_10226BC8, 0, 0x11Cu);
      memset(&unk_10226C04, 255, 0xC8u);
      dword_10226BE8 = 0;
      byte_10226BF2 = 0;
      qmemcpy(a2, &unk_10226BC8, 0x11Cu);
      break;
    default:
      j_reg_get_tag_hdr(&v9, a1, a1);
      v6 = v10;
      memset(&unk_1021FAC8, 0, (unsigned __int16)v10);
      if ( !sub_1004E770(a1, (int)&unk_1021FAC8, v6) )
        memcpy(a2, &unk_1021FAC8, (unsigned __int16)v10);
      break;
  }
  return 0;
}
// 1004E790: using guessed type int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD);
// 102252CA: using guessed type __int16 word_102252CA[];
// 10226BE8: using guessed type int dword_10226BE8;
// 10226BF2: using guessed type char byte_10226BF2;
// 10226CE8: using guessed type __int16 word_10226CE8[];
// 10226CEA: using guessed type __int16 word_10226CEA[];
// 10226CEC: using guessed type __int16 word_10226CEC[];
// 10228C28: using guessed type __int16 word_10228C28[];
// 10228CC4: using guessed type __int16 word_10228CC4[];

//----- (100502D0) --------------------------------------------------------
int __cdecl sub_100502D0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050AC2: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (10050320) --------------------------------------------------------
int __cdecl sub_10050320(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 100508D6: using guessed type int SYS_exit_krnl(void);
// 100508DC: using guessed type int SYS_enter_krnl(void);
// 10050AC8: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (10050390) --------------------------------------------------------
bool sub_10050390()
{
  unsigned int v0; // eax@1

  v0 = j_HWM_pvg_read_reg(0);
  return v0 >= 0x17 && (v0 <= 0x18 || v0 == 40);
}
// 1004ED00: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (100503B0) --------------------------------------------------------
void __cdecl sub_100503B0(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_1001A030(v2) && sub_1001A0B0(v3) != 1 )
    *a2 = 0;
}

//----- (100503E0) --------------------------------------------------------
unsigned int __cdecl sub_100503E0(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_1022CB38[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_1022CAF0[a1];
  dword_1022CAF0[a1] = a3 + v9;
  dword_1022CAB0[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_1022CAB0[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 1022CAF0: using guessed type int dword_1022CAF0[];
// 1022CB38: using guessed type int dword_1022CB38[];

//----- (10050590) --------------------------------------------------------
int __usercall sub_10050590@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_1022CB38[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_1022CB38[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 1022CB38: using guessed type int dword_1022CB38[];

//----- (10050640) --------------------------------------------------------
int __cdecl sub_10050640(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_10050590(a1);
  v3 = &dword_1022CB38[a1];
  v4 = sub_1004F060(
         *(_DWORD *)dword_1022CB38[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_1022CB38[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_1022CAF0[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 1022CAF0: using guessed type int dword_1022CAF0[];
// 1022CB38: using guessed type int dword_1022CB38[];

//----- (100506F0) --------------------------------------------------------
int __usercall sub_100506F0@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_1022CB38[a1];
  v3 = (int *)(dword_1022CAF0[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_1022CB38[a1] + 32)) % *(_WORD *)(dword_1022CB38[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_10050640(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 1022CAF0: using guessed type int dword_1022CAF0[];
// 1022CB38: using guessed type int dword_1022CB38[];

//----- (10050780) --------------------------------------------------------
unsigned int __cdecl sub_10050780(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  unsigned int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_1022CB30 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_1022CB38[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_1022CB30 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_1004E560(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_1022CB38[v6] + 28);
        v12 = sub_100506F0(v6, (unsigned int)v7 & *(_DWORD *)(dword_1022CB38[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_1022CB38[v6] + 4) != 138 )
        sub_1004E540(*(_DWORD *)(dword_1022CB38[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_1022CB38[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_1004E540(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 1022CB30: using guessed type int dword_1022CB30;
// 1022CB38: using guessed type int dword_1022CB38[];

//----- (10052ABC) --------------------------------------------------------
int __cdecl sub_10052ABC(int a1, int a2, char a3)
{
  return vscan_fn(sub_1005976A, a2, 0, &a3);
}
// 10052A54: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10053EB2) --------------------------------------------------------
int __cdecl sub_10053EB2(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_1005C863() + 8 && (void **)v2 != sub_1005C863() + 16 || !sub_1005C805((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_10111280;
      else
        v9 = (_BYTE *)(dword_102378C0[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_1005C6E5((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_1005C6E5((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 1005C7C1: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 102378C0: using guessed type int dword_102378C0[];

//----- (10054A47) --------------------------------------------------------
int __cdecl sub_10054A47(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1022CED4 = a1;
  return result;
}
// 1022CED4: using guessed type int dword_1022CED4;

//----- (10054C1A) --------------------------------------------------------
signed int __cdecl sub_10054C1A(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_1022CEDC )
  {
    *a1 = dword_1022CEDC;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 10054B4D: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1022CEDC: using guessed type int dword_1022CEDC;

//----- (10054C51) --------------------------------------------------------
signed int __cdecl sub_10054C51(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_1022CEDC )
  {
    *a1 = dword_1022CEE8;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 10054B4D: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1022CEDC: using guessed type int dword_1022CEDC;
// 1022CEE8: using guessed type int dword_1022CEE8;

//----- (10055897) --------------------------------------------------------
void sub_10055897()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_102378C0;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_102379C0 );
}
// 102378C0: using guessed type int dword_102378C0[];
// 102379C0: using guessed type int dword_102379C0;

//----- (10055D44) --------------------------------------------------------
int (*sub_10055D44())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_1010F2F0;
  v1 = (int (**)(void))&unk_1010F2F0;
  if ( &unk_1010F2F0 < &unk_1010F2F0 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_1010F2F0 );
  }
  return result;
}

//----- (10055D68) --------------------------------------------------------
void __cdecl sub_10055D68()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_1010F2F8;
  if ( &unk_1010F2F8 < &unk_1010F2F8 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_1010F2F8 );
  }
}

//----- (1005976A) --------------------------------------------------------
int __cdecl sub_1005976A(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
  {
    v7 = &unk_10111280;
  }
  else
  {
    v6 = &dword_102378C0[_fileno(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno(a1) == -1 || _fileno(a1) == -2 ? (v9 = &unk_10111280) : (v8 = &dword_102378C0[_fileno(a1) >> 5],
                                                                         v9 = (_BYTE *)(*v8 + ((_fileno(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_1005F8E6(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_1005F8E6(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_1005F8E6(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_1005F8E6(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_1005F8E6(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_1011125C[0]);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_1005F8E6(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_1005F8E6(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_1005F8E6(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_1005F8E6(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 10054B4D: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10054F50: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1005972F: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 10059745: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 1011125C: using guessed type int (*off_1011125C[3])();
// 102378C0: using guessed type int dword_102378C0[];
// 1005976A: using guessed type char var_24[11];

//----- (1005A9F4) --------------------------------------------------------
#error "1005A9F9: positive sp value has been found (funcsize=0)"

//----- (1005A9FF) --------------------------------------------------------
#error "1005AA04: positive sp value has been found (funcsize=0)"

//----- (1005AA0A) --------------------------------------------------------
#error "1005AA0F: positive sp value has been found (funcsize=0)"

//----- (1005AA10) --------------------------------------------------------
#error "1005AA15: positive sp value has been found (funcsize=0)"

//----- (1005AA16) --------------------------------------------------------
#error "1005AA1B: positive sp value has been found (funcsize=0)"

//----- (1005AA1C) --------------------------------------------------------
#error "1005AA21: positive sp value has been found (funcsize=0)"

//----- (1005AA22) --------------------------------------------------------
#error "1005AA3D: positive sp value has been found (funcsize=0)"

//----- (1005AA43) --------------------------------------------------------
#error "1005AA58: positive sp value has been found (funcsize=0)"

//----- (1005AA5E) --------------------------------------------------------
#error "1005AA79: positive sp value has been found (funcsize=0)"

//----- (1005AA7A) --------------------------------------------------------
#error "1005AA89: positive sp value has been found (funcsize=0)"

//----- (1005AA8A) --------------------------------------------------------
#error "1005AA9D: positive sp value has been found (funcsize=0)"

//----- (1005AA9E) --------------------------------------------------------
#error "1005AAAD: positive sp value has been found (funcsize=0)"

//----- (1005AAAE) --------------------------------------------------------
#error "1005AACD: positive sp value has been found (funcsize=0)"

//----- (1005AAD3) --------------------------------------------------------
#error "1005AAEC: positive sp value has been found (funcsize=0)"

//----- (1005AAF2) --------------------------------------------------------
#error "1005AB11: positive sp value has been found (funcsize=0)"

//----- (1005AB12) --------------------------------------------------------
#error "1005AB25: positive sp value has been found (funcsize=0)"

//----- (1005AB26) --------------------------------------------------------
#error "1005AB3D: positive sp value has been found (funcsize=0)"

//----- (1005AB3E) --------------------------------------------------------
#error "1005AB51: positive sp value has been found (funcsize=0)"

//----- (1005AB52) --------------------------------------------------------
#error "1005AB71: positive sp value has been found (funcsize=0)"

//----- (1005AB77) --------------------------------------------------------
#error "1005AB90: positive sp value has been found (funcsize=0)"

//----- (1005AB96) --------------------------------------------------------
#error "1005ABB5: positive sp value has been found (funcsize=0)"

//----- (1005ABB6) --------------------------------------------------------
#error "1005ABC9: positive sp value has been found (funcsize=0)"

//----- (1005ABCA) --------------------------------------------------------
#error "1005ABE1: positive sp value has been found (funcsize=0)"

//----- (1005ABE2) --------------------------------------------------------
#error "1005ABF5: positive sp value has been found (funcsize=0)"

//----- (1005ABF6) --------------------------------------------------------
#error "1005AC15: positive sp value has been found (funcsize=0)"

//----- (1005AC1B) --------------------------------------------------------
#error "1005AC34: positive sp value has been found (funcsize=0)"

//----- (1005AC3A) --------------------------------------------------------
#error "1005AC59: positive sp value has been found (funcsize=0)"

//----- (1005AC5A) --------------------------------------------------------
#error "1005AC6D: positive sp value has been found (funcsize=0)"

//----- (1005AC6E) --------------------------------------------------------
#error "1005AC85: positive sp value has been found (funcsize=0)"

//----- (1005AC86) --------------------------------------------------------
#error "1005AC99: positive sp value has been found (funcsize=0)"

//----- (1005AC9A) --------------------------------------------------------
#error "1005ACB9: positive sp value has been found (funcsize=0)"

//----- (1005ACBF) --------------------------------------------------------
#error "1005ACD8: positive sp value has been found (funcsize=0)"

//----- (1005ACDE) --------------------------------------------------------
#error "1005ACFD: positive sp value has been found (funcsize=0)"

//----- (1005ACFE) --------------------------------------------------------
#error "1005AD11: positive sp value has been found (funcsize=0)"

//----- (1005AD12) --------------------------------------------------------
#error "1005AD29: positive sp value has been found (funcsize=0)"

//----- (1005AD2A) --------------------------------------------------------
#error "1005AD3D: positive sp value has been found (funcsize=0)"

//----- (1005AD3E) --------------------------------------------------------
#error "1005AD5D: positive sp value has been found (funcsize=0)"

//----- (1005AD63) --------------------------------------------------------
#error "1005AD7C: positive sp value has been found (funcsize=0)"

//----- (1005AD82) --------------------------------------------------------
#error "1005ADA1: positive sp value has been found (funcsize=0)"

//----- (1005ADA2) --------------------------------------------------------
#error "1005ADB5: positive sp value has been found (funcsize=0)"

//----- (1005ADB6) --------------------------------------------------------
#error "1005ADCD: positive sp value has been found (funcsize=0)"

//----- (1005ADCE) --------------------------------------------------------
#error "1005ADE1: positive sp value has been found (funcsize=0)"

//----- (1005ADE2) --------------------------------------------------------
#error "1005AE01: positive sp value has been found (funcsize=0)"

//----- (1005AE07) --------------------------------------------------------
#error "1005AE20: positive sp value has been found (funcsize=0)"

//----- (1005AE26) --------------------------------------------------------
#error "1005AE45: positive sp value has been found (funcsize=0)"

//----- (1005AE46) --------------------------------------------------------
#error "1005AE59: positive sp value has been found (funcsize=0)"

//----- (1005AE5A) --------------------------------------------------------
#error "1005AE71: positive sp value has been found (funcsize=0)"

//----- (1005AE72) --------------------------------------------------------
#error "1005AE85: positive sp value has been found (funcsize=0)"

//----- (1005B94C) --------------------------------------------------------
int __cdecl sub_1005B94C(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1005FB2E((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 100605B2: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1005B9F2) --------------------------------------------------------
int __cdecl sub_1005B9F2(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_10060070((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 100605B2: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1005BE62) --------------------------------------------------------
void sub_1005BE62()
{
  dword_102378A4 = 0;
}
// 102378A4: using guessed type int dword_102378A4;

//----- (1005BF1A) --------------------------------------------------------
int sub_1005BF1A()
{
  dword_102379D8 = _get_sse2_info();
  return 0;
}
// 1005BEBA: using guessed type int _get_sse2_info(void);
// 102379D8: using guessed type int dword_102379D8;

//----- (1005BF27) --------------------------------------------------------
DWORD __cdecl sub_1005BF27(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_100619EA(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_102378C0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 10052FAB: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 102378C0: using guessed type int dword_102378C0[];

//----- (1005C0C3) --------------------------------------------------------
_WORD *__cdecl sub_1005C0C3(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  CHAR v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_102378C0[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_102378C0[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_1005BF27(a1, 0, 0, 2u);
  if ( sub_1005C805(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 10052FAB: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 10054B4D: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1005516C: using guessed type int _getptd(void);
// 102378C0: using guessed type int dword_102378C0[];
// 1005C0C3: using guessed type CHAR var_410[688];

//----- (1005C6E5) --------------------------------------------------------
_WORD *__cdecl sub_1005C6E5(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_102378C0[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_1005C0C3(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_10061AFB(a1);
  return v6;
}
// 10054B4D: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10061A5B: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 102378C0: using guessed type int dword_102378C0[];

//----- (1005C805) --------------------------------------------------------
int __cdecl sub_1005C805(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_102378C0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 10054B4D: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 102378C0: using guessed type int dword_102378C0[];

//----- (1005C863) --------------------------------------------------------
void **sub_1005C863()
{
  return &off_10111CD0;
}
// 10111CD0: using guessed type void *off_10111CD0;

//----- (1005C869) --------------------------------------------------------
signed int sub_1005C869()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_102378A0;
  if ( !dword_102378A0 )
  {
    v0 = 512;
LABEL_5:
    dword_102378A0 = v0;
    goto LABEL_6;
  }
  if ( dword_102378A0 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_10236880 = v1;
  if ( v1 || (dword_102378A0 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_10236880 = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_10111CD0;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&dword_10111F50 )
        break;
      v1 = dword_10236880;
    }
    v5 = 0;
    v6 = &unk_10111CE0;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_102378C0[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_10111D40 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 10055560: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 10111CD0: using guessed type void *off_10111CD0;
// 10111F50: using guessed type int dword_10111F50;
// 102378A0: using guessed type int dword_102378A0;
// 102378C0: using guessed type int dword_102378C0[];

//----- (1005D152) --------------------------------------------------------
int sub_1005D152()
{
  return _decode_pointer(dword_1022D510);
}
// 10054F50: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1022D510: using guessed type int dword_1022D510;

//----- (1005D30F) --------------------------------------------------------
int __cdecl sub_1005D30F(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1022D51C = a1;
  return result;
}
// 1022D51C: using guessed type int dword_1022D51C;

//----- (1005D319) --------------------------------------------------------
int __cdecl sub_1005D319(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1022D528 = a1;
  return result;
}
// 1022D528: using guessed type int dword_1022D528;

//----- (1005D323) --------------------------------------------------------
int __cdecl sub_1005D323(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1022D52C = a1;
  return result;
}
// 1022D52C: using guessed type int dword_1022D52C;

//----- (1005D402) --------------------------------------------------------
int __cdecl sub_1005D402(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1022D530 = a1;
  return result;
}
// 1022D530: using guessed type int dword_1022D530;

//----- (1005ED0C) --------------------------------------------------------
int sub_1005ED0C()
{
  return 0;
}

//----- (1005F7C6) --------------------------------------------------------
int __cdecl sub_1005F7C6(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
    {
      v8 = &unk_10111280;
    }
    else
    {
      v7 = &dword_102378C0[_fileno(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 10054B4D: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1005C7C1: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 102378C0: using guessed type int dword_102378C0[];

//----- (1005F8E6) --------------------------------------------------------
int __cdecl sub_1005F8E6(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno(a2) == -1 || _fileno(a2) == -2 )
    {
      v3 = &unk_10111280;
    }
    else
    {
      v2 = &dword_102378C0[_fileno(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno(a2) == -1 || _fileno(a2) == -2 ? (v5 = &unk_10111280) : (v4 = &dword_102378C0[_fileno(a2) >> 5],
                                                                           v5 = (_BYTE *)(*v4
                                                                                        + ((_fileno(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 10054B4D: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1005C7C1: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 102378C0: using guessed type int dword_102378C0[];

//----- (1005FB2E) --------------------------------------------------------
signed int __cdecl sub_1005FB2E(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_1011225C - 1;
    v64 = v3;
    v65 = dword_1011225C / 32;
    v9 = dword_1011225C % 32;
    v10 = (int *)(&v60 + dword_1011225C / 32);
    v66 = 31 - dword_1011225C % 32;
    if ( (1 << (31 - dword_1011225C % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_10112258 - dword_1011225C )
    {
      if ( v3 > dword_10112258 )
      {
        if ( v3 < dword_10112254 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_10112268 + v3;
          v50 = dword_10112260 / 32;
          v51 = dword_10112260 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_10112260 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_10112260 / 32;
          v44 = dword_10112260 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_10112260 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_10112268 + dword_10112254;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_10112258 - v64) / 32;
      v62 = v59;
      v18 = (dword_10112258 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_1011225C - 1;
      v25 = dword_1011225C / 32;
      v65 = dword_1011225C / 32;
      v26 = (int *)(&v60 + dword_1011225C / 32);
      v64 = 31 - dword_1011225C % 32;
      if ( (1 << (31 - dword_1011225C % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_1011225C % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_10112260 + 1) / 32;
      v37 = (dword_10112260 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_10112260));
  if ( dword_10112264 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_10112264 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 10112254: using guessed type int dword_10112254;
// 10112258: using guessed type int dword_10112258;
// 1011225C: using guessed type int dword_1011225C;
// 10112260: using guessed type int dword_10112260;
// 10112264: using guessed type int dword_10112264;
// 10112268: using guessed type int dword_10112268;

//----- (10060070) --------------------------------------------------------
signed int __cdecl sub_10060070(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_10112274 - 1;
    v64 = v3;
    v65 = dword_10112274 / 32;
    v9 = dword_10112274 % 32;
    v10 = (int *)(&v60 + dword_10112274 / 32);
    v66 = 31 - dword_10112274 % 32;
    if ( (1 << (31 - dword_10112274 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_10112270 - dword_10112274 )
    {
      if ( v3 > dword_10112270 )
      {
        if ( v3 < dword_1011226C )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_10112280 + v3;
          v50 = dword_10112278 / 32;
          v51 = dword_10112278 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_10112278 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_10112278 / 32;
          v44 = dword_10112278 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_10112278 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_10112280 + dword_1011226C;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_10112270 - v64) / 32;
      v62 = v59;
      v18 = (dword_10112270 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_10112274 - 1;
      v25 = dword_10112274 / 32;
      v65 = dword_10112274 / 32;
      v26 = (int *)(&v60 + dword_10112274 / 32);
      v64 = 31 - dword_10112274 % 32;
      if ( (1 << (31 - dword_10112274 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_10112274 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_10112278 + 1) / 32;
      v37 = (dword_10112278 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_10112278));
  if ( dword_1011227C == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_1011227C == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 1011226C: using guessed type int dword_1011226C;
// 10112270: using guessed type int dword_10112270;
// 10112274: using guessed type int dword_10112274;
// 10112278: using guessed type int dword_10112278;
// 1011227C: using guessed type int dword_1011227C;
// 10112280: using guessed type int dword_10112280;

//----- (10061969) --------------------------------------------------------
signed int __cdecl sub_10061969(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_102378C0[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_1022CBA8 == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 1022CBA8: using guessed type int dword_1022CBA8;
// 102378C0: using guessed type int dword_102378C0[];

//----- (100619EA) --------------------------------------------------------
signed int __cdecl sub_100619EA(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_102378C0[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 10054B4D: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 102378C0: using guessed type int dword_102378C0[];

//----- (10061AFB) --------------------------------------------------------
void __cdecl sub_10061AFB(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_102378C0[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 102378C0: using guessed type int dword_102378C0[];

//----- (10061DFC) --------------------------------------------------------
int sub_10061DFC()
{
  return flsall(1);
}
// 10061D22: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (10061E05) --------------------------------------------------------
int __cdecl sub_10061E05(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_1022D54C )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_1022D54C = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_1022D550 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_1022D554 = _encode_pointer(v7);
    if ( sub_10054C1A(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_1022D55C = _encode_pointer(v8);
      if ( dword_1022D55C )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_1022D558 = _encode_pointer(v9);
      }
    }
  }
  if ( dword_1022D558 == v23
    || dword_1022D55C == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_1022D558),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_1022D55C),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_1022D550 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_1022D550);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_1022D554 != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_1022D554);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_10054C51(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_1022D54C);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 10054A51: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10054ED9: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 10054F47: using guessed type int _encoded_null(void);
// 10054F50: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1022D54C: using guessed type int dword_1022D54C;
// 1022D550: using guessed type int dword_1022D550;
// 1022D554: using guessed type int dword_1022D554;
// 1022D558: using guessed type int dword_1022D558;
// 1022D55C: using guessed type int dword_1022D55C;

//----- (10062DE1) --------------------------------------------------------
signed int __cdecl sub_10062DE1(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_100619EA(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_102378C0[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_102378C0[0] + 68) & 1)
    && (v1 = sub_100619EA(2), sub_100619EA(1) == v1)
    || (v2 = (void *)sub_100619EA(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_10061969(a1);
  *(_BYTE *)(dword_102378C0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10052FAB: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 102378C0: using guessed type int dword_102378C0[];

#error "There were 50 decompilation failure(s) on 1628 function(s)"
