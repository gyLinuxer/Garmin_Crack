/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// int __usercall sub_10001000@<eax>(int result@<eax>, int a2@<ecx>);
int __cdecl sub_10001020(int a1, int a2, int a3);
char __thiscall sub_10001070(int this);
char __cdecl sub_100010E0(char a1, int a2);
int __cdecl sub_10001160(int a1, unsigned int a2);
int __cdecl sub_100011A0(_BYTE *a1);
char sub_10001240();
char __cdecl sub_100012C0(int a1, unsigned int a2, int a3);
// int __usercall sub_10001390@<eax>(int a1@<eax>);
// unsigned int __usercall sub_100013E0@<eax>(unsigned int a1@<esi>, _DWORD *a2);
// int __usercall sub_10001400@<eax>(char a1@<al>, int a2@<esi>);
// int __usercall sub_10001440@<eax>(int a1@<esi>, int a2, int a3);
// unsigned int __usercall sub_10001470@<eax>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_10001480@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>);
// int __usercall sub_10001520@<eax>(unsigned __int8 a1@<al>, unsigned int a2@<ecx>, int a3@<edi>, int a4);
// char __usercall sub_10001680@<al>(int a1@<eax>, unsigned int a2@<esi>);
_BYTE *__cdecl sub_100016C0(char *a1);
// int __usercall sub_10001740@<eax>(_BYTE *a1@<eax>);
int __cdecl sub_10001780(int a1);
int __cdecl sub_100017A0(int, void *, size_t); // idb
int __cdecl sub_100018D0(int a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_10001930(int a1);
int __cdecl sub_10001960(int *a1);
bool __cdecl sub_10001980(char a1);
void __cdecl sub_10001990(int a1, int a2);
int __cdecl sub_100019B0(int a1, int a2);
int __cdecl sub_100019E0(int a1, unsigned int a2);
int __cdecl sub_10001A90(int a1);
int __cdecl sub_10001AA0(int a1);
// void *__usercall sub_10001AD0@<eax>(int a1@<esi>);
// int __usercall sub_10001AF0@<eax>(int a1@<eax>, int a2@<edi>);
int __cdecl sub_10001B20(int a1, unsigned int a2);
void *__cdecl sub_10001B90(char a1);
char __cdecl sub_10001BD0(int a1);
_DWORD *__cdecl sub_10001C40(int a1);
_BYTE *sub_10001C80();
// int __usercall sub_10001CE0@<eax>(int a1@<eax>, _BYTE *a2@<ecx>);
int __cdecl sub_10001D20(int a1, unsigned int a2);
void *__cdecl sub_10001D40(int a1);
void *__cdecl sub_10001DA0(int a1);
bool __cdecl sub_10001E00(int a1);
bool __cdecl sub_10001E40(int a1);
bool __cdecl sub_10001EA0(char a1);
bool __cdecl sub_10001EC0(_DWORD *a1);
bool __cdecl sub_10001EE0(int a1);
int __cdecl sub_10001F00(int a1);
bool __cdecl sub_10001F40(int a1);
// bool __usercall sub_10001F60@<al>(int a1@<eax>);
// bool __usercall sub_10001F80@<al>(int a1@<eax>);
char __cdecl sub_10001FA0(int a1);
// bool __usercall sub_10001FF0@<al>(int a1@<eax>);
bool __thiscall sub_10002070(void *this);
// char __usercall sub_100020B0@<al>(int a1@<eax>);
bool __cdecl sub_100020F0(char a1);
// _BYTE **__usercall sub_10002150@<eax>(_BYTE **result@<eax>, signed int a2@<edx>, size_t a3@<ebx>, char *a4@<edi>, _DWORD *a5);
// unsigned int __usercall sub_100022B0@<eax>(const char *a1@<esi>);
char __cdecl sub_10002300(int a1);
char __cdecl sub_100026C0(int a1);
bool __cdecl sub_10002770(int a1, int a2);
// int __usercall sub_10002790@<eax>(int result@<eax>, int a2@<esi>);
int __cdecl sub_10002840(int a1, int a2);
char __cdecl sub_10002870(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
char __cdecl sub_100029B0(int a1, int a2);
_DWORD *__cdecl sub_10002B90(int a1, char *a2, int a3, _DWORD *a4);
char __cdecl sub_10002C10(int a1, _WORD *a2, char **a3, int a4, int a5, int a6);
bool __cdecl sub_10002D30(int a1, _WORD *a2, char *a3, int a4, int a5, int a6);
int __cdecl sub_10002E30(unsigned int a1);
int *__cdecl sub_10002E60(unsigned int a1);
int __cdecl sub_10002E80(unsigned int a1);
signed int __cdecl sub_10002EA0(__int16 a1);
signed int __cdecl sub_10002ED0(int a1);
// int __usercall sub_10002F00@<eax>(_BYTE *a1@<eax>);
// char __usercall sub_10002F30@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3);
// char __usercall sub_10002F80@<al>(size_t a1@<edx>, signed int a2@<ecx>, int a3@<esi>, const char *a4, int *a5, char a6, char a7);
__int16 __cdecl sub_10003480(_BYTE *a1, unsigned int a2);
int __cdecl sub_100034E0(unsigned int a1, unsigned int a2, float *a3);
int sub_10003510();
char __cdecl sub_100035B0(int a1, const char *a2, int *a3);
int __cdecl sub_100035F0(unsigned int a1, char a2);
char __cdecl sub_10003650(int a1, const char *a2, int *a3, int a4);
int __cdecl sub_10003860(int a1, int a2, unsigned int a3, int a4);
__int16 __cdecl sub_10003930(char *a1, int a2, int a3, int a4, int a5);
char __cdecl sub_100039C0(int a1, char *a2, const char *a3, __int16 a4, __int16 a5, unsigned int a6, __int16 a7);
int sub_10003BE0(void); // weak
unsigned int sub_10003BF0();
int __cdecl sub_10003CE0(int a1, int a2);
int __cdecl sub_10003D00(int a1);
_DWORD *sub_10003D30();
int __cdecl sub_10003D50(int a1, char *a2, int a3, int a4);
char __cdecl sub_10003DE0(int a1, int a2, int a3);
char __cdecl sub_10003E50(int a1, int a2, int a3);
int sub_10003EC0();
_DWORD *__cdecl sub_10003EE0(int a1);
unsigned int __cdecl sub_10003F00(int a1, int a2, int a3);
// void __usercall sub_10003F70(int a1@<esi>);
// int __usercall sub_10003FD0@<eax>(int a1@<esi>);
// void __usercall sub_100040B0(int a1@<esi>, int a2);
// void __usercall sub_10004180(int a1@<esi>, int a2);
// int __usercall sub_10004220@<eax>(int a1@<edi>, int a2);
char __thiscall sub_100043F0(int this);
signed int __cdecl sub_10004410(int a1, int a2);
char __cdecl sub_10004560(int a1, int a2, __int16 a3);
char __cdecl sub_10004590(int a1, int a2, __int16 a3);
void __cdecl sub_100045C0(int a1);
// int __usercall sub_100048F0@<eax>(int a1@<eax>);
void __noreturn sub_10004980();
int __cdecl sub_10004BD0(int a1, int a2);
char __cdecl sub_10004BF0(int a1, unsigned int a2);
char sub_10004C30();
char __thiscall sub_10004C50(int this);
// void *__usercall sub_10004DC0@<eax>(unsigned int a1@<ecx>, int a2@<ebx>);
char __cdecl sub_10004F70(int a1);
int __cdecl sub_10004F90(int a1, int a2);
int __cdecl sub_10005010(int a1, __int16 a2, __int16 a3);
char __cdecl sub_10005030(unsigned __int8 a1);
__int16 __cdecl sub_10005050(unsigned __int8 a1);
char __cdecl sub_10005070(int (__cdecl *a1)(int));
char __cdecl sub_100050B0(int (__cdecl *a1)(int));
char __cdecl sub_100050D0(int a1, __int16 *a2, _BYTE *a3);
char __cdecl sub_10005150(int a1);
char __thiscall sub_100052B0(void *this);
bool __cdecl sub_100052E0(unsigned int a1, char a2);
bool __cdecl sub_100053F0(unsigned int a1, char a2);
_WORD *__cdecl sub_10005520(int a1);
// void __usercall sub_10005590(_BYTE *a1@<edx>, unsigned int a2@<ecx>, unsigned int a3@<ebx>, _BYTE *a4);
int __cdecl sub_10005690(unsigned __int16 **a1, unsigned __int16 **a2);
char __cdecl sub_100056E0(unsigned int a1, unsigned int a2);
char __cdecl sub_10005730(unsigned int a1, unsigned int a2);
// char __usercall sub_10005780@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>);
// char __usercall sub_100057E0@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>);
// char __usercall sub_10005990@<al>(int a1@<eax>, signed int a2@<edi>, int a3@<esi>);
// int __usercall sub_10005A50@<eax>(char *a1@<ebx>, int a2, int a3, char a4, size_t a5);
// int __usercall sub_10005BE0@<eax>(const char *a1@<esi>, int a2);
// int __usercall sub_10005C50@<eax>(_BYTE a1@<dl>, int a2, int a3);
char __cdecl sub_10005CA0(int a1, int a2, __int16 a3);
// signed int __usercall sub_10005CF0@<eax>(int a1@<edi>);
int __cdecl sub_10005D60(int a1);
int __cdecl sub_10005DB0(int a1);
unsigned int __cdecl sub_10007470(int a1);
// char __usercall sub_10007710@<al>(int a1@<esi>);
char __cdecl sub_10007840(int a1, int a2, __int16 a3);
char __cdecl sub_10007860(int a1, int a2, __int16 a3);
char __thiscall sub_10007880(int this);
// char __usercall sub_10007E50@<al>(int a1@<esi>);
char __thiscall sub_10007F80(unsigned int this);
char __cdecl sub_100082C0(int a1);
unsigned __int8 __cdecl sub_100083A0(int a1);
// char __usercall sub_10008650@<al>(int a1@<edi>);
// char __usercall sub_10008B00@<al>(int a1@<esi>);
// char __usercall sub_10008B20@<al>(int a1@<esi>);
bool __thiscall sub_10008CB0(int this);
char __cdecl sub_100092C0(int a1);
// int __usercall sub_100093A0@<eax>(__int16 a1@<ax>, int a2@<esi>, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7);
// int __usercall sub_10009430@<eax>(__int16 a1@<ax>, __int16 a2@<cx>, int a3@<esi>, __int16 a4);
double __cdecl sub_100094B0(char, char); // weak
int __cdecl sub_10009560(int a1);
char __cdecl sub_10009EC0(int a1, _BYTE *a2, _BYTE *a3, char a4);
// void __usercall sub_1000A600(int a1@<esi>);
// char __usercall sub_1000A6B0@<al>(int a1@<edi>);
// char __usercall sub_1000AA50@<al>(int a1@<eax>);
// int __usercall sub_1000ABE0@<eax>(int a1@<eax>);
char __cdecl sub_1000AF30(int a1);
// void *__usercall sub_1000B680@<eax>(int a1@<eax>);
int __cdecl sub_1000B8B0(int a1);
// int __usercall sub_1000BA80@<eax>(int a1@<eax>);
// int __usercall sub_1000BCA0@<eax>(int a1@<eax>);
// int __usercall sub_1000CB70@<eax>(int a1@<edi>);
// char __usercall sub_1000CBB0@<al>(int a1@<edi>);
char __cdecl sub_1000CC90(int a1);
// char __usercall sub_1000D750@<al>(unsigned int a1@<eax>);
// void __usercall sub_1000D880(unsigned int a1@<esi>);
// bool __usercall sub_1000D930@<al>(unsigned int a1@<esi>);
// char __usercall sub_1000E000@<al>(unsigned int a1@<edi>);
void __cdecl sub_1000E610(unsigned int a1);
// int __usercall sub_1000E750@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3@<esi>, __int16 a4);
// int __usercall sub_1000E7B0@<eax>(unsigned __int8 a1@<al>, int a2, int a3, int a4, _WORD *a5, _WORD *a6, _WORD *a7, _BYTE *a8, char a9);
// int __usercall sub_1000E8F0@<eax>(int a1@<eax>, int a2@<edx>, int a3, _WORD *a4, __int16 a5, _WORD *a6, _WORD *a7, _BYTE *a8, _BYTE *a9, char a10);
// int __usercall sub_1000EA90@<eax>(int a1@<eax>, int a2@<edx>, unsigned __int16 a3@<cx>, unsigned __int16 a4, __int16 a5);
char __cdecl sub_1000EB10(int a1, int a2, unsigned __int16 a3);
// bool __usercall sub_1000EBD0@<al>(int a1@<esi>);
// void __usercall sub_1000EC20(unsigned int a1@<edi>);
// _WORD *__usercall sub_1000ED70@<eax>(unsigned __int8 *a1@<ebx>, int a2@<esi>, _WORD *a3, _WORD *a4, _WORD *a5, _WORD *a6, _WORD *a7, __int16 a8, _WORD *a9, char a10, char a11);
// int __usercall sub_1000EE50@<eax>(int a1@<eax>);
// signed int __usercall sub_1000EF00@<eax>(int a1@<ebx>);
void __cdecl sub_1000F1E0(int a1);
// int __usercall sub_1000F2D0@<eax>(unsigned __int8 a1@<al>, int a2, int a3, int a4, _WORD *a5, _WORD *a6, _WORD *a7, _BYTE *a8, char a9);
// int __usercall sub_1000F400@<eax>(int a1@<edx>, int a2@<ecx>, int a3, _WORD *a4, __int16 a5, _WORD *a6, _WORD *a7, _BYTE *a8, _BYTE *a9, char a10);
// int __usercall sub_1000F550@<eax>(int a1@<eax>, int a2@<edx>, unsigned __int16 a3@<si>);
char __cdecl sub_1000F5A0(int a1, int a2, unsigned __int16 a3);
// bool __usercall sub_1000F600@<al>(int a1@<esi>);
// void __usercall sub_1000F650(unsigned int a1@<esi>);
// int __usercall sub_1000F760@<eax>(unsigned __int8 *a1@<ebx>, int a2@<esi>, _WORD *a3, _WORD *a4, _WORD *a5, _WORD *a6, _WORD *a7, __int16 a8, _WORD *a9, char a10, char a11, int a12, int a13);
// int __usercall sub_1000F870@<eax>(int a1@<eax>);
// int __usercall sub_1000F950@<eax>(int a1@<eax>);
void __cdecl sub_1000FA30(int a1);
void __cdecl sub_1000FC40(unsigned int a1);
char __cdecl sub_1000FD50(int a1, char a2, __int16 a3, char *a4, float a5, int a6);
// char __usercall sub_1000FDE0@<al>(int a1@<esi>);
// char __usercall sub_1000FE60@<al>(int a1@<esi>);
// char __usercall sub_1000FE90@<al>(int a1@<edi>);
// void __usercall sub_10010060(unsigned int a1@<esi>);
// int __usercall sub_10010100@<eax>(int a1@<esi>);
// void __usercall sub_10010160(unsigned int a1@<esi>);
char __cdecl sub_100101D0(int a1);
// void __usercall sub_10010420(int a1@<eax>);
char __cdecl sub_100104C0(int a1);
// char __usercall sub_10010650@<al>(int a1@<esi>);
// bool __usercall sub_10010720@<al>(int a1@<esi>);
int sub_10010940(); // weak
void __cdecl sub_10010A60(int a1, char a2, __int16 a3, char *a4, float a5, int a6);
// void *__usercall sub_10010AA0@<eax>(void *result@<eax>, char a2@<cl>, int a3@<esi>);
// char __usercall sub_10010B50@<al>(int a1@<eax>, int a2@<edx>, signed int a3@<ecx>);
// bool __usercall sub_10010C50@<al>(int a1@<eax>, int a2@<ebx>, signed int a3@<edi>);
int __fastcall sub_10010CD0(int a1, int a2);
bool __cdecl sub_10010DA0(int a1, int a2, __int16 a3);
char __cdecl sub_10010DC0(int a1);
// void __usercall sub_10011080(unsigned int a1@<esi>);
// int __usercall sub_100111C0@<eax>(int a1@<eax>);
signed int sub_10011240();
int __cdecl sub_10011250(int a1, int a2);
// char __usercall sub_10011880@<al>(int a1@<esi>);
// char __usercall sub_100118D0@<al>(int a1@<edi>);
bool __cdecl sub_10011950(int a1, int a2, __int16 a3);
// void __usercall sub_100119C0(int a1@<ecx>, unsigned int a2@<edi>);
// bool __usercall sub_10011AF0@<al>(int a1@<edi>);
void __cdecl sub_10011F30(unsigned int a1);
// int __usercall sub_10012020@<eax>(int a1@<eax>, __int16 a2@<cx>);
// char __usercall sub_10012070@<al>(int a1@<esi>);
// unsigned __int8 __usercall sub_100120D0@<al>(char a1@<al>);
// int __usercall sub_100120E0@<eax>(int a1@<eax>);
// char __usercall sub_100120F0@<al>(char a1@<al>);
int __cdecl sub_10012100(int a1);
// char __usercall sub_10012180@<al>(int a1@<edi>);
// char __usercall sub_10012450@<al>(int a1@<esi>);
// char __usercall sub_10012660@<al>(int a1@<edi>);
char __cdecl sub_10012860(int a1);
int __cdecl sub_10012920(int a1);
// char __usercall sub_10012940@<al>(int a1@<esi>);
char __cdecl sub_10012980(int a1);
// bool __usercall sub_10012C90@<al>(int a1@<edi>);
char __cdecl sub_10012EF0(int a1);
// int __usercall sub_10012FD0@<eax>(int a1@<eax>);
// int __usercall sub_100133A0@<eax>(int a1@<edi>);
// int __usercall sub_10013C60@<eax>(int a1@<esi>);
// char __usercall sub_10013CC0@<al>(int a1@<esi>);
// char __usercall sub_10013D30@<al>(int a1@<eax>);
// int __usercall sub_100140D0@<eax>(int a1@<eax>);
char __cdecl sub_10014950(int a1);
int sub_10014A40(); // weak
// int __usercall sub_10014A90@<eax>(int a1@<eax>);
// char __usercall sub_10014B70@<al>(int a1@<esi>);
// char __usercall sub_10014BB0@<al>(int a1@<eax>);
// char __usercall sub_10014D70@<al>(int a1@<eax>);
// unsigned __int8 __usercall sub_10014F40@<al>(int a1@<eax>);
char __cdecl sub_10015180(int a1);
// char __usercall sub_10015B90@<al>(int a1@<edi>);
// int __usercall sub_10016210@<eax>(int a1@<esi>);
char __cdecl sub_100162C0(int a1);
void __cdecl sub_100163A0(unsigned int a1, char a2, _BYTE *a3, char a4);
int __cdecl sub_10016490(int a1, int a2, _DWORD *a3);
int sub_10016660(void); // weak
char __cdecl sub_10016670(char a1);
char sub_10016690();
int __cdecl sub_100166A0(int a1, char a2, void (__cdecl *a3)(int, char *, int), int a4);
int __cdecl sub_10016B60(_DWORD *a1, unsigned int a2);
int __cdecl sub_10016BC0(int a1, unsigned int a2);
int __cdecl sub_10016C10(unsigned int a1);
int sub_10016C60();
signed int __cdecl sub_10016CD0(_BYTE *a1);
_DWORD sub_10016E80(); // weak
int __cdecl sub_10016E90(char, void *, size_t, int); // idb
void __cdecl sub_10016F00(int a1);
char __cdecl sub_10016F70(int a1);
void __cdecl sub_10017210(int a1);
unsigned int __cdecl sub_100172B0(int a1);
unsigned int __cdecl sub_100173B0(int a1);
char __cdecl sub_100174F0(int a1);
void __cdecl sub_10017550(int a1);
int __cdecl sub_10017580(int a1, int a2);
int __cdecl sub_10017C00(int a1);
int sub_10017CF0();
int sub_10017E40();
int sub_10017F80();
int __cdecl sub_100181D0(int a1);
int sub_100182E0();
int __cdecl sub_100184B0(int a1);
// int __usercall sub_10018520@<eax>(int a1@<ecx>, int a2@<ebx>, unsigned int a3);
char sub_100186A0();
void __cdecl sub_100186B0(unsigned int a1);
char __cdecl sub_100186E0(int a1, unsigned __int8 a2);
int __cdecl sub_10018700(int a1, unsigned __int8 a2, char a3);
char __cdecl sub_10018750(int a1, unsigned __int8 a2, __int16 a3);
int __cdecl sub_100187A0(int a1, unsigned __int8 a2);
// bool __usercall sub_10018870@<al>(int a1@<eax>, char a2);
// char __usercall sub_100188B0@<al>(int a1@<eax>, int a2@<esi>, char a3);
// char __usercall sub_10018920@<al>(int a1@<eax>, int a2@<ecx>, char a3);
// bool __usercall sub_100189B0@<al>(unsigned __int8 a1@<al>, int a2@<esi>);
void __cdecl sub_10018A30(int a1);
char __cdecl sub_10018B20(int a1, unsigned __int8 a2);
char __cdecl sub_10018B50(int a1, unsigned __int8 a2, char a3);
// int __usercall sub_10018B90@<eax>(int a1@<eax>, char a2@<bl>, int a3);
int __cdecl sub_10018BB0(int a1, char a2);
int __cdecl sub_10018BD0(int a1);
int __cdecl sub_10018E40(int a1, void *a2, unsigned __int8 a3, char a4, unsigned __int8 a5);
char __cdecl sub_10019770(int a1);
int __cdecl nullsub_1(_DWORD, _DWORD);
__int16 __cdecl sub_10019950(char a1);
int *sub_10019990();
char __cdecl sub_100199D0(char a1, int a2, _DWORD *a3);
// int __usercall sub_10019A80@<eax>(_BYTE *a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>);
signed int __cdecl sub_10019AC0(int a1, int a2, _BYTE *a3, int a4);
_DWORD __cdecl sub_10019BD0(_DWORD, _DWORD, _DWORD, _DWORD); // weak
bool __cdecl sub_10019BE0(int a1, char *a2);
int sub_10019CB0();
int __cdecl sub_10019CE0(_DWORD *a1, _DWORD *a2);
int sub_10019D00();
// __int16 __usercall sub_10019D40@<ax>(int a1@<ebx>, int a2@<edi>, __int16 a3);
int __fastcall sub_10019E90(__int16 a1, __int16 *a2);
int __cdecl sub_1001A140(const char *a1, int a2, int a3, char a4);
// unsigned int __usercall sub_1001A3E0@<eax>(int a1@<edi>);
int __cdecl sub_1001A460(unsigned __int16 a1);
int __cdecl sub_1001B310(__int16 a1);
void __fastcall sub_1001B340(char a1);
// int __usercall sub_1001B530@<eax>(char a1@<bl>);
// void __usercall sub_1001B7C0(int a1@<ebx>, int a2);
// void __usercall sub_1001C1E0(int a1@<ecx>, int a2@<ebx>);
_DWORD sub_1001C270(); // weak
int __cdecl sub_1001C300(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
int __cdecl sub_1001C410(int a1, _BYTE *a2, int a3);
char __cdecl sub_1001C450(char a1, char a2);
int __cdecl sub_1001C470(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7);
bool __cdecl sub_1001CCB0(_BYTE *a1);
bool __cdecl sub_1001CD50(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5);
int __cdecl sub_1001CE60(int a1, _BYTE *a2, int a3);
int __cdecl sub_1001CF50(int a1, __int16 a2, __int16 a3, char a4);
unsigned int __cdecl sub_1001D4A0(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
int __cdecl sub_1001D580(int a1);
int __cdecl sub_1001D8D0(int a1);
unsigned int __cdecl sub_1001DAB0(int a1);
int __cdecl sub_1001DFE0(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
_WORD *__cdecl sub_1001E040(int a1);
int __cdecl sub_1001E0A0(int a1, int a2, char a3);
char __cdecl sub_1001E190(int a1, __int16 a2, __int16 a3, __int16 a4, char a5);
int __cdecl sub_1001EC10(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
void sub_1001EE70();
int __cdecl sub_1001EE80(int a1, signed int a2, signed int a3);
int __cdecl sub_1001F350(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
char __cdecl sub_1001F440(int a1);
char __cdecl sub_1001F4F0(int a1);
int __cdecl sub_1001F660(int a1);
char *__cdecl sub_1001F6C0(int a1);
unsigned int __cdecl sub_1001F810(int a1, signed int a2, int a3, int a4);
int __cdecl sub_1001F8D0(int a1, int a2);
unsigned int __cdecl sub_1001F9F0(int a1, int a2);
int __cdecl sub_1001FB90(int a1, int a2, int a3);
int __cdecl sub_1001FC10(int a1, int a2, int a3);
int __cdecl sub_1001FC80(int a1, int a2, int a3);
char __cdecl sub_1001FD00(int a1, signed int a2, int a3, int a4);
int __cdecl sub_1001FE10(int a1, signed int a2, signed int a3);
int __cdecl sub_1001FF00(int a1, signed int a2, int a3, int a4);
int __cdecl sub_10020000(int a1, int a2);
char *__cdecl sub_10020130(int a1, signed int a2, int a3, int *a4);
char *__cdecl sub_10020270(int a1, signed int a2, int a3, int *a4);
int __cdecl sub_100204C0(int a1, signed int a2, int a3);
int __cdecl sub_10020600(int a1, signed int a2, int a3);
int __cdecl sub_10020740(int a1);
char __cdecl sub_10020910(int a1, __int16 a2, __int16 a3, __int16 a4, int a5, __int16 a6, __int16 a7);
char *__cdecl sub_10021A50(int a1, int a2, int a3, int a4);
char __cdecl sub_10021AC0(int a1, int a2);
char *__cdecl sub_10021B10(int a1, int a2);
signed int __cdecl sub_10021B60(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
char __cdecl sub_10021CB0(__int16 a1, __int16 a2);
char *__cdecl sub_10021D50(int a1, int a2);
char *__cdecl sub_10021F00(int a1, int a2);
int __cdecl sub_100220B0(int a1, __int16 a2, __int16 a3, __int16 a4);
int __cdecl sub_10022310(int a1, __int16 a2, __int16 a3);
void *sub_10022370();
int __cdecl sub_100223A0(char, void *, size_t, int); // idb
// int __usercall sub_100223D0@<eax>(int a1@<esi>);
int __cdecl sub_10022410(char, void *, size_t, int, size_t, int, size_t, int, size_t, int, int, int, size_t); // idb
char sub_10022720();
void __cdecl sub_100227E0(int a1, signed int a2, signed int a3);
signed int sub_10022830();
int __cdecl sub_10022970(signed int a1, signed int a2);
double __cdecl sub_100229B0(float a1, float a2);
int __cdecl sub_10022A50(signed int a1, signed int a2);
double __cdecl sub_10022A90(float a1, float a2);
double __cdecl sub_10022B30(float a1, float a2);
double __cdecl sub_10022BB0(float a1);
int __cdecl sub_10022BF0(float); // idb
int __cdecl sub_10022C20(signed int a1, signed int a2);
double __cdecl sub_10022C70(float a1, float a2);
int __cdecl sub_10022CE0(float); // idb
int __cdecl sub_10022D10(int a1, int a2, int a3);
double __cdecl sub_10022D40(int a1, int a2);
double __cdecl sub_10022D70(int a1);
int __cdecl sub_10022DB0(float, int, int); // idb
unsigned __int16 __cdecl sub_10022DE0(_BYTE *a1, int a2, unsigned __int16 a3, char a4);
int __cdecl sub_10022E60(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_10022E80(unsigned int *a1, signed int a2, unsigned int a3);
// int __cdecl TXT_get_hndl(_DWORD); weak
// int __cdecl FNT_get_fnt_hdr(_DWORD); weak
bool __thiscall sub_10022FB0(void *this);
char __cdecl sub_10022FE0(char a1);
// _WORD *__usercall sub_10022FF0@<eax>(_WORD *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, __int16 a5);
// __int16 __usercall sub_10023030@<ax>(int a1@<eax>, _WORD *a2@<ecx>, int a3, int a4);
// int __usercall sub_10023150@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
// __int16 __usercall sub_10023180@<ax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4, int a5, __int16 a6, __int16 a7);
// char __usercall sub_10023210@<al>(__int16 a1@<ax>, int a2@<edx>, int a3, int a4);
// signed int __usercall sub_10023240@<eax>(__int16 a1@<ax>, int a2@<ecx>, int a3@<edi>, char a4, char a5);
// BOOL __usercall sub_100232B0@<eax>(int a1@<eax>, int a2@<ecx>);
// __int16 __usercall sub_100232E0@<ax>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, int a5, int a6, __int16 a7);
// unsigned int __usercall sub_10023550@<eax>(_WORD *a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
__int16 __cdecl sub_100237E0(int a1, int a2, int a3, __int16 a4);
// __int16 __usercall sub_100238E0@<ax>(int a1@<eax>, int a2, int a3, __int16 a4);
char __cdecl sub_10023A00(int a1, int a2, int a3, __int16 a4);
// __int16 __usercall sub_10023AE0@<ax>(__int16 a1@<bx>, int a2@<edi>, int a3@<esi>, int a4);
int __cdecl sub_10023B20(int a1, int a2, int a3, int a4, int a5, int a6, char a7);
char __cdecl sub_10023EE0(int a1, int a2, int a3, int a4, int a5);
char __cdecl sub_10024110(int a1, int a2, int a3, int a4, __int16 *a5);
// char __usercall sub_100245E0@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, const char *a4, char a5);
// char __usercall sub_10024680@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5);
char __cdecl sub_10024AC0(int a1, int a2, int a3, __int16 *a4, int a5);
char __cdecl sub_10024B00(int a1, int a2, int a3, int a4, int a5);
char __cdecl sub_10024B20(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
// char __usercall sub_10025000@<al>(int a1@<eax>, char *a2@<ecx>);
// char __usercall sub_10025060@<al>(int a1@<esi>, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_100251B0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_100254C0(unsigned int a1, char a2);
char __cdecl sub_10025520(signed __int16 *a1, _BYTE *a2);
// __int16 __usercall sub_10025590@<ax>(int a1@<eax>, int a2@<esi>, unsigned int a3);
// char *__usercall sub_100255F0@<eax>(int a1@<ebx>, int a2@<edi>, int a3, int a4);
// int __usercall sub_100256B0@<eax>(unsigned int a1@<eax>, char a2@<cl>);
// char __usercall sub_10025720@<al>(int *a1@<ebx>, int a2@<edi>, _DWORD *a3);
// char __usercall sub_10025790@<al>(signed int *a1@<ecx>, int a2@<ebx>, int a3, int a4);
char __cdecl sub_10025980(signed __int16 *a1, _BYTE *a2);
// char __usercall sub_10025A00@<al>(int a1@<eax>, int a2@<ecx>, signed int *a3, int a4);
// char __usercall sub_100261F0@<al>(int a1@<eax>, signed int *a2@<edx>, int a3, _BYTE *a4);
// char __usercall sub_100266F0@<al>(signed int *a1@<edx>, int a2@<ecx>, int a3@<edi>, int a4@<esi>);
char __cdecl sub_100267B0(int a1, int a2, int *a3, signed int *a4, int a5);
// char __usercall sub_100272B0@<al>(signed int *a1@<eax>, int a2@<edi>, int a3@<esi>);
char __cdecl sub_10027300(int a1);
// char __usercall sub_10027360@<al>(float *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4);
// char __usercall sub_10027380@<al>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
char __cdecl sub_10027610(int a1, int a2, int a3, float *a4, int a5);
double __cdecl sub_10027AA0(float a1, float a2);
double __cdecl sub_10027AC0(float a1, float a2);
signed int __fastcall sub_10027AE0(int a1);
// char __usercall sub_10027B00@<al>(int a1@<eax>, float *a2@<edi>, int a3);
char __cdecl sub_10027C10(int a1);
// char __usercall sub_10027C70@<al>(int a1@<ecx>, float *a2@<edi>, int a3@<esi>, int a4);
int __cdecl sub_10027CE0(float); // idb
// char __usercall sub_10027D20@<al>(int a1@<eax>, int a2, int a3);
char __cdecl sub_100281F0(int a1, int a2, int *a3, float *a4, int a5);
// int __usercall sub_10028840@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4);
char __cdecl sub_10028C20(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_10028C60(int a1, int a2, int a3);
char __cdecl sub_10028D30(int a1, int a2, int a3, float *a4);
// char __usercall sub_10028F20@<al>(_DWORD *a1@<eax>, int a2@<ebx>, int a3@<esi>);
// char __usercall sub_10028F90@<al>(int a1@<eax>, int a2@<ecx>, int a3);
char __cdecl sub_10029250(int a1, int a2);
char __cdecl sub_100292B0(int a1, int a2, int *a3, float *a4, int a5);
// char __usercall sub_10029760@<al>(_WORD *a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4, _WORD *a5);
char __cdecl sub_10029890(int a1, int a2, int a3, _WORD *a4, int a5);
char __cdecl sub_10029B20(int a1, int a2, int a3, int a4, _WORD *a5);
// char __usercall sub_10029C70@<al>(int a1@<edx>, int a2@<esi>, int a3, int *a4, int a5);
char __cdecl sub_10029D20(unsigned int a1, int a2, int *a3, int a4, int a5);
int __cdecl sub_10029F30(unsigned int a1, unsigned __int8 a2);
int __cdecl sub_10029F90(int, char *, char); // idb
// int __usercall sub_10029FF0@<eax>(int a1@<eax>, int a2);
// char *__usercall sub_1002A040@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4);
// char *__usercall sub_1002A0E0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4);
// char __usercall sub_1002A1C0@<al>(int a1@<eax>, int a2@<edi>, int a3);
// char __usercall sub_1002A4D0@<al>(int a1@<edi>, int a2@<esi>, int a3);
// char __usercall sub_1002A6E0@<al>(int a1@<edi>, int a2@<esi>, int a3, unsigned int *a4);
char __cdecl sub_1002A840(int a1, int a2, int a3, unsigned int *a4, int a5);
char __cdecl sub_1002B120(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_1002B1D0(int a1, int a2, int a3, _WORD *a4, _WORD *a5);
// char __usercall sub_1002B250@<al>(unsigned __int16 *a1@<eax>, int a2@<ebx>, int a3@<edi>, unsigned int a4@<esi>, int a5);
char __cdecl sub_1002B2E0(int a1, int a2, int *a3, int a4, _WORD *a5);
char __cdecl sub_1002B480(int a1, int a2, int a3, _BYTE *a4, _WORD *a5);
int __cdecl sub_1002B700(float, float); // idb
void __cdecl sub_1002B750(int a1);
char __cdecl sub_1002BB80(int a1, int a2, int a3, int a4, int a5);
// int __usercall sub_1002BD50@<eax>(int a1@<ecx>, int a2@<esi>);
char __cdecl sub_1002BEB0(int a1, int a2, int a3, int a4, int a5);
// int __usercall sub_1002C050@<eax>(int a1@<eax>, int a2@<esi>, int a3);
// double __usercall sub_1002C470@<st0>(int a1@<eax>, float *a2@<edx>, float a3, float a4);
char __thiscall sub_1002C530(int this);
// void __usercall sub_1002C540(int a1@<edi>, int a2@<esi>, char a3);
// char __usercall sub_1002C7C0@<al>(int a1@<edi>, int a2@<esi>, char a3);
int __cdecl sub_1002CAF0(int, int, int, float); // idb
// int __usercall sub_1002D0C0@<eax>(int a1@<eax>, int a2@<esi>, int a3);
// void __usercall sub_1002D280(int a1@<eax>, int a2@<ecx>, int a3@<ebx>);
// char __usercall sub_1002D380@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4);
char __cdecl sub_1002E020(int a1, int a2, int a3, int a4, _WORD *a5);
BOOL __thiscall sub_1002E120(void *this);
char sub_1002E160();
char __cdecl sub_1002E240(void *a1);
char __cdecl sub_1002E390(__int16 a1, char *a2, __int16 a3, int a4);
const char *__cdecl sub_1002E4C0(const char *a1, int a2);
char __thiscall sub_1002E540(void *this);
char __cdecl sub_1002E560(void *a1, char *a2);
char __cdecl sub_1002E5E0(int a1, int a2);
char __cdecl sub_1002E660(unsigned __int8 a1);
int __cdecl sub_1002E6D0(unsigned int a1);
int sub_1002E6F0();
bool __cdecl sub_1002E810(int a1);
int sub_1002E830();
char __cdecl sub_1002E850(int a1, unsigned __int8 a2);
char __cdecl sub_1002E880(int a1, unsigned __int8 a2);
char __cdecl sub_1002E8B0(int a1, unsigned __int8 a2);
BOOL __cdecl sub_1002E8E0(char a1);
// signed int __usercall sub_1002E910@<eax>(int a1@<eax>);
// signed int __usercall sub_1002EA00@<eax>(int a1@<eax>);
int sub_1002EAF0();
// BOOL __usercall sub_1002EBA0@<eax>(char a1@<al>);
// BOOL __usercall sub_1002EBC0@<eax>(char a1@<al>);
char __cdecl sub_1002EBF0(int a1);
int __cdecl sub_1002EC10(int a1, char a2);
char sub_1002EC30();
int __cdecl sub_1002F1E0(int a1);
char __thiscall sub_1002F220(void *this);
char sub_1002F230();
char sub_1002F540();
int __cdecl sub_1002F560(int a1, int a2);
// int __usercall sub_1002F600@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>);
char __cdecl sub_1002F6C0(int a1, int a2, int a3);
__int16 __cdecl sub_1002F790(char a1, char a2);
__int16 __cdecl sub_1002F800(char a1, char a2);
char __cdecl sub_1002F870(char a1, char a2, __int16 a3);
char __cdecl sub_1002F920(char a1, char a2, __int16 a3);
char __cdecl sub_1002F9D0(char a1, signed __int16 *a2);
char __cdecl sub_1002FB00(char a1, char a2, _WORD *a3);
// bool __usercall sub_1002FBA0@<al>(int a1@<eax>);
// bool __usercall sub_1002FBC0@<al>(int a1@<esi>);
// void __usercall sub_1002FC50(unsigned int a1@<esi>);
// char __usercall sub_1002FDD0@<al>(int a1@<esi>);
// int __usercall sub_1002FF20@<eax>(int a1@<eax>);
// __int16 __usercall sub_10030080@<ax>(int a1@<eax>);
// char __usercall sub_10030180@<al>(int a1@<edi>);
char __thiscall sub_100302E0(int this);
void __cdecl sub_10030410(unsigned int a1);
int __cdecl sub_10030500(unsigned __int16 a1, char a2, int a3);
int sub_100305D0();
char __cdecl sub_10030630(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
void *__cdecl sub_10030760(int a1, __int16 a2);
char __cdecl sub_10030790(int a1, int a2, char *a3);
int __cdecl sub_100307F0(int a1, int a2, int a3, signed int a4, int a5);
// char __usercall sub_10030940@<al>(char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>);
// char __usercall sub_10030A00@<al>(unsigned __int16 a1@<di>, int a2);
// signed int __usercall sub_10030A60@<eax>(int a1@<edi>, unsigned __int16 a2@<si>, int a3);
signed int __cdecl sub_10030BC0(int a1, int a2, signed int a3);
char __cdecl sub_10030C20(int a1, int a2, int a3, char *a4);
char __cdecl sub_10030E80(int a1, int a2, int a3, char *a4);
char __cdecl sub_10031070(int a1, int a2, int a3, char *a4, int a5);
// int __usercall sub_100312D0@<eax>(int a1@<eax>, _WORD *a2@<ecx>);
// __int16 __usercall sub_10031340@<ax>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_100313B0@<eax>(int result@<eax>, int a2@<edx>);
// char *__usercall sub_100313E0@<eax>(int a1@<eax>);
// char __usercall sub_10031460@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, _WORD *a4);
char __cdecl sub_100315D0(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_10031610(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_10031840(int a1, int a2, int a3, _BYTE *a4, _WORD *a5);
int __cdecl sub_10031920(unsigned int a1, char a2, int a3, int a4);
char __cdecl sub_10031980(int a1, int a2, int a3, double *a4);
// char __usercall sub_10031E80@<al>(float *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4);
// char __usercall sub_10031F60@<al>(int a1@<eax>, int a2, int a3, int a4);
// char __usercall sub_10032A30@<al>(int a1@<eax>, float *a2@<ecx>, int a3@<ebx>, int a4@<esi>, int a5);
// char __usercall sub_10032AF0@<al>(int a1@<edx>, float *a2@<ecx>, int a3, int a4);
char __cdecl sub_10032B30(int a1, int a2, int *a3, float *a4, int a5);
// int __usercall sub_10033420@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int8 a3);
char __cdecl sub_10033500(int a1, int a2, int a3, int a4, _WORD *a5);
// unsigned int __usercall sub_10033AB0@<eax>(int a1@<ebx>, int a2@<esi>, unsigned __int16 *a3);
char __cdecl sub_10033B60(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
// char __usercall sub_10033C00@<al>(int ebx0@<ebx>, int a1, int a2, int a3, int *a4, _WORD *a5);
// char __usercall sub_100347F0@<al>(int a1@<edi>, int a2, int a3, int a4, int a5, _WORD *a6);
void __cdecl sub_10034E30(int a1, int (__cdecl *a2)(int));
void sub_10034E70();
// unsigned int __usercall sub_10034E80@<eax>(unsigned int result@<eax>);
// int __usercall sub_10034EC0@<eax>(int result@<eax>);
void __cdecl sub_10034EF0(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4, int a5);
void __cdecl sub_100352A0(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4);
__int16 __cdecl sub_100352C0(char a1);
void sub_10035430();
unsigned int __cdecl sub_10035440(const char *a1, int a2, signed int a3, int a4, int a5, _DWORD *a6);
int __cdecl sub_100354B0(int, int, int, int, int, char, char *); // idb
int sub_10035A40();
char *__cdecl sub_10035AE0(unsigned __int8 a1);
signed int sub_10035BA0();
int sub_10035BC0();
int sub_10035C20();
char *sub_10035C90();
int __cdecl sub_10035D60(const void *a1);
int __cdecl sub_10035E10(_BYTE *a1, _BYTE *a2);
int sub_10035E40();
int __fastcall sub_10035E50(unsigned __int8 a1);
int __fastcall sub_10035E70(unsigned __int8 a1);
void *__cdecl sub_10035E90(char a1, void *a2);
int __cdecl sub_10035F60(int a1);
char sub_10036120();
char *__cdecl sub_10036280(int a1, char *a2, int a3, char *a4, int a5);
char sub_100363B0();
char __cdecl sub_100363C0(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_100364C0(char *a1, int a2, char a3, char *a4);
void __cdecl sub_10036530(const char *a1, unsigned int a2, int a3);
void __cdecl sub_10036580(const char *a1, char a2, char a3);
int __cdecl sub_100365D0(int a1, _BYTE *a2, int a3);
signed int __cdecl sub_10036620(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_10036690(void *, size_t); // idb
void __cdecl sub_100366C0(_BYTE *a1);
int __cdecl sub_100366F0(int, char *, int); // idb
int __cdecl sub_10036750(char *, size_t, char *, va_list); // idb
int sub_10036790(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_100367C0(const char *a1, _BYTE *a2, int a3);
int __cdecl sub_10036800(int a1, int a2);
char __cdecl sub_10036820(const void *a1);
double sub_10036890(void); // weak
char __thiscall sub_100368B0(void *this);
char __thiscall sub_100368E0(void *this);
char __thiscall sub_10036910(void *this);
__int16 __cdecl sub_10036940(int a1);
char __fastcall sub_100369B0(int a1);
char __thiscall sub_10036A20(void *this);
char __fastcall sub_10036A50(int a1);
int __cdecl sub_10036AA0(int a1, int a2, int a3);
char sub_10036B00();
char __thiscall sub_10036B10(void *this);
BOOL __thiscall sub_10036B70(void *this);
char __thiscall sub_10036B90(void *this);
char __thiscall sub_10036BC0(void *this);
char __fastcall sub_10036BF0(int a1);
bool __thiscall sub_10036C40(void *this);
char __thiscall sub_10036D10(void *this);
char __thiscall sub_10036D40(void *this);
int sub_10036D70();
signed int __cdecl sub_10036DA0(int a1);
char __thiscall sub_10036DD0(void *this);
char __fastcall sub_10036E00(int a1);
char __cdecl sub_10036E50(int a1);
int __cdecl sub_10036E70(int, char *); // idb
char __thiscall sub_10036ED0(void *this);
char __thiscall sub_10036EF0(void *this);
char __thiscall sub_10036F10(void *this);
char __thiscall sub_10036F30(void *this);
int __thiscall sub_10036F50(void *this);
__int16 __thiscall sub_10036F70(void *this);
int __thiscall sub_10036F80(void *this);
char __thiscall sub_10036FA0(void *this);
int __thiscall sub_10036FC0(void *this);
char __thiscall sub_10036FE0(void *this);
bool __fastcall sub_10037000(int a1, int a2);
char __thiscall sub_10037080(void *this);
char sub_100370A0();
int __cdecl sub_100370C0(char a1);
int __cdecl sub_100370D0(char a1);
int __cdecl sub_100370E0(char *); // idb
int __cdecl sub_100370F0(char *); // idb
char __thiscall sub_10037100(void *this);
int __thiscall sub_10037130(void *this);
int __cdecl sub_10037150(char *); // idb
char sub_10037170();
bool __cdecl sub_100371F0(char a1);
int __cdecl sub_10037260(unsigned __int16 a1);
char *__cdecl sub_10037280(unsigned __int16 a1);
char __cdecl sub_100372C0(_BYTE *a1);
char __cdecl sub_10037400(int a1, int a2, int a3);
char __cdecl sub_10037430(int a1, _WORD *a2, int a3);
__int16 __cdecl sub_10037460(unsigned int a1);
bool __cdecl sub_10037480(char *a1, int *a2, _DWORD *a3);
char __cdecl sub_100374D0(int a1, char *a2);
int __cdecl sub_10037530(int a1, int a2, char *a3, int a4);
char __cdecl sub_100375A0(int a1, char *a2, int a3);
int __cdecl sub_10037650(int a1);
int __cdecl sub_100376D0(int a1);
bool __cdecl sub_100376E0(char a1);
int __cdecl sub_10037710(unsigned __int8 a1);
int __cdecl sub_10037720(unsigned int a1, float *a2);
char __cdecl sub_10037750(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
// int __usercall sub_10037770@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
char __cdecl sub_100377C0(int a1, int a2, int a3, int a4, _WORD *a5);
// char __usercall sub_10037840@<al>(int a1@<esi>, int a2, int a3, int a4, int a5, _WORD *a6);
int __cdecl sub_10037AC0(unsigned __int16 a1);
char __cdecl sub_10037AD0(int a1, int a2, int a3, int a4, __int16 *a5);
char __cdecl sub_10038130(int a1, int a2, int *a3, int a4, int a5);
_DWORD *__cdecl sub_100381A0(_DWORD *a1);
int __cdecl sub_100381B0(int *a1, int a2);
_DWORD *__cdecl sub_100381E0(_DWORD *a1, int a2);
char __cdecl sub_100381F0(char a1);
char __cdecl sub_10038230(char a1);
char __cdecl sub_100382A0(char a1);
signed int __cdecl sub_10038310(char a1);
char __cdecl sub_10038390(char a1);
char __cdecl sub_10038400(char a1);
bool __cdecl sub_100384B0(char a1, void *a2);
char __cdecl sub_10038500(int a1);
char __thiscall sub_10038600(void *this);
int __cdecl sub_10038610(int *a1);
// char __usercall sub_10038640@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_100386E0(const char *a1);
char __cdecl sub_10038720(void *a1);
signed int __cdecl sub_10038770(unsigned int a1, int a2);
char **sub_10038B10();
int __cdecl j_nullsub_1(_DWORD); // weak
int __cdecl sub_10038B30(int a1);
int sub_10038B40(void); // weak
char __cdecl sub_10038B70(char a1, unsigned __int16 a2, char a3);
signed int __cdecl sub_10038BA0(int (__cdecl *a1)(int));
char *__cdecl sub_10038BD0(unsigned __int8 a1);
bool __cdecl sub_10038C00(unsigned __int16 a1, _BYTE *a2, unsigned __int8 a3);
char __cdecl sub_10038C80(unsigned __int16 a1);
char __cdecl sub_10038CF0(unsigned __int16 a1);
char __cdecl sub_10038D60(unsigned __int16 a1, char a2);
bool __cdecl sub_10038DD0(unsigned __int16 a1, _BYTE *a2);
int __cdecl sub_10038E00(int a1, unsigned int a2);
int __cdecl sub_10038EF0(int *a1, unsigned int a2);
__int16 __cdecl sub_10038FE0(int a1, unsigned int a2);
int __cdecl sub_10039030(int *a1, unsigned int a2);
__int16 __cdecl sub_10039060(unsigned int *a1, _WORD *a2, _WORD *a3);
char __cdecl sub_100390E0(void *a1);
char __cdecl sub_10039160(char *a1);
char __cdecl sub_10039190(int a1);
unsigned int __cdecl sub_100391E0(int a1, int a2, size_t a3, int a4, int a5);
int sub_10039340(); // weak
unsigned int __cdecl sub_10039360(int a1, int a2, size_t a3, int a4);
int __cdecl sub_10039390(char *a1, char a2);
bool __cdecl sub_10039400(int a1, void *a2);
char __cdecl sub_100394C0(int a1, bool *a2);
void sub_10039580();
signed int sub_10039590();
signed int __cdecl sub_100395A0(char *a1);
signed int __fastcall sub_10039610(unsigned __int8 a1);
char __cdecl sub_10039620(unsigned __int8 a1);
__int16 __cdecl sub_10039640(unsigned __int8 a1);
__int16 __cdecl sub_10039660(unsigned __int8 a1);
bool __cdecl sub_10039680(unsigned __int8 a1);
char __cdecl sub_100396A0(bool *a1);
char __cdecl sub_100397E0(char a1);
signed int __cdecl sub_10039810(signed int a1);
char __cdecl sub_10039850(int a1);
int __cdecl sub_100398C0(char *, char *); // idb
// void *__usercall sub_10039900@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>);
signed int sub_10039950();
char __cdecl sub_1003B750(char a1, void *a2);
char __cdecl sub_1003B800(char a1);
int __cdecl sub_1003B860(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1003B9F0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5);
int __cdecl sub_1003BB10(char a1);
char __cdecl sub_1003BB60(int a1, int a2, int a3, int a4, int a5, int a6);
signed int sub_1003BBD0();
// char __usercall sub_1003BBE0@<al>(char a1@<bl>, int a2@<edi>, const void *a3@<esi>, char a4, char a5, char a6, unsigned int a7);
int __cdecl sub_1003BD40(char *a1);
char __cdecl sub_1003BDD0(char a1);
char __cdecl sub_1003BDF0(char a1, char a2, char a3, int a4);
char __cdecl sub_1003BE20(_BYTE *a1);
char __cdecl sub_1003BE50(char *a1);
char sub_1003BE80();
char __cdecl sub_1003BEA0(char a1, char a2, int a3);
char __cdecl sub_1003BED0(char a1, char a2, char a3, int a4, const void *a5, unsigned int a6);
char __thiscall sub_1003BF00(void *this);
char __cdecl sub_1003BF90(char a1);
char __cdecl sub_1003C000(int a1, char a2);
char __cdecl sub_1003C0C0(int a1, char a2);
char __cdecl sub_1003C180(char a1, char a2);
char __cdecl sub_1003C1D0(char a1);
char __cdecl sub_1003C200(char a1);
char __cdecl sub_1003C230(char a1);
char __cdecl sub_1003C270(char a1, _BYTE *a2);
char __cdecl sub_1003C2C0(char a1, void *a2);
char __cdecl sub_1003C2F0(unsigned __int8 a1, void *a2);
bool __cdecl sub_1003C310(unsigned __int8 a1, char *a2);
char __cdecl sub_1003C350(char a1, char a2, int a3, int a4, char *a5);
int __cdecl sub_1003C390(char a1);
char __cdecl sub_1003C3C0(char a1);
void __cdecl sub_1003C3F0(int a1);
int __cdecl sub_1003CC80(__int16 a1, char a2);
void __cdecl sub_1003CCC0(__int16 a1, char a2);
char __cdecl sub_1003CD30(char a1);
signed int __cdecl sub_1003CD70(char a1);
char sub_1003CDB0();
void sub_1003CDD0();
signed int sub_1003CDE0();
char __cdecl sub_1003CDF0(_BYTE *a1);
char __cdecl sub_1003CE20(int a1);
char *__cdecl sub_1003CEB0(int a1);
int __cdecl sub_1003CED0(float); // idb
int __cdecl sub_1003CF60(int a1, _WORD *a2, char *a3, int a4, int a5, int a6, int a7);
int __cdecl sub_1003D0A0(int a1, _WORD *a2, char *a3, int a4, int a5, int a6);
// void __usercall sub_1003D0E0(int a1@<eax>, int a2@<edi>, int a3@<esi>, float a4);
void __cdecl sub_1003D230(int a1, int a2, int a3);
// int __usercall sub_1003D250@<eax>(float a1@<eax>, int a2@<ecx>, int a3@<ebx>, int a4);
int __cdecl sub_1003D330(int a1, int a2, int a3);
int __cdecl sub_1003D350(int a1, int a2, int a3);
char __cdecl sub_1003D3C0(char a1);
BOOL sub_1003D440();
char __cdecl sub_1003D480(unsigned __int8 a1);
void sub_1003D520();
signed int sub_1003D530();
char __cdecl sub_1003D540(unsigned __int8 a1, _DWORD *a2);
BOOL __fastcall sub_1003D5B0(int a1);
bool __thiscall sub_1003D5E0(void *this);
int __cdecl sub_1003D620(char a1);
signed int sub_1003D640();
// signed int __usercall sub_1003D690@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_1003D730@<eax>(char a1@<al>);
// int __usercall sub_1003D750@<eax>(char a1@<al>);
// signed __int16 __usercall sub_1003D770@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_1003D9B0(char a1, unsigned __int16 a2, _BYTE *a3);
char __cdecl sub_1003DB10(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_1003DC90(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_1003DDF0(int a1, int a2, void *a3, char a4, __int16 a5, char a6);
char __cdecl sub_1003DF30(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_1003E010(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_1003E290(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_1003E2C0(char a1, int a2, void *a3);
char __cdecl sub_1003E2F0(char a1, int a2, void *a3, int a4);
char __cdecl sub_1003E320(_WORD *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1003E3F0(_BYTE *a1);
char __cdecl sub_1003E420(_BYTE *a1, _BYTE *a2);
char __cdecl sub_1003E470(_BYTE *a1, _BYTE *a2);
int sub_1003E4C0();
__int16 sub_1003E590();
// int __usercall sub_1003E5F0@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4);
signed int __cdecl sub_1003E670(int a1);
char sub_1003E760();
int (__cdecl *(*sub_1003E920())[2])(int, int);
char __cdecl sub_1003EA50(int a1, int a2);
char __cdecl sub_1003EB70(int a1);
char __cdecl sub_1003EB80(int a1);
char __cdecl sub_1003EB90(int a1);
_DWORD *sub_1003EBA0();
char sub_1003EBB0();
BOOL __cdecl sub_1003EBD0(unsigned int a1);
char __thiscall sub_1003EC40(void *this);
void __cdecl sub_1003EC60(_BYTE *a1, _BYTE *a2, _BYTE *a3);
int __cdecl sub_1003EC90(int a1);
signed int sub_1003ECB0();
void __cdecl sub_1003ECE0(_BYTE *a1);
char __cdecl sub_1003ED00(int a1, size_t a2, void *a3);
int __cdecl sub_1003ED40(int a1);
char __fastcall sub_1003ED60(int *a1);
char sub_1003EF80();
void sub_1003EFA0();
signed int sub_1003EFB0();
signed int sub_1003EFC0();
char sub_1003EFF0();
bool __cdecl sub_1003F060(float *a1);
void sub_1003F110();
int sub_1003F120();
char sub_1003F150();
int __cdecl sub_1003F1F0(int a1, int a2);
signed int sub_1003F210();
int sub_1003F230();
signed int __cdecl sub_1003F240(_BYTE *a1, char a2, int a3);
int __cdecl sub_1003F290(int, float, float, int, int); // idb
unsigned int __cdecl sub_1003F380(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_1003F3D0(_BYTE *a1, __int16 a2, __int16 a3, __int16 a4, int a5);
unsigned int __cdecl sub_1003F470(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
unsigned int __cdecl sub_1003F530(void *a1, size_t a2, int a3);
int __cdecl sub_1003F590(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_1003F5E0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_1003F680(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
int __cdecl sub_1003F730(int *a1, int a2);
char __cdecl sub_1003F750(unsigned __int16 a1, int a2, char a3);
char __cdecl sub_1003F950(char a1);
char __cdecl sub_1003F970(unsigned int a1, float *a2);
double __cdecl sub_1003FD90(int a1, unsigned __int16 a2, char a3, char *a4);
double __cdecl sub_10040160(int a1, unsigned int a2);
double __cdecl sub_10040790(int a1, unsigned int a2);
int __cdecl sub_10040E80(float, float, float, float, float, int, int); // idb
// __int16 __usercall sub_100411D0@<ax>(int a1@<edi>, char a2);
// signed __int16 __usercall sub_10041370@<ax>(void *a1@<ecx>, signed __int16 a2@<bx>, const char *a3@<esi>);
char __cdecl sub_100415C0(signed __int16 a1);
char __cdecl sub_10041650(char a1, int a2);
int __cdecl sub_10041670(unsigned __int8 *a1, int a2);
int __cdecl sub_100416A0(unsigned __int8 *a1, int a2);
int __cdecl sub_100416D0(unsigned __int8 *a1, int a2);
int __cdecl sub_10041700(unsigned __int8 *a1, int a2);
int __cdecl sub_10041730(unsigned __int8 *a1, int a2);
int __cdecl sub_10041760(unsigned __int8 *a1, int a2);
int __cdecl sub_10041790(unsigned __int8 *a1, int a2);
int __cdecl sub_100417C0(unsigned __int8 *a1, int a2);
int __cdecl sub_100417F0(unsigned __int8 *a1, int a2);
int __cdecl sub_10041820(unsigned __int8 *a1, int a2);
int __cdecl sub_10041850(unsigned __int8 *a1, int a2);
int __cdecl sub_10041880(unsigned __int8 *a1);
signed int __cdecl sub_100418A0(unsigned __int8 *a1, int a2);
int __cdecl sub_100418D0(unsigned __int8 *a1, int a2);
int __cdecl sub_10041900(unsigned __int8 *a1, int a2);
int __cdecl sub_10041930(unsigned __int8 *a1, int a2);
unsigned int __cdecl sub_10041960(char *a1);
int __cdecl sub_10041980(_BYTE *a1);
int __cdecl sub_100419A0(unsigned __int8 *a1);
int __cdecl sub_100419C0(unsigned __int8 *a1, int a2);
unsigned int __cdecl sub_100419F0(int a1, int a2);
unsigned int __cdecl sub_10041D20(int a1, int a2);
unsigned int __cdecl sub_10042160(_BYTE *a1);
int __cdecl sub_10042180(unsigned __int8 *a1);
int __cdecl sub_100421A0(unsigned __int8 *a1);
int __cdecl sub_100421C0(_BYTE *a1);
int __cdecl sub_100421E0(int a1);
// void __cdecl __noreturn exit(int);
int __cdecl sub_10042230(unsigned __int8 *a1);
int __cdecl sub_10042250(int a1);
unsigned int __cdecl sub_100422E0(int a1);
signed int __cdecl sub_10042300(int a1);
unsigned int __cdecl sub_10042350(int a1);
int __cdecl sub_100423B0(_BYTE *a1);
unsigned int __cdecl sub_100423D0(_BYTE *a1);
int __cdecl sub_100423F0(unsigned __int8 *a1);
int __cdecl sub_10042410(_BYTE *a1);
signed int __cdecl sub_10042430(_BYTE *a1, int a2);
int __cdecl sub_10042460(_BYTE *a1, int a2);
signed int __cdecl sub_100424A0(_BYTE *a1, int a2);
int __cdecl sub_100424D0(int a1, int a2);
int __cdecl sub_10042560(unsigned __int8 *a1);
int __cdecl sub_10042580(int a1);
int __cdecl sub_100425B0(unsigned __int8 *a1);
unsigned int __cdecl sub_100425D0(int a1);
int __cdecl sub_10042600(int a1);
int __cdecl sub_100426F0(int a1);
int __cdecl sub_10042800(int a1);
int __cdecl sub_10042830(unsigned __int8 *a1);
signed int __cdecl sub_10042850(int a1, int a2);
int __cdecl sub_10042D60(_BYTE *a1, int a2);
signed int __cdecl sub_10042D90(_BYTE *a1, int a2);
int __cdecl sub_10042E00(unsigned __int8 *a1);
int __cdecl sub_10042E60(int a1);
signed int __cdecl sub_10042E70(_BYTE *a1, int a2);
unsigned int __cdecl sub_10042EA0(int a1);
int __cdecl sub_10042EF0(int a1, int a2);
_DWORD __cdecl sub_10042F70(_DWORD); // weak
int __cdecl sub_10042F80(int a1);
unsigned int __cdecl sub_10043000(int a1);
unsigned int __cdecl sub_10043040(int a1);
int __cdecl sub_10043090(int a1);
int __cdecl sub_100430C0(int a1);
unsigned int __cdecl sub_100430F0(int a1);
unsigned int __cdecl sub_10043120(int a1);
unsigned int __cdecl sub_10043140(int a1);
void __cdecl __noreturn sub_10043180(int a1);
signed int __cdecl sub_100432F0(int a1, int a2);
int __cdecl sub_10043340(int a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// int __usercall sub_100433A0@<eax>(unsigned __int8 *a1@<eax>, int a2@<edi>);
// signed int __usercall sub_100433F0@<eax>(int a1@<eax>, int a2@<edi>);
int __cdecl sub_100434C0(unsigned __int8 *a1);
signed int __cdecl sub_100434D0(int a1);
char __cdecl sub_100434E0(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_10043610(char a1, int a2);
char __cdecl sub_10043670(char a1, int a2);
bool __cdecl sub_100436F0(void *a1);
char __cdecl sub_10043740(char a1, int a2);
bool __cdecl sub_10043820(char a1, int a2);
// __int16 __usercall sub_10043860@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10043870(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_10043900(unsigned __int8 a1, char a2);
bool __cdecl sub_100439C0(__int16 a1, char a2, int a3, int a4, void *a5);
// int __usercall sub_10043AC0@<eax>(const char *a1@<eax>, int a2@<ecx>);
// int __usercall sub_10043B40@<eax>(int a1@<ebx>, float a2, float a3, int a4, int a5, int a6, float a7, char a8);
bool __cdecl sub_10043CE0(unsigned int a1, unsigned __int16 a2);
int __cdecl sub_10043D20(unsigned __int16 a1);
char __cdecl sub_10043D50(void *a1);
BOOL sub_10043D60();
// int __usercall sub_10043D90@<eax>(char a1@<al>, int a2@<ecx>);
char __thiscall sub_10043DC0(void *this);
char __thiscall sub_10043E20(void *this);
char __cdecl sub_10043E90(char a1, char a2, int *a3);
char __cdecl sub_10044040(char a1, int *a2, char a3);
char __cdecl sub_100440B0(char a1, int *a2);
char __cdecl sub_100440E0(_DWORD *a1);
bool __cdecl sub_10044160(float *a1);
int sub_10044200();
// char __usercall sub_10044230@<al>(int a1@<eax>, float *a2@<esi>, float a3, float a4);
char __cdecl sub_10044290(void *a1);
char __cdecl sub_100442F0(float *a1);
char __cdecl sub_100443F0(void *a1);
char __cdecl sub_10044450(void *a1);
char __cdecl sub_10044530(float *a1);
bool sub_10044570();
signed int sub_10044590();
char __thiscall sub_100445D0(void *this);
char __cdecl sub_100445F0(char a1);
int sub_10044640();
char __thiscall sub_10044670(void *this);
int __cdecl sub_100446B0(void *); // idb
char __thiscall sub_10044700(void *this);
int __cdecl sub_10044730(void *); // idb
char sub_10044790();
int __cdecl sub_100447C0(int a1);
int __cdecl sub_10044810(int a1);
int __cdecl sub_10044830(float a1, int a2, char a3);
char __cdecl sub_100449C0(char a1);
double __cdecl sub_10044A40(char a1);
int __cdecl sub_10044AC0(unsigned __int8 a1);
double __cdecl sub_10044AE0(float a1);
double __cdecl sub_10044B40(float a1);
// bool __usercall sub_10044BB0@<al>(int a1@<eax>);
char __cdecl sub_10044C20(char *a1);
double sub_10044DA0();
double __thiscall sub_10044E00(void *this);
char sub_10044E70();
double sub_10044E80(void); // weak
char __fastcall sub_10044E90(int a1);
int __cdecl sub_10044ED0(float); // idb
void __cdecl sub_10044F00(char a1, float a2);
int __cdecl sub_10044FD0(int a1);
double __fastcall sub_10045030(float a1);
int __thiscall sub_100450B0(void *this);
char __cdecl sub_10045140(char a1);
char __thiscall sub_10045170(void *this);
int __cdecl sub_100451D0(int, float); // idb
char __cdecl sub_10045200(__int16 a1, void *a2);
int __cdecl sub_100452A0(int a1);
signed int __cdecl sub_100452E0(unsigned int a1);
signed int __cdecl sub_10045320(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_10045380(unsigned int a1, int a2, int a3);
unsigned int __cdecl sub_100453A0(unsigned int a1);
int __cdecl sub_100453C0(int a1);
bool __cdecl sub_100453D0(int a1);
int __cdecl sub_100454A0(int a1);
int __cdecl sub_100454C0(int a1, int a2);
bool __cdecl sub_10045500(int a1);
signed int __cdecl sub_10045560(int a1, void *a2, unsigned __int16 a3, __int16 a4);
signed int __cdecl sub_10045620(int a1, int a2, int a3);
int __cdecl sub_100456D0(int a1);
signed int __cdecl sub_100456F0(_BYTE *a1, _BYTE *a2, int a3);
// int __usercall sub_10045750@<eax>(int a1@<esi>, int a2, char a3);
// int __usercall sub_10045860@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_10045910@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_10045AE0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_10045AF0@<eax>(int result@<eax>);
// char __usercall sub_10045B10@<al>(int a1@<eax>);
// int __usercall sub_10045B30@<eax>(int a1@<esi>, unsigned __int8 a2);
int __cdecl sub_10045B70(unsigned int a1);
int __fastcall sub_10045D20(int a1, int a2);
// int __usercall sub_10045D40@<eax>(int result@<eax>, int a2@<ecx>);
// int __usercall sub_10045D50@<eax>(int a1@<esi>);
// signed int __usercall sub_10045D90@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_10045FA0(void *); // idb
int __cdecl sub_10046000(int, int, void *, int); // idb
signed int __cdecl sub_10046100(int a1, unsigned __int64 a2);
signed int __cdecl sub_10046300(int a1, int a2);
int __cdecl sub_10046320(int a1);
int __cdecl sub_10046590(void *, int, char); // idb
signed int __cdecl sub_10046660(unsigned int a1, int a2, int a3);
// int __usercall sub_10046700@<eax>(int a1@<eax>);
// int __usercall sub_10046720@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_10046750@<eax>(int a1@<eax>, int a2@<ebx>);
int __cdecl sub_100467C0(int, char *, int); // idb
// void __cdecl __noreturn exit_0(int);
signed int __cdecl sub_10046930(int a1);
// char __usercall sub_10046990@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_100469C0@<eax>(int a1@<eax>);
// BOOL __usercall sub_100469F0@<eax>(int a1@<ebx>, int a2);
signed int __cdecl sub_10046A30(unsigned int a1);
signed int __cdecl sub_10046A80(int a1, int a2);
// bool __usercall sub_10046C70@<al>(int a1@<eax>);
int __cdecl sub_10046CA0(int, int, char, void *, int); // idb
signed int __cdecl sub_10046DB0(unsigned int a1, int a2, int a3);
signed int __cdecl sub_10046E10(unsigned int a1, int a2, int a3);
int __cdecl sub_10046FA0(int a1, char *a2, int a3, void *a4, int a5);
// unsigned int __usercall sub_10047190@<eax>(int a1@<eax>);
char __cdecl sub_100473D0(int a1, int a2, int a3, int a4, __int16 *a5);
unsigned int __cdecl sub_100474B0(_BYTE *a1);
int __cdecl sub_100474D0(_BYTE *a1);
int __cdecl sub_100474F0(_BYTE *a1);
unsigned int __cdecl sub_10047510(int a1);
int __cdecl sub_10047580(unsigned __int8 *a1);
int __cdecl sub_100475A0(unsigned __int8 *a1);
int __cdecl sub_100475C0(unsigned __int8 *a1);
int __cdecl sub_100475E0(unsigned __int8 *a1);
_DWORD __cdecl sub_10047600(_DWORD); // weak
int __cdecl sub_10047610(int a1);
int __cdecl sub_10047650(int a1);
char *__cdecl sub_10047670(char **a1);
int sub_100476C0();
int __cdecl sub_10047700(_BYTE *a1, int a2);
signed int __cdecl sub_10047770(_BYTE *a1, int a2);
// int __usercall sub_10047810@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_10047840@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_10047A10@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// int __usercall sub_10047A70@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_10047B00@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_10047B50@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_10047BB0@<eax>(int a1@<eax>);
// int __usercall sub_10047BD0@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_10047C10@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_10047CA0@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_10047DF0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_10047E90@<eax>(int result@<eax>);
char *__cdecl sub_10047ED0(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_10048080@<eax>(int a1@<eax>);
// int __usercall sub_100480B0@<eax>(int a1@<esi>);
void __cdecl sub_100480E0(int (**a1)(void), char **a2, _DWORD *a3);
int sub_10048550();
void *sub_100485A0();
char *sub_10048600();
char sub_10048620();
char __cdecl sub_10048630(int a1, int a2, unsigned int a3);
// int *__usercall sub_10048670@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_100486C0();
int __cdecl sub_100486D0(_DWORD *a1, int a2, int a3);
int __cdecl sub_10048780(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_10048990@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_10048A50(char a1);
int *__cdecl sub_10048AF0(_BYTE *a1);
// int __usercall sub_10048BB0@<eax>(int a1@<eax>);
// signed int __usercall sub_10048D10@<eax>(int a1@<esi>);
int __cdecl sub_10048D80(int, int); // weak
char **sub_10049060();
// int __usercall sub_10049070@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_10049160(char *a1);
int sub_100493A0();
int __cdecl sub_10049480(int a1, int a2, char a3);
int __cdecl sub_100494D0(int a1);
int __cdecl sub_100494E0(void *); // idb
int __cdecl sub_10049560(int a1, int a2);
signed int __cdecl sub_10049590(int a1, int a2, int a3);
char __cdecl sub_100495B0(_DWORD *a1);
char __cdecl sub_100496C0(int a1, unsigned int a2);
bool __cdecl sub_100496F0(const void **a1, int a2);
bool __cdecl sub_10049720(const void **a1, int a2);
bool __cdecl sub_10049750(const void **a1, int a2);
bool __cdecl sub_10049780(const void **a1, int a2);
bool __cdecl sub_100497B0(const void **a1, int a2);
bool __cdecl sub_100497E0(int a1, int a2);
bool __cdecl sub_10049820(int a1, int a2);
bool __cdecl sub_10049860(const void **a1, int a2);
bool __cdecl sub_10049890(const void **a1, int a2);
char __cdecl sub_100498C0(int a1, unsigned int a2);
bool __cdecl sub_100498F0(const void **a1, int a2);
bool __cdecl sub_10049920(const void **a1, int a2);
bool __cdecl sub_10049950(const void **a1, int a2);
bool __cdecl sub_10049980(const void **a1, int a2);
bool __cdecl sub_100499B0(const void **a1, int a2);
bool __cdecl sub_100499E0(const void **a1, int a2);
bool __cdecl sub_10049A10(const void **a1, int a2);
bool __cdecl sub_10049A40(const void **a1, int a2);
bool __cdecl sub_10049A70(const void **a1, int a2);
bool __cdecl sub_10049AA0(const void **a1, int a2);
int __cdecl sub_10049AD0(int a1, int a2, int a3);
// void __cdecl __noreturn exit_1(int);
int __cdecl sub_10049B40(int a1, char a2);
int __cdecl sub_10049B60(int a1, int a2, int a3);
int __cdecl sub_10049B90(int a1, int a2, int a3, int a4);
int __cdecl sub_10049BC0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10049C00(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10049C40(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_10049C90(int a1);
char __cdecl sub_10049CC0(int a1);
char __cdecl sub_10049CD0(int a1, int a2);
signed int __cdecl sub_10049E50(int a1);
signed int __cdecl sub_10049E90(int a1, int a2, int a3);
char __cdecl sub_10049F30(int a1);
char __cdecl sub_10049F90(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1004A000(char *a1);
int __cdecl sub_1004A0A0(int a1, int a2, int a3);
bool __cdecl sub_1004A110(int a1, unsigned int a2, int a3);
char __cdecl sub_1004A1A0(int a1, int a2, char a3, char a4);
char __cdecl sub_1004A250(int a1);
char __cdecl sub_1004A260(int a1, void (__cdecl *a2)(int));
int (__cdecl *__cdecl sub_1004A2E0(int a1, const char *a2))(const char *);
signed int __cdecl sub_1004A330(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1004A380(int a1, int a2, int a3, size_t a4, char *a5);
int sub_1004A500();
const char *__cdecl sub_1004A510(unsigned int a1);
int __cdecl sub_1004A530(int a1, int a2, int a3, int a4);
int __cdecl sub_1004A5E0(int a1);
int __cdecl sub_1004A600(int a1);
char *sub_1004A620(char *a1, ...);
// char *__usercall sub_1004A660@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_1004A680@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_1004A860();
int sub_1004A880();
int __cdecl sub_1004A8A0(int a1, int a2);
int __cdecl sub_1004A900(int a1);
int __cdecl sub_1004A910(int a1, int a2);
int __cdecl sub_1004A970(int a1);
bool __cdecl sub_1004A980(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1004AAC0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1004AE70(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_1004B2C0(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_1004B780(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1004BB40(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_1004BF40(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1004C300(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_1004C840(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_1004CC20(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1004CFE0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1004D380(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_1004D780(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1004DB20(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_1004E100(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_1004E4F0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_1004E890();
// BOOL __usercall sub_1004E8C0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_1004EA30@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_1004ECA0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_1004EFA0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_1004F050(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
const char *__cdecl sub_1004F090(int a1, int a2);
char __cdecl sub_1004F0D0(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_1004FE80(int a1, int a2);
char **__cdecl sub_1004FF00(int a1);
int (**sub_1004FF40())();
int (__cdecl *__cdecl sub_1004FF50(const char *a1))(const char *);
const char *sub_1004FF70();
__int64 sub_1004FF80();
const char *sub_1004FF90();
// int __usercall sub_1004FFA0@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_1004FFF0(int a1, int a2);
int sub_10050020(); // weak
// int __usercall sub_10050140@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_100504C0(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_100512E0(int a1);
char __thiscall sub_10051350(void *this);
// char __usercall sub_100513C0@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_10051400@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_100514A0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_100514E0(char a1, char a2, void *a3);
char __cdecl sub_10051540(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10051580(char a1, char a2, void *a3);
char __cdecl sub_100515B0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_100515F0(char a1, char a2, void *a3);
char __cdecl sub_10051630(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10051670(char a1, char a2, void *a3);
char __cdecl sub_100516C0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10051700(char a1, char a2, void *a3);
char __cdecl sub_10051740(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10051780(char a1, char a2, void *a3);
char __cdecl sub_100517C0(char a1, void *a2);
char __cdecl sub_100517F0(char a1, void *a2);
char __cdecl sub_10051820(char a1, void *a2);
char __cdecl sub_10051850(char a1, void *a2);
char __cdecl sub_10051880(char a1, void *a2);
char __cdecl sub_100518B0(char a1, void *a2);
char __cdecl sub_100518E0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10051920(char a1, char a2, void *a3);
char __cdecl sub_10051970(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_100519B0(char a1, char a2, void *a3);
char __cdecl sub_100519E0(char a1, void *a2);
char __cdecl sub_10051A10(char a1, void *a2);
char __cdecl sub_10051A40(char a1, void *a2);
char __cdecl sub_10051A70(int a1, char a2, char a3, int a4, void *a5);
bool __cdecl sub_10051E10(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10051E80(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10051EE0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10051F50(char a1, _BYTE *a2);
char __thiscall sub_10051F90(void *this);
char __cdecl sub_10052000(char a1, int a2);
char __cdecl sub_10052030(char a1, int a2);
char __cdecl sub_10052060(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
char __cdecl sub_10052230(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
char __cdecl sub_10052290(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
signed int __cdecl sub_100522F0(char a1, char a2);
int __cdecl sub_10052350(char a1);
signed int __cdecl sub_10052390(char a1, char a2, char a3);
int __cdecl sub_10052400(char a1);
int __cdecl sub_10052440(char a1);
char __cdecl sub_10052480(char a1, int a2);
char __cdecl sub_100524A0(char a1, int a2);
char __cdecl sub_100524D0(char a1, int a2);
char __cdecl sub_10052520(char a1, int a2);
char __cdecl sub_10052550(char a1, int a2);
char __cdecl sub_10052570(int a1);
int __cdecl sub_10052590(unsigned __int8 *a1);
unsigned int __cdecl sub_100525B0(void *a1);
unsigned int __cdecl sub_100525D0(void *a1);
unsigned int __cdecl sub_100525F0(void *a1);
unsigned int __cdecl sub_10052610(void *a1);
unsigned int __cdecl sub_10052630(void *a1);
int __cdecl sub_10052650(int a1);
signed int __cdecl sub_100526A0(_BYTE *a1, int a2);
int __cdecl sub_100526D0(void *); // idb
unsigned int __cdecl sub_100527A0(void *a1);
char __cdecl sub_10052800(char a1, void *a2);
unsigned __int8 __cdecl sub_10052850(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_10052890(char a1, _DWORD *a2);
char __cdecl sub_100528D0(char a1);
char __cdecl sub_10052900(char a1, void *a2);
int __cdecl sub_10052980(char a1, _DWORD *a2);
void __cdecl sub_100529D0(char a1, char a2);
char *__cdecl sub_10052A40(char *a1);
int __cdecl sub_10052B30(char a1);
int __cdecl sub_10052B50(int, void *); // idb
// int __usercall sub_10052BB0@<eax>(char a1@<al>);
BOOL __cdecl sub_10052BE0(char a1, int a2);
int __cdecl sub_10052C10(int, char, int, int, void *); // idb
char __cdecl sub_10052C40(void *a1);
BOOL __cdecl sub_10052C60(int a1);
char __cdecl sub_10052C80(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_10052CB0(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_10052D40(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
bool __cdecl sub_10052DE0(char a1, void *a2);
// signed int __usercall sub_10052E20@<eax>(char a1@<al>);
bool __cdecl sub_10052E40(char a1, void *a2);
bool __cdecl sub_10052F30(char a1, char a2, int a3, int a4, void *a5);
BOOL __cdecl sub_10052F60(unsigned __int8 a1);
// BOOL __usercall sub_10052F70@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_10052FA0(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_10053150(unsigned __int8 a1, int a2);
bool __cdecl sub_10053190(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
char sub_10053280();
BOOL __cdecl sub_10053320(int a1, int a2);
char __cdecl sub_10053340(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_10053380(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10053420(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_100534A0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10053510(char a1, void *a2);
char __cdecl sub_10053590(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10053610(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10053690(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10053700(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
BOOL sub_10053810();
char __cdecl sub_10053870(int a1, char *a2);
BOOL __cdecl sub_10053960(int a1, int a2);
char __cdecl sub_10053980(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_100539C0(int a1, int a2);
BOOL __cdecl sub_10053A70(int a1, int a2);
char __cdecl sub_10053A90(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_10053AD0(void *a1);
char __cdecl sub_10053AF0(void *a1);
bool __thiscall sub_10053C40(void *this);
char __cdecl sub_10053C60(int a1, char a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_10053E00(char a1);
// __int16 __usercall sub_10053E40@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10053E50(unsigned __int8 a1, char *a2);
char __cdecl sub_10053F20(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_10053FA0(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_100540B0(char a1);
char __cdecl sub_10054100(char a1, int a2);
// int __usercall sub_10054270@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_100542B0@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_100542F0();
char __cdecl sub_10054300(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_10054360(char a1, void *a2);
char __cdecl sub_10054480(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10054500(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
char __cdecl sub_100546B0(char a1);
char __cdecl sub_100546E0(char a1);
int __cdecl sub_10054700(int a1, int a2);
int __cdecl sub_10054720(int a1, int a2, int a3);
int __cdecl sub_10054740(char a1, int a2, int a3, int a4);
char __cdecl sub_10054760(int a1, int a2, char a3);
int __cdecl sub_10054780(int a1, int a2);
char __cdecl sub_100547C0(char a1);
char __thiscall sub_100547E0(void *this);
__int16 __thiscall sub_10054810(void *this);
char __cdecl sub_10054830(void *a1);
char __cdecl sub_10054860(int a1, char a2, char a3);
char __cdecl sub_10054890(char a1, char a2);
char __cdecl sub_100548C0(char a1, char a2);
int __cdecl sub_100548F0(int a1);
char sub_10054CB0();
char __cdecl sub_10054D80(int a1);
char __cdecl sub_10054DE0(int a1);
int __cdecl sub_10055020(int a1);
int __cdecl sub_10055080(char a1);
char __cdecl sub_10055110(int a1);
void sub_100553F0();
void __cdecl sub_10055650(int a1);
double __cdecl sub_10055730(float a1, char a2);
void __cdecl sub_10055870(int a1);
void sub_100558C0();
char sub_10055910();
unsigned __int8 __cdecl sub_10055920(int a1);
int __cdecl sub_100559C0(void *); // idb
char sub_100559F0();
signed int __cdecl sub_10055A60(unsigned __int8 a1);
char __cdecl sub_10055B90(int a1, int a2);
char __cdecl sub_10055BE0(int a1, int a2);
char __cdecl sub_10055C90(int a1, int a2);
char __cdecl sub_10055CF0(int a1, int a2);
char __thiscall sub_10055DC0(void *this);
// _DWORD *__usercall sub_10055DE0@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4);
int sub_10055E10(); // weak
int sub_10055E70(); // weak
char __cdecl sub_10055EC0(int a1, int a2);
_DWORD *sub_10055FC0();
int __cdecl sub_10056050(int, float); // idb
int __cdecl sub_10056070(int, float); // idb
int __cdecl sub_10056090(unsigned __int8 *a1);
int __cdecl sub_100560B0(unsigned __int8 *a1, int a2);
char __cdecl sub_100560E0(unsigned __int8 a1);
signed int sub_10056140();
// char __usercall sub_10056150@<al>(unsigned __int8 a1@<al>, char a2, void *a3);
char __cdecl sub_10056230(int a1, char a2, void *a3);
char __cdecl sub_100562B0(int a1, void *a2);
char __cdecl sub_100562D0(_DWORD *a1);
int __cdecl sub_10056340(char a1);
// int __usercall sub_10056350@<eax>(char *a1@<eax>, char a2@<cl>);
// char __usercall sub_10056360@<al>(char a1@<bl>, char a2);
char __cdecl sub_10056420(char a1, char a2);
bool __cdecl sub_10056440(void *a1);
char __cdecl sub_10056480(char a1);
char __cdecl sub_100564B0(char a1);
char sub_100564E0();
char sub_100564F0();
// signed int __usercall sub_10056570@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10057620@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_10057680@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_10058400@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_10058420(int a1, unsigned int a2);
// int __usercall sub_10058480@<eax>(int result@<eax>);
// int __usercall sub_100584C0@<eax>(int result@<eax>);
// unsigned int __usercall sub_10059BE0@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_10059CE0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_10059D60@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_10059E00@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_10059EC0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_10059F20@<eax>(char *a1@<edi>);
// int __usercall sub_10059FE0@<eax>(int a1@<ebx>);
char __cdecl sub_1005A0A0(char *a1, size_t a2, int a3);
char __cdecl sub_1005A0F0(char *a1, unsigned int a2, int a3);
bool __cdecl sub_1005A140(int a1, int a2);
// int __usercall sub_1005A170@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_1005A380@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_1005A3D0(int a1, int a2);
signed int __cdecl sub_1005A460(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_1005A590(void *a1, int a2);
// BOOL __usercall sub_1005A610@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1005A6B0@<eax>(int result@<eax>);
unsigned int __fastcall sub_1005A740(unsigned int a1, int a2);
// int __usercall sub_1005A760@<eax>(int result@<eax>);
// int __usercall sub_1005A7F0@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_1005AC70@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_1005AD20@<eax>(int a1@<edi>);
// int __usercall sub_1005AD80@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_1005AF50@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_1005AFD0(int a1, int a2);
// signed int __usercall sub_1005B040@<eax>(int a1@<esi>);
// unsigned int __usercall sub_1005B100@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_1005B2B0@<eax>(int a1@<esi>, int a2);
// int __usercall sub_1005B380@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_1005B430@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_1005B470@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_1005B4D0@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1005B5B0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
_WORD *__fastcall sub_1005BB50(int a1, int a2);
signed int __cdecl sub_1005BBB0(int a1);
// int __usercall sub_1005BC40@<eax>(int a1@<eax>);
// int __usercall sub_1005BE80@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_1005BF20@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_1005C100@<eax>(int a1@<edi>);
// int __usercall sub_1005C240@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_1005C4F0(int a1, int a2);
signed int __cdecl sub_1005C7B0(int a1, unsigned __int8 a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8);
// signed int __usercall sub_1005C960@<eax>(int a1@<eax>);
// _WORD *__usercall sub_1005CA30@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_1005CC50(int a1, int a2);
signed int __cdecl sub_1005CF60(int a1, int a2);
signed int __cdecl sub_1005D370(int a1, int a2);
int __cdecl sub_1005D4E0(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_1005D5E0(int a1);
// signed int __usercall sub_1005D600@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_1005DAA0@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_1005DAF0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_1005DB10(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_1005DEC0@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_1005E000@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_1005E050@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_1005E0F0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_1005E110(int a1, int a2, int a3, int a4);
signed int __cdecl sub_1005E200(int a1);
// int __usercall sub_1005E210@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1005E8B0@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_1005F290@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_1005F5C0(int a1, int a2);
int __cdecl sub_1005F5E0(int a1);
char __cdecl sub_1005F5F0(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_1005F630(const char *a1, int a2);
// char *__usercall sub_1005F6A0@<eax>(char *result@<eax>);
void __cdecl sub_1005F6D0(char *a1);
void __cdecl sub_1005F790(char *a1, char *a2);
void *__cdecl sub_1005F7F0(int a1);
int __cdecl sub_1005F980(int a1, int a2);
// char __usercall sub_1005FAC0@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_1005FB90(_DWORD *a1, char *a2);
BOOL __cdecl sub_1005FC70(unsigned int a1);
BOOL __cdecl sub_1005FC90(int a1);
_DWORD __cdecl sub_1005FCB0(_DWORD); // weak
unsigned int __cdecl sub_1005FCC0(int a1, char a2);
signed int __cdecl sub_1005FD20(void *a1, int a2, unsigned int a3);
int __cdecl sub_1005FD40(int a1, int a2, int a3);
char __cdecl sub_1005FD60(const char *a1, const char *a2);
int __cdecl sub_1005FEA0(int a1, int a2, unsigned int a3);
int sub_1005FF20();
void __cdecl sub_1005FF30(int a1);
int __cdecl sub_1005FF60(int a1);
bool __cdecl sub_1005FF80(int a1);
void *__cdecl sub_1005FFB0(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_1005FFF0@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_10060010@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_10060030(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_10060060(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_10060140(int a1, int a2, int a3);
// void *__usercall sub_100601F0@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_10060470(int a1, int a2);
char __cdecl sub_10060540(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_100605B0@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_10060910@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_10060A20(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_10060BB0(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_10060D00@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_10060E50(int a1, int a2);
signed int __cdecl sub_10060E90(int a1, int a2);
bool __cdecl sub_10060EF0(signed int a1);
int sub_10060F60();
char sub_10061280();
char sub_100614A0();
char sub_100616A0();
char sub_10061820();
char sub_100619A0();
char sub_10061B10();
char sub_10061C10();
char sub_10061D70();
char sub_10061ED0();
char sub_10062030();
char sub_100621A0();
char sub_10062300();
char sub_10062460();
char sub_10062680();
char sub_100627E0();
char sub_10062940();
char sub_10062AA0();
char sub_10062C10();
char sub_10062D70();
char sub_10062ED0();
char sub_100630F0();
char sub_100632F0();
char sub_10063470();
char sub_100635F0();
char sub_10063760();
char sub_10063850();
char sub_100639B0();
char sub_10063B10();
char sub_10063C70();
char sub_10063DE0();
char sub_10063F40();
char sub_100640A0();
char sub_100642A0();
char sub_10064400();
char sub_10064560();
char sub_100646C0();
char sub_10064830();
char sub_10064990();
char sub_10064AF0();
char sub_10065090();
char sub_100652A0();
char sub_10065490();
char sub_10065600();
char sub_10065770();
char sub_100658D0();
char sub_100659C0();
char sub_10065B20();
char sub_10065C80();
char sub_10065DE0();
char sub_10065F50();
char sub_100660B0();
char sub_10066210();
char sub_10066410();
char sub_10066570();
char sub_100666D0();
char sub_10066830();
char sub_100669A0();
char sub_10066B00();
char sub_10066C60();
char sub_10066E70();
char sub_10067060();
char sub_100671D0();
char sub_10067340();
char sub_100674A0();
char sub_10067590();
char sub_100676F0();
char sub_10067850();
char sub_100679B0();
char sub_10067B20();
char sub_10067C80();
char sub_10067DE0();
char sub_10067FE0();
char sub_10068140();
char sub_100682A0();
char sub_10068400();
char sub_10068570();
char sub_100686D0();
char **sub_10068830();
int __cdecl sub_10068840(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_10068860@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_10068870@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_10068AA0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10068AF0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10068B40(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_10068B90(int a1))(int);
int __cdecl sub_10068C10(int a1, int a2);
int (__cdecl *__cdecl sub_10068C90(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_10068CE0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10068D20(int a1, int a2, int a3))(int);
char __cdecl sub_10068D80(char a1);
char __cdecl sub_10068E00(char a1);
int __cdecl sub_10068E40(char a1, char a2);
// bool __usercall sub_10068EF0@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_10068F20@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_10068FC0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10069040(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_100690C0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10069140(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_100691C0(char a1);
bool __cdecl sub_10069260(char a1);
char __fastcall sub_10069300(int a1, int a2);
void __cdecl sub_100693B0(float a1, int a2);
void __cdecl sub_10069410(float a1, float a2, int a3);
void __cdecl sub_10069480(float a1, float a2, int a3);
int __cdecl sub_100694F0(int a1, int a2);
char __cdecl sub_10069510(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9);
int __cdecl sub_100695E0(char a1);
_DWORD __cdecl sub_10069610(char); // weak
int __cdecl sub_10069620(char a1, char *a2);
int __cdecl sub_10069670(int a1);
int sub_10069690();
int __cdecl sub_100696B0(int a1, int a2);
__int16 __cdecl sub_100696E0(int a1);
int sub_10069700();
int __cdecl sub_10069720(int a1, int a2, int a3, int a4);
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_10069760(int a1, int a2, int a3, int a4);
int __cdecl sub_10069790(int a1);
int __cdecl sub_100697B0(int a1);
int __cdecl sub_100697D0(int a1, int a2);
int __cdecl sub_10069800(int a1, int a2, int a3, int a4);
int __cdecl sub_10069830(int a1, int a2);
int __cdecl sub_10069860(int a1);
int __cdecl sub_10069880(int a1);
char __cdecl sub_100698A0(int a1, int a2);
int __cdecl sub_10069910(_BYTE *a1);
int __cdecl sub_10069950(int a1, int a2);
int __cdecl sub_10069980(int a1, int a2);
int __cdecl sub_100699A0(int, float); // idb
int __cdecl j_gdi_pvg_begin(_DWORD); // weak
int __cdecl j_gdi_pvg_bind_buffer(_DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD); // weak
int j_gdi_pvg_bind_video_cap_as_textmap(void); // weak
int __cdecl sub_10069A00(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_buffer_data(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_clear(_DWORD); // weak
int __cdecl sub_10069A80(float, float, float, float); // idb
int __cdecl sub_10069AB0(float, float, float, float); // idb
int __cdecl sub_10069AE0(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_gdi_pvg_color_u32(_DWORD); // weak
int __cdecl j_gdi_pvg_depth_func(_DWORD); // weak
int __cdecl j_gdi_pvg_disable(_DWORD); // weak
int __cdecl j_gdi_pvg_disable_client_state(_DWORD); // weak
int __cdecl j_gdi_pvg_draw_arrays(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_10069B70(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl j_gdi_pvg_enable(_DWORD); // weak
int __cdecl j_gdi_pvg_enable_client_state(_DWORD); // weak
int __stdcall j_gdi_pvg_end(_DWORD); // weak
int j_gdi_pvg_finish(void); // weak
int j_gdi_pvg_flush(void); // weak
int __cdecl sub_10069C10(float, float, float, float, float, float); // idb
int __cdecl j_gdi_pvg_gen_buffers(_DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_gen_textures(_DWORD, _DWORD); // weak
int sub_10069C70();
int __cdecl sub_10069C80(float); // idb
int __cdecl j_gdi_pvg_load_identity();
int __cdecl j_gdi_pvg_make_window_active(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_current(_DWORD); // weak
int __cdecl j_gdi_pvg_matrix_mode(_DWORD); // weak
int __cdecl sub_10069CD0(float, float, float, float, float, float); // idb
int j_gdi_pvg_pop_attrib(void); // weak
int j_gdi_pvg_pop_matrix(void); // weak
int __cdecl j_gdi_pvg_push_attrib(_DWORD); // weak
int j_gdi_pvg_push_matrix(void); // weak
int __cdecl sub_10069D50(float, float, float, float); // idb
int __cdecl sub_10069D80(float, float, float); // idb
int __cdecl sub_10069DB0(float, float); // idb
int __cdecl sub_10069DD0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10069E10(int, int, float); // idb
int __cdecl sub_10069E30(int a1, char a2, char a3, int a4, int a5, int a6, char a7, int a8, int a9, int a10);
int __cdecl j_gdi_pvg_tex_parameteri(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_text_out_verts(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_10069EB0(float, float, float); // idb
int j_gdi_pvg_update_display_wdw(void); // weak
int __cdecl sub_10069EF0(float, float); // idb
int __cdecl sub_10069F10(float, float, float); // idb
int __cdecl sub_10069F40(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_10069F90(int a1, int a2, int a3);
int __cdecl j_gdi_pvg_destroy_window(_DWORD); // weak
int sub_10069FD0();
int __cdecl sub_1006A020(int a1);
int __cdecl sub_1006A030(int a1);
int __cdecl sub_1006A040(int a1);
int __cdecl sub_1006A050(int a1);
int __fastcall j_reg_get_tag_hdr(_DWORD, _DWORD); // weak
int __cdecl sub_1006A0A0(int a1, int a2, int a3);
char __cdecl sub_1006A0C0(int a1, int a2, int a3);
int __cdecl sub_1006A100(int, void *, int, void *); // idb
int __cdecl sub_1006A140(int a1, int a2, int a3);
int __cdecl sub_1006A170(int a1, int a2, int a3);
int __cdecl sub_1006A190(int a1, int a2, int a3);
int __cdecl sub_1006A1B0(int a1, int a2, int a3);
int __cdecl sub_1006A210(int a1, int a2, int a3);
char __cdecl sub_1006A250(int a1, int a2, int a3);
char __cdecl sub_1006A290(int a1, _DWORD *a2, int a3, int a4, int a5, unsigned int a6);
int __cdecl sub_1006A3A0(int, void *, int, void *); // idb
char __cdecl sub_1006A3F0(_DWORD *a1);
int __cdecl sub_1006A450(unsigned int a1);
void __cdecl sub_1006A470(float a1, float a2, float a3, float a4, float a5, float a6, float a7);
void sub_1006A5B0();
int __cdecl sub_1006A5C0(int a1);
char __cdecl sub_1006A620(_DWORD *a1, int a2, int a3, _DWORD *a4, unsigned int a5);
int sub_1006A6B0();
signed int __fastcall sub_1006A6E0(char *a1);
// char __usercall sub_1006A730@<al>(int a1@<eax>, char *a2@<ecx>, unsigned int a3);
// int __usercall sub_1006A800@<eax>(unsigned int a1@<eax>);
int __cdecl sub_1006A810(int, int, char *); // idb
// int __usercall sub_1006A900@<eax>(_BYTE *a1@<eax>, signed int a2@<ecx>, signed int a3, int a4, int a5, _BYTE *a6);
_BYTE *__cdecl sub_1006A9E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
double __cdecl sub_1006AAF0(int a1, int a2, float a3, float a4, float a5);
double __cdecl sub_1006AC90(int a1, int a2, float a3);
unsigned int __cdecl sub_1006ACF0(char *a1);
char __cdecl sub_1006AD60(char *a1);
bool __cdecl sub_1006AF40(char *a1, int a2, int a3, int a4, int a5);
char __cdecl sub_1006B180(char *a1);
int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD); // weak
signed int __cdecl sub_1006B1D0(unsigned int a1);
signed int __cdecl sub_1006B210(unsigned int a1);
int __cdecl j_FIL_vfs_copy(_DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_crc32(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl j_FIL_vfs_ioctl(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1006B280(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_1006B2F0(unsigned int a1, void *a2, int a3);
int __cdecl j_FIL_vfs_read_dir_cnt(_DWORD, _DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_1006B340(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_rmdir(_DWORD); // weak
signed int __cdecl sub_1006B3E0(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_1006B430(int a1);
int j_FIL_vfs_sync_all(void); // weak
int __cdecl sub_1006B460(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1006B490(int a1, int a2, int a3, char a4);
unsigned int __cdecl sub_1006B4B0(int a1, int a2);
char __cdecl sub_1006B510(int a1);
int __cdecl sub_1006B540(char *, size_t, int, int); // idb
int __cdecl sub_1006B740(int a1, int a2, int a3);
signed int __cdecl sub_1006B760(unsigned int a1, int a2, int a3);
int __cdecl sub_1006B780(int a1, int a2, int a3);
int __cdecl sub_1006B7A0(const char *a1);
__int16 __cdecl sub_1006B970(int a1, int a2, int a3, int a4);
const char *__cdecl sub_1006B9A0(int a1);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
__int16 __cdecl sub_1006B9E0(int a1, _DWORD *a2, _BYTE *a3);
void __cdecl sub_1006BA40(int a1, _BYTE *a2);
int __cdecl sub_1006BA70(int a1, int a2);
int j_HWM_pvg_dspl_bklt_calc_led_temp(void); // weak
int __cdecl j_HWM_pvg_dspl_bklt_get_actv_led_calib(_DWORD); // weak
int __cdecl j_HWM_pvg_dspl_bklt_get_intnsty(_DWORD); // weak
int __cdecl j_HWM_pvg_dspl_bklt_set_led_calib(_DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_dspl_bklt_set_rgb_pwm(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_ethr_get_stats(_DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_get_anlg_outp(_DWORD); // weak
int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_get_frmt_adc(_DWORD); // weak
int __cdecl j_HWM_pvg_get_raw_adc(_DWORD); // weak
int __cdecl j_HWM_pvg_get_real_baud(_DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_get_uart(_DWORD, _DWORD, _DWORD); // weak
int __fastcall j_HWM_pvg_hsdb_get_lrus_online(_DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_hsdb_get_stats(_DWORD); // weak
int j_HWM_pvg_is_video_conn(void); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_lpbk_ethr(_DWORD); // weak
int __cdecl j_HWM_pvg_lpbk_uart(_DWORD); // weak
int __cdecl j_HWM_pvg_put_uart(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_read_keys(_DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
int __cdecl j_HWM_pvg_set_anlg_outp(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_set_decoder_cfg(_DWORD); // weak
int __cdecl j_HWM_pvg_set_reg(_DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_set_uart(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_uart_tx_busy(_DWORD); // weak
int sub_1006BC30();
// int __usercall sub_1006BC50@<eax>(int a1@<eax>);
int __cdecl sub_1006BC60(__int16 a1);
signed int __cdecl sub_1006BC90(__int16 a1, char a2);
unsigned int __cdecl sub_1006BE10(__int16 a1);
unsigned int __cdecl sub_1006BE60(char a1);
signed int __cdecl sub_1006C0E0(__int16 *a1, char a2);
// int _RTC_NumErrors(void); weak
bool sub_1006C1E0();
__int16 __cdecl sub_1006C200(unsigned __int16 a1);
char __cdecl sub_1006C280(int a1);
signed int sub_1006C2C0();
__int16 sub_1006C2E0();
int __cdecl j_HWM_pvg_dspl_bklt_set_cnfg(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1006C330(int a1);
int __cdecl sub_1006C370(int a1);
int __cdecl sub_1006C3B0(int a1);
int __cdecl sub_1006C3F0(int a1);
int __cdecl sub_1006C430(int a1, int a2, int a3, int a4);
int __cdecl sub_1006C4A0(int a1, int a2, int a3);
int sub_1006C540(void); // weak
int __cdecl sub_1006C550(int a1, int a2);
// int __usercall sub_1006C5B0@<eax>(const char **a1@<esi>);
// int __usercall sub_1006C8B0@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_1006C8D0(int a1);
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_1006C9E0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_1006CA30(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
int sub_1006CAA0(void); // weak
char __cdecl sub_1006CAB0(unsigned int a1, unsigned int *a2, int *a3);
signed int sub_1006CD80();
int __cdecl sub_1006CD90(unsigned int a1);
unsigned int __cdecl sub_1006CDF0(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_1006CFA0@<eax>(int a1@<esi>);
int __cdecl sub_1006D050(int a1, unsigned __int64 a2);
// int __usercall sub_1006D100@<eax>(int a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_1006D190(int a1, void *a2, int a3, int a4, int a5);
void __cdecl sub_1006D2E0(__int16 a1, _BYTE *a2);
int __cdecl j_HWM_pvg_arnc_close(_DWORD); // weak
int __cdecl j_HWM_pvg_arnc_ioctl(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_arnc_open(_DWORD); // weak
int __cdecl sub_1006D340(int a1, int a2);
// char __usercall sub_1006D3D0@<al>(size_t a1@<eax>, void *a2@<ebx>, size_t a3@<edi>);
char __cdecl sub_1006D470(int a1, unsigned int a2, unsigned int a3, size_t a4);
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
// int __cdecl SIM_proc_rqst(_DWORD); weak
// int SYS_exit_krnl(void); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int SYS_enter_krnl(void); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_set_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl gdi_pvg_alpha_func(_DWORD, _DWORD); weak
// int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_clear_color(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_color4f(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_color_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_frustum(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int gdi_pvg_init(void); weak
// int __cdecl gdi_pvg_line_width(_DWORD); weak
// int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_rotatef(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_scalef(_DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_tex_coord2f(_DWORD, _DWORD); weak
// int __cdecl gdi_pvg_tex_coord_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_tex_envf(_DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_tex_image_2d(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_translatef(_DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_vertex2f(_DWORD, _DWORD); weak
// int __cdecl gdi_pvg_vertex3f(_DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_vertex_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_create_window(_DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_close(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD); weak
// int __cdecl HWM_pvg_test_dev(_DWORD); weak
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// void *__cdecl memset(void *, int, size_t);
// char *__cdecl strncpy(char *, const char *, size_t);
// char *__cdecl strchr(const char *, int);
__int32 __cdecl j__atol(const char *);
// char *__cdecl strstr(const char *, const char *);
// int _snprintf(char *, size_t, const char *, ...);
// int sprintf(char *, const char *, ...);
// char *__cdecl strncat(char *, const char *, size_t);
// void *__cdecl memcpy(void *, const void *, size_t);
// int __cdecl rand();
// void *__cdecl memcpy_0(void *, const void *, size_t);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// double __cdecl atof(const char *);
// int __cdecl strncmp(const char *, const char *, size_t);
// int __cdecl isalpha(int);
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isalnum(int);
// int __cdecl isprint(int);
// char *__cdecl strrchr(const char *, int);
// int __cdecl toupper(int);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_10070073(int a1, int a2, char a3);
// double __cdecl floor(double);
// char *__cdecl strpbrk(const char *, const char *);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
int __cdecl sub_100714DC(int, FILE *); // idb
int __cdecl sub_10072071(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
signed int __cdecl sub_100729D3(_DWORD *a1);
signed int __cdecl sub_10072A0A(_DWORD *a1);
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_1007302B();
int (*sub_100734D8())(void);
void __cdecl sub_100734FC(); // idb
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl isleadbyte(int);
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_10078B0F(FILE *, int, struct localeinfo_struct *, int); // idb
// int _get_sse2_info(void); weak
int sub_1007A360();
void sub_1007A36D();
int __cdecl sub_1007A375(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_1007A41B(int, int, struct localeinfo_struct *); // idb
DWORD __cdecl sub_1007A925(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_1007AAC1(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_1007B0E3(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_1007B203(signed int a1);
void **sub_1007B261();
signed int sub_1007B267();
// int __cdecl _fileno(FILE *);
int sub_1007BB32();
int __cdecl sub_1007BCEF(int a1);
int __cdecl sub_1007BCF9(int a1);
int __cdecl sub_1007BD03(int a1);
int __cdecl sub_1007BDE2(int a1);
signed int __cdecl sub_1007D709(int a1, int a2);
signed int __cdecl sub_1007DC4B(int a1, int a2);
int __cdecl sub_1007E58C(FILE *); // idb
int __cdecl sub_1007E6AC(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
int sub_1007E8F4();
signed int __cdecl sub_1007FDD0(signed int a1);
signed int __cdecl sub_1007FE51(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_1007FF62(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_10080263();
int __cdecl sub_1008026C(int a1, int a2, int a3);
// int __cdecl _read(int, void *, unsigned int);
signed int __cdecl sub_10081081(signed int a1);
double __cdecl sub_10081220(char a1);
signed int __cdecl sub_100812B0(char a1);
char sub_100812D0();
bool __cdecl sub_10081390(void *a1);
char sub_100813E0();
double __cdecl sub_10081430(float a1);
int __cdecl sub_10081460(int a1, signed int a2, int a3, char a4);
int __cdecl sub_100818F0(int a1, signed int a2, int a3, int a4, int a5);
double __cdecl sub_10081FE0(int a1);
int __cdecl sub_10082020(float, int, int); // idb
int __cdecl sub_10082040(int a1, int a2, int a3);
int __cdecl sub_10082060(int a1, int a2);
void __cdecl sub_10082080(int a1, int a2);
// int __cdecl BMP_get_bm_def(_DWORD); weak
// int __cdecl BMP_get_xfrm(_DWORD); weak
// int TXT_get_static_string(void); weak
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN j_j_FIL_vfs_write; // weak
_UNKNOWN loc_1005DFC0; // weak
_UNKNOWN unk_10084524; // weak
char byte_10084570[4] = { '\0', '\0', '\0', '\0' }; // idb
_UNKNOWN unk_10084574; // weak
int dword_10084B28[] = { 49 }; // weak
int (__cdecl *off_10084B2C)(int, int, int, int, int) = &sub_1002E020; // weak
int dword_10084B30[] = { 16 }; // weak
int dword_10084B34[] = { 10 }; // weak
int (__cdecl *off_10084B38)(int, int, int, int, int) = &sub_100347F0; // weak
int dword_10084B3C[] = { 12 }; // weak
int dword_10084B40[] = { 12 }; // weak
int (__cdecl *off_10084B44)(int, int, int, int, int) = &sub_1002BEB0; // weak
int dword_10084B48[] = { 4 }; // weak
int dword_10084B4C[] = { 18 }; // weak
int (__cdecl *off_10084B50)(int, int, int, int, int) = &sub_10038130; // weak
int dword_10084B54[] = { 4 }; // weak
int dword_10084B58[] = { 24 }; // weak
int (__cdecl *off_10084B5C)(int, int, int, int, int) = &sub_10033C00; // weak
int dword_10084B60[] = { 80 }; // weak
int dword_10084B64[] = { 27 }; // weak
int (__cdecl *off_10084B68)(int, int, int, int, int) = &sub_10037AD0; // weak
int dword_10084B6C[] = { 4 }; // weak
_UNKNOWN unk_10085288; // weak
_UNKNOWN unk_10085290; // weak
_UNKNOWN unk_100852B0; // weak
_UNKNOWN unk_1008660E; // weak
_UNKNOWN unk_10086BB4; // weak
char byte_10086BF8[] = { '\x04' }; // weak
_UNKNOWN unk_10086D20; // weak
_UNKNOWN unk_10086DA8; // weak
_UNKNOWN unk_10086EB8; // weak
_UNKNOWN unk_10086F40; // weak
_UNKNOWN unk_10086FC8; // weak
_UNKNOWN unk_10087000; // weak
_UNKNOWN unk_10087004; // weak
_UNKNOWN unk_10087008; // weak
_UNKNOWN unk_1008700C; // weak
_UNKNOWN unk_10087010; // weak
_UNKNOWN unk_10087014; // weak
_UNKNOWN unk_1008701C; // weak
_UNKNOWN unk_10087024; // weak
_UNKNOWN unk_10087030; // weak
_UNKNOWN unk_1008703C; // weak
_UNKNOWN unk_10087048; // weak
_UNKNOWN unk_10087054; // weak
_UNKNOWN unk_10087060; // weak
_UNKNOWN unk_1008706C; // weak
char aAirframe[9] = "AIRFRAME"; // weak
_UNKNOWN unk_100871D8; // weak
char byte_10088B78[] = { '\x03' }; // weak
int dword_10088B7C[] = { 4 }; // weak
__int16 word_10088B80[] = { 4553 }; // weak
void *off_10088B84 = &unk_10086FAC; // weak
char byte_10088BA8[] = { '\x02' }; // weak
_DWORD off_10088BAC[2] = { 268985808, 1 }; // idb
char byte_10088BD8[] = { '\0' }; // weak
_UNKNOWN off_10088BDC; // idb
char *off_10088BEC = "ERASE FAIL"; // weak
_UNKNOWN unk_10088C64; // weak
char word_10088C68[] = { ' ', '\0' }; // idb
__int16 word_100893F8[] = { 2588 }; // weak
_UNKNOWN unk_100893FC; // weak
_UNKNOWN unk_10089430; // weak
_UNKNOWN unk_100896B8; // weak
_UNKNOWN unk_100897A4; // weak
_UNKNOWN unk_100897C0; // weak
_UNKNOWN unk_10089810; // weak
_UNKNOWN unk_100899D0; // weak
_UNKNOWN unk_10089B30; // weak
void *off_10089BD0 = &unk_10089AF4; // weak
void *off_10089C0C = &unk_10089B24; // weak
_UNKNOWN unk_10089C1C; // weak
char byte_10089C1D[] = { '\x01' }; // weak
_UNKNOWN unk_1008A3A4; // weak
_UNKNOWN unk_1008A3A8; // weak
_UNKNOWN unk_1008A3D4; // weak
_UNKNOWN unk_1008A3E0; // weak
_UNKNOWN unk_1008A3F0; // weak
_UNKNOWN unk_1008A3FC; // weak
_UNKNOWN unk_1008A40A; // weak
char byte_1008A428[] = { '\x03' }; // weak
char byte_1008A429[] = { '\x02' }; // weak
_UNKNOWN unk_1008A43F; // weak
_UNKNOWN unk_1008A46C; // weak
_UNKNOWN unk_1008A480; // weak
_UNKNOWN unk_1008A4B8; // weak
_UNKNOWN unk_1008A91C; // weak
_UNKNOWN unk_1008A940; // weak
_UNKNOWN unk_1008A9E4; // weak
_UNKNOWN unk_1008AA08; // weak
_UNKNOWN unk_1008AA3C; // weak
_UNKNOWN unk_1008AA70; // weak
_UNKNOWN unk_1008AA98; // weak
_UNKNOWN unk_1008ADA0; // weak
_UNKNOWN unk_1008AF70; // weak
_UNKNOWN unk_1008B4B0; // weak
_UNKNOWN unk_1008B9E0; // weak
_UNKNOWN unk_1008B9E4; // weak
_UNKNOWN unk_1008B9E8; // weak
_UNKNOWN unk_1008B9EC; // weak
_UNKNOWN unk_1008B9F8; // weak
_UNKNOWN unk_1008BA08; // weak
_UNKNOWN unk_1008BB24; // weak
void *off_1008BB50 = &unk_1008B910; // weak
void *off_1008BB5C = &unk_1008B918; // weak
void *off_1008BB68 = &unk_1008B920; // weak
void *off_1008BB78 = &unk_1008B92C; // weak
void *off_1008BB88 = &unk_1008B938; // weak
_UNKNOWN unk_1008BB94; // weak
void *off_1008BB98 = &unk_1008B940; // weak
_UNKNOWN unk_1008BC5C; // weak
_UNKNOWN unk_1008BC6C; // weak
_UNKNOWN unk_1008BC7C; // weak
_UNKNOWN unk_1008BC9C; // weak
_UNKNOWN unk_1008BCBC; // weak
_UNKNOWN unk_1008BCDC; // weak
_UNKNOWN unk_1008BCFC; // weak
int dword_1008BD00[] = { 3535 }; // weak
_UNKNOWN unk_1008C9E0; // weak
_UNKNOWN unk_1008C9F0; // weak
_UNKNOWN unk_1008C9F8; // weak
__int16 word_1008C9FC[] = { 10 }; // weak
__int16 word_1008C9FE[] = { 4 }; // weak
_UNKNOWN unk_1008D018; // weak
_UNKNOWN unk_1008D028; // weak
_UNKNOWN unk_1008D5D8; // weak
__int16 word_1008D5E4[] = { 4748 }; // weak
_UNKNOWN unk_1008D5F4; // weak
_UNKNOWN unk_1008D624; // weak
_UNKNOWN unk_1008D63C; // weak
_UNKNOWN unk_1008D66C; // weak
_UNKNOWN unk_1008D670; // weak
__int16 word_1008D680[] = { 4748 }; // weak
_UNKNOWN unk_1008D716; // weak
_UNKNOWN unk_1008D717; // weak
_UNKNOWN unk_1008DC90; // weak
_UNKNOWN unk_1008DC94; // weak
_UNKNOWN unk_1008DC98; // weak
_UNKNOWN unk_1008DCA0; // weak
_UNKNOWN unk_1008DCA8; // weak
char aAlignment[10] = "Alignment"; // weak
_UNKNOWN unk_1008DDE8; // weak
_UNKNOWN unk_1008DDEC; // weak
_UNKNOWN unk_1008DE24; // weak
_UNKNOWN unk_1008DEE8; // weak
_UNKNOWN unk_1008E118; // weak
_UNKNOWN unk_1008E418; // weak
char aMntCard0[11] = "/mnt/card0"; // weak
_UNKNOWN unk_1008EB50; // weak
_UNKNOWN unk_1008EB60; // weak
_UNKNOWN unk_1008F3B0; // weak
_UNKNOWN unk_1008F3D8; // weak
_UNKNOWN unk_1008F718; // weak
_UNKNOWN unk_1008FD60; // weak
_UNKNOWN unk_10090080; // weak
_UNKNOWN unk_10090158; // weak
_UNKNOWN unk_1009045C; // weak
_UNKNOWN unk_10090460; // weak
_UNKNOWN unk_10090464; // weak
_UNKNOWN unk_10090468; // weak
_UNKNOWN unk_10090470; // weak
int dword_10090534[] = { 2490428 }; // weak
int dword_10090540[] = { 23592972 }; // weak
int dword_10090588[] = { 48300051 }; // weak
int dword_100905B8[] = { 4980804 }; // weak
int dword_100905C0[] = { 1638432 }; // weak
int dword_10090650[] = { 12058684 }; // weak
int dword_10090660[] = { 19595324 }; // weak
_UNKNOWN unk_10090678; // weak
_UNKNOWN unk_1009067C; // weak
_UNKNOWN unk_10090680; // weak
_UNKNOWN unk_10090684; // weak
_UNKNOWN unk_10090688; // weak
_UNKNOWN unk_1009068C; // weak
_UNKNOWN unk_10090690; // weak
__int16 word_10090692[] = { 16388 }; // weak
_UNKNOWN unk_10090BF4; // weak
float flt_10090BF8[] = {  1.0 }; // weak
_UNKNOWN unk_10090C30; // weak
float flt_10090C34[] = {  0.0 }; // weak
_UNKNOWN unk_10090C50; // weak
_UNKNOWN unk_10090C88; // weak
_UNKNOWN unk_10091430; // weak
_UNKNOWN unk_10091480; // weak
_UNKNOWN unk_10091574; // weak
_UNKNOWN unk_10091580; // weak
_UNKNOWN unk_10091610; // weak
_UNKNOWN unk_10091E38; // weak
char asc_10092000[3] = "\r\n"; // weak
__int16 word_10092290 = 47; // weak
void *off_100932DC = &unk_10319590; // weak
float flt_100932EC[] = { -1.9 }; // weak
float flt_100932F0[] = {  0.0 }; // weak
char byte_10093F04[] = { '\0' }; // weak
int (__cdecl *off_10093F10)(int) = &sub_10014950; // weak
char byte_10093F14[] = { '\0' }; // weak
char aKeyTest[9] = "KEY TEST"; // weak
_UNKNOWN unk_100952A0; // weak
_UNKNOWN unk_10095390; // weak
_UNKNOWN unk_10095450; // weak
_UNKNOWN unk_10095478; // weak
_UNKNOWN unk_10095538; // weak
_UNKNOWN unk_100955F0; // weak
_UNKNOWN unk_100956A0; // weak
_UNKNOWN unk_100957C8; // weak
_UNKNOWN unk_10095868; // weak
_UNKNOWN unk_10095888; // weak
_UNKNOWN unk_100958C0; // weak
_UNKNOWN unk_100959C4; // weak
_UNKNOWN unk_10095A00; // weak
_UNKNOWN unk_10095A70; // weak
_UNKNOWN unk_10095B10; // weak
char byte_10095B11[] = { '\x17' }; // weak
_UNKNOWN unk_100960E0; // weak
__int16 word_100960E2[] = { 4856 }; // weak
char *off_100986B0[9] =
{
  "bad_blks0.dat",
  "bad_blks1.dat",
  "/reg_krnl.reg",
  "bad_blks0.dat",
  "bad_blks1.dat",
  "/reg_krnl.reg",
  "/mnt/sys_nand0/sys_files.gca",
  "sys_krnl.bin",
  "bmap.bin"
}; // weak
char *off_100986BC[6] =
{
  "bad_blks0.dat",
  "bad_blks1.dat",
  "/reg_krnl.reg",
  "/mnt/sys_nand0/sys_files.gca",
  "sys_krnl.bin",
  "bmap.bin"
}; // weak
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
char byte_10099608[] = { '\0' }; // weak
char byte_10099614[12] =
{
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\xFF',
  '\0',
  '\x01',
  '\0'
}; // idb
int (__cdecl *off_10099620[16])(int, int) =
{
  &sub_10021D50,
  &sub_10021D50,
  &sub_10021D50,
  &sub_10021F00,
  &sub_10021F00,
  &sub_10021F00,
  &sub_10021F00,
  &sub_10021D50,
  &sub_10021B10,
  &sub_10021AC0,
  &sub_10021AC0,
  &sub_10021B10,
  &sub_10021B10,
  &sub_10021AC0,
  &sub_10021AC0,
  &sub_10021B10
}; // weak
int (__cdecl *off_10099640[8])(int, int) =
{
  &sub_10021B10,
  &sub_10021AC0,
  &sub_10021AC0,
  &sub_10021B10,
  &sub_10021B10,
  &sub_10021AC0,
  &sub_10021AC0,
  &sub_10021B10
}; // weak
int dword_10099668 = 0; // idb
char *off_10099A80[3] = { "04T1", "04B1", "04A1" }; // weak
__int16 word_10099C78[] = { 0 }; // weak
__int16 word_10099E78[] = { 0 }; // weak
int dword_1009A078[] = { 0 }; // weak
char *off_1009CAA0[2] = { "%02d:%02u", "__:__" }; // weak
char *off_1009CAA4 = "__:__"; // weak
char byte_1009CAA8[] = { '9' }; // weak
char a03d02u[11] = "%+03d:%02u"; // weak
int dword_1009CAD0 = 1; // weak
__int16 word_1009CAD4[] = { 99 }; // weak
int dword_1009CAD8 = 4; // weak
char byte_1009CADC[] = { '\0' }; // weak
char byte_1009CADD[] = { '\x01' }; // weak
char byte_1009CD60[] = { '#' }; // weak
char *off_1009FB44 = "%02u-%3s-%02u"; // idb
char *off_1009FB48 = "__-___-__"; // weak
char byte_1009FB4C[] = { '\x06' }; // weak
char byte_1009FB4D[] = { '\x03' }; // weak
int dword_1009FB50[] = { 3 }; // weak
int dword_1009FB54[] = { 0 }; // weak
int dword_1009FB58[] = { 7 }; // weak
char byte_1009FB5C[] = { '\x01' }; // weak
_UNKNOWN unk_100A1D5C; // weak
float flt_100A1D60[] = {  1.0 }; // weak
float flt_100A1D64[] = {  0.050000001 }; // weak
char byte_100A1DB8[] = { '\0' }; // weak
char byte_100A1E40[4] = { '\0', '\0', '\0', '\0' }; // idb
_UNKNOWN unk_100A3EE6; // weak
_UNKNOWN unk_100A4410; // weak
char aMntCard1[11] = "/mnt/card1"; // weak
_UNKNOWN unk_100A55E0; // weak
__int16 word_100A55E2[] = { 553 }; // weak
_UNKNOWN unk_100A55EC; // weak
int dword_100A55F0[] = { 1 }; // weak
int dword_100A55F4[] = { 4 }; // weak
__int16 word_100A5BE0[] = { 7220 }; // weak
__int16 word_100A5BE2[] = { 4727 }; // weak
char byte_100A5BFC[] = { '\x01' }; // weak
_UNKNOWN unk_100A5C0C; // weak
_UNKNOWN unk_100A5C10; // weak
_UNKNOWN unk_100A5C14; // weak
__int16 word_100A5C36[] = { 0 }; // weak
__int16 word_100A5C38[] = { 4094 }; // weak
_UNKNOWN unk_100A5C4E; // weak
_UNKNOWN unk_100A619D; // weak
_UNKNOWN unk_100A61D6; // weak
char byte_100A61D8[] = { '\x0E' }; // weak
__int16 word_100A72E8[] = { 65 }; // weak
int dword_100A7308[] = { 4196400 }; // weak
__int16 word_100A7348[] = { 4321 }; // weak
__int16 word_100A7368[] = { 4355 }; // weak
__int16 word_100A7388[] = { 33 }; // weak
__int16 word_100A7F38 = 48; // weak
_UNKNOWN unk_100AA1A8; // weak
int dword_100AA1AC[] = { 8 }; // weak
__int16 word_100AA1B0[] = { 3413 }; // weak
_UNKNOWN unk_100AA328; // weak
__int16 word_100AA330[] = { 3423 }; // weak
_UNKNOWN unk_100AA368; // weak
__int16 word_100AA36A[] = { 3178 }; // weak
char aWgs84[21] = "WGS 84              "; // weak
_UNKNOWN unk_100AE0F0; // weak
_UNKNOWN unk_100AF234; // weak
char byte_100AF235[] = { '\x0E' }; // weak
int dword_100AF250[] = { 1 }; // weak
_UNKNOWN off_100AF254; // idb
_UNKNOWN unk_100AF330; // weak
__int16 word_100AF334[] = { 2 }; // weak
_UNKNOWN unk_100AF354; // weak
_UNKNOWN unk_100AF898; // weak
int dword_100AF89C[] = { 41107 }; // weak
_UNKNOWN unk_100AF8B0; // weak
__int16 word_100B03EC[] = { 81 }; // weak
_UNKNOWN unk_100B096C; // weak
_UNKNOWN unk_100B0974; // weak
_UNKNOWN unk_100B097C; // weak
_UNKNOWN unk_100B0984; // weak
_UNKNOWN unk_100B0A30; // weak
void *off_100B0A34 = &unk_100B09A4; // weak
void *off_100B1848 = &unk_100B129C; // weak
int dword_100B3100[] = { 0 }; // weak
_UNKNOWN unk_100B3370; // weak
_UNKNOWN unk_100B3440; // weak
_UNKNOWN unk_100B3510; // weak
_UNKNOWN unk_100B35E0; // weak
_UNKNOWN unk_100B36B0; // weak
_UNKNOWN unk_100B3780; // weak
_UNKNOWN unk_100B3850; // weak
_UNKNOWN unk_100B3920; // weak
_UNKNOWN unk_100B39F0; // weak
_UNKNOWN unk_100B3AC0; // weak
_UNKNOWN unk_100B3B90; // weak
_UNKNOWN unk_100B3C60; // weak
_UNKNOWN unk_100B3D30; // weak
_UNKNOWN unk_100B3E00; // weak
_UNKNOWN unk_100B3ED0; // weak
_UNKNOWN unk_100B3FA0; // weak
_UNKNOWN unk_100B4070; // weak
_UNKNOWN unk_100B4140; // weak
_UNKNOWN unk_100B4210; // weak
_UNKNOWN unk_100B42E0; // weak
_UNKNOWN unk_100B43B0; // weak
_UNKNOWN unk_100B4480; // weak
_UNKNOWN unk_100B4550; // weak
_UNKNOWN unk_100B4620; // weak
_UNKNOWN unk_100B46F0; // weak
_UNKNOWN unk_100B47C0; // weak
_UNKNOWN unk_100B4890; // weak
_UNKNOWN unk_100B4960; // weak
_UNKNOWN unk_100B4A30; // weak
_UNKNOWN unk_100B4B00; // weak
_UNKNOWN unk_100B4BD0; // weak
_UNKNOWN unk_100B4CA0; // weak
_UNKNOWN unk_100B4D70; // weak
_UNKNOWN unk_100B4E40; // weak
_UNKNOWN unk_100B4F10; // weak
_UNKNOWN unk_100B4FE0; // weak
_UNKNOWN unk_100B50B0; // weak
_UNKNOWN unk_100B5180; // weak
_UNKNOWN unk_100B5250; // weak
_UNKNOWN unk_100B5320; // weak
_UNKNOWN unk_100B53F0; // weak
_UNKNOWN unk_100B54C0; // weak
_UNKNOWN unk_100B5590; // weak
_UNKNOWN unk_100B5660; // weak
_UNKNOWN unk_100B5730; // weak
_UNKNOWN unk_100B5800; // weak
_UNKNOWN unk_100B58D0; // weak
_UNKNOWN unk_100B59A0; // weak
_UNKNOWN unk_100B5A70; // weak
_UNKNOWN unk_100B5B40; // weak
_UNKNOWN unk_100B5C10; // weak
_UNKNOWN unk_100B5CE0; // weak
_UNKNOWN unk_100B5DB0; // weak
_UNKNOWN unk_100B5E80; // weak
_UNKNOWN unk_100B5F50; // weak
_UNKNOWN unk_100B6020; // weak
_UNKNOWN unk_100B60F0; // weak
_UNKNOWN unk_100B61C0; // weak
_UNKNOWN unk_100B6290; // weak
_UNKNOWN unk_100B6360; // weak
_UNKNOWN unk_100B6430; // weak
_UNKNOWN unk_100B6500; // weak
_UNKNOWN unk_100B65D0; // weak
_UNKNOWN unk_100B66A0; // weak
_UNKNOWN unk_100B6770; // weak
_UNKNOWN unk_100B6840; // weak
_UNKNOWN unk_100B6910; // weak
_UNKNOWN unk_100B7A40; // weak
__int16 word_100B7A42[] = { 338 }; // weak
char *off_100B7E50[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_100B7CC0 }; // weak
_UNKNOWN unk_100B7E64; // weak
_BYTE word_100B8FD0[2094] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  128,
  4,
  0,
  45,
  0,
  37,
  0,
  47,
  0,
  45,
  0,
  44,
  0,
  45,
  0,
  45,
  0,
  37,
  0,
  37,
  0,
  47,
  0,
  45,
  0,
  37,
  0,
  60,
  0,
  61,
  0,
  45,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  0,
  37,
  0,
  37,
  0,
  36,
  0,
  44,
  0,
  36,
  0,
  45,
  32,
  44,
  13,
  0,
  5,
  0,
  5,
  0,
  5,
  0,
  13,
  0,
  5,
  0,
  1,
  0,
  1,
  0,
  9,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  9,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  9,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  0,
  36,
  0,
  36,
  0,
  36,
  0,
  44,
  64,
  45,
  0,
  4,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  0,
  44,
  0,
  44,
  0,
  44,
  0,
  44,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  32,
  0,
  32,
  0,
  32,
  0,
  32,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2,
  23,
  21,
  3,
  3,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  18,
  10,
  18,
  10,
  28,
  14,
  29,
  14,
  29,
  14,
  29,
  10,
  29,
  10,
  28,
  10,
  24,
  10,
  24,
  0,
  24,
  0,
  23,
  0,
  22,
  0,
  23,
  0,
  23,
  0,
  23,
  0,
  28,
  0,
  24,
  0,
  22,
  0,
  20,
  10,
  24,
  10,
  18,
  10,
  20,
  10,
  24,
  10,
  13,
  10,
  20,
  10,
  28,
  10,
  18,
  0,
  22,
  0,
  22,
  0,
  20,
  0,
  18,
  10,
  18,
  0,
  28,
  0,
  23,
  0,
  22,
  10,
  28,
  10,
  22,
  10,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  0,
  1,
  0,
  136,
  25,
  0,
  0,
  1,
  0,
  1,
  0,
  137,
  25,
  0,
  0,
  2,
  0,
  1,
  0,
  138,
  25,
  0,
  0,
  4,
  0,
  1,
  0,
  139,
  25,
  0,
  0,
  5,
  0,
  1,
  0,
  140,
  25,
  0,
  0,
  6,
  0,
  1,
  0,
  141,
  25,
  0,
  0,
  18,
  0,
  1,
  0,
  142,
  25,
  0,
  0,
  19,
  0,
  1,
  0,
  143,
  25,
  0,
  0,
  20,
  0,
  1,
  0,
  144,
  25,
  0,
  0,
  21,
  0,
  1,
  0,
  145,
  25,
  0,
  0,
  22,
  0,
  1,
  0,
  146,
  25,
  0,
  0,
  23,
  0,
  1,
  0,
  147,
  25,
  0,
  0,
  25,
  0,
  1,
  0,
  148,
  25,
  0,
  0,
  26,
  0,
  1,
  0,
  149,
  25,
  0,
  0,
  27,
  0,
  1,
  0,
  150,
  25,
  0,
  0,
  28,
  0,
  1,
  0,
  151,
  25,
  0,
  0,
  29,
  0,
  1,
  0,
  152,
  25,
  0,
  0,
  30,
  0,
  1,
  0,
  153,
  25,
  0,
  0,
  31,
  0,
  1,
  0,
  154,
  25,
  0,
  0,
  32,
  0,
  4,
  0,
  155,
  25,
  0,
  0,
  36,
  0,
  4,
  0,
  156,
  25,
  0,
  0,
  40,
  0,
  1,
  0,
  157,
  25,
  0,
  0,
  41,
  0,
  1,
  0,
  158,
  25,
  0,
  0,
  42,
  0,
  1,
  0,
  159,
  25,
  0,
  0,
  43,
  0,
  1,
  0,
  160,
  25,
  0,
  0,
  44,
  0,
  1,
  0,
  161,
  25,
  0,
  0,
  45,
  0,
  1,
  0,
  162,
  25,
  0,
  0,
  46,
  0,
  1,
  0,
  163,
  25,
  0,
  0,
  47,
  0,
  1,
  0,
  164,
  25,
  0,
  0,
  49,
  0,
  1,
  0,
  166,
  25,
  0,
  0,
  50,
  0,
  30,
  0,
  167,
  25,
  0,
  0,
  80,
  0,
  1,
  0,
  168,
  25,
  0,
  0,
  81,
  0,
  1,
  0,
  169,
  25,
  0,
  0,
  84,
  0,
  4,
  0,
  170,
  25,
  0,
  0,
  88,
  0,
  1,
  0,
  171,
  25,
  0,
  0,
  89,
  0,
  1,
  0,
  172,
  25,
  0,
  0,
  92,
  0,
  4,
  0,
  173,
  25,
  0,
  0,
  96,
  0,
  4,
  0,
  174,
  25,
  0,
  0,
  100,
  0,
  1,
  0,
  175,
  25,
  0,
  0,
  208,
  0,
  4,
  0,
  168,
  23,
  0,
  0,
  104,
  0,
  1,
  0,
  177,
  25,
  0,
  0,
  105,
  0,
  1,
  0,
  178,
  25,
  0,
  0,
  106,
  0,
  1,
  0,
  179,
  25,
  0,
  0,
  107,
  0,
  1,
  0,
  180,
  25,
  0,
  0,
  108,
  0,
  1,
  0,
  181,
  25,
  0,
  0,
  109,
  0,
  1,
  0,
  182,
  25,
  0,
  0,
  110,
  0,
  1,
  0,
  183,
  25,
  0,
  0,
  111,
  0,
  1,
  0,
  184,
  25,
  0,
  0,
  112,
  0,
  1,
  0,
  185,
  25,
  0,
  0,
  113,
  0,
  1,
  0,
  186,
  25,
  0,
  0,
  114,
  0,
  1,
  0,
  187,
  25,
  0,
  0,
  115,
  0,
  1,
  0,
  188,
  25,
  0,
  0,
  116,
  0,
  1,
  0,
  189,
  25,
  0,
  0,
  117,
  0,
  1,
  0,
  190,
  25,
  0,
  0,
  118,
  0,
  1,
  0,
  191,
  25,
  0,
  0,
  120,
  0,
  4,
  0,
  192,
  25,
  0,
  0,
  124,
  0,
  4,
  0,
  193,
  25,
  0,
  0,
  128,
  0,
  4,
  0,
  194,
  25,
  0,
  0,
  132,
  0,
  4,
  0,
  195,
  25,
  0,
  0,
  136,
  0,
  4,
  0,
  196,
  25,
  0,
  0,
  140,
  0,
  1,
  0,
  197,
  25,
  0,
  0,
  141,
  0,
  1,
  0,
  198,
  25,
  0,
  0,
  142,
  0,
  1,
  0,
  199,
  25,
  0,
  0,
  144,
  0,
  2,
  0,
  200,
  25,
  0,
  0,
  146,
  0,
  1,
  0,
  201,
  25,
  0,
  0,
  147,
  0,
  1,
  0,
  202,
  25,
  0,
  0,
  148,
  0,
  1,
  0,
  203,
  25,
  0,
  0,
  149,
  0,
  1,
  0,
  204,
  25,
  0,
  0,
  150,
  0,
  1,
  0,
  205,
  25,
  0,
  0,
  151,
  0,
  1,
  0,
  206,
  25,
  0,
  0,
  152,
  0,
  1,
  0,
  207,
  25,
  0,
  0,
  153,
  0,
  1,
  0,
  208,
  25,
  0,
  0,
  154,
  0,
  1,
  0,
  209,
  25,
  0,
  0,
  155,
  0,
  1,
  0,
  210,
  25,
  0,
  0,
  156,
  0,
  1,
  0,
  211,
  25,
  0,
  0,
  157,
  0,
  1,
  0,
  212,
  25,
  0,
  0,
  158,
  0,
  1,
  0,
  213,
  25,
  0,
  0,
  159,
  0,
  1,
  0,
  214,
  25,
  0,
  0,
  160,
  0,
  1,
  0,
  215,
  25,
  0,
  0,
  161,
  0,
  1,
  0,
  216,
  25,
  0,
  0,
  162,
  0,
  1,
  0,
  217,
  25,
  0,
  0,
  163,
  0,
  1,
  0,
  218,
  25,
  0,
  0,
  164,
  0,
  1,
  0,
  219,
  25,
  0,
  0,
  165,
  0,
  1,
  0,
  220,
  25,
  0,
  0,
  166,
  0,
  1,
  0,
  221,
  25,
  0,
  0,
  167,
  0,
  1,
  0,
  222,
  25,
  0,
  0,
  168,
  0,
  1,
  0,
  223,
  25,
  0,
  0,
  169,
  0,
  1,
  0,
  224,
  25,
  0,
  0,
  170,
  0,
  1,
  0,
  225,
  25,
  0,
  0,
  171,
  0,
  1,
  0,
  226,
  25,
  0,
  0,
  172,
  0,
  1,
  0,
  227,
  25,
  0,
  0,
  173,
  0,
  1,
  0,
  228,
  25,
  0,
  0,
  174,
  0,
  1,
  0,
  229,
  25,
  0,
  0,
  177,
  0,
  1,
  0,
  231,
  25,
  0,
  0,
  178,
  0,
  1,
  0,
  232,
  25,
  0,
  0,
  179,
  0,
  1,
  0,
  233,
  25,
  0,
  0,
  180,
  0,
  1,
  0,
  234,
  25,
  0,
  0,
  181,
  0,
  1,
  0,
  235,
  25,
  0,
  0,
  182,
  0,
  5,
  0,
  236,
  25,
  0,
  0,
  187,
  0,
  1,
  0,
  237,
  25,
  0,
  0,
  188,
  0,
  1,
  0,
  238,
  25,
  0,
  0,
  189,
  0,
  1,
  0,
  239,
  25,
  0,
  0,
  190,
  0,
  1,
  0,
  240,
  25,
  0,
  0,
  191,
  0,
  1,
  0,
  241,
  25,
  0,
  0,
  192,
  0,
  1,
  0,
  242,
  25,
  0,
  0,
  193,
  0,
  1,
  0,
  243,
  25,
  0,
  0,
  194,
  0,
  1,
  0,
  244,
  25,
  0,
  0,
  195,
  0,
  1,
  0,
  245,
  25,
  0,
  0,
  196,
  0,
  1,
  0,
  246,
  25,
  0,
  0,
  197,
  0,
  1,
  0,
  28,
  26,
  0,
  0,
  198,
  0,
  1,
  0,
  29,
  26,
  0,
  0,
  199,
  0,
  1,
  0,
  30,
  26,
  0,
  0,
  200,
  0,
  1,
  0,
  117,
  26,
  0,
  0,
  201,
  0,
  1,
  0,
  118,
  26,
  0,
  0,
  202,
  0,
  1,
  0,
  124,
  26,
  0,
  0,
  203,
  0,
  1,
  0,
  144,
  26,
  0,
  0,
  204,
  0,
  1,
  0,
  145,
  26,
  0,
  0,
  205,
  0,
  1,
  0,
  30,
  27,
  0,
  0,
  206,
  0,
  1,
  0,
  149,
  26,
  0,
  0,
  32,
  0,
  0,
  0,
  150,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  167,
  26,
  0,
  0,
  4,
  0,
  0,
  0,
  168,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  169,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  170,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  171,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  172,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  176,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  241,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  244,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  247,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  248,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  249,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  29,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  40,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  39,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  47,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  49,
  27,
  0,
  0,
  68,
  69,
  70,
  65,
  85,
  76,
  84,
  32,
  80,
  82,
  79,
  70,
  73,
  76,
  69,
  0,
  0,
  78,
  79,
  78,
  69,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  14,
  0,
  0,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2,
  23,
  21,
  3,
  3,
  10,
  0,
  0,
  0,
  10,
  18,
  10,
  18,
  10,
  28,
  14,
  29,
  14,
  29,
  14,
  29,
  10,
  29,
  10,
  28,
  10,
  24,
  10,
  24,
  0,
  24,
  0,
  23,
  0,
  22,
  0,
  23,
  0,
  23,
  0,
  23,
  0,
  28,
  0,
  24,
  0,
  22,
  0,
  20,
  10,
  24,
  10,
  18,
  10,
  20,
  10,
  24,
  10,
  13,
  10,
  20,
  10,
  28,
  10,
  18,
  0,
  22,
  0,
  22,
  0,
  20,
  0,
  18,
  10,
  18,
  0,
  28,
  0,
  23,
  0,
  22,
  10,
  28,
  10,
  22,
  10,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28
}; // idb
_BYTE word_100B97FE[2666] =
{
  0,
  28,
  0,
  0,
  31,
  0,
  59,
  0,
  90,
  0,
  120,
  0,
  151,
  0,
  181,
  0,
  212,
  0,
  243,
  0,
  17,
  1,
  48,
  1,
  78,
  1,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2,
  23,
  21,
  3,
  3,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  18,
  10,
  18,
  10,
  28,
  14,
  29,
  14,
  29,
  14,
  29,
  10,
  29,
  10,
  28,
  10,
  24,
  10,
  24,
  0,
  24,
  0,
  23,
  0,
  22,
  0,
  23,
  0,
  23,
  0,
  23,
  0,
  28,
  0,
  24,
  0,
  22,
  0,
  20,
  10,
  24,
  10,
  18,
  10,
  20,
  10,
  24,
  10,
  13,
  10,
  20,
  10,
  28,
  10,
  18,
  0,
  22,
  0,
  22,
  0,
  20,
  0,
  18,
  10,
  18,
  0,
  28,
  0,
  23,
  0,
  22,
  10,
  28,
  10,
  22,
  10,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  0,
  1,
  0,
  136,
  25,
  0,
  0,
  1,
  0,
  1,
  0,
  137,
  25,
  0,
  0,
  2,
  0,
  1,
  0,
  138,
  25,
  0,
  0,
  4,
  0,
  1,
  0,
  139,
  25,
  0,
  0,
  5,
  0,
  1,
  0,
  140,
  25,
  0,
  0,
  6,
  0,
  1,
  0,
  141,
  25,
  0,
  0,
  18,
  0,
  1,
  0,
  142,
  25,
  0,
  0,
  19,
  0,
  1,
  0,
  143,
  25,
  0,
  0,
  20,
  0,
  1,
  0,
  144,
  25,
  0,
  0,
  21,
  0,
  1,
  0,
  145,
  25,
  0,
  0,
  22,
  0,
  1,
  0,
  146,
  25,
  0,
  0,
  23,
  0,
  1,
  0,
  147,
  25,
  0,
  0,
  25,
  0,
  1,
  0,
  148,
  25,
  0,
  0,
  26,
  0,
  1,
  0,
  149,
  25,
  0,
  0,
  27,
  0,
  1,
  0,
  150,
  25,
  0,
  0,
  28,
  0,
  1,
  0,
  151,
  25,
  0,
  0,
  29,
  0,
  1,
  0,
  152,
  25,
  0,
  0,
  30,
  0,
  1,
  0,
  153,
  25,
  0,
  0,
  31,
  0,
  1,
  0,
  154,
  25,
  0,
  0,
  32,
  0,
  4,
  0,
  155,
  25,
  0,
  0,
  36,
  0,
  4,
  0,
  156,
  25,
  0,
  0,
  40,
  0,
  1,
  0,
  157,
  25,
  0,
  0,
  41,
  0,
  1,
  0,
  158,
  25,
  0,
  0,
  42,
  0,
  1,
  0,
  159,
  25,
  0,
  0,
  43,
  0,
  1,
  0,
  160,
  25,
  0,
  0,
  44,
  0,
  1,
  0,
  161,
  25,
  0,
  0,
  45,
  0,
  1,
  0,
  162,
  25,
  0,
  0,
  46,
  0,
  1,
  0,
  163,
  25,
  0,
  0,
  47,
  0,
  1,
  0,
  164,
  25,
  0,
  0,
  49,
  0,
  1,
  0,
  166,
  25,
  0,
  0,
  50,
  0,
  30,
  0,
  167,
  25,
  0,
  0,
  80,
  0,
  1,
  0,
  168,
  25,
  0,
  0,
  81,
  0,
  1,
  0,
  169,
  25,
  0,
  0,
  84,
  0,
  4,
  0,
  170,
  25,
  0,
  0,
  88,
  0,
  1,
  0,
  171,
  25,
  0,
  0,
  89,
  0,
  1,
  0,
  172,
  25,
  0,
  0,
  92,
  0,
  4,
  0,
  173,
  25,
  0,
  0,
  96,
  0,
  4,
  0,
  174,
  25,
  0,
  0,
  100,
  0,
  1,
  0,
  175,
  25,
  0,
  0,
  208,
  0,
  4,
  0,
  168,
  23,
  0,
  0,
  104,
  0,
  1,
  0,
  177,
  25,
  0,
  0,
  105,
  0,
  1,
  0,
  178,
  25,
  0,
  0,
  106,
  0,
  1,
  0,
  179,
  25,
  0,
  0,
  107,
  0,
  1,
  0,
  180,
  25,
  0,
  0,
  108,
  0,
  1,
  0,
  181,
  25,
  0,
  0,
  109,
  0,
  1,
  0,
  182,
  25,
  0,
  0,
  110,
  0,
  1,
  0,
  183,
  25,
  0,
  0,
  111,
  0,
  1,
  0,
  184,
  25,
  0,
  0,
  112,
  0,
  1,
  0,
  185,
  25,
  0,
  0,
  113,
  0,
  1,
  0,
  186,
  25,
  0,
  0,
  114,
  0,
  1,
  0,
  187,
  25,
  0,
  0,
  115,
  0,
  1,
  0,
  188,
  25,
  0,
  0,
  116,
  0,
  1,
  0,
  189,
  25,
  0,
  0,
  117,
  0,
  1,
  0,
  190,
  25,
  0,
  0,
  118,
  0,
  1,
  0,
  191,
  25,
  0,
  0,
  120,
  0,
  4,
  0,
  192,
  25,
  0,
  0,
  124,
  0,
  4,
  0,
  193,
  25,
  0,
  0,
  128,
  0,
  4,
  0,
  194,
  25,
  0,
  0,
  132,
  0,
  4,
  0,
  195,
  25,
  0,
  0,
  136,
  0,
  4,
  0,
  196,
  25,
  0,
  0,
  140,
  0,
  1,
  0,
  197,
  25,
  0,
  0,
  141,
  0,
  1,
  0,
  198,
  25,
  0,
  0,
  142,
  0,
  1,
  0,
  199,
  25,
  0,
  0,
  144,
  0,
  2,
  0,
  200,
  25,
  0,
  0,
  146,
  0,
  1,
  0,
  201,
  25,
  0,
  0,
  147,
  0,
  1,
  0,
  202,
  25,
  0,
  0,
  148,
  0,
  1,
  0,
  203,
  25,
  0,
  0,
  149,
  0,
  1,
  0,
  204,
  25,
  0,
  0,
  150,
  0,
  1,
  0,
  205,
  25,
  0,
  0,
  151,
  0,
  1,
  0,
  206,
  25,
  0,
  0,
  152,
  0,
  1,
  0,
  207,
  25,
  0,
  0,
  153,
  0,
  1,
  0,
  208,
  25,
  0,
  0,
  154,
  0,
  1,
  0,
  209,
  25,
  0,
  0,
  155,
  0,
  1,
  0,
  210,
  25,
  0,
  0,
  156,
  0,
  1,
  0,
  211,
  25,
  0,
  0,
  157,
  0,
  1,
  0,
  212,
  25,
  0,
  0,
  158,
  0,
  1,
  0,
  213,
  25,
  0,
  0,
  159,
  0,
  1,
  0,
  214,
  25,
  0,
  0,
  160,
  0,
  1,
  0,
  215,
  25,
  0,
  0,
  161,
  0,
  1,
  0,
  216,
  25,
  0,
  0,
  162,
  0,
  1,
  0,
  217,
  25,
  0,
  0,
  163,
  0,
  1,
  0,
  218,
  25,
  0,
  0,
  164,
  0,
  1,
  0,
  219,
  25,
  0,
  0,
  165,
  0,
  1,
  0,
  220,
  25,
  0,
  0,
  166,
  0,
  1,
  0,
  221,
  25,
  0,
  0,
  167,
  0,
  1,
  0,
  222,
  25,
  0,
  0,
  168,
  0,
  1,
  0,
  223,
  25,
  0,
  0,
  169,
  0,
  1,
  0,
  224,
  25,
  0,
  0,
  170,
  0,
  1,
  0,
  225,
  25,
  0,
  0,
  171,
  0,
  1,
  0,
  226,
  25,
  0,
  0,
  172,
  0,
  1,
  0,
  227,
  25,
  0,
  0,
  173,
  0,
  1,
  0,
  228,
  25,
  0,
  0,
  174,
  0,
  1,
  0,
  229,
  25,
  0,
  0,
  177,
  0,
  1,
  0,
  231,
  25,
  0,
  0,
  178,
  0,
  1,
  0,
  232,
  25,
  0,
  0,
  179,
  0,
  1,
  0,
  233,
  25,
  0,
  0,
  180,
  0,
  1,
  0,
  234,
  25,
  0,
  0,
  181,
  0,
  1,
  0,
  235,
  25,
  0,
  0,
  182,
  0,
  5,
  0,
  236,
  25,
  0,
  0,
  187,
  0,
  1,
  0,
  237,
  25,
  0,
  0,
  188,
  0,
  1,
  0,
  238,
  25,
  0,
  0,
  189,
  0,
  1,
  0,
  239,
  25,
  0,
  0,
  190,
  0,
  1,
  0,
  240,
  25,
  0,
  0,
  191,
  0,
  1,
  0,
  241,
  25,
  0,
  0,
  192,
  0,
  1,
  0,
  242,
  25,
  0,
  0,
  193,
  0,
  1,
  0,
  243,
  25,
  0,
  0,
  194,
  0,
  1,
  0,
  244,
  25,
  0,
  0,
  195,
  0,
  1,
  0,
  245,
  25,
  0,
  0,
  196,
  0,
  1,
  0,
  246,
  25,
  0,
  0,
  197,
  0,
  1,
  0,
  28,
  26,
  0,
  0,
  198,
  0,
  1,
  0,
  29,
  26,
  0,
  0,
  199,
  0,
  1,
  0,
  30,
  26,
  0,
  0,
  200,
  0,
  1,
  0,
  117,
  26,
  0,
  0,
  201,
  0,
  1,
  0,
  118,
  26,
  0,
  0,
  202,
  0,
  1,
  0,
  124,
  26,
  0,
  0,
  203,
  0,
  1,
  0,
  144,
  26,
  0,
  0,
  204,
  0,
  1,
  0,
  145,
  26,
  0,
  0,
  205,
  0,
  1,
  0,
  30,
  27,
  0,
  0,
  206,
  0,
  1,
  0,
  149,
  26,
  0,
  0,
  32,
  0,
  0,
  0,
  150,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  167,
  26,
  0,
  0,
  4,
  0,
  0,
  0,
  168,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  169,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  170,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  171,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  172,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  176,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  241,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  244,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  247,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  248,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  249,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  29,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  40,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  39,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  47,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  49,
  27,
  0,
  0,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2,
  23,
  21,
  3,
  3,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  18,
  10,
  18,
  10,
  28,
  14,
  29,
  14,
  29,
  14,
  29,
  10,
  29,
  10,
  28,
  10,
  24,
  10,
  24,
  0,
  24,
  0,
  23,
  0,
  22,
  0,
  23,
  0,
  23,
  0,
  23,
  0,
  28,
  0,
  24,
  0,
  22,
  0,
  20,
  10,
  24,
  10,
  18,
  10,
  20,
  10,
  24,
  10,
  13,
  10,
  20,
  10,
  28,
  10,
  18,
  0,
  22,
  0,
  22,
  0,
  20,
  0,
  18,
  10,
  18,
  0,
  28,
  0,
  23,
  0,
  22,
  10,
  28,
  10,
  22,
  10,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  0,
  1,
  0,
  136,
  25,
  0,
  0,
  1,
  0,
  1,
  0,
  137,
  25,
  0,
  0,
  2,
  0,
  1,
  0,
  138,
  25,
  0,
  0,
  4,
  0,
  1,
  0,
  139,
  25,
  0,
  0,
  5,
  0,
  1,
  0,
  140,
  25,
  0,
  0,
  6,
  0,
  1,
  0,
  141,
  25,
  0,
  0,
  18,
  0,
  1,
  0,
  142,
  25,
  0,
  0,
  19,
  0,
  1,
  0,
  143,
  25,
  0,
  0,
  20,
  0,
  1,
  0,
  144,
  25,
  0,
  0,
  21,
  0,
  1,
  0,
  145,
  25,
  0,
  0,
  22,
  0,
  1,
  0,
  146,
  25,
  0,
  0,
  23,
  0,
  1,
  0,
  147,
  25,
  0,
  0,
  25,
  0,
  1,
  0,
  148,
  25,
  0,
  0,
  26,
  0,
  1,
  0,
  149,
  25,
  0,
  0,
  27,
  0,
  1,
  0,
  150,
  25,
  0,
  0,
  28,
  0,
  1,
  0,
  151,
  25,
  0,
  0,
  29,
  0,
  1,
  0,
  152,
  25,
  0,
  0,
  30,
  0,
  1,
  0,
  153,
  25,
  0,
  0,
  31,
  0,
  1,
  0,
  154,
  25,
  0,
  0,
  32,
  0,
  4,
  0,
  155,
  25,
  0,
  0,
  36,
  0,
  4,
  0,
  156,
  25,
  0,
  0,
  40,
  0,
  1,
  0,
  157,
  25,
  0,
  0,
  41,
  0,
  1,
  0,
  158,
  25,
  0,
  0,
  42,
  0,
  1,
  0,
  159,
  25,
  0,
  0,
  43,
  0,
  1,
  0,
  160,
  25,
  0,
  0,
  44,
  0,
  1,
  0,
  161,
  25,
  0,
  0,
  45,
  0,
  1,
  0,
  162,
  25,
  0,
  0,
  46,
  0,
  1,
  0,
  163,
  25,
  0,
  0,
  47,
  0,
  1,
  0,
  164,
  25,
  0,
  0,
  49,
  0,
  1,
  0,
  166,
  25,
  0,
  0,
  50,
  0,
  30,
  0,
  167,
  25,
  0,
  0,
  80,
  0,
  1,
  0,
  168,
  25,
  0,
  0,
  81,
  0,
  1,
  0,
  169,
  25,
  0,
  0,
  84,
  0,
  4,
  0,
  170,
  25,
  0,
  0,
  88,
  0,
  1,
  0,
  171,
  25,
  0,
  0,
  89,
  0,
  1,
  0,
  172,
  25,
  0,
  0,
  92,
  0,
  4,
  0,
  173,
  25,
  0,
  0,
  96,
  0,
  4,
  0,
  174,
  25,
  0,
  0,
  100,
  0,
  1,
  0,
  175,
  25,
  0,
  0,
  208,
  0,
  4,
  0,
  168,
  23,
  0,
  0,
  104,
  0,
  1,
  0,
  177,
  25,
  0,
  0,
  105,
  0,
  1,
  0,
  178,
  25,
  0,
  0,
  106,
  0,
  1,
  0,
  179,
  25,
  0,
  0,
  107,
  0,
  1,
  0,
  180,
  25,
  0,
  0,
  108,
  0,
  1,
  0,
  181,
  25,
  0,
  0,
  109,
  0,
  1,
  0,
  182,
  25,
  0,
  0,
  110,
  0,
  1,
  0,
  183,
  25,
  0,
  0,
  111,
  0,
  1,
  0,
  184,
  25,
  0,
  0,
  112,
  0,
  1,
  0,
  185,
  25,
  0,
  0,
  113,
  0,
  1,
  0,
  186,
  25,
  0,
  0,
  114,
  0,
  1,
  0,
  187,
  25,
  0,
  0,
  115,
  0,
  1,
  0,
  188,
  25,
  0,
  0,
  116,
  0,
  1,
  0,
  189,
  25,
  0,
  0,
  117,
  0,
  1,
  0,
  190,
  25,
  0,
  0,
  118,
  0,
  1,
  0,
  191,
  25,
  0,
  0,
  120,
  0,
  4,
  0,
  192,
  25,
  0,
  0,
  124,
  0,
  4,
  0,
  193,
  25,
  0,
  0,
  128,
  0,
  4,
  0,
  194,
  25,
  0,
  0,
  132,
  0,
  4,
  0,
  195,
  25,
  0,
  0,
  136,
  0,
  4,
  0,
  196,
  25,
  0,
  0,
  140,
  0,
  1,
  0,
  197,
  25,
  0,
  0,
  141,
  0,
  1,
  0,
  198,
  25,
  0,
  0,
  142,
  0,
  1,
  0,
  199,
  25,
  0,
  0,
  144,
  0,
  2,
  0,
  200,
  25,
  0,
  0,
  146,
  0,
  1,
  0,
  201,
  25,
  0,
  0,
  147,
  0,
  1,
  0,
  202,
  25,
  0,
  0,
  148,
  0,
  1,
  0,
  203,
  25,
  0,
  0,
  149,
  0,
  1,
  0,
  204,
  25,
  0,
  0,
  150,
  0,
  1,
  0,
  205,
  25,
  0,
  0,
  151,
  0,
  1,
  0,
  206,
  25,
  0,
  0,
  152,
  0,
  1,
  0,
  207,
  25,
  0,
  0,
  153,
  0,
  1,
  0,
  208,
  25,
  0,
  0,
  154,
  0,
  1,
  0,
  209,
  25,
  0,
  0,
  155,
  0,
  1,
  0,
  210,
  25,
  0,
  0,
  156,
  0,
  1,
  0,
  211,
  25,
  0,
  0,
  157,
  0,
  1,
  0,
  212,
  25,
  0,
  0,
  158,
  0,
  1,
  0,
  213,
  25,
  0,
  0,
  159,
  0,
  1,
  0,
  214,
  25,
  0,
  0,
  160,
  0,
  1,
  0,
  215,
  25,
  0,
  0,
  161,
  0,
  1,
  0,
  216,
  25,
  0,
  0,
  162,
  0,
  1,
  0,
  217,
  25,
  0,
  0,
  163,
  0,
  1,
  0,
  218,
  25,
  0,
  0,
  164,
  0,
  1,
  0,
  219,
  25,
  0,
  0,
  165,
  0,
  1,
  0,
  220,
  25,
  0,
  0,
  166,
  0,
  1,
  0,
  221,
  25,
  0,
  0,
  167,
  0,
  1,
  0,
  222,
  25,
  0,
  0,
  168,
  0,
  1,
  0,
  223,
  25,
  0,
  0,
  169,
  0,
  1,
  0,
  224,
  25,
  0,
  0,
  170,
  0,
  1,
  0,
  225,
  25,
  0,
  0,
  171,
  0,
  1,
  0,
  226,
  25,
  0,
  0,
  172,
  0,
  1,
  0,
  227,
  25,
  0,
  0,
  173,
  0,
  1,
  0,
  228,
  25,
  0,
  0,
  174,
  0,
  1,
  0,
  229,
  25,
  0,
  0,
  177,
  0,
  1,
  0,
  231,
  25,
  0,
  0,
  178,
  0,
  1,
  0,
  232,
  25,
  0,
  0,
  179,
  0,
  1,
  0,
  233,
  25,
  0,
  0,
  180,
  0,
  1,
  0,
  234,
  25,
  0,
  0,
  181,
  0,
  1,
  0,
  235,
  25,
  0,
  0,
  182,
  0,
  5,
  0,
  236,
  25,
  0,
  0,
  187,
  0,
  1,
  0,
  237,
  25,
  0,
  0,
  188,
  0,
  1,
  0,
  238,
  25,
  0,
  0,
  189,
  0,
  1,
  0,
  239,
  25,
  0,
  0,
  190,
  0,
  1,
  0,
  240,
  25,
  0,
  0,
  191,
  0,
  1,
  0,
  241,
  25,
  0,
  0,
  192,
  0,
  1,
  0,
  242,
  25,
  0,
  0,
  193,
  0,
  1,
  0,
  243,
  25,
  0,
  0,
  194,
  0,
  1,
  0,
  244,
  25,
  0,
  0,
  195,
  0,
  1,
  0,
  245,
  25,
  0,
  0,
  196,
  0,
  1,
  0,
  246,
  25,
  0,
  0,
  197,
  0,
  1,
  0,
  28,
  26,
  0,
  0,
  198,
  0,
  1,
  0,
  29,
  26,
  0,
  0,
  199,
  0,
  1,
  0,
  30,
  26,
  0,
  0,
  200,
  0,
  1,
  0,
  117,
  26,
  0,
  0,
  201,
  0,
  1,
  0,
  118,
  26,
  0,
  0,
  202,
  0,
  1,
  0,
  124,
  26,
  0,
  0,
  203,
  0,
  1,
  0,
  144,
  26,
  0,
  0,
  204,
  0,
  1,
  0,
  145,
  26,
  0,
  0,
  205,
  0,
  1,
  0,
  30,
  27,
  0,
  0,
  206,
  0,
  1,
  0,
  149,
  26,
  0,
  0,
  32,
  0,
  0,
  0,
  150,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  167,
  26,
  0,
  0,
  4,
  0,
  0,
  0,
  168,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  169,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  170,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  171,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  172,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  176,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  241,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  244,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  247,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  248,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  249,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  29,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  40,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  39,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  47,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  49,
  27,
  0,
  0
}; // idb
int dword_100BA268 = 1391376; // weak
int (__cdecl *off_100BA7F8[3])(char) = { &sub_10038390, &sub_100382A0, &sub_100381F0 }; // weak
char *off_100BA804 = "/shr_mem/iop_prod_data_intf.shr"; // weak
__int16 word_100BA818[] = { 43 }; // weak
__int16 word_100BA81A[] = { 111 }; // weak
char byte_100BA81C[] = { '\x06' }; // weak
_UNKNOWN unk_100BB1E8; // weak
_UNKNOWN unk_100BB1F0; // weak
char byte_100BB1F8[] = { '\x01' }; // weak
_UNKNOWN unk_100C15F8; // weak
int dword_100C15FC[] = { 0 }; // weak
_UNKNOWN unk_100C1998; // weak
int dword_100C199C[] = { 0 }; // weak
char *off_100C1BF0 = "/shr_mem/iop_cnfg_mngr_intf.shr"; // weak
char byte_100C2184[] = { '\x02' }; // weak
char byte_100C2185[] = { '\0' }; // weak
__int16 word_100C26F0[] = { 235 }; // weak
__int16 word_100C26F2[] = { 233 }; // weak
int dword_100C26F8[] = { 6201 }; // weak
_UNKNOWN unk_100C2EA0; // weak
char byte_100C2EA1[] = { '\0' }; // weak
_UNKNOWN unk_100C2EB0; // weak
int dword_100C2EB4[] = { 1 }; // weak
char *off_100C3350 = "/shr_mem/iop_upld_mngr_intf.shr"; // weak
char *off_100C3D08[62] =
{
  "ERR_NO_ERR: there was no err",
  "ERR_GENERIC: generic error",
  "ERR_ABNRML_PWRDN: abnormal powerdown",
  "ERR_AGAIN: function can do more work if called again.",
  "ERR_ACCES: access error",
  "ERR_ASSERT: UTL_assert()",
  "ERR_BADF: bad file descriptor",
  "ERR_BUSY: dev or system is busy",
  "ERR_DATA_ABORT: cpu data abort occured",
  "ERR_DEV_REM: device was removed (card not inserted)",
  "ERR_DONT_EXISTS: something doesnt exist",
  "ERR_EXIST: something already exists",
  "ERR_FAULT: illegal address",
  "ERR_FBIG: file to big",
  "ERR_INTEGRITY: crc, checksum, ... errors",
  "ERR_INVAL: invalid value",
  "ERR_IO: IO error",
  "ERR_IOP_CMND_PWRDN:",
  "ERR_ISDIR: it is a directory",
  "ERR_LOCK_FAILED: failed to lock (unable to reserve smphr)",
  "ERR_LOOP: possible infinite link loop",
  "ERR_NAMETOOLONG: supplied name is to long",
  "ERR_NFILE: no more file structures",
  "ERR_MFILE: no more file descriptors",
  "ERR_NOENT: no entry. file or path not found",
  "ERR_NOEXEC: file cant be executed or doesn't support mmap",
  "ERR_NOMEM: out of memory",
  "ERR_NOSPC: out of space(disk space)",
  "ERR_NOTBLK: not a blk device",
  "ERR_NOT_COMPLETE: something isn't complete (not complete rd,write)",
  "ERR_NOT_EMPTY: something isnt empty probably directory",
  "ERR_NOT_SUPPORTED: something isnt supported",
  "ERR_NOTDIR: not a directory",
  "ERR_NODEV: no such device",
  "ERR_PERM: no permission to perform operation",
  "ERR_PREFETCH_ABORT: cpu prefectch abort occured",
  "ERR_RTL_TRAP: run time library trap",
  "ERR_SPIPE: seek is not supported on file",
  "ERR_STK_OVFLOW: stack overflow",
  "ERR_TXTBSY: text file is busy. cant get or deny file write access",
  "ERR_UNDEF_INSTR: undefined instruction",
  "ERR_UNDEF_IRQ: undefined cpu irq",
  "ERR_UNDEF_SWI: undefined swi",
  "ERR_EXDEV: external device or different file system",
  "ERR_ASSERT_CONTINUE: UTL_assert_continue()",
  "ERR_HW_FAIL: Hardware Failure",
  "ERR_USING_DEFAULTS: stored value error using defaults",
  "ERR_OUT_OF_RANGE: value is out of range",
  "ERR_BADFUNC: bad function, function not supported",
  "ERR_BADPATH: path not found",
  "ERR_BAD_HNDL: bad handle(socket handle)",
  "ERR_SOCK_CLOSED: socket is closed",
  "ERR_SOCK_INVALID_ST: Socket in invalid state for op",
  "ERR_CONN_CLOSING: connection is closing",
  "ERR_CONN_RESET: connection was reset",
  "ERR_CONN_ABORT: connection was aborted",
  "ERR_CONN_NOT_ESTAB: connection is not established",
  "ERR_TIMEOUT: Normal timeout waiting for something",
  "ERR_WAIT_ABORT: Aborted wait for something",
  "ERR_BAD_FUNC_PARM: Bad function parameter",
  "ERR_IN_PROGRESS: In progress",
  "ERR_SRVR_DOWN: Server Down"
}; // weak
int dword_100C49F8[] = { 2175 }; // weak
char *off_100C5288 = "/shr_mem/iop_gea_intf.shr"; // weak
int dword_100C5DB4[] = { 88 }; // weak
__int16 word_100C6264[] = { 836 }; // weak
char *off_100C6284 = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_100C6298 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_100C62AC = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_100C62C0 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_100C62D4 = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_100C62E8 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
char a006D0170[11] = "006-D0170-"; // weak
char *off_100C63EC = "006-D0170-"; // weak
int (__cdecl *(*off_100C63F0)[2])(int, int) = &off_100F3560; // weak
_UNKNOWN unk_100C64A0; // weak
int dword_100C64A4[] = { 1312 }; // weak
int (__cdecl *off_100C7228)(int, size_t, void *) = &sub_1003ED00; // weak
char *off_100C725C = "/shr_mem/pvt_intf.shr"; // weak
char *off_100C72B4 = "/shr_mem/nav_intf.shr"; // weak
int (*off_100C77F0[4])() = { &sub_1003F220, &sub_1003F210, &sub_1003F200, &sub_1003F210 }; // weak
char byte_100C7EE7[] = { '\0' }; // weak
__int16 word_100C9AD0[] = { 551 }; // weak
_UNKNOWN unk_100CA110; // weak
int dword_100CBE60[] = { 9032 }; // weak
_UNKNOWN unk_100CC420; // weak
char byte_100CC424[] = { '\0' }; // weak
_UNKNOWN unk_100DEAAA; // weak
int dword_100DEAAC = 9429; // idb
_UNKNOWN unk_100DF920; // weak
__int16 word_100DF922[] = { 301 }; // weak
__int16 word_100DF924[] = { 302 }; // weak
__int16 word_100DF926[] = { 303 }; // weak
__int16 word_100DF928[] = { 304 }; // weak
__int16 word_100DF92A[] = { 305 }; // weak
__int16 word_100DF92C[] = { 306 }; // weak
__int16 word_100DF92E[] = { 307 }; // weak
_UNKNOWN unk_100E0AD0; // weak
_UNKNOWN unk_100E10D0; // weak
_UNKNOWN unk_100E12B0; // weak
char *off_100E1454[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_100E1468 }; // weak
char *off_100E15F8 = "true"; // weak
char byte_100E15FC[] = { '\x01' }; // weak
char *off_100E1660 = "failure listener"; // weak
_UNKNOWN unk_100E1DF0; // weak
char *off_100E1FEC[5] = { "FAIL", "PASS", "normal", "robust", "EQ" }; // weak
char *off_100E1FF4[3] = { "normal", "robust", "EQ" }; // weak
char *off_100E1FFC = "EQ"; // weak
char *off_100E2018[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_100E2024[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_100E202C[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_100E22E0; // weak
_UNKNOWN unk_100E2314; // weak
char *off_100E26D0 = "printf_listener"; // weak
int (*off_100E33BC[2])() = { &sub_10068830, &sub_10038B10 }; // weak
char *off_100E3468 = "gate_listener"; // weak
_UNKNOWN unk_100E4080; // weak
_UNKNOWN unk_100E4098; // weak
_UNKNOWN unk_100E40E0; // weak
int dword_100E40E4[] = { 6767 }; // weak
_UNKNOWN unk_100E40F0; // weak
_UNKNOWN unk_100E4108; // weak
_UNKNOWN unk_100E4120; // weak
int dword_100E4124[] = { 6769 }; // weak
_UNKNOWN unk_100E4138; // weak
int dword_100E413C[] = { 6093 }; // weak
int dword_100E4148[] = { 1600085855 }; // weak
_UNKNOWN unk_100E5008; // weak
char byte_100E5009[] = { '\0' }; // weak
int dword_100E5034[] = { 6829 }; // weak
int dword_100E5EA8 = 64; // weak
__int16 word_100E5EAC[] = { 6782 }; // weak
__int16 word_100E5EB0[] = { 128 }; // weak
_UNKNOWN unk_100E5ECC; // weak
_DWORD dword_100E5ED0[10] = { 64, 24, 62, 18, 65, 27525120, 27394467, 27721729, 27591078, 0 }; // idb
__int16 word_100E72E0[] = { 1565 }; // weak
__int16 word_100E72E4[] = { 534 }; // weak
char byte_100E72E8[] = { '\x04' }; // weak
__int16 word_100E72EA[] = { 6512 }; // weak
int dword_100E7300[] = { 118000 }; // weak
__int16 word_100EB2E8[] = { 114 }; // weak
_UNKNOWN unk_100EBB20; // weak
int dword_100EBB24[] = { 6006 }; // weak
char *off_100EC9F0 = "/shr_mem/iop_gtx_intf.shr"; // weak
__int16 word_100F15A8[] = { 42 }; // weak
char byte_100F2DF1[] = { '\x1E' }; // weak
int (__cdecl *off_100F3560[2])(int, int) = { &sub_10055C90, &sub_10055CF0 }; // weak
char *off_100F57D0 = "/shr_mem/iop_fltr_data_intf.shr"; // weak
_UNKNOWN unk_100F585C; // weak
__int16 word_100F585E[] = { 565 }; // weak
_WORD dword_100F78C0[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_100F7CC0[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_100F80C0[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_100F84C0[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_100F88C0[] = { 99 }; // weak
int dword_100F8CC0[] = { 25344 }; // weak
int dword_100F90C0[] = { 6488064 }; // weak
int dword_100F94C0[] = { 1660944384 }; // weak
int dword_100F98E8[] = { 128 }; // weak
int dword_100F98F8[] = { 0 }; // weak
int dword_100F9908[] = { 0 }; // weak
char byte_100F9979[] = { '\0' }; // weak
char byte_100F997A[] = { '\0' }; // weak
char byte_100F997B[] = { '\0' }; // weak
char byte_100F997C[] = { '\x10' }; // weak
int dword_100F9990[] = { 0 }; // weak
_UNKNOWN unk_100F9A08; // weak
_UNKNOWN unk_100F9E88; // weak
char byte_100F9F00[] = { '\0' }; // weak
char byte_100FA000[] = { '\0' }; // weak
char byte_100FA100[] = { '\0' }; // weak
int dword_100FA200[] = { 0 }; // weak
int dword_100FA278[] = { 0 }; // weak
__int16 word_100FA2F0[] = { 0 }; // weak
__int16 word_100FA2F2[] = { 0 }; // weak
__int16 word_100FA2F4[] = { 0 }; // weak
__int16 word_100FA2F6[] = { 0 }; // weak
int (__cdecl *off_100FA2F8)(int, int) = &sub_1005D370; // weak
void *off_100FA4A4 = &unk_100F9A08; // weak
void *off_100FA4B8 = &unk_100F9E88; // weak
_UNKNOWN unk_100FA4CC; // weak
int dword_100FA4E0[] = { 0 }; // weak
int dword_100FA528[] = { 16 }; // weak
_UNKNOWN unk_100FA578; // weak
_UNKNOWN unk_100FA5F8; // weak
_UNKNOWN unk_100FA678; // weak
_UNKNOWN unk_100FA6F0; // weak
_UNKNOWN unk_100FA768; // weak
_UNKNOWN unk_100FB768; // weak
_UNKNOWN unk_100FB8E8; // weak
_UNKNOWN unk_100FB90C; // weak
_UNKNOWN unk_100FBAA0; // weak
char off_100FC6D0[] = { '', '\x1F', '\x0E', '\x10' }; // idb
int dword_100FC6EC = 1; // idb
char byte_100FC708[] = { '\x01' }; // weak
void *off_100FC70C = &unk_100AE0F0; // weak
char *off_100FC710[2] = { "2", "fail_normal_1" }; // weak
char off_100FC714[8] = { '', '', '\x0F', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100FC798[] = { '\0' }; // weak
char byte_100FC799[] = { '\0' }; // weak
int dword_100FC79C[] = { 0 }; // weak
char *off_100FC7A0 = "0, 0, 0"; // weak
double dbl_100FCA08[] = {  0.0 }; // weak
double dbl_100FCA10[] = {  0.0 }; // weak
double dbl_100FCA18[] = {  0.0 }; // weak
int dword_100FCA20[] = { 0 }; // weak
char *off_100FCA24 = "0, 0, 0"; // weak
float flt_100FD628[] = {  0.0 }; // weak
float flt_100FD62C[] = {  0.0 }; // weak
float flt_100FD630[] = {  0.0 }; // weak
int dword_100FD634[] = { 0 }; // weak
char off_100FD638[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char *off_100FDDBC[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_10112A18
}; // weak
int dword_100FDDD0[] = { 0 }; // weak
int dword_100FDDD4[] = { 0 }; // weak
int dword_100FDDD8[] = { 0 }; // weak
int dword_100FDDDC[] = { 0 }; // weak
char *off_100FDDE0 = "0, 0, 0"; // weak
__int16 word_100FE568[] = { 0 }; // weak
__int16 word_100FE56A[] = { 0 }; // weak
__int16 word_100FE56C[] = { 0 }; // weak
int dword_100FE570[] = { 0 }; // weak
char *off_100FE574 = "0, 0, 0"; // weak
int dword_100FEB78[] = { 0 }; // weak
int dword_100FEB7C[] = { 0 }; // weak
int dword_100FEB80[] = { 0 }; // weak
int dword_100FEB84[] = { 0 }; // weak
char off_100FEB88[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100FF310[] = { 0 }; // weak
int dword_100FF314[] = { 0 }; // weak
int dword_100FF318[] = { 0 }; // weak
int dword_100FF31C[] = { 0 }; // weak
int dword_100FF320[] = { 0 }; // weak
int dword_100FF324[] = { 0 }; // weak
int dword_100FF328[] = { 0 }; // weak
char off_100FF32C[32] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100FFF30[] = { '\0' }; // weak
char byte_100FFF31[] = { '\0' }; // weak
char byte_100FFF32[] = { '\0' }; // weak
int dword_100FFF34[] = { 0 }; // weak
char *off_100FFF38 = "0, 0, 0"; // weak
int dword_101003C0[] = { 0 }; // weak
int dword_101003C4[] = { 0 }; // weak
int dword_101003C8[] = { 0 }; // weak
int dword_101003CC[] = { 0 }; // weak
char *off_101003D0 = "0, 0, 0"; // weak
int dword_10100B58[] = { 0 }; // weak
int dword_10100B5C[] = { 0 }; // weak
int dword_10100B60[] = { 0 }; // weak
int dword_10100B64[] = { 0 }; // weak
char off_10100B68[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_10100EC8[] = { 0 }; // weak
__int16 word_10100ECA[] = { 0 }; // weak
__int16 word_10100ECC[] = { 0 }; // weak
int dword_10100ED0[] = { 0 }; // weak
char *off_10100ED4 = "0, 0, 0"; // weak
int dword_10101188[] = { 0 }; // weak
int dword_1010118C[] = { 0 }; // weak
int dword_10101190[] = { 0 }; // weak
int dword_10101194[] = { 0 }; // weak
char off_10101198[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_101014F8[] = { 0 }; // weak
int dword_101014FC[] = { 0 }; // weak
int dword_10101500[] = { 0 }; // weak
int dword_10101504[] = { 0 }; // weak
int dword_10101508[] = { 0 }; // weak
int dword_1010150C[] = { 0 }; // weak
int dword_10101510[] = { 0 }; // weak
char off_10101514[32] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10101A78[] = { '\0' }; // weak
char byte_10101A79[] = { '\0' }; // weak
char byte_10101A7A[] = { '\0' }; // weak
int dword_10101A7C[] = { 0 }; // weak
char *off_10101A80 = "0, 0, 0"; // weak
int dword_10101C88[] = { 0 }; // weak
int dword_10101C8C[] = { 0 }; // weak
int dword_10101C90[] = { 0 }; // weak
int dword_10101C94[] = { 0 }; // weak
char off_10101C98[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10101FF8[] = { '\x01' }; // weak
void *off_10101FFC = &unk_100AE0F0; // weak
char *off_10102000[2] = { "2", "fail_robust_1" }; // weak
char off_10102004[8] = { '0', '', '\x0F', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_10102088[] = { '\0' }; // weak
char byte_10102089[] = { '\0' }; // weak
int dword_1010208C[] = { 0 }; // weak
char *off_10102090 = "0, 0, 0"; // weak
double dbl_101022F8[] = {  0.0 }; // weak
double dbl_10102300[] = {  0.0 }; // weak
double dbl_10102308[] = {  0.0 }; // weak
int dword_10102310[] = { 0 }; // weak
char off_10102314[32] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_10102F18[] = {  0.0 }; // weak
float flt_10102F1C[] = {  0.0 }; // weak
float flt_10102F20[] = {  0.0 }; // weak
int dword_10102F24[] = { 0 }; // weak
char off_10102F28[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_101036B0[] = { 0 }; // weak
int dword_101036B4[] = { 0 }; // weak
int dword_101036B8[] = { 0 }; // weak
int dword_101036BC[] = { 0 }; // weak
char *off_101036C0 = "0, 0, 0"; // weak
__int16 word_10103E48[] = { 0 }; // weak
__int16 word_10103E4A[] = { 0 }; // weak
__int16 word_10103E4C[] = { 0 }; // weak
int dword_10103E50[] = { 0 }; // weak
char *off_10103E54 = "0, 0, 0"; // weak
int dword_10104458[] = { 0 }; // weak
int dword_1010445C[] = { 0 }; // weak
int dword_10104460[] = { 0 }; // weak
int dword_10104464[] = { 0 }; // weak
char off_10104468[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10104BF0[] = { 0 }; // weak
int dword_10104BF4[] = { 0 }; // weak
int dword_10104BF8[] = { 0 }; // weak
int dword_10104BFC[] = { 0 }; // weak
int dword_10104C00[] = { 0 }; // weak
int dword_10104C04[] = { 0 }; // weak
int dword_10104C08[] = { 0 }; // weak
char off_10104C0C[32] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10105810[] = { '\0' }; // weak
char byte_10105811[] = { '\0' }; // weak
char byte_10105812[] = { '\0' }; // weak
int dword_10105814[] = { 0 }; // weak
char *off_10105818 = "0, 0, 0"; // weak
int dword_10105CA0[] = { 0 }; // weak
int dword_10105CA4[] = { 0 }; // weak
int dword_10105CA8[] = { 0 }; // weak
int dword_10105CAC[] = { 0 }; // weak
char *off_10105CB0 = "0, 0, 0"; // weak
int dword_10106438[] = { 0 }; // weak
int dword_1010643C[] = { 0 }; // weak
int dword_10106440[] = { 0 }; // weak
int dword_10106444[] = { 0 }; // weak
char off_10106448[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_101067A8[] = { 0 }; // weak
__int16 word_101067AA[] = { 0 }; // weak
__int16 word_101067AC[] = { 0 }; // weak
int dword_101067B0[] = { 0 }; // weak
char *off_101067B4 = "0, 0, 0"; // weak
int dword_10106A68[] = { 0 }; // weak
int dword_10106A6C[] = { 0 }; // weak
int dword_10106A70[] = { 0 }; // weak
int dword_10106A74[] = { 0 }; // weak
char off_10106A78[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10106DD8[] = { 0 }; // weak
int dword_10106DDC[] = { 0 }; // weak
int dword_10106DE0[] = { 0 }; // weak
int dword_10106DE4[] = { 0 }; // weak
int dword_10106DE8[] = { 0 }; // weak
int dword_10106DEC[] = { 0 }; // weak
int dword_10106DF0[] = { 0 }; // weak
char off_10106DF4[32] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10107358[] = { '\0' }; // weak
char byte_10107359[] = { '\0' }; // weak
char byte_1010735A[] = { '\0' }; // weak
int dword_1010735C[] = { 0 }; // weak
char *off_10107360 = "0, 0, 0"; // weak
int dword_10107568[] = { 0 }; // weak
int dword_1010756C[] = { 0 }; // weak
int dword_10107570[] = { 0 }; // weak
int dword_10107574[] = { 0 }; // weak
char off_10107578[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_101078D8[] = { '\x01' }; // weak
void *off_101078DC = &unk_100AE0F0; // weak
void *off_101078E0 = &unk_100AE0F0; // weak
char off_101078E4[8] = { '', '', '\x0F', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_10107928[] = { '\0' }; // weak
char byte_10107929[] = { '\0' }; // weak
int dword_1010792C[] = { 0 }; // weak
char *off_10107930 = "0, 0, 0"; // weak
double dbl_10107B98[] = {  0.0 }; // weak
double dbl_10107BA0[] = {  0.0 }; // weak
double dbl_10107BA8[] = {  0.0 }; // weak
int dword_10107BB0[] = { 0 }; // weak
char off_10107BB4[32] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_101087B8[] = {  0.0 }; // weak
float flt_101087BC[] = {  0.0 }; // weak
float flt_101087C0[] = {  0.0 }; // weak
int dword_101087C4[] = { 0 }; // weak
char off_101087C8[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10108F50[] = { 0 }; // weak
int dword_10108F54[] = { 0 }; // weak
int dword_10108F58[] = { 0 }; // weak
int dword_10108F5C[] = { 0 }; // weak
char *off_10108F60 = "0, 0, 0"; // weak
__int16 word_101096E8[] = { 0 }; // weak
__int16 word_101096EA[] = { 0 }; // weak
__int16 word_101096EC[] = { 0 }; // weak
int dword_101096F0[] = { 0 }; // weak
char *off_101096F4 = "0, 0, 0"; // weak
int dword_10109CF8[] = { 0 }; // weak
int dword_10109CFC[] = { 0 }; // weak
int dword_10109D00[] = { 0 }; // weak
int dword_10109D04[] = { 0 }; // weak
char off_10109D08[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1010A490[] = { 0 }; // weak
int dword_1010A494[] = { 0 }; // weak
int dword_1010A498[] = { 0 }; // weak
int dword_1010A49C[] = { 0 }; // weak
int dword_1010A4A0[] = { 0 }; // weak
int dword_1010A4A4[] = { 0 }; // weak
int dword_1010A4A8[] = { 0 }; // weak
char off_1010A4AC[32] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1010B0B0[] = { '\0' }; // weak
char byte_1010B0B1[] = { '\0' }; // weak
char byte_1010B0B2[] = { '\0' }; // weak
int dword_1010B0B4[] = { 0 }; // weak
char *off_1010B0B8 = "0, 0, 0"; // weak
int dword_1010B540[] = { 0 }; // weak
int dword_1010B544[] = { 0 }; // weak
int dword_1010B548[] = { 0 }; // weak
int dword_1010B54C[] = { 0 }; // weak
char *off_1010B550 = "0, 0, 0"; // weak
int dword_1010BCD8[] = { 0 }; // weak
int dword_1010BCDC[] = { 0 }; // weak
int dword_1010BCE0[] = { 0 }; // weak
int dword_1010BCE4[] = { 0 }; // weak
char off_1010BCE8[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_1010C048[] = { 0 }; // weak
__int16 word_1010C04A[] = { 0 }; // weak
__int16 word_1010C04C[] = { 0 }; // weak
int dword_1010C050[] = { 0 }; // weak
char *off_1010C054 = "0, 0, 0"; // weak
int dword_1010C308[] = { 0 }; // weak
int dword_1010C30C[] = { 0 }; // weak
int dword_1010C310[] = { 0 }; // weak
int dword_1010C314[] = { 0 }; // weak
char off_1010C318[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1010C678[] = { 0 }; // weak
int dword_1010C67C[] = { 0 }; // weak
int dword_1010C680[] = { 0 }; // weak
int dword_1010C684[] = { 0 }; // weak
int dword_1010C688[] = { 0 }; // weak
int dword_1010C68C[] = { 0 }; // weak
int dword_1010C690[] = { 0 }; // weak
char off_1010C694[32] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1010CBF8[] = { '\0' }; // weak
char byte_1010CBF9[] = { '\0' }; // weak
char byte_1010CBFA[] = { '\0' }; // weak
int dword_1010CBFC[] = { 0 }; // weak
char *off_1010CC00 = "0, 0, 0"; // weak
int dword_1010CE08[] = { 0 }; // weak
int dword_1010CE0C[] = { 0 }; // weak
int dword_1010CE10[] = { 0 }; // weak
int dword_1010CE14[] = { 0 }; // weak
char off_1010CE18[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1010D178[] = { '\x01' }; // weak
void *off_1010D17C = &unk_100AE0F0; // weak
void *off_1010D180 = &unk_100AE0F0; // weak
char off_1010D184[8] = { 'P', '', '\x0F', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_1010D1C8[] = { '\0' }; // weak
char byte_1010D1C9[] = { '\0' }; // weak
int dword_1010D1CC[] = { 0 }; // weak
char *off_1010D1D0 = "0, 0, 0"; // weak
double dbl_1010D438[] = {  0.0 }; // weak
double dbl_1010D440[] = {  0.0 }; // weak
double dbl_1010D448[] = {  0.0 }; // weak
int dword_1010D450[] = { 0 }; // weak
char off_1010D454[32] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_1010E058[] = {  0.0 }; // weak
float flt_1010E05C[] = {  0.0 }; // weak
float flt_1010E060[] = {  0.0 }; // weak
int dword_1010E064[] = { 0 }; // weak
char off_1010E068[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1010E7F0[] = { 0 }; // weak
int dword_1010E7F4[] = { 0 }; // weak
int dword_1010E7F8[] = { 0 }; // weak
int dword_1010E7FC[] = { 0 }; // weak
char *off_1010E800 = "0, 0, 0"; // weak
__int16 word_1010EF88[] = { 0 }; // weak
__int16 word_1010EF8A[] = { 0 }; // weak
__int16 word_1010EF8C[] = { 0 }; // weak
int dword_1010EF90[] = { 0 }; // weak
char *off_1010EF94 = "0, 0, 0"; // weak
int dword_1010F598[] = { 0 }; // weak
int dword_1010F59C[] = { 0 }; // weak
int dword_1010F5A0[] = { 0 }; // weak
int dword_1010F5A4[] = { 0 }; // weak
char off_1010F5A8[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1010FD30[] = { 0 }; // weak
int dword_1010FD34[] = { 0 }; // weak
int dword_1010FD38[] = { 0 }; // weak
int dword_1010FD3C[] = { 0 }; // weak
int dword_1010FD40[] = { 0 }; // weak
int dword_1010FD44[] = { 0 }; // weak
int dword_1010FD48[] = { 0 }; // weak
char off_1010FD4C[32] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10110950[] = { '\0' }; // weak
char byte_10110951[] = { '\0' }; // weak
char byte_10110952[] = { '\0' }; // weak
int dword_10110954[] = { 0 }; // weak
char *off_10110958 = "0, 0, 0"; // weak
int dword_10110DE0[] = { 0 }; // weak
int dword_10110DE4[] = { 0 }; // weak
int dword_10110DE8[] = { 0 }; // weak
int dword_10110DEC[] = { 0 }; // weak
char *off_10110DF0 = "0, 0, 0"; // weak
int dword_10111578[] = { 0 }; // weak
int dword_1011157C[] = { 0 }; // weak
int dword_10111580[] = { 0 }; // weak
int dword_10111584[] = { 0 }; // weak
char off_10111588[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_101118E8[] = { 0 }; // weak
__int16 word_101118EA[] = { 0 }; // weak
__int16 word_101118EC[] = { 0 }; // weak
int dword_101118F0[] = { 0 }; // weak
char *off_101118F4 = "0, 0, 0"; // weak
int dword_10111BA8[] = { 0 }; // weak
int dword_10111BAC[] = { 0 }; // weak
int dword_10111BB0[] = { 0 }; // weak
int dword_10111BB4[] = { 0 }; // weak
char off_10111BB8[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10111F18[] = { 0 }; // weak
int dword_10111F1C[] = { 0 }; // weak
int dword_10111F20[] = { 0 }; // weak
int dword_10111F24[] = { 0 }; // weak
int dword_10111F28[] = { 0 }; // weak
int dword_10111F2C[] = { 0 }; // weak
int dword_10111F30[] = { 0 }; // weak
char off_10111F34[32] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10112498[] = { '\0' }; // weak
char byte_10112499[] = { '\0' }; // weak
char byte_1011249A[] = { '\0' }; // weak
int dword_1011249C[] = { 0 }; // weak
char *off_101124A0 = "0, 0, 0"; // weak
int dword_101126A8[] = { 0 }; // weak
int dword_101126AC[] = { 0 }; // weak
int dword_101126B0[] = { 0 }; // weak
int dword_101126B4[] = { 0 }; // weak
char off_101126B8[20] =
{
  ' ',
  '',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_10113698; // weak
int dword_10116874[] = { 0 }; // weak
char *off_10116878[19] =
{
  "\r\n",
  "\r\n  ",
  "\r\n    ",
  "\r\n      ",
  "\r\n        ",
  "\r\n          ",
  "\r\n            ",
  "\r\n              ",
  "\r\n                ",
  "\r\n                  ",
  "\r\n                    ",
  "\r\n                      ",
  "\r\n                        ",
  "\r\n                          ",
  "\r\n                            ",
  "\r\n                              ",
  "\r\n                                ",
  "\r\n                                  ",
  "\r\n                                    "
}; // weak
_UNKNOWN unk_10116908; // weak
_UNKNOWN unk_1011690C; // weak
_UNKNOWN unk_10116910; // weak
_UNKNOWN unk_10116914; // weak
_UNKNOWN unk_10116918; // weak
_UNKNOWN unk_1011691C; // weak
_UNKNOWN unk_10116920; // weak
_UNKNOWN unk_10116924; // weak
char byte_10116928[] = { '\x01' }; // weak
__int16 word_1011692A[] = { 3020 }; // weak
char byte_101181F0[] = { '\x01' }; // weak
__int16 word_101181F8[] = { 3020 }; // weak
_UNKNOWN unk_1011B380; // weak
int dword_1011B384[] = { 0 }; // weak
_UNKNOWN unk_1011B398; // weak
int dword_1011B39C[] = { 0 }; // weak
_UNKNOWN unk_1011B3C0; // weak
int dword_1011B3C4[] = { 0 }; // weak
_UNKNOWN unk_1011B3F0; // weak
int dword_1011B3F4[] = { 0 }; // weak
_UNKNOWN unk_10120828; // weak
void *off_1012082C = &unk_101205A0; // weak
_UNKNOWN unk_101209D0; // weak
_UNKNOWN unk_101209D1; // weak
char byte_10120B22[] = { '\x04' }; // weak
char byte_10120B27[] = { '\a' }; // weak
_UNKNOWN unk_10121DF0; // weak
_UNKNOWN unk_10121DF4; // weak
_UNKNOWN unk_10121DF8; // weak
char byte_10122618[] = { '\0' }; // weak
_DWORD off_1012261C[2] = { 269623012, 1 }; // idb
__int16 word_10123110[] = { 0 }; // weak
int dword_10123114[] = { 106639 }; // weak
int dword_10123118[] = { 4294791889 }; // weak
_UNKNOWN unk_10123C18; // weak
int dword_10123C1C[] = { 3535 }; // weak
_UNKNOWN unk_10123C50; // weak
int dword_10123C54[] = { 6813 }; // weak
_UNKNOWN unk_10123C88; // weak
int dword_10123C8C[] = { 9036 }; // weak
_UNKNOWN unk_10123CC0; // weak
int dword_10123CC4[] = { 6763 }; // weak
_UNKNOWN unk_10124DA0; // weak
int dword_101258E8[] = { 6103 }; // weak
int dword_101258EC[] = { 8000 }; // weak
_UNKNOWN unk_10125E10; // weak
char *off_10125F58 = "/shr_mem/cdp_mngr_intf.shr"; // weak
_UNKNOWN unk_10134350; // weak
_UNKNOWN unk_10134358; // weak
int (*off_10136284[3])() = { &_fptrap, &_fptrap, &_fptrap }; // weak
_UNKNOWN unk_101362A8; // weak
void *off_10136CC0 = &unk_10789FE0; // weak
_UNKNOWN unk_10136CD0; // weak
_UNKNOWN unk_10136D30; // weak
int dword_10136F40 = 2; // weak
int dword_10137130 = 1024; // weak
int dword_10137134 = 4294966273; // weak
int dword_10137138 = 53; // weak
int dword_1013713C = 11; // weak
int dword_10137140 = 64; // weak
int dword_10137144 = 1023; // weak
int dword_10137148 = 128; // weak
int dword_1013714C = 4294967169; // weak
int dword_10137150 = 24; // weak
int dword_10137154 = 8; // weak
int dword_10137158 = 32; // weak
int dword_1013715C = 127; // weak
_UNKNOWN unk_10137780; // weak
int dword_10137790 = 0; // weak
_UNKNOWN unk_1013F4B0; // weak
char byte_1013F4B4; // weak
int dword_1013F4B8; // weak
_UNKNOWN unk_1013F4C0; // weak
char byte_1013F590; // weak
char byte_1013F598; // idb
int dword_10140598; // weak
char byte_101405A0[]; // weak
char byte_101405A2[]; // weak
__int16 word_101405A4[]; // weak
int dword_101405A8; // weak
int dword_101405AC[]; // weak
__int16 word_101405B0[]; // weak
char byte_101405B8[]; // weak
char byte_10140650; // weak
char byte_10140651; // weak
_UNKNOWN unk_10140658; // weak
_UNKNOWN unk_1014068A; // weak
int dword_101406BC[]; // weak
_UNKNOWN unk_101406C0; // weak
char byte_10141FF0; // weak
int dword_10141FF8; // weak
int dword_10141FFC; // weak
int dword_10142000; // weak
int dword_10142004; // weak
_UNKNOWN unk_10142008; // weak
int dword_10319588; // weak
int dword_1031958C; // weak
_UNKNOWN unk_10319590; // weak
_UNKNOWN unk_10325476; // weak
int dword_103D9590; // weak
int dword_103D9594; // weak
int dword_103D9598; // weak
int dword_103D959C; // weak
_UNKNOWN unk_103D95A8; // weak
_UNKNOWN unk_103D95AC; // weak
char byte_103D96C0; // weak
char byte_103D96C1; // weak
_UNKNOWN unk_103D96C8; // weak
_UNKNOWN unk_104D96C8; // weak
char byte_104D96C9[]; // weak
char byte_104D9AD4[]; // weak
int dword_104D9AD8[]; // weak
char byte_104D9AE4[]; // weak
char byte_104D9AE5[]; // weak
char byte_104D9AE6[]; // weak
_BYTE byte_104D9AE7[3121]; // idb
int dword_104DA718; // weak
int dword_104DA71C; // weak
int dword_104DA720; // weak
float flt_104DA724; // weak
double dbl_104DA728; // weak
double dbl_104DA730; // weak
double dbl_104DA738; // weak
char byte_104DA740; // weak
char byte_104DA741; // weak
char byte_104DA742; // weak
char byte_104DA743; // weak
int dword_104DA744; // weak
char byte_104DA748; // weak
char byte_104DA749; // weak
_UNKNOWN unk_104DAB28; // weak
int dword_104DAB54; // weak
int dword_104DAB58; // weak
int dword_104DAB5C; // weak
int dword_104DAB60; // weak
int dword_104DAB64; // weak
int dword_104DAB6C; // weak
int dword_104DAB70; // weak
int dword_104DAB74; // weak
int dword_104DAB78; // weak
int dword_104DAB7C; // weak
int dword_104DAB80; // weak
int dword_104DAB84; // weak
int dword_104DAB88; // weak
int dword_104DAB8C; // weak
int dword_104DAB90; // weak
int dword_104DAB94; // weak
int dword_104DAB98; // weak
int dword_104DAB9C; // weak
int dword_104DABA0; // weak
int dword_104DABA4; // weak
int dword_104DABA8; // weak
int dword_104DABAC; // weak
int dword_104DABB0; // weak
int dword_104DABB4; // weak
char byte_104DABC4; // weak
char byte_104DABC5; // weak
char byte_104DABC6; // weak
int dword_104DABD4; // weak
float flt_104DABD8; // weak
double dbl_104DABDC; // weak
double dbl_104DABE4; // weak
double dbl_104DABEC; // weak
double dbl_104DABF4; // weak
double dbl_104DABFC; // weak
double dbl_104DAC04; // weak
int dword_104DAC10; // weak
float flt_104DAC14; // weak
double dbl_104DAC18; // weak
double dbl_104DAC20; // weak
double dbl_104DAC28; // weak
char byte_104DACB0; // weak
char byte_104DACB1; // weak
_UNKNOWN unk_104DACB4; // weak
char byte_104DACE0; // weak
_UNKNOWN unk_104DACE8; // weak
int dword_104DACF0; // weak
int dword_104DACF4; // weak
int dword_104DACF8; // weak
int dword_104DACFC; // weak
int dword_104DAD08; // weak
_UNKNOWN unk_104DAD18; // weak
char byte_104DDF18; // weak
_UNKNOWN unk_104DDF28; // weak
_UNKNOWN unk_104DDF54; // weak
_UNKNOWN unk_104E4FD4; // weak
int dword_104E5024; // weak
_UNKNOWN unk_104E5028; // weak
_UNKNOWN unk_104E5054; // weak
int dword_104E6C74; // weak
int dword_104E6C78; // weak
int dword_104E6C7C; // weak
int dword_104E6C80; // weak
int dword_104E6C84; // weak
int dword_104E6C88; // weak
int dword_104E6C8C; // weak
int dword_104E6C90; // weak
int dword_104E6C94; // weak
int dword_104E6C98; // weak
int dword_104E6C9C; // weak
int dword_104E6CA0; // weak
int dword_104E6CA4; // weak
int dword_104E6CA8; // weak
int dword_104E6CAC; // weak
int dword_104E6CB0; // weak
char byte_104E6CB4; // weak
float flt_104E6CB8[]; // weak
float flt_104E6CBC[]; // weak
float flt_104E6CC0[]; // weak
float flt_104E6CC4[]; // weak
float flt_104E6CC8[]; // weak
float flt_104E6CCC[]; // weak
float flt_104E6CD0[]; // weak
float flt_104E6CD4[]; // weak
int dword_104E6CF8; // weak
int dword_104E6CFC; // weak
__int16 word_104E6D00; // weak
float flt_104E6D08[]; // weak
float flt_104E6D0C[]; // weak
int dword_104E6D48[]; // weak
float flt_104E6D50[]; // weak
float flt_104E6D54[]; // weak
float flt_104E6D58[]; // weak
float flt_104E6D5C[]; // weak
float flt_104E6D60[]; // weak
float flt_104E6D64[]; // weak
float flt_104E6D68[]; // weak
float flt_104E6D6C[]; // weak
int dword_104E6D90[]; // weak
char byte_104E6D94[]; // weak
char byte_104E6D95[]; // weak
int dword_104E6DA0[]; // weak
char byte_104E6DA4[]; // weak
float flt_104E6DB0[]; // weak
float flt_104E6DB4[]; // weak
float flt_104E6DB8[]; // weak
float flt_104E6DBC[]; // weak
float flt_104E6DC0[]; // weak
float flt_104E6DC4[]; // weak
float flt_104E6DC8[]; // weak
float flt_104E6DCC[]; // weak
float flt_104E6DF0[]; // weak
int dword_104E6E00; // weak
int dword_104E6E04; // weak
int dword_104E6E08; // weak
char byte_104E6E0C; // weak
char byte_104E6E0D; // weak
int dword_104E6E10; // weak
int dword_104E6E14; // weak
_UNKNOWN unk_104E6E18; // weak
_UNKNOWN unk_10624DD3; // weak
int dword_1065DEA8; // weak
void *dword_1065DEAC; // idb
int dword_1065DEB0; // weak
int dword_1065DEB4; // weak
int dword_1065DEB8[]; // weak
int dword_1065DEBC[]; // weak
int dword_1065DEC4; // weak
int dword_1065DEC8; // weak
char *dword_1065DECC; // idb
__int16 word_1065DED0[]; // weak
char byte_1065DEF8[]; // weak
__int16 word_1065E07C; // weak
__int16 word_1065E080; // weak
__int16 word_1065E084; // weak
int dword_1065E088; // weak
void (__cdecl *dword_1065E090[8])(_DWORD, _DWORD, _DWORD); // idb
_UNKNOWN unk_1065E0B0; // weak
char byte_10668788; // weak
char byte_10668789; // weak
int dword_10673E48; // weak
int dword_10673E4C[]; // weak
int dword_10673E60; // weak
int dword_10673E64; // weak
_UNKNOWN unk_10673E68; // weak
_UNKNOWN unk_10673E69; // weak
_UNKNOWN unk_10673E7F; // weak
_UNKNOWN unk_10673E80; // weak
_UNKNOWN unk_10673E81; // weak
_UNKNOWN unk_10673E82; // weak
_UNKNOWN unk_10673E84; // weak
_UNKNOWN unk_10673E88; // weak
_UNKNOWN unk_10673E8C; // weak
_UNKNOWN unk_10673EAC; // weak
_UNKNOWN unk_10673ECC; // weak
_UNKNOWN unk_10673EEC; // weak
_UNKNOWN unk_10673F0C; // weak
_UNKNOWN unk_10673F2C; // weak
_UNKNOWN unk_10673F4C; // weak
_UNKNOWN unk_10673F6C; // weak
_UNKNOWN unk_10673F8C; // weak
_UNKNOWN unk_10673FAC; // weak
_UNKNOWN unk_10673FCC; // weak
_UNKNOWN unk_10673FEC; // weak
_UNKNOWN unk_1067400C; // weak
_UNKNOWN unk_1067402C; // weak
_UNKNOWN unk_1067404C; // weak
_UNKNOWN unk_1067406C; // weak
_UNKNOWN unk_1067408C; // weak
_UNKNOWN unk_106740AC; // weak
_UNKNOWN unk_106740CC; // weak
_UNKNOWN unk_106740EC; // weak
_UNKNOWN unk_1067410C; // weak
_UNKNOWN unk_1067412C; // weak
_UNKNOWN unk_1067414C; // weak
_UNKNOWN unk_1067416C; // weak
_UNKNOWN unk_1067418C; // weak
_UNKNOWN unk_106741AC; // weak
_UNKNOWN unk_106741CC; // weak
_UNKNOWN unk_106741EC; // weak
_UNKNOWN unk_1067420C; // weak
_UNKNOWN unk_10674210; // weak
_UNKNOWN unk_10674214; // weak
_UNKNOWN unk_10674218; // weak
_UNKNOWN unk_1067421C; // weak
_UNKNOWN unk_10674220; // weak
_UNKNOWN unk_10674224; // weak
_UNKNOWN unk_10674244; // weak
_UNKNOWN unk_10674264; // weak
_UNKNOWN unk_10674284; // weak
_UNKNOWN unk_106742A4; // weak
_UNKNOWN unk_106742C4; // weak
_UNKNOWN unk_106742E4; // weak
_UNKNOWN unk_10674304; // weak
_UNKNOWN unk_10674324; // weak
_UNKNOWN unk_10674325; // weak
_UNKNOWN unk_10674326; // weak
_UNKNOWN unk_10674378; // weak
_UNKNOWN unk_10674398; // weak
_UNKNOWN unk_106743B8; // weak
_UNKNOWN unk_106743BC; // weak
_UNKNOWN unk_106743C0; // weak
_UNKNOWN unk_106743C4; // weak
_UNKNOWN unk_106743E4; // weak
_UNKNOWN unk_10674404; // weak
_UNKNOWN unk_10674424; // weak
_UNKNOWN unk_10674444; // weak
_UNKNOWN unk_10674464; // weak
_UNKNOWN unk_10674484; // weak
_UNKNOWN unk_106744A4; // weak
_UNKNOWN unk_106744C4; // weak
_UNKNOWN unk_106744E4; // weak
_UNKNOWN unk_1067452C; // weak
_UNKNOWN unk_10674574; // weak
_UNKNOWN unk_106745BC; // weak
_UNKNOWN unk_10674604; // weak
_UNKNOWN unk_1067464C; // weak
_UNKNOWN unk_10674694; // weak
_UNKNOWN unk_106746DC; // weak
_UNKNOWN unk_10674724; // weak
_UNKNOWN unk_1067476C; // weak
_UNKNOWN unk_106747B4; // weak
_UNKNOWN unk_106747FC; // weak
_UNKNOWN unk_10674844; // weak
_UNKNOWN unk_1067488C; // weak
_UNKNOWN unk_106748D4; // weak
_UNKNOWN unk_1067491C; // weak
_UNKNOWN unk_10674964; // weak
_UNKNOWN unk_106749AC; // weak
_UNKNOWN unk_106749F4; // weak
_UNKNOWN unk_10674A3C; // weak
_UNKNOWN unk_10674A84; // weak
_UNKNOWN unk_10674ACC; // weak
_UNKNOWN unk_10674B14; // weak
_UNKNOWN unk_10674B5C; // weak
_UNKNOWN unk_10674BA4; // weak
_UNKNOWN unk_10674BEC; // weak
_UNKNOWN unk_10674C34; // weak
_UNKNOWN unk_10674C7C; // weak
_UNKNOWN unk_10674CC4; // weak
_UNKNOWN unk_10674D0C; // weak
_UNKNOWN unk_10674D54; // weak
_UNKNOWN unk_10674D6C; // weak
_UNKNOWN unk_10674D8C; // weak
_UNKNOWN unk_10674DAC; // weak
_UNKNOWN unk_10674DB0; // weak
_UNKNOWN unk_10674E54; // weak
_UNKNOWN unk_10674EF8; // weak
_UNKNOWN unk_10674F9C; // weak
_UNKNOWN unk_10675040; // weak
_UNKNOWN unk_106750E4; // weak
_UNKNOWN unk_10675188; // weak
_UNKNOWN unk_1067522C; // weak
_UNKNOWN unk_106752D0; // weak
_UNKNOWN unk_10675374; // weak
_UNKNOWN unk_10675418; // weak
_UNKNOWN unk_106754BC; // weak
_UNKNOWN unk_10675560; // weak
_UNKNOWN unk_10675604; // weak
_UNKNOWN unk_106756A8; // weak
_UNKNOWN unk_1067574C; // weak
_UNKNOWN unk_106757F0; // weak
_UNKNOWN unk_10675894; // weak
_UNKNOWN unk_10675938; // weak
_UNKNOWN unk_106759DC; // weak
_UNKNOWN unk_10675A80; // weak
_UNKNOWN unk_10675B24; // weak
_UNKNOWN unk_10675BC8; // weak
_UNKNOWN unk_10675C6C; // weak
_UNKNOWN unk_10675D10; // weak
_UNKNOWN unk_10675DB4; // weak
_UNKNOWN unk_10675E58; // weak
_UNKNOWN unk_10675EFC; // weak
_UNKNOWN unk_10675FA0; // weak
_UNKNOWN unk_10676044; // weak
_UNKNOWN unk_106760E8; // weak
_UNKNOWN unk_1067618C; // weak
_UNKNOWN unk_10676230; // weak
_UNKNOWN unk_106762D4; // weak
_UNKNOWN unk_10676378; // weak
_UNKNOWN unk_1067641C; // weak
_UNKNOWN unk_106764C0; // weak
_UNKNOWN unk_10676564; // weak
_UNKNOWN unk_10676608; // weak
_UNKNOWN unk_106766AC; // weak
_UNKNOWN unk_10676750; // weak
_UNKNOWN unk_106767F4; // weak
_UNKNOWN unk_10676898; // weak
_UNKNOWN unk_1067693C; // weak
_UNKNOWN unk_106769E0; // weak
_UNKNOWN unk_10676A84; // weak
_UNKNOWN unk_10676B28; // weak
_UNKNOWN unk_10676BCC; // weak
_UNKNOWN unk_10676C70; // weak
_UNKNOWN unk_10676D14; // weak
_UNKNOWN unk_10676DB8; // weak
_UNKNOWN unk_10676E5C; // weak
_UNKNOWN unk_10676F00; // weak
_UNKNOWN unk_10676FA4; // weak
_UNKNOWN unk_10677048; // weak
_UNKNOWN unk_106770EC; // weak
_UNKNOWN unk_10677190; // weak
_UNKNOWN unk_10677234; // weak
_UNKNOWN unk_106772D8; // weak
_UNKNOWN unk_1067737C; // weak
_UNKNOWN unk_10677420; // weak
_UNKNOWN unk_106774C4; // weak
_UNKNOWN unk_10677568; // weak
_UNKNOWN unk_1067760C; // weak
_UNKNOWN unk_106776B0; // weak
_UNKNOWN unk_10677754; // weak
_UNKNOWN unk_106777F8; // weak
_UNKNOWN unk_1067789C; // weak
_UNKNOWN unk_10677940; // weak
_UNKNOWN unk_106779E4; // weak
_UNKNOWN unk_10677A88; // weak
_UNKNOWN unk_10677B2C; // weak
_UNKNOWN unk_10677BD0; // weak
_UNKNOWN unk_10677C74; // weak
_UNKNOWN unk_10677D18; // weak
_UNKNOWN unk_10677DBC; // weak
_UNKNOWN unk_10677E60; // weak
_UNKNOWN unk_10677F04; // weak
_UNKNOWN unk_10677FA8; // weak
_UNKNOWN unk_1067804C; // weak
_UNKNOWN unk_106780F0; // weak
_UNKNOWN unk_10678194; // weak
_UNKNOWN unk_10678238; // weak
_UNKNOWN unk_106782DC; // weak
_UNKNOWN unk_10678380; // weak
_UNKNOWN unk_10678424; // weak
_UNKNOWN unk_106784C8; // weak
_UNKNOWN unk_1067856C; // weak
_UNKNOWN unk_10678610; // weak
_UNKNOWN unk_106786B4; // weak
_UNKNOWN unk_10678758; // weak
_UNKNOWN unk_106787FC; // weak
_UNKNOWN unk_106788A0; // weak
_UNKNOWN unk_10678944; // weak
_UNKNOWN unk_106789E8; // weak
_UNKNOWN unk_10678A8C; // weak
_UNKNOWN unk_10678B30; // weak
_UNKNOWN unk_10678BD4; // weak
_UNKNOWN unk_10678C78; // weak
_UNKNOWN unk_10678D1C; // weak
_UNKNOWN unk_10678DC0; // weak
_UNKNOWN unk_10678DE0; // weak
_UNKNOWN unk_10678E00; // weak
_UNKNOWN unk_10678E20; // weak
_UNKNOWN unk_10678E40; // weak
_UNKNOWN unk_10678E68; // weak
_UNKNOWN unk_10678E84; // weak
_UNKNOWN unk_10678EA0; // weak
_UNKNOWN unk_10678EBC; // weak
_UNKNOWN unk_10678ED8; // weak
_UNKNOWN unk_10678EF4; // weak
_UNKNOWN unk_10678F10; // weak
_UNKNOWN unk_10678F2C; // weak
_UNKNOWN unk_10678F48; // weak
_UNKNOWN unk_10678F64; // weak
_UNKNOWN unk_10678F80; // weak
_UNKNOWN unk_10678F9C; // weak
_UNKNOWN unk_10678FB8; // weak
_UNKNOWN unk_10678FD4; // weak
_UNKNOWN unk_10678FF0; // weak
_UNKNOWN unk_1067900C; // weak
_UNKNOWN unk_10679028; // weak
_UNKNOWN unk_10679044; // weak
_UNKNOWN unk_10679060; // weak
_UNKNOWN unk_1067907C; // weak
_UNKNOWN unk_10679098; // weak
_UNKNOWN unk_106790B4; // weak
_UNKNOWN unk_106790D0; // weak
_UNKNOWN unk_106790EC; // weak
_UNKNOWN unk_10679108; // weak
_UNKNOWN unk_10679124; // weak
_UNKNOWN unk_10679140; // weak
_UNKNOWN unk_1067915C; // weak
_UNKNOWN unk_10679178; // weak
_UNKNOWN unk_10679194; // weak
_UNKNOWN unk_106791B0; // weak
_UNKNOWN unk_106791CC; // weak
_UNKNOWN unk_106791E8; // weak
_UNKNOWN unk_10679204; // weak
_UNKNOWN unk_10679220; // weak
_UNKNOWN unk_1067923C; // weak
_UNKNOWN unk_10679258; // weak
_UNKNOWN unk_10679274; // weak
_UNKNOWN unk_10679290; // weak
_UNKNOWN unk_106792AC; // weak
_UNKNOWN unk_106792C8; // weak
_UNKNOWN unk_106792E4; // weak
_UNKNOWN unk_10679300; // weak
_UNKNOWN unk_1067931C; // weak
_UNKNOWN unk_10679338; // weak
_UNKNOWN unk_10679354; // weak
_UNKNOWN unk_10679370; // weak
_UNKNOWN unk_1067938C; // weak
_UNKNOWN unk_106793A8; // weak
_UNKNOWN unk_106793C4; // weak
_UNKNOWN unk_106793E0; // weak
_UNKNOWN unk_106793FC; // weak
_UNKNOWN unk_10679418; // weak
_UNKNOWN unk_10679434; // weak
_UNKNOWN unk_10679450; // weak
_UNKNOWN unk_1067946C; // weak
_UNKNOWN unk_10679488; // weak
_UNKNOWN unk_106794A4; // weak
_UNKNOWN unk_106794C0; // weak
_UNKNOWN unk_106794DC; // weak
_UNKNOWN unk_106794F8; // weak
_UNKNOWN unk_10679514; // weak
_UNKNOWN unk_10679530; // weak
_UNKNOWN unk_1067954C; // weak
_UNKNOWN unk_10679568; // weak
_UNKNOWN unk_10679584; // weak
_UNKNOWN unk_106795A0; // weak
_UNKNOWN unk_106795BC; // weak
_UNKNOWN unk_106795D8; // weak
_UNKNOWN unk_106795F4; // weak
_UNKNOWN unk_10679610; // weak
_UNKNOWN unk_1067962C; // weak
_UNKNOWN unk_10679648; // weak
_UNKNOWN unk_10679664; // weak
_UNKNOWN unk_10679680; // weak
_UNKNOWN unk_1067969C; // weak
_UNKNOWN unk_106796B8; // weak
_UNKNOWN unk_106796D4; // weak
_UNKNOWN unk_106796F0; // weak
_UNKNOWN unk_1067970C; // weak
_UNKNOWN unk_10679728; // weak
_UNKNOWN unk_10679744; // weak
_UNKNOWN unk_10679760; // weak
_UNKNOWN unk_1067977C; // weak
_UNKNOWN unk_10679798; // weak
_UNKNOWN unk_106797B4; // weak
_UNKNOWN unk_106797D0; // weak
_UNKNOWN unk_106797EC; // weak
_UNKNOWN unk_10679808; // weak
_UNKNOWN unk_10679824; // weak
_UNKNOWN unk_10679840; // weak
_UNKNOWN unk_1067985C; // weak
_UNKNOWN unk_10679878; // weak
_UNKNOWN unk_10679894; // weak
_UNKNOWN unk_106798B0; // weak
_UNKNOWN unk_106798CC; // weak
_UNKNOWN unk_106798E8; // weak
_UNKNOWN unk_10679904; // weak
_UNKNOWN unk_10679920; // weak
_UNKNOWN unk_1067993C; // weak
_UNKNOWN unk_10679958; // weak
_UNKNOWN unk_1067995C; // weak
_UNKNOWN unk_10679960; // weak
_UNKNOWN unk_10679964; // weak
_UNKNOWN unk_10679968; // weak
_UNKNOWN unk_1067996C; // weak
_UNKNOWN unk_10679970; // weak
_UNKNOWN unk_10679974; // weak
_UNKNOWN unk_10679978; // weak
_UNKNOWN unk_1067997C; // weak
_UNKNOWN unk_10679980; // weak
_UNKNOWN unk_10679984; // weak
_UNKNOWN unk_10679988; // weak
_UNKNOWN unk_1067998C; // weak
_UNKNOWN unk_10679990; // weak
_UNKNOWN unk_10679994; // weak
_UNKNOWN unk_10679998; // weak
_UNKNOWN unk_1067999C; // weak
_UNKNOWN unk_106799A0; // weak
_UNKNOWN unk_10679A84; // weak
_UNKNOWN unk_1067AC44; // weak
_UNKNOWN unk_1067AC48; // weak
_UNKNOWN unk_1067AC70; // weak
_UNKNOWN unk_1067AC98; // weak
_UNKNOWN unk_1067ACD8; // weak
_UNKNOWN unk_1067AD58; // weak
_UNKNOWN unk_1067AD5C; // weak
_UNKNOWN unk_1067AD60; // weak
_UNKNOWN unk_1067AD62; // weak
_UNKNOWN unk_1067AD64; // weak
_UNKNOWN unk_1067AD65; // weak
_UNKNOWN unk_1067AD66; // weak
_UNKNOWN unk_1067AD68; // weak
_UNKNOWN unk_1067ADCC; // weak
_UNKNOWN unk_1067ADD4; // weak
_UNKNOWN unk_1067ADDC; // weak
_UNKNOWN unk_1067ADE4; // weak
_UNKNOWN unk_1067ADEC; // weak
_UNKNOWN unk_1067ADF4; // weak
_UNKNOWN unk_1067ADFC; // weak
_UNKNOWN unk_1067AE04; // weak
_UNKNOWN unk_1067AE0C; // weak
_UNKNOWN unk_1067AE14; // weak
_UNKNOWN unk_1067AE1C; // weak
_UNKNOWN unk_1067AE24; // weak
_UNKNOWN unk_1067AE2C; // weak
_UNKNOWN unk_1067AE34; // weak
_UNKNOWN unk_1067AE3C; // weak
_UNKNOWN unk_1067AE44; // weak
_UNKNOWN unk_1067AE4C; // weak
_UNKNOWN unk_1067AE54; // weak
_UNKNOWN unk_1067AE5C; // weak
_UNKNOWN unk_1067AE64; // weak
_UNKNOWN unk_1067AE6C; // weak
_UNKNOWN unk_1067AE74; // weak
_UNKNOWN unk_1067AE7C; // weak
_UNKNOWN unk_1067AE84; // weak
_UNKNOWN unk_1067AE8C; // weak
_UNKNOWN unk_1067AE94; // weak
_UNKNOWN unk_1067AE9C; // weak
_UNKNOWN unk_1067AEA4; // weak
_UNKNOWN unk_1067AEAC; // weak
_UNKNOWN unk_1067AEB4; // weak
_UNKNOWN unk_1067AEBC; // weak
_UNKNOWN unk_1067AEC4; // weak
_UNKNOWN unk_1067AECC; // weak
_UNKNOWN unk_1067AED4; // weak
_UNKNOWN unk_1067AEDC; // weak
_UNKNOWN unk_1067AEE4; // weak
_UNKNOWN unk_1067AEEC; // weak
_UNKNOWN unk_1067AEF4; // weak
_UNKNOWN unk_1067AEFC; // weak
_UNKNOWN unk_1067AF04; // weak
_UNKNOWN unk_1067B0EC; // weak
_UNKNOWN unk_1067B0FC; // weak
_UNKNOWN unk_1067B10C; // weak
_UNKNOWN unk_1067B11C; // weak
_UNKNOWN unk_1067B11D; // weak
_UNKNOWN unk_1067B11E; // weak
_UNKNOWN unk_1067B120; // weak
_UNKNOWN unk_1067B124; // weak
_UNKNOWN unk_1067B1CC; // weak
_UNKNOWN unk_1067B1D0; // weak
_UNKNOWN unk_1067B1D4; // weak
_UNKNOWN unk_1067B224; // weak
_UNKNOWN unk_1067B228; // weak
_UNKNOWN unk_1067B22C; // weak
_UNKNOWN unk_1067B31C; // weak
_UNKNOWN unk_1067B40C; // weak
_UNKNOWN unk_1067B410; // weak
_UNKNOWN unk_1067B418; // weak
_UNKNOWN unk_1067B420; // weak
_UNKNOWN unk_1067B428; // weak
_UNKNOWN unk_1067B430; // weak
_UNKNOWN unk_1067B438; // weak
_UNKNOWN unk_1067B440; // weak
_UNKNOWN unk_1067B448; // weak
_UNKNOWN unk_1067B450; // weak
_UNKNOWN unk_1067B458; // weak
_UNKNOWN unk_1067B460; // weak
_UNKNOWN unk_1067B468; // weak
_UNKNOWN unk_1067B46C; // weak
_UNKNOWN unk_1067B470; // weak
_UNKNOWN unk_1067B474; // weak
_UNKNOWN unk_1067B4C8; // weak
_UNKNOWN unk_1067B51C; // weak
_UNKNOWN unk_1067B524; // weak
_UNKNOWN unk_1067B528; // weak
_UNKNOWN unk_1067B52C; // weak
_UNKNOWN unk_1067B530; // weak
_UNKNOWN unk_1067B534; // weak
_UNKNOWN unk_1067B73C; // weak
_UNKNOWN unk_1067B89C; // weak
_UNKNOWN unk_1067B8B4; // weak
_UNKNOWN unk_1067B8CC; // weak
_UNKNOWN unk_1067B8D6; // weak
_UNKNOWN unk_1067B8D8; // weak
_UNKNOWN unk_1067B8E8; // weak
_UNKNOWN unk_1067B8EC; // weak
_UNKNOWN unk_1067B8F0; // weak
_UNKNOWN unk_1067B8F4; // weak
_UNKNOWN unk_1067B8F5; // weak
_UNKNOWN unk_1067B8F8; // weak
_UNKNOWN unk_1067B948; // weak
_UNKNOWN unk_1067B94C; // weak
_UNKNOWN unk_1067B94D; // weak
_UNKNOWN unk_1067B94E; // weak
_UNKNOWN unk_1067B94F; // weak
_UNKNOWN unk_1067B963; // weak
_UNKNOWN unk_1067B964; // weak
_UNKNOWN unk_1067B965; // weak
_UNKNOWN unk_1067B966; // weak
_UNKNOWN unk_1067B968; // weak
_UNKNOWN unk_1067BA08; // weak
_UNKNOWN unk_1067BA58; // weak
_UNKNOWN unk_1067BA5C; // weak
_UNKNOWN unk_1067BA60; // weak
_UNKNOWN unk_1067BA64; // weak
_UNKNOWN unk_1067BA68; // weak
_UNKNOWN unk_1067BA6C; // weak
_UNKNOWN unk_1067BA70; // weak
_UNKNOWN unk_1067BA74; // weak
_UNKNOWN unk_1067BA78; // weak
_UNKNOWN unk_1067BA7C; // weak
_UNKNOWN unk_1067BA80; // weak
_UNKNOWN unk_1067BA84; // weak
_UNKNOWN unk_1067BA88; // weak
_UNKNOWN unk_1067BBC8; // weak
_UNKNOWN unk_1067BBD4; // weak
_UNKNOWN unk_1067BC1C; // weak
_UNKNOWN unk_1067BC1D; // weak
_UNKNOWN unk_1067BC48; // weak
_UNKNOWN unk_1067BC78; // weak
_UNKNOWN unk_1067BCA0; // weak
_UNKNOWN unk_1067BCA4; // weak
_UNKNOWN unk_1067BCA8; // weak
_UNKNOWN unk_1067BCAC; // weak
_UNKNOWN unk_1067BCDC; // weak
_UNKNOWN unk_1067BCDD; // weak
_UNKNOWN unk_1067BCDE; // weak
_UNKNOWN unk_1067BCE0; // weak
_UNKNOWN unk_1067BCE4; // weak
_UNKNOWN unk_1067BCE8; // weak
_UNKNOWN unk_1067BCEC; // weak
_UNKNOWN unk_1067BCF0; // weak
_UNKNOWN unk_1067BCF4; // weak
_UNKNOWN unk_1067BCF8; // weak
_UNKNOWN unk_1067BCFC; // weak
_UNKNOWN unk_1067BD00; // weak
_UNKNOWN unk_1067BD04; // weak
_UNKNOWN unk_1067C064; // weak
_UNKNOWN unk_1067C068; // weak
_UNKNOWN unk_1067C072; // weak
_UNKNOWN unk_1067C07C; // weak
int dword_1067D838; // weak
int dword_1067D840; // weak
_UNKNOWN unk_1067D848; // weak
char byte_1067DB20[]; // weak
char byte_1067DB21[]; // weak
char byte_1067DB40[]; // weak
char byte_1067DB41[]; // weak
_UNKNOWN unk_1067ED88; // weak
_UNKNOWN unk_10680738; // weak
int dword_1068073C; // weak
int dword_10680740; // weak
int dword_106AD1BC; // weak
int dword_106AD1C0; // weak
int dword_106AD1C4; // weak
int dword_106AD1C8; // weak
int dword_106AD1CC; // weak
int dword_106AD1D0; // weak
int dword_106AD1D4; // weak
int dword_106AD1D8; // weak
int dword_106AD1DC; // weak
int dword_106AD1E0; // weak
int dword_106AD1E4; // weak
int dword_106AD1E8; // weak
int dword_106AD1EC; // weak
int dword_106AD1F0; // weak
int dword_106AD1F4; // weak
int dword_106AD1F8; // weak
char byte_106AD1FC; // weak
int dword_106AD200; // weak
char byte_106AD208[104]; // idb
char byte_106AD270; // weak
char byte_106AD271; // weak
char byte_106AD272; // weak
char byte_106AD273; // weak
_UNKNOWN unk_106AD278; // weak
_UNKNOWN unk_106AD298; // weak
float flt_106AD2BC; // weak
float flt_106AD2C0; // weak
int dword_106AD2C4; // weak
char byte_106AD2C8; // weak
int dword_106AD2EC; // weak
int dword_106AD2F0; // weak
int dword_106AD2F4; // weak
int dword_106AD2F8; // weak
int dword_106BAA48[]; // weak
int dword_106BAA4C; // weak
int dword_106BAA50; // weak
int dword_106BAA54; // weak
int dword_106BAA58; // weak
int dword_106BAA5C[]; // weak
int dword_106BAA60; // weak
int dword_106BAA64; // weak
int dword_106BAA68; // weak
int dword_106BAA6C; // weak
_UNKNOWN unk_106BAA70; // weak
char byte_106BAB88; // idb
char byte_106BAC88[254]; // idb
char byte_106BAD86[]; // weak
char byte_106BAD87[]; // weak
char byte_106BB188[2800]; // idb
char byte_106BBC78[1022]; // idb
char byte_106BC076[]; // weak
char byte_106BC077[]; // weak
char byte_106BC078[1022]; // idb
char byte_106BC476[]; // weak
char byte_106BC477[]; // weak
char byte_106BC478[1022]; // idb
char byte_106BC876[]; // weak
char byte_106BC877[]; // weak
int dword_106BF878[]; // weak
int dword_106BF88C[]; // weak
char byte_106BF8A0[2800]; // idb
char byte_106C0390[2800]; // idb
char byte_106C0E80[2800]; // idb
int dword_106C1970[]; // weak
int dword_106C1984[]; // weak
char byte_106C1998[2796]; // idb
char byte_106C2484[]; // weak
char byte_106C2488[559]; // idb
char byte_106C26B7[]; // weak
int dword_106C2F78[]; // weak
int dword_106C2F8C[]; // weak
char byte_106C2FA0[2800]; // idb
int dword_106C3A90; // weak
_UNKNOWN unk_106C3A98; // weak
_UNKNOWN unk_106C45F0; // weak
int dword_106C6958; // weak
_UNKNOWN unk_106C6960; // weak
int dword_106C7EA0; // weak
char byte_106C7EA8[]; // weak
char byte_106C7EAC[]; // weak
char byte_106C7EAD[]; // weak
int dword_106C7EB4[]; // weak
int dword_106C7EBC[]; // weak
char byte_106CA780[]; // weak
char byte_106CA781[]; // weak
_UNKNOWN unk_106CA820; // weak
int dword_106CAAF0[]; // weak
int dword_106CAAF4[]; // weak
_UNKNOWN unk_106CB010; // weak
_UNKNOWN unk_106CDF18; // weak
_UNKNOWN unk_106CE418; // weak
_UNKNOWN unk_106CE4C0; // weak
_UNKNOWN unk_106CE510; // weak
_UNKNOWN unk_106CE518; // weak
_UNKNOWN unk_106CE520; // weak
int dword_10730270; // weak
char byte_10730278[]; // weak
char byte_107302C8[]; // weak
char byte_10737618; // weak
char byte_10737619; // weak
int dword_1073762C; // weak
int dword_10737630; // weak
int dword_10737634; // weak
int dword_10737638; // weak
int dword_1073763C; // weak
int dword_10737640; // weak
_UNKNOWN unk_1073CE48; // weak
void *dword_1073CEC8; // idb
_UNKNOWN unk_1073CED0; // weak
_UNKNOWN unk_1073D1B0; // weak
_UNKNOWN unk_107488F8; // weak
int dword_10755CDC; // weak
_DWORD dword_10755CE0[16]; // idb
int dword_10755D20[]; // weak
int dword_10755D60; // weak
int dword_10755D68[]; // weak
_UNKNOWN unk_10755DA8; // weak
int dword_107561C0; // weak
int dword_107564EC; // weak
int dword_10756504; // weak
int dword_10756510; // weak
int dword_10756B28; // weak
int dword_10756B34; // weak
int dword_10756B40; // weak
int dword_10756B44; // weak
int dword_10756B48; // weak
int dword_10756B64; // weak
int dword_10756B68; // weak
int dword_10756B6C; // weak
int dword_10756B70; // weak
int dword_10756B74; // weak
__int16 word_10756F50; // weak
int dword_10756F54; // weak
int dword_10756F58; // weak
char byte_10756F5C; // weak
char byte_10756F5D; // weak
char byte_10756F5E; // weak
int dword_10756F60; // weak
_UNKNOWN unk_10756F64; // weak
char byte_10788F80; // weak
char byte_10788F81; // weak
char byte_10788F82; // weak
char byte_10788F84; // weak
char byte_10788F8B; // weak
__int16 word_10788F8E; // weak
__int16 word_10788F90; // weak
__int16 word_10788F94; // weak
int dword_10788F98; // weak
int dword_10788F9C; // weak
int dword_10788FB4; // weak
int dword_10788FC0; // weak
int dword_10788FC8; // weak
char byte_10789108; // weak
int dword_1078915C; // weak
char byte_10789160; // weak
int dword_10789180[]; // weak
_BYTE dword_10789184[1128]; // idb
_UNKNOWN unk_107895EC; // weak
int dword_10789600[]; // weak
int dword_10789604[]; // weak
char byte_10789611[]; // weak
int dword_107896C8; // weak
char byte_107896CC; // weak
__int16 word_107896CE; // weak
__int16 word_107896D0; // weak
char byte_107896D2; // weak
__int16 word_107896D4; // weak
char byte_107896D6; // weak
int dword_107896E0; // weak
char byte_107896E4; // weak
int dword_107896E8; // weak
char byte_107896EC; // weak
int dword_107896F0; // weak
char byte_107896F4; // weak
int dword_107896F8; // weak
int dword_107896FC; // weak
int dword_10789700; // weak
int dword_10789704; // weak
int dword_10789708; // weak
int dword_10789710; // weak
int dword_10789714; // weak
int dword_10789718; // weak
int dword_1078971C; // weak
int dword_10789720; // weak
int dword_10789724; // weak
char byte_10789728; // weak
int dword_10789740[]; // weak
__int16 word_10789744[]; // weak
int dword_10789748[]; // weak
int dword_1078974C; // weak
int dword_10789750; // weak
int dword_10789754; // weak
int dword_10789758; // weak
__int16 word_1078975C; // weak
int dword_10789760; // weak
int dword_107897A8; // weak
int dword_10789808; // weak
int dword_10789838; // weak
int dword_10789880; // weak
int dword_10789928; // weak
int dword_10789934; // weak
int dword_10789944; // weak
__int16 word_10789948; // weak
int dword_10789950; // weak
__int16 word_10789954; // weak
int dword_1078995C; // weak
int dword_10789A64; // weak
int dword_10789ADC; // weak
__int16 word_10789AE0; // weak
_UNKNOWN unk_10789E48; // weak
_UNKNOWN unk_10789E49; // weak
_UNKNOWN unk_10789E4A; // weak
__int16 word_10789E60[]; // weak
char byte_10789F8C; // weak
char byte_10789F8D; // weak
int dword_10789F90; // weak
char byte_10789F94; // weak
int dword_10789F98; // weak
int dword_10789FA0; // weak
char byte_10789FA4[]; // weak
void *dword_10789FC0; // idb
int dword_1078AFE0; // weak
int dword_1078AFE4; // weak
UINT uNumber; // idb
int dword_1078B000[]; // weak
int dword_1078B100; // weak
int dword_1078B118; // weak


//----- (10001000) --------------------------------------------------------
int __usercall sub_10001000@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_DWORD *)(result + 84) = a2;
  *(_DWORD *)(result + 4) = -122944301;
  *(_DWORD *)(result + 60) = 0;
  *(_DWORD *)(result + 64) = 0;
  *(_DWORD *)(result + 68) = 0;
  *(_DWORD *)(result + 72) = 0;
  *(_DWORD *)(result + 76) = 0;
  *(_DWORD *)(result + 80) = 0;
  return result;
}

//----- (10001020) --------------------------------------------------------
int __cdecl sub_10001020(int a1, int a2, int a3)
{
  int v3; // edx@1
  int result; // eax@1
  signed int v5; // esi@1

  v3 = a1;
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 4) = -122944301;
  *(_DWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 28) = 0;
  result = a1 + 32;
  v5 = 32;
  do
  {
    result = sub_10001000(result, v3) + 96;
    --v5;
  }
  while ( v5 );
  return result;
}

//----- (10001070) --------------------------------------------------------
char __thiscall sub_10001070(int this)
{
  int v1; // edx@1
  int v2; // esi@1
  char result; // al@6
  int v4; // eax@7

  v1 = *(_DWORD *)(this + 40);
  v2 = *(_DWORD *)(this + 32);
  if ( !v2 && !*(_DWORD *)(this + 36) )
  {
    if ( *(_DWORD *)(v1 + 56) == this )
      *(_DWORD *)(v1 + 56) = 0;
    if ( *(_DWORD *)(v1 + 52) == this )
    {
      *(_DWORD *)(v1 + 52) = 0;
      return 1;
    }
    return 1;
  }
  v4 = *(_DWORD *)(this + 36);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 36) = v4;
    if ( v4 )
      *(_DWORD *)(v4 + 32) = v2;
    *(_DWORD *)(this + 32) = 0;
    *(_DWORD *)(this + 36) = 0;
    return 1;
  }
  if ( *(_DWORD *)(v1 + 52) == this )
  {
    *(_DWORD *)(v1 + 52) = v4;
    *(_DWORD *)(v4 + 32) = 0;
    *(_DWORD *)(this + 32) = 0;
    *(_DWORD *)(this + 36) = 0;
    result = 1;
  }
  else
  {
    *(_DWORD *)(v1 + 56) = v4;
    *(_DWORD *)(v4 + 32) = 0;
    *(_DWORD *)(this + 32) = 0;
    *(_DWORD *)(this + 36) = 0;
    result = 1;
  }
  return result;
}

//----- (100010E0) --------------------------------------------------------
char __cdecl sub_100010E0(char a1, int a2)
{
  int v2; // edi@3
  char result; // al@5
  int v4; // eax@6
  int v5; // eax@9

  if ( a2 && *(_DWORD *)(a2 + 40) )
  {
    sub_10001E00(a2);
    sub_10001FA0(a2);
    v2 = *(_DWORD *)(a2 + 40);
    sub_10001070(a2);
    if ( a1 == 1 )
    {
      *(_DWORD *)(a2 + 36) = *(_DWORD *)(v2 + 52);
      v5 = *(_DWORD *)(v2 + 52);
      if ( v5 )
        *(_DWORD *)(v5 + 32) = a2;
      *(_DWORD *)(v2 + 52) = a2;
      *(_BYTE *)(a2 + 9) = 1;
      result = 1;
    }
    else if ( a1 == 2 )
    {
      *(_DWORD *)(a2 + 36) = *(_DWORD *)(v2 + 56);
      v4 = *(_DWORD *)(v2 + 56);
      if ( v4 )
        *(_DWORD *)(v4 + 32) = a2;
      *(_DWORD *)(v2 + 56) = a2;
      *(_BYTE *)(a2 + 9) = 0;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10001160) --------------------------------------------------------
int __cdecl sub_10001160(int a1, unsigned int a2)
{
  int result; // eax@2
  int v3; // eax@3

  if ( a2 && (sub_10001EC0(0), (v3 = sub_10001930(a1)) != 0) )
    result = sub_10001D20(v3, a2);
  else
    result = 0;
  return result;
}

//----- (100011A0) --------------------------------------------------------
int __cdecl sub_100011A0(_BYTE *a1)
{
  unsigned int v1; // ebx@1
  char *v2; // ebp@1
  int result; // eax@2
  char *v4; // ecx@4
  char v5; // dl@6
  int v6; // esi@7
  int v7; // [sp+8h] [bp-4h]@1

  v1 = 0;
  v7 = 0;
  v2 = (char *)sub_10001B90(2);
  if ( v2 )
  {
    do
    {
      if ( v2[3200 * v1 + 24] )
      {
        v4 = &v2[3200 * v1 + 3156];
        if ( &v2[3200 * v1 + 24] != (char *)-3132 )
        {
          if ( a1 )
          {
            v5 = *v4;
            if ( *v4 == *a1 )
            {
              v6 = a1 - v4;
              while ( v5 )
              {
                v5 = (v4++)[1];
                if ( v5 != v4[v6] )
                  goto LABEL_12;
              }
              v7 = (int)&v2[3200 * v1 + 24];
              v1 = 10;
            }
          }
        }
      }
LABEL_12:
      ++v1;
    }
    while ( v1 < 0xA );
    result = v7;
  }
  else
  {
    sub_100364C0("..\\lib\\acl\\bam\\bam_main.c", 379, 1, 0);
    result = 0;
  }
  return result;
}

//----- (10001240) --------------------------------------------------------
char sub_10001240()
{
  char *v0; // eax@1
  int v1; // ebx@1
  char result; // al@2
  unsigned int v3; // esi@3
  int v4; // edi@3

  v0 = (char *)sub_10001B90(1);
  v1 = (int)v0;
  if ( v0 )
  {
    v3 = 0;
    v4 = (int)(v0 + 24);
    do
    {
      result = sub_10001020(v4, v1, v3++);
      v4 += 3200;
    }
    while ( v3 < 0xA );
  }
  else
  {
    result = sub_100364C0("..\\lib\\acl\\bam\\bam_main.c", 716, 1, 0);
  }
  return result;
}

//----- (100012C0) --------------------------------------------------------
char __cdecl sub_100012C0(int a1, unsigned int a2, int a3)
{
  char result; // al@2
  int v4; // eax@5
  int v5; // edi@5
  int v6; // esi@7
  unsigned int v7; // ecx@7
  int v8; // eax@7
  unsigned int v9; // eax@11
  bool v10; // zf@18
  unsigned int v11; // eax@18

  if ( a3 )
  {
    if ( a2 )
    {
      v4 = sub_10001F00(a1);
      v5 = v4;
      if ( v4 )
      {
        v6 = v4 + 32;
        v7 = 0;
        v8 = v4 + 32;
        while ( !*(_BYTE *)v8 || *(_DWORD *)(v8 + 24) != a2 )
        {
          ++v7;
          v8 += 96;
          if ( v7 >= 0x20 )
          {
            v9 = 0;
            while ( *(_BYTE *)v6 )
            {
              ++v9;
              v6 += 96;
              if ( v9 >= 0x20 )
              {
                ++*(_DWORD *)(v5 + 3124);
                goto LABEL_15;
              }
            }
            *(_BYTE *)v6 = 1;
            *(_DWORD *)(v6 + 84) = v5;
            v10 = sub_10001980(a2) == 0;
            v11 = a2;
            if ( v10 )
              v11 = (a2 & 0xFFFFFFF8) + 8;
            *(_DWORD *)(v6 + 20) = v11;
            *(_DWORD *)(v6 + 24) = a2;
            *(_DWORD *)(v6 + 28) = a3;
            *(_DWORD *)(v6 + 60) = a3;
            ++*(_DWORD *)(v5 + 28);
            ++*(_DWORD *)(v5 + 3104);
            return 1;
          }
        }
        if ( *(_BYTE *)(v5 + 3197) )
        {
          *(_DWORD *)(v8 + 28) += a3;
          *(_DWORD *)(v8 + 60) += a3;
          result = 1;
        }
        else
        {
LABEL_15:
          result = 0;
        }
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10001390) --------------------------------------------------------
int __usercall sub_10001390@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  void *v2; // eax@1
  unsigned int v3; // ecx@1
  int v4; // esi@1
  char v5; // bl@1
  _DWORD *v6; // edx@1

  v1 = a1;
  v2 = sub_10001B90(2);
  v3 = 0;
  v4 = ~v1;
  v5 = 0;
  v6 = (char *)v2 + 32024;
  do
  {
    if ( v5 )
      goto LABEL_8;
    if ( *v6 )
    {
      ++v3;
      ++v6;
    }
    else
    {
      v5 = 1;
    }
  }
  while ( v3 < 5 );
  if ( v5 )
  {
LABEL_8:
    *((_DWORD *)v2 + v3 + 8006) = v4;
    return v4;
  }
  return 0;
}

//----- (100013E0) --------------------------------------------------------
unsigned int __usercall sub_100013E0@<eax>(unsigned int a1@<esi>, _DWORD *a2)
{
  bool v2; // zf@1
  unsigned int result; // eax@1
  char v4; // [sp+0h] [bp-4h]@0

  v2 = sub_10001980(v4) == 0;
  result = a1;
  if ( v2 )
  {
    result = (a1 & 0xFFFFFFF8) + 8;
    *a2 = result - a1;
  }
  return result;
}

//----- (10001400) --------------------------------------------------------
int __usercall sub_10001400@<eax>(char a1@<al>, int a2@<esi>)
{
  signed int v2; // ecx@1
  signed int v3; // edx@1

  v2 = 0;
  v3 = 0;
  if ( a1 == 3 || a1 == 1 )
    v2 = 48;
  if ( a1 == 3 || a1 == 2 )
    v2 += *(_DWORD *)(a2 + 20) + 24;
  if ( a1 == 3 )
    v3 = 8;
  return v3 + v2 * *(_DWORD *)(a2 + 28);
}

//----- (10001440) --------------------------------------------------------
int __usercall sub_10001440@<eax>(int a1@<esi>, int a2, int a3)
{
  int result; // eax@1

  memset((void *)a1, 0, 0x30u);
  result = a2;
  *(_BYTE *)a1 = 1;
  *(_DWORD *)(a1 + 4) = -122944301;
  *(_DWORD *)(a1 + 40) = a2;
  *(_DWORD *)(a1 + 12) = a3;
  return result;
}

//----- (10001470) --------------------------------------------------------
unsigned int __usercall sub_10001470@<eax>(int a1@<eax>, int a2@<ecx>)
{
  unsigned int result; // eax@1

  *(_DWORD *)a2 = a1;
  result = a1 ^ 0xAD8CCC84;
  *(_DWORD *)(a2 + 4) = result;
  return result;
}

//----- (10001480) --------------------------------------------------------
int __usercall sub_10001480@<eax>(int a1@<eax>, int a2@<edx>, int a3@<esi>)
{
  int v3; // edi@1
  int v4; // ecx@1
  int v5; // ecx@1
  int result; // eax@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v3 = *(_DWORD *)(a1 + 20);
  v9 = 0;
  v10 = 0;
  *(_DWORD *)(a3 + 4) = -122944301;
  *(_DWORD *)(a3 + 40) = a1;
  *(_DWORD *)(a3 + 44) = *(_DWORD *)(a1 + 84);
  v3 += 24;
  *(_DWORD *)(a3 + 12) = a2;
  v4 = *(_DWORD *)(a1 + 44) + a2 * v3;
  *(_DWORD *)(a3 + 20) = v3;
  *(_DWORD *)(a3 + 16) = v4;
  *(_DWORD *)(a3 + 24) = v4 + 16;
  *(_DWORD *)(a3 + 28) = *(_DWORD *)(a1 + 20);
  sub_100018D0(a3, &v7, &v8);
  *(_DWORD *)v7 = -168364040;
  *(_DWORD *)(v7 + 4) = -235736076;
  *(_DWORD *)v8 = -168364040;
  *(_DWORD *)(v8 + 4) = -235736076;
  sub_10001470(a3, (int)&v9);
  sub_100019B0(v5, a3);
  result = v3;
  *(_BYTE *)(a3 + 8) = 1;
  return result;
}

//----- (10001520) --------------------------------------------------------
int __usercall sub_10001520@<eax>(unsigned __int8 a1@<al>, unsigned int a2@<ecx>, int a3@<edi>, int a4)
{
  unsigned int v4; // ebp@1
  int v5; // ebx@1
  int v6; // eax@1
  unsigned int v7; // esi@1
  int v8; // eax@3
  bool v9; // sf@3
  unsigned __int8 v10; // of@3
  int v11; // eax@4
  int v12; // esi@4
  unsigned int v14; // eax@15
  void *v15; // ebp@15
  int v16; // eax@15
  int v17; // [sp+Ch] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1 - 1;
  v7 = a2;
  v17 = 0;
  if ( !v6 )
  {
    if ( *(_DWORD *)(a3 + 36) )
      sub_100364C0("..\\lib\\acl\\bam\\bam_setup.c", 1502, 1, 0);
    if ( *(_DWORD *)(a3 + 52) )
      sub_100364C0("..\\lib\\acl\\bam\\bam_setup.c", 1503, 1, 0);
    if ( *(_DWORD *)(a3 + 56) )
      sub_100364C0("..\\lib\\acl\\bam\\bam_setup.c", 1504, 1, 0);
    if ( !*(_DWORD *)(a3 + 84) || *(_BYTE *)(a3 + 8) )
    {
      sub_100364C0("..\\lib\\acl\\bam\\bam_setup.c", 1509, 1, 0);
    }
    else
    {
      *(_DWORD *)(a3 + 52) = 0;
      *(_DWORD *)(a3 + 56) = 0;
      v14 = sub_100013E0(v7, &v17);
      v15 = (void *)v14;
      *(_DWORD *)(a3 + 36) = v14;
      v16 = sub_10001400(1, a3);
      v5 = v16 + v17;
      v10 = __OFSUB__(a4, v16 + v17);
      v9 = a4 - (v16 + v17) < 0;
      *(_DWORD *)(a3 + 40) = v16;
      if ( !(v9 ^ v10) )
      {
        if ( !(*(_BYTE *)(*(_DWORD *)(a3 + 84) + 3196) & 8) )
          memset(v15, 0, v16);
        return v5;
      }
    }
    return 0;
  }
  if ( v6 != 1 )
    return v5;
  *(_DWORD *)(a3 + 44) = sub_100013E0(a2, &v17);
  v8 = sub_10001400(2, a3);
  v5 = v17;
  v10 = __OFSUB__(a4 - v17, v8);
  v9 = a4 - v17 - v8 < 0;
  *(_DWORD *)(a3 + 48) = v8;
  if ( v9 ^ v10 )
    return 0;
  v11 = *(_DWORD *)(a3 + 28);
  v12 = *(_DWORD *)(a3 + 36);
  *(_DWORD *)(a3 + 92) = 0;
  *(_DWORD *)(a3 + 88) = v11;
  if ( !v11 )
    return v5;
  do
  {
    sub_10001440(v12, a3, v4);
    v5 += sub_10001480(a3, v4, v12);
    *(_BYTE *)(v12 + 9) = 1;
    sub_100010E0(2, v12);
    ++v4;
    v12 += 48;
  }
  while ( v4 < *(_DWORD *)(a3 + 28) );
  return v5;
}

//----- (10001680) --------------------------------------------------------
char __usercall sub_10001680@<al>(int a1@<eax>, unsigned int a2@<esi>)
{
  unsigned int v2; // edi@1
  char *v3; // eax@1
  unsigned int v4; // ecx@1
  int v5; // eax@1

  v2 = a2 + a1;
  v3 = (char *)sub_10001B90(2);
  v4 = 0;
  v5 = (int)(v3 + 44);
  while ( !*(_BYTE *)(v5 - 8) || *(_DWORD *)v5 + *(_DWORD *)(v5 + 4) <= a2 || *(_DWORD *)v5 >= v2 )
  {
    ++v4;
    v5 += 3200;
    if ( v4 >= 0xA )
      return 0;
  }
  return 1;
}

//----- (100016C0) --------------------------------------------------------
_BYTE *__cdecl sub_100016C0(char *a1)
{
  _BYTE *result; // eax@6
  int v2; // esi@6

  if ( a1 && *a1 && strlen(a1) < 0x40 && sub_10001B90(2) && !sub_100011A0(a1) )
  {
    result = sub_10001C80();
    v2 = (int)result;
    if ( result )
    {
      sub_100365D0((int)(result + 3132), a1, 64);
      *(_BYTE *)(v2 + 3196) = 2;
      sub_10001EA0(2);
      result = (_BYTE *)sub_10001390(v2);
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10001740) --------------------------------------------------------
int __usercall sub_10001740@<eax>(_BYTE *a1@<eax>)
{
  int v1; // ebx@3
  _BYTE *v2; // esi@3
  signed int v3; // edi@3
  int result; // eax@7

  if ( a1 && *a1 )
  {
    v1 = 0;
    v2 = a1 + 32;
    v3 = 32;
    do
    {
      if ( *v2 )
        v1 += sub_10001400(3, (int)v2);
      v2 += 96;
      --v3;
    }
    while ( v3 );
    result = v1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10001780) --------------------------------------------------------
int __cdecl sub_10001780(int a1)
{
  _BYTE *v1; // eax@1
  int result; // eax@2

  v1 = (_BYTE *)sub_10001F00(a1);
  if ( v1 )
    result = sub_10001740(v1);
  else
    result = 0;
  return result;
}

//----- (100017A0) --------------------------------------------------------
int __cdecl sub_100017A0(int a1, void *a2, size_t a3)
{
  int result; // eax@1
  int v4; // ebp@1
  int v5; // esi@8
  int v6; // ebp@8
  _BYTE *v7; // edi@8
  int v8; // eax@10
  int v9; // edi@13
  int v10; // eax@15
  unsigned int v11; // [sp+4h] [bp-8h]@8
  unsigned int v12; // [sp+4h] [bp-8h]@13
  int v13; // [sp+8h] [bp-4h]@1

  result = sub_10001F00(a1);
  v4 = result;
  v13 = result;
  if ( result )
  {
    if ( *(_BYTE *)(result + 12) || !a2 || sub_10001680(a3, (unsigned int)a2) || a3 < sub_10001740((_BYTE *)v4) )
      goto LABEL_20;
    if ( *(_BYTE *)(v4 + 3196) & 8 )
      memset(a2, 0, a3);
    sub_10001C40(a1);
    *(_DWORD *)(v4 + 24) = a3;
    v5 = a3;
    *(_DWORD *)(v4 + 20) = a2;
    v6 = 0;
    v11 = 0;
    v7 = (_BYTE *)(v13 + 32);
    do
    {
      if ( *v7 )
      {
        v8 = sub_10001520(1u, (unsigned int)a2 + v6, (int)v7, v5);
        if ( !v8 )
          goto LABEL_20;
        v6 += v8;
        v5 -= v8;
      }
      v7 += 96;
      ++v11;
    }
    while ( v11 < 0x20 );
    v12 = 0;
    v9 = v13 + 32;
    do
    {
      if ( *(_BYTE *)v9 )
      {
        v10 = sub_10001520(2u, (unsigned int)a2 + v6, v9, v5);
        if ( !v10 )
          goto LABEL_20;
        v6 += v10;
        v5 -= v10;
        *(_BYTE *)(v9 + 8) = 1;
      }
      v9 += 96;
      ++v12;
    }
    while ( v12 < 0x20 );
    if ( !sub_100020F0(1) )
    {
LABEL_20:
      result = 0;
    }
    else
    {
      result = v13;
      *(_BYTE *)(v13 + 12) = 1;
    }
  }
  return result;
}

//----- (100018D0) --------------------------------------------------------
int __cdecl sub_100018D0(int a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax@1
  int v4; // ecx@5

  result = a1;
  if ( a1 && a2 && a3 )
  {
    if ( *(_DWORD *)(a1 + 4) == -122944301
      && (v4 = *(_DWORD *)(a1 + 16)) != 0
      && *(_DWORD *)(a1 + 24)
      && *(_DWORD *)(a1 + 28) )
    {
      *a2 = v4 + 8;
      *a3 = *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 28);
    }
    else
    {
      *a2 = 0;
      *a3 = 0;
    }
  }
  return result;
}

//----- (10001930) --------------------------------------------------------
int __cdecl sub_10001930(int a1)
{
  int result; // eax@2

  if ( sub_10001F00(a1) || (result = a1) == 0 || *(_DWORD *)(a1 + 4) != -122944301 )
    result = 0;
  return result;
}

//----- (10001960) --------------------------------------------------------
int __cdecl sub_10001960(int *a1)
{
  int result; // eax@2

  if ( sub_10001F40((int)a1) )
    result = *a1;
  else
    result = 0;
  return result;
}

//----- (10001980) --------------------------------------------------------
bool __cdecl sub_10001980(char a1)
{
  return (a1 & 7) == 0;
}

//----- (10001990) --------------------------------------------------------
void __cdecl sub_10001990(int a1, int a2)
{
  if ( a1 )
  {
    if ( a2 )
    {
      *(_DWORD *)a1 = *(_DWORD *)(a2 - 16);
      *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 - 12);
    }
  }
}

//----- (100019B0) --------------------------------------------------------
int __cdecl sub_100019B0(int a1, int a2)
{
  int result; // eax@2

  if ( a1 )
  {
    result = a2;
    if ( a2 )
    {
      result = *(_DWORD *)(a2 + 24) - 16;
      *(_DWORD *)result = *(_DWORD *)a1;
      *(_DWORD *)(result + 4) = *(_DWORD *)(a1 + 4);
    }
  }
  return result;
}

//----- (100019E0) --------------------------------------------------------
int __cdecl sub_100019E0(int a1, unsigned int a2)
{
  int result; // eax@1
  int v3; // ecx@2
  signed int v4; // ebx@2
  unsigned int v5; // edx@4
  unsigned int v6; // edx@14
  unsigned int v7; // edx@19

  result = 0;
  if ( a1 )
  {
    v3 = a1 + 152;
    v4 = 8;
    do
    {
      if ( *(_BYTE *)(v3 - 120) )
      {
        v5 = *(_DWORD *)(v3 - 96);
        if ( v5 >= a2 && (!result || *(_DWORD *)(result + 24) > v5) )
          result = v3 - 120;
      }
      if ( *(_BYTE *)(v3 - 24) && *(_DWORD *)v3 >= a2 && (!result || *(_DWORD *)(result + 24) > *(_DWORD *)v3) )
        result = v3 - 24;
      if ( *(_BYTE *)(v3 + 72) )
      {
        v6 = *(_DWORD *)(v3 + 96);
        if ( v6 >= a2 && (!result || *(_DWORD *)(result + 24) > v6) )
          result = v3 + 72;
      }
      if ( *(_BYTE *)(v3 + 168) )
      {
        v7 = *(_DWORD *)(v3 + 192);
        if ( v7 >= a2 && (!result || *(_DWORD *)(result + 24) > v7) )
          result = v3 + 168;
      }
      v3 += 384;
      --v4;
    }
    while ( v4 );
  }
  return result;
}

//----- (10001A90) --------------------------------------------------------
int __cdecl sub_10001A90(int a1)
{
  int result; // eax@1

  result = a1;
  --*(_DWORD *)(result + 4);
  ++*(_DWORD *)result;
  ++*(_DWORD *)(result + 16);
  return result;
}

//----- (10001AA0) --------------------------------------------------------
int __cdecl sub_10001AA0(int a1)
{
  int result; // eax@1
  unsigned int v2; // ecx@1
  unsigned int v3; // edx@1

  result = a1;
  --*(_DWORD *)result;
  ++*(_DWORD *)(result + 4);
  ++*(_DWORD *)(result + 12);
  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a1 + 8);
  if ( v3 <= v2 )
    *(_DWORD *)(a1 + 8) = v2;
  else
    *(_DWORD *)(a1 + 8) = v3;
  return result;
}

//----- (10001AD0) --------------------------------------------------------
void *__usercall sub_10001AD0@<eax>(int a1@<esi>)
{
  void *result; // eax@1

  result = memset((void *)a1, 0, 0x7D2Cu);
  *(_BYTE *)(a1 + 12) = 1;
  *(_DWORD *)(a1 + 16) = -122944301;
  return result;
}

//----- (10001AF0) --------------------------------------------------------
int __usercall sub_10001AF0@<eax>(int a1@<eax>, int a2@<edi>)
{
  unsigned int v2; // esi@2
  unsigned int v3; // edx@2
  _DWORD *v4; // ecx@3
  int result; // eax@4

  if ( *(_BYTE *)a1 && (v2 = *(_DWORD *)(a1 + 28), v3 = 0, v2) )
  {
    v4 = (_DWORD *)(*(_DWORD *)(a1 + 36) + 24);
    while ( 1 )
    {
      result = (int)(v4 - 6);
      if ( *((_BYTE *)v4 - 15) )
      {
        if ( *v4 == a2 )
          break;
      }
      ++v3;
      v4 += 12;
      if ( v3 >= v2 )
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    result = 0;
  }
  return result;
}

//----- (10001B20) --------------------------------------------------------
int __cdecl sub_10001B20(int a1, unsigned int a2)
{
  int v2; // edi@3

  if ( !a1 || *(_DWORD *)(a1 + 20) < a2 )
    return 0;
  v2 = *(_DWORD *)(a1 + 56);
  if ( !v2 )
  {
    ++*(_DWORD *)(a1 + 80);
    return 0;
  }
  if ( !sub_100010E0(1, *(_DWORD *)(a1 + 56)) )
    return 0;
  sub_10001AA0(a1 + 60);
  --*(_DWORD *)(a1 + 88);
  ++*(_DWORD *)(a1 + 92);
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 44) + 3196) & 2 )
    memset(*(void **)(v2 + 24), 0, *(_DWORD *)(v2 + 28));
  return *(_DWORD *)(v2 + 24);
}

//----- (10001B90) --------------------------------------------------------
void *__cdecl sub_10001B90(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 == 1 )
  {
    sub_10001AD0((int)&unk_10137780);
    result = &unk_10137780;
  }
  else if ( a1 == 2 && dword_10137790 == -122944301 )
  {
    result = &unk_10137780;
  }
  return result;
}
// 10137790: using guessed type int dword_10137790;

//----- (10001BD0) --------------------------------------------------------
char __cdecl sub_10001BD0(int a1)
{
  int v1; // esi@4
  char result; // al@6

  if ( a1 && sub_10001FA0(a1) && *(_BYTE *)(a1 + 9) )
  {
    v1 = *(_DWORD *)(a1 + 40);
    if ( *(_BYTE *)(*(_DWORD *)(v1 + 84) + 3196) & 4 )
      memset(*(void **)(a1 + 24), 0, *(_DWORD *)(a1 + 28));
    sub_100010E0(2, a1);
    sub_10001A90(v1 + 60);
    result = 1;
    ++*(_DWORD *)(v1 + 88);
    --*(_DWORD *)(v1 + 92);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10001C40) --------------------------------------------------------
_DWORD *__cdecl sub_10001C40(int a1)
{
  _DWORD *result; // eax@1
  unsigned int v2; // ecx@1

  result = sub_10001B90(2);
  v2 = 0;
  do
  {
    if ( a1 == result[v2 + 8006] )
    {
      result[v2 + 8006] = 0;
      v2 = 5;
    }
    ++v2;
  }
  while ( v2 < 5 );
  return result;
}

//----- (10001C80) --------------------------------------------------------
_BYTE *sub_10001C80()
{
  _BYTE *v0; // ebx@1
  void *v1; // edi@1
  unsigned int v2; // ebp@1
  char v3; // al@1
  _BYTE *v4; // esi@1

  v0 = 0;
  v1 = sub_10001B90(2);
  v2 = 0;
  v3 = 0;
  v4 = (char *)v1 + 24;
  do
  {
    if ( v3 )
      return v0;
    v0 = v4;
    if ( *v4 )
    {
      ++v2;
      v4 += 3200;
    }
    else
    {
      ++*((_DWORD *)v1 + 5);
      *v4 = 1;
      sub_10001EE0((int)v4);
      v3 = 1;
    }
  }
  while ( v2 < 0xA );
  if ( v3 )
    return v0;
  return 0;
}

//----- (10001CE0) --------------------------------------------------------
int __usercall sub_10001CE0@<eax>(int a1@<eax>, _BYTE *a2@<ecx>)
{
  int v2; // edi@1
  int result; // eax@1
  unsigned int v4; // ebp@1
  char v5; // bl@1
  int v6; // esi@2

  v2 = a1;
  result = 0;
  v4 = 0;
  v5 = 0;
  if ( *a2 )
  {
    v6 = (int)(a2 + 32);
    while ( !v5 )
    {
      result = sub_10001AF0(v6, v2);
      if ( result )
      {
        v5 = 1;
      }
      else
      {
        ++v4;
        v6 += 96;
      }
      if ( v4 >= 0x20 )
      {
        if ( v5 )
          return result;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    result = 0;
  }
  return result;
}

//----- (10001D20) --------------------------------------------------------
int __cdecl sub_10001D20(int a1, unsigned int a2)
{
  int v2; // eax@1

  v2 = sub_100019E0(a1, a2);
  return sub_10001B20(v2, a2);
}

//----- (10001D40) --------------------------------------------------------
void *__cdecl sub_10001D40(int a1)
{
  int v1; // ebp@1
  void *result; // eax@1
  unsigned int v3; // edi@2
  char v4; // bl@2
  _BYTE *v5; // esi@2

  v1 = 0;
  result = sub_10001B90(2);
  if ( result )
  {
    v3 = 0;
    v4 = 0;
    v5 = (char *)result + 24;
    do
    {
      if ( v4 )
        return (void *)v1;
      v1 = sub_10001CE0(a1, v5);
      if ( v1 )
      {
        v4 = 1;
      }
      else
      {
        ++v3;
        v5 += 3200;
      }
    }
    while ( v3 < 0xA );
    if ( v4 )
      return (void *)v1;
    result = 0;
  }
  return result;
}

//----- (10001DA0) --------------------------------------------------------
void *__cdecl sub_10001DA0(int a1)
{
  void *v1; // esi@1
  void *result; // eax@5
  char v3; // [sp+8h] [bp-8h]@1

  sub_10001990((int)&v3, a1);
  v1 = (void *)sub_10001960((int *)&v3);
  if ( (v1 || (v1 = sub_10001D40(a1)) != 0) && sub_10001E00((int)v1) && sub_10001E40((int)v1) )
    result = v1;
  else
    result = 0;
  return result;
}

//----- (10001E00) --------------------------------------------------------
bool __cdecl sub_10001E00(int a1)
{
  return a1
      && *(_DWORD *)(a1 + 4) == -122944301
      && *(_DWORD *)(a1 + 40)
      && *(_DWORD *)(a1 + 44)
      && *(_DWORD *)(a1 + 28)
      && *(_DWORD *)(a1 + 16)
      && *(_DWORD *)(a1 + 20)
      && *(_DWORD *)(a1 + 24);
}

//----- (10001E40) --------------------------------------------------------
bool __cdecl sub_10001E40(int a1)
{
  int v1; // ecx@0
  bool result; // al@8
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  result = 0;
  if ( a1 )
  {
    sub_100018D0(a1, &a1, &v3);
    if ( a1 )
    {
      if ( v3
        && *(_DWORD *)a1 == -168364040
        && *(_DWORD *)(a1 + 4) == -235736076
        && *(_DWORD *)v3 == -168364040
        && *(_DWORD *)(v3 + 4) == -235736076 )
      {
        result = 1;
      }
    }
  }
  return result;
}

//----- (10001EA0) --------------------------------------------------------
bool __cdecl sub_10001EA0(char a1)
{
  return !(a1 & 1) || a1 == 1;
}

//----- (10001EC0) --------------------------------------------------------
bool __cdecl sub_10001EC0(_DWORD *a1)
{
  _DWORD *v1; // eax@1

  v1 = a1;
  if ( !a1 )
    v1 = sub_10001B90(2);
  return v1[4] == -122944301;
}

//----- (10001EE0) --------------------------------------------------------
bool __cdecl sub_10001EE0(int a1)
{
  return a1 && *(_DWORD *)(a1 + 4) == -122944301;
}

//----- (10001F00) --------------------------------------------------------
int __cdecl sub_10001F00(int a1)
{
  _DWORD *v1; // esi@1
  int result; // eax@1
  unsigned int v3; // ecx@3

  v1 = sub_10001B90(2);
  result = 0;
  if ( v1 && a1 )
  {
    v3 = 0;
    do
    {
      if ( a1 == v1[v3 + 8006] )
      {
        result = ~a1;
        v3 = 5;
      }
      ++v3;
    }
    while ( v3 < 5 );
  }
  return result;
}

//----- (10001F40) --------------------------------------------------------
bool __cdecl sub_10001F40(int a1)
{
  return a1 && (*(_DWORD *)a1 ^ 0xAD8CCC84) == *(_DWORD *)(a1 + 4);
}

//----- (10001F60) --------------------------------------------------------
bool __usercall sub_10001F60@<al>(int a1@<eax>)
{
  char v2; // [sp+0h] [bp-8h]@1

  sub_10001990((int)&v2, *(_DWORD *)(a1 + 24));
  return sub_10001F40((int)&v2);
}

//----- (10001F80) --------------------------------------------------------
bool __usercall sub_10001F80@<al>(int a1@<eax>)
{
  return a1 && *(_DWORD *)(a1 + 4) == -122944301;
}

//----- (10001FA0) --------------------------------------------------------
char __cdecl sub_10001FA0(int a1)
{
  _DWORD *v1; // eax@4
  char result; // al@5

  if ( sub_10001E00(a1) && sub_10001E40(a1) && sub_10001F60(a1) && (v1 = sub_10001B90(2)) != 0 )
  {
    ++v1[2];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10001FF0) --------------------------------------------------------
bool __usercall sub_10001FF0@<al>(int a1@<eax>)
{
  int v1; // edi@1
  bool result; // al@1
  _BYTE *v3; // eax@2
  int v4; // edx@2
  unsigned int v5; // esi@3
  int v6; // ebx@4
  unsigned int v7; // edi@8
  int v8; // edx@9
  int v9; // ecx@9

  v1 = a1;
  result = sub_10001F80(a1);
  if ( result )
  {
    v3 = sub_10001B90(2);
    v4 = *(_DWORD *)(v1 + 36);
    if ( *v3 )
    {
      v5 = 0;
      if ( *(_DWORD *)(v1 + 28) )
      {
        v6 = *(_DWORD *)(v1 + 36);
        while ( sub_10001FA0(v6) )
        {
          ++v5;
          v6 += 48;
          if ( v5 >= *(_DWORD *)(v1 + 28) )
            goto LABEL_7;
        }
        return 0;
      }
    }
    else
    {
      v7 = *(_DWORD *)(v1 + 28);
      if ( v7 )
      {
        while ( sub_10001E00(v4) )
        {
          v4 = v8 + 48;
          if ( v9 + 1 >= v7 )
            return 1;
        }
        return 0;
      }
    }
LABEL_7:
    result = 1;
  }
  return result;
}

//----- (10002070) --------------------------------------------------------
bool __thiscall sub_10002070(void *this)
{
  bool result; // al@1
  int v2; // ecx@1
  unsigned int v3; // esi@2
  int v4; // edi@2

  result = sub_10001EE0((int)this);
  if ( result )
  {
    v3 = 0;
    v4 = v2 + 32;
    while ( !*(_BYTE *)(v4 + 8) || sub_10001FF0(v4) )
    {
      ++v3;
      v4 += 96;
      if ( v3 >= 0x20 )
        return 1;
    }
    result = 0;
  }
  return result;
}

//----- (100020B0) --------------------------------------------------------
char __usercall sub_100020B0@<al>(int a1@<eax>)
{
  unsigned int v1; // esi@1
  void *v2; // edi@1

  v1 = 0;
  v2 = (void *)(a1 + 24);
  while ( sub_10002070(v2) )
  {
    ++v1;
    v2 = (char *)v2 + 3200;
    if ( v1 >= 0xA )
      return 1;
  }
  return 0;
}

//----- (100020F0) --------------------------------------------------------
bool __cdecl sub_100020F0(char a1)
{
  _DWORD *v1; // eax@1
  int v2; // esi@1
  bool result; // al@6

  v1 = sub_10001B90(2);
  v2 = (int)v1;
  if ( v1 )
  {
    if ( a1 )
      *(_BYTE *)v1 = 1;
    result = sub_10001EC0(v1) && sub_100020B0(v2);
    if ( a1 )
      *(_BYTE *)v2 = 0;
    if ( result )
      ++*(_DWORD *)(v2 + 4);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10002150) --------------------------------------------------------
_BYTE **__usercall sub_10002150@<eax>(_BYTE **result@<eax>, signed int a2@<edx>, size_t a3@<ebx>, char *a4@<edi>, _DWORD *a5)
{
  _DWORD *v5; // esi@1
  char *v6; // eax@11
  char v7; // cl@14
  char *v8; // eax@15
  int v9; // [sp+4h] [bp-8h]@11

  v5 = a5;
  if ( a2 > 5 )
    goto LABEL_6;
  while ( 2 )
  {
    if ( !v5 || !result )
    {
LABEL_6:
      *a4 = 0;
      return result;
    }
    switch ( *v5 )
    {
      case 0x4B:
        v5 = result[2];
        ++a2;
        result = (_BYTE **)result[3];
        if ( a2 > 5 )
          goto LABEL_6;
        continue;
      default:
        goto LABEL_6;
      case 0x59:
        return (_BYTE **)sub_10036790(a4, a3, "%f", *(float *)result);
      case 0x5A:
        return (_BYTE **)sub_10036790(a4, a3, "%li", *result);
      case 0x66:
        return (_BYTE **)sub_10036790(a4, a3, "%li", *result);
      case 0x69:
      case 0x7C:
        return (_BYTE **)sub_100365D0((int)a4, result, a3);
      case 0x6B:
        v9 = a3;
        v6 = sub_10037280(*(_WORD *)result);
        return (_BYTE **)sub_100365D0((int)a4, v6, v9);
      case 0x44:
        v9 = a3;
        v6 = sub_10037280(*(_WORD *)result);
        return (_BYTE **)sub_100365D0((int)a4, v6, v9);
      case 0x76:
        v7 = *((_BYTE *)result + 4) & 7;
        if ( v7 == 1 )
        {
          v8 = sub_10037280(*(_WORD *)result);
          return (_BYTE **)sub_100365D0((int)a4, v8, a3);
        }
        if ( v7 )
          goto LABEL_6;
        result = (_BYTE **)sub_100365D0((int)a4, *result, a3);
        break;
    }
    return result;
  }
}

//----- (100022B0) --------------------------------------------------------
unsigned int __usercall sub_100022B0@<eax>(const char *a1@<esi>)
{
  int v1; // ecx@1
  unsigned int result; // eax@3

  for ( LOBYTE(v1) = strlen(a1) - 1; a1[(unsigned __int8)v1] == 32; LOBYTE(v1) = v1 - 1 )
    ;
  v1 = (unsigned __int8)v1;
  result = strlen(a1) - 1;
  if ( (unsigned __int8)v1 < result )
    a1[v1 + 1] = 0;
  return result;
}

//----- (10002300) --------------------------------------------------------
char __cdecl sub_10002300(int a1)
{
  __int16 v1; // bx@1
  int v2; // ST00_4@1
  int v3; // ecx@1
  int v4; // edx@1
  int v5; // eax@1
  int v6; // edi@1
  bool v7; // zf@1
  _BYTE **v8; // eax@2
  signed int v9; // esi@2
  char *v10; // eax@26
  char v11; // cl@27
  int v12; // esi@30
  signed int v13; // edi@31
  char result; // al@40
  char v15; // [sp+Fh] [bp-329h]@1
  char v16; // [sp+10h] [bp-328h]@1
  char v17; // [sp+11h] [bp-327h]@1
  char v18; // [sp+12h] [bp-326h]@1
  char v19; // [sp+13h] [bp-325h]@3
  int v20; // [sp+14h] [bp-324h]@1
  signed int v21; // [sp+18h] [bp-320h]@2
  int v22; // [sp+1Ch] [bp-31Ch]@2
  __int16 v23; // [sp+20h] [bp-318h]@31
  int v24; // [sp+24h] [bp-314h]@31
  char v25; // [sp+28h] [bp-310h]@31
  __int16 v26; // [sp+2Ah] [bp-30Eh]@31
  __int16 v27; // [sp+2Ch] [bp-30Ch]@31
  __int16 v28; // [sp+2Eh] [bp-30Ah]@31
  char v29; // [sp+30h] [bp-308h]@31
  int v30; // [sp+34h] [bp-304h]@1
  _BYTE **v31; // [sp+38h] [bp-300h]@2
  int v32; // [sp+3Ch] [bp-2FCh]@1
  char v33; // [sp+40h] [bp-2F8h]@1
  char v34; // [sp+104h] [bp-234h]@1
  char v35; // [sp+105h] [bp-233h]@1
  __int16 v36; // [sp+106h] [bp-232h]@28
  char v37; // [sp+208h] [bp-130h]@1

  v1 = 0;
  v33 = 9;
  v34 = 0;
  memset(&v35, 0, 0x100u);
  memset(&v37, 0, 0x12Cu);
  v2 = *(_DWORD *)(a1 + 52) + 12;
  v20 = 0;
  v30 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  *(_BYTE *)(a1 + 6) = 2;
  TXT_get_hndl(v2);
  v3 = *(_DWORD *)(a1 + 48);
  v4 = *(_DWORD *)(v3 + 56);
  v5 = 4 * *(_BYTE *)(v3 + 230);
  v6 = *(_DWORD *)(v5 + v4);
  v7 = *(_DWORD *)v6 == 122;
  v32 = *(_DWORD *)(v5 + v4);
  if ( !v7 )
  {
    v34 = 0;
    sub_100365D0((int)&v35, "Field type not recognized.", 256);
    goto LABEL_36;
  }
  v22 = *(_DWORD *)(v5 + *(_DWORD *)(v3 + 60));
  v8 = (_BYTE **)sub_10004F90(a1, *(_WORD *)(v6 + 6));
  v9 = 0;
  v7 = *(_WORD *)(v22 + 8) == 0;
  v31 = v8;
  v21 = 0;
  if ( v7 )
    goto LABEL_25;
  while ( 1 )
  {
    v19 = (*(int (__cdecl **)(int, _BYTE **, signed int))(v6 + 12))(a1, v31, v9);
    if ( v19 == (_BYTE)v1 )
      goto LABEL_21;
    sub_10002150(v31, 0, 0x12Cu, &v37, *(_DWORD **)(v6 + 8));
    sub_100022B0(&v37);
    if ( !v18 && v21 == *(_WORD *)(v22 + 2) )
    {
      v18 = 1;
      if ( !v17 )
      {
        v15 = 1;
        v30 = 1;
        goto LABEL_11;
      }
      v15 = 0;
      v16 = 1;
    }
    if ( v17 )
      goto LABEL_16;
LABEL_11:
    if ( strcmp(&v37, (const char *)(*(_DWORD *)(a1 + 52) + 12)) )
      goto LABEL_16;
    if ( v19 != 1 )
    {
      v34 = 0;
      sub_100365D0((int)&v35, "This selection cannot be highlighted: ", 256);
      sub_100367C0(&v35, (_BYTE *)(*(_DWORD *)(a1 + 52) + 12), 256);
LABEL_16:
      if ( !v15 || v19 != 1 )
        goto LABEL_19;
      goto LABEL_18;
    }
    v17 = 1;
    if ( v18 )
      break;
    v15 = 1;
    v30 = -1;
LABEL_18:
    ++v20;
LABEL_19:
    v9 = v21;
    if ( v16 )
      goto LABEL_24;
    v6 = v32;
    v1 = 0;
LABEL_21:
    v21 = ++v9;
    if ( v9 >= *(_WORD *)(v22 + 8) )
      goto LABEL_25;
  }
  v9 = v21;
  v16 = 1;
LABEL_24:
  v1 = 0;
LABEL_25:
  sub_10004BF0(0, (unsigned int)v31);
  if ( v9 == *(_WORD *)(v22 + 8) )
  {
    v10 = &v35;
    v34 = 0;
    v20 = 0;
    do
      v11 = *v10++;
    while ( v11 );
    if ( (__int16 *)v10 == &v36 )
    {
      sub_100365D0((int)&v35, "This selection does not exist: ", 256);
      sub_100367C0(&v35, (_BYTE *)(*(_DWORD *)(a1 + 52) + 12), 256);
    }
  }
  v12 = v20;
  if ( v16 != (_BYTE)v1 )
  {
    v13 = 0;
    v34 = 1;
    v23 = -32696;
    v24 = 0;
    v25 = v30;
    v26 = 57;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    if ( v20 > 0 )
    {
      do
      {
        if ( v13 >= 15 )
          break;
        sub_10003DE0(a1, (int)&v23, 20);
        --v12;
        ++v13;
      }
      while ( v12 > 0 );
    }
    v34 = 1;
  }
  if ( v12 )
  {
    result = sub_100372C0((_BYTE *)(*(_DWORD *)(a1 + 52) + 12));
  }
  else
  {
LABEL_36:
    v23 = -32696;
    v25 = 1;
    v27 = v1;
    v28 = v1;
    v29 = v1;
    if ( v34 == 1 )
    {
      v24 = *(_DWORD *)(a1 + 56);
      v26 = 33;
      sub_10003DE0(a1, (int)&v23, 20);
    }
    else
    {
      v24 = *(_DWORD *)(a1 + 56);
      v26 = 40;
      sub_10003DE0(a1, (int)&v23, 20);
    }
    result = sub_10036820(&v33);
  }
  return result;
}
// 10022FA2: using guessed type int __cdecl TXT_get_hndl(_DWORD);

//----- (100026C0) --------------------------------------------------------
char __cdecl sub_100026C0(int a1)
{
  int *v1; // ecx@1
  __int16 v2; // bx@1
  __int16 v3; // di@1
  char result; // al@1
  bool v5; // zf@1
  __int16 v6; // bp@1
  int v7; // ecx@3
  __int16 v8; // si@4
  __int16 v9; // dx@5
  char v10; // [sp+13h] [bp-1h]@1
  int v11; // [sp+18h] [bp+4h]@1

  v1 = (int *)a1;
  v2 = *(_WORD *)(a1 + 30);
  v3 = *(_WORD *)(a1 + 28);
  result = 0;
  v5 = a1 == dword_107896C8;
  v10 = 0;
  v6 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 34) - 1;
  v11 = (unsigned __int16)(*(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 32) - 1);
  if ( v5 )
  {
    result = 1;
    v10 = 1;
  }
  v7 = *v1;
  if ( v7 )
  {
    while ( 1 )
    {
      v8 = *(_WORD *)(v7 + 28);
      if ( v3 >= v8 )
      {
        v9 = *(_WORD *)(v7 + 30);
        if ( v2 >= v9 && v6 <= *(_WORD *)(v7 + 34) + v9 - 1 && (signed __int16)v11 <= *(_WORD *)(v7 + 32) + v8 - 1 )
          break;
      }
      v7 = *(_DWORD *)v7;
      if ( !v7 )
        return v10;
    }
    result = 1;
  }
  return result;
}
// 107896C8: using guessed type int dword_107896C8;

//----- (10002770) --------------------------------------------------------
bool __cdecl sub_10002770(int a1, int a2)
{
  char v2; // al@1

  v2 = *(_BYTE *)(a2 + 24);
  return v2 == 1 || v2 == 3;
}

//----- (10002790) --------------------------------------------------------
int __usercall sub_10002790@<eax>(int result@<eax>, int a2@<esi>)
{
  float v2; // ST10_4@2
  float v3; // ST08_4@2

  if ( *(_BYTE *)(result + 11) )
  {
    j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
    j_gdi_pvg_matrix_mode(51);
    j_gdi_pvg_load_identity();
    v2 = (double)*(_WORD *)(a2 + 34);
    v3 = (double)*(_WORD *)(a2 + 32);
    sub_10069CD0(0.0, v3, 0.0, v2, 0.0, 1.0);
    j_gdi_pvg_matrix_mode(52);
    j_gdi_pvg_load_identity();
    if ( (*(_BYTE *)(a2 + 24) & 3) == 2 )
      result = j_gdi_pvg_viewport(0, 0, *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
    else
      result = j_gdi_pvg_viewport(*(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
  }
  return result;
}
// 10069CB0: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 10069CC0: using guessed type int __cdecl j_gdi_pvg_matrix_mode(_DWORD);
// 10069F80: using guessed type int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10002840) --------------------------------------------------------
int __cdecl sub_10002840(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // edx@2

  v2 = a2;
  if ( a2 )
  {
    v3 = a1;
    do
    {
      if ( sub_10002770(v3, v2) )
        break;
      v2 = *(_DWORD *)(v2 + 4);
    }
    while ( v2 );
  }
  return v2;
}

//----- (10002870) --------------------------------------------------------
char __cdecl sub_10002870(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int v6; // eax@2

  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 24) = a6;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) = a5;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) = a4;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 28) = a2;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 30) = a3;
  switch ( a6 & 3 )
  {
    case 0:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = sub_10005010(a1, a4, a5);
      LOBYTE(v6) = -1;
      if ( *(_DWORD *)(a1 + 24) == -1 || *(_BYTE *)(a1 + 11) != 1 )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = -1;
      }
      else
      {
        sub_10069FD0();
        sub_1006A020(1);
        v6 = sub_10069F90(a4, a5, 57);
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      }
      break;
    case 1:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = &unk_10319590;
      v6 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      break;
    case 2:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      sub_10069FD0();
      sub_1006A020(1);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = sub_10069F90(a4, a5, 59);
      LOBYTE(v6) = sub_10002790(a1, *(_DWORD *)(a1 + 56));
      break;
    case 3:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      v6 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(v6 + 52) = *(_DWORD *)(a1 + 24);
      break;
    default:
      LOBYTE(v6) = sub_100364C0(".\\cdp_cnvs_utl.c", 250, 1, 0);
      break;
  }
  return v6;
}
// 100932DC: using guessed type void *off_100932DC;

//----- (100029B0) --------------------------------------------------------
char __cdecl sub_100029B0(int a1, int a2)
{
  __int64 v2; // rax@4
  char result; // al@4
  int v4; // eax@5
  int v5; // eax@6
  int v6; // edx@6
  int v7; // eax@7
  int v8; // esi@9

  if ( !a2 )
    sub_100364C0(".\\cdp_cnvs_utl.c", 388, 1, 0);
  switch ( *(_BYTE *)(a2 + 24) & 3 )
  {
    case 0:
      *(_WORD *)(a1 + 270) = *(_WORD *)(a2 + 32);
      *(_WORD *)(a1 + 268) = *(_WORD *)(a2 + 34);
      *(_BYTE *)(a1 + 272) = 8;
      v2 = *(_WORD *)(a2 + 32) + 255;
      *(_WORD *)(a1 + 274) = (unsigned __int16)((BYTE4(v2) + (signed int)v2) >> 8) << 8;
      *(_DWORD *)(a1 + 264) = *(_DWORD *)(a2 + 48);
      *(_BYTE *)(a1 + 273) = 0;
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(a1 + 268);
      *(_WORD *)(a1 + 434) = 0;
      *(_WORD *)(a1 + 432) = 0;
      result = 1;
      break;
    case 1:
      v4 = *(_DWORD *)(a1 + 56);
      if ( *(_DWORD *)(v4 + 8) != *(_DWORD *)(a1 + 44) )
      {
        *(_DWORD *)(v4 + 52) = *(_DWORD *)(a1 + 24);
        sub_10002790(a1, *(_DWORD *)(a1 + 56));
        v5 = *(_DWORD *)(a1 + 56);
        v6 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 44) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(v5 + 52) = v6;
      }
      *(_DWORD *)(a1 + 264) = &unk_10319590;
      v7 = a1 + 264;
      *(_DWORD *)(v7 + 4) = *(&off_100932DC + 1);
      *(_DWORD *)(v7 + 8) = *(&off_100932DC + 2);
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(a1 + 268);
      sub_1001C300(a1 + 392, *(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
      *(_WORD *)(a1 + 434) = *(_WORD *)(a2 + 28);
      *(_WORD *)(a1 + 432) = *(_WORD *)(a2 + 30);
      result = 1;
      break;
    case 2:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      result = 1;
      break;
    case 3:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      v8 = *(_DWORD *)(a1 + 56);
      if ( *(_DWORD *)(v8 + 8) == *(_DWORD *)(a1 + 44) )
        goto LABEL_12;
      sub_10002790(a1, v8);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 8);
      result = 1;
      break;
    default:
      sub_100364C0(".\\cdp_cnvs_utl.c", 473, 1, 0);
LABEL_12:
      result = 1;
      break;
  }
  return result;
}
// 10069CB0: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 100932DC: using guessed type void *off_100932DC;

//----- (10002B90) --------------------------------------------------------
_DWORD *__cdecl sub_10002B90(int a1, char *a2, int a3, _DWORD *a4)
{
  char *v4; // edi@1
  void (__cdecl *v5)(int, char *, char *, int, void *); // ebx@1
  char *v6; // eax@1
  int v7; // ST0C_4@1
  _DWORD *result; // eax@1

  v4 = a2;
  v5 = (void (__cdecl *)(int, char *, char *, int, void *))dword_10789180[2 * (*(_DWORD *)a2 & 0xFF)];
  sub_10037480(a2, (int *)&a2, 0);
  v6 = a2;
  *(_WORD *)(a1 + 276) = *(_WORD *)a2;
  *(_WORD *)(a1 + 278) = *((_WORD *)v6 + 1);
  *(_WORD *)(a1 + 280) = *(_WORD *)v6;
  v7 = a3;
  *(_WORD *)(a1 + 282) = *((_WORD *)v6 + 1);
  v5(a1, v4, v6, v7, &unk_100B0974);
  result = a4;
  *a4 = *(_DWORD *)(a1 + 276);
  result[1] = *(_DWORD *)(a1 + 280);
  return result;
}
// 10789180: using guessed type int dword_10789180[];

//----- (10002C10) --------------------------------------------------------
char __cdecl sub_10002C10(int a1, _WORD *a2, char **a3, int a4, int a5, int a6)
{
  int v6; // edi@1
  char result; // al@1
  char **v8; // ebp@1
  int v9; // esi@1
  int v10; // ebx@1
  bool v11; // al@7
  bool v12; // al@11
  int v13; // [sp+10h] [bp-4h]@5
  int v14; // [sp+18h] [bp+4h]@2

  v6 = a1;
  result = sub_100029B0(a1, *(_DWORD *)(a1 + 56));
  v8 = a3;
  v9 = *(_DWORD *)*a3 & 0xFF;
  v10 = 0;
  if ( v9 == 141 )
  {
    *(_BYTE *)(a1 + 3) = 0;
  }
  else
  {
    v14 = 0;
    do
    {
      if ( *v8 )
      {
        result = sub_10037400(v6, a5, v10);
        if ( result )
        {
          sub_10037480(*v8, &v13, 0);
          v11 = v10 == a6 && sub_10037430(v6, a2, *(_DWORD *)(v6 + 56));
          *(_BYTE *)(v6 + 3) = v11;
          v12 = v10 == a6 && *(_DWORD *)(v6 + 56) == *(_DWORD *)(*(_DWORD *)(v6 + 48) + 4);
          *(_BYTE *)(v6 + 9) = v12;
          result = ((int (__cdecl *)(int, char *, int, _DWORD, _WORD *))dword_10789180[2 * v9])(
                     v6,
                     *v8,
                     v13,
                     *(_DWORD *)(v14 + a4),
                     a2);
        }
      }
      v14 = 4 * ++v10;
      v8 = &a3[v10];
      v9 = *(_DWORD *)a3[v10] & 0xFF;
    }
    while ( v9 != 141 );
    *(_BYTE *)(v6 + 3) = 0;
  }
  return result;
}
// 10789180: using guessed type int dword_10789180[];

//----- (10002D30) --------------------------------------------------------
bool __cdecl sub_10002D30(int a1, _WORD *a2, char *a3, int a4, int a5, int a6)
{
  int v6; // esi@1
  char *v7; // ebp@1
  int v8; // edi@1
  bool result; // al@1
  _WORD *v10; // ebx@2
  int v11; // eax@4
  bool v12; // al@6
  bool v13; // zf@8
  bool v14; // al@10
  char *v15; // [sp+Ch] [bp-8h]@1
  int v16; // [sp+10h] [bp-4h]@1

  v6 = a1;
  sub_100029B0(a1, *(_DWORD *)(a1 + 56));
  v7 = a3;
  v8 = 0;
  result = sub_10037480(a3, &v16, &v15);
  if ( result )
  {
    v10 = a2;
    do
    {
      if ( sub_10037400(v6, a5, v8) )
      {
        v11 = *(_DWORD *)(v6 + 56);
        LOWORD(a1) = *(_WORD *)v16 + *(_WORD *)(v11 + 36);
        HIWORD(a1) = *(_WORD *)(v16 + 2) + *(_WORD *)(v11 + 38);
        v12 = v8 == a6 && sub_10037430(v6, v10, v11);
        v13 = v8 == a6;
        *(_BYTE *)(v6 + 3) = v12;
        v14 = v13 && *(_DWORD *)(v6 + 56) == *(_DWORD *)(*(_DWORD *)(v6 + 48) + 4);
        *(_BYTE *)(v6 + 9) = v14;
        ((void (__cdecl *)(int, char *, int *, _DWORD, _WORD *))dword_10789180[2 * (*(_DWORD *)v7 & 0xFF)])(
          v6,
          v7,
          &a1,
          *(_DWORD *)(a4 + 4 * v8),
          v10);
      }
      v7 = v15;
      ++v8;
      result = sub_10037480(v15, &v16, &v15);
    }
    while ( result );
  }
  *(_BYTE *)(v6 + 3) = 0;
  return result;
}
// 10789180: using guessed type int dword_10789180[];

//----- (10002E30) --------------------------------------------------------
int __cdecl sub_10002E30(unsigned int a1)
{
  __int16 v1; // ax@1
  int v3; // [sp+4h] [bp+4h]@1

  v1 = word_1065DED0[(a1 >> 5) & 0x1F];
  HIWORD(v3) = word_1065DED0[a1 & 0x1F];
  LOWORD(v3) = v1;
  return v3;
}
// 1065DED0: using guessed type __int16 word_1065DED0[];

//----- (10002E60) --------------------------------------------------------
int *__cdecl sub_10002E60(unsigned int a1)
{
  return &dword_10789600[5 * ((a1 >> 10) & 0xF)];
}
// 10789600: using guessed type int dword_10789600[];

//----- (10002E80) --------------------------------------------------------
int __cdecl sub_10002E80(unsigned int a1)
{
  int *v1; // eax@1
  char v2; // cl@1
  int result; // eax@2

  v1 = sub_10002E60(a1);
  if ( v2 & 1 )
    result = v1[2];
  else
    result = v1[1];
  return result;
}

//----- (10002EA0) --------------------------------------------------------
signed int __cdecl sub_10002EA0(__int16 a1)
{
  signed int result; // eax@1

  result = 1073741828;
  if ( a1 & 0xC000 )
  {
    if ( (a1 & 0xC000) == 0x8000 )
      result = 1073741829;
  }
  else
  {
    result = 1073741830;
  }
  return result;
}

//----- (10002ED0) --------------------------------------------------------
signed int __cdecl sub_10002ED0(int a1)
{
  int v1; // eax@1
  signed int result; // eax@3

  v1 = a1 & 0xC00000;
  if ( a1 & 0xC00000 )
  {
    if ( v1 == 0x400000 )
      result = 1;
    else
      result = v1 != 0x800000 ? 0 : 2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10002F00) --------------------------------------------------------
int __usercall sub_10002F00@<eax>(_BYTE *a1@<eax>)
{
  int result; // eax@5

  if ( !*a1 )
    goto LABEL_9;
  do
  {
    if ( *a1 == 10 )
      break;
    ++a1;
  }
  while ( *a1 );
  if ( *a1 )
  {
    *a1 = 0;
    result = (int)(a1 + 1);
  }
  else
  {
LABEL_9:
    result = 0;
  }
  return result;
}

//----- (10002F30) --------------------------------------------------------
char __usercall sub_10002F30@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3)
{
  signed int v3; // ebx@1
  char result; // al@1
  char v5; // al@2
  char v6; // [sp+Bh] [bp-5h]@1
  char v7; // [sp+Ch] [bp-4h]@2
  char v8; // [sp+Dh] [bp-3h]@1

  v3 = a1;
  result = 0;
  v6 = 0;
  v8 = 0;
  if ( a1 <= (signed int)a3 )
  {
    do
    {
      v7 = v3;
      v5 = sub_1001C410(a2, &v7, 0);
      if ( v5 > v6 )
        v6 = v5;
      ++v3;
    }
    while ( v3 <= a3 );
    result = v6;
  }
  return result;
}

//----- (10002F80) --------------------------------------------------------
char __usercall sub_10002F80@<al>(size_t a1@<edx>, signed int a2@<ecx>, int a3@<esi>, const char *a4, int *a5, char a6, char a7)
{
  unsigned int v7; // ecx@1
  int v8; // edi@1
  int v9; // ebx@1
  int v10; // ecx@1
  char *v11; // eax@4
  char v12; // cl@6
  signed __int16 v13; // dx@9
  int v14; // eax@25
  unsigned int v15; // ebx@29
  unsigned __int8 v16; // al@29
  __int16 v17; // dx@37
  __int16 v18; // cx@37
  unsigned int v19; // edi@42
  signed int v20; // ecx@44
  int v21; // edi@46
  unsigned int v22; // edi@52
  __int16 v23; // ax@52
  __int16 v24; // dx@55
  __int16 v25; // cx@55
  int v26; // eax@58
  char result; // al@63
  int v28; // [sp+0h] [bp-6Ch]@0
  int v29; // [sp+Ch] [bp-60h]@1
  char *v30; // [sp+10h] [bp-5Ch]@6
  signed int v31; // [sp+14h] [bp-58h]@1
  int v32; // [sp+18h] [bp-54h]@1
  int v33; // [sp+1Ch] [bp-50h]@1
  int v34; // [sp+20h] [bp-4Ch]@1
  int v35; // [sp+24h] [bp-48h]@1
  int v36; // [sp+28h] [bp-44h]@1
  int v37; // [sp+2Ch] [bp-40h]@1
  int v38; // [sp+30h] [bp-3Ch]@1
  __int16 v39; // [sp+30h] [bp-3Ch]@29
  __int16 v40; // [sp+32h] [bp-3Ah]@29
  int v41; // [sp+34h] [bp-38h]@1
  size_t v42; // [sp+3Ch] [bp-30h]@1
  signed int v43; // [sp+40h] [bp-2Ch]@9
  int v44; // [sp+44h] [bp-28h]@21
  int v45; // [sp+48h] [bp-24h]@15
  unsigned int v46; // [sp+4Ch] [bp-20h]@29
  signed int v47; // [sp+50h] [bp-1Ch]@1
  char v48; // [sp+54h] [bp-18h]@4

  v31 = a2;
  v42 = a1;
  v7 = strlen(a4);
  v34 = a5[2];
  v8 = a5[1];
  v35 = a5[3];
  v9 = v7;
  v36 = a5[4];
  v47 = v7;
  v32 = *a5;
  v33 = v8;
  v37 = a5[5];
  v29 = 0;
  v41 = *(_WORD *)(*a5 + 28);
  v10 = sub_1001C410(*a5, a4, v8);
  v38 = v10;
  if ( (signed __int16)v35 <= 0 )
    LOWORD(v35) = v10;
  if ( (unsigned int)v9 >= 0x14 )
    v11 = (char *)sub_10004F90(a3, v9 + 1);
  else
    v11 = &v48;
  v12 = *(_BYTE *)(a3 + 3);
  v30 = v11;
  if ( v12 && a6 && v31 > 0 )
  {
    v13 = 1;
    v43 = 1;
  }
  else
  {
    v43 = 0;
    v13 = 1;
  }
  v45 = v12 && (!a6 || v31 >= 0 && v31 + 1 <= v9);
  v44 = *(_BYTE *)(a3 + 3) && a6 && (v31 < 0 || (signed int)(v31 + v42) < v9);
  if ( (v8 & 3) != 2 )
  {
    if ( v8 & 3 )
    {
      *(_WORD *)(a3 + 438) += (signed __int16)v35 / -2;
      v14 = ((signed __int16)v35 - v38) / 2;
    }
    else
    {
      *(_WORD *)(a3 + 438) += v13 - v35;
      v14 = (signed __int16)v35 - v38;
    }
    v8 = v8 & 0xFFFFFFFE | 2;
    v33 = v8;
    if ( v14 > 0 )
      v29 = v14;
  }
  v15 = v8 & 0xFFFFFFF7 | 4;
  v39 = v35 + v41 + *(_WORD *)(a3 + 438);
  v16 = v34;
  v40 = *(_WORD *)(a3 + 436);
  v46 = v8 & 0xFFFFFFF7 | 4;
  if ( !v43 && !v45 && v44 )
    v16 = 0;
  if ( *(_BYTE *)(a3 + 3) && !a6 && (byte_10756F5E || byte_10789160) )
  {
    v17 = v36;
    v18 = HIWORD(v35);
  }
  else
  {
    v17 = HIWORD(v35);
    v18 = v36;
  }
  *(_WORD *)(a3 + 428) = v17;
  *(_WORD *)(a3 + 430) = v18;
  sub_1001C470(a3 + 392, v32, byte_10084570, v35, v8 & 0xFFFFFFF7 | 4, v16, v28);
  *(_WORD *)(a3 + 438) += v29;
  if ( *(_BYTE *)(a3 + 3) )
  {
    if ( v43 )
    {
      v19 = v8 & 0xFFFFFFF3;
      if ( a7 )
        --*(_WORD *)(a3 + 438);
      strncpy(v30, a4, v31);
      v20 = v31;
      if ( v31 >= v47 )
        v20 = v47;
      v30[v20] = 0;
      *(_WORD *)(a3 + 428) = HIWORD(v35);
      *(_WORD *)(a3 + 430) = v36;
      v21 = sub_1001C470(a3 + 392, v32, v30, v35 - v29, v19 | 0x80000000, 0, v37) + v29;
      if ( a7 )
        *(_WORD *)(a3 + 438) += v41 + 1;
      else
        *(_WORD *)(a3 + 438) += v41;
      v15 = v46;
      v29 = v41 + v21;
      v8 = v33;
    }
    if ( v45 )
    {
      if ( a6 )
      {
        v22 = v34 & 0xFFFF0001 | 1;
        strncpy(v30, &a4[v31], v42);
        v30[v42] = 0;
        v23 = 0;
      }
      else
      {
        LOWORD(v22) = (unsigned __int8)v34;
        strcpy(v30, a4);
        v23 = v35 - v29;
      }
      if ( byte_10756F5E || byte_10789160 )
      {
        v24 = v36;
        v25 = HIWORD(v35);
      }
      else
      {
        v24 = HIWORD(v35);
        v25 = v36;
      }
      *(_WORD *)(a3 + 428) = v24;
      *(_WORD *)(a3 + 430) = v25;
      v26 = sub_1001C470(a3 + 392, v32, v30, v23, v15 | 0x80000000, v22, v37);
      v8 = v33;
      *(_WORD *)(a3 + 438) += v41;
      v29 += v41 + v26;
    }
    if ( v44 )
    {
      if ( a7 )
        ++*(_WORD *)(a3 + 438);
      *(_WORD *)(a3 + 428) = HIWORD(v35);
      *(_WORD *)(a3 + 430) = v36;
      sub_1001C470(
        a3 + 392,
        v32,
        &a4[((v42 + v31) & 0x80000000) != 0 ? 0 : v42 + v31],
        v35 - v29,
        v8 & 0xFFFFFFF3 | 0x80000000,
        0,
        v37);
    }
  }
  else
  {
    *(_WORD *)(a3 + 428) = HIWORD(v35);
    *(_WORD *)(a3 + 430) = v36;
    sub_1001C470(a3 + 392, v32, a4, v35 - v29, v8 | 0x80000000, v34, v37);
  }
  *(_WORD *)(a3 + 436) = v40;
  result = (char)v30;
  *(_WORD *)(a3 + 438) = v39;
  if ( v30 != &v48 )
    result = sub_10004BF0(a3, (unsigned int)v30);
  return result;
}
// 10756F5E: using guessed type char byte_10756F5E;
// 10789160: using guessed type char byte_10789160;

//----- (10003480) --------------------------------------------------------
__int16 __cdecl sub_10003480(_BYTE *a1, unsigned int a2)
{
  int v2; // edi@1
  __int16 result; // ax@2
  int v4; // ebx@3
  _BYTE *v5; // edx@3
  int v6; // ebp@3
  int v7; // esi@4
  _BYTE *v8; // edx@4
  int v9; // eax@4

  v2 = 0;
  if ( *a1 )
  {
    v4 = sub_10002EA0(a2);
    v6 = sub_10002E60(a2)[1];
    do
    {
      v7 = sub_10002F00(v5);
      v9 = sub_1001C410(v6, v8, v4);
      if ( v2 <= v9 )
        v2 = v9;
      v5 = (_BYTE *)v7;
    }
    while ( v7 );
    result = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100034E0) --------------------------------------------------------
int __cdecl sub_100034E0(unsigned int a1, unsigned int a2, float *a3)
{
  int v3; // esi@1
  _BYTE *v4; // eax@1

  v3 = sub_10002E60(a1)[1];
  v4 = (_BYTE *)sub_10037720(a2, a3);
  return sub_1001C410(v3, v4, 0);
}

//----- (10003510) --------------------------------------------------------
int sub_10003510()
{
  void *v0; // ebx@1
  unsigned __int8 v1; // al@2
  int *v2; // esi@2
  unsigned __int8 v3; // al@2
  int v4; // eax@2
  char v5; // al@2
  int v6; // edi@2
  char v7; // al@2
  int v8; // edi@2
  unsigned __int8 v9; // al@2
  int result; // eax@2

  v0 = &unk_10084524;
  do
  {
    v1 = *(_BYTE *)v0;
    v2 = &dword_10789600[5 * ((*((_DWORD *)v0 - 1) >> 10) & 0xF)];
    *((_BYTE *)v2 + 12) = *(_BYTE *)v0;
    *v2 = FNT_get_fnt_hdr(v1);
    v3 = *((_BYTE *)v0 + 1);
    *((_BYTE *)v2 + 13) = v3;
    v4 = FNT_get_fnt_hdr(v3);
    v2[1] = v4;
    v5 = sub_1001C410(v4, &unk_10084574, 0);
    v6 = v2[1];
    *((_BYTE *)v2 + 15) = v5;
    v7 = sub_10002F30(0x20u, v6, 0x5Fu);
    v8 = v2[1];
    *((_BYTE *)v2 + 16) = v7;
    *((_BYTE *)v2 + 17) = sub_10002F30(0x30u, v8, 0x39u);
    v9 = *((_BYTE *)v0 + 2);
    *((_BYTE *)v2 + 14) = v9;
    result = FNT_get_fnt_hdr(v9);
    v0 = (char *)v0 + 8;
    v2[2] = result;
  }
  while ( (signed int)v0 < (signed int)&unk_10084574 );
  return result;
}
// 10022FA8: using guessed type int __cdecl FNT_get_fnt_hdr(_DWORD);
// 10789600: using guessed type int dword_10789600[];

//----- (100035B0) --------------------------------------------------------
char __cdecl sub_100035B0(int a1, const char *a2, int *a3)
{
  return sub_10002F80(
           *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242),
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 240),
           a1,
           a2,
           a3,
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128,
           1);
}

//----- (100035F0) --------------------------------------------------------
int __cdecl sub_100035F0(unsigned int a1, char a2)
{
  int v2; // eax@1
  int v3; // edx@1
  char v4; // si@1
  signed int v5; // eax@4

  v2 = sub_10002E60(a1)[1];
  v3 = 1;
  v4 = 1;
  if ( !a2 )
  {
    if ( *(_WORD *)(v2 + 22) - *(_WORD *)(v2 + 24) > 1 )
      v3 = *(_WORD *)(v2 + 22) - *(_WORD *)(v2 + 24);
    v5 = *(_WORD *)(v2 + 26);
    if ( v5 > 1 )
      v4 = v5;
  }
  return (((v3 << 8) | (unsigned __int8)v4) << 16) | 0x101;
}

//----- (10003650) --------------------------------------------------------
char __cdecl sub_10003650(int a1, const char *a2, int *a3, int a4)
{
  int v4; // eax@1
  unsigned int v5; // edi@1
  int v6; // ebp@1
  int v7; // esi@1
  int v8; // eax@1
  char *v9; // edi@1
  int v10; // ecx@2
  int v11; // ebp@2
  int v12; // ecx@6
  char v14; // [sp+13h] [bp-11h]@1
  char *v15; // [sp+14h] [bp-10h]@1
  unsigned int v16; // [sp+18h] [bp-Ch]@1
  unsigned int v17; // [sp+1Ch] [bp-8h]@1
  __int16 v18; // [sp+20h] [bp-4h]@1
  signed int v19; // [sp+28h] [bp+4h]@1
  __int16 v20; // [sp+2Ch] [bp+8h]@1
  __int16 v21; // [sp+2Eh] [bp+Ah]@1

  v4 = a3[2];
  v5 = (unsigned int)a3[2] >> 24;
  v6 = ((unsigned int)a3[2] >> 16) & 0xFF;
  v16 = v4 & 0xFFFF0001 | 1;
  v14 = 1;
  v17 = (v4 & 0xFFFFFF ^ ((v5 + a4) << 24)) & 0xFFFF0001 | 1;
  v7 = a1;
  v15 = (char *)sub_10004F90(a1, strlen(a2) + 1);
  strcpy(v15, a2);
  v21 = *(_WORD *)(a1 + 436);
  v19 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
  v20 = *(_WORD *)(v7 + 438);
  v8 = v5 + v6 + *(_WORD *)(*a3 + 24) - *(_WORD *)(*a3 + 26);
  v9 = v15;
  v18 = a4 + v8;
  do
  {
    v11 = sub_10002F00(v9);
    *(_WORD *)(v7 + 438) = v20;
    *(_WORD *)(v7 + 436) = v21;
    if ( v11 )
      *(_DWORD *)(v10 + 8) = v17;
    else
      *(_DWORD *)(v10 + 8) = v16;
    if ( *(_BYTE *)(v7 + 3) && (v12 = *(_DWORD *)(v7 + 56), *(_WORD *)(v12 + 240) != -128) )
    {
      if ( v19 >= (signed int)strlen(v9) || v19 < 0 )
      {
        *(_BYTE *)(v7 + 3) = 0;
        sub_10002F80(*(_BYTE *)(v12 + 242), -128, v7, v9, a3, 0, 0);
        *(_BYTE *)(v7 + 3) = 1;
      }
      else
      {
        sub_10002F80(*(_BYTE *)(v12 + 242), v19, v7, v9, a3, 1, 0);
      }
      v19 -= strlen(v9);
    }
    else
    {
      if ( !v14 )
      {
        LOBYTE(a4) = *(_BYTE *)(v7 + 3);
        *(_BYTE *)(v7 + 3) = 0;
      }
      sub_10002F80(
        *(_BYTE *)(*(_DWORD *)(v7 + 56) + 242),
        v19,
        v7,
        v9,
        a3,
        *(_WORD *)(*(_DWORD *)(v7 + 56) + 240) != -128,
        1);
      if ( !v14 )
        *(_BYTE *)(v7 + 3) = a4;
    }
    v21 += v18;
    v9 = (char *)v11;
    v14 = 0;
  }
  while ( v11 );
  return sub_10004BF0(v7, (unsigned int)v15);
}

//----- (10003860) --------------------------------------------------------
int __cdecl sub_10003860(int a1, int a2, unsigned int a3, int a4)
{
  unsigned int v4; // edi@1
  int v5; // eax@1
  unsigned int v6; // ecx@1
  int v7; // edi@1
  int v8; // eax@3
  int result; // eax@3
  int v10; // [sp+18h] [bp+Ch]@1

  v4 = a3;
  v10 = sub_100035F0(a3, 0);
  v5 = sub_10002E60(v4)[1];
  *(_WORD *)(a1 + 2) = HIWORD(a2) + *(_WORD *)(v5 + 26) - BYTE2(v10) - *(_WORD *)(v5 + 24) + 1;
  v7 = v4 & 0xC000;
  *(_WORD *)(a1 + 6) = HIWORD(a2) + *(_WORD *)(v5 + 22) + (v6 >> 24) - *(_WORD *)(v5 + 24) - 1;
  if ( v7 )
  {
    if ( v7 == 0x4000 )
    {
      *(_WORD *)(a1 + 4) = a2 + 1;
      result = a2 + 1 - a4 - 1;
      *(_WORD *)a1 = result;
    }
    else
    {
      v8 = a2 - (a4 + 2) / 2 - 1;
      *(_WORD *)a1 = v8;
      result = v8 + a4 + 2 - 1;
      *(_WORD *)(a1 + 4) = result;
    }
  }
  else
  {
    result = a2 - 1;
    *(_WORD *)(a1 + 4) = a2 - 1 + a4 + 1;
    *(_WORD *)a1 = a2 - 1;
  }
  return result;
}

//----- (10003930) --------------------------------------------------------
__int16 __cdecl sub_10003930(char *a1, int a2, int a3, int a4, int a5)
{
  unsigned int v5; // eax@1
  unsigned int v6; // edi@1
  int v7; // ebp@1
  int v8; // ebx@1
  char *v9; // eax@1
  int v10; // edx@3

  v5 = sub_100035F0(a2, 0);
  v6 = v5 >> 24;
  v7 = (v5 >> 16) & 0xFF;
  v8 = sub_10002E60(a2)[1];
  v9 = strchr(a1, 10);
  for ( *(_DWORD *)a5 = 1; v9; ++*(_DWORD *)a5 )
    v9 = strchr(v9 + 1, 10);
  v10 = a3 + v6 + v7 + *(_WORD *)(v8 + 24) - *(_WORD *)(v8 + 26);
  *(_DWORD *)a4 = v10;
  return *(_WORD *)a5 * v10 - a3;
}

//----- (100039C0) --------------------------------------------------------
char __cdecl sub_100039C0(int a1, char *a2, const char *a3, __int16 a4, __int16 a5, unsigned int a6, __int16 a7)
{
  int *v7; // eax@1
  int v8; // ebx@1
  signed int v9; // edi@1
  signed int v10; // eax@4
  int v11; // ebp@4
  unsigned int v12; // ebx@4
  int v13; // eax@4
  __int16 v14; // cx@4
  int v15; // edx@4
  int v16; // edi@9
  signed int v17; // ecx@12
  __int64 v18; // rax@12
  __int16 v19; // dx@15
  __int16 v20; // dx@15
  int v21; // eax@17
  signed int v22; // edi@17
  int v24; // [sp+10h] [bp-30h]@1
  unsigned int v25; // [sp+14h] [bp-2Ch]@1
  unsigned int v26; // [sp+18h] [bp-28h]@1
  __int16 v27; // [sp+1Ch] [bp-24h]@2
  int v28; // [sp+1Eh] [bp-22h]@1
  int v29; // [sp+24h] [bp-1Ch]@4
  int v30; // [sp+28h] [bp-18h]@4
  unsigned int v31; // [sp+2Ch] [bp-14h]@4
  int v32; // [sp+30h] [bp-10h]@4
  char v33[6]; // [sp+34h] [bp-Ch]@4
  int v34; // [sp+3Ch] [bp-4h]@4

  v28 = sub_10002E30(a6);
  v7 = sub_10002E60(a6);
  v8 = v7[1];
  v24 = v7[1];
  v26 = sub_100035F0(a6, 0) & 0xFFFFFF00;
  v9 = sub_10002EA0(a6);
  v25 = v9 & 0xFFFFFFFE | 2;
  if ( a7 & 0x200 )
  {
    v27 = 0;
    a3 = byte_10084570;
  }
  else
  {
    v27 = a5;
  }
  v10 = sub_10002ED0(a6);
  v11 = v10;
  v29 = v10;
  *(_DWORD *)&v33[2] = sub_10002E30(a6);
  v30 = v8;
  v12 = v9 & 0xFFFFFFFC;
  v34 = v11;
  v32 = sub_100035F0(a6, 0);
  v31 = v9 & 0xFFFFFFFC;
  *(_WORD *)v33 = a4;
  v13 = sub_1001C410(v30, a2, v9 & 0xFFFFFFFC);
  v14 = v27;
  v15 = 0;
  if ( v27 > 0 && a4 > 0 )
    v15 = *(_WORD *)(v30 + 28);
  if ( a6 & 0xC000 )
  {
    if ( (a6 & 0xC000) == 0x8000 )
    {
      if ( v27 && a4 )
      {
        v17 = v15 + v27 + a4;
        v18 = v13 - *(_WORD *)(v30 + 28) - v27 + 1;
        v16 = (((signed int)v18 - HIDWORD(v18)) >> 1) - 1;
        LODWORD(v18) = v17 / 2 + v16 + 1;
        LOWORD(v17) = v17 - *(_WORD *)(v30 + 28);
        *(_WORD *)v33 = v18;
        v14 = v17 - v18;
        v27 = v14;
      }
      else
      {
        LOWORD(v16) = 0;
        v31 = v12 & 0xFFFFFFFD | 1;
        v25 = v25 & 0xFFFFFFFD | 1;
      }
    }
    else
    {
      v16 = -v27;
    }
  }
  else
  {
    if ( a4 > v13 )
    {
      v19 = v15 - *(_WORD *)(v30 + 28);
      *(_WORD *)v33 = v13;
      v20 = a4 + v19 - v13;
      v14 = v20 + v27;
      v27 += v20;
    }
    LOWORD(v16) = *(_WORD *)v33 - 1;
  }
  *(_WORD *)(a1 + 438) += v16;
  v21 = *(_DWORD *)(a1 + 56);
  v22 = *(_WORD *)(v21 + 240);
  if ( *(_WORD *)v33 > 0 )
  {
    LOBYTE(v21) = sub_10002F80(*(_BYTE *)(v21 + 242), v22, a1, a2, &v30, *(_WORD *)(v21 + 240) != -128, 1);
    v14 = v27;
  }
  if ( v14 > 0 )
  {
    if ( v22 != -128 )
      v22 -= strlen(a2);
    LOBYTE(v21) = sub_10002F80(
                    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242),
                    v22,
                    a1,
                    a3,
                    &v24,
                    *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128,
                    1);
  }
  return v21;
}

//----- (10003BF0) --------------------------------------------------------
unsigned int sub_10003BF0()
{
  int *v0; // ecx@1
  unsigned int result; // eax@1
  int v2; // ecx@3
  int v3; // ecx@3
  int v4; // ecx@3
  int v5; // ecx@3
  int v6; // ecx@3
  int v7; // ecx@3
  int v8; // edx@3

  v0 = dword_10789184;
  result = 0;
  do
  {
    *(v0 - 1) = 0;
    *(_BYTE *)v0 = 0;
    v0 += 2;
  }
  while ( (signed int)v0 < (signed int)&unk_107895EC );
  do
  {
    v2 = dword_10084B28[result];
    dword_10789180[2 * v2] = *(int *)((char *)&off_10084B2C + result * 4);
    dword_10789184[2 * v2] = dword_10084B30[result];
    v3 = dword_10084B34[result];
    dword_10789180[2 * v3] = *(int *)((char *)&off_10084B38 + result * 4);
    dword_10789184[2 * v3] = dword_10084B3C[result];
    v4 = dword_10084B40[result];
    dword_10789180[2 * v4] = *(int *)((char *)&off_10084B44 + result * 4);
    dword_10789184[2 * v4] = dword_10084B48[result];
    v5 = dword_10084B4C[result];
    dword_10789180[2 * v5] = *(int *)((char *)&off_10084B50 + result * 4);
    dword_10789184[2 * v5] = dword_10084B54[result];
    v6 = dword_10084B58[result];
    dword_10789180[2 * v6] = *(int *)((char *)&off_10084B5C + result * 4);
    dword_10789184[2 * v6] = dword_10084B60[result];
    v7 = dword_10084B64[result];
    dword_10789180[2 * v7] = *(int *)((char *)&off_10084B68 + result * 4);
    v8 = dword_10084B6C[result];
    result += 18;
    dword_10789184[2 * v7] = v8;
  }
  while ( result < 108 );
  return result * 4;
}
// 10084B28: using guessed type int dword_10084B28[];
// 10084B2C: using guessed type int (__cdecl *off_10084B2C)(int, int, int, int, int);
// 10084B30: using guessed type int dword_10084B30[];
// 10084B34: using guessed type int dword_10084B34[];
// 10084B38: using guessed type int (__cdecl *off_10084B38)(int, int, int, int, int);
// 10084B3C: using guessed type int dword_10084B3C[];
// 10084B40: using guessed type int dword_10084B40[];
// 10084B44: using guessed type int (__cdecl *off_10084B44)(int, int, int, int, int);
// 10084B48: using guessed type int dword_10084B48[];
// 10084B4C: using guessed type int dword_10084B4C[];
// 10084B50: using guessed type int (__cdecl *off_10084B50)(int, int, int, int, int);
// 10084B54: using guessed type int dword_10084B54[];
// 10084B58: using guessed type int dword_10084B58[];
// 10084B5C: using guessed type int (__cdecl *off_10084B5C)(int, int, int, int, int);
// 10084B60: using guessed type int dword_10084B60[];
// 10084B64: using guessed type int dword_10084B64[];
// 10084B68: using guessed type int (__cdecl *off_10084B68)(int, int, int, int, int);
// 10084B6C: using guessed type int dword_10084B6C[];
// 10789180: using guessed type int dword_10789180[];
// 10789184: using guessed type int dword_10789184[];

//----- (10003CE0) --------------------------------------------------------
int __cdecl sub_10003CE0(int a1, int a2)
{
  int result; // eax@1

  for ( result = *(_DWORD *)(a1 + 48); result; result = *(_DWORD *)(result + 4) )
  {
    if ( *(_DWORD *)(result + 8) == a2 )
      break;
  }
  return result;
}

//----- (10003D00) --------------------------------------------------------
int __cdecl sub_10003D00(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 3) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_BYTE *)(a1 + 5) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 10) = 0;
  *(_BYTE *)(a1 + 7) = 1;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

//----- (10003D30) --------------------------------------------------------
_DWORD *sub_10003D30()
{
  _DWORD *result; // eax@1

  byte_10789160 = 0;
  result = sub_100381A0(&unk_1013F4B0);
  dword_10756F54 = 0;
  return result;
}
// 10756F54: using guessed type int dword_10756F54;
// 10789160: using guessed type char byte_10789160;

//----- (10003D50) --------------------------------------------------------
int __cdecl sub_10003D50(int a1, char *a2, int a3, int a4)
{
  if ( !a2 )
    sub_100364C0(".\\cdp_main.c", 890, 1, 0);
  if ( a3 > 0 )
    *((_DWORD *)a2 + 3) = sub_10004F90(a1, a3);
  *((_DWORD *)a2 + 14) = sub_10004F90(a1, 4 * a4 + 4);
  a2[68] = a4;
  a2[231] = 0;
  if ( a4 > 0 )
  {
    *((_DWORD *)a2 + 15) = sub_10004F90(a1, 4 * a4);
    *((_DWORD *)a2 + 16) = sub_10004F90(a1, a4);
  }
  return *((_DWORD *)a2 + 3);
}

//----- (10003DE0) --------------------------------------------------------
char __cdecl sub_10003DE0(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 1;
  v9 = 1000;
  v4 = sub_10069830(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_100364C0(".\\cdp_main.c", 1068, 0, 0);
  return v4;
}

//----- (10003E50) --------------------------------------------------------
char __cdecl sub_10003E50(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 2;
  v9 = 1000;
  v4 = sub_10069830(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_100364C0(".\\cdp_main.c", 1136, 0, 0);
  return v4;
}

//----- (10003EC0) --------------------------------------------------------
int sub_10003EC0()
{
  int result; // eax@1

  result = sub_10069700();
  dword_1013F4B8 = result;
  byte_1013F4B4 = 0;
  return result;
}
// 1013F4B4: using guessed type char byte_1013F4B4;
// 1013F4B8: using guessed type int dword_1013F4B8;

//----- (10003EE0) --------------------------------------------------------
_DWORD *__cdecl sub_10003EE0(int a1)
{
  return sub_100381E0(&unk_1013F4B0, a1);
}

//----- (10003F00) --------------------------------------------------------
unsigned int __cdecl sub_10003F00(int a1, int a2, int a3)
{
  int v3; // ecx@1
  unsigned int result; // eax@1

  v3 = a3 * (1000 / *(_WORD *)(a1 + 20)) + 500;
  result = ((signed int)((unsigned __int64)(v3 * (signed __int64)(signed int)&unk_10624DD3) >> 32) >> 6)
         + ((unsigned int)((unsigned __int64)(v3 * (signed __int64)(signed int)&unk_10624DD3) >> 32) >> 31);
  if ( result >= 1 )
  {
    if ( result >= 0xFF )
      result = 255;
    *(_BYTE *)(a2 + 243) = result;
    *(_BYTE *)(a2 + 244) = result;
  }
  else
  {
    result = 1;
    *(_BYTE *)(a2 + 243) = 1;
    *(_BYTE *)(a2 + 244) = 1;
  }
  return result;
}

//----- (10003F70) --------------------------------------------------------
void __usercall sub_10003F70(int a1@<esi>)
{
  if ( *(_BYTE *)(a1 + 11) )
  {
    sub_10069C70();
    sub_10069FD0();
    sub_1006A020(1);
    *(_DWORD *)(a1 + 28) = sub_10069F90(*(_WORD *)(a1 + 16), *(_WORD *)(a1 + 14), 57);
    sub_10069FD0();
    sub_1006A030(1);
    sub_1006A040(3000000);
    *(_DWORD *)(a1 + 24) = sub_10069F90(*(_WORD *)(a1 + 16), *(_WORD *)(a1 + 14), 59);
  }
}

//----- (10003FD0) --------------------------------------------------------
int __usercall sub_10003FD0@<eax>(int a1@<esi>)
{
  _WORD *v1; // eax@1
  int v2; // edi@1
  void *v3; // ecx@1
  int v4; // eax@1
  int v5; // eax@9
  int result; // eax@13
  char v7; // [sp+8h] [bp-8h]@1
  int v8; // [sp+Ch] [bp-4h]@1

  v1 = *(_WORD **)(a1 + 52);
  v8 = 2;
  byte_10756F5E = *v1 == -32749;
  byte_10789160 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  v2 = *(_DWORD *)(a1 + 56);
  sub_1006A100(9129, &v7, 2, &v8);
  v4 = *(_DWORD *)(a1 + 64);
  if ( (v4 == 1 || v4 == 9) && sub_10038600(v3) != 2 && v7 & 0x1C )
  {
    byte_10756F5E = 0;
    byte_10789160 = 0;
  }
  if ( *(_DWORD *)(a1 + 64) == 1 && sub_100370A0() )
  {
    byte_10756F5E = 0;
    byte_10789160 = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 238) = 1;
  }
  v5 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 56) = v5;
  if ( v5 && *(_BYTE *)(v5 + 230) != -1 && !*(_BYTE *)(v5 + 238) )
  {
    sub_100375A0(a1, (char *)v5, (int)&unk_100B0984);
    *(_BYTE *)(a1 + 1) = 1;
  }
  *(_DWORD *)(a1 + 56) = v2;
  result = nullsub_1(a1, v2);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 10756F5E: using guessed type char byte_10756F5E;
// 10789160: using guessed type char byte_10789160;

//----- (100040B0) --------------------------------------------------------
void __usercall sub_100040B0(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  __int64 v3; // rax@8

  v2 = *(_DWORD *)(a1 + 52);
  if ( v2 != -1 )
  {
    if ( *(_BYTE *)(a1 + 24) & 3 )
    {
      if ( (*(_BYTE *)(a1 + 24) & 3) == 2 )
        sub_10069A00(v2, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), 0, 0, *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 34));
    }
    else if ( *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 26) && !sub_100026C0(a1) )
    {
      j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 52));
      v3 = *(_WORD *)(a1 + 32) + 255;
      sub_10069B70(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(a1 + 34), 57, 15, *(_DWORD *)(a1 + 48));
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 24));
      sub_10069A00(
        *(_DWORD *)(a1 + 52),
        *(_WORD *)(a1 + 28),
        *(_WORD *)(a1 + 30),
        0,
        0,
        *(_WORD *)(a1 + 32),
        *(_WORD *)(a1 + 34));
    }
  }
}
// 10069CB0: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);

//----- (10004180) --------------------------------------------------------
void __usercall sub_10004180(int a1@<esi>, int a2)
{
  __int16 v2; // ST1C_2@5
  __int16 v3; // ST14_2@5
  __int16 v4; // ST10_2@5
  int v5; // [sp+0h] [bp-Ch]@5
  __int16 v6; // [sp+4h] [bp-8h]@5
  __int16 v7; // [sp+6h] [bp-6h]@5
  char v8; // [sp+8h] [bp-4h]@5
  char v9; // [sp+9h] [bp-3h]@5
  __int16 v10; // [sp+Ah] [bp-2h]@5

  if ( !(*(_BYTE *)(a1 + 24) & 3) && *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 26) && !sub_100026C0(a1) )
  {
    v2 = *(_WORD *)(a1 + 34);
    v7 = *(_WORD *)(a1 + 32);
    v3 = *(_WORD *)(a1 + 30);
    v4 = *(_WORD *)(a1 + 28);
    v10 = (unsigned __int16)((v7 + 255) / 256) << 8;
    v5 = *(_DWORD *)(a1 + 48);
    v6 = v2;
    v8 = 8;
    v9 = 0;
    sub_1001D4A0(a2 + 392, (int)&v5, 0, 0, v4, v3, v7, v2);
  }
}

//----- (10004220) --------------------------------------------------------
int __usercall sub_10004220@<eax>(int a1@<edi>, int a2)
{
  int v2; // esi@1
  __int64 v3; // rax@8
  int result; // eax@11

  v2 = *(_DWORD *)(a1 + 48);
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)(v2 + 4) )
  {
    if ( !*(_DWORD *)(v2 + 4) )
      break;
    if ( sub_10002770(a1, v2) )
      break;
  }
  if ( *(_DWORD *)(a1 + 24) != -1 )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 24));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
    if ( v2 )
    {
      if ( (*(_BYTE *)(v2 + 24) & 3) == 1 )
      {
        j_gdi_pvg_make_window_current(*(_DWORD *)(v2 + 52));
        v3 = *(_WORD *)(a1 + 16) + 255;
        sub_10069B70(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(v2 + 34), 57, 15, *(_DWORD *)(v2 + 48));
        j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
        sub_10069A00(
          *(_DWORD *)(v2 + 52),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 32),
          *(_WORD *)(v2 + 34));
      }
      nullsub_1(a1, 1);
      do
      {
        sub_100040B0(v2, a1);
        v2 = *(_DWORD *)v2;
      }
      while ( v2 );
    }
    result = nullsub_1(a1, 0);
    goto LABEL_21;
  }
  if ( *(_BYTE *)(a1 + 11) )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 28));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 28));
  }
  if ( v2 && *(_BYTE *)(v2 + 26) )
    nullsub_1(a1, 1);
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)v2 )
    sub_10004180(v2, a1);
  result = nullsub_1(a1, 0);
  if ( *(_BYTE *)(a1 + 11) )
  {
    result = sub_10069B70(
               0,
               0,
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 10),
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 4),
               57,
               15,
               **(_DWORD **)(a1 + 444));
LABEL_21:
    if ( *(_BYTE *)(a1 + 11) )
      result = j_gdi_pvg_update_display_wdw();
  }
  *(_BYTE *)(a1 + 392) = 0;
  return result;
}
// 10069CA0: using guessed type int __cdecl j_gdi_pvg_make_window_active(_DWORD);
// 10069CB0: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 10069EE0: using guessed type int j_gdi_pvg_update_display_wdw(void);

//----- (100043F0) --------------------------------------------------------
char __thiscall sub_100043F0(int this)
{
  char result; // al@1

  result = 0;
  if ( !*(_BYTE *)(*(_DWORD *)(this + 56) + 26) && **(_WORD **)(this + 52) == -32696 )
  {
    result = 1;
    *(_BYTE *)(this + 6) = 2;
  }
  return result;
}

//----- (10004410) --------------------------------------------------------
signed int __cdecl sub_10004410(int a1, int a2)
{
  const void *v2; // edx@1
  int v3; // ebx@1
  char v4; // al@4
  char v6; // al@13
  char v7; // al@14
  int v8; // [sp-Ch] [bp-FCh]@15
  __int16 *v9; // [sp-8h] [bp-F8h]@15
  int v10; // [sp+Ch] [bp-E4h]@1
  __int16 v11; // [sp+18h] [bp-D8h]@7
  int v12; // [sp+1Ch] [bp-D4h]@12

  v2 = (const void *)a2;
  v3 = *(_DWORD *)(a2 + 4);
  v10 = 0;
  if ( !v3 )
  {
    if ( *(_WORD *)a2 > 0x8001u && *(_WORD *)a2 < 0x800Du )
    {
      v3 = *(_DWORD *)(a1 + 48);
      v4 = 1;
      goto LABEL_7;
    }
    v3 = 0;
  }
  v4 = 0;
LABEL_7:
  qmemcpy(&v11, (const void *)a2, 0xCCu);
  if ( !v4 )
  {
    sub_10003DE0(a1, (int)&v11, 204);
    return 1;
  }
  if ( v3 )
  {
    while ( 1 )
    {
      qmemcpy(&v11, v2, 0xCCu);
      v12 = v3;
      if ( v11 != -32760 )
        break;
      v6 = *(_BYTE *)(v3 + 243);
      if ( v6 )
      {
        v7 = v6 - 1;
        *(_BYTE *)(v3 + 243) = v7;
        if ( !v7 )
        {
          v11 = -32648;
          v9 = &v11;
          *(_BYTE *)(v3 + 243) = *(_BYTE *)(v3 + 244);
          v8 = a1;
LABEL_17:
          sub_10003DE0(v8, (int)v9, 204);
          ++v10;
          goto LABEL_18;
        }
      }
LABEL_18:
      if ( sub_10002770(a1, v3) )
        return v10;
      v3 = *(_DWORD *)(v3 + 4);
      if ( !v3 )
        return v10;
      v2 = (const void *)a2;
    }
    v9 = &v11;
    v8 = a1;
    goto LABEL_17;
  }
  return v10;
}

//----- (10004560) --------------------------------------------------------
char __cdecl sub_10004560(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_10003DE0(a1, (int)&v4, 8);
}

//----- (10004590) --------------------------------------------------------
char __cdecl sub_10004590(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_10003E50(a1, (int)&v4, 8);
}

//----- (100045C0) --------------------------------------------------------
void __cdecl sub_100045C0(int a1)
{
  int v1; // eax@1
  int v2; // ecx@2
  __int16 v3; // dx@2
  unsigned int v4; // ebx@3
  _DWORD *v5; // eax@3
  char v6; // dl@3
  __int16 v7; // ax@10
  unsigned __int16 v8; // cx@14
  int v9; // eax@31
  int v10; // eax@31
  int v11; // eax@41
  __int16 v12; // ax@48
  char v13; // al@52
  _WORD *v14; // edx@55
  int v15; // ebp@58

  v1 = *(_DWORD *)(a1 + 52);
  if ( *(_WORD *)v1 < 0x8000u )
  {
    v2 = *(_DWORD *)(v1 + 4);
    v3 = *(_WORD *)(v1 + 8);
    *(_WORD *)v1 = -32670;
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 12) = v2;
    *(_WORD *)(*(_DWORD *)(a1 + 52) + 8) = v3;
  }
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
  sub_100381B0((int *)&unk_1013F4B0, a1);
  v5 = *(_DWORD **)(a1 + 32);
  v6 = 0;
  if ( v5 )
  {
    while ( *(_DWORD **)(*(_DWORD *)(a1 + 52) + 4) != v5 )
    {
      v5 = (_DWORD *)*v5;
      if ( !v5 )
        goto LABEL_8;
    }
    v6 = 1;
  }
LABEL_8:
  if ( v4 )
  {
    if ( !v6 )
    {
      v7 = **(_WORD **)(a1 + 52);
      if ( v7 != -32703 )
      {
        if ( v7 == -32744 )
          return;
        v4 = 0;
        *(_DWORD *)(a1 + 56) = 0;
      }
    }
  }
  if ( !sub_100174F0(a1) )
  {
    v8 = **(_WORD **)(a1 + 52);
    switch ( **(_WORD **)(a1 + 52) )
    {
      case 0x8013:
      case 0x8014:
        sub_10003FD0(a1);
        goto LABEL_40;
      case 0x8018:
        if ( *(_DWORD *)(a1 + 24) != -1 && (!(*(_BYTE *)(v4 + 24) & 3) || (*(_BYTE *)(v4 + 24) & 3) == 2) )
          j_gdi_pvg_destroy_window(*(_DWORD *)(v4 + 52));
        if ( v4 != *(_DWORD *)(a1 + 32) && *(_DWORD *)(v4 + 4) )
        {
          *(_DWORD *)(a1 + 48) = *(_DWORD *)(v4 + 4);
          **(_DWORD **)(v4 + 4) = 0;
        }
        else
        {
          sub_10003D00(a1);
        }
        goto LABEL_40;
      case 0x8022:
      case 0x8078:
        if ( *(_BYTE *)(a1 + 4) || v4 && sub_100026C0(v4) )
          v4 = 0;
        if ( *(_DWORD *)(a1 + 64) == 1 && sub_100370A0() != byte_1013F4B4 )
        {
          **(_WORD **)(a1 + 52) = -32734;
          byte_1013F4B4 = sub_100370A0();
        }
        goto LABEL_40;
      case 0x8041:
        v9 = sub_10004F90(a1, 332);
        v4 = v9;
        qmemcpy((void *)v9, &unk_100852B0, 0x14Cu);
        *(_DWORD *)(v9 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
        v10 = *(_DWORD *)(a1 + 48);
        if ( v10 )
        {
          *(_DWORD *)(v4 + 4) = v10;
          **(_DWORD **)(a1 + 48) = v4;
          *(_BYTE *)(v4 + 243) = *(_BYTE *)(*(_DWORD *)(v4 + 4) + 243);
        }
        if ( !*(_DWORD *)(a1 + 32) )
          *(_DWORD *)(a1 + 32) = v4;
        --*(_BYTE *)(a1 + 4);
        *(_DWORD *)(a1 + 48) = v4;
        goto LABEL_40;
      default:
        if ( !v4 )
        {
          if ( v8 <= 0x800Eu || v8 >= 0xFFFFu )
            goto LABEL_66;
          v4 = *(_DWORD *)(a1 + 48);
LABEL_40:
          if ( !v4 )
            goto LABEL_66;
        }
        v11 = *(_DWORD *)(a1 + 52);
        *(_DWORD *)(a1 + 56) = v4;
        *(_BYTE *)(a1 + 6) = 1;
        *(_DWORD *)(v11 + 4) = v4;
        if ( **(_WORD **)(a1 + 52) == -32665 )
          *(_BYTE *)(*(_DWORD *)(a1 + 56) + 237) = 0;
        sub_10017210(a1);
        if ( *(_BYTE *)(a1 + 6) == 1 && !sub_100043F0(a1) )
          (*(void (__cdecl **)(int))(v4 + 8))(a1);
        if ( !v4 || v4 > *(_DWORD *)(a1 + 48) && (v12 = **(_WORD **)(a1 + 52), v12 != -32703) && v12 != -32744 )
        {
LABEL_66:
          v4 = 0;
          *(_DWORD *)(a1 + 56) = 0;
        }
        sub_10016F00(a1);
        if ( v4 )
        {
          v13 = *(_BYTE *)(a1 + 6);
          if ( v13 == 1 || v13 == 3 )
            sub_10016F70(a1);
          v14 = *(_WORD **)(a1 + 52);
          switch ( *v14 )
          {
            case 0x8018:
              sub_10004BF0(0, v4);
              if ( !*(_DWORD *)(a1 + 32) )
                *(_DWORD *)(a1 + 56) = 0;
              *(_BYTE *)(a1 + 1) = 1;
              break;
            case 0x8067:
              sub_10004560(a1, *(_DWORD *)(a1 + 56), -32734);
              break;
            case 0x8078:
              v15 = *(_DWORD *)(a1 + 56);
              if ( v15 )
                *(_BYTE *)(v15 + 26) = 1;
              break;
          }
        }
        break;
    }
  }
}
// 10069FC0: using guessed type int __cdecl j_gdi_pvg_destroy_window(_DWORD);
// 1013F4B4: using guessed type char byte_1013F4B4;

//----- (100048F0) --------------------------------------------------------
int __usercall sub_100048F0@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  int result; // eax@1
  __int16 v3; // ax@2
  bool v4; // al@4
  char v5; // [sp+4h] [bp-4h]@1

  v1 = a1;
  for ( result = sub_100696B0(*(_DWORD *)(a1 + 52), (int)&v5);
        result != 1;
        result = sub_100696B0(*(_DWORD *)(v1 + 52), (int)&v5) )
  {
    v3 = **(_WORD **)(v1 + 52);
    v4 = v3 == -32696 || v3 == -32734;
    *(_BYTE *)(v1 + 10) = v4;
    sub_100045C0(v1);
    if ( *(_BYTE *)(v1 + 6) != 1 && *(_BYTE *)(v1 + 10) && (*(_BYTE *)(v1 + 392) || *(_BYTE *)(v1 + 1)) )
    {
      sub_10004220(v1, (int)&off_100932DC);
      *(_BYTE *)(v1 + 10) = 0;
    }
  }
  return result;
}
// 100932DC: using guessed type void *off_100932DC;

//----- (10004980) --------------------------------------------------------
void __noreturn sub_10004980()
{
  void *v0; // ecx@8
  int v1; // ecx@14
  unsigned int v2; // esi@17
  int v3; // eax@20
  int v4; // [sp+10h] [bp-ECh]@1
  char v5; // [sp+14h] [bp-E8h]@9
  char v6; // [sp+18h] [bp-E4h]@5

  dword_1078915C = (int)&dword_10756F60;
  sub_10069910(&v4);
  if ( !(v4 & 0x10) )
    sub_100364C0(".\\cdp_main.c", 403, 1, 0);
  v4 |= 0x10u;
  if ( !sub_100698A0(1, 20000) )
    sub_100364C0(".\\cdp_main.c", 428, 1, 0);
  sub_10038B40();
  sub_10038720(&v6);
  sub_1006A5B0();
  while ( 1 )
  {
    byte_10789108 = 0;
    if ( v4 & 0x10 || v4 & 0x8000 )
    {
      sub_10003D00((int)&byte_10788F80);
      byte_10788F82 = sub_10036FA0(v0);
      byte_10788F84 = 0;
      dword_10788FB4 = (int)&unk_1013F4C0;
      word_10788F8E = 768;
      word_10788F90 = 1024;
      dword_10788FC0 = 15;
      word_10788F94 = 16;
      dword_10788F98 = -1;
      dword_10788F9C = -1;
      byte_10788F8B = 1;
      dword_10788FC8 = 0;
      byte_10788F80 = 0;
      while ( sub_100696B0(dword_10788FB4, (int)&v5) != 1 )
        ;
      sub_10003BE0();
      sub_10004F70((int)&byte_10788F80);
      sub_10017550((int)&byte_10788F80);
      sub_100376D0((int)&unk_10085288);
      sub_10038B30((int)&unk_10085290);
      sub_10003F70((int)&byte_10788F80);
      sub_100186B0((unsigned int)&byte_10788F80);
    }
    if ( v4 & 2 )
      sub_100048F0((int)&byte_10788F80);
    if ( v4 & 1 )
    {
      v4 |= 0x20000000u;
      if ( (unsigned int)(sub_10069700() - dword_1013F4B8) >= 0x3E8 )
      {
        dword_1013F4B8 += 1000;
        j_nullsub_1(&byte_10788F80);
        sub_10038610((int *)&v6);
      }
      sub_10018520(v1, 0, (unsigned int)&byte_10788F80);
    }
    v2 = 0x40000000;
    do
    {
      if ( v2 != 0x8000 && v2 & v4 )
      {
        v3 = sub_10037650(v2);
        sub_10004410((int)&byte_10788F80, v3);
        sub_100048F0((int)&byte_10788F80);
      }
      v2 >>= 1;
    }
    while ( v2 >= 0x200 );
    if ( byte_10789108 || byte_10788F81 )
      sub_10004220((int)&byte_10788F80, (int)&off_100932DC);
    sub_10069910(&v4);
  }
}
// 10003BE0: using guessed type int sub_10003BE0(void);
// 10038B20: using guessed type int __cdecl j_nullsub_1(_DWORD);
// 10038B40: using guessed type int sub_10038B40(void);
// 100932DC: using guessed type void *off_100932DC;
// 1013F4B8: using guessed type int dword_1013F4B8;
// 10756F60: using guessed type int dword_10756F60;
// 10788F80: using guessed type char byte_10788F80;
// 10788F81: using guessed type char byte_10788F81;
// 10788F82: using guessed type char byte_10788F82;
// 10788F84: using guessed type char byte_10788F84;
// 10788F8B: using guessed type char byte_10788F8B;
// 10788F8E: using guessed type __int16 word_10788F8E;
// 10788F90: using guessed type __int16 word_10788F90;
// 10788F94: using guessed type __int16 word_10788F94;
// 10788F98: using guessed type int dword_10788F98;
// 10788F9C: using guessed type int dword_10788F9C;
// 10788FB4: using guessed type int dword_10788FB4;
// 10788FC0: using guessed type int dword_10788FC0;
// 10788FC8: using guessed type int dword_10788FC8;
// 10789108: using guessed type char byte_10789108;
// 1078915C: using guessed type int dword_1078915C;

//----- (10004BD0) --------------------------------------------------------
int __cdecl sub_10004BD0(int a1, int a2)
{
  return a2 * ((a1 + 255) / 256) << 8;
}

//----- (10004BF0) --------------------------------------------------------
char __cdecl sub_10004BF0(int a1, unsigned int a2)
{
  char result; // al@4

  if ( !a2 || a2 < (unsigned int)&unk_10756F64 || a2 >= dword_10756F60 )
    result = sub_100364C0(".\\cdp_mem.c", 222, 1, 0);
  dword_10756F60 = a2;
  return result;
}
// 10756F60: using guessed type int dword_10756F60;

//----- (10004C30) --------------------------------------------------------
char sub_10004C30()
{
  char result; // al@1

  byte_1013F590 = 0;
  result = sub_1006B510((int)"/mnt/card0/enable_heap_mntr.txt");
  if ( result )
    byte_1013F590 = 1;
  return result;
}
// 1013F590: using guessed type char byte_1013F590;

//----- (10004C50) --------------------------------------------------------
char __thiscall sub_10004C50(int this)
{
  unsigned int v1; // eax@1
  unsigned int v2; // esi@2
  int v3; // ecx@5
  int v4; // eax@5
  char *v5; // edi@6
  char v7[4]; // [sp+4h] [bp-ACh]@1
  int v8; // [sp+8h] [bp-A8h]@1
  int v9; // [sp+Ch] [bp-A4h]@1
  int v10; // [sp+10h] [bp-A0h]@1
  int v11; // [sp+14h] [bp-9Ch]@1
  char v12; // [sp+18h] [bp-98h]@1
  char v13; // [sp+2Ch] [bp-84h]@1

  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  sub_10069720((int)&v12, 1, *(_DWORD *)(this + 64), 20);
  sub_10036790(&v13, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v12);
  LOBYTE(v1) = sub_1006B510((int)&v13);
  if ( (_BYTE)v1 )
  {
    v1 = j_FIL_vfs_open(&v13, 4, 0);
    v2 = v1;
    if ( v1 < 0xFFFFFFC2
      && v1
      && (sub_1006B2F0(v1, &byte_1013F598, 4096),
          sub_1006B1D0(v2),
          (v1 = (unsigned int)strstr(&byte_1013F598, "usage:")) != 0) )
    {
      v3 = v1 - (_DWORD)&byte_1013F598;
      v4 = v1 - (_DWORD)&byte_1013F598 + 7;
      if ( v4 < v3 + 27 )
      {
        v5 = &v7[-v4];
        do
        {
          if ( !((word_100B8FD0[2 * (unsigned __int8)*(&byte_1013F598 + v4)] >> 4) & 1) )
            break;
          v5[v4] = *(&byte_1013F598 + v4);
          ++v4;
        }
        while ( v4 < v3 + 27 );
      }
      v1 = j__atol(v7);
      dword_10140598 = v1;
    }
    else
    {
      dword_10140598 = 0;
    }
  }
  else
  {
    dword_10140598 = 0;
  }
  return v1;
}
// 1006B2E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10140598: using guessed type int dword_10140598;

//----- (10004DC0) --------------------------------------------------------
void *__usercall sub_10004DC0@<eax>(unsigned int a1@<ecx>, int a2@<ebx>)
{
  int v2; // edi@1
  unsigned int v3; // esi@1
  void *result; // eax@1
  int v5; // ecx@3
  unsigned int v6; // ebp@3
  _DWORD *i; // esi@5
  int v8; // esi@9
  int v9; // [sp+8h] [bp-198h]@1
  char v10; // [sp+Ch] [bp-194h]@3
  char v11; // [sp+20h] [bp-180h]@1
  char v12; // [sp+54h] [bp-14Ch]@4
  char v13; // [sp+11Ch] [bp-84h]@3

  v2 = 0;
  v3 = a1;
  result = memset(&v11, 0, 0x32u);
  v9 = 0;
  if ( a2 && dword_10140598 < v3 )
  {
    v5 = *(_DWORD *)(a2 + 64);
    dword_10140598 = v3;
    sub_10069720((int)&v10, 1, v5, 20);
    sub_10036790(&v13, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v10);
    v6 = j_FIL_vfs_open(&v13, 10, 0);
    sub_100365D0((int)&byte_1013F598, "HEAP STATISTICS:\r\n", 4096);
    if ( v3 > 0x32000 )
    {
      sub_100365D0((int)&v12, "\r\n!!!HEAP LIMIT EXCEEDED!!!\r\n", 200);
      sub_100367C0(&byte_1013F598, &v12, 4096);
    }
    sub_10036790(&v12, 0xC8u, "%s maximum heap usage: %d bytes out of %d bytes\r\n", &v10, v3, 204800);
    result = (void *)sub_100367C0(&byte_1013F598, &v12, 4096);
    for ( i = *(_DWORD **)(a2 + 32); i; ++v2 )
    {
      sub_100050D0((int)i, (__int16 *)&v9, &v11);
      sub_10036790(&v12, 0xC8u, "  Page[%d]: %s\r\n", v2, &v11);
      result = (void *)sub_100367C0(&byte_1013F598, &v12, 4096);
      i = (_DWORD *)*i;
    }
    if ( v6 < 0xFFFFFFC2 )
    {
      if ( v6 )
      {
        v8 = sub_10036690(&byte_1013F598, 0x1000u);
        j_FIL_vfs_write(v6, &byte_1013F598, v8);
        sub_1006B460(v6, v8, 0);
        result = (void *)sub_1006B1D0(v6);
      }
    }
  }
  return result;
}
// 1006B2E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1006B480: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 10140598: using guessed type int dword_10140598;

//----- (10004F70) --------------------------------------------------------
char __cdecl sub_10004F70(int a1)
{
  char result; // al@2

  dword_10756F60 = (int)&unk_10756F64;
  if ( byte_1013F590 )
    result = sub_10004C50(a1);
  return result;
}
// 1013F590: using guessed type char byte_1013F590;
// 10756F60: using guessed type int dword_10756F60;

//----- (10004F90) --------------------------------------------------------
int __cdecl sub_10004F90(int a1, int a2)
{
  unsigned int v2; // esi@1
  int result; // eax@4

  v2 = (unsigned int)(a2 + 3) >> 2;
  if ( byte_1013F590 )
    sub_10004DC0(dword_10756F60 + 4 * v2 - *(_DWORD *)(a1 + 476), a1);
  if ( !a2 || (result = dword_10756F60, dword_10756F60 + 4 * v2 > *(_DWORD *)(a1 + 476) + 204804) )
  {
    sub_100364C0(".\\cdp_mem.c", 371, 1, 0);
    result = dword_10756F60;
  }
  dword_10756F60 = result + 4 * v2;
  return result;
}
// 1013F590: using guessed type char byte_1013F590;
// 10756F60: using guessed type int dword_10756F60;

//----- (10005010) --------------------------------------------------------
int __cdecl sub_10005010(int a1, __int16 a2, __int16 a3)
{
  int v3; // eax@1

  v3 = sub_10004BD0(a2, a3);
  return sub_10004F90(a1, v3);
}

//----- (10005030) --------------------------------------------------------
char __cdecl sub_10005030(unsigned __int8 a1)
{
  return *(_BYTE *)(dword_10756F58 + 4 * (unsigned __int8)byte_101405A0[a1] + 1);
}
// 10756F58: using guessed type int dword_10756F58;

//----- (10005050) --------------------------------------------------------
__int16 __cdecl sub_10005050(unsigned __int8 a1)
{
  return *(_WORD *)(dword_10756F58 + 4 * (unsigned __int8)byte_101405A0[a1] + 2);
}
// 10756F58: using guessed type int dword_10756F58;

//----- (10005070) --------------------------------------------------------
char __cdecl sub_10005070(int (__cdecl *a1)(int))
{
  signed int v1; // esi@1

  v1 = sub_10038BA0(a1);
  if ( v1 == -1 )
    sub_100364C0(".\\cdp_page_list.c", 705, 1, 0);
  return byte_10093F14[56 * v1];
}

//----- (100050B0) --------------------------------------------------------
char __cdecl sub_100050B0(int (__cdecl *a1)(int))
{
  unsigned __int8 v1; // ST04_1@1

  v1 = sub_10005070(a1);
  return sub_10005030(v1);
}

//----- (100050D0) --------------------------------------------------------
char __cdecl sub_100050D0(int a1, __int16 *a2, _BYTE *a3)
{
  int v3; // esi@1
  _BYTE *v4; // ecx@1
  _BYTE *v5; // edx@1
  char *v6; // eax@2
  char v7; // cl@3

  v3 = 56 * sub_10038BA0(*(int (__cdecl **)(int))(a1 + 8));
  *a2 = sub_10005050(byte_10093F14[v3]);
  v4 = *(_BYTE **)(a1 + 252);
  v5 = a3;
  if ( v4 )
  {
    do
    {
      LOBYTE(v6) = *v4;
      *v5++ = *v4++;
    }
    while ( (_BYTE)v6 );
  }
  else
  {
    v6 = &aKeyTest[v3];
    do
    {
      v7 = *v6;
      v6[a3 - &aKeyTest[v3]] = *v6;
      ++v6;
    }
    while ( v7 );
  }
  return (unsigned int)v6;
}

//----- (10005150) --------------------------------------------------------
char __cdecl sub_10005150(int a1)
{
  int v1; // ecx@0
  signed int v2; // eax@1
  signed int v3; // esi@3
  char *v4; // edi@3
  int v5; // eax@4
  signed int v6; // eax@8
  char *v7; // esi@8
  int v8; // ecx@9
  signed int v9; // edi@13
  int (__cdecl **v10)(int); // ebp@13
  int v12; // [sp-2h] [bp-4h]@1

  v12 = v1;
  dword_10756F58 = (int)byte_10093F04;
  dword_101405A8 = 0;
  BYTE3(v12) = 0;
  byte_101405A2[0] = 1;
  v2 = 0;
  do
  {
    byte_101405A0[(unsigned __int8)byte_10093F04[4 * v2]] = v2;
    ++v2;
  }
  while ( v2 <= 1 );
  v3 = 0;
  v4 = byte_10093F14;
  memset(byte_101405B8, 1, 0xFu);
  do
  {
    LOBYTE(v5) = *v4;
    if ( (unsigned __int8)*v4 < 1u )
    {
      v5 = (unsigned __int8)v5;
      if ( !*((_BYTE *)&v12 + (unsigned __int8)v5 + 3) )
      {
        word_101405A4[v5] = v3;
        *((_BYTE *)&v12 + (unsigned __int8)v5 + 3) = 1;
      }
    }
    ++v3;
    v4 += 56;
  }
  while ( v3 < 15 );
  dword_101405AC[0] = (int)*(&off_10093F10 + 14 * (unsigned __int16)word_101405A4[0]);
  v6 = 14;
  BYTE3(v12) = 0;
  v7 = &byte_10093F14[784];
  do
  {
    LOBYTE(v8) = *v7;
    if ( (unsigned __int8)*v7 < 1u )
    {
      v8 = (unsigned __int8)v8;
      if ( !*((_BYTE *)&v12 + (unsigned __int8)v8 + 3) )
      {
        word_101405B0[v8] = v6;
        *((_BYTE *)&v12 + (unsigned __int8)v8 + 3) = 1;
      }
    }
    --v6;
    v7 -= 56;
  }
  while ( v6 >= 0 );
  sub_100186A0();
  sub_10005520(a1);
  sub_10017210(a1);
  v9 = 0;
  v10 = &off_10093F10;
  do
  {
    (*v10)(a1);
    ++v9;
    v10 += 14;
  }
  while ( v9 < 15 );
  sub_10016F00(a1);
  sub_10016F70(a1);
  return sub_10004BF0(0, *(_DWORD *)(a1 + 56));
}
// 10093F10: using guessed type int (__cdecl *off_10093F10)(int);
// 101405A4: using guessed type __int16 word_101405A4[];
// 101405A8: using guessed type int dword_101405A8;
// 101405AC: using guessed type int dword_101405AC[];
// 101405B0: using guessed type __int16 word_101405B0[];
// 10756F58: using guessed type int dword_10756F58;

//----- (100052B0) --------------------------------------------------------
char __thiscall sub_100052B0(void *this)
{
  char v1; // bl@1

  v1 = 1;
  if ( !dword_101405A8 && !sub_10036B10(this) )
    v1 = 0;
  dword_101405A8 = sub_10069700();
  return v1;
}
// 101405A8: using guessed type int dword_101405A8;

//----- (100052E0) --------------------------------------------------------
bool __cdecl sub_100052E0(unsigned int a1, char a2)
{
  unsigned int v2; // esi@4
  signed int v3; // eax@4
  char v4; // bl@4
  void *v5; // ecx@4
  void *v6; // ecx@5
  char v7; // cl@9
  int v8; // eax@9
  bool result; // al@17
  char v10; // [sp+1h] [bp-7h]@2
  char v11; // [sp+2h] [bp-6h]@2
  unsigned __int8 v12; // [sp+3h] [bp-5h]@4
  char v13; // [sp+Ch] [bp+4h]@4

  if ( a2 >= 0 )
  {
    v11 = 1;
    v10 = 1;
  }
  else
  {
    v11 = -1;
    v10 = -1;
  }
  v2 = a1;
  v3 = sub_10038BA0(*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 56) + 8));
  v4 = byte_10093F14[56 * v3];
  v12 = byte_10093F14[56 * v3];
  v13 = sub_10005030(v12);
  if ( v4 == 1 )
    goto LABEL_17;
  if ( !sub_100052B0(v5) && !(unsigned __int8)sub_10036B70(v6) )
  {
    *(_BYTE *)(v2 + 392) = 1;
    goto LABEL_17;
  }
  if ( a2 )
  {
    while ( 1 )
    {
      v7 = v10;
      v8 = (unsigned __int8)v4 + v10;
      if ( v8 < 0 || v8 >= 1 )
        goto LABEL_17;
      if ( !byte_101405A2[v8] )
        goto LABEL_15;
      if ( sub_10005030(v10 + v4) != v13 )
        break;
      v4 += v10;
      a2 -= v11;
      v10 = v11;
LABEL_16:
      if ( !a2 )
        goto LABEL_17;
    }
    v7 = v10;
LABEL_15:
    v10 = v11 + v7;
    goto LABEL_16;
  }
LABEL_17:
  result = v4 != v12;
  if ( v4 != v12 )
  {
    sub_100352A0(v2, -3, (int (__cdecl *)(int))dword_101405AC[(unsigned __int8)v4], 0);
    result = v4 != v12;
  }
  return result;
}
// 101405AC: using guessed type int dword_101405AC[];

//----- (100053F0) --------------------------------------------------------
bool __cdecl sub_100053F0(unsigned int a1, char a2)
{
  char v2; // bl@2
  void *v3; // ecx@4
  signed int v4; // edi@4
  signed int v5; // esi@4
  void *v6; // ecx@5
  char v8; // cl@9
  int i; // ebp@10
  int v10; // eax@12
  int (__cdecl *v11)(int); // eax@20
  char v12; // [sp+12h] [bp-Ah]@2
  char v13; // [sp+13h] [bp-9h]@4

  if ( a2 >= 0 )
  {
    v12 = 1;
    v2 = 1;
  }
  else
  {
    v2 = -1;
    v12 = -1;
  }
  v4 = sub_10038BA0(*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 56) + 8));
  v5 = v4;
  v13 = byte_10093F14[56 * v4];
  if ( v13 == 1 )
    return 0;
  if ( !sub_100052B0(v3) && !(unsigned __int8)sub_10036B70(v6) )
  {
    *(_BYTE *)(a1 + 392) = 1;
    return 0;
  }
  v8 = a2;
  if ( a2 )
  {
    for ( i = (unsigned __int8)v13; ; i = (unsigned __int8)v13 )
    {
      v10 = v2 + v5;
      if ( v10 < (unsigned __int16)word_101405A4[(unsigned __int8)v13]
        || v10 > (unsigned __int16)word_101405B0[i]
        || byte_10093F14[56 * v10] != v13 )
      {
        break;
      }
      if ( byte_101405B8[v10] )
      {
        v2 = v12;
        v5 = v10;
        v8 -= v12;
      }
      else
      {
        v2 += v12;
      }
      if ( !v8 )
        break;
    }
  }
  if ( v4 != v5 )
  {
    v11 = *(&off_10093F10 + 14 * v5);
    dword_101405AC[(unsigned __int8)v13] = (int)v11;
    sub_100352A0(a1, -3, v11, 0);
  }
  return v4 != v5;
}
// 10093F10: using guessed type int (__cdecl *off_10093F10)(int);
// 101405A4: using guessed type __int16 word_101405A4[];
// 101405AC: using guessed type int dword_101405AC[];
// 101405B0: using guessed type __int16 word_101405B0[];

//----- (10005520) --------------------------------------------------------
_WORD *__cdecl sub_10005520(int a1)
{
  void *v1; // eax@1

  v1 = (void *)sub_10004F90(a1, 332);
  *(_DWORD *)(a1 + 56) = v1;
  qmemcpy(v1, &unk_100852B0, 0x14Cu);
  sub_10003D50(a1, *(char **)(a1 + 56), 0, 0);
  **(_WORD **)(a1 + 52) = -32671;
  sub_1001E0A0(a1 + 392, (int)&off_100932DC, 0);
  *(_WORD *)(a1 + 428) = 0;
  *(_WORD *)(a1 + 430) = 0;
  return sub_1001E040(a1 + 392);
}
// 100932DC: using guessed type void *off_100932DC;

//----- (10005590) --------------------------------------------------------
void __usercall sub_10005590(_BYTE *a1@<edx>, unsigned int a2@<ecx>, unsigned int a3@<ebx>, _BYTE *a4)
{
  unsigned int v4; // edi@1
  _BYTE *v5; // esi@1
  unsigned int v6; // eax@1
  char v7; // cl@2
  size_t v8; // [sp+0h] [bp-48h]@0
  char v9; // [sp+Fh] [bp-39h]@7
  char v10[52]; // [sp+10h] [bp-38h]@1

  v4 = a2;
  v5 = a1;
  memset(a4, 0, v8);
  sub_100365D0((int)v10, v5, 50);
  v6 = 0;
  if ( !v4 )
    goto LABEL_14;
  do
  {
    v7 = v10[v6];
    if ( !v7 )
      break;
    if ( v7 == 32 )
      break;
    ++v6;
  }
  while ( v6 < v4 );
  if ( v6 )
  {
    v10[v6] = 0;
    if ( a3 < strlen(v10) )
      *(&v9 + a3) = 0;
    sub_100365D0((int)a4, v10, a3 + 1);
    if ( !memcmp(a4, &unk_10088C64, 3u) )
    {
      *(_DWORD *)a4 = 1280462679;
      *((_DWORD *)a4 + 1) = 1145657156;
      *((_WORD *)a4 + 4) = 69;
    }
    a4[a3 - 1] = 0;
    sub_100366C0(a4);
  }
  else
  {
LABEL_14:
    *(_DWORD *)a4 = 1096175177;
    *((_DWORD *)a4 + 1) = 4475212;
    a4[a3 - 1] = 0;
  }
}
// 10005590: using guessed type char var_38[52];

//----- (10005690) --------------------------------------------------------
int __cdecl sub_10005690(unsigned __int16 **a1, unsigned __int16 **a2)
{
  char *v2; // esi@1

  v2 = sub_10037280(**a2);
  return strcmp(sub_10037280(**a1), v2);
}

//----- (100056E0) --------------------------------------------------------
char __cdecl sub_100056E0(unsigned int a1, unsigned int a2)
{
  bool v2; // cf@2

  if ( BYTE1(a1) < BYTE1(a2) )
  {
    v2 = (unsigned __int8)a1 < (unsigned __int8)a2;
    if ( (_BYTE)a1 != (_BYTE)a2 )
      goto LABEL_5;
    if ( a1 >> 16 == a2 >> 16 )
      return 0;
  }
  v2 = (unsigned __int8)a1 < (unsigned __int8)a2;
LABEL_5:
  if ( v2 && a1 >> 16 == a2 >> 16 || a1 >> 16 < a2 >> 16 )
    return 0;
  return 1;
}

//----- (10005730) --------------------------------------------------------
char __cdecl sub_10005730(unsigned int a1, unsigned int a2)
{
  bool v2; // cf@2
  bool v3; // zf@2

  if ( BYTE1(a1) >= BYTE1(a2) )
  {
    v2 = (unsigned __int8)a1 < (unsigned __int8)a2;
    v3 = (_BYTE)a1 == (_BYTE)a2;
    if ( (_BYTE)a1 != (_BYTE)a2 )
      goto LABEL_5;
    if ( a1 >> 16 == a2 >> 16 )
      return 1;
  }
  v2 = (unsigned __int8)a1 < (unsigned __int8)a2;
  v3 = (_BYTE)a1 == (_BYTE)a2;
LABEL_5:
  if ( !v2 && !v3 && a1 >> 16 == a2 >> 16 || a1 >> 16 > a2 >> 16 )
    return 1;
  return 0;
}

//----- (10005780) --------------------------------------------------------
char __usercall sub_10005780@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>)
{
  int v3; // edx@1
  char *v4; // esi@2
  char result; // al@2

  v3 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 12);
  *(_DWORD *)(a1 + 4) = &unk_10087000;
  *(_DWORD *)(a1 + 8) = &unk_10087004;
  if ( a3 > 6 )
  {
    *(_DWORD *)(a1 + 16) = "NOT AVAILABLE";
    *(_DWORD *)(a1 + 20) = "NOT AVAILABLE";
    result = 0;
  }
  else
  {
    v4 = &aAirframe[50 * a3];
    *(_DWORD *)(a1 + 16) = v4;
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(v3 + 4 * a3 + 31676);
    result = (memcmp(v4, word_10088C68, 2u) == 0) + 1;
  }
  return result;
}

//----- (100057E0) --------------------------------------------------------
char __usercall sub_100057E0@<al>(int a1@<eax>, int a2@<edx>, int a3@<ebx>)
{
  int v3; // eax@1
  bool v4; // al@3
  _BYTE *v5; // ebp@5
  int v6; // esi@6
  bool v7; // cf@21
  int v8; // ecx@24
  char result; // al@24
  char v10; // [sp+Bh] [bp-Dh]@5
  int v11; // [sp+Ch] [bp-Ch]@1

  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v11 = v3;
  *(_DWORD *)(a2 + 4) = &unk_10087008;
  *(_DWORD *)(a2 + 8) = &unk_10087010;
  v4 = a3 >= 0 && a3 < *(_DWORD *)(v3 + 32688);
  v5 = (_BYTE *)(a2 + 36);
  *(_BYTE *)(a2 + 36) = 0;
  *(_BYTE *)(a2 + 37) = 1;
  *(_DWORD *)(a2 + 48) = 0;
  *(_DWORD *)(a2 + 44) = 0;
  *(_DWORD *)(a2 + 28) = &unk_10140658;
  *(_DWORD *)(a2 + 32) = &unk_1014068A;
  v10 = 0;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 28) = (char *)&unk_10140658 + 104 * a3;
    *(_DWORD *)(a2 + 32) = (char *)&unk_1014068A + 104 * a3;
    *v5 = 1;
    v6 = dword_101406BC[26 * a3];
    v10 = 2;
    if ( v6 == 82 )
    {
      *(_DWORD *)(a2 + 48) = &unk_1008660E;
      if ( *(_BYTE *)(v11 + 31674) )
      {
        *(_WORD *)(a2 + 40) = 0;
        *v5 = 1;
        *(_BYTE *)(a2 + 37) = 1;
        *(_WORD *)(a2 + 38) = -30;
        *(_DWORD *)(a2 + 44) = &unk_10087048;
        *(_WORD *)(a2 + 40) = -16;
      }
      else
      {
        *(_WORD *)(a2 + 38) = 0;
        *(_DWORD *)(a2 + 44) = &unk_1008703C;
        *(_WORD *)(a2 + 40) = -16;
      }
    }
    else if ( v6 )
    {
      *(_DWORD *)(a2 + 4) = &unk_1008700C;
      *(_DWORD *)(a2 + 8) = &unk_10087010;
      if ( dword_101406BC[26 * a3] == 71 )
      {
        if ( *(_BYTE *)(v11 + a3 + 32692) )
          *(_DWORD *)(a2 + 44) = &unk_10087030;
        else
          *(_DWORD *)(a2 + 44) = &unk_10087024;
      }
      else if ( !memcmp((char *)&unk_10140658 + 104 * a3, word_10088C68, 2u) )
      {
        if ( *(_BYTE *)(v11 + 31674) )
          *(_DWORD *)(a2 + 44) = &unk_1008706C;
        else
          *(_DWORD *)(a2 + 44) = &unk_10087060;
      }
      else if ( dword_101406BC[26 * a3] == 105 )
      {
        *(_DWORD *)(a2 + 44) = &unk_10087054;
      }
      *(_DWORD *)(a2 + 48) = *(_DWORD *)(v11 + 4 * a3 + 31704);
      v7 = *(_BYTE *)(v11 + 31674) != 0;
      *(_WORD *)(a2 + 40) = 0;
      *(_WORD *)(a2 + 38) = v7 ? 289 : 348;
    }
    if ( *((_BYTE *)&unk_10140658 + 104 * a3) != 32 )
      v10 = 1;
  }
  v8 = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a2 + 28);
  result = v10;
  *(_DWORD *)(a2 + 24) = v5;
  *(_DWORD *)(a2 + 20) = v8;
  return result;
}
// 101406BC: using guessed type int dword_101406BC[];

//----- (10005990) --------------------------------------------------------
char __usercall sub_10005990@<al>(int a1@<eax>, signed int a2@<edi>, int a3@<esi>)
{
  int v3; // ebp@1
  bool v4; // cl@3
  char result; // al@5
  char *v6; // eax@6

  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_DWORD *)(a3 + 4) = &unk_10087014;
  *(_DWORD *)(a3 + 8) = &unk_1008701C;
  v4 = a2 >= 0 && a2 < *(_WORD *)(v3 + 30704);
  result = 0;
  *(_WORD *)(a3 + 32) = 2;
  *(_DWORD *)(a3 + 20) = a3 + 32;
  if ( v4 )
  {
    v6 = sub_10037280(**(_WORD **)(v3 + 4 * a2 + 30716));
    strncpy((char *)(*(_DWORD *)(v3 + 4 * a2 + 30716) + 2), v6, 0xFu);
    *(_DWORD *)(a3 + 16) = *(_DWORD *)(v3 + 4 * a2 + 30716) + 2;
    *(_DWORD *)(a3 + 24) = *(_DWORD *)(v3 + 4 * a2 + 30716) + 27;
    *(_DWORD *)(a3 + 28) = *(_DWORD *)(v3 + 4 * a2 + 30716) + 19;
    result = 1;
    if ( *(_BYTE *)(*(_DWORD *)(v3 + 4 * a2 + 30716) + 18) )
      *(_WORD *)(a3 + 32) = 3;
  }
  else
  {
    *(_DWORD *)(a3 + 16) = 0;
    *(_DWORD *)(a3 + 24) = 0;
    *(_DWORD *)(a3 + 28) = 0;
  }
  return result;
}

//----- (10005A50) --------------------------------------------------------
int __usercall sub_10005A50@<eax>(char *a1@<ebx>, int a2, int a3, char a4, size_t a5)
{
  char v5; // dl@1
  signed int v6; // edi@1
  int result; // eax@2
  unsigned int v8; // eax@3
  unsigned int v9; // esi@9
  unsigned int v10; // edi@9
  unsigned int v11; // ecx@9
  unsigned __int64 v12; // rax@11
  const char *v13; // ecx@14
  int v14; // eax@14
  char *v15; // eax@19
  char v16; // [sp+Fh] [bp-11h]@1
  char v17[12]; // [sp+10h] [bp-10h]@1

  v5 = *(_BYTE *)(a2 + 12);
  v16 = *(_BYTE *)(a2 + 12);
  *a1 = 0;
  v17[0] = 0;
  v6 = 0;
  do
  {
    result = a3;
    if ( (1 << v6) & a3 )
    {
      v8 = strlen(v17);
      if ( v8 )
      {
        sub_100367C0(v17, ",", 10);
        v8 = strlen(v17);
      }
      result = sub_10036AA0(1 << v6, (int)&v17[v8], 10 - v8);
      v5 = v16;
    }
    ++v6;
  }
  while ( v6 < 32 );
  if ( v5 )
  {
    if ( v5 == 2 )
    {
      v9 = *(_WORD *)(a2 + 16) / 0x3Cu;
      v10 = *(_WORD *)(a2 + 16) % 0x3Cu;
      v11 = *(_DWORD *)(a2 + 24);
      if ( *(_DWORD *)(a2 + 24) <= 1u )
        v11 = 1;
      v12 = 100 * (unsigned __int64)*(_DWORD *)(a2 + 20) / v11;
      if ( a4 )
        result = sub_10036790(a1, a5, " - SYNC %u%% %u:%02u", (_DWORD)v12, v9, v10);
      else
        result = sub_10036790(a1, a5, "%u%% %u:%02u %s", (_DWORD)v12, v9, v10, v17);
    }
    else
    {
      v13 = "Unknown Err";
      v14 = 0;
      while ( v5 != byte_10088BA8[8 * v14] )
      {
        if ( (unsigned int)++v14 >= 6 )
          goto LABEL_19;
      }
      v13 = (const char *)off_10088BAC[2 * v14];
LABEL_19:
      v15 = "- SYNC";
      if ( !a4 )
        v15 = byte_10084570;
      result = sub_10036790(a1, a5, " %s %s %s", v15, v13, v17);
    }
  }
  return result;
}
// 10005A50: using guessed type char var_10[12];

//----- (10005BE0) --------------------------------------------------------
int __usercall sub_10005BE0@<eax>(const char *a1@<esi>, int a2)
{
  const char *v2; // eax@3
  char v4; // [sp+0h] [bp-38h]@2

  if ( *(_BYTE *)(a2 + 12) )
  {
    sub_10005A50(&v4, a2, 0, 1, 0x32u);
  }
  else
  {
    v2 = sub_1006B9A0(a2);
    sub_10036790(&v4, 0x32u, " - %s", v2);
  }
  return sub_100367C0(a1, &v4, 50);
}

//----- (10005C50) --------------------------------------------------------
int __usercall sub_10005C50@<eax>(_BYTE a1@<dl>, int a2, int a3)
{
  _DWORD v3; // eax@1

  v3 = 0;
  while ( byte_10088BD8[8 * v3] != a1 )
  {
    if ( ++v3 >= 0xFu )
      return sub_100365D0(a2, "NOT AVAILABLE", a3);
  }
  return sub_100365D0(a2, *(_BYTE **)&off_10088BDC[8 * v3], a3);
}
// 10005C50: too many cbuild loops

//----- (10005CA0) --------------------------------------------------------
char __cdecl sub_10005CA0(int a1, int a2, __int16 a3)
{
  return sub_10005990(a1, a3, a2);
}

//----- (10005CF0) --------------------------------------------------------
signed int __usercall sub_10005CF0@<eax>(int a1@<edi>)
{
  int v1; // esi@1
  char v2; // al@1
  signed int result; // eax@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = sub_10038CF0(0x39u);
  *(_DWORD *)(v1 + 31509) = 50529027;
  *(_BYTE *)(v1 + 31513) = 3;
  if ( !v2 )
    *(_BYTE *)(v1 + 31513) = 0;
  *(_WORD *)(v1 + 31520) = sub_100186E0(a1, 0x43u) != 0 ? 1994 : 2494;
  result = sub_100186E0(a1, 0x44u) != 0 ? 2001 : 2506;
  *(_WORD *)(v1 + 31522) = result;
  return result;
}

//----- (10005D60) --------------------------------------------------------
int __cdecl sub_10005D60(int a1)
{
  int v1; // ecx@0
  char v2; // al@1
  int v4; // [sp-2h] [bp-4h]@1

  v4 = v1;
  sub_1006A0A0(9110, (int)&v4 + 3, 1);
  v2 = sub_100186E0(a1, 0x43u);
  BYTE3(v4) = BYTE3(v4) & 0xFE | (v2 == 1);
  return sub_1006A190(9110, (int)&v4 + 3, 1);
}

//----- (10005DB0) --------------------------------------------------------
int __cdecl sub_10005DB0(int a1)
{
  int v1; // ebp@1
  char v2; // bl@1
  int v3; // ecx@1
  int v4; // esi@2
  int v5; // edi@2
  int *v6; // eax@2
  unsigned __int8 v7; // cl@3
  unsigned __int8 v8; // dl@5
  int *v9; // edi@11
  unsigned __int8 v10; // cl@16
  int v11; // esi@18
  int v12; // eax@18
  int v13; // edi@18
  unsigned int v14; // ebx@22
  unsigned int v15; // ST24_4@22
  _BYTE *v16; // edx@22
  char *v17; // eax@22
  int v18; // edi@22
  char v19; // cl@23
  unsigned int v20; // eax@24
  _BYTE *v21; // edi@24
  const char *v22; // esi@24
  int *v23; // eax@25
  int *v24; // ecx@26
  char *v25; // eax@27
  bool v26; // sf@30
  unsigned __int8 v27; // of@30
  int v28; // ecx@32
  char v29; // dl@32
  _BYTE *v30; // edx@33
  char *v31; // eax@33
  int v32; // esi@33
  char v33; // cl@34
  int v34; // edi@35
  int v35; // esi@35
  char *v36; // eax@38
  int v37; // ecx@42
  char v38; // dl@42
  const char *v39; // esi@43
  int v40; // edi@43
  unsigned __int8 v41; // al@44
  unsigned __int8 v42; // al@46
  unsigned __int8 v43; // al@50
  unsigned __int8 v44; // al@52
  char *v45; // eax@58
  int v46; // edx@62
  int v47; // eax@62
  char v48; // dl@62
  int v49; // esi@63
  char *v50; // eax@66
  int v51; // ecx@70
  char v52; // dl@70
  int v53; // esi@71
  char *v54; // eax@74
  int v55; // eax@78
  char v56; // dl@78
  int v57; // edi@79
  char *v58; // eax@89
  int v59; // edx@93
  int v60; // eax@93
  char v61; // dl@93
  int v62; // edi@94
  unsigned __int8 v63; // al@95
  unsigned __int8 v64; // al@97
  unsigned __int8 v65; // al@101
  unsigned __int8 v66; // al@103
  char *v67; // eax@108
  int v68; // edx@112
  char v69; // al@114
  unsigned int v70; // esi@123
  _WORD *v71; // edi@123
  char v72; // al@124
  unsigned int v73; // eax@125
  char *v74; // edi@125
  char v75; // cl@126
  int v76; // eax@134
  int v77; // eax@134
  int v78; // ecx@134
  signed int v79; // eax@134
  signed int v80; // ecx@134
  int v81; // ecx@141
  int v82; // eax@141
  int result; // eax@144
  signed int v84; // ecx@144
  char v85; // [sp+12h] [bp-D2h]@18
  char v86; // [sp+12h] [bp-D2h]@42
  char v87; // [sp+12h] [bp-D2h]@78
  char v88; // [sp+12h] [bp-D2h]@112
  bool v89; // [sp+13h] [bp-D1h]@18
  bool v90; // [sp+13h] [bp-D1h]@42
  bool v91; // [sp+13h] [bp-D1h]@78
  bool v92; // [sp+13h] [bp-D1h]@112
  int v93; // [sp+14h] [bp-D0h]@2
  const char *v94; // [sp+14h] [bp-D0h]@27
  const char *v95; // [sp+14h] [bp-D0h]@38
  const char *v96; // [sp+14h] [bp-D0h]@58
  const char *v97; // [sp+14h] [bp-D0h]@66
  const char *v98; // [sp+14h] [bp-D0h]@74
  const char *v99; // [sp+14h] [bp-D0h]@89
  const char *v100; // [sp+14h] [bp-D0h]@108
  const char *v101; // [sp+14h] [bp-D0h]@135
  int v102; // [sp+18h] [bp-CCh]@1
  int v103; // [sp+18h] [bp-CCh]@22
  char *v104; // [sp+18h] [bp-CCh]@27
  char *v105; // [sp+18h] [bp-CCh]@38
  char *v106; // [sp+18h] [bp-CCh]@58
  char *v107; // [sp+18h] [bp-CCh]@66
  char *v108; // [sp+18h] [bp-CCh]@74
  char *v109; // [sp+18h] [bp-CCh]@89
  char *v110; // [sp+18h] [bp-CCh]@108
  char *v111; // [sp+18h] [bp-CCh]@135
  signed int v112; // [sp+1Ch] [bp-C8h]@1
  const char *v113; // [sp+20h] [bp-C4h]@1
  int v114; // [sp+20h] [bp-C4h]@18
  int v115; // [sp+20h] [bp-C4h]@32
  int v116; // [sp+20h] [bp-C4h]@42
  int v117; // [sp+20h] [bp-C4h]@62
  int v118; // [sp+20h] [bp-C4h]@70
  int v119; // [sp+20h] [bp-C4h]@78
  int v120; // [sp+20h] [bp-C4h]@93
  int v121; // [sp+20h] [bp-C4h]@112
  signed int v122; // [sp+24h] [bp-C0h]@1
  unsigned __int8 i; // [sp+29h] [bp-BBh]@16
  char v124; // [sp+29h] [bp-BBh]@114
  char v125; // [sp+2Ah] [bp-BAh]@115
  bool v126; // [sp+2Bh] [bp-B9h]@112
  unsigned int v127; // [sp+2Ch] [bp-B8h]@1
  int *v128; // [sp+2Ch] [bp-B8h]@22
  int *v129; // [sp+2Ch] [bp-B8h]@135
  unsigned int v130; // [sp+30h] [bp-B4h]@1
  int *v131; // [sp+34h] [bp-B0h]@1
  char v132; // [sp+3Bh] [bp-A9h]@19
  char *v133; // [sp+3Ch] [bp-A8h]@2
  int v134; // [sp+40h] [bp-A4h]@134
  int v135; // [sp+44h] [bp-A0h]@134
  char v136; // [sp+48h] [bp-9Ch]@118
  char v137; // [sp+49h] [bp-9Bh]@118
  char v138; // [sp+68h] [bp-7Ch]@118
  char v139; // [sp+87h] [bp-5Dh]@123
  char v140; // [sp+A0h] [bp-44h]@125
  __int16 v141; // [sp+D2h] [bp-12h]@123
  unsigned int v142; // [sp+D4h] [bp-10h]@119
  unsigned int v143; // [sp+D8h] [bp-Ch]@123
  unsigned int v144; // [sp+DCh] [bp-8h]@123

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_DWORD *)(v1 + 32688) = 0;
  v130 = 0;
  sub_10039190((int)&v130);
  sub_100390E0((void *)(v1 + 880));
  *(_DWORD *)(v1 + 4 * *(_DWORD *)(v1 + 32688) + 31704) = 0;
  v2 = 1;
  ++*(_DWORD *)(v1 + 32688);
  qmemcpy(&unk_10140658, &unk_100871D8, 0x68u);
  v3 = 0;
  v112 = 1;
  v122 = 1;
  v102 = 0;
  v127 = 0;
  v131 = (int *)&unk_101406C0;
  v113 = "NAV STANDBY";
  do
  {
    v4 = (unsigned __int8)byte_10086BF8[v3];
    v5 = 0;
    v93 = 0;
    v6 = dword_10088B7C;
    v133 = (char *)(232 * v4 + v1 + 892);
    do
    {
      v7 = *v133;
      if ( !*v133 )
        goto LABEL_9;
      if ( !v5 )
        goto LABEL_148;
      v8 = *(_BYTE *)(v5 + 12);
      if ( v8 == v7 )
      {
        v93 |= *v6;
        goto LABEL_9;
      }
      if ( v8 <= v7 )
      {
LABEL_148:
        v93 = *v6;
        v5 = (int)(v133 - 12);
      }
LABEL_9:
      v133 += 3248;
      v6 += 4;
    }
    while ( (signed int)v6 < (signed int)&off_10088BEC );
    if ( v5 )
    {
      sub_10005A50((char *)(50 * v4 + v1 + 31956), v5, v93, 0, 0x32u);
      v9 = v131;
      ++v102;
      ++v112;
      ++v122;
      *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = 50 * (unsigned __int8)byte_10086BF8[v127] + v1 + 31956;
      qmemcpy(v9, v113, 0x68u);
      v131 += 26;
      v113 += 104;
      v2 = 1;
    }
    else
    {
      ++v122;
      v113 += 104;
    }
    v3 = v127++ + 1;
  }
  while ( v127 < 7 );
  if ( !v102 )
  {
    --v112;
    --*(_DWORD *)(v1 + 32688);
  }
  v10 = 0;
  for ( i = 0; ; v10 = i )
  {
    v11 = v10;
    v12 = 232 * (v10 + 14 * *(_BYTE *)(v1 + 23616));
    v13 = v12 + v1 + 1576;
    v85 = 0;
    v89 = 0;
    v114 = v12 + v1 + 1576;
    if ( v10 != v2 || (sub_1006A0A0(6464, (int)&v132, 1), v132) )
    {
      if ( *(_BYTE *)(v13 + 2) )
      {
        *(_BYTE *)(v11 + v1 + 332) = 0;
        *(_BYTE *)(v11 + v1 + 4 * v11 + 306) = 0;
        v103 = v11 + v1 + 4 * v11 + 306;
        sub_10005C50(*(_BYTE *)(v13 + 2), v1 + 14 * v11 + 334, 14);
        v21 = (_BYTE *)(v1 + 14 * v11 + 334);
        *(_DWORD *)(v1 + 4 * v11 + 316) = -1;
        v128 = (int *)(v1 + 4 * v11 + 316);
        v23 = (int *)(v1 + 4 * v11 + 324);
        v22 = (const char *)(v1 + 51 * (v11 + 4));
        *v23 = -1;
        v131 = v23;
        *v22 = 0;
      }
      else
      {
        *(_BYTE *)(v11 + v1 + 332) = v2;
        v14 = v130;
        v89 = sub_100056E0(v130, *(_DWORD *)(v13 + 188)) == 0;
        v85 = sub_10005730(v14, *(_DWORD *)(v13 + 192));
        v128 = (int *)(v1 + 4 * v11 + 316);
        sub_10038EF0(v128, *(_DWORD *)(v13 + 188));
        v15 = *(_DWORD *)(v13 + 192);
        v131 = (int *)(v1 + 4 * v11 + 324);
        sub_10038EF0(v131, v15);
        v103 = v11 + v1 + 4 * v11 + 306;
        sub_100365D0(v103, (_BYTE *)(v13 + 148), 5);
        v16 = (_BYTE *)(v13 + 64);
        v17 = (char *)(v13 + 64);
        v18 = v13 + 65;
        do
          v19 = *v17++;
        while ( v19 );
        v20 = (unsigned int)&v17[-v18];
        v21 = (_BYTE *)(v1 + 14 * v11 + 334);
        sub_10005590(v16, v20, 0xDu, v21);
        v22 = (const char *)(v1 + 51 * (v11 + 4));
        sub_100365D0((int)v22, (_BYTE *)(v114 + 92), 51);
        sub_100367C0(v22, word_10088C68, 51);
        sub_100367C0(v22, (_BYTE *)(v114 + 156), 51);
        v2 = 1;
      }
      *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = 0;
      *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v21;
      *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v103;
      *(_BYTE *)(*(_DWORD *)(v1 + 32688) + v1 + 32692) = v89;
      *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v128;
      v24 = v131;
      *(_BYTE *)(*(_DWORD *)(v1 + 32688) + v1 + 32692) = v85;
      *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v24;
      *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v22;
      if ( v112 < *(_DWORD *)(v1 + 32688) )
      {
        v94 = (char *)&unk_1014068A + 104 * v112;
        v104 = (char *)&unk_100871D8 + 104 * v122;
        v25 = (char *)&unk_1014068A + 104 * v112;
        do
        {
          qmemcpy(v25 - 50, v104, 0x68u);
          if ( *v25 )
          {
            sub_10005BE0(v94, v114);
            v25 = (char *)v94;
          }
          ++v122;
          v104 += 104;
          v25 += 104;
          v27 = __OFSUB__(v112 + 1, *(_DWORD *)(v1 + 32688));
          v26 = v112++ + 1 - *(_DWORD *)(v1 + 32688) < 0;
          v94 = v25;
        }
        while ( v26 ^ v27 );
      }
    }
    else
    {
      v122 += 6;
    }
    i += v2;
    if ( i >= 2u )
      break;
  }
  v28 = 3248 * *(_BYTE *)(v1 + 23616);
  v29 = *(_BYTE *)(v28 + v1 + 2042);
  v115 = v28 + v1 + 2040;
  if ( v29 )
  {
    v34 = v1 + 413;
    sub_10005C50(v29, v1 + 413, 14);
    v35 = v1 + 362;
    *(_BYTE *)(v1 + 427) = 0;
    *(_BYTE *)(v1 + 362) = 0;
  }
  else
  {
    v30 = (_BYTE *)(v28 + v1 + 2104);
    v31 = (char *)(v28 + v1 + 2104);
    v32 = v28 + v1 + 2105;
    do
      v33 = *v31++;
    while ( v33 );
    v34 = v1 + 413;
    sub_10005590(v30, (unsigned int)&v31[-v32], 0xDu, (_BYTE *)(v1 + 413));
    sub_100365D0(v1 + 427, (_BYTE *)(v115 + 44), 7);
    v35 = v1 + 362;
    sub_100365D0(v1 + 362, (_BYTE *)(v115 + 92), 51);
    sub_100367C0((const char *)(v1 + 362), (_BYTE *)(v115 + 156), 51);
    v2 = 1;
  }
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = 0;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v34;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 427;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v35;
  if ( v112 < *(_DWORD *)(v1 + 32688) )
  {
    v95 = (char *)&unk_1014068A + 104 * v112;
    v105 = (char *)&unk_100871D8 + 104 * v122;
    v36 = (char *)&unk_1014068A + 104 * v112;
    do
    {
      qmemcpy(v36 - 50, v105, 0x68u);
      if ( *v36 )
      {
        sub_10005BE0(v95, v115);
        v36 = (char *)v95;
      }
      ++v122;
      v105 += 104;
      v36 += 104;
      v27 = __OFSUB__(v112 + 1, *(_DWORD *)(v1 + 32688));
      v26 = v112++ + 1 - *(_DWORD *)(v1 + 32688) < 0;
      v95 = v36;
    }
    while ( v26 ^ v27 );
  }
  v37 = 3248 * *(_BYTE *)(v1 + 23616);
  v38 = *(_BYTE *)(v37 + v1 + 2970);
  v86 = 0;
  v90 = 0;
  v116 = v37 + v1 + 2968;
  if ( v38 )
  {
    sub_10005C50(v38, v1 + 491, 14);
    v40 = v1 + 512;
    *(_BYTE *)(v1 + 505) = 0;
    *(_BYTE *)(v1 + 485) = 0;
    *(_DWORD *)(v1 + 512) = -1;
    *(_DWORD *)(v1 + 516) = -1;
    *(_BYTE *)(v1 + 434) = 0;
  }
  else
  {
    v39 = (const char *)(v37 + v1 + 3032);
    sub_1002E4C0(v39, v1 + 485);
    sub_10005590(v39, strlen(v39), 0xDu, (_BYTE *)(v1 + 491));
    sub_100365D0(v1 + 505, (_BYTE *)(v116 + 44), 7);
    v40 = v1 + 512;
    *(_DWORD *)(v1 + 512) = -1;
    if ( *(_WORD *)(v116 + 190) > 0x7CFu )
    {
      v41 = *(_BYTE *)(v116 + 188);
      if ( v41 )
      {
        if ( v41 <= 0xCu )
        {
          v42 = *(_BYTE *)(v116 + 189);
          if ( v42 )
          {
            if ( v42 <= 0x1Fu )
            {
              sub_10038EF0((int *)(v1 + 512), *(_DWORD *)(v116 + 188));
              v90 = sub_100056E0(v130, *(_DWORD *)(v116 + 188)) == 0;
            }
          }
        }
      }
    }
    *(_DWORD *)(v1 + 516) = -1;
    if ( *(_WORD *)(v116 + 194) > 0x7CFu )
    {
      v43 = *(_BYTE *)(v116 + 192);
      if ( v43 )
      {
        if ( v43 <= 0xCu )
        {
          v44 = *(_BYTE *)(v116 + 193);
          if ( v44 )
          {
            if ( v44 <= 0x1Fu )
            {
              sub_10038EF0((int *)(v1 + 516), *(_DWORD *)(v116 + 192));
              v86 = sub_10005730(v130, *(_DWORD *)(v116 + 192));
            }
          }
        }
      }
    }
    sub_100365D0(v1 + 434, (_BYTE *)(v116 + 92), 51);
    sub_100367C0((const char *)(v1 + 434), (_BYTE *)(v116 + 156), 51);
    v2 = 1;
  }
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = 0;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 491;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 505;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 485;
  *(_BYTE *)(*(_DWORD *)(v1 + 32688) + v1 + 32692) = v90;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v40;
  *(_BYTE *)(*(_DWORD *)(v1 + 32688) + v1 + 32692) = v86;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 516;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 434;
  if ( v112 < *(_DWORD *)(v1 + 32688) )
  {
    v96 = (char *)&unk_1014068A + 104 * v112;
    v106 = (char *)&unk_100871D8 + 104 * v122;
    v45 = (char *)&unk_1014068A + 104 * v112;
    do
    {
      qmemcpy(v45 - 50, v106, 0x68u);
      if ( *v45 )
      {
        sub_10005BE0(v96, v116);
        v45 = (char *)v96;
      }
      ++v122;
      v106 += 104;
      v45 += 104;
      v27 = __OFSUB__(v112 + 1, *(_DWORD *)(v1 + 32688));
      v26 = v112++ + 1 - *(_DWORD *)(v1 + 32688) < 0;
      v96 = v45;
    }
    while ( v26 ^ v27 );
  }
  v46 = 3248 * *(_BYTE *)(v1 + 23616);
  v47 = v46 + v1 + 2272;
  v48 = *(_BYTE *)(v46 + v1 + 2274);
  v117 = v47;
  if ( v48 )
  {
    sub_10005C50(v48, v1 + 31653, 14);
    v49 = v1 + 31596;
    *(_BYTE *)(v1 + 31647) = 0;
    *(_BYTE *)(v1 + 31667) = 0;
    *(_BYTE *)(v1 + 31596) = 0;
  }
  else
  {
    sub_10005590((_BYTE *)(v47 + 64), 0x21u, 0xDu, (_BYTE *)(v1 + 31653));
    sub_100365D0(v1 + 31647, (_BYTE *)(v117 + 148), 6);
    sub_100365D0(v1 + 31667, (_BYTE *)(v117 + 44), 7);
    v49 = v1 + 31596;
    sub_100365D0(v1 + 31596, (_BYTE *)(v117 + 92), 51);
    sub_100367C0((const char *)(v1 + 31596), word_10088C68, 51);
    sub_100367C0((const char *)(v1 + 31596), (_BYTE *)(v117 + 156), 51);
    v2 = 1;
  }
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = 0;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 31653;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 31667;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 31647;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v49;
  if ( v112 < *(_DWORD *)(v1 + 32688) )
  {
    v97 = (char *)&unk_1014068A + 104 * v112;
    v107 = (char *)&unk_100871D8 + 104 * v122;
    v50 = (char *)&unk_1014068A + 104 * v112;
    do
    {
      qmemcpy(v50 - 50, v107, 0x68u);
      if ( *v50 )
      {
        sub_10005BE0(v97, v117);
        v50 = (char *)v97;
      }
      ++v122;
      v107 += 104;
      v50 += 104;
      v27 = __OFSUB__(v112 + 1, *(_DWORD *)(v1 + 32688));
      v26 = v112++ + 1 - *(_DWORD *)(v1 + 32688) < 0;
      v97 = v50;
    }
    while ( v26 ^ v27 );
  }
  v51 = 3248 * *(_BYTE *)(v1 + 23616);
  v52 = *(_BYTE *)(v51 + v1 + 2738);
  v118 = v51 + v1 + 2736;
  if ( v52 )
  {
    sub_10005C50(v52, v1 + 97, 14);
    v53 = v1 + 40;
    *(_BYTE *)(v1 + 91) = 0;
    *(_BYTE *)(v1 + 111) = 0;
    *(_BYTE *)(v1 + 40) = 0;
  }
  else
  {
    sub_10005590((_BYTE *)(v51 + v1 + 2800), 0x21u, 0xDu, (_BYTE *)(v1 + 97));
    sub_100365D0(v1 + 91, (_BYTE *)(v118 + 148), 6);
    sub_100365D0(v1 + 111, (_BYTE *)(v118 + 44), 7);
    v53 = v1 + 40;
    sub_100365D0(v1 + 40, (_BYTE *)(v118 + 92), 51);
    sub_100367C0((const char *)(v1 + 40), word_10088C68, 51);
    sub_100367C0((const char *)(v1 + 40), (_BYTE *)(v118 + 156), 51);
    v2 = 1;
  }
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = 0;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 97;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 111;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 91;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v53;
  if ( v112 < *(_DWORD *)(v1 + 32688) )
  {
    v98 = (char *)&unk_1014068A + 104 * v112;
    v108 = (char *)&unk_100871D8 + 104 * v122;
    v54 = (char *)&unk_1014068A + 104 * v112;
    do
    {
      qmemcpy(v54 - 50, v108, 0x68u);
      if ( *v54 )
      {
        sub_10005BE0(v98, v118);
        v54 = (char *)v98;
      }
      ++v122;
      v108 += 104;
      v54 += 104;
      v27 = __OFSUB__(v112 + 1, *(_DWORD *)(v1 + 32688));
      v26 = v112++ + 1 - *(_DWORD *)(v1 + 32688) < 0;
      v98 = v54;
    }
    while ( v26 ^ v27 );
  }
  v55 = 3248 * *(_BYTE *)(v1 + 23616);
  v56 = *(_BYTE *)(v55 + v1 + 2506);
  v119 = v55 + v1 + 2504;
  v87 = 0;
  v91 = 0;
  if ( v56 )
  {
    sub_10005C50(v56, v1 + 31488, 14);
    v57 = v1 + 31420;
    *(_BYTE *)(v1 + 31471) = 0;
    *(_BYTE *)(v1 + 31502) = 0;
    *(_DWORD *)(v1 + 31480) = -1;
    *(_DWORD *)(v1 + 31484) = -1;
    *(_BYTE *)(v1 + 31420) = 0;
  }
  else
  {
    sub_10005590((_BYTE *)(v55 + v1 + 2568), 0x21u, 0xDu, (_BYTE *)(v1 + 31488));
    sub_100365D0(v1 + 31471, (_BYTE *)(v119 + 148), 6);
    sub_100365D0(v1 + 31502, (_BYTE *)(v119 + 44), 7);
    v57 = v1 + 31420;
    sub_100365D0(v1 + 31420, (_BYTE *)(v119 + 92), 51);
    sub_100367C0((const char *)(v1 + 31420), word_10088C68, 51);
    sub_100367C0((const char *)(v1 + 31420), (_BYTE *)(v119 + 156), 51);
    *(_DWORD *)(v1 + 31480) = -1;
    if ( *(_WORD *)(v119 + 190) && *(_BYTE *)(v119 + 188) && *(_BYTE *)(v119 + 189) )
    {
      v91 = sub_100056E0(v130, *(_DWORD *)(v119 + 188)) == 0;
      sub_10038EF0((int *)(v1 + 31480), *(_DWORD *)(v119 + 188));
    }
    *(_DWORD *)(v1 + 31484) = -1;
    if ( *(_WORD *)(v119 + 194) && *(_BYTE *)(v119 + 192) && *(_BYTE *)(v119 + 193) )
    {
      v87 = sub_10005730(v130, *(_DWORD *)(v119 + 192));
      sub_10038EF0((int *)(v1 + 31484), *(_DWORD *)(v119 + 192));
    }
    v2 = 1;
  }
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = 0;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 31488;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 31502;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 31471;
  *(_BYTE *)(*(_DWORD *)(v1 + 32688) + v1 + 32692) = v91;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 31480;
  *(_BYTE *)(*(_DWORD *)(v1 + 32688) + v1 + 32692) = v87;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 31484;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v57;
  if ( v112 < *(_DWORD *)(v1 + 32688) )
  {
    v99 = (char *)&unk_1014068A + 104 * v112;
    v109 = (char *)&unk_100871D8 + 104 * v122;
    v58 = (char *)&unk_1014068A + 104 * v112;
    do
    {
      qmemcpy(v58 - 50, v109, 0x68u);
      if ( *v58 )
      {
        sub_10005BE0(v99, v119);
        v58 = (char *)v99;
      }
      ++v122;
      v109 += 104;
      v58 += 104;
      v27 = __OFSUB__(v112 + 1, *(_DWORD *)(v1 + 32688));
      v26 = v112++ + 1 - *(_DWORD *)(v1 + 32688) < 0;
      v99 = v58;
    }
    while ( v26 ^ v27 );
  }
  v59 = 3248 * *(_BYTE *)(v1 + 23616);
  v60 = v59 + v1 + 3432;
  v61 = *(_BYTE *)(v59 + v1 + 3434);
  v120 = v60;
  if ( v61 )
  {
    sub_10005C50(v61, v1 + 175, 14);
    v62 = v1 + 118;
    *(_BYTE *)(v1 + 169) = 0;
    *(_BYTE *)(v1 + 189) = 0;
    *(_DWORD *)(v1 + 196) = -1;
    *(_DWORD *)(v1 + 200) = -1;
    *(_BYTE *)(v1 + 118) = 0;
  }
  else
  {
    sub_10005590((_BYTE *)(v60 + 64), 0x21u, 0xDu, (_BYTE *)(v1 + 175));
    sub_100365D0(v1 + 169, (_BYTE *)(v120 + 148), 6);
    sub_100365D0(v1 + 189, (_BYTE *)(v120 + 44), 7);
    v62 = v1 + 118;
    sub_100365D0(v1 + 118, (_BYTE *)(v120 + 92), 51);
    sub_100367C0((const char *)(v1 + 118), word_10088C68, 51);
    sub_100367C0((const char *)(v1 + 118), (_BYTE *)(v120 + 156), 51);
    *(_DWORD *)(v1 + 196) = -1;
    if ( *(_WORD *)(v120 + 190) > 0x7CFu )
    {
      v63 = *(_BYTE *)(v120 + 188);
      if ( v63 )
      {
        if ( v63 <= 0xCu )
        {
          v64 = *(_BYTE *)(v120 + 189);
          if ( v64 )
          {
            if ( v64 <= 0x1Fu )
            {
              v91 = sub_100056E0(v130, *(_DWORD *)(v120 + 188)) == 0;
              sub_10038EF0((int *)(v1 + 196), *(_DWORD *)(v120 + 188));
            }
          }
        }
      }
    }
    *(_DWORD *)(v1 + 200) = -1;
    if ( *(_WORD *)(v120 + 194) > 0x7CFu )
    {
      v65 = *(_BYTE *)(v120 + 192);
      if ( v65 )
      {
        if ( v65 <= 0xCu )
        {
          v66 = *(_BYTE *)(v120 + 193);
          if ( v66 )
          {
            if ( v66 <= 0x1Fu )
            {
              v87 = sub_10005730(v130, *(_DWORD *)(v120 + 192));
              sub_10038EF0((int *)(v1 + 200), *(_DWORD *)(v120 + 192));
            }
          }
        }
      }
    }
    v2 = 1;
  }
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = 0;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 175;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 189;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 169;
  *(_BYTE *)(*(_DWORD *)(v1 + 32688) + v1 + 32692) = v91;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 196;
  *(_BYTE *)(*(_DWORD *)(v1 + 32688) + v1 + 32692) = v87;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 200;
  *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v62;
  if ( v112 < *(_DWORD *)(v1 + 32688) )
  {
    v100 = (char *)&unk_1014068A + 104 * v112;
    v110 = (char *)&unk_100871D8 + 104 * v122;
    v67 = (char *)&unk_1014068A + 104 * v112;
    do
    {
      qmemcpy(v67 - 50, v110, 0x68u);
      if ( *v67 )
      {
        sub_10005BE0(v100, v120);
        v67 = (char *)v100;
      }
      ++v122;
      v110 += 104;
      v67 += 104;
      v27 = __OFSUB__(v112 + 1, *(_DWORD *)(v1 + 32688));
      v26 = v112++ + 1 - *(_DWORD *)(v1 + 32688) < 0;
      v100 = v67;
    }
    while ( v26 ^ v27 );
  }
  v68 = 3248 * *(_BYTE *)(v1 + 23616);
  v88 = 0;
  v92 = 0;
  v126 = 0;
  v121 = v68 + v1 + 3200;
  if ( byte_10088B78[16 * *(_BYTE *)(v1 + 23616)] == 3 )
  {
    if ( (unsigned __int8)sub_1002E120((void *)(v68 + v1 + 3200)) )
    {
      v69 = sub_1002E160();
      v124 = v69;
      if ( v69 != 13 )
      {
        *(_DWORD *)(v1 + 752) = -1;
        *(_DWORD *)(v1 + 756) = -1;
        *(_DWORD *)(v1 + 748) = -1;
        v125 = 0;
        if ( v69 != 9 && v69 != 10 )
        {
          if ( v69 != 8 )
          {
            *(_BYTE *)(v1 + 760) = v2;
            sub_1002E240(&v136);
            sub_100365D0(v1 + 683, &v137, 31);
            sub_100365D0(v1 + 714, &v138, 31);
            if ( v136 == v2 )
            {
              v125 = v2;
            }
            else
            {
              v92 = sub_100056E0(v130, v142) == 0;
              sub_10038EF0((int *)(v1 + 752), v142);
            }
            v70 = v143;
            v88 = sub_10005730(v130, v143);
            v126 = v124 == 7;
            sub_10038EF0((int *)(v1 + 756), v70);
            sub_10038EF0((int *)(v1 + 748), v144);
            sub_10036790((char *)(v1 + 658), 0x19u, "%0*i", 4, v141);
            strcpy((char *)(v1 + 607), &v139);
            v71 = (_WORD *)(v1 + 606);
            do
            {
              v72 = *((_BYTE *)v71 + 1);
              v71 = (_WORD *)((char *)v71 + 1);
            }
            while ( v72 );
            *v71 = 32;
            v73 = strlen(&v140) + 1;
            v74 = (char *)(v1 + 606);
            do
              v75 = (v74++)[1];
            while ( v75 );
            qmemcpy(v74, &v140, v73);
            goto LABEL_134;
          }
LABEL_133:
          *(_BYTE *)(v1 + 760) = 0;
          sub_100365D0(v1 + 683, "Verifying Database", 31);
          sub_100365D0(v1 + 714, "Verifying Database", 31);
          sub_100365D0(v1 + 658, "Verifying Database", 25);
          sub_100365D0(v1 + 607, byte_10084570, 51);
          goto LABEL_134;
        }
        if ( v69 == 8 )
          goto LABEL_133;
        *(_BYTE *)(v1 + 760) = 0;
        sub_1002E240(&v136);
        if ( v136 == v2 )
          sub_100365D0(v1 + 683, "Jeppesen ChartView", 31);
        else
          sub_100365D0(v1 + 683, "FliteCharts", 31);
        sub_100365D0(v1 + 714, "NOT AVAILABLE", 31);
        sub_100365D0(v1 + 658, "NOT AVAILABLE", 25);
        sub_100365D0(v1 + 607, byte_10084570, 51);
LABEL_134:
        *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = 0;
        *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 683;
        v76 = *(_DWORD *)(v1 + 32688);
        v134 = v76;
        *(_DWORD *)(v1 + 4 * v76 + 31704) = v1 + 714;
        *(_DWORD *)(v1 + 4 * ++*(_DWORD *)(v1 + 32688) + 31704) = v1 + 658;
        v77 = ++*(_DWORD *)(v1 + 32688);
        *(_BYTE *)(v77 + v1 + 32692) = v92;
        v78 = *(_DWORD *)(v1 + 32688);
        v135 = v77;
        *(_DWORD *)(v1 + 4 * v78 + 31704) = v1 + 752;
        *(_BYTE *)(++*(_DWORD *)(v1 + 32688) + v1 + 32692) = v88;
        *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 756;
        *(_BYTE *)(*(_DWORD *)(v1 + 32688) + v1 + 32692) = v126;
        *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 748;
        *(_DWORD *)(v1 + 4 * (*(_DWORD *)(v1 + 32688))++ + 31704) = v1 + 607;
        v79 = v112;
        v80 = *(_DWORD *)(v1 + 32688);
        v131 = (int *)v112;
        if ( v112 < v80 )
        {
          v101 = (char *)&unk_1014068A + 104 * v112;
          v111 = (char *)&unk_100871D8 + 104 * v122;
          v133 = (char *)(v1 + 4 * v112 + 31704);
          v129 = (int *)(v1 + 4 * v112 + 31704);
          do
          {
            if ( !v125 || v134 != v79 && v135 != v79 )
            {
              qmemcpy((void *)(v101 - 50), v111, 0x68u);
              if ( *v101 )
                sub_10005BE0(v101, v121);
              v81 = *v129;
              v82 = (int)v133;
              v131 = (int *)((char *)v131 + 1);
              *(_DWORD *)v133 = v81;
              v101 += 104;
              v133 = (char *)(v82 + 4);
              v79 = v112;
            }
            v111 += 104;
            ++v129;
            v112 = ++v79;
          }
          while ( v79 < *(_DWORD *)(v1 + 32688) );
        }
        *(_DWORD *)(v1 + 32688) = v131;
      }
    }
  }
  result = *(_WORD *)(v1 + 32688);
  v84 = *(_WORD *)(v1 + 810);
  *(_WORD *)(v1 + 816) = result;
  if ( v84 >= (unsigned __int16)result )
  {
    result -= 2;
    *(_WORD *)(v1 + 810) = result;
  }
  return result;
}
// 10088B7C: using guessed type int dword_10088B7C[];
// 10088BEC: using guessed type char *off_10088BEC;

//----- (10007470) --------------------------------------------------------
unsigned int __cdecl sub_10007470(int a1)
{
  int v1; // esi@1
  unsigned __int8 v2; // bl@1
  signed int v3; // edx@1
  void *v4; // ebp@3
  int v5; // esi@3
  void *v6; // ecx@4
  char v7; // al@5
  __int16 v8; // di@16
  char v9; // al@16
  signed int v10; // edx@16
  signed int v11; // edi@25
  signed int v12; // esi@26
  int *v13; // ecx@26
  char v14; // bl@27
  signed int i; // edx@27
  int v16; // ebp@35
  int v17; // esi@35
  unsigned __int16 v18; // dx@35
  int *v19; // ecx@35
  int v20; // eax@35
  signed int v21; // edi@35
  unsigned int result; // eax@39
  bool v23; // [sp+12h] [bp-766h]@13
  unsigned __int8 v24; // [sp+12h] [bp-766h]@25
  char v25; // [sp+13h] [bp-765h]@7
  __int16 *v26; // [sp+14h] [bp-764h]@26
  int v27; // [sp+18h] [bp-760h]@26
  int v28; // [sp+1Ch] [bp-75Ch]@1
  char v29[4]; // [sp+20h] [bp-758h]@2
  int v30[351]; // [sp+24h] [bp-754h]@2
  char v31; // [sp+5A0h] [bp-1D8h]@13
  char v32; // [sp+600h] [bp-178h]@15
  __int16 v33[176]; // [sp+614h] [bp-164h]@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = 0;
  v3 = 0;
  v28 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  memset(v33, 0xFFu, sizeof(v33));
  do
  {
    v29[8 * v3] = 0;
    v30[2 * v3++] = -1;
  }
  while ( v3 < 176 );
  v4 = 0;
  v5 = v1 + 23674;
  do
  {
    if ( sub_1002E660((unsigned __int8)v4) || (v7 = sub_10038600(v6), v4 == (void *)(unsigned __int8)sub_10038390(v7)) )
    {
      if ( sub_10039680((unsigned __int8)v4) )
      {
        *(_BYTE *)v5 = sub_1002E560(v4, &v25) && v25 == 2;
        if ( !sub_1002E5E0((int)v4, v5 + 1) )
        {
          *(_DWORD *)(v5 + 1) = 757935405;
          *(_WORD *)(v5 + 5) = 45;
        }
        v23 = sub_10039400((int)v4, &v31);
        if ( v23 )
        {
          strncpy((char *)(v5 + 9), &v32, 0xCu);
          *(_BYTE *)(v5 + 19) = 0;
          sub_10036800(v5 + 9, 11);
        }
        else
        {
          *(_DWORD *)(v5 + 9) = 757935405;
          *(_DWORD *)(v5 + 13) = 757935405;
          *(_WORD *)(v5 + 17) = 11565;
          *(_BYTE *)(v5 + 19) = 0;
        }
        v8 = sub_100352C0((char)v4);
        v9 = 0;
        v10 = 0;
        for ( *(_WORD *)(v5 - 18) = v8; v10 < v2; ++v10 )
        {
          if ( v9 )
            break;
          v9 = 1;
          if ( v33[v10] != v8 || !v29[8 * v10] )
            v9 = 0;
        }
        *(_BYTE *)(v5 - 1) = 0;
        if ( !v9 )
        {
          *(_BYTE *)(v5 - 1) = 1;
          v33[v2] = v8;
          v29[8 * v2] = v23;
          v30[2 * v2++] = (int)v4;
        }
      }
    }
    v4 = (char *)v4 + 1;
    v5 += 40;
  }
  while ( (signed int)v4 < 176 );
  v11 = v2;
  v24 = v2;
  if ( (signed int)v2 > 0 )
  {
    v12 = 1;
    v13 = v30;
    v26 = v33;
    v27 = v2;
    do
    {
      v14 = 0;
      for ( i = v12; i < v11; ++i )
      {
        if ( v14 )
          break;
        if ( *v26 == v33[i] )
        {
          v14 = 1;
          if ( !*((_BYTE *)v13 - 4) )
          {
            --v24;
            *(_BYTE *)(v28 + 40 * *v13 + 23673) = 0;
          }
        }
      }
      ++v26;
      ++v12;
      v13 += 2;
      --v27;
    }
    while ( v27 );
    v2 = v24;
  }
  v16 = v28;
  v17 = v28 + 30716;
  v18 = 0;
  v19 = (int *)(v28 + 30716);
  v20 = v28 + 23656;
  v21 = 176;
  do
  {
    if ( *(_BYTE *)(v20 + 17) )
    {
      *v19 = v20;
      ++v18;
      ++v19;
    }
    v20 += 40;
    --v21;
  }
  while ( v21 );
  result = sub_10039360(v17, v18, 4u, (int)sub_10005690);
  *(_WORD *)(v16 + 30704) = v2;
  return result;
}
// 10007470: using guessed type __int16 var_164[176];
// 10007470: using guessed type char var_758[4];
// 10007470: using guessed type int var_754[351];

//----- (10007710) --------------------------------------------------------
char __usercall sub_10007710@<al>(int a1@<esi>)
{
  int v1; // edi@1
  int v2; // ecx@1
  char *v3; // eax@1
  _BYTE *v4; // edx@1
  char v5; // cl@3
  int v6; // edx@4
  char v7; // bl@7
  char result; // al@16
  char v9; // [sp+Ah] [bp-2h]@11
  char v10; // [sp+Bh] [bp-1h]@1

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 12);
  v10 = *(_BYTE *)(v2 + 333);
  v3 = (char *)(v2 + 306);
  v4 = (_BYTE *)(v2 + 311);
  if ( v2 == -306 || v2 == -311 || (v5 = *v3, *v3 != *v4) )
  {
LABEL_7:
    v7 = 0;
  }
  else
  {
    v6 = v4 - v3;
    while ( v5 )
    {
      v5 = (v3++)[1];
      if ( v5 != v3[v6] )
        goto LABEL_7;
    }
    v7 = 1;
  }
  sub_10018B50(a1, 0x40u, **(_BYTE **)(v1 + 64) == 3);
  sub_10018B50(a1, 0x41u, *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 1) == 3);
  sub_10018B50(a1, 0x42u, *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 2) == 3);
  if ( byte_10140650 == 1 )
  {
    if ( sub_100396A0((bool *)&v9) && v9 && !v7 && v10 )
    {
      sub_10018700(a1, 0x45u, 0);
      if ( byte_10140651 == 1 )
        result = sub_10018B50(a1, 0x45u, 1);
      else
        result = sub_10018B50(a1, 0x45u, 0);
    }
    else
    {
      sub_10018B50(a1, 0x45u, 0);
      result = sub_10018700(a1, 0x45u, 1);
    }
  }
  else
  {
    result = sub_10018700(a1, 0x45u, 2);
  }
  return result;
}
// 10140650: using guessed type char byte_10140650;
// 10140651: using guessed type char byte_10140651;

//----- (10007840) --------------------------------------------------------
char __cdecl sub_10007840(int a1, int a2, __int16 a3)
{
  return sub_10005780(a2, a1, a3);
}

//----- (10007860) --------------------------------------------------------
char __cdecl sub_10007860(int a1, int a2, __int16 a3)
{
  return sub_100057E0(a1, a2, a3);
}

//----- (10007880) --------------------------------------------------------
char __thiscall sub_10007880(int this)
{
  int v1; // ebx@1
  char *v2; // ST30_4@1
  int v3; // ebp@1
  int v4; // eax@1
  signed int v5; // ecx@1
  int v6; // esi@6
  char v7; // al@6
  int v8; // edx@6
  char *v9; // eax@7
  int v10; // edx@7
  char v11; // cl@8
  char *v12; // ecx@9
  _BYTE *v13; // edx@9
  char v14; // al@10
  const char *v15; // eax@12
  int v16; // edx@12
  char v17; // cl@13
  int v18; // esi@15
  void *v19; // ecx@19
  int v20; // eax@21
  int v21; // esi@24
  __int16 v22; // cx@27
  int v23; // eax@27
  int v24; // ebx@27
  int v25; // eax@27
  int v26; // ecx@27
  int v27; // edx@27
  _WORD *v28; // eax@27
  char result; // al@35
  char v30; // [sp+12h] [bp-3Ah]@3
  char v31; // [sp+13h] [bp-39h]@32
  int v32; // [sp+14h] [bp-38h]@1
  char v33[4]; // [sp+18h] [bp-34h]@1
  int v34; // [sp+1Ch] [bp-30h]@18
  int v35; // [sp+20h] [bp-2Ch]@19
  char v36; // [sp+24h] [bp-28h]@6
  char v37; // [sp+2Ch] [bp-20h]@24

  v1 = this;
  v2 = *(char **)(this + 56);
  v32 = this;
  v3 = sub_10003D50(this, v2, 32756, 3);
  sub_1006BA40(29, (_BYTE *)(v3 + 31674));
  *(_DWORD *)v33 = 0;
  memset((void *)(v3 + 32692), 0, 0x3Fu);
  qmemcpy((void *)(v3 + 32656), &unk_10086FC8, 0x20u);
  memset(&unk_10140658, 0, 0x1998u);
  v4 = v3 + 23656;
  v5 = 176;
  do
  {
    *(_BYTE *)(v4 + 17) = 0;
    *(_WORD *)v4 = 6;
    *(_BYTE *)(v4 + 2) = 0;
    *(_BYTE *)(v4 + 19) = 0;
    v4 += 40;
    --v5;
  }
  while ( v5 );
  v30 = sub_10038CF0(0x39u);
  sub_10002870(v1, 151, 0, 873, 686, 1);
  if ( *(_BYTE *)(v3 + 31674) )
    sub_100374D0(*(_DWORD *)(v1 + 56), (char *)&unk_10086F40);
  else
    sub_100374D0(*(_DWORD *)(v1 + 56), (char *)&unk_10086DA8);
  *(_DWORD *)(v3 + 31514) = 412686497;
  *(_DWORD *)(v3 + 31518) = 163453086;
  *(_WORD *)(v3 + 31522) = 2506;
  *(_DWORD *)(v3 + 31524) = 0;
  *(_DWORD *)(v3 + 31528) = 0;
  *(_DWORD *)(v3 + 31532) = 0;
  *(_DWORD *)(v3 + 31536) = 5;
  *(_DWORD *)(v3 + 31540) = 0;
  *(_DWORD *)(v3 + 31544) = 0;
  *(_DWORD *)(v3 + 31524) = v3 + 31514;
  v6 = v3 + 31509;
  *(_DWORD *)(v3 + 31532) = v3 + 31509;
  *(_DWORD *)v6 = 50529027;
  *(_BYTE *)(v6 + 4) = 3;
  *(_DWORD *)(*(_DWORD *)(v1 + 56) + 20) = v3 + 31524;
  **(_DWORD **)(*(_DWORD *)(v1 + 56) + 60) = v3 + 30696;
  **(_BYTE **)(*(_DWORD *)(v1 + 56) + 64) = 3;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 56) + 60) + 4) = v3 + 764;
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v1 + 56) + 64) + 1) = 2;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 56) + 60) + 8) = v3 + 808;
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v1 + 56) + 64) + 2) = 2;
  strncpy((char *)v3, (const char *)(dword_10789FA0 + 20440), 0x28u);
  v7 = sub_10039850((int)&v36);
  v8 = v3 + 31566;
  if ( v7 )
  {
    v9 = &v36;
    v10 = v8 - (_DWORD)&v36;
    do
    {
      v11 = *v9;
      v9[v10] = *v9;
      ++v9;
    }
    while ( v11 );
    v12 = (char *)(dword_10789FA0 + 1);
    v13 = (_BYTE *)(v3 + 585);
    do
    {
      v14 = *v12;
      *v13++ = *v12++;
    }
    while ( v14 );
  }
  else
  {
    v15 = "NOT AVAILABLE";
    v16 = v8 - (_DWORD)"NOT AVAILABLE";
    do
    {
      v17 = *v15;
      v15[v16] = *v15;
      ++v15;
    }
    while ( v17 );
    *(_BYTE *)(v3 + 585) = 0;
  }
  v18 = v3 + 31580;
  *(_DWORD *)v18 = 0;
  *(_DWORD *)(v18 + 4) = 0;
  *(_DWORD *)(v18 + 8) = 0;
  *(_DWORD *)(v18 + 12) = 0;
  if ( sub_1006A3F0((_DWORD *)v33) )
    sub_10036790((char *)(v3 + 31580), 0x10u, "%lX", *(_DWORD *)v33);
  else
    sub_100365D0(v3 + 31580, "NOT AVAILABLE", 16);
  if ( sub_1006A0A0(6103, (int)&v34, 8) )
    strncpy((char *)(v3 + 31549), "NOT AVAILABLE", 0x11u);
  else
    _snprintf((char *)(v3 + 31549), 0x11u, "%lX%08lX", v35, v34);
  *(_BYTE *)(v3 + 31565) = 0;
  v20 = (unsigned __int8)sub_1002F220(v19);
  if ( (_BYTE)v20 )
  {
    if ( v20 == 1 )
    {
      sub_1002E8B0(v3 + 520, 0x19u);
      sub_1002E880((int)&v37, 0x19u);
      v21 = v3 + 545;
      sub_1002E850(v3 + 545, 0x28u);
      sub_100367C0((const char *)(v3 + 545), word_10088C68, 40);
      sub_100367C0((const char *)(v3 + 545), &v37, 40);
      goto LABEL_27;
    }
    sub_100365D0(v3 + 520, "NOT AVAILABLE", 25);
  }
  else
  {
    sub_100365D0(v3 + 520, "INVALID", 25);
  }
  v21 = v3 + 545;
  sub_100365D0(v3 + 545, word_10088C68, 40);
LABEL_27:
  *(_DWORD *)(v3 + 31680) = v3 + 31566;
  *(_DWORD *)(v3 + 31684) = v3 + 31580;
  *(_DWORD *)(v3 + 31688) = v3 + 585;
  *(_DWORD *)(v3 + 31692) = v3 + 31549;
  *(_DWORD *)(v3 + 31700) = v21;
  *(_DWORD *)(v3 + 31676) = v3;
  *(_DWORD *)(v3 + 31696) = v3 + 520;
  *(_DWORD *)(v3 + 776) = 0;
  *(_WORD *)(v3 + 772) = 7;
  *(_WORD *)(v3 + 768) = 0;
  *(_WORD *)(v3 + 766) = 0;
  *(_DWORD *)(v3 + 780) = v3 + 784;
  sub_10005780(v3 + 784, v1, 0xFFFFFFFF);
  v22 = *(_WORD *)(v3 + 32688);
  v23 = v32;
  *(_DWORD *)(v3 + 820) = 0;
  *(_WORD *)(v3 + 816) = v22;
  *(_WORD *)(v3 + 812) = 0;
  *(_WORD *)(v3 + 810) = 0;
  *(_DWORD *)(v3 + 824) = v3 + 828;
  sub_100057E0(v23, v3 + 828, -1);
  v24 = v32;
  *(_DWORD *)(v3 + 30708) = 0;
  *(_WORD *)(v3 + 30704) = 0;
  *(_WORD *)(v3 + 30700) = 0;
  *(_WORD *)(v3 + 30698) = 0;
  *(_DWORD *)(v3 + 30712) = v3 + 23620;
  sub_10005990(v24, -1, v3 + 23620);
  sub_10003F00(v24, *(_DWORD *)(v24 + 56), 1000);
  sub_10007470(v24);
  v25 = *(_DWORD *)(v24 + 56);
  v26 = *(_BYTE *)(v25 + 230);
  v27 = *(_DWORD *)(v25 + 60);
  v28 = *(_WORD **)(v24 + 52);
  if ( *(_BYTE *)(v3 + 31674) )
    sub_10002D30(v24, v28, (char *)&unk_10086F40, v27, 0, v26);
  else
    sub_10002D30(v24, v28, (char *)&unk_10086DA8, v27, 0, v26);
  sub_10018E40(v24, &unk_10086BB4, 6u, 0, 1u);
  sub_10018700(v24, 0, 2);
  *(_BYTE *)(v3 + 23616) = 0;
  sub_10018750(v24, 0x42u, 4553);
  sub_10018B50(v24, 0x42u, 0);
  sub_10005DB0(v24);
  if ( v30 )
    sub_10018700(v24, 0x44u, 0);
  sub_1006A0A0(9110, (int)&v31, 1);
  sub_10018B50(v24, 0x43u, (v31 & 1) != 0);
  *(_BYTE *)(v3 + 31548) = 0;
  sub_1006A0A0(6464, (int)&byte_10140650, 1);
  if ( byte_10140650 )
  {
    sub_10018700(v24, 0x45u, 1);
    sub_1006A0A0(2178, (int)&byte_10140651, 1);
  }
  else
  {
    sub_10018700(v24, 0x45u, 2);
  }
  result = sub_10004590(v24, *(_DWORD *)(v24 + 56), -32648);
  *(_BYTE *)(v24 + 6) = 2;
  return result;
}
// 10140650: using guessed type char byte_10140650;
// 10140651: using guessed type char byte_10140651;
// 10789FA0: using guessed type int dword_10789FA0;

//----- (10007E50) --------------------------------------------------------
char __usercall sub_10007E50@<al>(int a1@<esi>)
{
  int v1; // edi@1
  int v2; // eax@1
  bool v3; // ST08_1@5
  bool v4; // ST08_1@6

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 8);
  switch ( v2 )
  {
    case 0:
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 1) = 2;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 2) = 2;
      **(_BYTE **)(*(_DWORD *)(a1 + 56) + 64) = 3;
      LOBYTE(v2) = sub_1002F6C0(a1, 0, 0);
      break;
    case 1:
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 1) = 3;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 2) = 2;
      **(_BYTE **)(*(_DWORD *)(a1 + 56) + 64) = 2;
      LOBYTE(v2) = sub_1002F6C0(a1, 1, 0);
      break;
    case 2:
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 2) = 3;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 1) = 2;
      **(_BYTE **)(*(_DWORD *)(a1 + 56) + 64) = 2;
      LOBYTE(v2) = sub_1002F6C0(a1, 2, 0);
      break;
    case 3:
      v3 = sub_100186E0(a1, 0x43u) == 0;
      sub_10018B50(a1, 0x43u, v3);
      LOBYTE(v2) = sub_10005D60(a1);
      break;
    case 4:
      v4 = sub_100186E0(a1, 0x44u) == 0;
      sub_10018B50(a1, 0x44u, v4);
      LOBYTE(v2) = sub_100186E0(a1, 0x44u) == 1;
      *(_BYTE *)(v1 + 31548) = v2;
      break;
    default:
      return v2;
  }
  return v2;
}

//----- (10007F80) --------------------------------------------------------
char __thiscall sub_10007F80(unsigned int this)
{
  unsigned int v1; // esi@1
  int v2; // ebp@1
  int v3; // edi@1
  int v4; // ecx@1
  int v5; // ebp@5
  char v6; // al@8
  int v7; // ecx@8
  int v9; // [sp+Ch] [bp-D8Ch]@5
  char v10[4]; // [sp+10h] [bp-D88h]@8
  char v11; // [sp+14h] [bp-D84h]@8
  char v12; // [sp+CE0h] [bp-B8h]@1

  v1 = this;
  v2 = *(_DWORD *)(this + 56);
  v3 = *(_DWORD *)(v2 + 12);
  memset(&v12, 0, 0xB4u);
  v4 = *(_DWORD *)(v1 + 52);
  switch ( *(_BYTE *)(v4 + 8) )
  {
    case 0x40:
      *(_BYTE *)(*(_DWORD *)(v2 + 64) + 1) = 2;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v1 + 56) + 64) + 2) = 2;
      **(_BYTE **)(*(_DWORD *)(v1 + 56) + 64) = 3;
      sub_1002F6C0(v1, 0, 0);
      break;
    case 0x41:
      *(_BYTE *)(*(_DWORD *)(v2 + 64) + 1) = 3;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v1 + 56) + 64) + 2) = 2;
      **(_BYTE **)(*(_DWORD *)(v1 + 56) + 64) = 2;
      sub_1002F6C0(v1, 1, 0);
      break;
    case 0x42:
      if ( *(_BYTE *)(*(_DWORD *)(v2 + 64) + 2) == 3 )
      {
        v5 = sub_10037130((void *)v4);
        sub_1006A0A0(6005, (int)&v9, 4);
        do
        {
          if ( ++*(_BYTE *)(v3 + 23616) >= 3u )
            *(_BYTE *)(v3 + 23616) = 0;
          v10[0] = sub_10038400(byte_10088B78[16 * *(_BYTE *)(v3 + 23616)]);
          v6 = sub_1003B750(v10[0], &v11);
          v7 = dword_10088B7C[4 * *(_BYTE *)(v3 + 23616)];
        }
        while ( !(v7 & v9) && !v6 && !(v7 & v5) );
      }
      sub_10018750(v1, 0x42u, word_10088B80[8 * *(_BYTE *)(v3 + 23616)]);
      *(_DWORD *)(v3 + 32680) = *(&off_10088B84 + 4 * *(_BYTE *)(v3 + 23616));
      *(_BYTE *)(*(_DWORD *)(v1 + 56) + 246) = 1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v1 + 56) + 64) + 1) = 2;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v1 + 56) + 64) + 2) = 3;
      **(_BYTE **)(*(_DWORD *)(v1 + 56) + 64) = 2;
      sub_1002F6C0(v1, 2, 0);
      break;
    case 0x43:
      sub_10005D60(v1);
      break;
    case 0x44:
      *(_BYTE *)(v3 + 31548) = sub_100186E0(v1, 0x44u) == 1;
      break;
    case 0x45:
      sub_1006A0A0(2178, (int)&byte_10140651, 1);
      if ( byte_10140651 == 1 )
      {
        _snprintf(
          &v12,
          0xB4u,
          "Are you sure you want to cancel activation of the standby nav database?  The standby nav database will still a"
          "uto-update at 00:00 system time on the effective date.");
        sub_100163A0(v1, 0, &v12, 1);
      }
      else
      {
        _snprintf(
          &v12,
          0xB4u,
          "Are you sure you want to activate the standby nav database now?  This will overwrite the active nav database o"
          "n the next power cycle.");
        sub_100163A0(v1, 0, &v12, 0);
      }
      break;
    default:
      return sub_10007710(v1);
  }
  return sub_10007710(v1);
}
// 10088B7C: using guessed type int dword_10088B7C[];
// 10088B80: using guessed type __int16 word_10088B80[];
// 10088B84: using guessed type void *off_10088B84;
// 10140651: using guessed type char byte_10140651;

//----- (100082C0) --------------------------------------------------------
char __cdecl sub_100082C0(int a1)
{
  int v1; // eax@13
  int v2; // edi@13
  int v3; // eax@17
  int v4; // ecx@17
  int v5; // edx@17
  _WORD *v6; // eax@17
  int v7; // eax@1

  LOBYTE(v7) = a1;
  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x801D:
      v7 = *(_DWORD *)(a1 + 52);
      if ( *(_BYTE *)(v7 + 8) == 1 )
      {
        byte_10140651 = *(_BYTE *)(v7 + 9) == 0;
        LOBYTE(v7) = sub_1006A190(2178, (int)&byte_10140651, 1);
      }
      break;
    case 0x8022:
    case 0x8067:
      LOBYTE(v7) = sub_1000FE60(a1);
      break;
    case 0x8041:
      LOBYTE(v7) = sub_10007880(a1);
      break;
    case 0x8048:
      if ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) == 29 )
        sub_10005CF0(a1);
      LOBYTE(v7) = sub_100375A0(a1, *(char **)(a1 + 56), *(_DWORD *)(a1 + 52));
      *(_BYTE *)(a1 + 6) = v7;
      break;
    case 0x8058:
      LOBYTE(v7) = sub_10007E50(a1);
      break;
    case 0x806E:
      LOBYTE(v7) = sub_10007F80(a1);
      break;
    case 0x8078:
      v1 = *(_DWORD *)(a1 + 56);
      v2 = *(_DWORD *)(v1 + 12);
      if ( *(_BYTE *)(v1 + 246) )
      {
        *(_BYTE *)(v1 + 246) = 0;
        if ( *(_BYTE *)(v2 + 31674) )
          sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_10086EB8, v2 + 32656, 0, 255);
        else
          sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_10086D20, v2 + 32656, 0, 255);
      }
      sub_10007470(a1);
      sub_10005DB0(a1);
      sub_10005D60(a1);
      sub_10007710(a1);
      v3 = *(_DWORD *)(a1 + 56);
      v4 = *(_BYTE *)(v3 + 230);
      v5 = *(_DWORD *)(v3 + 60);
      v6 = *(_WORD **)(a1 + 52);
      if ( *(_BYTE *)(v2 + 31674) )
        sub_10002D30(a1, v6, (char *)&unk_10086F40, v5, 0, v4);
      else
        sub_10002D30(a1, v6, (char *)&unk_10086DA8, v5, 0, v4);
      LOBYTE(v7) = sub_10038D60(0x39u, *(_BYTE *)(v2 + 31548));
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 0x801E:
    case 0x801F:
    case 0x8020:
    case 0x8021:
    case 0x8023:
    case 0x8024:
    case 0x8025:
    case 0x8026:
    case 0x8027:
    case 0x8028:
    case 0x8029:
    case 0x802A:
    case 0x802B:
    case 0x802C:
    case 0x802D:
    case 0x802E:
    case 0x802F:
    case 0x8030:
    case 0x8031:
    case 0x8032:
    case 0x8033:
    case 0x8034:
    case 0x8035:
    case 0x8036:
    case 0x8037:
    case 0x8038:
    case 0x8039:
    case 0x803A:
    case 0x803B:
    case 0x803C:
    case 0x803D:
    case 0x803E:
    case 0x803F:
    case 0x8040:
    case 0x8042:
    case 0x8043:
    case 0x8044:
    case 0x8045:
    case 0x8046:
    case 0x8047:
    case 0x8049:
    case 0x804A:
    case 0x804B:
    case 0x804C:
    case 0x804D:
    case 0x804E:
    case 0x804F:
    case 0x8050:
    case 0x8051:
    case 0x8052:
    case 0x8053:
    case 0x8054:
    case 0x8055:
    case 0x8056:
    case 0x8057:
    case 0x8059:
    case 0x805A:
    case 0x805B:
    case 0x805C:
    case 0x805D:
    case 0x805E:
    case 0x805F:
    case 0x8060:
    case 0x8061:
    case 0x8062:
    case 0x8063:
    case 0x8064:
    case 0x8065:
    case 0x8066:
    case 0x8068:
    case 0x8069:
    case 0x806A:
    case 0x806B:
    case 0x806C:
    case 0x806D:
    case 0x806F:
    case 0x8070:
    case 0x8071:
    case 0x8072:
    case 0x8073:
    case 0x8074:
    case 0x8075:
    case 0x8076:
    case 0x8077:
      return v7;
  }
  return v7;
}
// 10140651: using guessed type char byte_10140651;

//----- (100083A0) --------------------------------------------------------
unsigned __int8 __cdecl sub_100083A0(int a1)
{
  unsigned __int8 result; // al@1
  int v2; // esi@1
  signed int v3; // edi@2
  __int16 *v4; // ebp@2
  __int16 **v5; // ebx@2
  __int16 *v6; // eax@4
  __int16 *v7; // ecx@4
  __int16 **v8; // edx@4
  int v9; // eax@7
  __int16 v10; // [sp+4h] [bp-10h]@1
  char v11; // [sp+6h] [bp-Eh]@1
  int v12; // [sp+8h] [bp-Ch]@6
  char v13; // [sp+Ch] [bp-8h]@7
  char v14; // [sp+Dh] [bp-7h]@8
  int v15; // [sp+Eh] [bp-6h]@8

  v10 = 0;
  v11 = 0;
  result = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(_BYTE *)(v2 + 60) )
  {
    *(_DWORD *)(v2 + 860) = 68;
    *(_DWORD *)(v2 + 868) = 4134;
    *(_WORD *)(v2 + 872) = 165;
    *(_BYTE *)(v2 + 864) = 0;
    *(_DWORD *)(v2 + 5696) = 68;
    *(_DWORD *)(v2 + 5704) = 4134;
    *(_WORD *)(v2 + 5708) = 100;
    *(_BYTE *)(v2 + 5700) = 0;
    v3 = 0;
    v4 = (__int16 *)(v2 + 876);
    v5 = (__int16 **)(v2 + 2464);
    do
    {
      *v5 = v4;
      *v4 = sub_10019950(v3);
      *(_BYTE *)(v2 + v3++ + 61) = 1;
      ++v5;
      ++v4;
    }
    while ( v3 < 793 );
    *(_DWORD *)(v2 + 5636) = v2 + 2462;
    *(_WORD *)(v2 + 2462) = 6778;
    *(_BYTE *)(v2 + 854) = 0;
    *(_WORD *)(v2 + 856) = 793;
    v6 = word_100893F8;
    v7 = (__int16 *)(v2 + 5712);
    v8 = (__int16 **)(v2 + 5716);
    do
    {
      *v8 = v7;
      *v7 = *v6;
      ++v6;
      ++v8;
      ++v7;
    }
    while ( (signed int)v6 < (signed int)&unk_100893FC );
    result = 0;
    LOBYTE(v12) = 0;
    do
    {
      *(_DWORD *)(16 * (result + 353) + v2) = v2 + 2464;
      *(_DWORD *)(16 * (unsigned __int8)v12 + v2 + 5644) = v2 + 860;
      *(_DWORD *)(16 * (unsigned __int8)v12 + v2 + 5652) = v2 + 61;
      *(_WORD *)(16 * (unsigned __int8)v12 + v2 + 5640) = 794;
      *(_DWORD *)(16 * (unsigned __int8)v12 + v2 + 5732) = v2 + 5716;
      *(_DWORD *)(16 * ((unsigned __int8)v12 + 358) + v2) = v2 + 5696;
      *(_DWORD *)(16 * (unsigned __int8)v12 + v2 + 5736) = 0;
      *(_WORD *)(16 * (unsigned __int8)v12 + v2 + 5724) = 2;
      LOBYTE(v10) = 0;
      LOBYTE(v9) = sub_10038230(v12);
      if ( sub_1003BB60(v9, 0, 3, (int)&v10, (int)&v13, 4) )
      {
        *(_WORD *)(16 * (unsigned __int8)v12 + v2 + 5642) = v15;
        *(_WORD *)(16 * (unsigned __int8)v12 + v2 + 5726) = v14 == 1;
        if ( (unsigned __int16)(v15 - 1) > 0x317u )
        {
          *(_BYTE *)((unsigned __int8)byte_10089C1D[2 * sub_1003B9F0(&v12, 1u, (int)&unk_10089C1C, 2, 3)]
                   + *(_DWORD *)(*(_DWORD *)(a1 + 56) + 64)) = 2;
        }
        else
        {
          *(_BYTE *)((unsigned __int16)v15 + v2 + 61) = 0;
          *(_BYTE *)((unsigned __int8)byte_10089C1D[2 * sub_1003B9F0(&v12, 1u, (int)&unk_10089C1C, 2, 3)]
                   + *(_DWORD *)(*(_DWORD *)(a1 + 56) + 64)) = 3;
        }
      }
      else
      {
        *(_WORD *)(16 * (unsigned __int8)v12 + v2 + 5642) = 793;
        *(_WORD *)(16 * (unsigned __int8)v12 + v2 + 5726) = 0;
        *(_BYTE *)((unsigned __int8)byte_10089C1D[2 * sub_1003B9F0(&v12, 1u, (int)&unk_10089C1C, 2, 3)]
                 + *(_DWORD *)(*(_DWORD *)(a1 + 56) + 64)) = 2;
      }
      result = v12 + 1;
      LOBYTE(v12) = v12 + 1;
    }
    while ( (unsigned __int8)v12 < 3u );
  }
  return result;
}
// 100893F8: using guessed type __int16 word_100893F8[];

//----- (10008650) --------------------------------------------------------
char __usercall sub_10008650@<al>(int a1@<edi>)
{
  int v1; // esi@1
  void *v2; // ecx@1
  int v3; // ecx@1
  int v4; // eax@1
  int v5; // eax@3
  signed int v6; // ecx@3
  int v7; // eax@5
  signed int v8; // ecx@5
  _WORD *v9; // ecx@7
  int v10; // eax@7
  signed int v11; // ebp@7
  int v12; // eax@9
  signed int v13; // ecx@9
  char result; // al@14

  v1 = sub_10003D50(a1, *(char **)(a1 + 56), 7020, 6);
  *(_BYTE *)(v1 + 60) = sub_10036FE0(v2) == 2;
  sub_10002870(a1, 0, 0, 1024, 768, 1);
  sub_100374D0(*(_DWORD *)(a1 + 56), (char *)&unk_100897C0);
  v3 = *(_DWORD *)(a1 + 56);
  v4 = *(_DWORD *)(v3 + 60);
  *(_BYTE *)(v3 + 230) = -1;
  *(_DWORD *)v4 = v1 + 5656;
  *(_DWORD *)(v4 + 8) = v1 + 5672;
  *(_DWORD *)(v4 + 16) = v1 + 5640;
  *(_DWORD *)(v4 + 4) = v1 + 5740;
  *(_DWORD *)(v4 + 12) = v1 + 5756;
  *(_DWORD *)(v4 + 20) = v1 + 5724;
  if ( !*(_BYTE *)(v1 + 60) )
  {
    **(_BYTE **)(*(_DWORD *)(a1 + 56) + 64) = 0;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 1) = 0;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 2) = 0;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 3) = 0;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 4) = 0;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 5) = 0;
  }
  *(_DWORD *)(v1 + 6840) = v1 + 20;
  *(_DWORD *)(v1 + 6844) = v1 + 24;
  *(_DWORD *)(v1 + 6824) = v1 + 32;
  *(_DWORD *)(v1 + 32) = 0x7FFFFFFF;
  *(_DWORD *)(v1 + 6848) = v1 + 28;
  *(_DWORD *)(v1 + 36) = 0x7FFFFFFF;
  *(_DWORD *)(v1 + 4) = 0x7FFFFFFF;
  *(_DWORD *)(v1 + 6828) = v1 + 36;
  *(_DWORD *)(v1 + 6832) = v1 + 4;
  *(_DWORD *)(v1 + 6852) = v1 + 40;
  *(_DWORD *)(v1 + 6880) = v1 + 5780;
  *(_DWORD *)(v1 + 6856) = v1 + 44;
  *(_DWORD *)(v1 + 6884) = v1 + 5816;
  *(_DWORD *)(v1 + 6888) = v1 + 5852;
  *(_DWORD *)(v1 + 6892) = v1 + 5888;
  *(_DWORD *)(v1 + 6860) = v1 + 48;
  *(_DWORD *)(v1 + 6896) = v1 + 5924;
  *(_DWORD *)(v1 + 6900) = v1 + 5960;
  *(_DWORD *)(v1 + 6904) = v1 + 5996;
  *(_DWORD *)(v1 + 6864) = v1 + 52;
  *(_DWORD *)(v1 + 6908) = v1 + 6032;
  *(_DWORD *)(v1 + 6912) = v1 + 6068;
  *(_DWORD *)(v1 + 6916) = v1 + 6104;
  *(_DWORD *)(v1 + 6868) = v1 + 56;
  *(_DWORD *)(v1 + 6920) = v1 + 6140;
  *(_DWORD *)(v1 + 6924) = v1 + 6176;
  *(_DWORD *)(v1 + 6928) = v1 + 6212;
  *(_DWORD *)(v1 + 6872) = v1 + 8;
  *(_DWORD *)(v1 + 6932) = v1 + 6248;
  *(_DWORD *)(v1 + 6936) = v1 + 6284;
  *(_DWORD *)(v1 + 6940) = v1 + 6320;
  *(_DWORD *)(v1 + 6836) = v1 + 16;
  *(_DWORD *)(v1 + 6876) = v1 + 12;
  *(_DWORD *)(v1 + 16) = 0x7FFFFFFF;
  *(_DWORD *)(v1 + 20) = 0x7FFFFFFF;
  *(_DWORD *)(v1 + 24) = 0x7FFFFFFF;
  *(_DWORD *)(v1 + 28) = 0x7FFFFFFF;
  *(_DWORD *)(v1 + 40) = 0x7FFFFFFF;
  *(_DWORD *)(v1 + 44) = 0x7FFFFFFF;
  *(_DWORD *)(v1 + 48) = 0x7FFFFFFF;
  *(_DWORD *)(v1 + 52) = 0x7FFFFFFF;
  *(_DWORD *)(v1 + 56) = 0x7FFFFFFF;
  *(_DWORD *)(v1 + 8) = 0x7FFFFFFF;
  *(_DWORD *)(v1 + 12) = 0x7FFFFFFF;
  *(_DWORD *)(v1 + 6944) = v1 + 6356;
  *(_DWORD *)(v1 + 6948) = v1 + 6392;
  *(_DWORD *)(v1 + 6952) = v1 + 6428;
  *(_DWORD *)(v1 + 6956) = v1 + 6464;
  v5 = v1 + 5813;
  v6 = 10;
  do
  {
    *(_BYTE *)(v5 - 1) = 1;
    *(_BYTE *)v5 = 1;
    *(_BYTE *)(v5 + 1) = 2;
    *(_BYTE *)(v5 + 2) = 0;
    v5 += 36;
    --v6;
  }
  while ( v6 );
  v7 = v1 + 6173;
  v8 = 10;
  do
  {
    *(_BYTE *)(v7 - 1) = 1;
    *(_BYTE *)v7 = 3;
    *(_BYTE *)(v7 + 1) = 2;
    *(_BYTE *)(v7 + 2) = 0;
    v7 += 36;
    --v8;
  }
  while ( v8 );
  *(_DWORD *)(v1 + 6984) = v1 + 6536;
  *(_DWORD *)(v1 + 6988) = v1 + 6572;
  *(_DWORD *)(v1 + 6992) = v1 + 6500;
  *(_DWORD *)(v1 + 6996) = v1 + 6644;
  *(_DWORD *)(v1 + 7000) = v1 + 6680;
  *(_DWORD *)(v1 + 7004) = v1 + 6608;
  *(_DWORD *)(v1 + 6960) = v1 + 5690;
  *(_DWORD *)(v1 + 6968) = v1 + 5688;
  *(_DWORD *)(v1 + 6964) = v1 + 5692;
  *(_DWORD *)(v1 + 6976) = v1 + 5776;
  v9 = (_WORD *)(v1 + 5772);
  *(_DWORD *)(v1 + 6972) = v1 + 5774;
  *(_DWORD *)(v1 + 6980) = v1 + 5772;
  v10 = v1 + 6533;
  v11 = 3;
  do
  {
    *(_BYTE *)(v10 - 1) = 1;
    *(_BYTE *)v10 = 0;
    *(_BYTE *)(v10 + 2) = 0;
    *(_BYTE *)(v10 + 1) = 2;
    *(_BYTE *)(v10 + 107) = 1;
    *(_BYTE *)(v10 + 108) = 3;
    *(_BYTE *)(v10 + 110) = 0;
    *(_BYTE *)(v10 + 109) = 2;
    *(v9 - 42) = 6;
    *v9 = 6;
    ++v9;
    v10 += 36;
    --v11;
  }
  while ( v11 );
  *(_DWORD *)(v1 + 7008) = v1 + 6716;
  *(_DWORD *)(v1 + 7012) = v1 + 6752;
  *(_DWORD *)(v1 + 7016) = v1 + 6788;
  v12 = v1 + 6749;
  v13 = 3;
  do
  {
    *(_BYTE *)(v12 - 1) = 1;
    *(_BYTE *)v12 = 1;
    *(_BYTE *)(v12 + 2) = 0;
    *(_BYTE *)(v12 + 1) = 2;
    v12 += 36;
    --v13;
  }
  while ( v13 );
  *(_DWORD *)v1 = j_HWM_pvg_hsdb_get_lrus_online(0, 1) != 0 ? 5 : 0;
  sub_100083A0(a1);
  if ( *(_BYTE *)(v1 + 60) )
  {
    sub_10002D30(
      a1,
      *(_WORD **)(a1 + 52),
      (char *)&unk_100897C0,
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
      0,
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
    sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_100899D0, v1 + 6960, 0, 255);
  }
  else
  {
    sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_100897A4, v1 + 7008, 0, 255);
  }
  sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_10089810, v1 + 6824, 0, 255);
  result = sub_10004590(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 1006BB50: using guessed type int __fastcall j_HWM_pvg_hsdb_get_lrus_online(_DWORD, _DWORD);

//----- (10008B00) --------------------------------------------------------
char __usercall sub_10008B00@<al>(int a1@<esi>)
{
  char result; // al@1

  result = sub_100375A0(a1, *(char **)(a1 + 56), *(_DWORD *)(a1 + 52));
  *(_BYTE *)(a1 + 6) = result;
  return result;
}

//----- (10008B20) --------------------------------------------------------
char __usercall sub_10008B20@<al>(int a1@<esi>)
{
  int v1; // ecx@1
  int v2; // eax@1
  int v3; // edi@1
  char v4; // al@1
  int v5; // edx@1
  int v6; // eax@2
  int v7; // eax@8
  int v8; // ecx@12
  unsigned __int16 v9; // ax@12
  char v10; // al@15
  __int16 v12; // [sp+4h] [bp-Ch]@1
  char v13; // [sp+6h] [bp-Ah]@1
  int v14; // [sp+8h] [bp-8h]@6
  char v15; // [sp+Ch] [bp-4h]@8
  bool v16; // [sp+Dh] [bp-3h]@12
  unsigned __int16 v17; // [sp+Eh] [bp-2h]@11

  v1 = *(_DWORD *)(a1 + 52);
  v12 = 0;
  v13 = 0;
  v2 = *(_DWORD *)(a1 + 56);
  v3 = *(_DWORD *)(v2 + 12);
  v4 = sub_100375A0(a1, (char *)v2, v1);
  v5 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(a1 + 6) = v4;
  switch ( *(_BYTE *)(v5 + 230) )
  {
    case 0:
    case 1:
      LOBYTE(v6) = 1;
      break;
    case 2:
    case 3:
      LOBYTE(v6) = 2;
      break;
    case 4:
    case 5:
      LOBYTE(v6) = 0;
      break;
    default:
      LOBYTE(v6) = 3;
      break;
  }
  LOBYTE(v14) = v6;
  LOBYTE(v12) = 0;
  if ( (unsigned __int8)v6 < 3u )
  {
    v6 = 16 * (unsigned __int8)v6;
    if ( *(_WORD *)(v6 + v3 + 5642) < 793 )
    {
      LOBYTE(v7) = sub_10038230(v14);
      LOBYTE(v6) = sub_1003BB60(v7, 0, 3, (int)&v12, (int)&v15, 4);
      if ( (_BYTE)v6 || *(_WORD *)(*(_DWORD *)(a1 + 52) + 8) == 793 )
      {
        if ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 8) != 793 )
          *(_BYTE *)(v17 + v3 + 61) = 1;
        v8 = 16 * (unsigned __int8)v14;
        v9 = *(_WORD *)(v8 + v3 + 5642);
        v17 = v9;
        v16 = *(_WORD *)(v3 + v8 + 5726) == 1;
        if ( v9 )
        {
          *(_BYTE *)(v9 + v3 + 61) = 0;
          *(_BYTE *)((unsigned __int8)byte_10089C1D[2 * sub_1003B9F0(&v14, 1u, (int)&unk_10089C1C, 2, 3)]
                   + *(_DWORD *)(*(_DWORD *)(a1 + 56) + 64)) = 3;
        }
        else
        {
          *(_BYTE *)((unsigned __int8)byte_10089C1D[2 * sub_1003B9F0(&v14, 1u, (int)&unk_10089C1C, 2, 3)]
                   + *(_DWORD *)(*(_DWORD *)(a1 + 56) + 64)) = 2;
        }
        LOBYTE(v12) = 0;
        v10 = sub_10038230(v14);
        LOBYTE(v6) = sub_1003BED0(v10, 0, 3, (int)&v12, &v15, 4u);
      }
    }
  }
  return v6;
}

//----- (10008CB0) --------------------------------------------------------
bool __thiscall sub_10008CB0(int this)
{
  int v1; // esi@1
  bool v2; // zf@1
  bool v3; // cl@5
  unsigned __int8 v4; // al@40
  signed int v5; // ebx@40
  _WORD *v6; // ebp@40
  bool *v7; // edi@40
  int v8; // eax@41
  void *v9; // ecx@41
  int v10; // edi@52
  int v11; // eax@56
  bool result; // al@61
  char v13; // [sp+8h] [bp-44h]@4
  char v14; // [sp+9h] [bp-43h]@4
  char v15; // [sp+Fh] [bp-3Dh]@43
  __int16 v16; // [sp+10h] [bp-3Ch]@1
  char v17; // [sp+12h] [bp-3Ah]@1
  char v18; // [sp+14h] [bp-38h]@41
  char v19; // [sp+15h] [bp-37h]@42
  unsigned int v20; // [sp+16h] [bp-36h]@42
  int v21; // [sp+1Ch] [bp-30h]@6
  int v22; // [sp+20h] [bp-2Ch]@1
  int v23; // [sp+24h] [bp-28h]@2
  int v24; // [sp+28h] [bp-24h]@3
  int v25; // [sp+2Ch] [bp-20h]@3
  int v26; // [sp+30h] [bp-1Ch]@3
  int v27; // [sp+34h] [bp-18h]@3
  char v28; // [sp+38h] [bp-14h]@6

  v16 = 0;
  v17 = 0;
  v1 = *(_DWORD *)(*(_DWORD *)(this + 56) + 12);
  v2 = *(_BYTE *)(v1 + 5814) == 0;
  v22 = this;
  if ( !v2 )
  {
    if ( sub_1006A0A0(3, (int)&v23, 20) )
    {
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v26 = 0;
      v27 = 0;
      sub_1006A190(3, (int)&v23, 20);
    }
    v13 = 3;
    v14 = 1;
    *(_BYTE *)(v1 + 5814) = v23 == 0;
  }
  v3 = j_HWM_pvg_read_reg(2) != 0;
  v2 = *(_BYTE *)(v1 + 5886) == 0;
  *(_BYTE *)(v1 + 5850) = v3;
  if ( !v2 )
  {
    sub_1002E390(7, &v28, 14, (int)&v21);
    *(_BYTE *)(v1 + 5886) = (_WORD)v21 != -1;
  }
  if ( *(_DWORD *)v1 != 5 )
  {
    if ( *(_BYTE *)(v1 + 6138) )
    {
      *(_BYTE *)(v1 + 6138) = (unsigned __int8)j_HWM_pvg_lpbk_uart(2) != 0;
      if ( (unsigned __int8)j_HWM_pvg_lpbk_uart(3) )
      {
        if ( *(_BYTE *)(v1 + 6138) != 1 )
          *(_BYTE *)(v1 + 6138) = 2;
      }
      else
      {
        *(_BYTE *)(v1 + 6138) = *(_BYTE *)(v1 + 6138) != 1 ? 0 : 2;
      }
    }
    if ( *(_BYTE *)(v1 + 5922) )
      *(_BYTE *)(v1 + 5922) = (unsigned __int8)j_HWM_pvg_lpbk_uart(0) != 0;
    if ( *(_BYTE *)(v1 + 5958) )
      *(_BYTE *)(v1 + 5958) = (unsigned __int8)j_HWM_pvg_lpbk_uart(1) != 0;
    if ( *(_BYTE *)(v1 + 5994) )
      *(_BYTE *)(v1 + 5994) = (unsigned __int8)j_HWM_pvg_lpbk_ethr(0) != 0;
    if ( *(_BYTE *)(v1 + 6030) )
      *(_BYTE *)(v1 + 6030) = (unsigned __int8)j_HWM_pvg_lpbk_ethr(1) != 0;
    if ( *(_BYTE *)(v1 + 6066) )
      *(_BYTE *)(v1 + 6066) = (unsigned __int8)j_HWM_pvg_lpbk_ethr(2) != 0;
    if ( *(_BYTE *)(v1 + 6102) )
      *(_BYTE *)(v1 + 6102) = _RTC_NumErrors() > 3 && (unsigned __int8)j_HWM_pvg_lpbk_ethr(3);
    if ( *(_BYTE *)(v1 + 6750) && *(_DWORD *)v1 == 2 )
    {
      v13 = 1;
      v14 = 0;
      *(_BYTE *)(v1 + 6750) = sub_1006C0E0((__int16 *)&v13, 0) == 0;
    }
    if ( *(_BYTE *)(v1 + 6786) && *(_DWORD *)v1 == 3 )
    {
      v13 = 1;
      v14 = 1;
      *(_BYTE *)(v1 + 6786) = sub_1006C0E0((__int16 *)&v13, 0) == 0;
    }
    if ( *(_BYTE *)(v1 + 6822) && *(_DWORD *)v1 == 1 )
    {
      v13 = 3;
      v14 = 0;
      *(_BYTE *)(v1 + 6822) = sub_1006C0E0((__int16 *)&v13, 0) == 0;
    }
    if ( !*(_BYTE *)(v1 + 60) && ++*(_DWORD *)v1 == 4 )
      *(_DWORD *)v1 = 1;
  }
  *(_DWORD *)(v1 + 32) = (signed __int16)j_HWM_pvg_get_frmt_adc(0);
  *(_DWORD *)(v1 + 36) = (signed __int16)j_HWM_pvg_get_frmt_adc(1);
  *(_DWORD *)(v1 + 4) = (signed __int16)j_HWM_pvg_get_frmt_adc(2);
  *(_DWORD *)(v1 + 16) = (signed __int16)j_HWM_pvg_get_frmt_adc(3);
  *(_DWORD *)(v1 + 20) = (signed __int16)j_HWM_pvg_get_frmt_adc(14);
  *(_DWORD *)(v1 + 24) = (signed __int16)j_HWM_pvg_get_frmt_adc(10);
  *(_DWORD *)(v1 + 28) = (signed __int16)j_HWM_pvg_get_frmt_adc(9);
  *(_DWORD *)(v1 + 40) = (signed __int16)j_HWM_pvg_get_frmt_adc(8);
  *(_DWORD *)(v1 + 44) = (signed __int16)j_HWM_pvg_get_frmt_adc(4);
  *(_DWORD *)(v1 + 48) = (signed __int16)j_HWM_pvg_get_frmt_adc(5);
  *(_DWORD *)(v1 + 52) = (signed __int16)j_HWM_pvg_get_frmt_adc(7);
  *(_DWORD *)(v1 + 56) = (signed __int16)j_HWM_pvg_get_frmt_adc(6);
  *(_DWORD *)(v1 + 8) = (signed __int16)j_HWM_pvg_get_frmt_adc(15);
  *(_DWORD *)(v1 + 12) = (signed __int16)j_HWM_pvg_get_frmt_adc(16);
  *(_BYTE *)(v1 + 6282) = j_HWM_pvg_read_reg(12) != 0;
  *(_BYTE *)(v1 + 6318) = j_HWM_pvg_read_reg(13) != 0;
  v4 = j_HWM_pvg_read_reg(16);
  *(_BYTE *)(v1 + 6174) = v4 & 1;
  *(_BYTE *)(v1 + 6210) = (v4 >> 1) & 1;
  *(_BYTE *)(v1 + 6246) = (v4 >> 2) & 1;
  *(_BYTE *)(v1 + 6462) = j_HWM_pvg_read_reg(3) != 0;
  *(_BYTE *)(v1 + 6498) = j_HWM_pvg_read_reg(4) != 0;
  *(_BYTE *)(v1 + 6390) = j_HWM_pvg_read_reg(17) != 0;
  *(_BYTE *)(v1 + 6426) = j_HWM_pvg_read_reg(1) != 0;
  *(_BYTE *)(v1 + 6354) = j_HWM_pvg_read_reg(14) != 0;
  v5 = 0;
  v6 = (_WORD *)(v1 + 5772);
  v7 = (bool *)(v1 + 6642);
  do
  {
    LOBYTE(v16) = 0;
    LOBYTE(v8) = sub_10038230(v5);
    if ( sub_1003BB60(v8, 0, 3, (int)&v16, (int)&v18, 4) )
    {
      *(v6 - 42) = sub_10019950(v20);
      *v6 = word_100893F8[v19 == 1];
      v9 = (void *)(v20 - 1);
      if ( (unsigned __int16)(v20 - 1) > 0x317u )
      {
        if ( !(_WORD)v20 )
        {
          *(v7 - 108) = 3;
          *v7 = 3;
          goto LABEL_51;
        }
LABEL_49:
        *(v7 - 108) = 2;
        *v7 = 2;
        goto LABEL_51;
      }
      if ( !sub_10038DD0(v20, &v15) )
        goto LABEL_49;
      if ( v15 )
      {
        *(v7 - 108) = 1;
        *v7 = v19 != 1;
      }
      else
      {
        *(v7 - 108) = 0;
        LOBYTE(v9) = v19 == 1;
        *v7 = v19 == 1;
      }
    }
    else
    {
      *(v6 - 42) = 6;
      *v6 = 6;
    }
LABEL_51:
    ++v5;
    ++v6;
    v7 += 36;
  }
  while ( v5 < 3 );
  v10 = v22;
  if ( *(_DWORD *)(v22 + 56) == *(_DWORD *)(v22 + 48) )
    sub_100083A0(v22);
  if ( sub_10022FB0(v9) )
    *(_BYTE *)(*(_DWORD *)(v10 + 56) + 230) = -1;
  v11 = *(_DWORD *)(v10 + 56);
  if ( *(_BYTE *)(v11 + 246) )
  {
    *(_BYTE *)(v11 + 246) = 0;
    sub_10002D30(v10, *(_WORD **)(v10 + 52), (char *)&unk_10089430, (int)&unk_10089B30, 0, 255);
    if ( *(_BYTE *)(v1 + 60) )
      sub_10002D30(v10, *(_WORD **)(v10 + 52), (char *)&unk_100896B8, (int)&off_10089BD0, 0, 255);
    else
      sub_10002D30(v10, *(_WORD **)(v10 + 52), (char *)&unk_100893FC, (int)&off_10089C0C, 0, 255);
  }
  sub_10002D30(v10, *(_WORD **)(v10 + 52), (char *)&unk_10089810, v1 + 6824, 0, 255);
  if ( *(_BYTE *)(v1 + 60) )
  {
    sub_10002D30(v10, *(_WORD **)(v10 + 52), (char *)&unk_100899D0, v1 + 6960, 0, 255);
    result = sub_10002D30(
               v10,
               *(_WORD **)(v10 + 52),
               (char *)&unk_100897C0,
               *(_DWORD *)(*(_DWORD *)(v10 + 56) + 60),
               0,
               *(_BYTE *)(*(_DWORD *)(v10 + 56) + 230));
    *(_BYTE *)(v10 + 6) = 2;
  }
  else
  {
    result = sub_10002D30(v10, *(_WORD **)(v10 + 52), (char *)&unk_100897A4, v1 + 7008, 0, 255);
    *(_BYTE *)(v10 + 6) = 2;
  }
  return result;
}
// 1006BB10: using guessed type int __cdecl j_HWM_pvg_get_frmt_adc(_DWORD);
// 1006BB90: using guessed type int __cdecl j_HWM_pvg_lpbk_ethr(_DWORD);
// 1006BBA0: using guessed type int __cdecl j_HWM_pvg_lpbk_uart(_DWORD);
// 1006BBD0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1006C1D0: using guessed type int _RTC_NumErrors(void);
// 100893F8: using guessed type __int16 word_100893F8[];
// 10089BD0: using guessed type void *off_10089BD0;
// 10089C0C: using guessed type void *off_10089C0C;

//----- (100092C0) --------------------------------------------------------
char __cdecl sub_100092C0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1

  v2 = **(_WORD **)(a1 + 52);
  switch ( v2 )
  {
    case 32802:
      LOBYTE(v2) = sub_1000FE60(a1);
      break;
    default:
      return v2;
    case 32833:
      LOBYTE(v2) = sub_10008650(a1);
      break;
    case 32840:
      if ( sub_10022FB0(v1) )
      {
        LOWORD(v2) = *(_WORD *)(*(_DWORD *)(a1 + 52) + 10);
        if ( (_WORD)v2 != 56 && (_WORD)v2 != 57 )
          *(_BYTE *)(a1 + 6) = 2;
      }
      else
      {
        LOBYTE(v2) = sub_10008B00(a1);
      }
      break;
    case 32849:
      LOBYTE(v2) = sub_10008B20(a1);
      break;
    case 32888:
      LOBYTE(v2) = sub_10008CB0(a1);
      break;
  }
  return v2;
}

//----- (100093A0) --------------------------------------------------------
int __usercall sub_100093A0@<eax>(__int16 a1@<ax>, int a2@<esi>, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7)
{
  __int16 v7; // bx@1
  int v8; // edi@1
  int result; // eax@1

  v7 = *(_WORD *)(a2 + 396);
  v8 = *(_DWORD *)(a2 + 428);
  *(_WORD *)(a2 + 428) = a1;
  *(_WORD *)(a2 + 430) = a1;
  *(_WORD *)(a2 + 394) = a3;
  *(_WORD *)(a2 + 438) = a4;
  *(_WORD *)(a2 + 436) = a5;
  *(_WORD *)(a2 + 396) = 3;
  sub_1001CF50(a2 + 392, a6, a7, 0);
  result = HIWORD(v8);
  *(_WORD *)(a2 + 428) = v8;
  *(_WORD *)(a2 + 396) = v7;
  *(_WORD *)(a2 + 430) = HIWORD(v8);
  return result;
}

//----- (10009430) --------------------------------------------------------
int __usercall sub_10009430@<eax>(__int16 a1@<ax>, __int16 a2@<cx>, int a3@<esi>, __int16 a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  int result; // eax@1

  v4 = *(_DWORD *)(a3 + 440);
  v5 = *(_DWORD *)(a3 + 428);
  *(_WORD *)(a3 + 428) = a1;
  *(_WORD *)(a3 + 430) = a1;
  *(_WORD *)(a3 + 440) = a1;
  *(_WORD *)(a3 + 442) = a1;
  sub_1001E190(a3 + 392, a2, a4, 3, 1);
  result = HIWORD(v5);
  *(_WORD *)(a3 + 428) = v5;
  *(_WORD *)(a3 + 440) = v4;
  *(_WORD *)(a3 + 430) = HIWORD(v5);
  *(_WORD *)(a3 + 442) = HIWORD(v4);
  return result;
}

//----- (100094B0) --------------------------------------------------------
void __usercall sub_100094B0(unsigned __int8 a1@<bl>, char a2, char a3)
{
  int v3; // eax@5
  double v4; // st7@7
  __int16 v5; // [sp+4h] [bp-10h]@2
  __int16 v6[4]; // [sp+8h] [bp-Ch]@6

  if ( a3 == 1 )
  {
    sub_1006A0A0(3532, (int)&v5, 2);
  }
  else if ( a1 < 3u )
  {
    v3 = sub_1003B860(&a2, 4u, (int)&unk_1008BCFC, 8, 7, -1);
    if ( v3 != -1 && !sub_1006A0A0(dword_1008BD00[2 * v3], (int)v6, 6) )
      v4 = (double)v6[a1];
  }
}
// 1008BD00: using guessed type int dword_1008BD00[];
// 100094B0: using guessed type __int16 var_C[4];

//----- (10009560) --------------------------------------------------------
int __cdecl sub_10009560(int a1)
{
  int v1; // esi@1
  int v2; // ebp@1
  void *v3; // ecx@1
  int v4; // edi@1
  _WORD *v5; // ebp@1
  signed int v6; // eax@2
  bool v7; // cf@8
  bool v8; // zf@8
  _WORD *v9; // edi@9
  _DWORD *v10; // ebp@9
  char v11; // al@10
  _WORD *v12; // edi@11
  _BYTE *v13; // edx@11
  _WORD *v14; // eax@11
  _DWORD *v15; // ecx@11
  __int16 v16; // ax@13
  _WORD *v17; // edx@14
  int v18; // eax@14
  int v19; // ecx@14
  _WORD *v20; // edi@15
  __int16 v21; // bp@15
  signed __int16 v22; // di@16
  int v23; // ecx@17
  _WORD *v24; // edx@18
  int v25; // eax@18
  _WORD *v26; // edi@19
  __int16 v27; // bp@19
  int result; // eax@20
  _BYTE *v29; // edi@21
  _WORD *v30; // edx@21
  int v31; // eax@21
  int v32; // ecx@21
  __int16 v33; // ax@23
  _WORD *v34; // edx@31
  _WORD *v35; // eax@31
  _WORD *v36; // edi@32
  __int16 v37; // bp@32
  char v38; // [sp+10h] [bp-18h]@1
  _DWORD *v39; // [sp+14h] [bp-14h]@1
  _WORD *v40; // [sp+18h] [bp-10h]@1
  signed int v41; // [sp+18h] [bp-10h]@9
  char *v42; // [sp+1Ch] [bp-Ch]@1
  char *v43; // [sp+1Ch] [bp-Ch]@9
  _BYTE *v44; // [sp+20h] [bp-8h]@1
  char *v45; // [sp+20h] [bp-8h]@9
  signed int v46; // [sp+20h] [bp-8h]@11
  signed int v47; // [sp+20h] [bp-8h]@21
  int v48; // [sp+24h] [bp-4h]@1
  _WORD *v49; // [sp+2Ch] [bp+4h]@9
  _WORD *v50; // [sp+2Ch] [bp+4h]@11
  signed int v51; // [sp+2Ch] [bp+4h]@14
  signed int v52; // [sp+2Ch] [bp+4h]@18
  int v53; // [sp+2Ch] [bp+4h]@21
  signed int v54; // [sp+2Ch] [bp+4h]@31

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_DWORD *)(v1 + 364) = 68;
  *(_DWORD *)(v1 + 372) = 4134;
  *(_WORD *)(v1 + 376) = 90;
  *(_BYTE *)(v1 + 368) = 0;
  *(_DWORD *)(v1 + 408) = 68;
  *(_DWORD *)(v1 + 416) = 4143;
  *(_WORD *)(v1 + 420) = 90;
  *(_BYTE *)(v1 + 412) = 0;
  *(_DWORD *)(v1 + 608) = 68;
  *(_DWORD *)(v1 + 616) = 4134;
  *(_WORD *)(v1 + 620) = 90;
  *(_BYTE *)(v1 + 612) = 0;
  *(_DWORD *)(v1 + 1152) = 68;
  *(_DWORD *)(v1 + 1160) = 4134;
  *(_WORD *)(v1 + 1164) = 90;
  *(_BYTE *)(v1 + 1156) = 0;
  *(_DWORD *)(v1 + 1196) = 68;
  *(_DWORD *)(v1 + 1204) = 4143;
  *(_WORD *)(v1 + 1208) = 90;
  *(_BYTE *)(v1 + 1200) = 0;
  *(_DWORD *)(v1 + 1396) = 68;
  *(_DWORD *)(v1 + 1404) = 4134;
  *(_WORD *)(v1 + 1408) = 90;
  *(_BYTE *)(v1 + 1400) = 0;
  *(_DWORD *)(v1 + 808) = 68;
  *(_DWORD *)(v1 + 816) = 4134;
  *(_WORD *)(v1 + 820) = 90;
  *(_BYTE *)(v1 + 812) = 0;
  *(_DWORD *)(v1 + 900) = 68;
  *(_DWORD *)(v1 + 908) = 4134;
  *(_WORD *)(v1 + 912) = 90;
  *(_BYTE *)(v1 + 904) = 0;
  *(_DWORD *)(v1 + 1596) = 68;
  *(_DWORD *)(v1 + 1604) = 4134;
  *(_WORD *)(v1 + 1608) = 90;
  *(_BYTE *)(v1 + 1600) = 0;
  *(_DWORD *)(v1 + 2376) = 68;
  *(_DWORD *)(v1 + 2384) = 4134;
  *(_WORD *)(v1 + 2388) = 228;
  *(_BYTE *)(v1 + 2380) = 0;
  *(_DWORD *)(v1 + 992) = 68;
  *(_DWORD *)(v1 + 1000) = 4134;
  *(_WORD *)(v1 + 1004) = 90;
  *(_BYTE *)(v1 + 996) = 0;
  *(_DWORD *)(v1 + 1072) = 68;
  *(_DWORD *)(v1 + 1080) = 4134;
  *(_WORD *)(v1 + 1084) = 90;
  *(_BYTE *)(v1 + 1076) = 0;
  *(_DWORD *)(v1 + 1688) = 68;
  *(_DWORD *)(v1 + 1696) = 4134;
  *(_WORD *)(v1 + 1700) = 90;
  *(_BYTE *)(v1 + 1692) = 0;
  *(_DWORD *)(v1 + 1768) = 68;
  *(_DWORD *)(v1 + 1776) = 4134;
  *(_WORD *)(v1 + 1780) = 90;
  *(_BYTE *)(v1 + 1772) = 0;
  v2 = sub_10037130((void *)0x1026);
  v48 = v2;
  v44 = (_BYTE *)(v1 + 2524);
  v4 = v2 | sub_10036FC0(v3);
  v38 = 0;
  v42 = byte_1008A429;
  v40 = &unk_1008A3FC;
  v5 = (_WORD *)(v1 + 2392);
  v39 = (_DWORD *)(v1 + 2436);
  do
  {
    *v39 = v5;
    *v5 = *v40;
    v6 = sub_10038310(v38);
    *v44 = 0;
    if ( (v4 & v6) == v6 )
    {
      *v44 = 1;
      if ( v6 == v48 )
      {
        if ( **(_WORD **)(a1 + 52) == -32703 )
          *(_WORD *)(v1 + 2550) = (unsigned __int8)v38;
        if ( !*(_BYTE *)((unsigned __int8)*v42 + v1 + 360) )
        {
          *(_BYTE *)(v1 + 2622) = 0;
          *(_BYTE *)(v1 + 2623) = 0;
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 8) = 0;
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 22) = 0;
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 6) = 0;
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 18) = 0;
        }
      }
    }
    ++v39;
    ++v40;
    v42 += 3;
    ++v5;
    v7 = (unsigned __int8)(v38 + 1) < 6u;
    v8 = v38++ == 5;
    ++v44;
  }
  while ( v7 || v8 );
  v45 = (char *)(v1 + 2531);
  v43 = (char *)&unk_1008A43F;
  v49 = &unk_1008A40A;
  v9 = (_WORD *)(v1 + 2406);
  v10 = (_DWORD *)(v1 + 2464);
  v41 = 15;
  do
  {
    *v10 = v9;
    *v9 = *v49;
    v11 = sub_1003C230(*v43);
    ++v49;
    v43 += 3;
    *v45 = v11;
    ++v10;
    ++v9;
    v8 = v41-- == 1;
    ++v45;
  }
  while ( !v8 );
  *(_DWORD *)(v1 + 2556) = v1 + 2436;
  *(_DWORD *)(v1 + 2552) = v1 + 2376;
  v12 = &unk_1008A3A4;
  *(_DWORD *)(v1 + 2560) = v1 + 2524;
  *(_WORD *)(v1 + 2548) = 22;
  v50 = &unk_1008A3A4;
  v13 = (_BYTE *)(v1 + 3206);
  v14 = (_WORD *)(v1 + 1168);
  v15 = (_DWORD *)(v1 + 1172);
  v46 = 2;
  do
  {
    *(v13 - 2) = 1;
    *(v15 - 197) = v14 - 394;
    *(v14 - 394) = *v12;
    *v13 = 1;
    *v15 = v14;
    *v14 = *v50;
    v12 = v50 + 1;
    ++v15;
    ++v13;
    ++v14;
    v8 = v46-- == 1;
    ++v50;
  }
  while ( !v8 );
  *(_DWORD *)(v1 + 396) = v1 + 364;
  *(_DWORD *)(v1 + 404) = v1 + 3204;
  *(_DWORD *)(v1 + 1188) = v1 + 1172;
  *(_DWORD *)(v1 + 1184) = v1 + 1152;
  *(_DWORD *)(v1 + 1192) = v1 + 3206;
  v16 = *(_WORD *)(v1 + 2550);
  *(_DWORD *)(v1 + 400) = v1 + 384;
  *(_WORD *)(v1 + 392) = 2;
  *(_WORD *)(v1 + 1180) = 2;
  if ( v16 > 6 )
  {
    *(_BYTE *)(v1 + 3205) = 0;
    *(_BYTE *)(v1 + 3207) = 0;
    *(_WORD *)(v1 + 394) = 0;
    *(_WORD *)(v1 + 1182) = 0;
    v17 = &unk_1008A3D4;
    v18 = v1 + 772;
    v19 = v1 + 784;
    v51 = 6;
    do
    {
      *(_DWORD *)(v19 - 200) = v18 - 200;
      *(_WORD *)(v18 - 200) = *v17;
      *(_DWORD *)v19 = v18;
      *(_WORD *)v18 = *v17;
      *(_DWORD *)(v19 + 588) = v18 + 588;
      *(_WORD *)(v18 + 588) = *v17;
      v20 = (_WORD *)(v18 + 788);
      *(_DWORD *)(v19 + 788) = v18 + 788;
      v21 = *v17;
      v19 += 4;
      v18 += 2;
      ++v17;
      v8 = v51-- == 1;
      *v20 = v21;
    }
    while ( !v8 );
    *(_DWORD *)(v1 + 560) = v1 + 408;
    *(_DWORD *)(v1 + 764) = v1 + 784;
    *(_DWORD *)(v1 + 760) = v1 + 608;
    *(_DWORD *)(v1 + 1352) = v1 + 1372;
    v22 = 6;
    *(_DWORD *)(v1 + 1348) = v1 + 1196;
    *(_DWORD *)(v1 + 564) = v1 + 584;
    *(_DWORD *)(v1 + 568) = 0;
    *(_WORD *)(v1 + 556) = 6;
    *(_DWORD *)(v1 + 768) = 0;
    *(_WORD *)(v1 + 756) = 6;
    *(_DWORD *)(v1 + 1356) = 0;
    *(_WORD *)(v1 + 1344) = 6;
    *(_DWORD *)(v1 + 1552) = v1 + 1572;
    *(_DWORD *)(v1 + 1548) = v1 + 1396;
    *(_DWORD *)(v1 + 1556) = 0;
    *(_WORD *)(v1 + 1544) = 6;
    goto LABEL_17;
  }
  v29 = (_BYTE *)(v1 + 3230);
  v30 = &unk_1008A3A8;
  v53 = v1 + 3230;
  v31 = v1 + 624;
  v32 = v1 + 668;
  v47 = 22;
  do
  {
    *(v29 - 22) = 1;
    *v29 = 1;
    *(_DWORD *)(v32 - 200) = v31 - 200;
    *(_WORD *)(v31 - 200) = *v30;
    *(_DWORD *)v32 = v31;
    *(_WORD *)v31 = *v30;
    *(_DWORD *)(v32 + 588) = v31 + 588;
    *(_WORD *)(v31 + 588) = *v30;
    *(_DWORD *)(v32 + 788) = v31 + 788;
    *(_WORD *)(v31 + 788) = *v30;
    v29 = (_BYTE *)(v53 + 1);
    v32 += 4;
    v31 += 2;
    ++v30;
    v8 = v47-- == 1;
    ++v53;
  }
  while ( !v8 );
  v33 = *(_WORD *)(v1 + 2550);
  if ( v33 == 3 || v33 == 4 || v33 == 5 )
  {
    v22 = 6;
LABEL_29:
    *(_BYTE *)(v1 + 3213) = 0;
    *(_BYTE *)(v1 + 3214) = 0;
    *(_BYTE *)(v1 + 3215) = 0;
    *(_BYTE *)(v1 + 3216) = 0;
    *(_BYTE *)(v1 + 3235) = 0;
    *(_BYTE *)(v1 + 3236) = 0;
    *(_BYTE *)(v1 + 3237) = 0;
    *(_BYTE *)(v1 + 3238) = 0;
    goto LABEL_30;
  }
  v22 = 6;
  if ( v33 == 6 )
    goto LABEL_29;
LABEL_30:
  *(_DWORD *)(v1 + 560) = v1 + 408;
  *(_DWORD *)(v1 + 564) = v1 + 468;
  *(_DWORD *)(v1 + 568) = v1 + 3208;
  *(_DWORD *)(v1 + 768) = v1 + 3208;
  *(_DWORD *)(v1 + 764) = v1 + 668;
  *(_DWORD *)(v1 + 1352) = v1 + 1256;
  *(_DWORD *)(v1 + 760) = v1 + 608;
  *(_DWORD *)(v1 + 1348) = v1 + 1196;
  *(_DWORD *)(v1 + 1552) = v1 + 1456;
  *(_WORD *)(v1 + 556) = 22;
  *(_WORD *)(v1 + 756) = 22;
  *(_DWORD *)(v1 + 1356) = v1 + 3230;
  *(_WORD *)(v1 + 1344) = 22;
  *(_DWORD *)(v1 + 1548) = v1 + 1396;
  *(_DWORD *)(v1 + 1556) = v1 + 3230;
  *(_WORD *)(v1 + 1544) = 22;
LABEL_17:
  v23 = v1 + 944;
  if ( *(_WORD *)(v1 + 2550) > v22 )
  {
    v34 = &unk_1008A3F0;
    v35 = (_WORD *)(v1 + 932);
    v54 = 6;
    do
    {
      *(_DWORD *)(v23 - 92) = v35 - 46;
      *(v35 - 46) = *v34;
      *(_DWORD *)v23 = v35;
      *v35 = *v34;
      v36 = v35 + 348;
      *(_DWORD *)(v23 + 696) = v35 + 348;
      v37 = *v34;
      v23 += 4;
      ++v35;
      ++v34;
      v8 = v54-- == 1;
      *v36 = v37;
    }
    while ( !v8 );
    *(_DWORD *)(v1 + 892) = v1 + 852;
    *(_DWORD *)(v1 + 888) = v1 + 808;
    *(_DWORD *)(v1 + 896) = 0;
    *(_WORD *)(v1 + 884) = 6;
    *(_DWORD *)(v1 + 984) = v1 + 944;
    *(_DWORD *)(v1 + 980) = v1 + 900;
    *(_DWORD *)(v1 + 988) = 0;
    *(_WORD *)(v1 + 976) = 6;
    *(_DWORD *)(v1 + 1680) = v1 + 1640;
    result = v1 + 1596;
    *(_DWORD *)(v1 + 1676) = v1 + 1596;
    *(_DWORD *)(v1 + 1684) = 0;
    *(_WORD *)(v1 + 1672) = 6;
  }
  else
  {
    v24 = &unk_1008A3E0;
    v25 = v1 + 916;
    v52 = 8;
    do
    {
      *(_DWORD *)(v23 - 92) = v25 - 92;
      *(_WORD *)(v25 - 92) = *v24;
      *(_DWORD *)v23 = v25;
      *(_WORD *)v25 = *v24;
      *(_DWORD *)(v23 + 696) = v25 + 696;
      *(_WORD *)(v25 + 696) = *v24;
      *(_DWORD *)(v23 + 80) = v25 + 92;
      *(_WORD *)(v25 + 92) = *v24;
      *(_DWORD *)(v23 + 160) = v25 + 172;
      *(_WORD *)(v25 + 172) = *v24;
      *(_DWORD *)(v23 + 776) = v25 + 788;
      *(_WORD *)(v25 + 788) = *v24;
      v26 = (_WORD *)(v25 + 868);
      *(_DWORD *)(v23 + 856) = v25 + 868;
      v27 = *v24;
      v23 += 4;
      v25 += 2;
      ++v24;
      v8 = v52-- == 1;
      *v26 = v27;
    }
    while ( !v8 );
    *(_DWORD *)(v1 + 892) = v1 + 852;
    *(_DWORD *)(v1 + 888) = v1 + 808;
    *(_DWORD *)(v1 + 896) = 0;
    result = 8;
    *(_WORD *)(v1 + 884) = 8;
    *(_DWORD *)(v1 + 984) = v1 + 944;
    *(_DWORD *)(v1 + 980) = v1 + 900;
    *(_DWORD *)(v1 + 988) = 0;
    *(_WORD *)(v1 + 976) = 8;
    *(_DWORD *)(v1 + 1680) = v1 + 1640;
    *(_DWORD *)(v1 + 1676) = v1 + 1596;
    *(_DWORD *)(v1 + 1684) = 0;
    *(_WORD *)(v1 + 1672) = 8;
    *(_DWORD *)(v1 + 1064) = v1 + 1024;
    *(_DWORD *)(v1 + 1060) = v1 + 992;
    *(_DWORD *)(v1 + 1068) = 0;
    *(_WORD *)(v1 + 1056) = 8;
    *(_DWORD *)(v1 + 1144) = v1 + 1104;
    *(_DWORD *)(v1 + 1140) = v1 + 1072;
    *(_DWORD *)(v1 + 1148) = 0;
    *(_WORD *)(v1 + 1136) = 8;
    *(_DWORD *)(v1 + 1760) = v1 + 1720;
    *(_DWORD *)(v1 + 1756) = v1 + 1688;
    *(_DWORD *)(v1 + 1764) = 0;
    *(_WORD *)(v1 + 1752) = 8;
    *(_DWORD *)(v1 + 1840) = v1 + 1800;
    *(_DWORD *)(v1 + 1836) = v1 + 1768;
    *(_DWORD *)(v1 + 1844) = 0;
    *(_WORD *)(v1 + 1832) = 8;
  }
  return result;
}

//----- (10009EC0) --------------------------------------------------------
char __cdecl sub_10009EC0(int a1, _BYTE *a2, _BYTE *a3, char a4)
{
  int v4; // eax@4
  int v5; // ebp@4
  int v6; // edi@4
  char v7; // cl@4
  char v8; // bl@4
  int v9; // edx@4
  int v10; // ecx@16
  int v11; // ecx@36
  int v12; // ebp@39
  int v13; // eax@40
  unsigned int v14; // eax@42
  signed int v15; // esi@47
  int v16; // ebx@47
  signed int v17; // esi@52
  int v18; // eax@54
  signed int v19; // esi@59
  int v20; // eax@60
  int v21; // edx@68
  unsigned __int16 v22; // ax@69
  unsigned __int16 v23; // ax@73
  int v24; // edx@76
  unsigned __int8 v25; // al@77
  unsigned __int8 v26; // al@81
  int v27; // ebp@83
  signed int v28; // esi@85
  int v29; // eax@86
  int v30; // eax@87
  int v31; // eax@89
  _BYTE *v32; // eax@94
  int v33; // eax@95
  signed int v34; // esi@99
  int v35; // edi@100
  int v36; // eax@102
  int v37; // esi@103
  int v38; // edx@105
  int v39; // eax@112
  int v40; // ebp@118
  int v41; // edx@118
  int v42; // ebx@121
  int v43; // esi@124
  int v44; // edx@125
  int v45; // edi@132
  signed int v46; // esi@135
  signed int v47; // esi@144
  int v48; // eax@146
  int v49; // eax@149
  char v51; // [sp+2h] [bp-26h]@4
  char v52; // [sp+3h] [bp-25h]@39
  int v53; // [sp+4h] [bp-24h]@4
  int v54; // [sp+8h] [bp-20h]@4
  int v55; // [sp+Ch] [bp-1Ch]@47
  signed int v56; // [sp+10h] [bp-18h]@4
  int v57; // [sp+14h] [bp-14h]@46
  signed int v58; // [sp+18h] [bp-10h]@2
  int v59; // [sp+18h] [bp-10h]@40
  int v60; // [sp+1Ch] [bp-Ch]@2
  int v61; // [sp+20h] [bp-8h]@4
  int v62; // [sp+24h] [bp-4h]@46
  char v63; // [sp+38h] [bp+10h]@4

  if ( a4 )
  {
    v60 = 4;
    v58 = 5;
  }
  else
  {
    v60 = 6;
    v58 = 7;
  }
  v61 = v60 - 1;
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v63 = 0;
  v53 = 0;
  v56 = 100;
  v54 = 0;
  v51 = 0;
  if ( (unsigned int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 10) - 46 > 7 )
    return v4;
  if ( *(_WORD *)(v4 + 394) == 1 )
    v7 = 1;
  if ( *(_WORD *)(v4 + 1182) == 1 )
  {
    v8 = 1;
    v6 = 0;
  }
  if ( !v7 )
  {
    if ( *(_WORD *)(v4 + 886) )
    {
      v9 = v4 + 884;
      if ( *(_WORD *)(v4 + 758) )
      {
        v10 = v4 + 110;
LABEL_20:
        v54 = v10;
        goto LABEL_21;
      }
    }
    else
    {
      if ( !*(_WORD *)(v4 + 978) )
        goto LABEL_21;
      v9 = v4 + 976;
    }
    v10 = v4 + 124;
    goto LABEL_20;
  }
  if ( *(_WORD *)(v4 + 1058) )
  {
    v6 = v4 + 8;
    v63 = 1;
    v9 = v4 + 1056;
    v53 = v4 + 8;
  }
  else if ( *(_WORD *)(v4 + 1138) )
  {
    v6 = v4 + 32;
    v63 = 1;
    v9 = v4 + 1136;
    v53 = v4 + 32;
  }
LABEL_21:
  if ( v8 )
  {
    if ( *(_WORD *)(v4 + 1754) )
    {
      v6 = v4 + 60;
      v63 = 1;
      v51 = 1;
      v9 = v4 + 1752;
      v53 = v4 + 60;
LABEL_32:
      v56 = 1000;
      goto LABEL_33;
    }
    if ( *(_WORD *)(v4 + 1834) )
    {
      v6 = v4 + 84;
      v63 = 1;
      v51 = 1;
      v9 = v4 + 1832;
      v53 = v4 + 84;
      goto LABEL_32;
    }
  }
  else if ( *(_WORD *)(v4 + 1674) )
  {
    v9 = v4 + 1672;
    if ( *(_WORD *)(v4 + 1546) )
    {
      v4 += 142;
    }
    else
    {
      v4 += 156;
      v51 = 1;
    }
    v54 = v4;
  }
  if ( v63 )
    goto LABEL_32;
LABEL_33:
  if ( v9 )
  {
    v4 = *(_WORD *)(v9 + 2);
    if ( v4 != v58 )
    {
      v5 = v4 - 1;
      v61 = v4 - 1;
    }
    v11 = v5;
    if ( v5 <= v61 )
    {
      while ( 1 )
      {
        v12 = v54;
        v52 = 0;
        if ( v11 - 1 >= 0 )
        {
          if ( v63 )
          {
            v14 = 10 * ((*(_WORD *)(v6 + 4 * v11 - 4) + 10) / 10);
            if ( *(_WORD *)(v6 + 4 * v11) < v14 )
              v14 = *(_WORD *)(v6 + 4 * v11);
            v59 = v14;
            v13 = *(_WORD *)(v6 + 4 * v11 - 2);
          }
          else
          {
            v59 = *(_BYTE *)(v54 + 2 * v11 - 2) + 1;
            v13 = *(_BYTE *)(v54 + 2 * v11 - 1);
          }
        }
        else
        {
          v13 = 0;
          v52 = 1;
          v59 = 0;
        }
        v57 = v13;
        v62 = v11 + 1;
        if ( v11 + 1 >= v60 )
        {
          v15 = v56;
          v52 = 1;
          v55 = v56;
          v16 = v56;
          if ( v51 )
          {
            v13 = 0;
            v57 = 0;
          }
          goto LABEL_67;
        }
        if ( v51 && v11 + 2 == v60 )
        {
          if ( !v63 )
          {
            v18 = *(_BYTE *)(v54 + 2 * v11 + 2) - 1;
LABEL_57:
            v16 = v56;
            v55 = v18;
            goto LABEL_65;
          }
          v17 = *(_WORD *)(v6 + 4 * v11 + 4);
          if ( v17 > 10 )
          {
            v18 = 10 * (v17 / 10);
            if ( v17 % 10 )
              goto LABEL_57;
            v16 = v56;
            v55 = v17 - 10;
          }
          else
          {
            v16 = v56;
            v55 = *(_WORD *)(v6 + 4 * v11);
          }
        }
        else
        {
          if ( !v63 )
          {
            v16 = *(_BYTE *)(v54 + 2 * v11 + 3);
            v55 = *(_BYTE *)(v54 + 2 * v11 + 2) - 1;
            goto LABEL_65;
          }
          v19 = *(_WORD *)(v6 + 4 * v11 + 4);
          if ( v19 > 10 )
          {
            v20 = 10 * (v19 / 10);
            if ( !(v19 % 10) )
            {
              v16 = *(_WORD *)(v6 + 4 * v11 + 6);
              v55 = v19 - 10;
              goto LABEL_65;
            }
          }
          else
          {
            v20 = *(_WORD *)(v6 + 4 * v11);
          }
          v16 = *(_WORD *)(v6 + 4 * v11 + 6);
          v55 = v20;
        }
LABEL_65:
        if ( !v52 )
          goto LABEL_83;
        v15 = v56;
        v13 = v57;
LABEL_67:
        if ( v63 )
        {
          v21 = *(_WORD *)(v6 + 4 * v11 + 2);
          if ( v21 == v13 )
          {
            v22 = *(_WORD *)(v6 + 4 * v11);
            if ( v22 )
            {
              if ( v22 != v15 )
                goto LABEL_116;
              v15 = v56;
              v6 = v53;
            }
          }
          if ( v21 == v16 )
          {
            v23 = *(_WORD *)(v6 + 4 * v11);
            if ( v23 )
            {
              if ( v23 != v15 )
                goto LABEL_116;
            }
          }
        }
        else
        {
          v24 = *(_BYTE *)(v54 + 2 * v11 + 1);
          if ( v24 == v13 )
          {
            v25 = *(_BYTE *)(v54 + 2 * v11);
            if ( v25 )
            {
              if ( v25 != v15 )
                goto LABEL_116;
              v12 = v54;
              v15 = v56;
            }
          }
          if ( v24 == v16 )
          {
            v26 = *(_BYTE *)(v12 + 2 * v11);
            if ( v26 )
            {
              if ( v26 != v15 )
                goto LABEL_116;
            }
          }
        }
LABEL_83:
        v27 = *(_DWORD *)(a1 + 52);
        switch ( *(_WORD *)(v27 + 10) )
        {
          case 0x2E:
          case 0x2F:
          case 0x30:
            if ( v63 )
            {
              v28 = *(_WORD *)(v53 + 4 * v11 + 2);
              if ( *(_WORD *)(v53 + 4 * v11 + 2) < 0xAu )
              {
                v31 = *(_BYTE *)(v27 + 8);
                if ( v31 < 10 - v28 )
                  v30 = v28 + v31;
                else
                  v30 = 10 * (v31 - (10 - v28) + 1);
              }
              else
              {
                v29 = *(_BYTE *)(v27 + 8);
                if ( v28 % 10 )
                  v30 = 10 * ((v28 + 10 * v29) / 10);
                else
                  v30 = v28 + 10 * v29;
              }
              if ( v16 < v30 )
                LOWORD(v30) = v16;
              *(_WORD *)(v53 + 4 * v11 + 2) = v30;
              v32 = a3;
              goto LABEL_115;
            }
            v33 = *(_BYTE *)(v54 + 2 * v11 + 1) + *(_BYTE *)(v27 + 8);
            if ( v16 < v33 )
              LOBYTE(v33) = v16;
            *(_BYTE *)(v54 + 2 * v11 + 1) = v33;
            *a2 = 1;
            break;
          case 0x32:
          case 0x33:
          case 0x34:
            if ( v63 )
            {
              v34 = *(_WORD *)(v53 + 4 * v11 + 2);
              if ( *(_WORD *)(v53 + 4 * v11 + 2) < 0xAu )
              {
                v38 = *(_BYTE *)(v27 + 8);
              }
              else
              {
                v35 = (v34 - 10) / 10;
                if ( v34 % 10 )
                  ++v35;
                v36 = *(_BYTE *)(v27 + 8);
                if ( v35 <= v36 )
                {
                  v37 = v35 - v36 + 10;
LABEL_109:
                  if ( v57 > v37 )
                    LOWORD(v37) = v57;
                  *(_WORD *)(v53 + 4 * v11 + 2) = v37;
                  *a3 = 1;
                  break;
                }
                if ( v34 % 10 )
                {
                  v37 = 10 * ((v34 - 10 * v36 + 10) / 10);
                  goto LABEL_109;
                }
                v38 = 10 * v36;
              }
              v37 = v34 - v38;
              goto LABEL_109;
            }
            v39 = *(_BYTE *)(v54 + 2 * v11 + 1) - *(_BYTE *)(v27 + 8);
            if ( v57 > v39 )
              LOBYTE(v39) = v57;
            *(_BYTE *)(v54 + 2 * v11 + 1) = v39;
            v32 = a2;
LABEL_115:
            *v32 = 1;
            break;
          default:
            break;
        }
LABEL_116:
        if ( v52 )
        {
          if ( v63 )
          {
            v40 = v53;
            v41 = *(_WORD *)(v53 + 4 * v11);
            if ( v41 == v59 )
            {
              LOWORD(v4) = *(_WORD *)(v53 + 4 * v11 + 2);
              if ( (_WORD)v4 )
              {
                if ( (unsigned __int16)v4 != v56 )
                  goto LABEL_153;
              }
            }
            v42 = v55;
            if ( v41 == v55 )
            {
              LOWORD(v4) = *(_WORD *)(v53 + 4 * v11 + 2);
              if ( (_WORD)v4 )
              {
                if ( (unsigned __int16)v4 != v56 )
                  goto LABEL_153;
              }
            }
            v43 = v54;
            goto LABEL_132;
          }
          v43 = v54;
          v44 = *(_BYTE *)(v54 + 2 * v11);
          if ( v44 == v59 )
          {
            LOBYTE(v4) = *(_BYTE *)(v54 + 2 * v11 + 1);
            if ( (_BYTE)v4 )
            {
              if ( (unsigned __int8)v4 != v56 )
                goto LABEL_153;
            }
          }
          v42 = v55;
          if ( v44 == v55 )
          {
            LOBYTE(v4) = *(_BYTE *)(v54 + 2 * v11 + 1);
            if ( (_BYTE)v4 )
            {
              if ( (unsigned __int8)v4 != v56 )
                goto LABEL_153;
            }
          }
        }
        else
        {
          v43 = v54;
          v42 = v55;
        }
        v40 = v53;
LABEL_132:
        v45 = *(_DWORD *)(a1 + 52);
        v4 = *(_WORD *)(v45 + 10);
        switch ( v4 )
        {
          case 48:
          case 49:
          case 50:
            if ( v63 )
            {
              v46 = *(_WORD *)(v40 + 4 * v11);
              if ( v46 % 10 )
                v46 = 10 * (v46 / 10);
              v4 = v46 + 10 * *(_BYTE *)(v45 + 8);
              if ( v55 < v4 )
                LOWORD(v4) = v55;
              *(_WORD *)(v40 + 4 * v11) = v4;
              *a3 = 1;
            }
            else
            {
              v4 = *(_BYTE *)(v45 + 8) + *(_BYTE *)(v43 + 2 * v11);
              if ( v42 < v4 )
                LOBYTE(v4) = v42;
              *(_BYTE *)(v43 + 2 * v11) = v4;
              *a2 = 1;
            }
            break;
          case 46:
          case 52:
          case 53:
            if ( v63 )
            {
              v47 = *(_WORD *)(v40 + 4 * v11);
              if ( v47 % 10 )
                v47 = 10 * ((v47 + 10) / 10);
              v48 = v47 + -10 * *(_BYTE *)(v45 + 8);
              if ( v59 > v48 )
                LOWORD(v48) = v59;
              *(_WORD *)(v40 + 4 * v11) = v48;
              v4 = (int)a3;
            }
            else
            {
              v49 = *(_BYTE *)(v43 + 2 * v11) - *(_BYTE *)(v45 + 8);
              if ( v59 > v49 )
                LOBYTE(v49) = v59;
              *(_BYTE *)(v43 + 2 * v11) = v49;
              v4 = (int)a2;
            }
            *(_BYTE *)v4 = 1;
            break;
          default:
            break;
        }
LABEL_153:
        ++v11;
        if ( v62 > v61 )
          return v4;
        v6 = v53;
      }
    }
  }
  return v4;
}

//----- (1000A600) --------------------------------------------------------
void __usercall sub_1000A600(int a1@<esi>)
{
  int v1; // edi@1
  int v2; // eax@2
  int v3; // eax@3
  int v4; // eax@4
  char v5; // [sp-8h] [bp-14h]@6
  char v6; // [sp-4h] [bp-10h]@6
  char v7; // [sp+0h] [bp-Ch]@6

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(_BYTE *)(v1 + 2334) == 5 )
  {
    v2 = sub_10069700();
    sub_10069880(*(_DWORD *)(v1 + 2340) - v2 + 1000 <= 0 ? 0 : *(_DWORD *)(v1 + 2340) - v2 + 1000);
  }
  v3 = *(_DWORD *)(a1 + 52);
  if ( *(_BYTE *)(v3 + 8) == 1 )
  {
    v4 = *(_BYTE *)(v3 + 9);
    if ( !v4 )
    {
      v7 = 16;
      v6 = 0;
      v5 = byte_1008A428[3 * *(_WORD *)(v1 + 2550)];
      goto LABEL_8;
    }
    if ( v4 == 1 )
    {
      v7 = 16;
      v6 = 1;
      v5 = byte_1008A428[3 * *(_WORD *)(v1 + 2550)];
LABEL_8:
      sub_1003BDF0(v5, v6, v7, 0);
      sub_10010A60(a1, 1, 0, byte_10084570, 0.0, 0);
      goto LABEL_9;
    }
  }
LABEL_9:
  *(_BYTE *)(a1 + 6) = 2;
}

//----- (1000A6B0) --------------------------------------------------------
char __usercall sub_1000A6B0@<al>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // esi@1
  __int16 v3; // cx@1
  bool v4; // bl@3
  int v5; // ST14_4@5
  char v6; // al@5
  int v7; // eax@6
  double v8; // st7@11
  double v9; // st7@13
  double v10; // st7@14
  float v11; // ST14_4@17
  double v12; // st7@23
  __int16 v13; // ax@27
  __int16 v14; // ax@28
  __int16 v15; // ax@29
  __int16 v16; // ax@30
  char v18; // [sp+Fh] [bp-9h]@5
  float v19; // [sp+10h] [bp-8h]@5
  float v20; // [sp+14h] [bp-4h]@5

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 12);
  v3 = *(_WORD *)(v2 + 2550);
  v4 = v3 >= 7 && v3 <= 21;
  v5 = *(_DWORD *)(a1 + 52);
  LOBYTE(v20) = v4;
  LOBYTE(v19) = 0;
  v18 = 0;
  v6 = sub_100375A0(a1, (char *)v1, v5);
  *(_BYTE *)(a1 + 6) = v6;
  if ( v6 == 3 )
  {
    v7 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230);
    switch ( v7 )
    {
      case 3:
        *(_BYTE *)(v2 + 122) = *(_BYTE *)(v2 + 2348);
        LOBYTE(v7) = 1;
        goto LABEL_33;
      case 4:
        *(_BYTE *)(v2 + 139) = *(_BYTE *)(v2 + 2352);
        LOBYTE(v7) = 1;
        goto LABEL_33;
      case 5:
        if ( !v4 )
        {
          if ( sub_1006C1E0() )
          {
            v8 = 0.0;
            if ( *(float *)(v2 + 2344) > 0.0 )
              v8 = *(float *)(v2 + 2344);
            v19 = v8;
            v20 = v19 * 100.0;
            v9 = v20;
          }
          else
          {
            v10 = 0.14;
            if ( *(float *)(v2 + 2344) > 0.14 )
              v10 = *(float *)(v2 + 2344);
            v19 = v10;
            v20 = v19 * 100.0;
            v9 = v20;
          }
          v11 = v9;
          *(_WORD *)(v2 + 108) = sub_10022BF0(v11);
        }
        LOBYTE(v7) = 1;
        goto LABEL_33;
      case 9:
        LODWORD(v20) = (signed int)(*(float *)(v2 + 2368) * 100.0);
        *(_WORD *)(v2 + 136) = LOWORD(v20);
        LOBYTE(v7) = 1;
        goto LABEL_33;
      case 15:
        *(_BYTE *)(v2 + 154) = *(_BYTE *)(v2 + 2360);
        LOBYTE(v7) = 1;
        goto LABEL_33;
      case 16:
        *(_BYTE *)(v2 + 171) = *(_BYTE *)(v2 + 2364);
        LOBYTE(v7) = 1;
        goto LABEL_33;
      case 17:
        if ( !v4 )
        {
          v12 = 0.0;
          if ( *(float *)(v2 + 2356) > 0.0 )
            v12 = *(float *)(v2 + 2356);
          v19 = v12;
          v20 = v19 * 100.0;
          *(_WORD *)(v2 + 140) = sub_10022BF0(v20);
        }
        LOBYTE(v7) = 1;
        goto LABEL_33;
      case 6:
        v20 = *(float *)(v2 + 344) * 100.0;
        v13 = sub_10022BF0(v20);
        LOBYTE(v7) = sub_1002F920(1, byte_1008A429[3 * *(_WORD *)(v2 + 2550)], v13);
        break;
      case 8:
        v20 = *(float *)(v2 + 340) * 100.0;
        v14 = sub_10022BF0(v20);
        LOBYTE(v7) = sub_1002F870(1, byte_1008A429[3 * *(_WORD *)(v2 + 2550)], v14);
        break;
      case 18:
        v20 = *(float *)(v2 + 356) * 100.0;
        v15 = sub_10022BF0(v20);
        LOBYTE(v7) = sub_1002F920(2, byte_1008A429[3 * *(_WORD *)(v2 + 2550)], v15);
        break;
      case 22:
        v20 = *(float *)(v2 + 352) * 100.0;
        v16 = sub_10022BF0(v20);
        LOBYTE(v7) = sub_1002F870(2, byte_1008A429[3 * *(_WORD *)(v2 + 2550)], v16);
        break;
      default:
        return v7;
    }
  }
  else
  {
    sub_10009EC0(a1, &v19, &v18, SLOBYTE(v20));
    LOBYTE(v7) = LOBYTE(v19);
    if ( LOBYTE(v19) || v18 != LOBYTE(v19) )
    {
LABEL_33:
      if ( v4 )
      {
        *(_BYTE *)(v2 + 2338) = 1;
      }
      else if ( (_BYTE)v7 )
      {
        LOBYTE(v7) = sub_1003BED0(byte_1008A428[3 * *(_WORD *)(v2 + 2550)], 0, 16, 0, (const void *)(v2 + 108), 0x40u);
      }
      else if ( v18 )
      {
        LOBYTE(v7) = sub_1003BED0(byte_1008A428[3 * *(_WORD *)(v2 + 2550)], 0, 15, 0, (const void *)(v2 + 4), 0x68u);
      }
    }
  }
  return v7;
}

//----- (1000AA50) --------------------------------------------------------
char __usercall sub_1000AA50@<al>(int a1@<eax>)
{
  int v1; // esi@1
  double v2; // st7@1
  int v3; // eax@1
  float v4; // ST20_4@1
  __int16 v5; // ax@1
  char v6; // cl@1
  double v7; // st7@1
  char v8; // dl@1
  int v9; // eax@1
  float v10; // ST20_4@1
  int v11; // ecx@1
  double v12; // st7@1
  int v13; // edx@1
  signed int v14; // eax@1
  double v15; // st6@1
  int v16; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(float *)(v1 + 2344) * 10.22999954223633;
  v3 = *(_DWORD *)(v1 + 114);
  *(_DWORD *)(v1 + 2298) = *(_DWORD *)(v1 + 110);
  v4 = v2;
  *(_DWORD *)(v1 + 2302) = v3;
  v5 = sub_10022BF0(v4);
  v6 = *(_BYTE *)(v1 + 122);
  v7 = *(float *)(v1 + 2356) * 10.22999954223633;
  v8 = *(_BYTE *)(v1 + 123);
  *(_WORD *)(v1 + 2330) = v5;
  v9 = *(_DWORD *)(v1 + 142);
  v10 = v7;
  *(_BYTE *)(v1 + 2291) = v6;
  v11 = *(_DWORD *)(v1 + 146);
  *(_BYTE *)(v1 + 2292) = v8;
  *(_DWORD *)(v1 + 2314) = v9;
  *(_DWORD *)(v1 + 2318) = v11;
  *(_WORD *)(v1 + 2332) = sub_10022BF0(v10);
  *(_BYTE *)(v1 + 2295) = *(_BYTE *)(v1 + 155);
  v12 = (double)*(_WORD *)(v1 + 136);
  *(_BYTE *)(v1 + 2294) = *(_BYTE *)(v1 + 154);
  v13 = *(_DWORD *)(v1 + 128);
  *(_DWORD *)(v1 + 2322) = *(_DWORD *)(v1 + 156);
  v14 = *(_WORD *)(v1 + 168);
  *(_DWORD *)(v1 + 2310) = v13;
  *(_DWORD *)(v1 + 2306) = *(_DWORD *)(v1 + 124);
  *(_BYTE *)(v1 + 2338) = 0;
  *(_BYTE *)(v1 + 2290) = (signed int)(v12 / 100.0 + 0.5);
  *(_DWORD *)(v1 + 2326) = *(_DWORD *)(v1 + 160);
  v15 = (double)v14 / 100.0;
  v16 = *(_WORD *)(v1 + 2550);
  *(_BYTE *)(v1 + 2293) = (signed int)(v15 + 0.5);
  return sub_1003BED0(byte_1008A428[3 * v16], 0, 16, 0, (const void *)(v1 + 2290), 0x2Cu);
}

//----- (1000ABE0) --------------------------------------------------------
int __usercall sub_1000ABE0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // eax@1
  signed int v3; // edx@1
  int v4; // ecx@2
  int v5; // ecx@5
  int v6; // eax@7
  signed int v7; // edx@7
  int v8; // ecx@8
  int v9; // ecx@11
  double v10; // st7@13
  int v11; // ecx@13
  int v12; // eax@13
  double v13; // st6@13
  int v14; // eax@16
  int v15; // eax@16
  double v16; // st7@16
  int v17; // eax@18
  int v18; // ecx@19
  int v19; // edx@19
  __int16 v20; // ax@19
  int v21; // edx@19
  int result; // eax@19
  unsigned __int16 v23; // [sp+Ch] [bp-8h]@14
  int v24; // [sp+10h] [bp-4h]@13

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_1003BB60((unsigned __int8)byte_1008A428[3 * *(_WORD *)(v1 + 2550)], 0, 16, 0, v1 + 108, 64);
  sub_1003BB60((unsigned __int8)byte_1008A428[3 * *(_WORD *)(v1 + 2550)], 0, 15, 0, v1 + 4, 104);
  v2 = v1 + 1928;
  v3 = 6;
  if ( *(_BYTE *)(v1 + 138) == 1 )
  {
    v4 = v1 + 10;
    do
    {
      *(_DWORD *)(v2 - 4) = *(_WORD *)(v4 - 2);
      *(_DWORD *)v2 = *(_WORD *)v4;
      *(_DWORD *)(v2 + 92) = *(_WORD *)(v4 + 22);
      *(_DWORD *)(v2 + 96) = *(_WORD *)(v4 + 24);
      v2 += 8;
      v4 += 4;
      --v3;
    }
    while ( v3 );
  }
  else
  {
    v5 = v1 + 111;
    do
    {
      *(_DWORD *)(v2 - 4) = *(_BYTE *)(v5 - 1);
      *(_DWORD *)v2 = *(_BYTE *)v5;
      *(_DWORD *)(v2 + 92) = *(_BYTE *)(v5 + 13);
      *(_DWORD *)(v2 + 96) = *(_BYTE *)(v5 + 14);
      v2 += 8;
      v5 += 2;
      --v3;
    }
    while ( v3 );
  }
  v6 = v1 + 2120;
  v7 = 6;
  if ( *(_BYTE *)(v1 + 170) == 1 )
  {
    v8 = v1 + 62;
    do
    {
      *(_DWORD *)(v6 - 4) = *(_WORD *)(v8 - 2);
      *(_DWORD *)v6 = *(_WORD *)v8;
      *(_DWORD *)(v6 + 92) = *(_WORD *)(v8 + 22);
      *(_DWORD *)(v6 + 96) = *(_WORD *)(v8 + 24);
      v6 += 8;
      v8 += 4;
      --v7;
    }
    while ( v7 );
  }
  else
  {
    v9 = v1 + 143;
    do
    {
      *(_DWORD *)(v6 - 4) = *(_BYTE *)(v9 - 1);
      *(_DWORD *)v6 = *(_BYTE *)v9;
      *(_DWORD *)(v6 + 92) = *(_BYTE *)(v9 + 13);
      *(_DWORD *)(v6 + 96) = *(_BYTE *)(v9 + 14);
      v6 += 8;
      v9 += 2;
      --v7;
    }
    while ( v7 );
  }
  v24 = *(_WORD *)(v1 + 108);
  v10 = (double)v24;
  v24 = *(_WORD *)(v1 + 140);
  v11 = *(_WORD *)(v1 + 136);
  v12 = *(_WORD *)(v1 + 2550);
  *(float *)(v1 + 2344) = v10 / 100.0;
  v13 = (double)v24;
  v24 = v11;
  *(float *)(v1 + 2356) = v13 / 100.0;
  *(float *)(v1 + 2368) = (double)v24 / 100.0;
  if ( *(_BYTE *)((unsigned __int8)byte_1008A429[3 * v12] + v1 + 360) )
  {
    *(_BYTE *)(v1 + 2622) = 0;
    if ( sub_1002FB00(1, byte_1008A429[3 * v12], &v23) )
    {
      v24 = v23;
      *(_BYTE *)(v1 + 2622) = 3;
      *(float *)(v1 + 336) = (double)v24 / 100.0;
    }
    v24 = sub_1002F790(1, byte_1008A429[3 * *(_WORD *)(v1 + 2550)]);
    v14 = *(_WORD *)(v1 + 2550);
    *(float *)(v1 + 340) = (double)v24 / 100.0;
    v24 = (unsigned __int16)sub_1002F800(1, byte_1008A429[3 * v14]);
    v15 = *(_WORD *)(v1 + 2550);
    v16 = (double)v24;
    *(_BYTE *)(v1 + 2623) = 0;
    *(float *)(v1 + 344) = v16 / 100.0;
    if ( sub_1002FB00(2, byte_1008A429[3 * v15], &v23) )
    {
      v24 = v23;
      *(_BYTE *)(v1 + 2623) = 3;
      *(float *)(v1 + 348) = (double)v24 / 100.0;
    }
    v24 = sub_1002F790(2, byte_1008A429[3 * *(_WORD *)(v1 + 2550)]);
    v17 = *(_WORD *)(v1 + 2550);
    *(float *)(v1 + 352) = (double)v24 / 100.0;
    v24 = (unsigned __int16)sub_1002F800(2, byte_1008A429[3 * v17]);
    *(float *)(v1 + 356) = (double)v24 / 100.0;
  }
  v18 = *(_BYTE *)(v1 + 122);
  v19 = *(_BYTE *)(v1 + 139);
  *(_WORD *)(v1 + 394) = *(_BYTE *)(v1 + 138);
  v20 = *(_BYTE *)(v1 + 123);
  *(_DWORD *)(v1 + 2348) = v18;
  LOWORD(v18) = *(_BYTE *)(v1 + 170);
  *(_DWORD *)(v1 + 2352) = v19;
  v21 = *(_BYTE *)(v1 + 154);
  *(_WORD *)(v1 + 758) = v20;
  result = *(_BYTE *)(v1 + 171);
  *(_WORD *)(v1 + 1182) = v18;
  LOWORD(v18) = *(_BYTE *)(v1 + 155);
  *(_DWORD *)(v1 + 2360) = v21;
  *(_DWORD *)(v1 + 2364) = result;
  *(_WORD *)(v1 + 1546) = v18;
  return result;
}

//----- (1000AF30) --------------------------------------------------------
char __cdecl sub_1000AF30(int a1)
{
  int v1; // ecx@1
  int v2; // esi@1
  char v3; // bl@1
  char v4; // al@1
  signed int v5; // edi@1
  void *v6; // ecx@1
  int v7; // edx@2
  int v8; // ebx@5
  bool v9; // zf@5
  int v10; // eax@5
  double v11; // st7@5
  double v12; // st5@5
  double v13; // st7@7
  unsigned __int16 v14; // bp@17
  double v15; // st7@17
  char v16; // al@17
  float v17; // ST28_4@17
  double v18; // st7@17
  double v19; // st6@20
  int v20; // eax@33
  double v21; // st7@36
  unsigned __int16 v22; // bp@46
  double v23; // st7@46
  float v24; // ST28_4@46
  double v25; // st7@46
  unsigned __int16 v27; // [sp+10h] [bp-18h]@17
  __int16 v28; // [sp+10h] [bp-18h]@46
  int v29; // [sp+18h] [bp-10h]@1
  int v30; // [sp+1Ch] [bp-Ch]@1
  int v31; // [sp+20h] [bp-8h]@1
  __int16 v32; // [sp+24h] [bp-4h]@1
  float v33; // [sp+2Ch] [bp+4h]@5
  float v34; // [sp+2Ch] [bp+4h]@17
  float v35; // [sp+2Ch] [bp+4h]@20
  float v36; // [sp+2Ch] [bp+4h]@20
  float v37; // [sp+2Ch] [bp+4h]@46
  float v38; // [sp+2Ch] [bp+4h]@49
  float v39; // [sp+2Ch] [bp+4h]@49

  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 12);
  v3 = 3;
  v4 = sub_10038400(byte_1008A428[3 * *(_WORD *)(*(_DWORD *)(v1 + 12) + 2550)]);
  v5 = sub_10038310(v4);
  *(_BYTE *)(v2 + 172) = 1;
  if ( sub_10037130(v6) == v5 )
  {
    LOWORD(v29) = sub_1006BC30();
    LOWORD(v31) = j_HWM_pvg_get_frmt_adc(10);
    HIWORD(v30) = j_HWM_pvg_get_frmt_adc(9);
    v32 = j_HWM_pvg_get_frmt_adc(18);
    HIWORD(v31) = j_HWM_pvg_get_frmt_adc(17);
    HIWORD(v29) = j_HWM_pvg_get_anlg_outp(3);
    LOWORD(v30) = sub_1006C2E0();
  }
  else if ( !sub_100384B0(byte_1008A428[3 * *(_WORD *)(v2 + 2550)], &v29) )
  {
    v3 = 0;
    *(_BYTE *)(v2 + 172) = 0;
  }
  LOBYTE(v7) = v3;
  BYTE1(v7) = v3;
  v8 = v7 << 16;
  LOWORD(v8) = v7;
  *(_DWORD *)(v2 + 2566) = v8;
  v9 = *(_BYTE *)(v2 + 138) == 1;
  v10 = *(_BYTE *)(v2 + 123);
  v11 = 100.0;
  *(float *)(v2 + 1852) = (double)(unsigned __int16)v29 / 100.0;
  v33 = (double)(unsigned __int16)v30 / 100.0;
  *(float *)(v2 + 1872) = v33;
  v12 = 2.0;
  if ( v9 )
  {
    *(float *)(v2 + 1856) = v33;
    switch ( v10 )
    {
      case 1:
        v13 = 2.0 * (double)SHIWORD(v30);
        break;
      case 2:
        v13 = (double)SHIWORD(v30);
        break;
      case 3:
        v13 = 5.599999904632568 * (double)SHIWORD(v30);
        break;
      case 4:
        v13 = (double)(signed __int16)v31;
        break;
      case 5:
        v13 = 2.0 * (double)SHIWORD(v31);
        break;
      case 6:
        v13 = (double)SHIWORD(v31);
        break;
      case 7:
        v13 = 5.599999904632568 * (double)SHIWORD(v31);
        break;
      case 8:
        v13 = (double)v32;
        break;
      case 9:
        v13 = sub_100094B0(v5, *(_BYTE *)(v2 + 188));
        break;
      default:
        v13 = 0.0;
        break;
    }
    v34 = v13;
    v14 = *(_WORD *)(v2 + 6);
    v27 = *(_WORD *)(v2 + 4);
    v15 = sub_100094B0(v5, 0);
    v16 = *(_BYTE *)(v2 + 123);
    v17 = v15;
    v18 = v17;
    *(float *)(v2 + 1848) = v17;
    if ( v16 != 9 && v16 )
    {
      if ( v27 < v14 )
      {
        v35 = (v34 - (double)v27) / (double)(v14 - v27) * 100.0;
        v36 = v35 * 2.0 - 100.0;
        *(float *)(v2 + 1848) = v18 + v36;
        v19 = 5.599999904632568;
        v12 = 2.0;
        v11 = 100.0;
        goto LABEL_33;
      }
    }
    else
    {
      *(float *)(v2 + 1848) = v18 + v34;
    }
    v11 = 100.0;
    v12 = 2.0;
    v19 = 5.599999904632568;
  }
  else
  {
    switch ( v10 )
    {
      case 0:
        v19 = 5.599999904632568;
        *(float *)(v2 + 1856) = v33;
        break;
      case 1:
        v19 = 5.599999904632568;
        *(float *)(v2 + 1856) = (double)SHIWORD(v30) * 2.0 / 100.0;
        break;
      case 2:
        v19 = 5.599999904632568;
        *(float *)(v2 + 1856) = (double)SHIWORD(v30) / 100.0;
        break;
      case 3:
        v19 = 5.599999904632568;
        *(float *)(v2 + 1856) = (double)SHIWORD(v30) * 5.599999904632568 / 100.0;
        break;
      case 4:
        v19 = 5.599999904632568;
        *(float *)(v2 + 1856) = (double)(signed __int16)v31 / 100.0;
        break;
      case 5:
        v19 = 5.599999904632568;
        *(float *)(v2 + 1856) = (double)SHIWORD(v31) * 2.0 / 100.0;
        break;
      case 6:
        v19 = 5.599999904632568;
        *(float *)(v2 + 1856) = (double)SHIWORD(v31) / 100.0;
        break;
      case 7:
        v19 = 5.599999904632568;
        *(float *)(v2 + 1856) = (double)SHIWORD(v31) * 5.599999904632568 / 100.0;
        break;
      case 8:
        v19 = 5.599999904632568;
        *(float *)(v2 + 1856) = (double)v32 / 100.0;
        break;
      default:
        v19 = 5.599999904632568;
        break;
    }
  }
LABEL_33:
  v9 = *(_BYTE *)(v2 + 170) == 1;
  v20 = *(_BYTE *)(v2 + 155);
  *(float *)(v2 + 1864) = (double)HIWORD(v29) / v11;
  if ( v9 )
  {
    *(float *)(v2 + 1868) = *(float *)(v2 + 1872);
    switch ( v20 )
    {
      case 1:
        v21 = v12 * (double)SHIWORD(v30);
        break;
      case 2:
        v21 = (double)SHIWORD(v30);
        break;
      case 3:
        v21 = v19 * (double)SHIWORD(v30);
        break;
      case 4:
        v21 = (double)(signed __int16)v31;
        break;
      case 5:
        v21 = v12 * (double)SHIWORD(v31);
        break;
      case 6:
        v21 = (double)SHIWORD(v31);
        break;
      case 7:
        v21 = v19 * (double)SHIWORD(v31);
        break;
      case 8:
        v21 = (double)v32;
        break;
      case 9:
        v21 = sub_100094B0(v5, *(_BYTE *)(v2 + 188));
        break;
      default:
        v21 = 0.0;
        break;
    }
    v37 = v21;
    v22 = *(_WORD *)(v2 + 58);
    v28 = *(_WORD *)(v2 + 56);
    v23 = sub_100094B0(v5, 0);
    LOBYTE(v20) = *(_BYTE *)(v2 + 155);
    v24 = v23;
    v25 = v24;
    *(float *)(v2 + 1860) = v24;
    if ( (_BYTE)v20 != 9 && (_BYTE)v20 )
    {
      LOBYTE(v20) = v28;
      if ( v28 != v22 )
      {
        LOWORD(v20) = v28;
        v38 = (v37 - (double)(unsigned __int16)v20) / (double)(v22 - (unsigned __int16)v20) * 100.0;
        v39 = v38 + v38 - 100.0;
        *(float *)(v2 + 1860) = v25 + v39;
      }
    }
    else
    {
      *(float *)(v2 + 1860) = v25 + v37;
    }
  }
  else
  {
    switch ( v20 )
    {
      case 0:
        *(float *)(v2 + 1868) = *(float *)(v2 + 1872);
        break;
      case 1:
        *(float *)(v2 + 1868) = v12 * (double)SHIWORD(v30) / v11;
        break;
      case 2:
        LOBYTE(v20) = BYTE2(v30);
        *(float *)(v2 + 1868) = (double)SHIWORD(v30) / v11;
        break;
      case 3:
        *(float *)(v2 + 1868) = v19 * (double)SHIWORD(v30) / v11;
        break;
      case 4:
        *(float *)(v2 + 1868) = (double)(signed __int16)v31 / v11;
        break;
      case 5:
        LOBYTE(v20) = BYTE2(v31);
        *(float *)(v2 + 1868) = v12 * (double)SHIWORD(v31) / v11;
        break;
      case 6:
        *(float *)(v2 + 1868) = (double)SHIWORD(v31) / v11;
        break;
      case 7:
        *(float *)(v2 + 1868) = v19 * (double)SHIWORD(v31) / v11;
        break;
      case 8:
        LOBYTE(v20) = v32;
        *(float *)(v2 + 1868) = (double)v32 / v11;
        break;
      default:
        return v20;
    }
  }
  return v20;
}
// 100094B0: using guessed type double __cdecl sub_100094B0(char, char);
// 1006BAF0: using guessed type int __cdecl j_HWM_pvg_get_anlg_outp(_DWORD);
// 1006BB10: using guessed type int __cdecl j_HWM_pvg_get_frmt_adc(_DWORD);

//----- (1000B680) --------------------------------------------------------
void *__usercall sub_1000B680@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ecx@1
  float v3; // ST28_4@2
  double v4; // st7@2
  signed int v5; // edx@2
  float v6; // ST28_4@2
  double v7; // st7@2
  int v8; // eax@2
  int v9; // ecx@2
  __int16 v10; // dx@2
  int v11; // eax@2
  signed int v12; // edx@2
  int v13; // eax@8
  void *result; // eax@8
  bool v15; // zf@8
  int v16; // [sp+14h] [bp-8h]@0

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  LOBYTE(v16) = 0;
  if ( sub_1003BB60((unsigned __int8)byte_1008A428[3 * *(_WORD *)(v1 + 2550)], 0, 16, 0, v1 + 2290, 44) )
  {
    LOBYTE(v16) = 3;
    v3 = (double)*(_WORD *)(v1 + 2330) * 0.09775171428918839;
    v4 = sub_10022C70(v3, 0.1);
    v5 = *(_WORD *)(v1 + 2332);
    *(float *)(v1 + 2268) = v4;
    *(_DWORD *)(v1 + 2272) = *(_BYTE *)(v1 + 2291);
    v6 = (double)v5 * 0.09775171428918839;
    v7 = sub_10022C70(v6, 0.1);
    v8 = *(_BYTE *)(v1 + 2294);
    *(float *)(v1 + 2276) = v7;
    v9 = *(_BYTE *)(v1 + 2290);
    v10 = *(_BYTE *)(v1 + 2292);
    *(_DWORD *)(v1 + 2280) = v8;
    LOWORD(v8) = *(_BYTE *)(v1 + 2295);
    *(_DWORD *)(v1 + 2284) = v9;
    *(_WORD *)(v1 + 558) = v10;
    *(_WORD *)(v1 + 1346) = v8;
    v11 = v1 + 1928;
    v2 = v1 + 2299;
    v12 = 4;
    do
    {
      *(_DWORD *)(v11 - 4) = *(_BYTE *)(v2 - 1);
      *(_DWORD *)v11 = *(_BYTE *)v2;
      *(_DWORD *)(v11 + 92) = *(_BYTE *)(v2 + 7);
      *(_DWORD *)(v11 + 96) = *(_BYTE *)(v2 + 8);
      *(_DWORD *)(v11 + 188) = *(_BYTE *)(v2 + 15);
      *(_DWORD *)(v11 + 192) = *(_BYTE *)(v2 + 16);
      *(_DWORD *)(v11 + 284) = *(_BYTE *)(v2 + 23);
      *(_DWORD *)(v11 + 288) = *(_BYTE *)(v2 + 24);
      v11 += 8;
      v2 += 2;
      --v12;
    }
    while ( v12 );
  }
  else if ( !*(_BYTE *)(v1 + 2338) && *(_BYTE *)(v1 + 2334) != 4 )
  {
    *(_BYTE *)(v1 + 2334) = 1;
  }
  LOBYTE(v2) = v16;
  BYTE1(v2) = v16;
  v13 = v2 << 16;
  LOWORD(v13) = v2;
  *(_DWORD *)(v1 + 2638) = v13;
  *(_WORD *)(v1 + 2642) = v2;
  *(_BYTE *)(v1 + 2644) = v16;
  result = memset((void *)(v1 + 2574), v16, 0x2Eu);
  v15 = *(_BYTE *)(v1 + 2337) == 0;
  *(_BYTE *)(v1 + 2578) = 0;
  *(_BYTE *)(v1 + 2579) = 0;
  *(_BYTE *)(v1 + 2584) = 0;
  *(_BYTE *)(v1 + 2585) = 0;
  *(_BYTE *)(v1 + 2590) = 0;
  *(_BYTE *)(v1 + 2591) = 0;
  *(_BYTE *)(v1 + 2596) = 0;
  *(_BYTE *)(v1 + 2597) = 0;
  *(_BYTE *)(v1 + 2602) = 0;
  *(_BYTE *)(v1 + 2603) = 0;
  *(_BYTE *)(v1 + 2608) = 0;
  *(_BYTE *)(v1 + 2609) = 0;
  *(_BYTE *)(v1 + 2614) = 0;
  *(_BYTE *)(v1 + 2615) = 0;
  *(_BYTE *)(v1 + 2620) = 0;
  *(_BYTE *)(v1 + 2621) = 0;
  if ( !v15 )
  {
    *(_WORD *)v1 = 1515;
    *(_BYTE *)(v1 + 2337) = 0;
    *(_BYTE *)(v1 + 2636) = 0;
    *(_BYTE *)(v1 + 2637) = 0;
  }
  return result;
}

//----- (1000B8B0) --------------------------------------------------------
int __cdecl sub_1000B8B0(int a1)
{
  int v1; // esi@1
  char v2; // bl@1
  int v3; // edx@1
  float v4; // ST10_4@2
  float v5; // ST10_4@2
  float v6; // ST10_4@2
  float v7; // ST10_4@2
  int result; // eax@6
  int v9; // ecx@6
  int v10; // ebx@6
  signed int v11; // edx@6
  unsigned __int16 v12; // [sp+14h] [bp-18h]@1
  unsigned __int16 v13; // [sp+18h] [bp-14h]@2
  char v14; // [sp+1Ch] [bp-10h]@2
  unsigned __int16 v15; // [sp+20h] [bp-Ch]@2
  unsigned __int16 v16; // [sp+24h] [bp-8h]@2

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = 0;
  if ( sub_1003C2C0(byte_1008A428[3 * *(_WORD *)(v1 + 2550)], &v12) )
  {
    v4 = (double)v12 * 0.09775171428918839;
    *(float *)(v1 + 1852) = sub_10022C70(v4, 0.1);
    v5 = (double)v15 * 0.09775171428918839;
    *(float *)(v1 + 1856) = sub_10022C70(v5, 0.1);
    v6 = (double)v13 * 0.09775171428918839;
    *(float *)(v1 + 1864) = sub_10022C70(v6, 0.1);
    v7 = (double)v16 * 0.09775171428918839;
    *(float *)(v1 + 1868) = sub_10022C70(v7, 0.1);
    *(_BYTE *)(v1 + 2335) = 1;
    *(_BYTE *)(v1 + 2336) = v14;
    if ( v14 )
      *(float *)(v1 + 1872) = *(float *)(v1 + 1856);
    v2 = 3;
  }
  else
  {
    *(_BYTE *)(v1 + 2335) = 0;
    *(_BYTE *)(v1 + 2336) = 0;
  }
  LOBYTE(v3) = v2;
  BYTE1(v3) = v2;
  result = v1 + 1880;
  v9 = v1 + 111;
  v10 = v3 << 16;
  LOWORD(v10) = v3;
  v11 = 6;
  *(_DWORD *)(v1 + 2566) = v10;
  do
  {
    *(_DWORD *)(result - 4) = *(_BYTE *)(v9 - 1);
    *(_DWORD *)result = *(_BYTE *)v9;
    *(_DWORD *)(result + 92) = *(_BYTE *)(v9 + 13);
    *(_DWORD *)(result + 96) = *(_BYTE *)(v9 + 14);
    *(_DWORD *)(result + 188) = *(_BYTE *)(v9 + 31);
    *(_DWORD *)(result + 192) = *(_BYTE *)(v9 + 32);
    *(_DWORD *)(result + 284) = *(_BYTE *)(v9 + 45);
    *(_DWORD *)(result + 288) = *(_BYTE *)(v9 + 46);
    result += 8;
    v9 += 2;
    --v11;
  }
  while ( v11 );
  return result;
}

//----- (1000BA80) --------------------------------------------------------
int __usercall sub_1000BA80@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ecx@1
  int v3; // edx@1
  char v4; // al@1
  int v5; // eax@1
  signed int v6; // ecx@1
  int v7; // eax@1
  signed int v8; // ST20_4@1
  int v9; // ecx@1
  signed int v10; // eax@1
  int v11; // edx@1
  float v12; // ST24_4@1
  double v13; // st7@1
  signed int v14; // edx@1
  __int16 v15; // cx@1
  float v16; // ST24_4@1
  double v17; // st7@1
  signed int v18; // edx@1
  int result; // eax@1
  __int16 v20; // cx@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_1003BB60((unsigned __int8)byte_1008A428[3 * *(_WORD *)(v1 + 2550)], 1, 16, 0, v1 + 2290, 44);
  v2 = *(_DWORD *)(v1 + 2302);
  v3 = *(_DWORD *)(v1 + 2306);
  *(_DWORD *)(v1 + 110) = *(_DWORD *)(v1 + 2298);
  v4 = *(_BYTE *)(v1 + 2291);
  *(_DWORD *)(v1 + 114) = v2;
  LOBYTE(v2) = *(_BYTE *)(v1 + 2292);
  *(_BYTE *)(v1 + 122) = v4;
  v5 = *(_DWORD *)(v1 + 2318);
  *(_DWORD *)(v1 + 118) = v3;
  *(_DWORD *)(v1 + 142) = *(_DWORD *)(v1 + 2314);
  LOBYTE(v3) = *(_BYTE *)(v1 + 2294);
  *(_DWORD *)(v1 + 146) = v5;
  LOBYTE(v5) = *(_BYTE *)(v1 + 2295);
  *(_BYTE *)(v1 + 123) = v2;
  *(_DWORD *)(v1 + 150) = *(_DWORD *)(v1 + 2322);
  *(_DWORD *)(v1 + 124) = *(_DWORD *)(v1 + 2306);
  v6 = *(_BYTE *)(v1 + 2290);
  *(_BYTE *)(v1 + 155) = v5;
  v7 = *(_DWORD *)(v1 + 2314);
  *(_BYTE *)(v1 + 154) = v3;
  v8 = v6;
  *(_DWORD *)(v1 + 128) = *(_DWORD *)(v1 + 2310);
  *(_DWORD *)(v1 + 132) = v7;
  v9 = *(_DWORD *)(v1 + 2326);
  *(_DWORD *)(v1 + 156) = *(_DWORD *)(v1 + 2322);
  v10 = *(_BYTE *)(v1 + 2293);
  *(_DWORD *)(v1 + 160) = v9;
  *(_WORD *)(v1 + 136) = (signed int)((double)v8 * 100.0);
  v11 = *(_DWORD *)(v1 + 2330);
  *(_DWORD *)(v1 + 164) = v11;
  *(_WORD *)(v1 + 168) = (signed int)(100.0 * (double)v10);
  v12 = (double)(unsigned __int16)v11 * 0.09775171428918839;
  v13 = sub_10022C70(v12, 0.1);
  v14 = *(_WORD *)(v1 + 2332);
  *(float *)(v1 + 2344) = v13;
  v15 = *(_BYTE *)(v1 + 123);
  *(_DWORD *)(v1 + 2348) = *(_BYTE *)(v1 + 122);
  *(_WORD *)(v1 + 758) = v15;
  v16 = (double)v14 * 0.09775171428918839;
  v17 = sub_10022C70(v16, 0.1);
  v18 = *(_WORD *)(v1 + 136);
  *(float *)(v1 + 2356) = v17;
  result = *(_BYTE *)(v1 + 154);
  v20 = *(_BYTE *)(v1 + 155);
  *(_DWORD *)(v1 + 2360) = result;
  *(_WORD *)(v1 + 1546) = v20;
  *(float *)(v1 + 2368) = (double)v18 / 100.0;
  return result;
}

//----- (1000BCA0) --------------------------------------------------------
int __usercall sub_1000BCA0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ebp@1
  __int16 v3; // ax@1
  int v4; // ebx@1
  __int16 v5; // dx@8
  __int16 v6; // ax@8
  __int16 v7; // cx@8
  signed int v8; // edi@9
  signed int v9; // eax@11
  int v10; // ecx@11
  __int16 v11; // ax@13
  signed int v12; // eax@20
  int v13; // ecx@20
  __int16 v14; // ax@22
  int v15; // ecx@26
  int v16; // edi@34
  int v17; // ebx@34
  int v18; // edi@37
  int v19; // ebx@37
  int v20; // edx@40
  signed int v21; // eax@43
  int v22; // ecx@43
  __int16 v23; // ax@45
  int v24; // edi@50
  int v25; // edi@54
  int v26; // edi@64
  signed int v27; // edi@65
  int v28; // eax@73
  signed int v29; // eax@81
  int v30; // ecx@81
  __int16 v31; // ax@83
  signed int v32; // eax@88
  int v33; // ecx@88
  __int16 v34; // ax@90
  int v35; // ecx@94
  int v36; // edi@102
  int v37; // ebx@102
  int v38; // ebx@104
  int v39; // edi@105
  int v40; // edi@108
  int v41; // edi@111
  int v42; // ebx@111
  int v43; // eax@116
  int v44; // edi@122
  signed int v45; // edi@123
  _WORD *v46; // ST68_4@131
  char v48; // [sp+11h] [bp-2Bh]@1
  char v49; // [sp+12h] [bp-2Ah]@1
  char v50; // [sp+13h] [bp-29h]@3
  signed int v51; // [sp+14h] [bp-28h]@9
  int v52; // [sp+18h] [bp-24h]@1
  int v53; // [sp+1Ch] [bp-20h]@1
  int v54; // [sp+20h] [bp-1Ch]@1
  int v55; // [sp+20h] [bp-1Ch]@105
  signed int v56; // [sp+24h] [bp-18h]@9
  int v57; // [sp+28h] [bp-14h]@8
  __int16 v58; // [sp+30h] [bp-Ch]@8
  __int16 v59; // [sp+32h] [bp-Ah]@8
  __int16 v60; // [sp+34h] [bp-8h]@8
  __int16 v61; // [sp+36h] [bp-6h]@8

  v1 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v3 = *(_WORD *)(v2 + 2550);
  LOWORD(v4) = 0;
  v53 = 0;
  v48 = 0;
  v49 = 0;
  v52 = 0;
  v54 = 0;
  if ( v3 < 7 || v3 > 21 )
  {
    v50 = 0;
    if ( *(_BYTE *)(v2 + 138) == 1 )
      v48 = 1;
    if ( *(_BYTE *)(v2 + 170) == 1 )
      v49 = 1;
  }
  else
  {
    v50 = 1;
  }
  v5 = *(_WORD *)(v1 + 416);
  v6 = *(_WORD *)(v1 + 422);
  v58 = *(_WORD *)(v1 + 418);
  v7 = *(_WORD *)(v1 + 420);
  *(_WORD *)(v1 + 428) = 0;
  *(_WORD *)(v1 + 430) = 0;
  *(_WORD *)(v1 + 440) = 0;
  *(_WORD *)(v1 + 442) = 0;
  *(_WORD *)(v1 + 396) = 3;
  v59 = v5;
  v60 = v6;
  v61 = v7;
  v57 = v1 + 392;
  sub_1001EC10(v1 + 392, 685, 123, 266, 266, 1);
  sub_1001EC10(v1 + 392, 685, 448, 266, 266, 1);
  sub_1001C300(v1 + 392, 685, 123, 266, 266);
  sub_100093A0(8, v1, 2, 690, 384, 946, 384);
  sub_100093A0(8, v1, 2, 691, 384, 691, 128);
  if ( v50 )
  {
    v8 = 4;
    v51 = 4;
    v56 = 5;
    if ( !*(_BYTE *)(v2 + 2335) )
      goto LABEL_32;
LABEL_10:
    if ( v48 )
    {
LABEL_20:
      v12 = (signed int)(*(float *)(v2 + 1852) * 2.559999942779541);
      v13 = 384 - v12;
      if ( 384 - v12 > 384 )
        goto LABEL_137;
      if ( v13 < 128 )
      {
        v14 = 128;
        goto LABEL_26;
      }
      if ( v13 <= 384 )
        v14 = 384 - v12;
      else
LABEL_137:
        v14 = 384;
LABEL_26:
      sub_100093A0(12, v1, 1, 690, v14, 946, v14);
      v15 = 690 - (signed int)(*(float *)(v2 + 1856) * -2.559999942779541);
      if ( v15 >= 690 )
      {
        if ( v15 > 946 )
        {
          LOWORD(v15) = 946;
LABEL_31:
          sub_100093A0(14, v1, 1, v15, 384, v15, 128);
          goto LABEL_32;
        }
        if ( v15 >= 690 )
          goto LABEL_31;
      }
      LOWORD(v15) = 690;
      goto LABEL_31;
    }
    v9 = (signed int)(*(float *)(v2 + 2344) * 2.559999942779541);
    v10 = 384 - v9;
    if ( 384 - v9 <= 384 )
    {
      if ( v10 < 128 )
      {
        v11 = 128;
LABEL_19:
        sub_100093A0(10, v1, 1, 690, v11, 946, v11);
        goto LABEL_20;
      }
      if ( v10 <= 384 )
      {
        v11 = 384 - v9;
        goto LABEL_19;
      }
    }
    v11 = 384;
    goto LABEL_19;
  }
  v8 = 6;
  v51 = 6;
  v56 = 7;
  if ( *(_BYTE *)(v2 + 172) )
    goto LABEL_10;
LABEL_32:
  if ( v48 )
  {
    if ( v8 > 1 )
    {
      v16 = v2 + 10;
      v17 = v51 - 1;
      do
      {
        sub_100093A0(
          11,
          v1,
          1,
          690 - (signed int)(-0.2560000121593475 * (double)*(_WORD *)(v16 - 2)),
          384 - (signed int)(0.2560000121593475 * (double)*(_WORD *)v16),
          690 - (signed int)((double)*(_WORD *)(v16 + 2) * -0.2560000121593475),
          384 - (signed int)((double)*(_WORD *)(v16 + 4) * 0.2560000121593475));
        v16 += 4;
        --v17;
      }
      while ( v17 );
    }
    v53 = v2 + 32;
    if ( v51 > 1 )
    {
      v18 = v2 + 34;
      v19 = v51 - 1;
      do
      {
        sub_100093A0(
          2,
          v1,
          1,
          690 - (signed int)(-0.2560000121593475 * (double)*(_WORD *)(v18 - 2)),
          384 - (signed int)(0.2560000121593475 * (double)*(_WORD *)v18),
          690 - (signed int)((double)*(_WORD *)(v18 + 2) * -0.2560000121593475),
          384 - (signed int)((double)*(_WORD *)(v18 + 4) * 0.2560000121593475));
        v18 += 4;
        --v19;
      }
      while ( v19 );
    }
    if ( *(_WORD *)(v2 + 1058) )
    {
      v20 = v2 + 1056;
      v53 = v2 + 8;
LABEL_62:
      v54 = v20;
      goto LABEL_63;
    }
    if ( *(_WORD *)(v2 + 1138) )
      v54 = v2 + 1136;
    goto LABEL_63;
  }
  if ( !*(_WORD *)(v2 + 758) )
  {
    v52 = v2 + 124;
    goto LABEL_53;
  }
  v52 = v2 + 110;
  v21 = (signed int)(*(float *)(v2 + 2368) * -2.559999942779541);
  v22 = 690 - v21;
  if ( 690 - v21 < 690 )
  {
LABEL_47:
    v23 = 690;
    goto LABEL_49;
  }
  if ( v22 <= 946 )
  {
    if ( v22 >= 690 )
    {
      v23 = 690 - v21;
      goto LABEL_49;
    }
    goto LABEL_47;
  }
  v23 = 946;
LABEL_49:
  sub_100093A0(13, v1, 1, v23, 384, v23, 128);
  if ( v8 <= 1 )
    goto LABEL_56;
  v24 = v2 + 126;
  v4 = v51 - 1;
  do
  {
    sub_100093A0(
      2,
      v1,
      1,
      690 - (signed int)(-2.559999942779541 * (double)*(_BYTE *)(v24 - 2)),
      384 - (signed int)(2.559999942779541 * (double)*(_BYTE *)(v24 - 1)),
      690 - (signed int)((double)*(_BYTE *)v24 * -2.559999942779541),
      384 - (signed int)((double)*(_BYTE *)(v24 + 1) * 2.559999942779541));
    v24 += 2;
    --v4;
  }
  while ( v4 );
  v8 = v51;
LABEL_53:
  if ( v8 > 1 )
  {
    v25 = v52 + 1;
    v4 = v51 - 1;
    do
    {
      sub_100093A0(
        11,
        v1,
        1,
        690 - (signed int)(-2.559999942779541 * (double)*(_BYTE *)(v25 - 1)),
        384 - (signed int)(2.559999942779541 * (double)*(_BYTE *)v25),
        690 - (signed int)((double)*(_BYTE *)(v25 + 1) * -2.559999942779541),
        384 - (signed int)((double)*(_BYTE *)(v25 + 2) * 2.559999942779541));
      v25 += 2;
      --v4;
    }
    while ( v4 );
  }
LABEL_56:
  if ( *(_WORD *)(v2 + 886) != (_WORD)v4 )
  {
    v54 = v2 + 884;
    goto LABEL_63;
  }
  if ( *(_WORD *)(v2 + 978) != (_WORD)v4 )
  {
    v20 = v2 + 976;
    v52 = v2 + 124;
    goto LABEL_62;
  }
LABEL_63:
  *(_BYTE *)(v2 + 2628) = 0;
  *(_BYTE *)(v2 + 2629) = 0;
  *(_BYTE *)(v2 + 2630) = 0;
  *(_BYTE *)(v2 + 2631) = 0;
  if ( v54 )
  {
    v26 = *(_WORD *)(v54 + 2);
    if ( v26 == v56 )
    {
      v27 = 0;
      if ( v48 )
      {
        if ( v51 > 0 )
        {
          do
          {
            sub_10009430(
              1,
              690 - (signed int)((double)*(_WORD *)(v53 + 4 * v27) * -0.2560000121593475),
              v1,
              384 - (signed int)((double)*(_WORD *)(v53 + 4 * v27 + 2) * 0.2560000121593475));
            ++v27;
          }
          while ( v27 < v51 );
        }
      }
      else if ( v51 > 0 )
      {
        do
        {
          sub_10009430(
            1,
            690 - (signed int)((double)*(_BYTE *)(v52 + 2 * v27) * -2.559999942779541),
            v1,
            384 - (signed int)((double)*(_BYTE *)(v52 + 2 * v27 + 1) * 2.559999942779541));
          ++v27;
        }
        while ( v27 < v51 );
      }
    }
    else
    {
      if ( v48 )
      {
        sub_10009430(
          1,
          690 - (signed int)((double)*(_WORD *)(v53 + 4 * v26 - 4) * -0.2560000121593475),
          v1,
          384 - (signed int)((double)*(_WORD *)(v53 + 4 * v26 - 2) * 0.2560000121593475));
        *(_DWORD *)(v2 + 2260) = *(_WORD *)(v53 + 4 * v26 - 4);
        v28 = *(_WORD *)(v53 + 4 * v26 - 2);
      }
      else
      {
        sub_10009430(
          1,
          690 - (signed int)((double)*(_BYTE *)(v52 + 2 * v26 - 2) * -2.559999942779541),
          v1,
          384 - (signed int)((double)*(_BYTE *)(v52 + 2 * v26 - 1) * 2.559999942779541));
        *(_DWORD *)(v2 + 2260) = *(_BYTE *)(v52 + 2 * v26 - 2);
        v28 = *(_BYTE *)(v52 + 2 * v26 - 1);
      }
      *(_DWORD *)(v2 + 2264) = v28;
      *(_BYTE *)(v2 + 2628) = 3;
      *(_BYTE *)(v2 + 2629) = 3;
      *(_BYTE *)(v2 + 2630) = 3;
      *(_BYTE *)(v2 + 2631) = 3;
    }
  }
  sub_1001C300(v57, 685, 448, 266, 266);
  sub_100093A0(8, v1, 2, 690, 709, 946, 709);
  sub_100093A0(8, v1, 2, 691, 709, 691, 453);
  if ( v50 )
  {
    if ( !*(_BYTE *)(v2 + 2335) )
      goto LABEL_100;
LABEL_80:
    if ( v49 )
    {
LABEL_88:
      v32 = (signed int)(*(float *)(v2 + 1864) * 2.559999942779541);
      v33 = 709 - v32;
      if ( 709 - v32 > 709 )
        goto LABEL_138;
      if ( v33 < 453 )
      {
        v34 = 453;
        goto LABEL_94;
      }
      if ( v33 <= 709 )
        v34 = 709 - v32;
      else
LABEL_138:
        v34 = 709;
LABEL_94:
      sub_100093A0(12, v1, 1, 690, v34, 946, v34);
      v35 = 690 - (signed int)(*(float *)(v2 + 1868) * -2.559999942779541);
      if ( v35 >= 690 )
      {
        if ( v35 > 946 )
        {
          LOWORD(v35) = 946;
LABEL_99:
          sub_100093A0(14, v1, 1, v35, 709, v35, 453);
          goto LABEL_100;
        }
        if ( v35 >= 690 )
          goto LABEL_99;
      }
      LOWORD(v35) = 690;
      goto LABEL_99;
    }
    v29 = (signed int)(*(float *)(v2 + 2356) * 2.559999942779541);
    v30 = 709 - v29;
    if ( 709 - v29 <= 709 )
    {
      if ( v30 < 453 )
      {
        v31 = 453;
LABEL_87:
        sub_100093A0(10, v1, 1, 690, v31, 946, v31);
        goto LABEL_88;
      }
      if ( v30 <= 709 )
      {
        v31 = 709 - v29;
        goto LABEL_87;
      }
    }
    v31 = 709;
    goto LABEL_87;
  }
  if ( *(_BYTE *)(v2 + 172) )
    goto LABEL_80;
LABEL_100:
  if ( v49 )
  {
    if ( v51 > 1 )
    {
      v36 = v2 + 62;
      v37 = v51 - 1;
      do
      {
        sub_100093A0(
          11,
          v1,
          1,
          690 - (signed int)(-0.2560000121593475 * (double)*(_WORD *)(v36 - 2)),
          709 - (signed int)(0.2560000121593475 * (double)*(_WORD *)v36),
          690 - (signed int)((double)*(_WORD *)(v36 + 2) * -0.2560000121593475),
          709 - (signed int)((double)*(_WORD *)(v36 + 4) * 0.2560000121593475));
        v36 += 4;
        --v37;
      }
      while ( v37 );
    }
    v38 = v2 + 84;
    if ( v51 > 1 )
    {
      v39 = v2 + 86;
      v55 = v51 - 1;
      do
      {
        sub_100093A0(
          2,
          v1,
          1,
          690 - (signed int)(-0.2560000121593475 * (double)*(_WORD *)(v39 - 2)),
          709 - (signed int)(0.2560000121593475 * (double)*(_WORD *)v39),
          690 - (signed int)((double)*(_WORD *)(v39 + 2) * -0.2560000121593475),
          709 - (signed int)((double)*(_WORD *)(v39 + 4) * 0.2560000121593475));
        v39 += 4;
        --v55;
      }
      while ( v55 );
    }
  }
  else
  {
    v40 = v2 + 156;
    if ( *(_WORD *)(v2 + 1546) )
      v40 = v2 + 142;
    v52 = v40;
    if ( v51 > 1 )
    {
      v41 = v40 + 1;
      v42 = v51 - 1;
      do
      {
        sub_100093A0(
          11,
          v1,
          1,
          690 - (signed int)(-2.559999942779541 * (double)*(_BYTE *)(v41 - 1)),
          709 - (signed int)(2.559999942779541 * (double)*(_BYTE *)v41),
          690 - (signed int)((double)*(_BYTE *)(v41 + 1) * -2.559999942779541),
          709 - (signed int)((double)*(_BYTE *)(v41 + 2) * 2.559999942779541));
        v41 += 2;
        --v42;
      }
      while ( v42 );
    }
    v38 = v53;
  }
  *(_BYTE *)(v2 + 2632) = 0;
  *(_BYTE *)(v2 + 2633) = 0;
  *(_BYTE *)(v2 + 2634) = 0;
  *(_BYTE *)(v2 + 2635) = 0;
  if ( v49 )
  {
    if ( *(_WORD *)(v2 + 1754) )
    {
      v43 = v2 + 1752;
      v38 = v2 + 60;
    }
    else
    {
      if ( !*(_WORD *)(v2 + 1834) )
        return sub_1001C300(v57, v58, v59, v60, v61);
      v43 = v2 + 1832;
    }
  }
  else
  {
    if ( !*(_WORD *)(v2 + 1674) )
      return sub_1001C300(v57, v58, v59, v60, v61);
    v43 = v2 + 1672;
  }
  if ( v43 )
  {
    v44 = *(_WORD *)(v43 + 2);
    if ( v44 == v56 )
    {
      v45 = 0;
      if ( v49 )
      {
        if ( v51 > 0 )
        {
          do
          {
            sub_10009430(
              1,
              690 - (signed int)((double)*(_WORD *)(v38 + 4 * v45) * -0.2560000121593475),
              v1,
              709 - (signed int)((double)*(_WORD *)(v38 + 4 * v45 + 2) * 0.2560000121593475));
            ++v45;
          }
          while ( v45 < v51 );
        }
      }
      else if ( v51 > 0 )
      {
        do
        {
          sub_10009430(
            1,
            690 - (signed int)((double)*(_BYTE *)(v52 + 2 * v45) * -2.559999942779541),
            v1,
            709 - (signed int)((double)*(_BYTE *)(v52 + 2 * v45 + 1) * 2.559999942779541));
          ++v45;
        }
        while ( v45 < v51 );
      }
    }
    else
    {
      if ( v49 )
      {
        v46 = (_WORD *)(v38 + 4 * v44 - 2);
        sub_10009430(
          1,
          690 - (signed int)((double)*(_WORD *)(v38 + 4 * v44 - 4) * -0.2560000121593475),
          v1,
          709 - (signed int)((double)*v46 * 0.2560000121593475));
        *(_DWORD *)(v2 + 2260) = *(_WORD *)(v38 + 4 * v44 - 4);
        *(_DWORD *)(v2 + 2264) = *v46;
      }
      else
      {
        sub_10009430(
          1,
          690 - (signed int)((double)*(_BYTE *)(v52 + 2 * v44 - 2) * -2.559999942779541),
          v1,
          709 - (signed int)((double)*(_BYTE *)(v52 + 2 * v44 - 1) * 2.559999942779541));
        *(_DWORD *)(v2 + 2260) = *(_BYTE *)(v52 + 2 * v44 - 2);
        *(_DWORD *)(v2 + 2264) = *(_BYTE *)(v52 + 2 * v44 - 1);
      }
      *(_BYTE *)(v2 + 2632) = 3;
      *(_BYTE *)(v2 + 2633) = 3;
      *(_BYTE *)(v2 + 2634) = 3;
      *(_BYTE *)(v2 + 2635) = 3;
    }
  }
  return sub_1001C300(v57, v58, v59, v60, v61);
}

//----- (1000CB70) --------------------------------------------------------
int __usercall sub_1000CB70@<eax>(int a1@<edi>)
{
  int v1; // esi@1
  int result; // eax@5

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(_BYTE *)(v1 + 2338) )
    sub_1000AA50(a1);
  if ( *(_BYTE *)(v1 + 186) )
    sub_1003CC80(56, 0);
  result = sub_100370D0(0);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (1000CBB0) --------------------------------------------------------
char __usercall sub_1000CBB0@<al>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // eax@5
  char v4; // al@7
  char result; // al@11

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 12);
  if ( !*(_BYTE *)(v1 + 230) )
  {
    if ( *(_BYTE *)(v2 + 2338) )
    {
      sub_1000AA50(a1);
      sub_10069880(1000);
      *(_BYTE *)(v2 + 2288) = 3;
      *(_BYTE *)(v2 + 2334) = 5;
    }
    else if ( *(_BYTE *)(v2 + 2334) == 5 )
    {
      v3 = sub_10069700();
      sub_10069880(*(_DWORD *)(v2 + 2340) - v3 + 1000 <= 0 ? 0 : *(_DWORD *)(v2 + 2340) - v3 + 1000);
    }
  }
  if ( *(_BYTE *)(v2 + 186) && (v4 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230), v4 != 5) && v4 != 17 && v4 != 8 && v4 != 22 )
  {
    result = sub_1003CC80(56, 0);
    *(_BYTE *)(v2 + 186) = 0;
  }
  else
  {
    result = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230);
    if ( result == 5 || result == 17 || result == 8 || result == 22 )
    {
      result = sub_1003CC80(56, 1);
      *(_BYTE *)(v2 + 186) = 1;
    }
  }
  return result;
}

//----- (1000CC90) --------------------------------------------------------
char __cdecl sub_1000CC90(int a1)
{
  int v1; // eax@1
  int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@1
  signed int v5; // ecx@1
  int v6; // eax@3
  signed int v7; // ecx@3
  char *v8; // edi@5
  char *v9; // ebp@5
  int v10; // edi@7
  char result; // al@9
  signed int v12; // [sp+10h] [bp-8h]@5
  unsigned __int8 v13; // [sp+1Ch] [bp+4h]@7

  v1 = sub_10003D50(a1, *(char **)(a1 + 56), 3252, 23);
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60);
  v3 = v1;
  sub_1006A0C0(6818, v1 + 188, 1);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  sub_10002870(a1, 0, 0, 1024, 768, 1);
  sub_100374D0(*(_DWORD *)(a1 + 56), (char *)&unk_1008ADA0);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 236) = 1;
  v4 = v3 + 194;
  v5 = 6;
  do
  {
    *(_BYTE *)(v4 - 1) = 0;
    *(_WORD *)v4 = 302;
    *(_DWORD *)(v4 + 6) = &unk_1008BC6C;
    *(_BYTE *)(v4 - 2) = 0;
    v4 += 16;
    --v5;
  }
  while ( v5 );
  *(_DWORD *)(v3 + 204) = v3 + 1848;
  *(_DWORD *)(v3 + 220) = v3 + 1852;
  *(_DWORD *)(v3 + 236) = v3 + 1856;
  *(_DWORD *)(v3 + 252) = v3 + 1860;
  *(_DWORD *)(v3 + 268) = v3 + 1864;
  *(_DWORD *)(v3 + 284) = v3 + 1868;
  *(_WORD *)(v3 + 196) = 335;
  *(_WORD *)(v3 + 212) = 173;
  *(_WORD *)(v3 + 228) = 146;
  *(_WORD *)(v3 + 244) = 669;
  *(_WORD *)(v3 + 260) = 507;
  *(_WORD *)(v3 + 276) = 480;
  v6 = v3 + 290;
  v7 = 3;
  do
  {
    *(_BYTE *)(v6 - 1) = 0;
    *(_WORD *)v6 = 302;
    *(_DWORD *)(v6 + 6) = &unk_1008BC7C;
    *(_BYTE *)(v6 - 2) = 0;
    v6 += 16;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(v3 + 316) = v3 + 2356;
  *(_DWORD *)(v3 + 332) = v3 + 2368;
  *(_DWORD *)(v3 + 2868) = v3 + 178;
  *(_DWORD *)(v3 + 2884) = v3 + 1924;
  *(_DWORD *)(v3 + 2896) = v3 + 1948;
  *(_DWORD *)(v3 + 2908) = v3 + 1928;
  *(_DWORD *)(v3 + 2920) = v3 + 1952;
  *(_DWORD *)(v3 + 2872) = v3 + 180;
  *(_DWORD *)(v3 + 2888) = v3 + 1932;
  *(_DWORD *)(v3 + 2892) = v3 + 1940;
  *(_DWORD *)(v3 + 2932) = v3 + 2020;
  *(_DWORD *)(v3 + 2900) = v3 + 1956;
  *(_DWORD *)(v3 + 2904) = v3 + 1964;
  *(_DWORD *)(v3 + 2936) = v3 + 2028;
  *(_DWORD *)(v3 + 2912) = v3 + 1936;
  *(_DWORD *)(v3 + 2916) = v3 + 1944;
  *(_DWORD *)(v3 + 2948) = v3 + 2052;
  *(_DWORD *)(v3 + 2924) = v3 + 1960;
  *(_DWORD *)(v3 + 2928) = v3 + 1968;
  *(_DWORD *)(v3 + 2960) = v3 + 2032;
  *(_DWORD *)(v3 + 2940) = v3 + 2036;
  *(_DWORD *)(v3 + 2944) = v3 + 2044;
  *(_DWORD *)(v3 + 2972) = v3 + 2056;
  *(_DWORD *)(v3 + 2952) = v3 + 2060;
  *(_DWORD *)(v3 + 2956) = v3 + 2024;
  *(_DWORD *)(v3 + 2876) = v3 + 182;
  *(_DWORD *)(v3 + 2964) = v3 + 2040;
  *(_DWORD *)(v3 + 2968) = v3 + 2048;
  *(_DWORD *)(v3 + 2980) = v3 + 2116;
  *(_DWORD *)(v3 + 2976) = v3 + 2064;
  *(_DWORD *)(v3 + 2984) = v3 + 2124;
  *(_DWORD *)(v3 + 2988) = v3 + 2132;
  *(_DWORD *)(v3 + 2992) = v3 + 2140;
  *(_DWORD *)(v3 + 2996) = v3 + 2148;
  *(_DWORD *)(v3 + 3000) = v3 + 2156;
  *(_WORD *)(v3 + 292) = 281;
  *(_DWORD *)(v3 + 300) = v3 + 2344;
  *(_WORD *)(v3 + 308) = 615;
  *(_DWORD *)(v3 + 328) = &unk_1008BCBC;
  *(_DWORD *)(v3 + 3004) = v3 + 2120;
  *(_DWORD *)(v3 + 3008) = v3 + 2128;
  *(_DWORD *)(v3 + 3012) = v3 + 2136;
  *(_DWORD *)(v3 + 3024) = v3 + 2160;
  *(_DWORD *)(v3 + 3020) = v3 + 2152;
  *(_DWORD *)(v3 + 2880) = v3 + 184;
  *(_DWORD *)(v3 + 3036) = v3 + 2228;
  *(_DWORD *)(v3 + 3016) = v3 + 2144;
  *(_DWORD *)(v3 + 3028) = v3 + 2212;
  *(_DWORD *)(v3 + 3048) = v3 + 2252;
  *(_DWORD *)(v3 + 3032) = v3 + 2220;
  *(_DWORD *)(v3 + 3040) = v3 + 2236;
  *(_DWORD *)(v3 + 3060) = v3 + 2232;
  *(_DWORD *)(v3 + 3044) = v3 + 2244;
  *(_DWORD *)(v3 + 3052) = v3 + 2216;
  *(_DWORD *)(v3 + 3072) = v3 + 2256;
  *(_DWORD *)(v3 + 3056) = v3 + 2224;
  *(_DWORD *)(v3 + 3064) = v3 + 2240;
  *(_DWORD *)(v3 + 3092) = v3 + 192;
  *(_DWORD *)(v3 + 3068) = v3 + 2248;
  *(_DWORD *)(v3 + 2852) = v3 + 208;
  *(_DWORD *)(v3 + 3076) = v3 + 336;
  *(_DWORD *)(v3 + 3096) = v3 + 240;
  *(_DWORD *)(v3 + 2856) = v3 + 224;
  *(_DWORD *)(v3 + 3080) = v3 + 348;
  *(_DWORD *)(v3 + 2844) = v3 + 174;
  *(_DWORD *)(v3 + 2860) = v3 + 256;
  *(_DWORD *)(v3 + 3108) = v3 + 2260;
  *(_DWORD *)(v3 + 3124) = v3 + 2260;
  *(_DWORD *)(v3 + 2864) = v3 + 272;
  *(_DWORD *)(v3 + 3084) = &unk_1008B9E0;
  *(_DWORD *)(v3 + 3100) = &unk_1008B9E8;
  *(_DWORD *)(v3 + 3104) = &unk_1008B9EC;
  *(_DWORD *)(v3 + 3112) = v3 + 2264;
  *(_DWORD *)(v3 + 3088) = &unk_1008B9E4;
  *(_DWORD *)(v3 + 2848) = v3 + 176;
  *(_DWORD *)(v3 + 3116) = &unk_1008B9E8;
  *(_DWORD *)(v3 + 3120) = &unk_1008B9EC;
  *(_DWORD *)(v3 + 3128) = v3 + 2264;
  memset((void *)(v3 + 4), 0, 0x68u);
  memset((void *)(v3 + 108), 0, 0x40u);
  memset((void *)(v3 + 1924), 0, 0x30u);
  memset((void *)(v3 + 2020), 0, 0x30u);
  memset((void *)(v3 + 2116), 0, 0x30u);
  memset((void *)(v3 + 2212), 0, 0x30u);
  memset((void *)(v3 + 2290), 0, 0x2Cu);
  *(_WORD *)(v3 + 174) = 1902;
  *(_WORD *)(v3 + 176) = 4106;
  *(_WORD *)(v3 + 178) = 5966;
  *(_WORD *)(v3 + 182) = 5966;
  *(_WORD *)(v3 + 180) = 5975;
  *(_WORD *)(v3 + 184) = 5975;
  *(float *)(v3 + 1848) = 0.0;
  *(float *)(v3 + 1852) = 0.0;
  *(float *)(v3 + 1872) = 0.0;
  *(float *)(v3 + 336) = 0.0;
  *(float *)(v3 + 348) = 0.0;
  *(float *)(v3 + 1860) = 0.0;
  *(float *)(v3 + 1864) = 0.0;
  *(float *)(v3 + 1868) = 0.0;
  memset((void *)(v3 + 2564), 3, 0x3Eu);
  *(_DWORD *)(v3 + 2628) = 0;
  *(_DWORD *)(v3 + 2632) = 0;
  memset((void *)(v3 + 3132), 3, 0x46u);
  *(_DWORD *)(v3 + 2680) = v3;
  *(_DWORD *)(v3 + 2684) = v3;
  *(_DWORD *)(v3 + 2716) = v3 + 1876;
  *(_DWORD *)(v3 + 2720) = v3 + 1884;
  *(_DWORD *)(v3 + 2724) = v3 + 1892;
  *(_DWORD *)(v3 + 2728) = v3 + 1900;
  *(_DWORD *)(v3 + 2732) = v3 + 1880;
  *(_DWORD *)(v3 + 2736) = v3 + 1888;
  *(_DWORD *)(v3 + 2740) = v3 + 1896;
  *(_DWORD *)(v3 + 2744) = v3 + 1904;
  *(_DWORD *)(v3 + 2748) = v3 + 1972;
  *(_DWORD *)(v3 + 2752) = v3 + 1980;
  *(_DWORD *)(v3 + 2756) = v3 + 1988;
  *(_DWORD *)(v3 + 2760) = v3 + 1996;
  *(_DWORD *)(v3 + 2764) = v3 + 1976;
  *(_DWORD *)(v3 + 2768) = v3 + 1984;
  *(_DWORD *)(v3 + 2772) = v3 + 1992;
  *(_DWORD *)(v3 + 2776) = v3 + 2000;
  *(_DWORD *)(v3 + 2688) = v3 + 2268;
  *(_DWORD *)(v3 + 2692) = v3 + 2272;
  *(_DWORD *)(v3 + 2696) = v3 + 556;
  *(_DWORD *)(v3 + 2700) = v3 + 2276;
  *(_DWORD *)(v3 + 2704) = v3 + 2280;
  *(_DWORD *)(v3 + 2708) = v3 + 1344;
  *(_DWORD *)(v3 + 2712) = v3 + 2284;
  *(_DWORD *)(v3 + 2780) = v3 + 2068;
  *(_DWORD *)(v3 + 2784) = v3 + 2076;
  *(_DWORD *)(v3 + 2788) = v3 + 2084;
  *(_DWORD *)(v3 + 2792) = v3 + 2092;
  *(_DWORD *)(v3 + 2796) = v3 + 2072;
  *(_DWORD *)(v3 + 2800) = v3 + 2080;
  *(_DWORD *)(v3 + 2804) = v3 + 2088;
  *(_DWORD *)(v3 + 2808) = v3 + 2096;
  *(_DWORD *)(v3 + 2812) = v3 + 2164;
  *(_DWORD *)(v3 + 2816) = v3 + 2172;
  *(_DWORD *)(v3 + 2820) = v3 + 2180;
  *(_DWORD *)(v3 + 2824) = v3 + 2188;
  *(_DWORD *)(v3 + 2828) = v3 + 2168;
  *(_DWORD *)(v3 + 2832) = v3 + 2176;
  *(_DWORD *)(v3 + 2836) = v3 + 2184;
  *(_DWORD *)(v3 + 2840) = v3 + 2192;
  memset((void *)(v3 + 1876), 0, 0x30u);
  memset((void *)(v3 + 1972), 0, 0x30u);
  memset((void *)(v3 + 2068), 0, 0x30u);
  memset((void *)(v3 + 2164), 0, 0x30u);
  *(float *)(v3 + 2268) = 0.0;
  *(_DWORD *)(v3 + 2272) = 0;
  *(float *)(v3 + 2276) = 0.0;
  *(_DWORD *)(v3 + 2280) = 0;
  *(_DWORD *)(v3 + 2284) = 0;
  *(_BYTE *)(v3 + 2) = 0;
  *(_WORD *)v3 = 5518;
  *(_BYTE *)(v3 + 3) = 0;
  *(_WORD *)(v3 + 558) = 0;
  *(_WORD *)(v3 + 1346) = 0;
  *(_DWORD *)(v3 + 2636) = 0;
  *(_DWORD *)(v3 + 2640) = 0;
  *(_BYTE *)(v3 + 2644) = 0;
  *(_DWORD *)(v3 + 2645) = 50529027;
  *(_DWORD *)(v3 + 2649) = 50529027;
  *(_DWORD *)(v3 + 2653) = 50529027;
  *(_DWORD *)(v3 + 2657) = 50529027;
  *(_DWORD *)(v3 + 2661) = 50529027;
  *(_DWORD *)(v3 + 2665) = 50529027;
  *(_DWORD *)(v3 + 2669) = 50529027;
  *(_DWORD *)(v3 + 2673) = 50529027;
  *(_DWORD *)(v2 + 20) = v3 + 288;
  *(_DWORD *)(v2 + 28) = v3 + 884;
  *(_DWORD *)(v2 + 24) = v3 + 344;
  *(_DWORD *)(v2 + 32) = v3 + 340;
  *(_DWORD *)(v2 + 52) = v3 + 1180;
  *(_DWORD *)(v2 + 56) = v3 + 1544;
  *(_DWORD *)(v2 + 60) = v3 + 2360;
  *(_DWORD *)(v2 + 64) = v3 + 2364;
  *(_DWORD *)(v2 + 68) = v3 + 304;
  *(_DWORD *)(v2 + 76) = v3 + 1672;
  *(_DWORD *)(v2 + 72) = v3 + 356;
  *(_DWORD *)(v2 + 88) = v3 + 352;
  *(_DWORD *)(v2 + 36) = v3 + 320;
  *(_DWORD *)(v2 + 40) = v3 + 976;
  *(_DWORD *)v2 = v3 + 2548;
  *(_DWORD *)(v2 + 44) = v3 + 1056;
  *(_DWORD *)(v2 + 48) = v3 + 1136;
  *(_DWORD *)(v2 + 4) = v3 + 392;
  *(_DWORD *)(v2 + 8) = v3 + 756;
  *(_DWORD *)(v2 + 80) = v3 + 1752;
  *(_DWORD *)(v2 + 12) = v3 + 2348;
  *(_DWORD *)(v2 + 16) = v3 + 2352;
  *(_DWORD *)(v2 + 84) = v3 + 1832;
  *(_DWORD *)(v3 + 2348) = 0;
  *(_DWORD *)(v3 + 2352) = 0;
  *(float *)(v3 + 2344) = 0.0;
  *(_WORD *)(v3 + 886) = 0;
  *(float *)(v3 + 344) = 0.0;
  *(float *)(v3 + 340) = 0.0;
  *(_DWORD *)(v3 + 2360) = 0;
  *(_DWORD *)(v3 + 2364) = 0;
  *(float *)(v3 + 2356) = 0.0;
  *(_WORD *)(v3 + 1674) = 0;
  *(float *)(v3 + 2368) = 0.0;
  *(_WORD *)(v3 + 978) = 0;
  *(_WORD *)(v3 + 1058) = 0;
  *(_WORD *)(v3 + 1138) = 0;
  *(_WORD *)(v3 + 1754) = 0;
  *(_WORD *)(v3 + 1834) = 0;
  v8 = (char *)&unk_1008BB94;
  v9 = (char *)(v3 + 360);
  v12 = 2;
  do
  {
    *v9++ = sub_1003C1D0(*v8++);
    --v12;
  }
  while ( v12 );
  v10 = a1;
  *(_BYTE *)(v3 + 362) = 0;
  *(_BYTE *)(v3 + 172) = 1;
  *(_BYTE *)(v3 + 173) = 0;
  *(_BYTE *)(v3 + 2288) = 0;
  *(_BYTE *)(v3 + 2372) = 0;
  *(_BYTE *)(v3 + 2334) = 0;
  *(_BYTE *)(v3 + 2335) = 0;
  *(_BYTE *)(v3 + 2336) = 0;
  *(_BYTE *)(v3 + 2337) = 0;
  *(_BYTE *)(v3 + 2338) = 0;
  *(_DWORD *)(v3 + 2340) = 0;
  *(_BYTE *)(v3 + 186) = 0;
  sub_10018E40(a1, &unk_1008A46C, 2u, 0, 0);
  sub_100370D0(1);
  *(_BYTE *)(v3 + 187) = 0;
  v13 = 0;
  do
    sub_10018700(v10, v13++, 2);
  while ( v13 < 2u );
  *(_WORD *)(v3 + 2550) = 0;
  sub_10009560(v10);
  sub_1000ABE0(v10);
  sub_10002D30(v10, *(_WORD **)(v10 + 52), (char *)&unk_1008AF70, v3 + 2844, 0, 255);
  sub_10002D30(
    v10,
    *(_WORD **)(v10 + 52),
    (char *)&unk_1008ADA0,
    *(_DWORD *)(*(_DWORD *)(v10 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(v10 + 56) + 230));
  result = sub_10004590(v10, *(_DWORD *)(v10 + 56), -32734);
  *(_BYTE *)(v10 + 6) = 2;
  return result;
}

//----- (1000D750) --------------------------------------------------------
char __usercall sub_1000D750@<al>(unsigned int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@2

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  switch ( *(_BYTE *)(v1 + 2334) )
  {
    case 0:
      v2 = *(_BYTE *)(v1 + 2338) == 0;
      *(_BYTE *)(v1 + 2636) = 0;
      *(_BYTE *)(v1 + 2637) = 0;
      *(_BYTE *)(v1 + 2334) = 3;
      if ( !v2 )
        *(_BYTE *)(v1 + 2334) = 2;
      break;
    case 1:
      sub_1003BEA0(byte_1008A428[3 * *(_WORD *)(v1 + 2550)], 16, 0);
      a1 = sub_10069700();
      *(_DWORD *)(v1 + 2340) = a1;
      *(_BYTE *)(v1 + 2288) = 3;
      *(_BYTE *)(v1 + 2334) = 5;
      break;
    case 2:
      *(_BYTE *)(v1 + 2636) = 3;
      *(_BYTE *)(v1 + 2637) = 3;
      sub_1000AA50(a1);
      a1 = sub_10069700();
      *(_BYTE *)(v1 + 2288) = 3;
      *(_DWORD *)(v1 + 2340) = a1;
      *(_BYTE *)(v1 + 2334) = 5;
      break;
    case 3:
      LOBYTE(a1) = (unsigned int)sub_1000B680(a1);
      v2 = *(_BYTE *)(v1 + 2338) == 0;
      *(_BYTE *)(v1 + 2334) = 2;
      if ( v2 )
        *(_BYTE *)(v1 + 2334) = 4;
      break;
    case 4:
      v2 = *(_BYTE *)(v1 + 2338) == 0;
      *(_BYTE *)(v1 + 2334) = 2;
      if ( v2 )
      {
        LOBYTE(a1) = sub_1000BA80(a1);
        *(_BYTE *)(v1 + 2334) = 0;
      }
      break;
    default:
      a1 = sub_10069700() - *(_DWORD *)(v1 + 2340);
      if ( a1 >= 0x3E8 )
      {
        LOBYTE(a1) = *(_BYTE *)(v1 + 2288);
        *(_BYTE *)(v1 + 2334) = a1;
      }
      break;
  }
  return a1;
}

//----- (1000D880) --------------------------------------------------------
void __usercall sub_1000D880(unsigned int a1@<esi>)
{
  int v1; // edi@1
  int v2; // ecx@3
  char v3; // [sp+4h] [bp-B8h]@5

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(_BYTE *)(v1 + 2338) )
  {
    sub_1000AA50(a1);
    *(_DWORD *)(v1 + 2340) = sub_10069700();
    *(_BYTE *)(v1 + 2288) = 3;
    *(_BYTE *)(v1 + 2334) = 5;
  }
  v2 = *(_DWORD *)(a1 + 52);
  if ( *(_BYTE *)(v2 + 8) )
  {
    if ( *(_BYTE *)(v2 + 8) == 1 )
    {
      sprintf(&v3, "Copy active settings?");
      sub_100163A0(a1, 1, &v3, 1);
    }
  }
  else
  {
    sprintf(&v3, "Activate parameter settings?");
    sub_100163A0(a1, 1, &v3, 0);
  }
}

//----- (1000D930) --------------------------------------------------------
bool __usercall sub_1000D930@<al>(unsigned int a1@<esi>)
{
  int v1; // ecx@1
  int v2; // edi@1
  __int16 v3; // ax@1
  char v4; // al@3
  char v5; // bl@4
  int v6; // eax@13
  int v7; // eax@21
  int v8; // eax@26
  int v9; // ecx@28
  int v10; // ecx@31
  int v11; // eax@33
  int v12; // eax@36
  int v13; // ecx@37
  int v14; // eax@39
  bool v15; // zf@40
  int v16; // ecx@41
  int v17; // eax@44
  double v18; // st7@57
  int v19; // edx@65
  int v20; // ecx@70
  unsigned __int8 v21; // bl@72
  int v22; // eax@74
  unsigned __int8 v23; // bl@78
  int v24; // eax@80
  char v26; // [sp+Bh] [bp-9h]@3
  char v27; // [sp+Ch] [bp-8h]@4
  char v28; // [sp+Dh] [bp-7h]@5
  char v29; // [sp+Eh] [bp-6h]@8
  char v30; // [sp+Fh] [bp-5h]@10
  unsigned __int8 v31; // [sp+10h] [bp-4h]@72
  unsigned __int8 v32; // [sp+10h] [bp-4h]@78

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 12);
  v3 = *(_WORD *)(v2 + 2550);
  if ( v3 < 7 || v3 > 21 )
  {
    v4 = 0;
    v26 = 0;
    if ( *(_BYTE *)(v2 + 138) == 1 )
    {
      v5 = 1;
      v27 = 1;
      goto LABEL_5;
    }
  }
  else
  {
    v26 = 1;
    v4 = 1;
  }
  v5 = 0;
  v27 = 0;
  if ( v4 )
  {
LABEL_6:
    v28 = 0;
    goto LABEL_7;
  }
LABEL_5:
  v28 = 1;
  if ( *(_BYTE *)(v2 + 170) != 1 )
    goto LABEL_6;
LABEL_7:
  if ( !*(_WORD *)(v2 + 758) || (v29 = 1, v5) )
    v29 = 0;
  v30 = 0;
  if ( v4 )
  {
    if ( v1 == *(_DWORD *)(a1 + 48) )
    {
      sub_1000B8B0(a1);
      sub_1000D750(a1);
    }
  }
  else
  {
    if ( !*(_BYTE *)(v2 + 173) )
    {
      sub_1000AF30(a1);
      sub_1000ABE0(a1);
    }
    v6 = *(_DWORD *)(v2 + 768);
    if ( v6 )
    {
      if ( v5 )
      {
        *(_WORD *)(v2 + 624) = 4752;
        *(_BYTE *)(v6 + 9) = 1;
        *(_WORD *)(v2 + 178) = 5963;
        *(_WORD *)(v2 + 180) = 5964;
      }
      else
      {
        *(_WORD *)(v2 + 624) = 5139;
        *(_BYTE *)(v6 + 9) = 0;
        *(_WORD *)(v2 + 178) = 5966;
        *(_WORD *)(v2 + 180) = 5975;
      }
    }
    v7 = *(_DWORD *)(v2 + 1556);
    if ( v7 )
    {
      v5 = v27;
      if ( v28 )
      {
        *(_WORD *)(v2 + 1412) = 4752;
        *(_BYTE *)(v7 + 9) = 1;
        *(_WORD *)(v2 + 182) = 5963;
        *(_WORD *)(v2 + 184) = 5964;
      }
      else
      {
        *(_WORD *)(v2 + 1412) = 5139;
        *(_BYTE *)(v7 + 9) = 0;
        *(_WORD *)(v2 + 182) = 5966;
        *(_WORD *)(v2 + 184) = 5975;
      }
    }
  }
  if ( v5 )
  {
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 11) = 3;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 12) = 3;
    *(_BYTE *)(v2 + 2626) = 3;
    *(_BYTE *)(v2 + 2624) = 3;
    v8 = *(_DWORD *)(a1 + 56);
    if ( *(_BYTE *)(*(_DWORD *)(v8 + 64) + 5) || *(_BYTE *)(*(_DWORD *)(v8 + 64) + 7) )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 246) = 1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 5) = 0;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 7) = 0;
      v9 = *(_DWORD *)(a1 + 56);
      if ( *(_BYTE *)(v9 + 230) == 5 || *(_BYTE *)(v9 + 230) == 7 )
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = 2;
    }
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 5) = 3;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 7) = 3;
    *(_BYTE *)(v2 + 2626) = 0;
    v10 = *(_DWORD *)(a1 + 56);
    if ( *(_BYTE *)(*(_DWORD *)(v10 + 64) + 11) || *(_BYTE *)(*(_DWORD *)(v10 + 64) + 12) )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 246) = 1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 11) = 0;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 12) = 0;
      v11 = *(_DWORD *)(a1 + 56);
      if ( *(_BYTE *)(v11 + 230) == 11 || *(_BYTE *)(v11 + 230) == 12 )
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = 2;
    }
  }
  v12 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 64);
  if ( v28 )
  {
    *(_BYTE *)(v12 + 20) = 3;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 21) = 3;
    *(_BYTE *)(v2 + 2627) = 3;
    *(_BYTE *)(v2 + 2625) = 3;
    v13 = *(_DWORD *)(a1 + 56);
    if ( *(_BYTE *)(*(_DWORD *)(v13 + 64) + 17) || *(_BYTE *)(*(_DWORD *)(v13 + 64) + 19) )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 246) = 1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 17) = 0;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 19) = 0;
      v14 = *(_DWORD *)(a1 + 56);
      if ( *(_BYTE *)(v14 + 230) != 17 )
      {
        v15 = *(_BYTE *)(v14 + 230) == 19;
        goto LABEL_46;
      }
      goto LABEL_47;
    }
  }
  else
  {
    *(_BYTE *)(v12 + 17) = 3;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 19) = 3;
    *(_BYTE *)(v2 + 2627) = 0;
    v16 = *(_DWORD *)(a1 + 56);
    if ( *(_BYTE *)(*(_DWORD *)(v16 + 64) + 20) || *(_BYTE *)(*(_DWORD *)(v16 + 64) + 21) || *(_BYTE *)(v2 + 2625) )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 246) = 1;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 20) = 0;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 21) = 0;
      *(_BYTE *)(v2 + 2625) = 0;
      v17 = *(_DWORD *)(a1 + 56);
      if ( *(_BYTE *)(v17 + 230) != 20 )
      {
        v15 = *(_BYTE *)(v17 + 230) == 21;
LABEL_46:
        if ( !v15 )
          goto LABEL_48;
      }
LABEL_47:
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = 14;
      goto LABEL_48;
    }
  }
LABEL_48:
  if ( v29 )
  {
    if ( v26 )
    {
      if ( *(_BYTE *)(v2 + 2336) )
        goto LABEL_57;
    }
    else
    {
      if ( !*(_BYTE *)(v2 + 2372) )
      {
        if ( *(float *)(v2 + 2368) * 100.0 <= *(float *)(v2 + 1856) * 100.0 )
          goto LABEL_58;
        goto LABEL_54;
      }
      if ( *(float *)(v2 + 1856) * 100.0 < *(float *)(v2 + 2368) * 100.0 + 100.0 )
      {
LABEL_54:
        if ( !*(_BYTE *)(v2 + 172) )
          goto LABEL_58;
LABEL_57:
        v18 = *(float *)(v2 + 1872);
        *(_BYTE *)(v2 + 2372) = 1;
        *(float *)(v2 + 1856) = v18;
        *(_BYTE *)(v2 + 2624) = 3;
        goto LABEL_62;
      }
    }
  }
LABEL_58:
  if ( *(_BYTE *)(v2 + 2624) )
  {
    if ( !*(_BYTE *)(v2 + 173) )
    {
      *(_BYTE *)(v2 + 2372) = 0;
      if ( !v5 )
      {
        *(_BYTE *)(v2 + 2624) = 0;
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 246) = 1;
      }
    }
  }
LABEL_62:
  if ( v29 )
  {
    v30 = 3;
  }
  else if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 9) )
  {
    *(_WORD *)(v2 + 978) = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 246) = 1;
    v19 = *(_DWORD *)(a1 + 56);
    if ( *(_BYTE *)(v19 + 230) == 9 || *(_BYTE *)(v19 + 230) == 10 )
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = 7;
  }
  if ( *(_BYTE *)(v2 + 2644) )
    *(_BYTE *)(v2 + 2644) = v30;
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 9) = v30;
  v20 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 64);
  *(_BYTE *)(v20 + 10) = v30;
  *(_BYTE *)(v2 + 173) = 0;
  if ( sub_10022FB0((void *)v20) )
  {
    if ( *(_BYTE *)(v2 + 187) )
    {
      v21 = 0;
      *(_BYTE *)(v2 + 187) = 0;
      v31 = 0;
      do
      {
        sub_10018700(a1, v31, 1);
        v31 = ++v21;
      }
      while ( v21 < 2u );
    }
    v22 = *(_DWORD *)(a1 + 56);
    if ( *(_BYTE *)(v22 + 230) )
    {
      *(_BYTE *)(v22 + 230) = -1;
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 231) = 0;
    }
  }
  else if ( v26 && !*(_BYTE *)(v2 + 187) )
  {
    v23 = 0;
    *(_BYTE *)(v2 + 187) = 1;
    v32 = 0;
    do
    {
      sub_10018700(a1, v32, 0);
      v32 = ++v23;
    }
    while ( v23 < 2u );
  }
  v24 = *(_DWORD *)(a1 + 56);
  if ( *(_BYTE *)(v24 + 246) )
  {
    *(_BYTE *)(v24 + 246) = 0;
    sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008A480, (int)&unk_1008B9F8, 0, 255);
  }
  sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008AF70, v2 + 2844, v2 + 2564, 255);
  sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008A4B8, (int)&unk_1008BA08, v2 + 3132, 255);
  if ( *(_BYTE *)((unsigned __int8)byte_1008A429[3 * *(_WORD *)(v2 + 2550)] + v2 + 360) )
    sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008A940, (int)&unk_1008BB24, 0, 255);
  if ( v27 )
    sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008AA08, (int)&off_1008BB68, 0, 255);
  else
    sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008A91C, (int)&off_1008BB50, 0, 255);
  if ( v28 )
    sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008AA3C, (int)&off_1008BB78, 0, 255);
  else
    sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008A9E4, (int)&off_1008BB5C, 0, 255);
  if ( v29 )
    sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008AA70, (int)&off_1008BB88, 0, 255);
  if ( v26 )
  {
    sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008AA98, (int)&off_1008BB98, 0, 255);
    sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008B4B0, v2 + 2680, v2 + 2636, 255);
  }
  sub_1000BCA0(a1);
  return sub_10002D30(
           a1,
           *(_WORD **)(a1 + 52),
           (char *)&unk_1008ADA0,
           *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
           *(_DWORD *)(*(_DWORD *)(a1 + 56) + 64),
           *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
}
// 1008BB50: using guessed type void *off_1008BB50;
// 1008BB5C: using guessed type void *off_1008BB5C;
// 1008BB68: using guessed type void *off_1008BB68;
// 1008BB78: using guessed type void *off_1008BB78;
// 1008BB88: using guessed type void *off_1008BB88;
// 1008BB98: using guessed type void *off_1008BB98;

//----- (1000E000) --------------------------------------------------------
char __usercall sub_1000E000@<al>(unsigned int a1@<edi>)
{
  int v1; // ecx@1
  int v2; // esi@1
  __int16 v3; // ax@1
  char v4; // al@4
  int v5; // ecx@4
  int v6; // eax@4
  int v7; // eax@44
  signed int v8; // ecx@44
  _DWORD *v9; // eax@46
  signed int v10; // ecx@46
  int v11; // eax@51
  signed int v12; // ecx@51
  _DWORD *v13; // eax@53
  signed int v14; // ecx@53
  char v15; // al@58
  char v17; // [sp+Bh] [bp-5h]@2
  unsigned __int8 v18; // [sp+Ch] [bp-4h]@48
  unsigned __int8 v19; // [sp+Ch] [bp-4h]@55

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 12);
  v3 = *(_WORD *)(v2 + 2550);
  if ( v3 < 7 || (v17 = 1, v3 > 21) )
    v17 = 0;
  v4 = sub_100375A0(a1, (char *)v1, *(_DWORD *)(a1 + 52));
  v5 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(a1 + 6) = v4;
  v6 = *(_BYTE *)(v5 + 230);
  switch ( v6 )
  {
    case 1:
      if ( !v17 )
      {
        if ( *(_BYTE *)(v2 + 138) == 1 && *(_BYTE *)(v2 + 123) == 9 && !*(_WORD *)(v2 + 394) )
          *(_BYTE *)(v2 + 123) = 0;
        *(_BYTE *)(v2 + 138) = *(_BYTE *)(v2 + 394);
        goto LABEL_11;
      }
      return v6;
    default:
      return v6;
    case 2:
      LOWORD(v6) = *(_WORD *)(v2 + 2550);
      *(_BYTE *)(v2 + 123) = *(_BYTE *)(v2 + 758);
      if ( (signed __int16)v6 >= 0 && (signed __int16)v6 <= 6 )
        *(_BYTE *)(v2 + 173) = 1;
      goto LABEL_17;
    case 13:
      if ( v17 )
        return v6;
      if ( *(_BYTE *)(v2 + 170) == 1 && *(_BYTE *)(v2 + 155) == 9 && !*(_WORD *)(v2 + 1182) )
        *(_BYTE *)(v2 + 155) = 0;
      *(_BYTE *)(v2 + 170) = *(_BYTE *)(v2 + 1182);
LABEL_11:
      *(_BYTE *)(v2 + 173) = 1;
      goto LABEL_12;
    case 14:
      LOBYTE(v6) = *(_BYTE *)(v2 + 1546);
      *(_BYTE *)(v2 + 155) = v6;
LABEL_17:
      if ( v17 )
        *(_BYTE *)(v2 + 2338) = 1;
      else
LABEL_12:
        LOBYTE(v6) = sub_1003BED0(byte_1008A428[3 * *(_WORD *)(v2 + 2550)], 0, 16, 0, (const void *)(v2 + 108), 0x40u);
      return v6;
    case 7:
      if ( !*(_WORD *)(v2 + 886) )
        return v6;
      *(_WORD *)(v2 + 978) = 0;
      goto LABEL_28;
    case 10:
      if ( !*(_WORD *)(v2 + 978) )
        return v6;
      *(_WORD *)(v2 + 886) = 0;
LABEL_28:
      *(_WORD *)(v2 + 1674) = 0;
      goto LABEL_29;
    case 19:
      if ( !*(_WORD *)(v2 + 1674) )
        return v6;
      *(_WORD *)(v2 + 886) = 0;
      *(_WORD *)(v2 + 978) = 0;
LABEL_29:
      *(_WORD *)(v2 + 1058) = 0;
      goto LABEL_30;
    case 11:
      if ( *(_WORD *)(v2 + 1058) )
      {
        *(_WORD *)(v2 + 886) = 0;
        *(_WORD *)(v2 + 978) = 0;
        *(_WORD *)(v2 + 1674) = 0;
LABEL_30:
        *(_WORD *)(v2 + 1138) = 0;
        *(_WORD *)(v2 + 1754) = 0;
        *(_WORD *)(v2 + 1834) = 0;
      }
      break;
    case 12:
      if ( *(_WORD *)(v2 + 1138) )
      {
        *(_WORD *)(v2 + 886) = 0;
        *(_WORD *)(v2 + 978) = 0;
        *(_WORD *)(v2 + 1674) = 0;
        *(_WORD *)(v2 + 1058) = 0;
        *(_WORD *)(v2 + 1754) = 0;
        *(_WORD *)(v2 + 1834) = 0;
      }
      break;
    case 20:
      if ( *(_WORD *)(v2 + 1754) )
      {
        *(_WORD *)(v2 + 886) = 0;
        *(_WORD *)(v2 + 978) = 0;
        *(_WORD *)(v2 + 1674) = 0;
        *(_WORD *)(v2 + 1058) = 0;
        *(_WORD *)(v2 + 1138) = 0;
        *(_WORD *)(v2 + 1834) = 0;
      }
      break;
    case 21:
      if ( *(_WORD *)(v2 + 1834) )
      {
        *(_WORD *)(v2 + 886) = 0;
        *(_WORD *)(v2 + 978) = 0;
        *(_WORD *)(v2 + 1674) = 0;
        *(_WORD *)(v2 + 1058) = 0;
        *(_WORD *)(v2 + 1138) = 0;
        *(_WORD *)(v2 + 1754) = 0;
      }
      break;
    case 0:
      if ( v17 )
      {
        sub_1000BA80(a1);
        *(_BYTE *)(v2 + 2334) = 1;
        sub_1000D750(a1);
        *(_WORD *)(v2 + 178) = 436;
        *(_WORD *)(v2 + 182) = 436;
        *(_WORD *)(v2 + 180) = 443;
        *(_WORD *)(v2 + 184) = 443;
        *(_WORD *)v2 = 5518;
        *(_WORD *)(v2 + 174) = 763;
        *(_WORD *)(v2 + 176) = 967;
        *(_BYTE *)(v2 + 2337) = 1;
        *(_BYTE *)(v2 + 187) = 1;
        *(_BYTE *)(v2 + 2636) = 3;
        *(_BYTE *)(v2 + 2637) = 3;
        v7 = v2 + 192;
        v8 = 6;
        do
        {
          *(_DWORD *)(v7 + 8) = &unk_1008BC5C;
          *(_BYTE *)v7 = 1;
          v7 += 16;
          --v8;
        }
        while ( v8 );
        v9 = (_DWORD *)(v2 + 296);
        v10 = 2;
        do
        {
          *v9 = &unk_1008BC9C;
          v9 += 4;
          --v10;
        }
        while ( v10 );
        *(_DWORD *)(v2 + 328) = &unk_1008BCDC;
        v18 = 0;
        do
          sub_10018700(a1, v18++, 0);
        while ( v18 < 2u );
        memset((void *)(v2 + 2574), 0, 0x30u);
        *(_DWORD *)(v2 + 2638) = 0;
        *(_WORD *)(v2 + 2642) = 0;
        *(_BYTE *)(v2 + 2644) = 0;
        *(_BYTE *)(v2 + 3141) = 0;
        *(_BYTE *)(v2 + 3142) = 0;
        *(_BYTE *)(v2 + 3143) = 0;
        *(_BYTE *)(v2 + 3144) = 0;
        *(_BYTE *)(v2 + 3154) = 0;
        *(_BYTE *)(v2 + 3155) = 0;
        *(_BYTE *)(v2 + 3156) = 0;
        *(_BYTE *)(v2 + 3157) = 0;
        *(_BYTE *)(v2 + 3167) = 0;
        *(_BYTE *)(v2 + 3168) = 0;
        *(_BYTE *)(v2 + 3169) = 0;
        *(_BYTE *)(v2 + 3170) = 0;
        *(_BYTE *)(v2 + 3180) = 0;
        *(_BYTE *)(v2 + 3181) = 0;
        *(_BYTE *)(v2 + 3182) = 0;
        *(_BYTE *)(v2 + 3183) = 0;
        *(_BYTE *)(v2 + 2626) = 0;
        *(_BYTE *)(v2 + 2627) = 0;
        *(_BYTE *)(v2 + 3189) = 0;
        *(_BYTE *)(v2 + 3198) = 0;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 4) = 0;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 16) = 0;
      }
      else
      {
        *(_WORD *)(v2 + 178) = 5966;
        *(_WORD *)(v2 + 180) = 5975;
        *(_WORD *)(v2 + 182) = 5966;
        *(_WORD *)(v2 + 184) = 5975;
        *(_WORD *)(v2 + 174) = 1902;
        *(_WORD *)(v2 + 176) = 4106;
        *(_BYTE *)(v2 + 2334) = 0;
        *(_BYTE *)(v2 + 187) = 0;
        *(_BYTE *)(v2 + 2566) = 3;
        *(_BYTE *)(v2 + 2567) = 3;
        *(_BYTE *)(v2 + 2568) = 3;
        *(_BYTE *)(v2 + 2569) = 3;
        v11 = v2 + 192;
        v12 = 6;
        do
        {
          *(_DWORD *)(v11 + 8) = &unk_1008BC6C;
          *(_BYTE *)v11 = 0;
          v11 += 16;
          --v12;
        }
        while ( v12 );
        v13 = (_DWORD *)(v2 + 296);
        v14 = 2;
        do
        {
          *v13 = &unk_1008BC7C;
          v13 += 4;
          --v14;
        }
        while ( v14 );
        *(_DWORD *)(v2 + 328) = &unk_1008BCBC;
        v19 = 0;
        do
          sub_10018700(a1, v19++, 2);
        while ( v19 < 2u );
        memset((void *)(v2 + 2574), 3, 0x30u);
        *(_BYTE *)(v2 + 3141) = 3;
        *(_BYTE *)(v2 + 3142) = 3;
        *(_BYTE *)(v2 + 3143) = 3;
        *(_BYTE *)(v2 + 3144) = 3;
        *(_BYTE *)(v2 + 3154) = 3;
        *(_BYTE *)(v2 + 3155) = 3;
        *(_BYTE *)(v2 + 3156) = 3;
        *(_BYTE *)(v2 + 3157) = 3;
        *(_BYTE *)(v2 + 3167) = 3;
        *(_BYTE *)(v2 + 3168) = 3;
        *(_BYTE *)(v2 + 3169) = 3;
        *(_BYTE *)(v2 + 3170) = 3;
        *(_BYTE *)(v2 + 3180) = 3;
        *(_BYTE *)(v2 + 3181) = 3;
        *(_BYTE *)(v2 + 3182) = 3;
        *(_BYTE *)(v2 + 3183) = 3;
      }
      v15 = 0;
      if ( *(_BYTE *)((unsigned __int8)byte_1008A429[3 * *(_WORD *)(v2 + 2550)] + v2 + 360) )
        v15 = 3;
      *(_BYTE *)(v2 + 2622) = v15;
      *(_BYTE *)(v2 + 2623) = v15;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 8) = v15;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 22) = v15;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 6) = v15;
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 18) = v15;
      LOBYTE(v6) = sub_10009560(a1);
      break;
  }
  return v6;
}

//----- (1000E610) --------------------------------------------------------
void __cdecl sub_1000E610(unsigned int a1)
{
  void *v1; // ecx@0
  __int16 v2; // ax@9

  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x8018:
      sub_1000CB70(a1);
      break;
    case 0x801D:
      sub_1000A600(a1);
      break;
    case 0x8022:
      sub_1000FE60(a1);
      break;
    case 0x803F:
      sub_1000CBB0(a1);
      break;
    case 0x8041:
      sub_1000CC90(a1);
      break;
    case 0x8048:
      if ( sub_10022FB0(v1)
        && *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) != -1
        && ((v2 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 10), v2 == 57) || v2 == 33) )
      {
        *(_BYTE *)(a1 + 6) = 2;
      }
      else
      {
        sub_1000A6B0(a1);
      }
      break;
    case 0x8051:
      sub_1000E000(a1);
      break;
    case 0x806E:
      sub_1000D880(a1);
      break;
    case 0x8078:
      sub_1000D930(a1);
      break;
    default:
      return;
  }
}

//----- (1000E750) --------------------------------------------------------
int __usercall sub_1000E750@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3@<esi>, __int16 a4)
{
  int v4; // edi@1
  int result; // eax@1
  int v6; // ecx@2
  int v7; // [sp+0h] [bp-4h]@1

  v7 = a2;
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v7 = *a3;
  result = sub_1003B860(&v7, 4u, (int)&unk_1008C9F8, 8, 15, -1);
  if ( result != -1 )
  {
    v6 = (unsigned __int16)word_1008C9FE[4 * result];
    result = (unsigned __int16)word_1008C9FC[4 * result];
    *(_WORD *)&a3[result] = a4 * (*(_WORD *)(v4 + 1886) - 2);
    *(_DWORD *)&a3[v6] &= 0xFFFF3FFF;
  }
  return result;
}
// 1008C9FC: using guessed type __int16 word_1008C9FC[];
// 1008C9FE: using guessed type __int16 word_1008C9FE[];

//----- (1000E7B0) --------------------------------------------------------
int __usercall sub_1000E7B0@<eax>(unsigned __int8 a1@<al>, int a2, int a3, int a4, _WORD *a5, _WORD *a6, _WORD *a7, _BYTE *a8, char a9)
{
  _WORD *v9; // ebp@1
  __int16 v10; // dx@1
  int v11; // ecx@1
  int v12; // esi@1
  int v13; // edi@1
  __int16 v14; // bx@1
  __int16 v15; // ax@3
  __int16 v16; // cx@4
  int result; // eax@4
  int v18; // [sp+20h] [bp+10h]@3
  int v19; // [sp+30h] [bp+20h]@3

  v9 = a5;
  v10 = *a5;
  v11 = *a5 + 6 * a1 + 28;
  LOWORD(v12) = 0;
  LOWORD(v13) = *(_WORD *)(a2 + 16);
  v14 = *(_WORD *)(a2 + 16);
  if ( a9 )
  {
    LOWORD(v12) = *(_WORD *)a4;
    LOWORD(v13) = *(_WORD *)(a4 + 4) - *(_WORD *)a4 + 1;
    v14 = *(_WORD *)(a4 + 4);
  }
  v13 = (signed __int16)v13;
  v18 = *(_WORD *)a3;
  v15 = v11 - v13;
  v19 = (signed __int16)v13;
  if ( v11 - (signed __int16)v13 <= 0 )
  {
    while ( *a8 > 1u )
    {
      if ( *a8 != 2 )
      {
        v12 = (signed __int16)v12;
        result = (signed __int16)v12 + (v13 - v11) / 2;
        if ( result + v11 > v14 )
        {
          result = v13 + v12 - v11;
          if ( result <= v12 )
            result = v12;
        }
        goto LABEL_16;
      }
      result = *(_WORD *)(a3 + 4) + 2;
      if ( result + v11 <= v14 )
        goto LABEL_16;
      result = *(_WORD *)a3 - v11 - 2;
      if ( result >= (signed __int16)v12 )
        goto LABEL_16;
      v13 = v19;
      *a8 = 3;
    }
    result = (signed __int16)v18 + 2;
    if ( result + v11 > v14 )
    {
      result = v14 - v11;
      if ( result <= (signed __int16)v12 )
      {
        result = (signed __int16)v12;
        *a6 = v11 - 1;
        *a7 = v12;
        return result;
      }
    }
LABEL_16:
    *a6 = v11 - 1;
    *a7 = result;
  }
  else
  {
    v16 = v11 - v15;
    *v9 = v10 - v15;
    result = (signed __int16)v12;
    *a6 = v16 - 1;
    *a7 = v12;
  }
  return result;
}

//----- (1000E8F0) --------------------------------------------------------
int __usercall sub_1000E8F0@<eax>(int a1@<eax>, int a2@<edx>, int a3, _WORD *a4, __int16 a5, _WORD *a6, _WORD *a7, _BYTE *a8, _BYTE *a9, char a10)
{
  int v10; // edi@1
  signed int v11; // eax@1
  unsigned int v12; // ecx@3
  int v13; // ecx@4
  signed int v14; // esi@6
  __int16 v15; // ax@8
  __int16 v16; // bx@8
  __int16 v17; // cx@8
  int v18; // eax@11
  int v19; // ecx@16
  int result; // eax@19
  int v21; // eax@22
  unsigned int v22; // eax@24
  int v23; // eax@25
  __int16 v24; // [sp+10h] [bp-Ch]@8
  signed int v25; // [sp+14h] [bp-8h]@1
  int v26; // [sp+18h] [bp-4h]@1
  int v27; // [sp+3Ch] [bp+20h]@10

  v10 = a1;
  v11 = *a4;
  v26 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 12);
  v25 = 4;
  if ( v11 <= 4 )
    v25 = *a4;
  v12 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 56) + 12) + 1852) + 4);
  if ( v12 & 0x3E0 )
    v13 = (v12 >> 5) & 0x1F;
  else
    LOBYTE(v13) = 10;
  v14 = (unsigned __int8)v13;
  if ( (unsigned __int8)v13 >= v11 )
    v14 = *a4;
  v15 = *(_WORD *)(a2 + 14);
  v16 = v15 - 1;
  v17 = 0;
  v24 = 0;
  if ( a10 )
  {
    v17 = *(_WORD *)(v10 + 2);
    v16 = *(_WORD *)(v10 + 6);
    v24 = *(_WORD *)(v10 + 2);
  }
  v27 = (unsigned __int16)(v16 - v17 + 1);
  if ( *(_DWORD *)(a2 + 64) != 1 )
  {
    v18 = v15 - 26;
    if ( v16 < v18 )
      LOWORD(v18) = v16;
    v16 = v18;
  }
  while ( 1 )
  {
    *a9 = 0;
    if ( *a4 > v14 )
      *a9 = 1;
    v19 = v14 * (a5 + 1) + 33;
    if ( !*a8 )
      break;
    if ( *a8 == 1 )
    {
      result = *(_WORD *)(a3 + 2) - v19 - 1;
      if ( result >= v24 )
        goto LABEL_32;
    }
    else if ( v19 <= (signed __int16)v27 )
    {
      result = v24 + ((signed __int16)v27 - v19) / 2;
      goto LABEL_32;
    }
LABEL_23:
    if ( v14 > v25 )
    {
      --v14;
    }
    else
    {
      v22 = *(_WORD *)(*(_DWORD *)(v26 + 1852) + 4);
      if ( v22 & 0x3E0 )
        v23 = (v22 >> 5) & 0x1F;
      else
        LOBYTE(v23) = 10;
      v14 = (unsigned __int8)v23;
      if ( (unsigned __int8)v23 >= (signed int)*a4 )
        v14 = *a4;
      ++*a8;
    }
  }
  v21 = *(_WORD *)(a3 + 6) + v19 + 2;
  if ( v21 > v16 )
    goto LABEL_23;
  result = v21 - v19 + 2;
LABEL_32:
  *a6 = v19;
  *a7 = result;
  *a4 = v14;
  return result;
}

//----- (1000EA90) --------------------------------------------------------
int __usercall sub_1000EA90@<eax>(int a1@<eax>, int a2@<edx>, unsigned __int16 a3@<cx>, unsigned __int16 a4, __int16 a5)
{
  int v5; // esi@1
  int v6; // edi@1
  _BYTE *v7; // ebx@2
  const void *v8; // esi@2

  v5 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_BYTE *)a2 = 0;
  *(_BYTE *)(a2 + 1) = 0;
  *(_WORD *)(a2 + 2) = 0;
  *(_WORD *)(a2 + 4) = 0;
  v6 = 4 * a4;
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(v6 + *(_DWORD *)(v5 + 1868));
  if ( *(_BYTE *)(*(_DWORD *)(v5 + 1852) + 4) & 1 )
  {
    v7 = (_BYTE *)(52 * a3 + v5 + 84);
    v8 = *(const void **)(v5 + 1864);
  }
  else
  {
    v7 = (_BYTE *)(52 * a3 + v5 + 84);
    v8 = *(const void **)(v6 + *(_DWORD *)(v5 + 1864));
  }
  qmemcpy(v7, v8, 0x34u);
  *(_DWORD *)(a2 + 8) = v7;
  return sub_1000E750(a1, 0, v7, a5);
}

//----- (1000EB10) --------------------------------------------------------
char __cdecl sub_1000EB10(int a1, int a2, unsigned __int16 a3)
{
  int v3; // edx@1
  char result; // al@1
  int v5; // ecx@3
  char v6; // bl@3
  int v7; // ecx@6
  unsigned int v8; // edx@8
  int v9; // edx@9
  int v10; // edx@11
  int v11; // edx@13
  int v12; // ecx@13
  int v13; // edx@13
  int v14; // [sp+8h] [bp-10h]@13
  int v15; // [sp+Ch] [bp-Ch]@13
  int v16; // [sp+10h] [bp-8h]@13
  int v17; // [sp+14h] [bp-4h]@13

  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  result = 0;
  if ( (a3 & 0x8000u) == 0 && (signed __int16)a3 < (signed int)*(_WORD *)(v3 + 1860) )
  {
    v5 = *(_DWORD *)(v3 + 1872);
    v6 = 2;
    if ( !v5 || *(_BYTE *)(v5 + (signed __int16)a3) )
      v6 = 1;
    v7 = (unsigned __int16)(a3 - *(_WORD *)(v3 + 44) + 1);
    if ( v7 <= 0 )
      v7 = 0;
    v8 = *(_WORD *)(*(_DWORD *)(v3 + 1852) + 4);
    if ( v8 & 0x3E0 )
      v9 = (v8 >> 5) & 0x1F;
    else
      LOBYTE(v9) = 10;
    v10 = (unsigned __int8)v9 + 1;
    if ( v7 >= v10 )
      LOWORD(v7) = v10;
    sub_1000EA90(a1, (int)&v14, v7, a3, 1);
    v11 = v15;
    *(_DWORD *)a2 = v14;
    v12 = v16;
    *(_DWORD *)(a2 + 4) = v11;
    v13 = v17;
    *(_DWORD *)(a2 + 8) = v12;
    *(_DWORD *)(a2 + 12) = v13;
    result = v6;
  }
  return result;
}

//----- (1000EBD0) --------------------------------------------------------
bool __usercall sub_1000EBD0@<al>(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // ebx@1
  int v3; // edi@1
  bool result; // al@1

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 60);
  v3 = *(_DWORD *)(v1 + 12);
  sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008C9E0, (int)&unk_1008C9F0, 0, 255);
  result = sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)(v3 + 8), v2, 0, *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (1000EC20) --------------------------------------------------------
void __usercall sub_1000EC20(unsigned int a1@<edi>)
{
  int v1; // eax@1
  int v2; // ecx@1
  int v3; // ebx@1
  int v4; // esi@1
  __int16 v5; // bp@1
  int v6; // eax@4
  __int16 v7; // cx@9
  int v8; // eax@10
  __int16 v9; // [sp+Ch] [bp-24h]@8
  int v10; // [sp+10h] [bp-20h]@8
  __int16 v11; // [sp+14h] [bp-1Ch]@12
  int v12; // [sp+18h] [bp-18h]@12
  __int16 v13; // [sp+1Ch] [bp-14h]@12
  __int16 v14; // [sp+20h] [bp-10h]@6
  int v15; // [sp+24h] [bp-Ch]@6
  __int16 v16; // [sp+28h] [bp-8h]@6
  __int16 v17; // [sp+2Ah] [bp-6h]@6
  int v18; // [sp+2Ch] [bp-4h]@6

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(a1 + 52);
  v3 = *(_DWORD *)(v1 + 4);
  v4 = *(_DWORD *)(v1 + 12);
  v5 = *(_WORD *)(v4 + 42);
  if ( *(_WORD *)(v2 + 10) != 33 )
    *(_BYTE *)(a1 + 6) = sub_100375A0(a1, (char *)v1, v2);
  switch ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) )
  {
    case 0x21:
      v6 = *(_DWORD *)(v4 + 1872);
      if ( !v6 || *(_BYTE *)(*(_WORD *)(v4 + 42) + v6) )
      {
        v15 = v3;
        v14 = -32687;
        v17 = *(_WORD *)(v4 + 42);
        v16 = *(_WORD *)(v4 + 1882);
        v18 = *(_DWORD *)(v4 + 1876);
        *(_WORD *)(*(_DWORD *)(v4 + 1856) + 2) = v17;
        sub_10003E50(a1, (int)&v14, 16);
        goto LABEL_7;
      }
      break;
    case 0x20:
    case 0x28:
      v10 = v3;
      v9 = -32690;
      sub_10003E50(a1, (int)&v9, 8);
LABEL_7:
      sub_100352A0(a1, 1, 0, 0);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 0x38:
    case 0x39:
      v7 = *(_WORD *)(v4 + 42);
      if ( v5 != v7 )
      {
        v8 = *(_DWORD *)(v4 + 1872);
        if ( !v8 || *(_BYTE *)(v7 + v8) )
        {
          v12 = v3;
          v11 = -32689;
          v13 = *(_WORD *)(v4 + 42);
          sub_10003E50(a1, (int)&v11, 12);
        }
      }
      *(_BYTE *)(a1 + 6) = 2;
      break;
    default:
      return;
  }
}

//----- (1000ED70) --------------------------------------------------------
_WORD *__usercall sub_1000ED70@<eax>(unsigned __int8 *a1@<ebx>, int a2@<esi>, _WORD *a3, _WORD *a4, _WORD *a5, _WORD *a6, _WORD *a7, __int16 a8, _WORD *a9, char a10, char a11)
{
  int v11; // eax@1
  __int16 v12; // dx@1
  __int16 v13; // cx@1
  __int16 v14; // ax@1
  __int16 v15; // dx@1
  _WORD *result; // eax@1
  __int16 v17; // cx@1
  char v18; // [sp+7h] [bp-19h]@1
  int v19; // [sp+8h] [bp-18h]@1
  int v20; // [sp+Ch] [bp-14h]@1
  int v21; // [sp+10h] [bp-10h]@1
  int v22; // [sp+14h] [bp-Ch]@1
  __int16 v23; // [sp+18h] [bp-8h]@1
  __int16 v24; // [sp+1Ah] [bp-6h]@1
  __int16 v25; // [sp+1Ch] [bp-4h]@1
  __int16 v26; // [sp+1Eh] [bp-2h]@1

  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v11 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 4);
  v12 = *(_WORD *)(v11 + 30) + *(_WORD *)(v11 + 34);
  v24 = *(_WORD *)(v11 + 30);
  v13 = *(_WORD *)(v11 + 28);
  LOWORD(v11) = v13 + *(_WORD *)(v11 + 32);
  v23 = v13;
  v26 = v12;
  v25 = v11;
  sub_1000E8F0((int)&v23, a2, (int)&a11, a7, a8, &v20, &v22, &v18, a1, a10);
  sub_1000E7B0(*a1, a2, (int)&a11, (int)&v23, a9, &v19, &v21, &v18, a10);
  v14 = v20;
  *a5 = v19;
  v15 = v21;
  *a6 = v14;
  result = a3;
  v17 = v22;
  *a3 = v15;
  *a4 = v17;
  return result;
}

//----- (1000EE50) --------------------------------------------------------
int __usercall sub_1000EE50@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int *v2; // edi@1
  unsigned int v3; // eax@1
  signed __int16 v4; // cx@1
  int result; // eax@1
  int v6; // edx@3
  __int16 v7; // dx@5
  __int16 v8; // cx@5

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = sub_10002E60(0x1026u);
  v3 = sub_100035F0(0x1026u, 0);
  v4 = 0;
  result = (v3 >> 16) & 0xFF;
  if ( *(_BYTE *)(v1 + 1888) )
    v4 = 64;
  v6 = *(_DWORD *)(v1 + 1852);
  *(_DWORD *)(v1 + 8) = 122;
  if ( !(*(_BYTE *)(v6 + 4) & 4) )
    v4 |= 0x80u;
  v7 = *(_WORD *)(v1 + 1890);
  *(_WORD *)(v1 + 12) = v4;
  *(_DWORD *)(v1 + 16) = v1 + 76;
  v8 = *(_WORD *)(v1 + 1884);
  *(_WORD *)(v1 + 24) = v7;
  *(_WORD *)(v1 + 14) = 16;
  *(_DWORD *)(v1 + 20) = sub_1000EB10;
  *(_WORD *)(v1 + 26) = v8 + 1;
  *(_WORD *)(v1 + 28) = 0;
  *(_WORD *)(v1 + 32) = 15;
  *(_WORD *)(v1 + 34) = result + *(_WORD *)(*v2 + 24) - *(_WORD *)(*v2 + 26) + 16;
  *(_DWORD *)(v1 + 36) = 141;
  return result;
}

//----- (1000EF00) --------------------------------------------------------
signed int __usercall sub_1000EF00@<eax>(int a1@<ebx>)
{
  signed int result; // eax@1
  int v2; // esi@1
  signed int v3; // edi@1
  __int16 v4; // dx@2
  signed int v5; // eax@2
  signed int v6; // ecx@4
  int v7; // [sp+8h] [bp-1Ch]@2
  int v8; // [sp+Ch] [bp-18h]@2
  char v9; // [sp+14h] [bp-10h]@2

  result = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(result + 12);
  v3 = 0;
  if ( *(_WORD *)(v2 + 1860) )
  {
    do
    {
      sub_1000EA90(a1, (int)&v9, 0, v3, 0);
      sub_10002B90(a1, (char *)(v2 + 76), (int)&v9, &v7);
      v4 = v8 - v7 + 1;
      v5 = (signed __int16)(HIWORD(v8) - HIWORD(v7) + 1);
      if ( *(_WORD *)(v2 + 1884) > v5 )
        LOWORD(v5) = *(_WORD *)(v2 + 1884);
      v6 = *(_WORD *)(v2 + 1886);
      *(_WORD *)(v2 + 1884) = v5;
      result = v4;
      if ( v6 > v4 )
        result = v6;
      *(_WORD *)(v2 + 1886) = result;
      ++v3;
    }
    while ( v3 < *(_WORD *)(v2 + 1860) );
  }
  return result;
}

//----- (1000F1E0) --------------------------------------------------------
void __cdecl sub_1000F1E0(int a1)
{
  int v1; // edi@5
  int v2; // eax@5
  int v3; // edx@5
  int v4; // eax@6
  int v5; // eax@7
  __int16 v6; // dx@7
  int v7; // eax@7
  int v8; // ST3C_4@7
  unsigned __int16 v9; // cx@7
  unsigned int v10; // eax@7
  int v11; // eax@9
  int v12; // eax@11
  __int16 v13; // ax@12
  int v14; // ecx@12
  _DWORD *v15; // [sp+0h] [bp-4h]@5

  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x8041:
      v1 = sub_10003D50(a1, *(char **)(a1 + 56), 1892, 1);
      v2 = *(_DWORD *)(a1 + 56);
      v3 = *(_DWORD *)(v2 + 4);
      v15 = *(_DWORD **)(v2 + 60);
      if ( v3 && (v4 = *(_DWORD *)(a1 + 52), *(_DWORD *)(v4 + 36) == *(_DWORD *)(v3 + 8)) )
      {
        *(_DWORD *)(v1 + 1852) = *(_DWORD *)(v4 + 16);
        v5 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 20);
        *(_DWORD *)(v1 + 1856) = v5;
        *(_DWORD *)(v1 + 1860) = *(_DWORD *)v5;
        *(_DWORD *)(v1 + 1864) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(v1 + 1868) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(v1 + 1872) = *(_DWORD *)(v5 + 12);
        v6 = *(_WORD *)(v1 + 1860);
        *(_DWORD *)(v1 + 1876) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 32);
        *(_BYTE *)(v1 + 1880) = 0;
        *(_WORD *)(v1 + 1890) = v6;
        *(_BYTE *)(v1 + 1888) = 0;
        *(_DWORD *)(v1 + 76) = 75;
        *(_WORD *)(v1 + 80) = 0;
        *(_WORD *)(v1 + 82) = 0;
        *(_WORD *)(v1 + 1884) = 0;
        *(_WORD *)(v1 + 1886) = 0;
        sub_1000EF00(a1);
        v7 = *(_DWORD *)(a1 + 52);
        v8 = *(_DWORD *)(v7 + 28);
        sub_1000ED70(
          (unsigned __int8 *)(v1 + 1888),
          a1,
          (_WORD *)(v1 + 4),
          (_WORD *)(v1 + 6),
          (_WORD *)(v1 + 2),
          (_WORD *)v1,
          (_WORD *)(v1 + 1890),
          *(_WORD *)(v1 + 1884),
          (_WORD *)(v1 + 1886),
          (*(_BYTE *)(*(_DWORD *)(v1 + 1852) + 4) & 8) == 8,
          *(_DWORD *)(v7 + 24));
        sub_1000EE50(a1);
        sub_10002870(a1, *(_WORD *)(v1 + 4), *(_WORD *)(v1 + 6), *(_WORD *)(v1 + 2), *(_WORD *)v1, 0);
        sub_100374D0(*(_DWORD *)(a1 + 56), (char *)(v1 + 8));
        *v15 = v1 + 40;
        v9 = *(_WORD *)(v1 + 1862);
        *(_DWORD *)(v1 + 52) = 0;
        *(_WORD *)(v1 + 44) = v9;
        v10 = *(_WORD *)(*(_DWORD *)(v1 + 1852) + 4);
        if ( v10 & 0x400 )
        {
          if ( v10 & 0x3E0 )
            v11 = (v10 >> 5) & 0x1F;
          else
            LOBYTE(v11) = 10;
          v12 = (signed __int16)v9 - ((unsigned __int8)v11 - 1) / 2;
          *(_WORD *)(v1 + 44) = v12 < 0 ? 0 : (unsigned __int16)v12;
        }
        v13 = *(_WORD *)(v1 + 1860);
        *(_WORD *)(v1 + 42) = v9;
        *(_WORD *)(v1 + 48) = v13;
        *(_WORD *)(v1 + 1882) = v9;
        *(_DWORD *)(v1 + 56) = v1 + 60;
        sub_1000EA90(a1, v1 + 60, 0, v9, 1);
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = 0;
        sub_10004590(a1, *(_DWORD *)(a1 + 56), -32734);
        sub_10002C10(
          a1,
          &unk_100B097C,
          *(char ***)(*(_DWORD *)(a1 + 56) + 56),
          *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
          0,
          *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
        v14 = *(_DWORD *)(a1 + 56);
        *(_BYTE *)(a1 + 9) = 1;
        *(_BYTE *)(v14 + 247) = 1;
        sub_100375A0(a1, *(char **)(*(_DWORD *)(a1 + 56) + 4), (int)&unk_100B096C);
        *(_BYTE *)(a1 + 6) = 2;
      }
      else
      {
        sub_100352A0(a1, 1, 0, 0);
        *(_BYTE *)(a1 + 6) = 2;
      }
      break;
    case 0x8022:
    case 0x8078:
      sub_1000EBD0(a1);
      break;
    default:
      return;
    case 0x8048:
      sub_1000EC20(a1);
      break;
    case 0x80AA:
      sub_10002300(a1);
      break;
  }
}

//----- (1000F2D0) --------------------------------------------------------
int __usercall sub_1000F2D0@<eax>(unsigned __int8 a1@<al>, int a2, int a3, int a4, _WORD *a5, _WORD *a6, _WORD *a7, _BYTE *a8, char a9)
{
  int v9; // ecx@1
  int v10; // esi@1
  int v11; // edi@1
  __int16 v12; // bx@1
  int v13; // eax@3
  int result; // eax@4
  int v15; // edx@16
  int v16; // ecx@16
  int v17; // [sp+30h] [bp+20h]@3

  v9 = *a5 + 6 * a1 + 28;
  LOWORD(v10) = 0;
  LOWORD(v11) = *(_WORD *)(a2 + 16);
  v12 = *(_WORD *)(a2 + 16);
  if ( a9 )
  {
    LOWORD(v10) = *(_WORD *)a4;
    LOWORD(v11) = *(_WORD *)(a4 + 4) - *(_WORD *)a4 + 1;
    v12 = *(_WORD *)(a4 + 4);
  }
  v17 = *(_WORD *)a3;
  v11 = (signed __int16)v11;
  v13 = v9 - (signed __int16)v11;
  if ( v9 - (signed __int16)v11 <= 0 )
  {
    while ( *a8 > 1u )
    {
      if ( *a8 != 2 )
      {
        v10 = (signed __int16)v10;
        result = (signed __int16)v10 + (v11 - v9) / 2;
        if ( result + v9 > v12 )
        {
          result = v11 + v10 - v9;
          if ( result <= v10 )
            result = v10;
        }
        goto LABEL_16;
      }
      result = *(_WORD *)(a3 + 4) + 2;
      if ( result + v9 <= v12 )
        goto LABEL_16;
      result = *(_WORD *)a3 - v9 - 2;
      if ( result >= (signed __int16)v10 )
        goto LABEL_16;
      *a8 = 3;
    }
    result = (signed __int16)v17 + 2;
    if ( result + v9 > v12 )
    {
      result = v12 - v9;
      if ( result <= (signed __int16)v10 )
        result = (signed __int16)v10;
    }
  }
  else
  {
    v9 -= v13;
    *a5 -= v13;
    result = (signed __int16)v10;
  }
LABEL_16:
  v15 = *(_WORD *)(a3 + 4) - *(_WORD *)a3 - 1;
  v16 = v9 - 1;
  if ( v16 <= v15 )
  {
    *a6 = v15;
    *a7 = result;
  }
  else
  {
    *a6 = v16;
    *a7 = result;
  }
  return result;
}

//----- (1000F400) --------------------------------------------------------
int __usercall sub_1000F400@<eax>(int a1@<edx>, int a2@<ecx>, int a3, _WORD *a4, __int16 a5, _WORD *a6, _WORD *a7, _BYTE *a8, _BYTE *a9, char a10)
{
  signed int v10; // eax@1
  signed int v11; // esi@3
  __int16 v12; // ax@5
  __int16 v13; // bx@5
  __int16 v14; // di@5
  int v15; // eax@8
  int v16; // ecx@13
  int result; // eax@16
  int v18; // eax@19
  __int16 v19; // [sp+0h] [bp-8h]@5
  signed int v20; // [sp+4h] [bp-4h]@1
  int v21; // [sp+28h] [bp+20h]@7

  v10 = *a4;
  v20 = 4;
  if ( v10 <= 4 )
    v20 = *a4;
  v11 = 10;
  if ( v10 <= 10 )
    v11 = *a4;
  v12 = *(_WORD *)(a2 + 14);
  v13 = 0;
  v14 = v12 - 1;
  v19 = 0;
  if ( a10 )
  {
    v13 = *(_WORD *)(a1 + 2);
    v14 = *(_WORD *)(a1 + 6);
    v19 = *(_WORD *)(a1 + 2);
  }
  v21 = (unsigned __int16)(v14 - v13 + 1);
  if ( *(_DWORD *)(a2 + 64) != 1 )
  {
    v15 = v12 - 26;
    if ( v14 < v15 )
      LOWORD(v15) = v14;
    v14 = v15;
  }
  while ( 1 )
  {
    *a9 = 0;
    if ( *a4 > v11 )
      *a9 = 1;
    v16 = v11 * (a5 + 1) + 33;
    if ( !*a8 )
      break;
    if ( *a8 == 1 )
    {
      result = *(_WORD *)(a3 + 2) - v16 - 1;
      if ( result >= v19 )
        goto LABEL_26;
    }
    else if ( v16 <= (signed __int16)v21 )
    {
      result = v19 + ((signed __int16)v21 - v16) / 2;
      goto LABEL_26;
    }
LABEL_20:
    if ( v11 > v20 )
    {
      --v11;
    }
    else
    {
      v11 = 10;
      if ( (signed int)*a4 <= 10 )
        v11 = *a4;
      ++*a8;
    }
  }
  v18 = *(_WORD *)(a3 + 6) + v16 + 2;
  if ( v18 > v14 )
    goto LABEL_20;
  result = v18 - v16 + 2;
LABEL_26:
  *a6 = v16;
  *a7 = result;
  *a4 = v11;
  return result;
}

//----- (1000F550) --------------------------------------------------------
int __usercall sub_1000F550@<eax>(int a1@<eax>, int a2@<edx>, unsigned __int16 a3@<si>)
{
  int result; // eax@1

  result = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(_BYTE *)(*(_DWORD *)(result + 92) + 8) & 1 )
  {
    if ( (*(_BYTE *)(*(_DWORD *)(result + 92) + 8) & 1) == 1 )
    {
      *(_BYTE *)(a2 + 4) = 1;
      result = *(_DWORD *)(*(_DWORD *)(result + 92) + 16);
      *(_WORD *)a2 = *(_WORD *)(result + 2 * a3);
    }
  }
  else
  {
    *(_BYTE *)(a2 + 4) = 0;
    result = *(_DWORD *)(*(_DWORD *)(result + 92) + 16);
    *(_DWORD *)a2 = *(_DWORD *)(result + 4 * a3);
  }
  return result;
}

//----- (1000F5A0) --------------------------------------------------------
char __cdecl sub_1000F5A0(int a1, int a2, unsigned __int16 a3)
{
  int v3; // ecx@3
  char result; // al@3
  int v5; // [sp+4h] [bp-8h]@3
  int v6; // [sp+8h] [bp-4h]@3

  if ( (a3 & 0x8000u) != 0
    || (signed __int16)a3 > *(_WORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 92) + 12) - 1 )
  {
    result = 0;
  }
  else
  {
    sub_1000F550(a1, (int)&v5, a3);
    v3 = v6;
    *(_DWORD *)a2 = v5;
    *(_DWORD *)(a2 + 4) = v3;
    result = 1;
  }
  return result;
}

//----- (1000F600) --------------------------------------------------------
bool __usercall sub_1000F600@<al>(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // ebx@1
  int v3; // edi@1
  bool result; // al@1

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 60);
  v3 = *(_DWORD *)(v1 + 12);
  sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008D018, (int)&unk_1008D028, 0, 255);
  result = sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)(v3 + 8), v2, 0, *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (1000F650) --------------------------------------------------------
void __usercall sub_1000F650(unsigned int a1@<esi>)
{
  int v1; // eax@1
  int v2; // ecx@1
  int v3; // ebx@1
  int v4; // edi@1
  __int16 v5; // bp@1
  __int16 v6; // [sp+Ch] [bp-24h]@5
  int v7; // [sp+10h] [bp-20h]@5
  __int16 v8; // [sp+14h] [bp-1Ch]@8
  int v9; // [sp+18h] [bp-18h]@8
  __int16 v10; // [sp+1Ch] [bp-14h]@8
  __int16 v11; // [sp+20h] [bp-10h]@4
  int v12; // [sp+24h] [bp-Ch]@4
  __int16 v13; // [sp+28h] [bp-8h]@4
  __int16 v14; // [sp+2Ah] [bp-6h]@4
  int v15; // [sp+2Ch] [bp-4h]@4

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(a1 + 52);
  v3 = *(_DWORD *)(v1 + 4);
  v4 = *(_DWORD *)(v1 + 12);
  v5 = *(_WORD *)(v4 + 46);
  if ( *(_WORD *)(v2 + 10) != 33 )
    *(_BYTE *)(a1 + 6) = sub_100375A0(a1, (char *)v1, v2);
  switch ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) )
  {
    case 0x21:
      v12 = v3;
      v11 = -32687;
      v14 = *(_WORD *)(v4 + 46);
      v13 = *(_WORD *)(v4 + 40);
      v15 = *(_DWORD *)(v4 + 116);
      **(_WORD **)(v4 + 100) = v14;
      sub_10003E50(a1, (int)&v11, 16);
      goto LABEL_6;
    case 0x20:
    case 0x28:
      v7 = v3;
      v6 = -32690;
      sub_10003E50(a1, (int)&v6, 8);
LABEL_6:
      sub_100352A0(a1, 1, 0, 0);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 0x38:
    case 0x39:
      if ( v5 != *(_WORD *)(v4 + 46) )
      {
        v9 = v3;
        v8 = -32689;
        v10 = *(_WORD *)(v4 + 46);
        sub_10003E50(a1, (int)&v8, 12);
      }
      break;
    default:
      return;
  }
}

//----- (1000F760) --------------------------------------------------------
int __usercall sub_1000F760@<eax>(unsigned __int8 *a1@<ebx>, int a2@<esi>, _WORD *a3, _WORD *a4, _WORD *a5, _WORD *a6, _WORD *a7, __int16 a8, _WORD *a9, char a10, char a11, int a12, int a13)
{
  int v13; // eax@1
  __int16 v14; // bp@1
  __int16 v15; // cx@1
  __int16 v16; // dx@4
  __int16 v17; // cx@4
  int result; // eax@4
  char v19; // [sp+Bh] [bp-21h]@1
  int v20; // [sp+Ch] [bp-20h]@1
  int v21; // [sp+10h] [bp-1Ch]@1
  int v22; // [sp+14h] [bp-18h]@1
  int v23; // [sp+18h] [bp-14h]@1
  int v24; // [sp+1Ch] [bp-10h]@2
  int v25; // [sp+20h] [bp-Ch]@2
  __int16 v26; // [sp+24h] [bp-8h]@1
  __int16 v27; // [sp+26h] [bp-6h]@1
  __int16 v28; // [sp+28h] [bp-4h]@1
  __int16 v29; // [sp+2Ah] [bp-2h]@1

  v13 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 4);
  v14 = *(_WORD *)(v13 + 30) + *(_WORD *)(v13 + 34);
  v27 = *(_WORD *)(v13 + 30);
  v15 = *(_WORD *)(v13 + 28);
  LOWORD(v13) = v15 + *(_WORD *)(v13 + 32);
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v19 = 0;
  v29 = v14;
  v26 = v15;
  v28 = v13;
  if ( a10 )
  {
    v24 = a12;
    v25 = a13;
  }
  else
  {
    v24 = 0;
    v25 = 0;
    v19 = 3;
  }
  sub_1000F400((int)&v26, a2, (int)&v24, a7, a8, &v21, &v23, &v19, a1, a11);
  sub_1000F2D0(*a1, a2, (int)&v24, (int)&v26, a9, &v20, &v22, &v19, a11);
  v16 = v21;
  *a5 = v20;
  v17 = v22;
  *a6 = v16;
  result = (unsigned __int16)v23;
  *a3 = v17;
  *a4 = result;
  return result;
}

//----- (1000F870) --------------------------------------------------------
int __usercall sub_1000F870@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int *v2; // edi@1
  unsigned int v3; // eax@1
  signed __int16 v4; // dx@1
  int v5; // ecx@1
  __int16 v6; // ax@3
  int v7; // edx@3
  signed __int16 v8; // ax@3
  int v9; // edx@3
  int result; // eax@8

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = sub_10002E60(*(_DWORD *)(v1 + 112));
  v3 = sub_100035F0(*(_DWORD *)(v1 + 112), 0);
  v4 = 0;
  v5 = (v3 >> 16) & 0xFF;
  if ( *(_BYTE *)(v1 + 111) )
    v4 = 64;
  v6 = *(_WORD *)(v1 + 108);
  *(_WORD *)(v1 + 12) = v4;
  *(_DWORD *)(v1 + 16) = v1 + 72;
  *(_WORD *)(v1 + 24) = *(_WORD *)(v1 + 104);
  *(_WORD *)(v1 + 26) = *(_WORD *)(v1 + 106) + 1;
  v7 = *(_DWORD *)(v1 + 92);
  v8 = v6 - 2;
  *(_WORD *)(v1 + 84) = v8;
  *(_DWORD *)(v1 + 8) = 122;
  *(_WORD *)(v1 + 14) = 8;
  *(_DWORD *)(v1 + 20) = sub_1000F5A0;
  *(_WORD *)(v1 + 28) = 0;
  v9 = *(_DWORD *)(v7 + 4) & 0xC000;
  if ( v9 )
  {
    if ( v9 == 0x8000 )
      *(_WORD *)(v1 + 32) = v8 / 2 + 15;
    else
      *(_WORD *)(v1 + 32) = v8 + 14;
  }
  else
  {
    *(_WORD *)(v1 + 32) = 15;
  }
  result = *v2;
  *(_WORD *)(v1 + 34) = v5 + *(_WORD *)(*v2 + 24) - *(_WORD *)(*v2 + 26) + 16;
  *(_DWORD *)(v1 + 36) = 141;
  return result;
}

//----- (1000F950) --------------------------------------------------------
int __usercall sub_1000F950@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // ecx@1
  signed int v4; // esi@1
  __int16 v5; // dx@2
  signed int v6; // eax@2
  signed int v7; // ecx@4
  __int16 v8; // ax@4
  int result; // eax@7
  int v10; // ecx@7
  char v11; // [sp+Ch] [bp-14h]@2
  int v12; // [sp+14h] [bp-Ch]@2
  int v13; // [sp+18h] [bp-8h]@2

  v1 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v3 = *(_DWORD *)(v2 + 92);
  v4 = 0;
  *(_WORD *)(v2 + 106) = 0;
  *(_WORD *)(v2 + 108) = 0;
  if ( *(_WORD *)(v3 + 12) )
  {
    do
    {
      sub_1000F550(v1, (int)&v11, v4);
      sub_10002B90(v1, (char *)(v2 + 72), (int)&v11, &v12);
      v5 = v13 - v12 + 1;
      v6 = (signed __int16)(HIWORD(v13) - HIWORD(v12) + 1);
      if ( *(_WORD *)(v2 + 106) > v6 )
        LOWORD(v6) = *(_WORD *)(v2 + 106);
      v7 = *(_WORD *)(v2 + 108);
      *(_WORD *)(v2 + 106) = v6;
      v8 = v5;
      if ( v7 > v5 )
        v8 = v7;
      *(_WORD *)(v2 + 108) = v8;
      ++v4;
    }
    while ( v4 < *(_WORD *)(*(_DWORD *)(v2 + 92) + 12) );
  }
  result = -6 * *(_BYTE *)(v2 + 111)
         - *(_WORD *)(*(_DWORD *)(v1 + 52) + 16)
         + *(_WORD *)(*(_DWORD *)(v1 + 52) + 20)
         - 28;
  v10 = *(_WORD *)(v2 + 108);
  if ( v10 <= result )
    *(_WORD *)(v2 + 108) = result;
  else
    *(_WORD *)(v2 + 108) = v10;
  return result;
}

//----- (1000FA30) --------------------------------------------------------
void __cdecl sub_1000FA30(int a1)
{
  int v1; // ebp@1
  int v2; // edi@1
  int v3; // eax@1
  _DWORD *v4; // ecx@1
  int v5; // eax@1
  int v6; // ecx@2
  _WORD *v7; // eax@3
  void *v8; // ecx@3
  void *v9; // ecx@3
  void *v10; // ecx@5
  void *v11; // ecx@7
  int v12; // eax@9
  unsigned __int16 v13; // si@11
  int v14; // eax@11
  int v15; // ecx@11
  _DWORD *v16; // [sp+Ch] [bp-4h]@1
  char v17; // [sp+14h] [bp+4h]@9

  v1 = a1;
  v2 = sub_10003D50(a1, *(char **)(a1 + 56), 120, 1);
  v3 = *(_DWORD *)(a1 + 56);
  v4 = *(_DWORD **)(v3 + 60);
  v5 = *(_DWORD *)(v3 + 4);
  v16 = v4;
  if ( v5 && (v6 = *(_DWORD *)(a1 + 52), *(_DWORD *)(v6 + 28) == *(_DWORD *)(v5 + 8)) )
  {
    *(_DWORD *)(v2 + 92) = *(_DWORD *)(v6 + 8);
    v7 = *(_WORD **)(*(_DWORD *)(a1 + 52) + 12);
    *(_DWORD *)(v2 + 100) = v7;
    *(_WORD *)(v2 + 96) = *v7;
    v8 = *(void **)(*(_DWORD *)(a1 + 52) + 24);
    *(_DWORD *)(v2 + 116) = v8;
    if ( (sub_10036FE0(v8) == 8 || sub_10036FE0(v9) == 2 || !(sub_10037130(v9) & 3) && sub_10037080(v10) != 1)
      && sub_10036FE0(v9) != 2 )
    {
      sub_10036FE0(v11);
    }
    v12 = *(_DWORD *)(v2 + 92);
    *(_DWORD *)(v2 + 112) = 4134;
    *(_BYTE *)(v2 + 110) = 0;
    *(_WORD *)(v2 + 104) = *(_WORD *)(v12 + 12);
    *(_BYTE *)(v2 + 111) = 0;
    *(_DWORD *)(v2 + 72) = 118;
    *(_DWORD *)(v2 + 80) = *(_DWORD *)(v12 + 4) & 0xC000 | 0x1026;
    *(_BYTE *)(v2 + 76) = 0;
    *(_WORD *)(v2 + 84) = 0;
    *(_WORD *)(v2 + 88) = 0;
    *(_WORD *)(v2 + 90) = 0;
    sub_1000F950(a1);
    v17 = 0;
    if ( *(_BYTE *)(*(_DWORD *)(v2 + 92) + 8) & 4 )
      v17 = 1;
    sub_1000F760(
      (unsigned __int8 *)(v2 + 111),
      v1,
      (_WORD *)(v2 + 4),
      (_WORD *)(v2 + 6),
      (_WORD *)(v2 + 2),
      (_WORD *)v2,
      (_WORD *)(v2 + 104),
      *(_WORD *)(v2 + 106),
      (_WORD *)(v2 + 108),
      1,
      v17,
      *(_DWORD *)(*(_DWORD *)(v1 + 52) + 16),
      *(_DWORD *)(*(_DWORD *)(v1 + 52) + 20));
    sub_1000F870(v1);
    sub_10002870(v1, *(_WORD *)(v2 + 4), *(_WORD *)(v2 + 6), *(_WORD *)(v2 + 2), *(_WORD *)v2, 0);
    sub_100374D0(*(_DWORD *)(v1 + 56), (char *)(v2 + 8));
    *v16 = v2 + 44;
    v13 = *(_WORD *)(v2 + 96);
    v14 = *(_DWORD *)(v2 + 92);
    *(_DWORD *)(v2 + 56) = 0;
    *(_WORD *)(v2 + 48) = v13;
    *(_WORD *)(v2 + 46) = v13;
    *(_DWORD *)(v2 + 60) = v2 + 64;
    *(_WORD *)(v2 + 52) = *(_WORD *)(v14 + 12);
    *(_WORD *)(v2 + 40) = v13;
    sub_1000F550(v1, v2 + 64, v13);
    *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230) = 0;
    sub_10004590(v1, *(_DWORD *)(v1 + 56), -32734);
    sub_10002C10(
      v1,
      &unk_100B097C,
      *(char ***)(*(_DWORD *)(v1 + 56) + 56),
      *(_DWORD *)(*(_DWORD *)(v1 + 56) + 60),
      0,
      *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230));
    v15 = *(_DWORD *)(v1 + 56);
    *(_BYTE *)(v1 + 9) = 1;
    *(_BYTE *)(v15 + 247) = 1;
    sub_100375A0(v1, *(char **)(*(_DWORD *)(v1 + 56) + 4), (int)&unk_100B096C);
    *(_BYTE *)(v1 + 6) = 2;
  }
  else
  {
    sub_100352A0(a1, 1, 0, 0);
    *(_BYTE *)(a1 + 6) = 2;
  }
}

//----- (1000FC40) --------------------------------------------------------
void __cdecl sub_1000FC40(unsigned int a1)
{
  bool v1; // zf@5

  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x8041:
      *(_BYTE *)(a1 + 6) = 2;
      byte_10141FF0 = 0;
      break;
    case 0x8050:
      sub_1000FA30(a1);
      byte_10141FF0 = 1;
      break;
    case 0x8022:
      sub_1000F600(a1);
      break;
    case 0x8048:
      v1 = byte_10141FF0 == 0;
      *(_BYTE *)(a1 + 6) = 2;
      if ( !v1 )
        sub_1000F650(a1);
      break;
    case 0x80AA:
      sub_10002300(a1);
      break;
    default:
      return;
  }
}
// 10141FF0: using guessed type char byte_10141FF0;

//----- (1000FD50) --------------------------------------------------------
char __cdecl sub_1000FD50(int a1, char a2, __int16 a3, char *a4, float a5, int a6)
{
  int v7; // [sp+8h] [bp-14h]@1
  int v8; // [sp+Ch] [bp-10h]@1
  int v9; // [sp+10h] [bp-Ch]@1
  float v10; // [sp+14h] [bp-8h]@1
  int v11; // [sp+18h] [bp-4h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0.0;
  v11 = 0;
  if ( a3 & 1 )
    strncpy((char *)(a1 + 84), a4, 0xB4u);
  v10 = a5;
  LOWORD(v7) = -32673;
  v8 = 0;
  LOBYTE(v9) = a2;
  HIWORD(v9) = a3;
  v11 = a6;
  return sub_10003E50(a1, (int)&v7, 20);
}

//----- (1000FDE0) --------------------------------------------------------
char __usercall sub_1000FDE0@<al>(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // edi@1
  char v3; // al@3

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 12);
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8) == 1 )
  {
    switch ( *(_BYTE *)(v2 + 371) )
    {
      case 0:
      case 1:
      case 6:
      case 7:
        v3 = sub_1003BE80();
        LOBYTE(v1) = sub_1003BDD0(v3);
        *(_BYTE *)(a1 + 6) = 2;
        break;
      case 2:
      case 3:
      case 8:
        LOBYTE(v1) = sub_1003CDB0();
        *(_BYTE *)(a1 + 6) = 2;
        break;
      default:
        v1 = *(_DWORD *)v2;
        if ( *(_DWORD *)v2 )
          LOBYTE(v1) = ((int (__cdecl *)(int))v1)(a1);
        *(_BYTE *)(v2 + 371) = 5;
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    *(_BYTE *)(a1 + 6) = 2;
  }
  return v1;
}

//----- (1000FE60) --------------------------------------------------------
char __usercall sub_1000FE60@<al>(int a1@<esi>)
{
  char result; // al@1

  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 246) = 1;
  result = sub_10004590(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (1000FE90) --------------------------------------------------------
char __usercall sub_1000FE90@<al>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // ecx@1
  char result; // al@1

  v1 = sub_10003D50(a1, *(char **)(a1 + 56), 428, 1);
  v2 = v1;
  *(_BYTE *)(v1 + 370) = 0;
  *(_BYTE *)(v1 + 371) = 9;
  *(_WORD *)(v1 + 408) = 0;
  *(_DWORD *)v1 = 0;
  *(_DWORD *)(v1 + 412) = 0;
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4);
  *(_BYTE *)(v1 + 364) = 0;
  sub_10002870(
    a1,
    *(_WORD *)(v3 + 28) + *(_WORD *)(v3 + 32) / 2 - 148,
    *(_WORD *)(v3 + 30) + *(_WORD *)(v3 + 34) / 2 - 120,
    296,
    240,
    0);
  sub_10018E40(a1, &unk_1008D5D8, 1u, 0, 0);
  sub_100374D0(*(_DWORD *)(a1 + 56), (char *)&unk_1008D624);
  **(_DWORD **)(*(_DWORD *)(a1 + 56) + 60) = &unk_1008D66C;
  **(_BYTE **)(*(_DWORD *)(a1 + 56) + 64) = 0;
  *(_WORD *)(v2 + 404) = 771;
  *(_DWORD *)(v2 + 416) = v2 + 184;
  *(_BYTE *)(v2 + 184) = 0;
  *(_DWORD *)(v2 + 420) = v2 + 366;
  *(_WORD *)(v2 + 366) = 6;
  *(_BYTE *)(v2 + 406) = 0;
  *(_BYTE *)(v2 + 4) = 0;
  *(_BYTE *)(v2 + 368) = 0;
  *(_BYTE *)(v2 + 369) = 0;
  *(_DWORD *)(v2 + 424) = v2 + 372;
  *(_BYTE *)(v2 + 372) = 2;
  *(_WORD *)(v2 + 384) = 495;
  *(_WORD *)(v2 + 386) = 2095;
  *(_BYTE *)(v2 + 373) = 2;
  *(_WORD *)(v2 + 382) = 32;
  *(_BYTE *)(v2 + 374) = 20;
  *(_BYTE *)(v2 + 375) = 2;
  *(_WORD *)(v2 + 380) = 266;
  *(_BYTE *)(v2 + 376) = 5;
  *(_WORD *)(v2 + 396) = 148;
  *(_WORD *)(v2 + 398) = 159;
  *(_WORD *)(v2 + 388) = 10;
  *(float *)(v2 + 400) = 0.0;
  *(_BYTE *)(v2 + 377) = 1;
  *(_WORD *)(v2 + 378) = 0;
  *(_DWORD *)(v2 + 392) = 34863;
  sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008D63C, v2 + 416, 0, 255);
  sub_10002D30(
    a1,
    *(_WORD **)(a1 + 52),
    (char *)&unk_1008D624,
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  result = sub_10004590(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10010060) --------------------------------------------------------
void __usercall sub_10010060(unsigned int a1@<esi>)
{
  int v1; // edi@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_BYTE *)(a1 + 6) = sub_100375A0(a1, *(char **)(a1 + 56), *(_DWORD *)(a1 + 52));
  if ( *(_BYTE *)(v1 + 370) != 1 )
  {
    switch ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) )
    {
      case 0x1C:
      case 0x1D:
      case 0x1E:
      case 0x1F:
      case 0x20:
      case 0x38:
      case 0x39:
        *(_BYTE *)(a1 + 6) = 2;
        break;
      default:
        break;
    }
  }
  if ( *(_BYTE *)(v1 + 370) )
  {
    if ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) == 33 )
    {
      sub_100352A0(a1, 1, 0, 0);
      *(_BYTE *)(a1 + 6) = 2;
    }
  }
}

//----- (10010100) --------------------------------------------------------
int __usercall sub_10010100@<eax>(int a1@<esi>)
{
  int v1; // edi@1
  __int16 v2; // cx@1
  int result; // eax@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_BYTE *)(v1 + 371) = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  v2 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 10);
  *(_WORD *)(v1 + 408) = v2;
  *(_DWORD *)v1 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 16);
  if ( v2 & 1 )
    sub_100365D0(v1 + 184, (_BYTE *)(a1 + 84), 180);
  result = *(_DWORD *)(a1 + 52);
  *(float *)(v1 + 400) = *(float *)(result + 12);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10010160) --------------------------------------------------------
void __usercall sub_10010160(unsigned int a1@<esi>)
{
  char v1; // [sp+0h] [bp-B8h]@2

  if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 371) == 4 )
    sub_100365D0((int)&v1, "Cancel operation?", 180);
  else
    sub_100365D0((int)&v1, "Cancel upload?", 180);
  sub_100163A0(a1, 0, &v1, 0);
}

//----- (100101D0) --------------------------------------------------------
char __cdecl sub_100101D0(int a1)
{
  int v1; // eax@1
  int v2; // esi@1
  char result; // al@1
  unsigned __int8 v4; // al@2
  _BYTE *v5; // ebp@10
  char *v6; // eax@11
  char v7; // cl@12
  _WORD *v8; // edi@13
  char v9; // al@14
  char *v10; // eax@18
  char v11; // cl@19
  char *v12; // eax@21
  char v13; // cl@22
  char v14; // al@33
  unsigned __int8 v15; // [sp+6h] [bp-FEh]@1
  unsigned __int8 v16; // [sp+7h] [bp-FDh]@1
  char v17; // [sp+Ch] [bp-F8h]@1
  unsigned int v18; // [sp+90h] [bp-74h]@8
  unsigned int v19; // [sp+98h] [bp-6Ch]@9
  char v20; // [sp+9Ch] [bp-68h]@17
  _BYTE v21[3]; // [sp+9Dh] [bp-67h]@20

  v1 = *(_DWORD *)(a1 + 56);
  v15 = 12;
  v2 = *(_DWORD *)(v1 + 12);
  v16 = 0;
  memset(&v17, 0, 0x90u);
  result = sub_1003BE20(&v15);
  if ( result == 1 )
  {
    v4 = v15;
    if ( v15 >= 7u && v15 <= 9u )
    {
      *(_BYTE *)(v2 + 370) = 1;
      v4 = v15;
    }
    *(_WORD *)(v2 + 366) = word_1008D680[v4];
    if ( v15 == 11 && sub_1003CDF0(&v16) && sub_1003CE20((int)&v17) && v18 )
    {
      *(_WORD *)(v2 + 366) = word_1008D5E4[v16];
      *(_BYTE *)(v2 + 406) = 3;
      *(float *)(v2 + 400) = (double)v19 / (double)v18;
    }
    v5 = (_BYTE *)(v2 + 4);
    if ( *(_BYTE *)(v2 + 408) & 1 )
    {
      v6 = (char *)(v2 + 184);
      do
      {
        v7 = *v6;
        v6[(_DWORD)&v5[-v2 - 184]] = *v6;
        ++v6;
      }
      while ( v7 );
      v8 = (_WORD *)(v2 + 3);
      do
      {
        v9 = *((_BYTE *)v8 + 1);
        v8 = (_WORD *)((char *)v8 + 1);
      }
      while ( v9 );
      *v8 = 10;
    }
    else
    {
      *v5 = 0;
    }
    if ( sub_1003BE50(&v20) )
    {
      v10 = &v20;
      do
        v11 = *v10++;
      while ( v11 );
      if ( v10 != v21 )
      {
        v12 = (char *)(v2 + 4);
        do
          v13 = *v12++;
        while ( v13 );
        strncat((char *)(v2 + 4), &v20, 180 - (_DWORD)&v12[-v2 - 5]);
        *(_DWORD *)(v2 + 416) = v5;
      }
    }
    result = v15 - 7;
    if ( v15 == 7 )
    {
      *(_BYTE *)(v2 + 364) = 2;
    }
    else
    {
      result = v15 - 8;
      if ( v15 == 8 )
      {
        *(_BYTE *)(v2 + 364) = 4;
      }
      else
      {
        result = v15 - 9;
        if ( v15 == 9 )
          *(_BYTE *)(v2 + 364) = 3;
        else
          *(_BYTE *)(v2 + 364) = 1;
      }
    }
    if ( v15 )
    {
      *(_DWORD *)(v2 + 412) = 0;
    }
    else if ( ++*(_DWORD *)(v2 + 412) > 0x64u )
    {
      v14 = sub_1003BE80();
      result = sub_1003BDD0(v14);
      *(_BYTE *)(v2 + 370) = 1;
    }
  }
  return result;
}
// 1008D5E4: using guessed type __int16 word_1008D5E4[];
// 1008D680: using guessed type __int16 word_1008D680[];

//----- (10010420) --------------------------------------------------------
void __usercall sub_10010420(int a1@<eax>)
{
  int v1; // ecx@1
  __int16 v2; // dx@1
  double v3; // st7@4

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(_WORD *)(v1 + 408);
  *(_WORD *)(v1 + 366) = 100;
  *(_BYTE *)(v1 + 364) = 1;
  if ( v2 & 0x10 )
    *(_WORD *)(v1 + 366) = 3823;
  if ( *(_BYTE *)(v1 + 371) == 5 )
  {
    v3 = *(float *)(v1 + 400);
    *(_BYTE *)(v1 + 370) = 1;
    if ( v3 < 0.9900000095367432 )
    {
      *(_WORD *)(v1 + 366) = 2585;
      *(_BYTE *)(v1 + 364) = 4;
      if ( v2 & 8 )
        *(_WORD *)(v1 + 366) = 3881;
      return;
    }
LABEL_9:
    *(_BYTE *)(v1 + 364) = 2;
    *(_WORD *)(v1 + 366) = 1495;
    return;
  }
  if ( v2 & 0x40 && 1.0 == *(float *)(v1 + 400) )
    goto LABEL_9;
}

//----- (100104C0) --------------------------------------------------------
char __cdecl sub_100104C0(int a1)
{
  int v1; // esi@1
  __int16 v2; // ax@1
  unsigned __int8 v3; // al@3
  unsigned __int8 v5; // [sp+7h] [bp-99h]@1
  unsigned int v6; // [sp+8h] [bp-98h]@8
  char v7; // [sp+Ch] [bp-94h]@1
  unsigned int v8; // [sp+90h] [bp-10h]@7
  unsigned int v9; // [sp+98h] [bp-8h]@8

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v5 = 0;
  memset(&v7, 0, 0x90u);
  LOBYTE(v2) = sub_1003CDF0(&v5);
  if ( (_BYTE)v2 == 1 )
  {
    LOBYTE(v2) = sub_1003CE20((int)&v7);
    if ( (_BYTE)v2 == 1 )
    {
      v3 = v5;
      if ( v5 )
      {
        if ( v5 > 4u && v5 <= 7u )
        {
          *(_BYTE *)(v1 + 370) = 1;
          v3 = v5;
        }
        *(_WORD *)(v1 + 366) = word_1008D5E4[v3];
        if ( v8 )
        {
          v6 = v8;
          *(float *)(v1 + 400) = (double)v9 / (double)v8;
        }
        LOBYTE(v2) = v5 - 5;
        if ( v5 == 5 )
        {
          *(_BYTE *)(v1 + 364) = 3;
        }
        else
        {
          LOBYTE(v2) = v5 - 6;
          if ( v5 == 6 )
          {
            *(_BYTE *)(v1 + 364) = 2;
          }
          else
          {
            LOBYTE(v2) = v5 - 7;
            if ( v5 == 7 )
              *(_BYTE *)(v1 + 364) = 4;
            else
              *(_BYTE *)(v1 + 364) = 1;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 370) = 1;
        v2 = word_1008D5E4[v5];
        *(_WORD *)(v1 + 366) = v2;
      }
    }
  }
  return v2;
}
// 1008D5E4: using guessed type __int16 word_1008D5E4[];

//----- (10010650) --------------------------------------------------------
char __usercall sub_10010650@<al>(int a1@<esi>)
{
  int v1; // edi@1
  int v2; // ebp@1
  __int16 v4; // [sp+Ch] [bp-298h]@2
  int v5; // [sp+10h] [bp-294h]@2
  char v6; // [sp+14h] [bp-290h]@2
  __int16 v7; // [sp+16h] [bp-28Eh]@2
  __int16 v8; // [sp+18h] [bp-28Ch]@2
  __int16 v9; // [sp+1Ah] [bp-28Ah]@2
  char v10; // [sp+1Ch] [bp-288h]@2
  char v11; // [sp+D8h] [bp-1CCh]@1
  char v12; // [sp+19Ch] [bp-108h]@1
  char v13; // [sp+19Dh] [bp-107h]@1

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 12);
  v11 = 0;
  v12 = 1;
  memset(&v13, 0, 0x100u);
  if ( *(_BYTE *)(v2 + 370) )
  {
    v4 = -32696;
    v5 = v1;
    v6 = 1;
    v7 = 33;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    sub_10003DE0(a1, (int)&v4, 204);
  }
  else
  {
    v12 = 0;
    sub_100365D0((int)&v13, "Option not selected", 256);
  }
  *(_BYTE *)(a1 + 6) = 2;
  return sub_10036820(&v11);
}

//----- (10010720) --------------------------------------------------------
bool __usercall sub_10010720@<al>(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // edi@1
  bool v3; // zf@2
  int v4; // eax@23
  bool result; // al@25

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 12);
  if ( *(_BYTE *)(v2 + 370) == 1 )
  {
    **(_BYTE **)(v1 + 64) = 3;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = 0;
    v3 = *(_BYTE *)(v2 + 364) == 0;
    *(_BYTE *)(v2 + 368) = 1;
    if ( !v3 )
    {
      sub_1003BD40((char *)(v2 + 364));
      *(_BYTE *)(v2 + 364) = 0;
    }
  }
  else
  {
    *(_DWORD *)(v2 + 416) = v2 + 184;
    switch ( *(_BYTE *)(v2 + 371) )
    {
      case 0:
      case 1:
        *(_BYTE *)(v2 + 406) = 0;
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 246) = 1;
        sub_100101D0(a1);
        break;
      case 7:
        *(_WORD *)(v2 + 386) = 2319;
        goto LABEL_7;
      case 6:
LABEL_7:
        *(_BYTE *)(v2 + 406) = 3;
        break;
      case 8:
        *(_WORD *)(v2 + 386) = 2319;
        goto LABEL_9;
      case 2:
      case 3:
LABEL_9:
        *(_BYTE *)(v2 + 406) = 3;
        sub_100104C0(a1);
        break;
      default:
        if ( *(_WORD *)(v2 + 408) & 2 || *(_BYTE *)(v2 + 406) )
        {
          if ( *(_WORD *)(v2 + 408) & 2 && *(_BYTE *)(v2 + 406) == 3 )
          {
            *(_BYTE *)(v2 + 406) = 0;
            *(_BYTE *)(*(_DWORD *)(a1 + 56) + 246) = 1;
          }
        }
        else
        {
          *(_BYTE *)(v2 + 406) = 3;
          *(_BYTE *)(*(_DWORD *)(a1 + 56) + 246) = 1;
        }
        sub_10010420(a1);
        break;
    }
    switch ( *(_BYTE *)(v2 + 371) )
    {
      case 0:
      case 2:
      case 6:
      case 7:
        sub_10018700(a1, 0, 0);
        *(_BYTE *)(v2 + 370) = 0;
        break;
      case 4:
        if ( *(_BYTE *)(v2 + 408) & 4 )
        {
          sub_10018700(a1, 0, 0);
          *(_BYTE *)(v2 + 370) = 0;
        }
        else
        {
          sub_10018700(a1, 0, 2);
          *(_BYTE *)(v2 + 370) = 0;
        }
        break;
      default:
        sub_10018700(a1, 0, 2);
        break;
    }
  }
  v4 = *(_DWORD *)(a1 + 56);
  if ( *(_BYTE *)(v4 + 246) )
  {
    *(_BYTE *)(v4 + 246) = 0;
    sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008D5F4, (int)&unk_1008D670, 0, 255);
  }
  sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008D63C, v2 + 416, v2 + 404, 255);
  result = sub_10002D30(
             a1,
             *(_WORD **)(a1 + 52),
             (char *)&unk_1008D624,
             *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
             *(_DWORD *)(*(_DWORD *)(a1 + 56) + 64),
             *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10010A60) --------------------------------------------------------
void __cdecl sub_10010A60(int a1, char a2, __int16 a3, char *a4, float a5, int a6)
{
  sub_1000FD50(a1, a2, a3, a4, a5, a6);
  sub_100352A0(a1, 0, (int (__cdecl *)(int))sub_10010940, 0);
}
// 10010940: using guessed type int sub_10010940();

//----- (10010AA0) --------------------------------------------------------
void *__usercall sub_10010AA0@<eax>(void *result@<eax>, char a2@<cl>, int a3@<esi>)
{
  char *v3; // eax@3
  char *v4; // eax@4

  if ( (unsigned int)result + 61 > 0x3C )
  {
    if ( a2 )
    {
      result = (void *)sprintf((char *)a3, "UNKNOWN ERROR %02X", result);
      *(_BYTE *)(a3 + 25) = 0;
    }
    else
    {
      *(_DWORD *)a3 = *(_DWORD *)"UNKNOWN";
      *(_BYTE *)(a3 + 25) = 0;
      *(_DWORD *)(a3 + 4) = *(_DWORD *)"OWN";
    }
  }
  else if ( a2 )
  {
    v3 = sub_1003CEB0((int)result);
    result = strncpy((char *)a3, v3, 0x19u);
    *(_BYTE *)(a3 + 25) = 0;
  }
  else
  {
    v4 = sub_1003CEB0((int)result);
    strncpy((char *)a3, v4, 0x19u);
    *(_BYTE *)(a3 + 1) = 82;
    *(_BYTE *)(a3 + 2) = 82;
    *(_BYTE *)(a3 + 24) = 0;
    *(_BYTE *)a3 = 69;
    *(_BYTE *)(a3 + 3) = 95;
    result = memcpy((void *)a3, (const void *)(a3 + 4), strlen((const char *)a3) - 4);
    *(_BYTE *)(a3 + 25) = 0;
  }
  return result;
}

//----- (10010B50) --------------------------------------------------------
char __usercall sub_10010B50@<al>(int a1@<eax>, int a2@<edx>, signed int a3@<ecx>)
{
  int v3; // ebp@1
  signed int *v4; // edi@4
  _BYTE *v5; // edx@4
  int v6; // esi@4
  unsigned int *v7; // ebx@4
  char result; // al@4
  int v9; // edi@5
  void *v10; // eax@5
  char v11; // [sp+13h] [bp-5h]@2
  _DWORD *v12; // [sp+14h] [bp-4h]@4

  v3 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 12);
  if ( a3 < 0 || (v11 = 1, a3 >= *(_WORD *)(v3 + 65312)) )
    v11 = 0;
  v4 = (signed int *)(a1 + 40);
  *(_DWORD *)(a1 + 24) = a1 + 72;
  v5 = (_BYTE *)(a1 + 32);
  v6 = a1 + 44;
  v12 = (_DWORD *)(a1 + 72);
  v7 = (unsigned int *)(a1 + 76);
  *(_DWORD *)(a1 + 12) = a1 + 32;
  *(_DWORD *)(a1 + 16) = a1 + 40;
  *(_DWORD *)(a1 + 20) = a1 + 44;
  *(_DWORD *)(a1 + 28) = a1 + 76;
  *(_DWORD *)(a1 + 4) = &unk_1008DC98;
  *(_DWORD *)(a1 + 8) = &unk_1008DCA0;
  *(_WORD *)(a1 + 34) = 9;
  *(_WORD *)(a1 + 36) = 0;
  result = v11;
  *v4 = a3;
  if ( v11 )
  {
    *v5 = a3 != *(_WORD *)(v3 + 65306) ? 33 : 47;
    v9 = *(_WORD *)(v3 + 65312) - a3;
    v10 = *(void **)(v3 + 4 * v9-- + 392);
    sub_10010AA0(v10, 0, v6);
    *v12 = *(_DWORD *)(640 * v9 + v3 + 1200);
    result = v11;
    *v7 = *(_DWORD *)(640 * v9 + v3 + 1200) % 0x15180u;
  }
  else
  {
    *v5 = 33;
    *v7 = 0x7FFFFFFF;
    *v12 = -1;
    *(_DWORD *)v6 = 1280724553;
    *(_WORD *)(v6 + 4) = 68;
  }
  return result;
}

//----- (10010C50) --------------------------------------------------------
bool __usercall sub_10010C50@<al>(int a1@<eax>, int a2@<ebx>, signed int a3@<edi>)
{
  int v3; // edx@1
  unsigned int v4; // ecx@1
  bool result; // al@4
  signed int *v6; // esi@6

  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v4 = *(_WORD *)(v3 + 65312) - *(_WORD *)(v3 + 65306) - 1;
  result = a3 >= 0 && a3 < *(_WORD *)(v3 + 65504) && v4 <= 0x63;
  v6 = (signed int *)(a2 + 16);
  *(_DWORD *)(a2 + 12) = a2 + 16;
  *(_DWORD *)(a2 + 4) = &unk_1008D716;
  *(_DWORD *)(a2 + 8) = &unk_1008D717;
  if ( result )
  {
    if ( *(_DWORD *)(v3 + 65372) == 1 )
      *v6 = *(_DWORD *)(v3 + 4 * a3 + 140);
    else
      *v6 = *(_DWORD *)(v3 + 4 * (a3 + 160 * v4) + 1556);
  }
  else
  {
    *v6 = a3;
  }
  return result;
}

//----- (10010CD0) --------------------------------------------------------
int __fastcall sub_10010CD0(int a1, int a2)
{
  int v2; // ecx@1
  int result; // eax@1

  v2 = *(_DWORD *)(a2 + 56);
  result = *(_DWORD *)(v2 + 12);
  **(_BYTE **)(v2 + 64) = 0;
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a2 + 56) + 64) + 1) = 0;
  *(float *)(result + 65552) = 0.0;
  *(float *)(result + 65556) = 0.0;
  *(_WORD *)(result + 65328) = 32;
  *(_WORD *)(result + 65356) = 32;
  *(_WORD *)(result + 65396) = 32;
  *(_WORD *)(result + 65636) = 32;
  *(_WORD *)(result + 65645) = 32;
  *(_WORD *)(result + 65516) = 32;
  *(_DWORD *)(result + 65572) = 0;
  *(_DWORD *)(result + 65576) = 0;
  *(_DWORD *)(result + 65580) = 0;
  *(_DWORD *)(result + 65584) = 0;
  *(_DWORD *)(result + 65588) = 0;
  *(_DWORD *)(result + 65592) = 0;
  *(_DWORD *)(result + 65596) = 0;
  *(_DWORD *)(result + 65600) = 0;
  *(_DWORD *)(result + 65604) = 0;
  *(_DWORD *)(result + 65608) = 0;
  *(_DWORD *)(result + 65612) = 0;
  *(_DWORD *)(result + 65616) = 0;
  *(_DWORD *)(result + 65620) = 0;
  *(_DWORD *)(result + 65632) = 0;
  *(_DWORD *)(result + 65368) = 0;
  *(_DWORD *)(result + 136) = 0;
  *(_DWORD *)(result + 65544) = 0;
  *(_DWORD *)(result + 65352) = 0;
  *(_DWORD *)(result + 65324) = 0;
  return result;
}

//----- (10010DA0) --------------------------------------------------------
bool __cdecl sub_10010DA0(int a1, int a2, __int16 a3)
{
  return sub_10010C50(a1, a2, a3) != 0;
}

//----- (10010DC0) --------------------------------------------------------
char __cdecl sub_10010DC0(int a1)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // eax@1
  _BYTE *v5; // ecx@1
  _BYTE *v6; // esi@4
  _BYTE *v7; // eax@4
  signed int v8; // ecx@4
  char result; // al@6

  v1 = sub_10003D50(a1, *(char **)(a1 + 56), 65668, 2);
  v2 = v1;
  *(_BYTE *)(v1 + 65665) = 0;
  sub_10002870(a1, 0, 0, 1024, 768, 1);
  sub_100374D0(*(_DWORD *)(a1 + 56), (char *)&unk_1008DE24);
  v3 = *(_DWORD *)(a1 + 56);
  v4 = *(_DWORD *)(v3 + 60);
  *(_BYTE *)(v3 + 230) = -1;
  *(_BYTE *)(*(_DWORD *)(v3 + 64) + 1) = 2;
  v5 = *(_BYTE **)(v3 + 64);
  if ( *(_BYTE *)(v2 + 65665) )
    *v5 = 0;
  else
    *v5 = 3;
  *(_DWORD *)v4 = v2 + 65304;
  *(_DWORD *)(v4 + 4) = v2 + 65496;
  *(_DWORD *)(v2 + 65372) = 1;
  *(_DWORD *)(v2 + 65316) = 0;
  *(_WORD *)(v2 + 65308) = 0;
  *(_WORD *)(v2 + 65306) = 0;
  *(_DWORD *)(v2 + 65320) = v2 + 65196;
  *(_WORD *)(v2 + 65312) = 0;
  *(_DWORD *)(v2 + 65508) = 0;
  *(_WORD *)(v2 + 65500) = 0;
  *(_WORD *)(v2 + 65498) = 0;
  *(_DWORD *)(v2 + 65512) = v2 + 65376;
  *(_WORD *)(v2 + 65504) = 0;
  sub_10010B50(v2 + 65196, a1, -1);
  sub_10010C50(a1, v2 + 65376, -1);
  *(_DWORD *)v2 = v2 + 65276;
  *(_DWORD *)(v2 + 4) = v2 + 65328;
  *(_DWORD *)(v2 + 8) = v2 + 65356;
  *(_DWORD *)(v2 + 12) = v2 + 65396;
  *(_DWORD *)(v2 + 104) = v2 + 65636;
  *(_DWORD *)(v2 + 16) = v2 + 65572;
  *(_DWORD *)(v2 + 20) = v2 + 65576;
  *(_DWORD *)(v2 + 24) = v2 + 65580;
  *(_DWORD *)(v2 + 28) = v2 + 65584;
  *(_DWORD *)(v2 + 32) = v2 + 65588;
  *(_DWORD *)(v2 + 36) = v2 + 65592;
  *(_DWORD *)(v2 + 40) = v2 + 65596;
  *(_DWORD *)(v2 + 44) = v2 + 65600;
  *(_DWORD *)(v2 + 48) = v2 + 65604;
  *(_DWORD *)(v2 + 52) = v2 + 65608;
  *(_DWORD *)(v2 + 56) = v2 + 65612;
  *(_DWORD *)(v2 + 60) = v2 + 65616;
  *(_DWORD *)(v2 + 64) = v2 + 65620;
  *(_DWORD *)(v2 + 68) = v2 + 65632;
  *(_DWORD *)(v2 + 72) = v2 + 65368;
  *(_DWORD *)(v2 + 76) = v2 + 136;
  *(_DWORD *)(v2 + 80) = v2 + 65544;
  *(_DWORD *)(v2 + 84) = v2 + 65352;
  *(_DWORD *)(v2 + 88) = v2 + 65324;
  *(_DWORD *)(v2 + 92) = v2 + 65645;
  *(_DWORD *)(v2 + 96) = v2 + 65516;
  *(_DWORD *)(v2 + 112) = v2 + 65548;
  *(_DWORD *)(v2 + 116) = v2 + 65552;
  *(_DWORD *)(v2 + 100) = v2 + 65556;
  *(_DWORD *)(v2 + 124) = v2 + 65564;
  *(_DWORD *)(v2 + 120) = v2 + 65560;
  *(_DWORD *)(v2 + 128) = v2 + 65568;
  *(_DWORD *)(v2 + 108) = &unk_1008DC90;
  sub_10010CD0(v2 + 65560, a1);
  *(_BYTE *)(v2 + 65624) = 0;
  sub_10002D30(
    a1,
    *(_WORD **)(a1 + 52),
    (char *)&unk_1008DE24,
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008E118, v2, 0, 255);
  sub_10018E40(a1, &unk_1008DDE8, 6u, 16, 0);
  sub_100370D0(1);
  v6 = (_BYTE *)(v2 + 65625);
  v7 = &unk_1008DDEC;
  v8 = 6;
  do
  {
    *v6 = *v7;
    v7 += 10;
    ++v6;
    --v8;
  }
  while ( v8 );
  result = sub_10004590(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10011080) --------------------------------------------------------
void __usercall sub_10011080(unsigned int a1@<esi>)
{
  int v1; // edi@1
  char v2; // al@1
  int v3; // edx@1
  int v4; // eax@1
  int v5; // [sp+4h] [bp-BCh]@6
  char v6; // [sp+8h] [bp-B8h]@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = sub_100375A0(a1, *(char **)(a1 + 56), *(_DWORD *)(a1 + 52));
  v3 = *(_DWORD *)(a1 + 52);
  *(_BYTE *)(a1 + 6) = v2;
  v4 = *(_WORD *)(v1 + 65312) - *(_WORD *)(v1 + 65306) - 1;
  switch ( *(_WORD *)(v3 + 10) )
  {
    case 0x20:
      if ( !*(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) )
      {
        sprintf(&v6, "Delete Exception #%d?", *(_WORD *)(v1 + 65306));
        sub_100163A0(a1, 1, &v6, 0);
      }
      break;
    case 0x21:
    case 0x38:
    case 0x39:
      if ( *(_DWORD *)(v1 + 65372) == 1 && !*(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) )
      {
        v5 = 64;
        sub_10016490(640 * v4 + v1 + 1292, v1 + 140, &v5);
        *(_WORD *)(v1 + 65504) = v5;
      }
      break;
    default:
      return;
  }
}

//----- (100111C0) --------------------------------------------------------
int __usercall sub_100111C0@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  int v2; // ebp@1
  signed int v3; // edi@1
  signed int *v4; // esi@1
  signed int *v5; // ebx@1
  int result; // eax@6
  signed int v7; // edx@6
  int v8; // [sp+10h] [bp-4h]@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v8 = v1;
  v2 = 0;
  v3 = 0;
  v4 = (signed int *)(v1 + 796);
  v5 = (signed int *)(v1 + 1196);
  do
  {
    if ( !sub_10016B60(v5, v3) && *v5 < 62 )
    {
      *(v4 - 100) = *v5;
      *v4 = v3;
      ++v2;
      ++v4;
      v5 += 160;
    }
    ++v3;
  }
  while ( v3 < 100 );
  result = v8;
  v7 = *(_WORD *)(v8 + 65306);
  *(_DWORD *)(v8 + 132) = v2;
  *(_WORD *)(v8 + 65312) = v2;
  if ( v7 > (unsigned __int16)v2 )
    *(_WORD *)(v8 + 65306) = v2;
  return result;
}

//----- (10011240) --------------------------------------------------------
signed int sub_10011240()
{
  return sub_10016CD0("/mnt/card0");
}

//----- (10011250) --------------------------------------------------------
int __cdecl sub_10011250(int a1, int a2)
{
  int v2; // ebp@1
  int result; // eax@3
  int v4; // eax@7
  unsigned int v5; // eax@9
  char *v6; // eax@10
  int v7; // edx@10
  char v8; // cl@11
  int v9; // eax@14
  int v10; // eax@17
  char *v11; // ecx@17
  char v12; // dl@18
  char *v13; // ecx@19
  char v14; // dl@20
  _WORD *v15; // edi@21
  char v16; // cl@22
  _BYTE *v17; // ebp@23
  int v18; // eax@24
  int v19; // ebx@25
  char *v20; // eax@25
  char v21; // cl@26
  char *v22; // eax@27
  char v23; // cl@28
  unsigned int v24; // eax@29
  char *v25; // edi@29
  char v26; // cl@30
  _BYTE *v27; // ebp@31
  int v28; // [sp+8h] [bp-10h]@9
  char v29; // [sp+Ch] [bp-Ch]@29

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( a2 == -1 )
  {
    if ( *(_BYTE *)(v2 + 65665) )
    {
      *(_DWORD *)(v2 + 65276) = 1162297680;
      *(_DWORD *)(v2 + 65280) = 542329120;
      result = 1262702412;
      *(_DWORD *)(v2 + 65284) = 1262702412;
      *(_WORD *)(v2 + 65288) = 17477;
      *(_BYTE *)(v2 + 65290) = 0;
    }
    else
    {
      *(_DWORD *)(v2 + 65276) = 1330795077;
      *(_DWORD *)(v2 + 65280) = 1330389074;
      *(_DWORD *)(v2 + 65284) = 1397301319;
      result = 1347241248;
      *(_DWORD *)(v2 + 65288) = 1347241248;
      *(_WORD *)(v2 + 65292) = 22868;
      *(_BYTE *)(v2 + 65294) = 0;
    }
  }
  else if ( a2 == -2 )
  {
    *(_DWORD *)(v2 + 65276) = 1278094894;
    *(_DWORD *)(v2 + 65280) = 1229209935;
    *(_DWORD *)(v2 + 65284) = 1159743310;
    result = 1380930130;
    *(_DWORD *)(v2 + 65288) = 1380930130;
    *(_DWORD *)(v2 + 65292) = 1196379168;
    *(_DWORD *)(v2 + 65296) = 3026478;
  }
  else
  {
    sub_10010AA0(*(void **)(v2 + 4 * a2 + 396), 1, v2 + 65276);
    v4 = *(_DWORD *)(v2 + 4 * a2 + 396);
    if ( v4 != -8 && v4 != -12
      || (v28 = *(_DWORD *)(640 * a2 + v2 + 1284) & 0x40F,
          v5 = sub_1003B860(&v28, 4u, (int)&unk_1008DCA8, 32, 10, 10),
          v5 >= 0xA) )
    {
      *(_WORD *)(v2 + 65516) = 32;
    }
    else
    {
      v6 = &aAlignment[32 * v5];
      v7 = v2 + 65516 - (_DWORD)v6;
      do
      {
        v8 = *v6;
        v6[v7] = *v6;
        ++v6;
      }
      while ( v8 );
    }
    v9 = *(_DWORD *)(v2 + 4 * a2 + 396);
    if ( v9 == -5 || v9 == -44 )
    {
      v19 = 640 * a2 + v2;
      v20 = (char *)(v19 + 1681);
      do
      {
        v21 = *v20;
        v20[v2 + 65396 - (v19 + 1681)] = *v20;
        ++v20;
      }
      while ( v21 );
      v22 = (char *)(v19 + 1660);
      do
      {
        v23 = *v22;
        v22[v2 + 65328 - (v19 + 1660)] = *v22;
        ++v22;
      }
      while ( v23 );
      *(_DWORD *)(v2 + 65356) = 1162758476;
      *(_WORD *)(v2 + 65360) = 32;
      sprintf(&v29, "%ld", *(_DWORD *)(v19 + 1656));
      v24 = strlen(&v29) + 1;
      v25 = (char *)(v2 + 65355);
      do
        v26 = (v25++)[1];
      while ( v26 );
      qmemcpy(v25, &v29, v24);
      *(_DWORD *)(v2 + 65572) = *(_DWORD *)(v19 + 1216);
      *(_DWORD *)(v2 + 65576) = *(_DWORD *)(v19 + 1220);
      *(_DWORD *)(v2 + 65580) = *(_DWORD *)(v19 + 1224);
      *(_DWORD *)(v2 + 65584) = *(_DWORD *)(v19 + 1228);
      *(_DWORD *)(v2 + 65588) = *(_DWORD *)(v19 + 1232);
      *(_DWORD *)(v2 + 65592) = *(_DWORD *)(v19 + 1236);
      *(_DWORD *)(v2 + 65596) = *(_DWORD *)(v19 + 1240);
      *(_DWORD *)(v2 + 65600) = *(_DWORD *)(v19 + 1244);
      *(_DWORD *)(v2 + 65604) = *(_DWORD *)(v19 + 1248);
      *(_DWORD *)(v2 + 65608) = *(_DWORD *)(v19 + 1252);
      *(_DWORD *)(v2 + 65612) = *(_DWORD *)(v19 + 1256);
      *(_DWORD *)(v2 + 65616) = *(_DWORD *)(v19 + 1260);
      *(_DWORD *)(v2 + 65620) = *(_DWORD *)(v19 + 1264);
      *(_DWORD *)(v2 + 65632) = *(_DWORD *)(v19 + 1268);
      *(_DWORD *)(v2 + 65368) = *(_DWORD *)(v19 + 1272);
      *(_DWORD *)(v2 + 136) = *(_DWORD *)(v19 + 1276);
      *(_DWORD *)(v2 + 65544) = *(_DWORD *)(((5 * a2 + 10) << 7) + v2);
      *(_DWORD *)(v2 + 65352) = 0;
      *(_DWORD *)(v2 + 65324) = 0;
      v27 = (_BYTE *)(v2 + 65645);
      *v27 = 0;
      result = sub_10069720((int)v27, 1, *(_DWORD *)(v19 + 1212), 20);
    }
    else if ( v9 == -45 )
    {
      v10 = v2 + 640 * a2;
      v11 = (char *)(v10 + 1681);
      do
      {
        v12 = *v11;
        v11[v2 + 65396 - (v10 + 1681)] = *v11;
        ++v11;
      }
      while ( v12 );
      v13 = (char *)(v10 + 1660);
      do
      {
        v14 = *v13;
        v13[v2 + 65328 - (v10 + 1660)] = *v13;
        ++v13;
      }
      while ( v14 );
      v15 = (_WORD *)(v2 + 65355);
      do
      {
        v16 = *((_BYTE *)v15 + 1);
        v15 = (_WORD *)((char *)v15 + 1);
      }
      while ( v16 );
      *v15 = 32;
      *(_DWORD *)(v2 + 65572) = *(_DWORD *)(v10 + 1216);
      *(_DWORD *)(v2 + 65576) = *(_DWORD *)(v10 + 1220);
      *(_DWORD *)(v2 + 65580) = *(_DWORD *)(v10 + 1224);
      *(_DWORD *)(v2 + 65584) = *(_DWORD *)(v10 + 1228);
      *(_DWORD *)(v2 + 65588) = *(_DWORD *)(v10 + 1232);
      *(_DWORD *)(v2 + 65592) = *(_DWORD *)(v10 + 1236);
      *(_DWORD *)(v2 + 65596) = *(_DWORD *)(v10 + 1240);
      *(_DWORD *)(v2 + 65600) = *(_DWORD *)(v10 + 1244);
      *(_DWORD *)(v2 + 65604) = *(_DWORD *)(v10 + 1248);
      *(_DWORD *)(v2 + 65608) = *(_DWORD *)(v10 + 1252);
      *(_DWORD *)(v2 + 65612) = *(_DWORD *)(v10 + 1256);
      *(_DWORD *)(v2 + 65616) = *(_DWORD *)(v10 + 1260);
      *(_DWORD *)(v2 + 65620) = *(_DWORD *)(v10 + 1264);
      *(_DWORD *)(v2 + 65632) = *(_DWORD *)(v10 + 1268);
      *(_DWORD *)(v2 + 65368) = *(_DWORD *)(v10 + 1272);
      *(_DWORD *)(v2 + 136) = *(_DWORD *)(v10 + 1276);
      *(_DWORD *)(v2 + 65544) = *(_DWORD *)(((5 * a2 + 10) << 7) + v2);
      *(_DWORD *)(v2 + 65352) = 0;
      *(_DWORD *)(v2 + 65324) = 0;
      v17 = (_BYTE *)(v2 + 65645);
      *v17 = 0;
      result = sub_10069720((int)v17, 1, *(_DWORD *)(v10 + 1212), 20);
    }
    else
    {
      *(_WORD *)(v2 + 65328) = 32;
      *(_WORD *)(v2 + 65356) = 32;
      *(_WORD *)(v2 + 65396) = 32;
      v18 = v2 + 640 * a2;
      *(_DWORD *)(v2 + 65572) = *(_DWORD *)(640 * a2 + v2 + 1216);
      *(_DWORD *)(v2 + 65576) = *(_DWORD *)(v18 + 1220);
      *(_DWORD *)(v2 + 65580) = *(_DWORD *)(v18 + 1224);
      *(_DWORD *)(v2 + 65584) = *(_DWORD *)(v18 + 1228);
      *(_DWORD *)(v2 + 65588) = *(_DWORD *)(v18 + 1232);
      *(_DWORD *)(v2 + 65592) = *(_DWORD *)(v18 + 1236);
      *(_DWORD *)(v2 + 65596) = *(_DWORD *)(v18 + 1240);
      *(_DWORD *)(v2 + 65600) = *(_DWORD *)(v18 + 1244);
      *(_DWORD *)(v2 + 65604) = *(_DWORD *)(v18 + 1248);
      *(_DWORD *)(v2 + 65608) = *(_DWORD *)(v18 + 1252);
      *(_DWORD *)(v2 + 65612) = *(_DWORD *)(v18 + 1256);
      *(_DWORD *)(v2 + 65616) = *(_DWORD *)(v18 + 1260);
      *(_DWORD *)(v2 + 65620) = *(_DWORD *)(v18 + 1264);
      *(_DWORD *)(v2 + 65632) = *(_DWORD *)(v18 + 1268);
      *(_DWORD *)(v2 + 65368) = *(_DWORD *)(v18 + 1272);
      *(_DWORD *)(v2 + 136) = *(_DWORD *)(v18 + 1276);
      *(_DWORD *)(v2 + 65544) = *(_DWORD *)(((5 * a2 + 10) << 7) + v2);
      *(_DWORD *)(v2 + 65352) = *(_DWORD *)(v18 + 1284);
      *(_DWORD *)(v2 + 65324) = *(_DWORD *)(v18 + 1288);
      result = sub_10069720(v2 + 65645, 1, *(_DWORD *)(v18 + 1212), 20);
    }
  }
  return result;
}

//----- (10011880) --------------------------------------------------------
char __usercall sub_10011880@<al>(int a1@<esi>)
{
  int v1; // edi@1
  int v2; // ecx@1
  char result; // al@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10016C60();
  sub_100111C0(a1);
  if ( !*(_WORD *)(v1 + 65312) )
  {
    sub_10010CD0(v2, a1);
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  }
  *(_WORD *)(v1 + 65308) = 0;
  result = sub_10004590(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (100118D0) --------------------------------------------------------
char __usercall sub_100118D0@<al>(int a1@<edi>)
{
  int v1; // esi@1
  int v2; // ecx@1
  unsigned __int16 v3; // ax@1
  char result; // al@5

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10016C10(*(_DWORD *)(v1 + 4 * (*(_WORD *)(v1 + 65312) - *(_WORD *)(v1 + 65306)) + 792));
  sub_100111C0(a1);
  v3 = *(_WORD *)(v1 + 65312);
  if ( v3 )
  {
    if ( *(_WORD *)(v1 + 65306) >= (signed int)v3 )
      *(_WORD *)(v1 + 65306) = v3 - 1;
  }
  else
  {
    sub_10010CD0(v2, a1);
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  }
  result = sub_10004590(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10011950) --------------------------------------------------------
bool __cdecl sub_10011950(int a1, int a2, __int16 a3)
{
  return sub_10010B50(a2, a1, a3) != 0;
}

//----- (100119C0) --------------------------------------------------------
void __usercall sub_100119C0(int a1@<ecx>, unsigned int a2@<edi>)
{
  int v2; // eax@1
  int v3; // esi@1
  int v4; // ST04_4@4
  int v5; // [sp+0h] [bp-4h]@1

  v5 = a1;
  v2 = *(_DWORD *)(a2 + 56);
  v3 = *(_DWORD *)(v2 + 12);
  switch ( *(_BYTE *)(*(_DWORD *)(a2 + 52) + 8) )
  {
    case 0:
      *(_BYTE *)(v2 + 230) = 0;
      break;
    case 1:
      *(_BYTE *)(v2 + 230) = 1;
      break;
    case 2:
      v4 = 640 * (*(_WORD *)(v3 + 65312) - *(_WORD *)(v3 + 65306) - 1) + v3 + 1292;
      v5 = 64;
      sub_10016490(v4, v3 + 140, &v5);
      *(_WORD *)(v3 + 65504) = v5;
      *(_DWORD *)(v3 + 65372) = 1;
      *(_DWORD *)(v3 + 108) = &unk_1008DC90;
      break;
    case 3:
      *(_WORD *)(v3 + 65504) = 25;
      *(_DWORD *)(v3 + 65372) = 0;
      *(_DWORD *)(v3 + 108) = &unk_1008DC94;
      break;
    case 4:
      if ( sub_10011240() )
        sub_100163A0(a2, 2, "Error saving to card!", 2);
      else
        sub_100163A0(a2, 2, "Save to card complete.", 2);
      break;
    case 5:
      sub_100163A0(a2, 1, "Delete ALL Exceptions?", 1);
      break;
    default:
      sub_100364C0(".\\cdp_pg_test_diag.c", 2073, 0, 0);
      break;
  }
}

//----- (10011AF0) --------------------------------------------------------
bool __usercall sub_10011AF0@<al>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // eax@6
  int v4; // ebp@8
  int v5; // eax@9
  char v6; // cl@9
  bool v7; // zf@10
  int v8; // ebp@15
  void *v9; // ecx@20
  int v10; // eax@26
  unsigned int v11; // eax@33
  int v12; // eax@35
  bool result; // al@37
  int v14; // [sp+8h] [bp-1Ch]@6
  int v15; // [sp+Ch] [bp-18h]@28
  int v16; // [sp+10h] [bp-14h]@27
  unsigned int v17; // [sp+14h] [bp-10h]@28
  int v18; // [sp+18h] [bp-Ch]@30
  unsigned int v19; // [sp+1Ch] [bp-8h]@31
  unsigned int v20; // [sp+20h] [bp-4h]@31

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 12);
  if ( *(_BYTE *)(v2 + 65665) )
    **(_BYTE **)(v1 + 64) = 0;
  else
    **(_BYTE **)(v1 + 64) = 3;
  if ( *(_BYTE *)(v2 + 65624) && !*(_BYTE *)(v2 + 65665) )
  {
    *(_BYTE *)(v2 + 65624) = 0;
    sub_100111C0(a1);
    v3 = *(_WORD *)(v2 + 65312) - *(_WORD *)(v2 + 65306) - 1;
    v14 = 64;
    sub_10016490(640 * v3 + v2 + 1292, v2 + 140, &v14);
    *(_WORD *)(v2 + 65504) = v14;
    **(_BYTE **)(*(_DWORD *)(a1 + 56) + 64) = 3;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 1) = 2;
  }
  if ( *(_WORD *)(v2 + 65312) )
  {
    v5 = *(_DWORD *)(a1 + 56);
    v6 = *(_BYTE *)(v5 + 230);
    if ( v6 )
    {
      if ( v6 == 1 )
      {
        **(_BYTE **)(v5 + 64) = 2;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 1) = 3;
        v8 = *(_WORD *)(v2 + 65312) - *(_WORD *)(v2 + 65306);
        *(_BYTE *)(v2 + 65626) = 0;
        *(_BYTE *)(v2 + 65625) = 0;
        v4 = v8 - 1;
      }
      else
      {
        if ( v6 != -1 )
        {
          **(_BYTE **)(v5 + 64) = 3;
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 1) = 2;
        }
        *(_BYTE *)(v2 + 65626) = 1;
        *(_BYTE *)(v2 + 65625) = 1;
        v4 = 0;
      }
      *(_BYTE *)(v2 + 65628) = 1;
      *(_BYTE *)(v2 + 65627) = 1;
    }
    else
    {
      **(_BYTE **)(v5 + 64) = 3;
      v7 = *(_WORD *)(v2 + 65504) == 0;
      *(_BYTE *)(v2 + 65627) = 0;
      *(_BYTE *)(v2 + 65628) = 0;
      if ( v7 )
      {
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 1) = 0;
        *(_BYTE *)(v2 + 65626) = 1;
        *(_BYTE *)(v2 + 65625) = 1;
      }
      else
      {
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 1) = 2;
        *(_BYTE *)(v2 + 65626) = 0;
        *(_BYTE *)(v2 + 65625) = 0;
      }
      v4 = *(_WORD *)(v2 + 65312) - *(_WORD *)(v2 + 65306) - 1;
      *(_WORD *)(v2 + 65500) = 0;
      *(_WORD *)(v2 + 65498) = 0;
    }
  }
  else
  {
    **(_BYTE **)(*(_DWORD *)(a1 + 56) + 64) = 0;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 1) = 0;
    *(_BYTE *)(v2 + 65626) = 2;
    *(_BYTE *)(v2 + 65625) = 2;
    *(_BYTE *)(v2 + 65627) = 2;
    *(_BYTE *)(v2 + 65628) = 2;
    v4 = -(*(_BYTE *)(*(_DWORD *)(a1 + 56) + 246) != 0) - 1;
  }
  sub_10018700(a1, 0, *(_BYTE *)(v2 + 65625));
  sub_10018700(a1, 1u, *(_BYTE *)(v2 + 65626));
  sub_10018700(a1, 2u, *(_BYTE *)(v2 + 65627));
  sub_10018700(a1, 3u, *(_BYTE *)(v2 + 65628));
  if ( sub_10022FB0(v9) || *(_BYTE *)(v2 + 65665) )
  {
    sub_10018700(a1, 4u, 1);
    sub_10018700(a1, 5u, 1);
  }
  else
  {
    sub_10018700(a1, 4u, *(_BYTE *)(v2 + 65629));
    sub_10018700(a1, 5u, *(_BYTE *)(v2 + 65630));
  }
  sub_10011250(a1, v4);
  if ( v4 < 0 || *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) == -1 )
  {
    if ( sub_1006A0A0(2, (int)&v16, 8) )
    {
      sub_100364C0(".\\cdp_pg_test_diag.c", 2242, 0, 0);
    }
    else
    {
      *(float *)(v2 + 65552) = (double)v17 / 3600.0;
      *(_DWORD *)(v2 + 65548) = v16;
      v15 = sub_10069700();
      *(float *)(v2 + 65556) = (double)(unsigned int)v15 / 1000.0;
      sub_100365D0(v2 + 65636, "14.01", 9);
    }
  }
  else
  {
    v10 = v2 + 640 * v4;
    *(float *)(v2 + 65552) = (double)*(unsigned int *)(640 * v4 + v2 + 1208) / 3600.0;
    *(_DWORD *)(v2 + 65548) = *(_DWORD *)(v10 + 1204);
    *(float *)(v2 + 65556) = (double)*(unsigned int *)(v10 + 1792) / 1000.0;
    sub_100365D0(v2 + 65636, (_BYTE *)(v10 + 1781), 9);
  }
  if ( sub_1006A0A0(10, (int)&v18, 12) )
  {
    v18 = 0;
    v19 = 0;
    v20 = 0;
  }
  *(_DWORD *)(v2 + 65560) = (char)v18;
  *(_DWORD *)(v2 + 65564) = SBYTE1(v18);
  if ( v19 )
    v11 = v20 / v19;
  else
    v11 = 0;
  *(_DWORD *)(v2 + 65568) = v11;
  v12 = *(_DWORD *)(a1 + 56);
  if ( *(_BYTE *)(v12 + 246) )
  {
    *(_BYTE *)(v12 + 246) = 0;
    *(_BYTE *)(v2 + 65624) = 1;
    sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008DEE8, (int)&unk_1008E418, 0, 255);
  }
  sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008E118, v2, 0, 255);
  result = sub_10002D30(
             a1,
             *(_WORD **)(a1 + 52),
             (char *)&unk_1008DE24,
             *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
             *(_DWORD *)(*(_DWORD *)(a1 + 56) + 64),
             *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10011F30) --------------------------------------------------------
void __cdecl sub_10011F30(unsigned int a1)
{
  int v1; // eax@10
  int v2; // eax@11
  int v3; // eax@12
  int v4; // ecx@0

  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x801D:
      v1 = *(_DWORD *)(a1 + 52);
      if ( *(_BYTE *)(v1 + 8) == 1 )
      {
        v2 = *(_BYTE *)(v1 + 9);
        if ( v2 )
        {
          v3 = v2 - 1;
          if ( v3 )
          {
            if ( v3 != 1 )
              sub_100364C0(".\\cdp_pg_test_diag.c", 1740, 1, 0);
          }
          else
          {
            sub_10011880(a1);
          }
        }
        else
        {
          sub_100118D0(a1);
        }
      }
      break;
    case 0x8022:
      sub_1000FE60(a1);
      break;
    case 0x8041:
      sub_10010DC0(a1);
      break;
    case 0x8048:
      sub_10011080(a1);
      break;
    case 0x806E:
      sub_100119C0(v4, a1);
      break;
    case 0x8078:
      sub_10011AF0(a1);
      break;
    case 0x8018:
      sub_10012920(a1);
      break;
    case 0x8019:
    case 0x801A:
    case 0x801B:
    case 0x801C:
    case 0x801E:
    case 0x801F:
    case 0x8020:
    case 0x8021:
    case 0x8023:
    case 0x8024:
    case 0x8025:
    case 0x8026:
    case 0x8027:
    case 0x8028:
    case 0x8029:
    case 0x802A:
    case 0x802B:
    case 0x802C:
    case 0x802D:
    case 0x802E:
    case 0x802F:
    case 0x8030:
    case 0x8031:
    case 0x8032:
    case 0x8033:
    case 0x8034:
    case 0x8035:
    case 0x8036:
    case 0x8037:
    case 0x8038:
    case 0x8039:
    case 0x803A:
    case 0x803B:
    case 0x803C:
    case 0x803D:
    case 0x803E:
    case 0x803F:
    case 0x8040:
    case 0x8042:
    case 0x8043:
    case 0x8044:
    case 0x8045:
    case 0x8046:
    case 0x8047:
    case 0x8049:
    case 0x804A:
    case 0x804B:
    case 0x804C:
    case 0x804D:
    case 0x804E:
    case 0x804F:
    case 0x8050:
    case 0x8051:
    case 0x8052:
    case 0x8053:
    case 0x8054:
    case 0x8055:
    case 0x8056:
    case 0x8057:
    case 0x8058:
    case 0x8059:
    case 0x805A:
    case 0x805B:
    case 0x805C:
    case 0x805D:
    case 0x805E:
    case 0x805F:
    case 0x8060:
    case 0x8061:
    case 0x8062:
    case 0x8063:
    case 0x8064:
    case 0x8065:
    case 0x8066:
    case 0x8067:
    case 0x8068:
    case 0x8069:
    case 0x806A:
    case 0x806B:
    case 0x806C:
    case 0x806D:
    case 0x806F:
    case 0x8070:
    case 0x8071:
    case 0x8072:
    case 0x8073:
    case 0x8074:
    case 0x8075:
    case 0x8076:
    case 0x8077:
      return;
  }
}
// 10011F30: could not find valid save-restore pair for edi

//----- (10012020) --------------------------------------------------------
int __usercall sub_10012020@<eax>(int a1@<eax>, __int16 a2@<cx>)
{
  *(_WORD *)(a1 + 440) = a2;
  *(_WORD *)(a1 + 442) = a2;
  *(_WORD *)(a1 + 428) = a2;
  *(_WORD *)(a1 + 430) = a2;
  *(_WORD *)(a1 + 398) = 3;
  return sub_1001EC10(a1 + 392, 0, 0, 1024, 768, 1);
}

//----- (10012070) --------------------------------------------------------
char __usercall sub_10012070@<al>(int a1@<esi>)
{
  int v1; // edi@1
  char result; // al@1

  v1 = sub_10003D50(a1, *(char **)(a1 + 56), 40, 0);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  sub_10002870(a1, 0, 0, 1024, 768, 1);
  *(_BYTE *)(v1 + 36) = 0;
  sub_10003F00(a1, *(_DWORD *)(a1 + 56), 50);
  result = sub_10004590(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (100120D0) --------------------------------------------------------
unsigned __int8 __usercall sub_100120D0@<al>(char a1@<al>)
{
  unsigned __int8 result; // al@1

  result = a1 + 1;
  if ( result >= 0x13u )
    result = 0;
  return result;
}

//----- (100120E0) --------------------------------------------------------
int __usercall sub_100120E0@<eax>(int a1@<eax>)
{
  int result; // eax@1

  result = a1 + 1;
  if ( (unsigned __int16)result >= 0x45u )
    result = 0;
  return result;
}

//----- (100120F0) --------------------------------------------------------
char __usercall sub_100120F0@<al>(char a1@<al>)
{
  char result; // al@2

  if ( a1 )
    result = a1 - 1;
  else
    result = 18;
  return result;
}

//----- (10012100) --------------------------------------------------------
int __cdecl sub_10012100(int a1)
{
  __int16 v1; // bx@1
  int result; // eax@2
  __int16 i; // si@2

  sub_10012020(a1, 16);
  v1 = 0;
  *(_WORD *)(a1 + 440) = 0;
  *(_WORD *)(a1 + 442) = 0;
  *(_WORD *)(a1 + 428) = 0;
  *(_WORD *)(a1 + 430) = 0;
  do
  {
    result = v1 & 0x10;
    for ( i = v1 & 0x10; i < 1024; i += 32 )
      result = sub_1001EC10(a1 + 392, i, v1, 16, 16, 1);
    v1 += 16;
  }
  while ( v1 < 768 );
  return result;
}

//----- (10012180) --------------------------------------------------------
char __usercall sub_10012180@<al>(int a1@<edi>)
{
  int v1; // esi@1
  signed int v2; // ebp@1
  _WORD *v3; // ST04_4@1
  signed int v4; // ebx@3
  signed int v5; // ebx@8
  signed int v6; // ebx@11

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = 0;
  v3 = *(_WORD **)(a1 + 52);
  *(_WORD *)(a1 + 394) = 1;
  sub_10002D30(a1, v3, (char *)&unk_1008EB50, (int)&unk_1008EB60, 0, 255);
  switch ( *(_BYTE *)(v1 + 36) )
  {
    case 0:
      *(_BYTE *)(v1 + 37) = 0;
      *(_DWORD *)v1 = 96;
      *(_WORD *)(v1 + 12) = 0;
      *(_WORD *)(v1 + 14) = 0;
      *(_WORD *)(v1 + 4) = 1024;
      *(_WORD *)(v1 + 6) = 768;
      *(_WORD *)(v1 + 8) = 1;
      break;
    case 1:
      *(_DWORD *)v1 = 96;
      *(_WORD *)(v1 + 4) = 64;
      *(_WORD *)(v1 + 6) = 48;
      *(_WORD *)(v1 + 12) = 0;
      *(_WORD *)(v1 + 14) = 0;
      v4 = 0;
      while ( 1 )
      {
        do
        {
          *(_WORD *)(v1 + 8) = ((_BYTE)v4 + (_BYTE)v2) & 0xF | 32 * (v4 + v2) & 0x1E0 | 0x800;
          sub_10037530(a1, *(_DWORD *)(a1 + 52), (char *)v1, 0);
          *(_WORD *)(v1 + 12) += 64;
          ++v2;
        }
        while ( v2 < 16 );
        *(_WORD *)(v1 + 14) += 48;
        ++v4;
        *(_WORD *)(v1 + 12) = 0;
        if ( v4 >= 16 )
          break;
        v2 = 0;
      }
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 2:
      *(_DWORD *)v1 = 96;
      *(_WORD *)(v1 + 4) = 53;
      *(_WORD *)(v1 + 6) = 768;
      *(_WORD *)(v1 + 12) = 0;
      *(_WORD *)(v1 + 14) = 0;
      v5 = 0;
      do
      {
        *(_WORD *)(v1 + 8) = v5 & 0x1F | 32 * (v5 & 0x1F | 0x40);
        sub_10037530(a1, *(_DWORD *)(a1 + 52), (char *)v1, 0);
        *(_WORD *)(v1 + 12) += 53;
        ++v5;
      }
      while ( v5 < 19 );
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 3:
      *(_DWORD *)v1 = 96;
      *(_WORD *)(v1 + 6) = 40;
      *(_WORD *)(v1 + 4) = 1024;
      *(_WORD *)(v1 + 12) = 0;
      *(_WORD *)(v1 + 14) = 0;
      v6 = 0;
      do
      {
        *(_WORD *)(v1 + 8) = v6 & 0x1F | 32 * (v6 & 0x1F | 0x40);
        sub_10037530(a1, *(_DWORD *)(a1 + 52), (char *)v1, 0);
        *(_WORD *)(v1 + 14) += 40;
        ++v6;
      }
      while ( v6 < 19 );
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 4:
      sub_10012020(a1, 0);
      break;
    case 5:
      sub_10012020(a1, 16);
      break;
    case 6:
      sub_10012020(a1, 10);
      break;
    case 7:
      sub_10012020(a1, 11);
      break;
    case 8:
      sub_10012020(a1, 13);
      break;
    case 9:
      sub_10012100(a1);
      break;
    case 10:
      *(_BYTE *)(v1 + 32) = 0;
      *(_DWORD *)(v1 + 16) = 69;
      *(_WORD *)(v1 + 24) = 512;
      *(_WORD *)(v1 + 26) = 384;
      *(_WORD *)(v1 + 22) = 1056;
      *(_WORD *)(v1 + 20) = 1;
      break;
    case 11:
      *(_WORD *)(v1 + 30) = 384;
      *(_WORD *)(v1 + 28) = 512;
      *(_WORD *)(a1 + 438) = 512;
      *(_WORD *)(a1 + 436) = *(_WORD *)(v1 + 30);
      *(_WORD *)(v1 + 34) = 13;
      *(_WORD *)(a1 + 428) = 13;
      *(_WORD *)(a1 + 430) = *(_WORD *)(v1 + 34);
      *(_WORD *)(a1 + 440) = *(_WORD *)(v1 + 34);
      *(_WORD *)(a1 + 442) = *(_WORD *)(v1 + 34);
      sub_1001EC10(a1 + 392, 2, 2, 7, 7, 1);
      break;
    default:
      return sub_10004590(a1, *(_DWORD *)(a1 + 56), -32648);
  }
  return sub_10004590(a1, *(_DWORD *)(a1 + 56), -32648);
}

//----- (10012450) --------------------------------------------------------
char __usercall sub_10012450@<al>(int a1@<esi>)
{
  int v1; // ecx@1
  int v2; // edx@1
  int v3; // eax@1
  char v4; // dl@2
  bool v5; // sf@2
  __int16 v6; // ax@8
  int v7; // ecx@8
  __int16 v8; // di@10
  double v9; // st7@10
  char v10; // al@11
  char v11; // al@13
  double v12; // st7@17
  char v13; // al@18

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(_DWORD *)(a1 + 52);
  v3 = *(_WORD *)(v2 + 10);
  switch ( v3 )
  {
    case 60:
      v4 = *(_BYTE *)(v2 + 8);
      v5 = (char)(v4 + *(_BYTE *)(v1 + 36)) < 0;
      *(_BYTE *)(v1 + 36) += v4;
      if ( v5 )
      {
        *(_BYTE *)(v1 + 36) = 11;
      }
      else if ( *(_BYTE *)(v1 + 36) >= 12 )
      {
        *(_BYTE *)(v1 + 36) = 0;
      }
      LOBYTE(v3) = sub_10004590(a1, *(_DWORD *)(a1 + 56), -32734);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 32:
      if ( *(_BYTE *)(v1 + 36) != 11 )
        goto LABEL_23;
      LOWORD(v3) = *(_WORD *)(v1 + 34);
      v6 = sub_100120E0(v3);
      *(_WORD *)(v7 + 34) = v6;
      *(_WORD *)(a1 + 428) = v6;
      *(_WORD *)(a1 + 430) = *(_WORD *)(v7 + 34);
      *(_WORD *)(a1 + 440) = *(_WORD *)(v7 + 34);
      *(_WORD *)(a1 + 442) = *(_WORD *)(v7 + 34);
      *(_WORD *)(a1 + 394) = 1;
      LOBYTE(v3) = sub_1001EC10(a1 + 392, 2, 2, 7, 7, 1);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 56:
      if ( *(_BYTE *)(v1 + 36) == 11 )
      {
        v8 = *(_WORD *)(v1 + 30);
        v9 = (double)*(_WORD *)(v1 + 30);
        if ( v9 > 10.5 && (v10 = *(_BYTE *)(v2 + 8), v10 > 0) )
        {
          *(_WORD *)(v1 + 30) = v8 - 7 * v10;
        }
        else if ( v9 < 756.5 )
        {
          v11 = *(_BYTE *)(v2 + 8);
          if ( v11 < 0 )
            *(_WORD *)(v1 + 30) = v8 - 7 * v11;
        }
        goto LABEL_22;
      }
      break;
    case 57:
      if ( *(_BYTE *)(v1 + 36) == 11 )
      {
        v12 = (double)*(_WORD *)(v1 + 28);
        if ( v12 > 10.5 && (v13 = *(_BYTE *)(v2 + 8), v13 < 0) || v12 < 1012.5 && (v13 = *(_BYTE *)(v2 + 8), v13 > 0) )
          *(_WORD *)(v1 + 28) += 7 * v13;
LABEL_22:
        *(_WORD *)(a1 + 428) = *(_WORD *)(v1 + 34);
        *(_WORD *)(a1 + 430) = *(_WORD *)(v1 + 34);
        *(_WORD *)(a1 + 440) = *(_WORD *)(v1 + 34);
        *(_WORD *)(a1 + 442) = *(_WORD *)(v1 + 34);
        *(_WORD *)(a1 + 394) = 7;
        LOBYTE(v3) = sub_1001CF50(a1 + 392, *(_WORD *)(v1 + 28), *(_WORD *)(v1 + 30), 0);
LABEL_23:
        *(_BYTE *)(a1 + 6) = 2;
      }
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (10012660) --------------------------------------------------------
char __usercall sub_10012660@<al>(int a1@<edi>)
{
  int v1; // esi@1
  __int16 v2; // ax@1
  char v3; // bl@2
  int v4; // ST2C_4@2
  signed int v5; // ebp@2
  char v6; // al@6
  char v7; // al@6
  char v8; // bl@8
  signed int v9; // ebp@8
  char v10; // al@12
  unsigned __int8 v11; // al@12
  int v13; // [sp+Ch] [bp-18h]@2
  __int16 v14; // [sp+Ch] [bp-18h]@8
  int v15; // [sp+18h] [bp-Ch]@2
  int v16; // [sp+1Ch] [bp-8h]@2

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  LOBYTE(v2) = *(_BYTE *)(v1 + 36);
  if ( (_BYTE)v2 )
  {
    if ( (_BYTE)v2 == 10 )
    {
      sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008EB50, (int)&unk_1008EB60, 0, 255);
      v8 = *(_BYTE *)(v1 + 32);
      v14 = *(_WORD *)(v1 + 20);
      v9 = 72;
      do
      {
        *(_WORD *)(v1 + 22) = v8 & 0x1F | 0x420;
        sub_10037530(a1, *(_DWORD *)(a1 + 52), (char *)(v1 + 16), 0);
        *(_WORD *)(v1 + 20) += 10;
        --v9;
        v8 = sub_100120F0(v8);
      }
      while ( v9 );
      if ( v14 >= 10 )
      {
        v10 = *(_BYTE *)(v1 + 32);
        *(_WORD *)(v1 + 20) = 1;
        v11 = sub_100120D0(v10);
        *(_BYTE *)(v1 + 32) = v11;
        v2 = v11 & 0x1F | 0x420;
        *(_WORD *)(v1 + 22) = v2;
      }
      else
      {
        LOBYTE(v2) = v14 + 1;
        *(_WORD *)(v1 + 20) = v14 + 1;
      }
    }
  }
  else
  {
    v3 = *(_BYTE *)(v1 + 37);
    v13 = *(_DWORD *)(v1 + 12);
    v4 = *(_DWORD *)v1;
    v15 = *(_DWORD *)(v1 + 4);
    v16 = *(_DWORD *)(v1 + 8);
    v5 = 38;
    do
    {
      sub_10037530(a1, *(_DWORD *)(a1 + 52), (char *)v1, 0);
      *(_WORD *)(v1 + 12) += 10;
      *(_WORD *)(v1 + 14) += 10;
      *(_WORD *)(v1 + 4) -= 20;
      *(_WORD *)(v1 + 6) -= 20;
      v3 = sub_100120F0(v3);
      --v5;
      *(_WORD *)(v1 + 8) = 32 * (v3 & 0x1F) | 0x801;
    }
    while ( v5 );
    if ( (signed __int16)v13 <= 0 )
    {
      *(_WORD *)(v1 + 12) = v13 + 9;
      *(_WORD *)(v1 + 14) = HIWORD(v13) + 9;
      v6 = *(_BYTE *)(v1 + 37);
      *(_WORD *)(v1 + 4) = v15 - 18;
      *(_WORD *)(v1 + 6) = HIWORD(v15) - 18;
      v7 = sub_100120F0(v6);
      *(_BYTE *)(v1 + 37) = v7;
      v2 = 32 * (v7 & 0x1F) | 0x801;
      *(_WORD *)(v1 + 8) = v2;
    }
    else
    {
      *(_WORD *)(v1 + 12) = v13 - 1;
      *(_WORD *)(v1 + 14) = HIWORD(v13) - 1;
      LOBYTE(v2) = v15 + 2;
      *(_WORD *)(v1 + 4) = v15 + 2;
      *(_WORD *)(v1 + 6) = HIWORD(v15) + 2;
      *(_WORD *)(v1 + 8) = v16;
    }
  }
  return v2;
}

//----- (10012860) --------------------------------------------------------
char __cdecl sub_10012860(int a1)
{
  int v1; // eax@1

  v1 = **(_WORD **)(a1 + 52);
  switch ( v1 )
  {
    case 32833:
      LOBYTE(v1) = sub_10012070(a1);
      break;
    case 32802:
      LOBYTE(v1) = sub_10012180(a1);
      break;
    case 32888:
      LOBYTE(v1) = sub_10012660(a1);
      break;
    case 32840:
      LOBYTE(v1) = sub_10012450(a1);
      break;
    default:
      return v1;
  }
  return v1;
}

//----- (10012920) --------------------------------------------------------
int __cdecl sub_10012920(int a1)
{
  int result; // eax@1

  sub_100370D0(0);
  result = a1;
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10012940) --------------------------------------------------------
char __usercall sub_10012940@<al>(int a1@<esi>)
{
  char result; // al@1

  sub_10002D30(a1, *(_WORD **)(a1 + 52), "B", (int)&unk_1008F718, 0, 255);
  result = sub_10004590(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10012980) --------------------------------------------------------
char __cdecl sub_10012980(int a1)
{
  int v1; // ebp@1
  int v2; // eax@1
  int v3; // ebx@1
  int v4; // eax@1
  _DWORD *v5; // ecx@1
  char result; // al@1

  v1 = a1;
  v2 = sub_10003D50(a1, *(char **)(a1 + 56), 1240, 1);
  v3 = v2;
  *(_BYTE *)(v2 + 1232) = 0;
  qmemcpy((void *)v2, &unk_1008F3B0, 0x24u);
  *(_WORD *)(v2 + 12) = _RTC_NumErrors();
  sub_10002870(a1, 0, 0, 1024, 768, 1);
  sub_100374D0(*(_DWORD *)(a1 + 56), (char *)v3);
  v4 = *(_DWORD *)(a1 + 56);
  v5 = *(_DWORD **)(v4 + 60);
  *(_BYTE *)(v4 + 230) = -1;
  *v5 = v3 + 172;
  *(_DWORD *)(v3 + 52) = v3 + 192;
  *(_DWORD *)(v3 + 56) = v3 + 196;
  *(_DWORD *)(v3 + 60) = v3 + 200;
  *(_DWORD *)(v3 + 64) = v3 + 204;
  *(_DWORD *)(v3 + 68) = v3 + 208;
  *(_DWORD *)(v3 + 72) = v3 + 212;
  *(_DWORD *)(v3 + 76) = v3 + 216;
  *(_DWORD *)(v3 + 80) = v3 + 220;
  *(_DWORD *)(v3 + 84) = v3 + 224;
  *(_DWORD *)(v3 + 88) = v3 + 228;
  *(_DWORD *)(v3 + 92) = v3 + 232;
  *(_DWORD *)(v3 + 96) = v3 + 236;
  *(_DWORD *)(v3 + 100) = v3 + 240;
  *(_WORD *)(v3 + 172) = 0;
  *(_DWORD *)(v3 + 104) = v3 + 244;
  *(_DWORD *)(v3 + 36) = v3 + 176;
  *(_DWORD *)(v3 + 40) = v3 + 180;
  *(_DWORD *)(v3 + 44) = v3 + 184;
  *(_DWORD *)(v3 + 48) = v3 + 188;
  *(_DWORD *)(v3 + 108) = v3 + 248;
  *(_DWORD *)(v3 + 176) = 0;
  *(_DWORD *)(v3 + 180) = 0;
  *(_DWORD *)(v3 + 184) = 0;
  *(_DWORD *)(v3 + 188) = 0;
  *(_DWORD *)(v3 + 192) = 0;
  *(_DWORD *)(v3 + 196) = 0;
  *(_DWORD *)(v3 + 200) = 0;
  *(_DWORD *)(v3 + 248) = 0;
  *(_DWORD *)(v3 + 128) = v3 + 1196;
  *(_DWORD *)(v3 + 132) = v3 + 1200;
  *(_DWORD *)(v3 + 136) = v3 + 1204;
  *(_DWORD *)(v3 + 140) = v3 + 1208;
  *(_DWORD *)(v3 + 144) = v3 + 1212;
  *(_DWORD *)(v3 + 148) = v3 + 1216;
  *(_DWORD *)(v3 + 152) = v3 + 1220;
  *(_DWORD *)(v3 + 156) = v3 + 1224;
  *(_DWORD *)(v3 + 160) = v3 + 1192;
  *(_DWORD *)(v3 + 1176) = 0;
  *(_DWORD *)(v3 + 112) = v3 + 1176;
  *(_DWORD *)(v3 + 164) = v3 + 1228;
  *(_DWORD *)(v3 + 204) = 0;
  *(_DWORD *)(v3 + 208) = 0;
  *(_DWORD *)(v3 + 212) = 0;
  *(_DWORD *)(v3 + 216) = 0;
  *(_DWORD *)(v3 + 220) = 0;
  *(_DWORD *)(v3 + 224) = 0;
  *(_DWORD *)(v3 + 228) = 0;
  *(_DWORD *)(v3 + 232) = 0;
  *(_DWORD *)(v3 + 236) = 0;
  *(_DWORD *)(v3 + 240) = 0;
  *(_DWORD *)(v3 + 244) = 0;
  *(_DWORD *)(v3 + 116) = v3 + 1180;
  *(_DWORD *)(v3 + 120) = v3 + 1184;
  *(_DWORD *)(v3 + 1180) = 0;
  *(_DWORD *)(v3 + 1184) = 0;
  *(_DWORD *)(v3 + 1188) = 0;
  *(_DWORD *)(v3 + 1196) = 0;
  *(_DWORD *)(v3 + 1200) = 0;
  *(_DWORD *)(v3 + 1204) = 0;
  *(_DWORD *)(v3 + 1208) = 0;
  *(_DWORD *)(v3 + 1212) = 0;
  *(_DWORD *)(v3 + 1216) = 0;
  *(_DWORD *)(v3 + 1220) = 0;
  *(_DWORD *)(v3 + 1224) = 0;
  *(_DWORD *)(v3 + 1192) = 0;
  *(_DWORD *)(v3 + 1228) = 0;
  *(_DWORD *)(v3 + 1236) = 0;
  *(_DWORD *)(v3 + 124) = v3 + 1188;
  *(_DWORD *)(v3 + 168) = v3 + 1236;
  sub_10002D30(
    v1,
    *(_WORD **)(v1 + 52),
    (char *)v3,
    *(_DWORD *)(*(_DWORD *)(v1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230));
  result = sub_10004590(v1, *(_DWORD *)(v1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 1006C1D0: using guessed type int _RTC_NumErrors(void);

//----- (10012C90) --------------------------------------------------------
bool __usercall sub_10012C90@<al>(int a1@<edi>)
{
  int v1; // esi@1
  int v2; // ecx@4
  int v3; // eax@4
  int v4; // edx@4
  int v5; // ecx@4
  int v6; // eax@4
  int v7; // edx@4
  int v8; // ecx@4
  int v9; // eax@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // eax@4
  int v13; // edx@4
  int v14; // ecx@4
  int v15; // eax@6
  int v16; // eax@6
  int v17; // eax@6
  int v18; // eax@6
  int v19; // eax@6
  int v20; // eax@6
  bool result; // al@6
  int v22; // [sp+4h] [bp-60h]@2
  int v23; // [sp+8h] [bp-5Ch]@4
  int v24; // [sp+Ch] [bp-58h]@4
  int v25; // [sp+10h] [bp-54h]@4
  int v26; // [sp+14h] [bp-50h]@4
  int v27; // [sp+18h] [bp-4Ch]@4
  int v28; // [sp+1Ch] [bp-48h]@4
  int v29; // [sp+20h] [bp-44h]@4
  int v30; // [sp+24h] [bp-40h]@4
  int v31; // [sp+28h] [bp-3Ch]@4
  int v32; // [sp+2Ch] [bp-38h]@4
  int v33; // [sp+30h] [bp-34h]@4
  int v34; // [sp+34h] [bp-30h]@4
  int v35; // [sp+38h] [bp-2Ch]@4
  int v36; // [sp+3Ch] [bp-28h]@4
  int v37; // [sp+40h] [bp-24h]@4
  int v38; // [sp+44h] [bp-20h]@4
  int v39; // [sp+48h] [bp-1Ch]@4
  int v40; // [sp+4Ch] [bp-18h]@4

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(_WORD *)(v1 + 172) >= 4 )
    j_HWM_pvg_ethr_get_stats(0, &v22);
  else
    j_HWM_pvg_ethr_get_stats(*(_BYTE *)(v1 + 172), &v22);
  *(_DWORD *)(v1 + 176) = v22;
  *(_DWORD *)(v1 + 180) = v23;
  *(_DWORD *)(v1 + 184) = v24;
  *(_DWORD *)(v1 + 188) = v25;
  *(_DWORD *)(v1 + 192) = v26;
  *(_DWORD *)(v1 + 196) = v27;
  *(_DWORD *)(v1 + 200) = v28;
  *(_DWORD *)(v1 + 204) = v29;
  *(_DWORD *)(v1 + 208) = v38;
  *(_DWORD *)(v1 + 212) = v30;
  *(_DWORD *)(v1 + 216) = v31;
  *(_DWORD *)(v1 + 220) = v36;
  *(_DWORD *)(v1 + 224) = v33;
  *(_DWORD *)(v1 + 228) = v35;
  *(_DWORD *)(v1 + 232) = v34;
  *(_DWORD *)(v1 + 236) = v32;
  *(_DWORD *)(v1 + 240) = v37;
  *(_DWORD *)(v1 + 244) = v40;
  *(_DWORD *)(v1 + 248) = v39;
  j_HWM_pvg_hsdb_get_stats(v1 + 252);
  v2 = *(_DWORD *)(v1 + 260);
  v3 = *(_DWORD *)(v1 + 256);
  *(_DWORD *)(v1 + 1176) = *(_DWORD *)(v1 + 252);
  v4 = *(_DWORD *)(v1 + 264);
  *(_DWORD *)(v1 + 1184) = v2;
  v5 = *(_DWORD *)(v1 + 272);
  *(_DWORD *)(v1 + 1180) = v3;
  v6 = *(_DWORD *)(v1 + 268);
  *(_DWORD *)(v1 + 1188) = v4;
  v7 = *(_DWORD *)(v1 + 276);
  *(_DWORD *)(v1 + 1200) = v5;
  v8 = *(_DWORD *)(v1 + 284);
  *(_DWORD *)(v1 + 1196) = v6;
  v9 = *(_DWORD *)(v1 + 280);
  *(_DWORD *)(v1 + 1204) = v7;
  v10 = *(_DWORD *)(v1 + 288);
  *(_DWORD *)(v1 + 1212) = v8;
  v11 = *(_DWORD *)(v1 + 324);
  *(_DWORD *)(v1 + 1208) = v9;
  v12 = *(_DWORD *)(v1 + 292);
  *(_DWORD *)(v1 + 1216) = v10;
  v13 = *(_DWORD *)(v1 + 328);
  *(_DWORD *)(v1 + 1224) = v11;
  v14 = *(_DWORD *)(v1 + 336);
  *(_DWORD *)(v1 + 1220) = v12;
  *(_DWORD *)(v1 + 1228) = v13;
  *(_DWORD *)(v1 + 1236) = v14;
  if ( v12 < 0 )
    *(_DWORD *)(v1 + 1220) = -1;
  *(_DWORD *)(v1 + 1192) = 0;
  v15 = *(_DWORD *)(v1 + 600);
  *(_DWORD *)(v1 + 1192) = v15;
  v16 = *(_DWORD *)(v1 + 640) + v15;
  *(_DWORD *)(v1 + 1192) = v16;
  v17 = *(_DWORD *)(v1 + 680) + v16;
  *(_DWORD *)(v1 + 1192) = v17;
  v18 = *(_DWORD *)(v1 + 720) + v17;
  *(_DWORD *)(v1 + 1192) = v18;
  v19 = *(_DWORD *)(v1 + 760) + v18;
  *(_DWORD *)(v1 + 1192) = v19;
  v20 = *(_DWORD *)(v1 + 800) + v19;
  *(_DWORD *)(v1 + 1192) = v20;
  *(_DWORD *)(v1 + 1192) = v20 + *(_DWORD *)(v1 + 840);
  sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008F3D8, v1 + 36, 0, 255);
  result = sub_10002D30(
             a1,
             *(_WORD **)(a1 + 52),
             (char *)v1,
             *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
             0,
             *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 1006BAE0: using guessed type int __cdecl j_HWM_pvg_ethr_get_stats(_DWORD, _DWORD);
// 1006BB60: using guessed type int __cdecl j_HWM_pvg_hsdb_get_stats(_DWORD);

//----- (10012EF0) --------------------------------------------------------
char __cdecl sub_10012EF0(int a1)
{
  int v1; // eax@1

  v1 = **(_WORD **)(a1 + 52);
  switch ( v1 )
  {
    case 32792:
      LOBYTE(v1) = sub_10012920(a1);
      break;
    case 32802:
      LOBYTE(v1) = sub_10012940(a1);
      break;
    case 32833:
      LOBYTE(v1) = sub_10012980(a1);
      break;
    case 32840:
      LOBYTE(v1) = sub_10008B00(a1);
      break;
    case 32849:
      LOBYTE(v1) = sub_10008B00(a1);
      break;
    case 32888:
      LOBYTE(v1) = sub_10012C90(a1);
      break;
    default:
      return v1;
  }
  return v1;
}

//----- (10012FD0) --------------------------------------------------------
int __usercall sub_10012FD0@<eax>(int a1@<eax>)
{
  int result; // eax@1

  result = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_WORD *)(result + 4) = 34;
  *(_WORD *)(result + 6) = 22;
  *(_WORD *)(result + 8) = -1;
  *(_DWORD *)result = 96;
  *(_DWORD *)(result + 1392) = 16843009;
  *(_DWORD *)(result + 1396) = 16843009;
  *(_DWORD *)(result + 1400) = 16843009;
  *(_DWORD *)(result + 1404) = 16843009;
  *(_WORD *)(result + 1408) = 257;
  *(_DWORD *)(result + 16) = 96;
  *(_WORD *)(result + 24) = -1;
  *(_WORD *)(result + 20) = 50;
  *(_WORD *)(result + 22) = 22;
  *(_DWORD *)(result + 1410) = 16843009;
  *(_DWORD *)(result + 1414) = 16843009;
  *(_DWORD *)(result + 1418) = 16843009;
  *(_DWORD *)(result + 32) = 96;
  *(_WORD *)(result + 40) = -1;
  *(_WORD *)(result + 36) = 42;
  *(_WORD *)(result + 38) = 30;
  *(_WORD *)(result + 1422) = 257;
  *(_DWORD *)(result + 48) = 96;
  *(_WORD *)(result + 56) = -1;
  *(_WORD *)(result + 52) = 10;
  *(_WORD *)(result + 54) = 10;
  *(_DWORD *)(result + 1424) = 16843009;
  *(_DWORD *)(result + 1428) = 16843009;
  *(_DWORD *)(result + 1432) = 16843009;
  *(_DWORD *)(result + 1436) = 16843009;
  *(_DWORD *)(result + 1440) = 16843009;
  *(_DWORD *)(result + 1444) = 16843009;
  *(_DWORD *)(result + 1448) = 16843009;
  *(_DWORD *)(result + 1452) = 16843009;
  *(_DWORD *)(result + 1456) = 16843009;
  *(_WORD *)(result + 70) = -1;
  *(_DWORD *)(result + 64) = 69;
  *(_WORD *)(result + 68) = 14;
  *(_WORD *)(result + 1460) = 257;
  *(_BYTE *)(result + 1462) = 1;
  *(_WORD *)(result + 82) = -1;
  *(_DWORD *)(result + 76) = 69;
  *(_WORD *)(result + 80) = 16;
  *(_DWORD *)(result + 1463) = 16843009;
  *(_WORD *)(result + 94) = -1;
  *(_DWORD *)(result + 88) = 69;
  *(_WORD *)(result + 92) = 22;
  *(_DWORD *)(result + 1467) = 16843009;
  *(_WORD *)(result + 1471) = 257;
  *(_BYTE *)(result + 1468) = 0;
  *(_BYTE *)(result + 1470) = 0;
  *(_BYTE *)(result + 1471) = 0;
  *(_BYTE *)(result + 1472) = 0;
  *(_BYTE *)(result + 488) = 1;
  *(_BYTE *)(result + 489) = 1;
  *(_BYTE *)(result + 491) = 0;
  *(_BYTE *)(result + 490) = 2;
  *(_BYTE *)(result + 524) = 1;
  *(_BYTE *)(result + 525) = 1;
  *(_BYTE *)(result + 527) = 0;
  *(_BYTE *)(result + 526) = 2;
  *(_BYTE *)(result + 560) = 1;
  *(_BYTE *)(result + 561) = 1;
  *(_BYTE *)(result + 563) = 0;
  *(_BYTE *)(result + 562) = 2;
  *(_BYTE *)(result + 596) = 1;
  *(_BYTE *)(result + 597) = 1;
  *(_BYTE *)(result + 599) = 0;
  *(_BYTE *)(result + 598) = 2;
  *(_BYTE *)(result + 632) = 1;
  *(_BYTE *)(result + 633) = 1;
  *(_BYTE *)(result + 635) = 0;
  *(_BYTE *)(result + 634) = 2;
  *(_BYTE *)(result + 668) = 1;
  *(_BYTE *)(result + 669) = 1;
  *(_BYTE *)(result + 671) = 0;
  *(_BYTE *)(result + 670) = 2;
  *(_BYTE *)(result + 704) = 1;
  *(_BYTE *)(result + 705) = 1;
  *(_BYTE *)(result + 707) = 0;
  *(_BYTE *)(result + 706) = 2;
  *(_BYTE *)(result + 740) = 1;
  *(_BYTE *)(result + 741) = 1;
  *(_BYTE *)(result + 743) = 0;
  *(_BYTE *)(result + 742) = 2;
  *(_BYTE *)(result + 776) = 1;
  *(_BYTE *)(result + 777) = 1;
  *(_BYTE *)(result + 779) = 0;
  *(_BYTE *)(result + 778) = 2;
  *(_BYTE *)(result + 812) = 1;
  *(_BYTE *)(result + 813) = 1;
  *(_BYTE *)(result + 815) = 0;
  *(_BYTE *)(result + 814) = 2;
  *(_BYTE *)(result + 848) = 1;
  *(_BYTE *)(result + 849) = 1;
  *(_BYTE *)(result + 851) = 0;
  *(_BYTE *)(result + 850) = 2;
  *(_BYTE *)(result + 884) = 1;
  *(_BYTE *)(result + 885) = 1;
  *(_BYTE *)(result + 887) = 0;
  *(_BYTE *)(result + 886) = 2;
  *(_BYTE *)(result + 920) = 1;
  *(_BYTE *)(result + 921) = 1;
  *(_BYTE *)(result + 923) = 0;
  *(_BYTE *)(result + 922) = 2;
  *(_BYTE *)(result + 956) = 1;
  *(_BYTE *)(result + 957) = 1;
  *(_BYTE *)(result + 959) = 0;
  *(_BYTE *)(result + 958) = 2;
  *(_BYTE *)(result + 992) = 1;
  *(_BYTE *)(result + 993) = 3;
  *(_BYTE *)(result + 995) = 0;
  *(_BYTE *)(result + 994) = 2;
  *(_BYTE *)(result + 1028) = 1;
  *(_BYTE *)(result + 1029) = 3;
  *(_BYTE *)(result + 1031) = 0;
  *(_BYTE *)(result + 1030) = 2;
  *(_BYTE *)(result + 1172) = 1;
  *(_BYTE *)(result + 1173) = 3;
  *(_BYTE *)(result + 1175) = 0;
  *(_BYTE *)(result + 1174) = 2;
  *(_BYTE *)(result + 1208) = 1;
  *(_BYTE *)(result + 1209) = 3;
  *(_BYTE *)(result + 1211) = 0;
  *(_BYTE *)(result + 1210) = 2;
  *(_BYTE *)(result + 1244) = 1;
  *(_BYTE *)(result + 1245) = 3;
  *(_BYTE *)(result + 1247) = 0;
  *(_BYTE *)(result + 1246) = 2;
  *(_BYTE *)(result + 1280) = 1;
  *(_BYTE *)(result + 1281) = 3;
  *(_BYTE *)(result + 1283) = 0;
  *(_BYTE *)(result + 1282) = 2;
  *(_BYTE *)(result + 1316) = 1;
  *(_BYTE *)(result + 1317) = 3;
  *(_BYTE *)(result + 1319) = 0;
  *(_BYTE *)(result + 1318) = 2;
  *(_BYTE *)(result + 1352) = 1;
  *(_BYTE *)(result + 1353) = 3;
  *(_BYTE *)(result + 1355) = 0;
  *(_BYTE *)(result + 1354) = 2;
  *(_BYTE *)(result + 1064) = 1;
  *(_BYTE *)(result + 1065) = 3;
  *(_BYTE *)(result + 1067) = 0;
  *(_BYTE *)(result + 1066) = 2;
  *(_BYTE *)(result + 1100) = 1;
  *(_BYTE *)(result + 1101) = 3;
  *(_BYTE *)(result + 1103) = 0;
  *(_BYTE *)(result + 1102) = 2;
  *(_BYTE *)(result + 1136) = 1;
  *(_BYTE *)(result + 1137) = 3;
  *(_BYTE *)(result + 1139) = 0;
  *(_BYTE *)(result + 1138) = 2;
  *(_BYTE *)(result + 1388) = 1;
  *(_BYTE *)(result + 1389) = 3;
  *(_BYTE *)(result + 1391) = 0;
  *(_BYTE *)(result + 1390) = 2;
  return result;
}

//----- (100133A0) --------------------------------------------------------
int __usercall sub_100133A0@<eax>(int a1@<edi>)
{
  int v1; // esi@1
  void *v2; // ecx@1
  bool v3; // zf@1
  int v4; // eax@40
  int v5; // eax@41
  unsigned __int8 v6; // al@53
  void *v7; // ecx@53
  int v8; // eax@62
  _WORD *v9; // ebx@64
  unsigned int v10; // ebp@64
  _BYTE *v11; // eax@65
  int v12; // eax@65
  int v13; // eax@66
  _WORD *v14; // ebx@72
  unsigned int v15; // ebp@72
  _BYTE *v16; // ecx@73
  _WORD *v17; // ebx@80
  unsigned int v18; // ebp@80
  _BYTE *v19; // edx@81
  _WORD *v20; // ebx@88
  unsigned int v21; // ebp@88
  _BYTE *v22; // eax@89
  int v23; // eax@89
  int v24; // eax@90
  _WORD *v25; // ebx@96
  unsigned int v26; // ebp@96
  _BYTE *v27; // ecx@97
  _WORD *v28; // ebx@104
  unsigned int v29; // ebp@104
  _BYTE *v30; // edx@105
  _WORD *v31; // ebx@112
  unsigned int v32; // ebp@112
  _BYTE *v33; // eax@113
  int v34; // eax@113
  int v35; // eax@114
  int result; // eax@119
  char v37; // [sp+Ch] [bp-20h]@27
  char v38; // [sp+Dh] [bp-1Fh]@27
  _BYTE *v39; // [sp+10h] [bp-1Ch]@64
  int v40; // [sp+14h] [bp-18h]@48
  int v41; // [sp+18h] [bp-14h]@44
  int v42; // [sp+1Ch] [bp-10h]@45
  int v43; // [sp+20h] [bp-Ch]@45
  int v44; // [sp+24h] [bp-8h]@45
  int v45; // [sp+28h] [bp-4h]@45

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_DWORD *)(v1 + 380) = (unsigned __int16)j_HWM_pvg_get_anlg_outp(0);
  *(_DWORD *)(v1 + 384) = (unsigned __int16)j_HWM_pvg_get_anlg_outp(2);
  *(_DWORD *)(v1 + 388) = (unsigned __int16)j_HWM_pvg_get_anlg_outp(3);
  *(_DWORD *)(v1 + 392) = (signed __int16)j_HWM_pvg_get_frmt_adc(0);
  *(_DWORD *)(v1 + 396) = (signed __int16)j_HWM_pvg_get_frmt_adc(1);
  *(_DWORD *)(v1 + 400) = (signed __int16)j_HWM_pvg_get_frmt_adc(2);
  *(_DWORD *)(v1 + 404) = (signed __int16)j_HWM_pvg_get_frmt_adc(3);
  *(_DWORD *)(v1 + 408) = (signed __int16)j_HWM_pvg_get_frmt_adc(14);
  *(_DWORD *)(v1 + 412) = (signed __int16)j_HWM_pvg_get_frmt_adc(4);
  *(_DWORD *)(v1 + 416) = (signed __int16)j_HWM_pvg_get_frmt_adc(5);
  *(_DWORD *)(v1 + 420) = (signed __int16)j_HWM_pvg_get_frmt_adc(7);
  *(_DWORD *)(v1 + 424) = (signed __int16)j_HWM_pvg_get_frmt_adc(6);
  *(_DWORD *)(v1 + 428) = (signed __int16)j_HWM_pvg_get_frmt_adc(8);
  *(_DWORD *)(v1 + 432) = (signed __int16)j_HWM_pvg_get_frmt_adc(9);
  *(_DWORD *)(v1 + 436) = (signed __int16)j_HWM_pvg_get_frmt_adc(17);
  *(_DWORD *)(v1 + 440) = (signed __int16)j_HWM_pvg_get_frmt_adc(10);
  *(_DWORD *)(v1 + 444) = (signed __int16)j_HWM_pvg_get_frmt_adc(18);
  *(_DWORD *)(v1 + 448) = (signed __int16)j_HWM_pvg_get_frmt_adc(15);
  v2 = (void *)(signed __int16)j_HWM_pvg_get_frmt_adc(16);
  v3 = *(_BYTE *)(v1 + 634) == 0;
  *(_DWORD *)(v1 + 452) = v2;
  if ( !v3 && *(_DWORD *)(v1 + 368) )
    *(_BYTE *)(v1 + 634) = (unsigned __int8)j_HWM_pvg_lpbk_uart(0) != 0;
  if ( *(_BYTE *)(v1 + 670) && *(_DWORD *)(v1 + 368) )
    *(_BYTE *)(v1 + 670) = (unsigned __int8)j_HWM_pvg_lpbk_uart(1) != 0;
  if ( *(_BYTE *)(v1 + 706) && *(_DWORD *)(v1 + 368) )
  {
    *(_BYTE *)(v1 + 706) = (unsigned __int8)j_HWM_pvg_lpbk_uart(3) != 0;
    if ( (unsigned __int8)j_HWM_pvg_lpbk_uart(2) )
    {
      if ( *(_BYTE *)(v1 + 706) != 1 )
        *(_BYTE *)(v1 + 706) = 2;
    }
    else
    {
      *(_BYTE *)(v1 + 706) = *(_BYTE *)(v1 + 706) != 1 ? 0 : 2;
    }
  }
  if ( *(_BYTE *)(v1 + 490) && *(_DWORD *)(v1 + 368) )
    *(_BYTE *)(v1 + 490) = (unsigned __int8)j_HWM_pvg_lpbk_ethr(0) != 0;
  if ( *(_BYTE *)(v1 + 526) && *(_DWORD *)(v1 + 368) )
  {
    LOBYTE(v2) = (unsigned __int8)j_HWM_pvg_lpbk_ethr(1) != 0;
    *(_BYTE *)(v1 + 526) = (_BYTE)v2;
  }
  if ( *(_BYTE *)(v1 + 562) && *(_DWORD *)(v1 + 368) )
    *(_BYTE *)(v1 + 562) = (unsigned __int8)j_HWM_pvg_lpbk_ethr(2) != 0;
  if ( *(_BYTE *)(v1 + 598) && *(_DWORD *)(v1 + 368) )
    *(_BYTE *)(v1 + 598) = (unsigned __int8)j_HWM_pvg_lpbk_ethr(3) != 0;
  if ( *(_BYTE *)(v1 + 814) && *(_DWORD *)(v1 + 368) == 2 )
  {
    v37 = 1;
    v38 = 0;
    *(_BYTE *)(v1 + 814) = sub_1006C0E0((__int16 *)&v37, 0) == 0;
  }
  if ( *(_BYTE *)(v1 + 850) && *(_DWORD *)(v1 + 368) == 3 )
  {
    v37 = 1;
    v38 = 1;
    LOBYTE(v2) = sub_1006C0E0((__int16 *)&v37, 0) == 0;
    *(_BYTE *)(v1 + 850) = (_BYTE)v2;
  }
  if ( *(_BYTE *)(v1 + 742) && (unsigned int)(sub_10069700() - *(_DWORD *)(v1 + 372)) >= 0x1388 )
  {
    *(_DWORD *)(v1 + 372) = sub_10069700();
    v37 = 6;
    v38 = 0;
    *(_BYTE *)(v1 + 742) = sub_1006C0E0((__int16 *)&v37, 0) == 0;
  }
  else if ( *(_BYTE *)(v1 + 778) && (unsigned int)(sub_10069700() - *(_DWORD *)(v1 + 376)) >= 0x1388 )
  {
    *(_DWORD *)(v1 + 376) = sub_10069700();
    v37 = 6;
    v38 = 1;
    *(_BYTE *)(v1 + 778) = sub_1006C0E0((__int16 *)&v37, 0) == 0;
  }
  if ( *(_BYTE *)(v1 + 886) )
  {
    v37 = 3;
    v38 = 0;
    LOBYTE(v2) = sub_1006C0E0((__int16 *)&v37, 0) == 0;
    *(_BYTE *)(v1 + 886) = (_BYTE)v2;
  }
  if ( sub_10036FE0(v2) != 2 )
  {
    v4 = *(_DWORD *)(v1 + 368);
    if ( v4 > 0 )
    {
      v5 = v4 + 1;
      *(_DWORD *)(v1 + 368) = v5;
      if ( v5 >= 4 )
        *(_DWORD *)(v1 + 368) = 2;
    }
  }
  if ( *(_BYTE *)(v1 + 922) )
  {
    if ( sub_1006A0A0(3, (int)&v41, 20) )
    {
      v41 = 0;
      v42 = 0;
      v43 = 0;
      v44 = 0;
      v45 = 0;
      sub_1006A190(3, (int)&v41, 20);
    }
    *(_BYTE *)(v1 + 922) = v41 == 0;
  }
  if ( *(_BYTE *)(v1 + 958) )
  {
    if ( sub_1006A0A0(14, (int)&v40, 4) )
    {
      v40 = 0;
      *(_BYTE *)(v1 + 958) = 1;
    }
    else if ( v40 )
    {
      *(_BYTE *)(v1 + 958) = 0;
    }
    else
    {
      *(_BYTE *)(v1 + 958) = 1;
    }
  }
  *(_BYTE *)(v1 + 994) = j_HWM_pvg_read_reg(12) != 0;
  *(_BYTE *)(v1 + 1030) = j_HWM_pvg_read_reg(13) != 0;
  v6 = j_HWM_pvg_read_reg(16);
  *(_BYTE *)(v1 + 1066) = v6 & 1;
  *(_BYTE *)(v1 + 1102) = (v6 >> 1) & 1;
  *(_BYTE *)(v1 + 1138) = (v6 >> 2) & 1;
  *(_BYTE *)(v1 + 1174) = j_HWM_pvg_read_reg(3) != 0;
  *(_BYTE *)(v1 + 1210) = j_HWM_pvg_read_reg(4) != 0;
  *(_BYTE *)(v1 + 1246) = j_HWM_pvg_read_reg(17) != 0;
  *(_BYTE *)(v1 + 1282) = j_HWM_pvg_read_reg(1) != 0;
  *(_BYTE *)(v1 + 1318) = j_HWM_pvg_read_reg(14) != 0;
  *(_BYTE *)(v1 + 1354) = j_HWM_pvg_read_reg(2) != 0;
  *(_BYTE *)(v1 + 1390) = j_HWM_pvg_read_reg(7)
                       && j_HWM_pvg_read_reg(8)
                       && j_HWM_pvg_read_reg(9)
                       && j_HWM_pvg_read_reg(10)
                       && j_HWM_pvg_read_reg(11);
  if ( sub_10022FB0(v7) )
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  v8 = *(_DWORD *)(a1 + 56);
  if ( *(_BYTE *)(v8 + 246) )
  {
    *(_BYTE *)(v8 + 246) = 0;
    sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008FD60, (int)&unk_10090470, 0, 255);
  }
  sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_10090158, v1 + 188, 0, 255);
  sub_10002C10(
    a1,
    *(_WORD **)(a1 + 52),
    *(char ***)(*(_DWORD *)(a1 + 56) + 56),
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 64),
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  v9 = (_WORD *)(v1 + 100);
  v39 = (_BYTE *)(v1 + 1392);
  v10 = 0;
  do
  {
    v11 = v39;
    *(_DWORD *)(v1 + 12) = dword_10090540[v10];
    v12 = *v11;
    if ( v12 )
    {
      v13 = v12 - 1;
      if ( v13 )
      {
        if ( v13 == 1 )
          *v9 = 1190;
      }
      else
      {
        *v9 = 1286;
      }
    }
    else
    {
      *v9 = 1414;
    }
    sub_10037530(a1, *(_DWORD *)(a1 + 52), (char *)v1, v1 + 100);
    ++v39;
    ++v10;
  }
  while ( v10 < 18 );
  v14 = (_WORD *)(v1 + 102);
  v39 = (_BYTE *)(v1 + 1410);
  v15 = 0;
  do
  {
    v16 = v39;
    *(_DWORD *)(v1 + 28) = dword_10090588[v15];
    if ( *v16 )
    {
      if ( *v16 == 1 )
      {
        *v14 = 1286;
      }
      else if ( *v16 == 2 )
      {
        *v14 = 1190;
      }
    }
    else
    {
      *v14 = 1414;
    }
    sub_10037530(a1, *(_DWORD *)(a1 + 52), (char *)(v1 + 16), v1 + 102);
    ++v39;
    ++v15;
  }
  while ( v15 < 12 );
  v17 = (_WORD *)(v1 + 104);
  v39 = (_BYTE *)(v1 + 1422);
  v18 = 0;
  do
  {
    v19 = v39;
    *(_DWORD *)(v1 + 44) = dword_100905B8[v18];
    if ( *v19 )
    {
      if ( *v19 == 1 )
      {
        *v17 = 1286;
      }
      else if ( *v19 == 2 )
      {
        *v17 = 1190;
      }
    }
    else
    {
      *v17 = 1414;
    }
    sub_10037530(a1, *(_DWORD *)(a1 + 52), (char *)(v1 + 32), v1 + 104);
    ++v39;
    ++v18;
  }
  while ( v18 < 2 );
  v20 = (_WORD *)(v1 + 108);
  v39 = (_BYTE *)(v1 + 1460);
  v21 = 0;
  do
  {
    v22 = v39;
    *(_DWORD *)(v1 + 72) = dword_10090534[v21];
    v23 = *v22;
    if ( v23 )
    {
      v24 = v23 - 1;
      if ( v24 )
      {
        if ( v24 == 1 )
          *v20 = 166;
      }
      else
      {
        *v20 = 262;
      }
    }
    else
    {
      *v20 = 390;
    }
    sub_10037530(a1, *(_DWORD *)(a1 + 52), (char *)(v1 + 64), v1 + 108);
    ++v39;
    ++v21;
  }
  while ( v21 < 3 );
  v25 = (_WORD *)(v1 + 112);
  v39 = (_BYTE *)(v1 + 1467);
  v26 = 0;
  do
  {
    v27 = v39;
    *(_DWORD *)(v1 + 96) = dword_10090660[v26];
    if ( *v27 )
    {
      if ( *v27 == 1 )
      {
        *v25 = 262;
      }
      else if ( *v27 == 2 )
      {
        *v25 = 166;
      }
    }
    else
    {
      *v25 = 390;
    }
    sub_10037530(a1, *(_DWORD *)(a1 + 52), (char *)(v1 + 88), v1 + 112);
    ++v39;
    ++v26;
  }
  while ( v26 < 6 );
  v28 = (_WORD *)(v1 + 110);
  v39 = (_BYTE *)(v1 + 1463);
  v29 = 0;
  do
  {
    v30 = v39;
    *(_DWORD *)(v1 + 84) = dword_10090650[v29];
    if ( *v30 )
    {
      if ( *v30 == 1 )
      {
        *v28 = 262;
      }
      else if ( *v30 == 2 )
      {
        *v28 = 166;
      }
    }
    else
    {
      *v28 = 390;
    }
    sub_10037530(a1, *(_DWORD *)(a1 + 52), (char *)(v1 + 76), v1 + 110);
    ++v39;
    ++v29;
  }
  while ( v29 < 4 );
  v31 = (_WORD *)(v1 + 106);
  v39 = (_BYTE *)(v1 + 1424);
  v32 = 0;
  do
  {
    v33 = v39;
    *(_DWORD *)(v1 + 60) = dword_100905C0[v32];
    v34 = *v33;
    if ( v34 )
    {
      v35 = v34 - 1;
      if ( v35 )
      {
        if ( v35 == 1 )
          *v31 = 1190;
      }
      else
      {
        *v31 = 1286;
      }
    }
    else
    {
      *v31 = 1414;
    }
    result = sub_10037530(a1, *(_DWORD *)(a1 + 52), (char *)(v1 + 48), v1 + 106);
    ++v39;
    ++v32;
  }
  while ( v32 < 36 );
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 1006BAF0: using guessed type int __cdecl j_HWM_pvg_get_anlg_outp(_DWORD);
// 1006BB10: using guessed type int __cdecl j_HWM_pvg_get_frmt_adc(_DWORD);
// 1006BB90: using guessed type int __cdecl j_HWM_pvg_lpbk_ethr(_DWORD);
// 1006BBA0: using guessed type int __cdecl j_HWM_pvg_lpbk_uart(_DWORD);
// 1006BBD0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10090534: using guessed type int dword_10090534[];
// 10090540: using guessed type int dword_10090540[];
// 10090588: using guessed type int dword_10090588[];
// 100905B8: using guessed type int dword_100905B8[];
// 100905C0: using guessed type int dword_100905C0[];
// 10090650: using guessed type int dword_10090650[];
// 10090660: using guessed type int dword_10090660[];

//----- (10013C60) --------------------------------------------------------
int __usercall sub_10013C60@<eax>(int a1@<esi>)
{
  int result; // eax@2

  if ( j_HWM_pvg_read_reg(0) == 22 || (result = j_HWM_pvg_read_reg(0), result == 46) )
  {
    result = sub_1003B860((_DWORD *)(*(_DWORD *)(a1 + 52) + 10), 2u, (int)&unk_10090690, 4, 6, 0xFFFF);
    if ( result != 0xFFFF )
      *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) = word_10090692[2 * result];
  }
  return result;
}
// 1006BBD0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10090692: using guessed type __int16 word_10090692[];

//----- (10013CC0) --------------------------------------------------------
char __usercall sub_10013CC0@<al>(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // ebx@1
  int v3; // edi@1
  _BYTE *v4; // ecx@1
  char result; // al@2

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 60);
  v3 = *(_DWORD *)(v1 + 12);
  sub_1006C4A0(v3 + 114, v3 + 178, 0);
  v4 = *(_BYTE **)(*(_DWORD *)(a1 + 56) + 64);
  if ( *(_BYTE *)(v3 + 180) == 1 )
  {
    result = 3;
    *v4 = 3;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 1) = 3;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 4) = 3;
    *(_DWORD *)(v2 + 8) = &unk_10090678;
  }
  else
  {
    result = 2;
    *v4 = 2;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 1) = 2;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 4) = 2;
    *(_DWORD *)(v2 + 8) = &unk_1009067C;
  }
  return result;
}

//----- (10013D30) --------------------------------------------------------
char __usercall sub_10013D30@<al>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // edi@1
  int v3; // eax@1
  int v4; // ebp@1
  void *v5; // ecx@1
  int v6; // edx@4
  int v7; // ecx@4
  char result; // al@4

  v1 = a1;
  v2 = sub_10003D50(a1, *(char **)(a1 + 56), 1480, 8);
  v3 = *(_DWORD *)(v1 + 56);
  v4 = *(_DWORD *)(v3 + 60);
  *(_BYTE *)(v3 + 230) = -1;
  sub_10002870(v1, 0, 0, 1024, 768, 1);
  sub_100374D0(*(_DWORD *)(v1 + 56), (char *)&unk_10090080);
  *(_DWORD *)(v2 + 380) = (unsigned __int16)j_HWM_pvg_get_anlg_outp(0);
  *(_DWORD *)(v2 + 384) = (unsigned __int16)j_HWM_pvg_get_anlg_outp(2);
  *(_DWORD *)(v2 + 388) = (unsigned __int16)j_HWM_pvg_get_anlg_outp(3);
  *(_DWORD *)(v2 + 372) = 0;
  *(_DWORD *)(v2 + 376) = 0;
  sub_1006C4A0(v2 + 114, v2 + 178, 0);
  if ( sub_10036FE0(v5) == 8 && *(_BYTE *)(v2 + 180) != 1 )
  {
    *(_BYTE *)(v2 + 180) = 1;
    *(_BYTE *)(v2 + 184) = 1;
    j_HWM_pvg_dspl_bklt_set_cnfg(0, v2 + 178, 0);
  }
  sub_10013CC0(v1);
  *(_DWORD *)(v4 + 4) = v2 + 384;
  *(_DWORD *)(v4 + 16) = v2 + 388;
  *(_DWORD *)(v4 + 12) = &unk_10090684;
  *(_DWORD *)(v4 + 20) = &unk_1009068C;
  *(_DWORD *)v4 = v2 + 380;
  *(_DWORD *)(v4 + 24) = &unk_1009045C;
  *(_DWORD *)(v4 + 28) = &unk_10090460;
  sub_10012FD0(v1);
  *(_DWORD *)(v2 + 368) = j_HWM_pvg_hsdb_get_lrus_online(v7, v6) == 0;
  *(_DWORD *)(v2 + 200) = v2 + 392;
  *(_DWORD *)(v2 + 204) = v2 + 396;
  *(_DWORD *)(v2 + 208) = v2 + 400;
  *(_DWORD *)(v2 + 212) = v2 + 404;
  *(_DWORD *)(v2 + 216) = v2 + 408;
  *(_DWORD *)(v2 + 220) = v2 + 412;
  *(_DWORD *)(v2 + 224) = v2 + 416;
  *(_DWORD *)(v2 + 228) = v2 + 420;
  *(_DWORD *)(v2 + 232) = v2 + 424;
  *(_DWORD *)(v2 + 236) = v2 + 428;
  *(_DWORD *)(v2 + 240) = v2 + 432;
  *(_DWORD *)(v2 + 244) = v2 + 436;
  *(_DWORD *)(v2 + 248) = v2 + 440;
  *(_DWORD *)(v2 + 252) = v2 + 444;
  *(_DWORD *)(v2 + 256) = v2 + 448;
  *(_DWORD *)(v2 + 260) = v2 + 452;
  *(_DWORD *)(v2 + 276) = v2 + 456;
  *(_DWORD *)(v2 + 280) = v2 + 492;
  *(_DWORD *)(v2 + 284) = v2 + 528;
  *(_DWORD *)(v2 + 288) = v2 + 564;
  *(_DWORD *)(v2 + 264) = v2 + 600;
  *(_DWORD *)(v2 + 268) = v2 + 636;
  *(_DWORD *)(v2 + 272) = v2 + 672;
  *(_DWORD *)(v2 + 296) = v2 + 708;
  *(_DWORD *)(v2 + 300) = v2 + 744;
  *(_DWORD *)(v2 + 312) = v2 + 780;
  *(_DWORD *)(v2 + 316) = v2 + 816;
  *(_DWORD *)(v2 + 188) = v2 + 1476;
  *(_DWORD *)(v2 + 192) = &unk_10090464;
  *(_DWORD *)(v2 + 196) = &unk_10090468;
  *(_DWORD *)(v2 + 292) = v2 + 852;
  *(_DWORD *)(v2 + 304) = v2 + 888;
  *(_DWORD *)(v2 + 308) = v2 + 924;
  *(_DWORD *)(v2 + 320) = v2 + 960;
  *(_DWORD *)(v2 + 324) = v2 + 996;
  *(_DWORD *)(v2 + 340) = v2 + 1140;
  *(_DWORD *)(v2 + 344) = v2 + 1176;
  *(_DWORD *)(v2 + 348) = v2 + 1212;
  *(_DWORD *)(v2 + 352) = v2 + 1248;
  *(_DWORD *)(v2 + 356) = v2 + 1284;
  *(_DWORD *)(v2 + 360) = v2 + 1320;
  *(_DWORD *)(v2 + 328) = v2 + 1032;
  *(_DWORD *)(v2 + 332) = v2 + 1068;
  *(_DWORD *)(v2 + 336) = v2 + 1104;
  *(_DWORD *)(v2 + 364) = v2 + 1356;
  *(_WORD *)(v2 + 1476) = 1904 - (j_HWM_pvg_read_reg(0) != 0);
  *(_BYTE *)(v2 + 1473) = 1;
  *(_BYTE *)(v2 + 1474) = 1;
  sub_10002C10(
    v1,
    *(_WORD **)(v1 + 52),
    *(char ***)(*(_DWORD *)(v1 + 56) + 56),
    *(_DWORD *)(*(_DWORD *)(v1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230));
  result = sub_10004590(v1, *(_DWORD *)(v1 + 56), -32734);
  *(_BYTE *)(v1 + 6) = 2;
  return result;
}
// 1006BAF0: using guessed type int __cdecl j_HWM_pvg_get_anlg_outp(_DWORD);
// 1006BB50: using guessed type int __fastcall j_HWM_pvg_hsdb_get_lrus_online(_DWORD, _DWORD);
// 1006BBD0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1006C320: using guessed type int __cdecl j_HWM_pvg_dspl_bklt_set_cnfg(_DWORD, _DWORD, _DWORD);

//----- (100140D0) --------------------------------------------------------
int __usercall sub_100140D0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // eax@1
  char v3; // cl@1
  int v4; // ebp@1
  int v5; // edi@1
  signed int *v6; // edx@2
  signed int v7; // ecx@8
  bool v8; // al@19
  int result; // eax@34
  signed int v10; // ecx@34

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 56);
  v3 = *(_BYTE *)(v2 + 230);
  v4 = *(_DWORD *)(v2 + 60);
  v5 = *(_DWORD *)(v2 + 12);
  if ( v3 )
  {
    if ( v3 == 1 )
    {
      v6 = (signed int *)(v5 + 384);
    }
    else
    {
      if ( v3 != 4 )
        goto LABEL_16;
      v6 = (signed int *)(v5 + 388);
    }
  }
  else
  {
    v6 = (signed int *)(v5 + 380);
  }
  if ( v6 )
  {
    v7 = *v6;
    if ( *v6 <= 200 )
    {
      if ( v7 > 0 && *(_BYTE *)(*(_DWORD *)(v1 + 52) + 8) < 0 )
      {
        *v6 = v7 - 10;
        goto LABEL_17;
      }
      if ( v7 < 200 && v7 >= 0 && *(_BYTE *)(*(_DWORD *)(v1 + 52) + 8) > 0 )
      {
        *v6 = v7 + 10;
        goto LABEL_17;
      }
    }
  }
LABEL_16:
  *(_BYTE *)(v1 + 6) = sub_100375A0(v1, (char *)v2, *(_DWORD *)(v1 + 52));
LABEL_17:
  if ( *(_BYTE *)(v1 + 6) == 3 )
  {
    switch ( *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230) )
    {
      case 7:
        v8 = *(_BYTE *)(v5 + 1390) != 1;
        *(_BYTE *)(v5 + 1390) = v8;
        j_HWM_pvg_set_reg(7, v8 == 1);
        if ( sub_1006C2C0() > 1 )
        {
          j_HWM_pvg_set_reg(8, *(_BYTE *)(v5 + 1390) == 1);
          j_HWM_pvg_set_reg(9, *(_BYTE *)(v5 + 1390) == 1);
          j_HWM_pvg_set_reg(10, *(_BYTE *)(v5 + 1390) == 1);
          j_HWM_pvg_set_reg(11, *(_BYTE *)(v5 + 1390) == 1);
        }
        sub_10013CC0(v1);
        break;
      case 2:
        if ( *(_BYTE *)(v5 + 180) == 1 )
        {
          *(_BYTE *)(v5 + 180) = 0;
          *(_BYTE *)(v5 + 184) = 0;
        }
        else
        {
          *(_BYTE *)(v5 + 180) = 1;
          *(_BYTE *)(v5 + 184) = 1;
        }
        j_HWM_pvg_dspl_bklt_set_cnfg(0, v5 + 178, 0);
        sub_10013CC0(v1);
        break;
      case 3:
        if ( *(_BYTE *)(v5 + 1473) )
        {
          j_HWM_pvg_set_anlg_outp(0, 65534, 2);
          *(_BYTE *)(v5 + 1473) = 0;
          *(_DWORD *)(v4 + 12) = &unk_10090680;
        }
        else
        {
          j_HWM_pvg_set_anlg_outp(0, 65534, 1);
          *(_BYTE *)(v5 + 1473) = 1;
          *(_DWORD *)(v4 + 12) = &unk_10090684;
        }
        break;
      case 5:
        if ( *(_BYTE *)(v5 + 1474) )
        {
          j_HWM_pvg_set_anlg_outp(3, 65534, 2);
          *(_BYTE *)(v5 + 1474) = 0;
          *(_DWORD *)(v4 + 20) = &unk_10090688;
        }
        else
        {
          j_HWM_pvg_set_anlg_outp(3, 65534, 1);
          *(_BYTE *)(v5 + 1474) = 1;
          *(_DWORD *)(v4 + 20) = &unk_1009068C;
        }
        break;
      case 6:
        sub_10012FD0(v1);
        *(_DWORD *)(v5 + 380) = 10000;
        *(_DWORD *)(v5 + 384) = 10000;
        *(_DWORD *)(v5 + 388) = 10000;
        j_HWM_pvg_set_anlg_outp(0, 10000, 4);
        j_HWM_pvg_set_anlg_outp(2, *(_WORD *)(v5 + 384), 0);
        j_HWM_pvg_set_anlg_outp(3, *(_WORD *)(v5 + 388), 0);
        break;
      default:
        break;
    }
    *(_BYTE *)(v1 + 6) = 2;
  }
  sub_10013C60(v1);
  result = *(_DWORD *)(v1 + 52);
  v10 = *(_WORD *)(result + 10);
  if ( v10 > 16387 )
  {
    switch ( v10 )
    {
      case 16397:
        *(_BYTE *)(v5 + 1397) = 2;
        break;
      case 16394:
        *(_BYTE *)(v5 + 1401) = 2;
        break;
      case 16395:
        *(_BYTE *)(v5 + 1396) = 2;
        break;
      case 16396:
        *(_BYTE *)(v5 + 1403) = 2;
        break;
      case 16398:
        *(_BYTE *)(v5 + 1402) = 2;
        break;
      case 16388:
        *(_BYTE *)(v5 + 1398) = 2;
        break;
      case 16389:
        *(_BYTE *)(v5 + 1393) = 2;
        break;
      case 16390:
        *(_BYTE *)(v5 + 1399) = 2;
        break;
      case 16391:
        *(_BYTE *)(v5 + 1394) = 2;
        break;
      case 16392:
        *(_BYTE *)(v5 + 1400) = 2;
        break;
      case 16393:
        *(_BYTE *)(v5 + 1395) = 2;
        break;
      default:
        return result;
    }
  }
  else if ( v10 == 16387 )
  {
    *(_BYTE *)(v5 + 1392) = 2;
  }
  else
  {
    switch ( v10 )
    {
      case 30:
        *(_BYTE *)(v5 + 1405) = 2;
        break;
      case 29:
        *(_BYTE *)(v5 + 1407) = 2;
        break;
      case 33:
        *(_BYTE *)(v5 + 1409) = 2;
        break;
      case 2:
        *(_BYTE *)(v5 + 1423) = 2;
        break;
      case 28:
        *(_BYTE *)(v5 + 1404) = 2;
        break;
      case 31:
        *(_BYTE *)(v5 + 1408) = 2;
        break;
      case 15:
        *(_BYTE *)(v5 + 1410) = 2;
        break;
      case 16:
        *(_BYTE *)(v5 + 1411) = 2;
        break;
      case 17:
        *(_BYTE *)(v5 + 1412) = 2;
        break;
      case 18:
        *(_BYTE *)(v5 + 1413) = 2;
        break;
      case 19:
        *(_BYTE *)(v5 + 1414) = 2;
        break;
      case 20:
        *(_BYTE *)(v5 + 1415) = 2;
        break;
      case 21:
        *(_BYTE *)(v5 + 1416) = 2;
        break;
      case 22:
        *(_BYTE *)(v5 + 1417) = 2;
        break;
      case 23:
        *(_BYTE *)(v5 + 1418) = 2;
        break;
      case 24:
        *(_BYTE *)(v5 + 1419) = 2;
        break;
      case 25:
        *(_BYTE *)(v5 + 1420) = 2;
        break;
      case 26:
        *(_BYTE *)(v5 + 1421) = 2;
        break;
      case 34:
        *(_BYTE *)(v5 + 1463) = 2;
        break;
      case 35:
        *(_BYTE *)(v5 + 1467) = 2;
        break;
      case 36:
        *(_BYTE *)(v5 + 1469) = 2;
        break;
      case 37:
        *(_BYTE *)(v5 + 1464) = 2;
        break;
      case 38:
      case 39:
        *(_BYTE *)(v5 + 1465) = 2;
        break;
      case 40:
        *(_BYTE *)(v5 + 1466) = 2;
        break;
      case 41:
        *(_BYTE *)(v5 + 1460) = 2;
        break;
      case 42:
        *(_BYTE *)(v5 + 1461) = 2;
        break;
      case 27:
        *(_BYTE *)(v5 + 1422) = 2;
        break;
      case 32:
        *(_BYTE *)(v5 + 1406) = 2;
        break;
      case 45:
        *(_BYTE *)(v5 + 1462) = 2;
        break;
      case 46:
        *(_BYTE *)(v5 + 1452) = 2;
        break;
      case 47:
        *(_BYTE *)(v5 + 1453) = 2;
        break;
      case 48:
        *(_BYTE *)(v5 + 1454) = 2;
        break;
      case 49:
        *(_BYTE *)(v5 + 1455) = 2;
        break;
      case 50:
        *(_BYTE *)(v5 + 1456) = 2;
        break;
      case 51:
        *(_BYTE *)(v5 + 1457) = 2;
        break;
      case 52:
        *(_BYTE *)(v5 + 1458) = 2;
        break;
      case 53:
        *(_BYTE *)(v5 + 1459) = 2;
        break;
      case 58:
        if ( *(_BYTE *)(result + 8) < 0 )
          *(_BYTE *)(v5 + 1426) = 2;
        if ( *(_BYTE *)(*(_DWORD *)(v1 + 52) + 8) > 0 )
          *(_BYTE *)(v5 + 1427) = 2;
        break;
      case 66:
        if ( *(_BYTE *)(result + 8) < 0 )
          *(_BYTE *)(v5 + 1437) = 2;
        if ( *(_BYTE *)(*(_DWORD *)(v1 + 52) + 8) > 0 )
          *(_BYTE *)(v5 + 1438) = 2;
        break;
      case 67:
        if ( *(_BYTE *)(result + 8) < 0 )
          *(_BYTE *)(v5 + 1436) = 2;
        result = *(_DWORD *)(v1 + 52);
        if ( *(_BYTE *)(result + 8) > 0 )
          *(_BYTE *)(v5 + 1439) = 2;
        break;
      case 63:
        if ( *(_BYTE *)(result + 8) < 0 )
          *(_BYTE *)(v5 + 1448) = 2;
        if ( *(_BYTE *)(*(_DWORD *)(v1 + 52) + 8) > 0 )
          *(_BYTE *)(v5 + 1449) = 2;
        break;
      case 64:
        if ( *(_BYTE *)(result + 8) < 0 )
          *(_BYTE *)(v5 + 1432) = 2;
        if ( *(_BYTE *)(*(_DWORD *)(v1 + 52) + 8) > 0 )
          *(_BYTE *)(v5 + 1433) = 2;
        break;
      case 65:
        if ( *(_BYTE *)(result + 8) < 0 )
          *(_BYTE *)(v5 + 1434) = 2;
        result = *(_DWORD *)(v1 + 52);
        if ( *(_BYTE *)(result + 8) > 0 )
          *(_BYTE *)(v5 + 1435) = 2;
        break;
      case 59:
        if ( *(_BYTE *)(result + 8) < 0 )
          *(_BYTE *)(v5 + 1424) = 2;
        if ( *(_BYTE *)(*(_DWORD *)(v1 + 52) + 8) > 0 )
          *(_BYTE *)(v5 + 1425) = 2;
        break;
      case 61:
        if ( *(_BYTE *)(result + 8) < 0 )
          *(_BYTE *)(v5 + 1429) = 2;
        if ( *(_BYTE *)(*(_DWORD *)(v1 + 52) + 8) > 0 )
          *(_BYTE *)(v5 + 1430) = 2;
        break;
      case 62:
        if ( *(_BYTE *)(result + 8) < 0 )
          *(_BYTE *)(v5 + 1428) = 2;
        result = *(_DWORD *)(v1 + 52);
        if ( *(_BYTE *)(result + 8) > 0 )
          *(_BYTE *)(v5 + 1431) = 2;
        break;
      case 55:
        if ( *(_BYTE *)(result + 8) < 0 )
          *(_BYTE *)(v5 + 1440) = 2;
        if ( *(_BYTE *)(*(_DWORD *)(v1 + 52) + 8) > 0 )
          *(_BYTE *)(v5 + 1443) = 2;
        break;
      case 54:
        if ( *(_BYTE *)(result + 8) < 0 )
          *(_BYTE *)(v5 + 1441) = 2;
        if ( *(_BYTE *)(*(_DWORD *)(v1 + 52) + 8) > 0 )
          *(_BYTE *)(v5 + 1442) = 2;
        break;
      case 56:
        if ( *(_BYTE *)(result + 8) >= 0 )
          *(_BYTE *)(v5 + 1446) = 2;
        else
          *(_BYTE *)(v5 + 1445) = 2;
        if ( *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230) )
        {
          if ( *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230) == 1 )
          {
            result = j_HWM_pvg_set_anlg_outp(2, *(_DWORD *)(v5 + 384) <= 0 ? 0 : *(_DWORD *)(v5 + 384), 0);
          }
          else
          {
            result = *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230) - 4;
            if ( *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230) == 4 )
              result = j_HWM_pvg_set_anlg_outp(3, *(_DWORD *)(v5 + 388) <= 0 ? 0 : *(_DWORD *)(v5 + 388), 0);
          }
        }
        else
        {
          result = j_HWM_pvg_set_anlg_outp(0, *(_DWORD *)(v5 + 380) <= 0 ? 0 : *(_DWORD *)(v5 + 380), 4);
        }
        if ( *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230) != -1 )
          *(_BYTE *)(v1 + 6) = 2;
        break;
      case 57:
        if ( *(_BYTE *)(result + 8) < 0 )
          *(_BYTE *)(v5 + 1444) = 2;
        if ( *(_BYTE *)(*(_DWORD *)(v1 + 52) + 8) > 0 )
          *(_BYTE *)(v5 + 1447) = 2;
        break;
      case 60:
        if ( *(_BYTE *)(result + 8) < 0 )
          *(_BYTE *)(v5 + 1450) = 2;
        result = *(_DWORD *)(v1 + 52);
        if ( *(_BYTE *)(result + 8) > 0 )
          *(_BYTE *)(v5 + 1451) = 2;
        break;
      default:
        return result;
    }
  }
  return result;
}
// 1006BBE0: using guessed type int __cdecl j_HWM_pvg_set_anlg_outp(_DWORD, _DWORD, _DWORD);
// 1006BC00: using guessed type int __cdecl j_HWM_pvg_set_reg(_DWORD, _DWORD);
// 1006C320: using guessed type int __cdecl j_HWM_pvg_dspl_bklt_set_cnfg(_DWORD, _DWORD, _DWORD);

//----- (10014950) --------------------------------------------------------
char __cdecl sub_10014950(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1

  v2 = **(_WORD **)(a1 + 52);
  switch ( v2 )
  {
    case 32833:
      LOBYTE(v2) = sub_10013D30(a1);
      break;
    case 32840:
      if ( sub_10022FB0(v1) )
      {
        LOWORD(v2) = *(_WORD *)(*(_DWORD *)(a1 + 52) + 10);
        if ( (_WORD)v2 != 56 && (_WORD)v2 != 57 )
          *(_BYTE *)(a1 + 6) = 2;
      }
      else
      {
        LOBYTE(v2) = sub_100140D0(a1);
      }
      break;
    case 32802:
      LOBYTE(v2) = sub_1000FE60(a1);
      break;
    case 32792:
      LOBYTE(v2) = a1;
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 32888:
      LOBYTE(v2) = sub_100133A0(a1);
      break;
    default:
      return v2;
  }
  return v2;
}

//----- (10014A90) --------------------------------------------------------
int __usercall sub_10014A90@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ebx@1
  int v3; // edi@1
  int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(_BYTE *)(v1 + 85);
  v3 = 84 * v2 + v1;
  *(_WORD *)(v1 + 666) = *(_BYTE *)(v3 + 246) != 1;
  *(float *)(v1 + 604) = flt_10090C34[2 * sub_1003B860((_DWORD *)(v3 + 247), 1u, (int)&unk_10090C30, 8, 4, 0)];
  *(float *)(v1 + 764) = (double)*(_WORD *)(v3 + 242);
  result = 21 * v2;
  *(float *)(v1 + 836) = (double)*(_WORD *)(v3 + 240);
  *(float *)(v1 + 908) = *(float *)(v3 + 220);
  *(float *)(v1 + 980) = *(float *)(v3 + 224);
  *(float *)(v1 + 1052) = *(float *)(v3 + 228);
  *(float *)(v1 + 1124) = *(float *)(v3 + 232);
  *(float *)(v1 + 1196) = *(float *)(v3 + 236);
  *(float *)(v1 + 1268) = (double)*(_BYTE *)(v3 + 270);
  return result;
}
// 10090C34: using guessed type float flt_10090C34[];

//----- (10014B70) --------------------------------------------------------
char __usercall sub_10014B70@<al>(int a1@<esi>)
{
  char result; // al@1

  sub_1003D0A0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10090C50, (int)&unk_10091574, 0, 255);
  result = sub_10004590(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10014BB0) --------------------------------------------------------
char __usercall sub_10014BB0@<al>(int a1@<eax>)
{
  int v1; // edi@1
  int v2; // esi@1
  int v3; // eax@1
  signed int v4; // ecx@1
  unsigned __int8 v5; // bl@1
  int v6; // ecx@5
  int v7; // ecx@5
  int v8; // edx@7
  int v9; // edi@17
  float *v10; // ecx@17
  int v11; // eax@17
  signed int v12; // edx@17

  v1 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v3 = *(_DWORD *)(a1 + 52);
  v4 = *(_WORD *)(v3 + 10);
  v5 = *(_BYTE *)(v2 + 85);
  if ( v4 >= 45 )
  {
    if ( v4 <= 53 )
    {
      LOBYTE(v3) = sub_1003D0A0(v1, (_WORD *)v3, (char *)&unk_10091480, v2 + 12, 0, 255);
    }
    else if ( v4 == 60 )
    {
      if ( *(_BYTE *)(v3 + 8) >= 0 )
      {
        v8 = v5 << 6;
        LOBYTE(v3) = *(_BYTE *)(v8 + v2 + 146);
        if ( (unsigned __int8)v3 > *(_BYTE *)(v8 + v2 + 148) )
        {
          LOBYTE(v3) = v3 - 1;
          *(_BYTE *)(v8 + v2 + 146) = v3;
        }
      }
      else
      {
        v6 = v5 << 6;
        LOBYTE(v3) = *(_BYTE *)(v6 + v2 + 146);
        v7 = v2 + v6;
        if ( (unsigned __int8)v3 < *(_BYTE *)(v7 + 147) )
        {
          LOBYTE(v3) = v3 + 1;
          *(_BYTE *)(v7 + 146) = v3;
        }
      }
    }
  }
  if ( *(_BYTE *)(v1 + 6) != 2 )
  {
    LOBYTE(v3) = sub_100375A0(v1, *(char **)(v1 + 56), *(_DWORD *)(v1 + 52));
    *(_BYTE *)(v1 + 6) = v3;
  }
  if ( *(_WORD *)(*(_DWORD *)(v1 + 52) + 10) == 56 )
  {
    LOBYTE(v3) = *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230);
    if ( (_BYTE)v3 != 3 && (_BYTE)v3 != 4 && (_BYTE)v3 != 5 && (_BYTE)v3 != 6 )
    {
      if ( *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230) == 7 )
      {
        *(float *)((v5 << 6) + v2 + 108) = *(float *)(v2 + 1196);
        LOBYTE(v3) = sub_1002CAF0(v2 + 68, v2 + 54, v2 + 84, 0.0);
        *(_BYTE *)(v2 + 48) = 1;
      }
      else if ( *(_BYTE *)(*(_DWORD *)(v1 + 56) + 230) == 8 )
      {
        v3 = v5 << 6;
        *(_BYTE *)(v3 + v2 + 145) = (signed int)*(float *)(v2 + 1268);
      }
    }
    else
    {
      v9 = (v5 << 6) + v2;
      v10 = (float *)(v2 + 908);
      v11 = v9 + 92;
      v12 = 4;
      do
      {
        v11 += 4;
        *(float *)(v11 - 4) = *v10;
        v10 += 18;
        --v12;
      }
      while ( v12 );
      LOBYTE(v3) = sub_1002CAF0(v2 + 68, v2 + 54, v2 + 84, COERCE_FLOAT(1));
      *(_BYTE *)(v9 + 146) = 7;
      *(_BYTE *)(v2 + 48) = 1;
    }
  }
  return v3;
}

//----- (10014D70) --------------------------------------------------------
char __usercall sub_10014D70@<al>(int a1@<eax>)
{
  int v1; // ecx@1
  int v2; // esi@1
  int v3; // eax@1
  int v4; // eax@1
  int v5; // ecx@2
  signed int v6; // edi@3
  signed int v7; // ebp@5
  void *v8; // ecx@8
  void *v9; // ecx@8
  int v10; // eax@8
  bool v11; // zf@8
  float v12; // ST18_4@11
  float v13; // ST18_4@14
  int v15; // [sp+18h] [bp-18h]@1
  int v16; // [sp+1Ch] [bp-14h]@1
  int v17; // [sp+20h] [bp-10h]@1
  int v18; // [sp+24h] [bp-Ch]@1
  int v19; // [sp+28h] [bp-8h]@1
  int v20; // [sp+2Ch] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 12);
  *(_BYTE *)(v2 + 48) = 1;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v3 = sub_10037130((void *)v1);
  v4 = sub_10036DA0(v3);
  sub_1006A0A0(v4, (int)&v15, 24);
  if ( *(_BYTE *)(v2 + 49) >= 3u )
  {
    *(_BYTE *)(v2 + 49) = 0;
    sub_100370D0(1);
    v5 = (*(_BYTE *)(v2 + 85) << 6) + v2 + 92;
    *(_DWORD *)v5 = 0;
    *(_DWORD *)(v5 + 4) = 0;
    *(_DWORD *)(v5 + 8) = 0;
    *(_DWORD *)(v5 + 12) = 0;
    *(_BYTE *)((*(_BYTE *)(v2 + 85) << 6) + v2 + 118) = 1;
  }
  v6 = *((_WORD *)&v16 + 6 * *(_BYTE *)(v2 + 85) + 1);
  if ( v6 <= 720 )
    v6 = 720;
  v7 = ((((unsigned int)*((_BYTE *)&v17 + 12 * *(_BYTE *)(v2 + 85) + 2) >> 1) & 1) + 1)
     * *((_WORD *)&v15 + 6 * *(_BYTE *)(v2 + 85) + 1);
  if ( v7 <= 480 )
    v7 = 480;
  if ( *(_BYTE *)(v2 + 49) )
  {
    sub_100370D0(0);
    *(_WORD *)(v2 + 76) = sub_10036F50(v8);
    LOWORD(v10) = sub_10036F80(v9);
    v11 = *(_BYTE *)(v2 + 49) == 2;
    *(_WORD *)(v2 + 78) = v10;
    if ( v11 )
    {
      if ( *(_WORD *)(v2 + 76) <= v6 )
      {
        v12 = 1.0 - (double)*(_WORD *)(v2 + 76) / (double)v6;
        *(float *)((*(_BYTE *)(v2 + 85) << 6) + v2 + 104) = COERCE_FLOAT(LODWORD(v12) & 0x7FFFFFFF);
      }
      else
      {
        *(_WORD *)(v2 + 76) = v6;
      }
      v10 = *(_WORD *)(v2 + 78);
      if ( v10 <= v7 )
      {
        v13 = 1.0 - (double)*(_WORD *)(v2 + 78) / (double)v7;
        v10 = *(_BYTE *)(v2 + 85) << 6;
        *(float *)(v10 + v2 + 96) = COERCE_FLOAT(LODWORD(v13) & 0x7FFFFFFF);
      }
      else
      {
        *(_WORD *)(v2 + 78) = v7;
      }
      *(_BYTE *)((*(_BYTE *)(v2 + 85) << 6) + v2 + 118) = 0;
    }
    *(_WORD *)(v2 + 54) = 0;
    *(_WORD *)(v2 + 56) = 0;
  }
  else
  {
    LOBYTE(v10) = *(_BYTE *)(v2 + 86);
    if ( (_BYTE)v10 != 1 && (_BYTE)v10 )
    {
      *(_WORD *)(v2 + 78) = 576;
      *(_WORD *)(v2 + 56) = 96;
      *(_WORD *)(v2 + 54) = 42;
      *(_WORD *)(v2 + 76) = 720;
    }
    else
    {
      *(_WORD *)(v2 + 78) = 480;
      *(_WORD *)(v2 + 56) = 144;
      *(_WORD *)(v2 + 54) = 42;
      *(_WORD *)(v2 + 76) = 720;
    }
  }
  return v10;
}

//----- (10014F40) --------------------------------------------------------
unsigned __int8 __usercall sub_10014F40@<al>(int a1@<eax>)
{
  int v1; // esi@1
  unsigned __int8 result; // al@1
  int v3; // ebp@2
  int v4; // edi@2
  _BYTE *v5; // ebx@14
  int v6; // eax@14
  signed int v7; // ecx@14
  signed int v8; // ST40_4@14
  signed int v9; // eax@14
  double v10; // st6@14
  int v11; // eax@14
  bool v12; // zf@14
  int v13; // edi@14
  int v14; // eax@14
  int v15; // [sp-18h] [bp-24h]@4
  int v16; // [sp-18h] [bp-24h]@10
  char *v17; // [sp-14h] [bp-20h]@4
  char *v18; // [sp-14h] [bp-20h]@10

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  result = *(_BYTE *)(v1 + 85);
  if ( result < 2u )
  {
    v3 = result;
    v4 = (result << 6) + v1;
    sub_100365D0(v1 + 557, (_BYTE *)(v4 + 125), 20);
    if ( *(_BYTE *)(v1 + 85) )
    {
      if ( *(_BYTE *)(v1 + 85) != 1 )
        goto LABEL_7;
      v17 = sub_10037280(0xA2u);
      v15 = v1 + 577;
    }
    else
    {
      v17 = sub_10037280(0x70u);
      v15 = v1 + 577;
    }
    sub_100365D0(v15, v17, 10);
LABEL_7:
    if ( *(_BYTE *)(v1 + 86) )
    {
      if ( *(_BYTE *)(v1 + 86) == 1 )
      {
        v18 = sub_10037280(0x12B2u);
        v16 = v1 + 587;
      }
      else
      {
        if ( *(_BYTE *)(v1 + 86) != 2 )
        {
LABEL_14:
          v5 = (_BYTE *)(v4 + 120);
          v6 = sub_1003B860((_DWORD *)(v4 + 120), 1u, (int)&unk_10090C30, 8, 4, 0);
          v7 = *(_BYTE *)(v1 + 87);
          *(float *)(v1 + 604) = flt_10090C34[2 * v6];
          v8 = *(_BYTE *)(v1 + 88);
          v9 = *(_BYTE *)(v1 + 89);
          *(float *)(v1 + 1288) = (double)v7 / 100.0;
          v10 = (double)v8;
          LOBYTE(v8) = v9;
          *(float *)(v1 + 1352) = v10 / 100.0;
          *(float *)(v1 + 1416) = (double)v9 / 100.0;
          v11 = sub_1003B860((_DWORD *)(v4 + 146), 1u, (int)&unk_10090BF4, 12, 5, 0);
          v12 = *(_WORD *)(v1 + 666) == 0;
          v13 = 84 * v3 + v1;
          *(float *)(v1 + 1480) = flt_10090BF8[3 * v11];
          *(_BYTE *)(v13 + 246) = v12;
          *(_BYTE *)(v13 + 247) = *v5;
          *(_WORD *)(v13 + 240) = (signed int)*(float *)(v1 + 836);
          *(_WORD *)(v13 + 242) = (signed int)*(float *)(v1 + 764);
          v14 = 21 * v3;
          *(float *)(v1 + 4 * v14 + 220) = *(float *)(v1 + 908);
          *(float *)(v1 + 4 * v14 + 224) = *(float *)(v1 + 980);
          *(float *)(v1 + 4 * v14 + 228) = *(float *)(v1 + 1052);
          *(float *)(v1 + 4 * v14 + 232) = *(float *)(v1 + 1124);
          result = v8;
          *(_BYTE *)(v13 + 270) = (signed int)*(float *)(v1 + 1268);
          *(float *)(v13 + 236) = *(float *)(v1 + 1196);
          return result;
        }
        v18 = sub_10037280(0x13B6u);
        v16 = v1 + 587;
      }
    }
    else
    {
      v18 = sub_10037280(0x376u);
      v16 = v1 + 587;
    }
    sub_100365D0(v16, v18, 10);
    goto LABEL_14;
  }
  return result;
}
// 10090BF8: using guessed type float flt_10090BF8[];
// 10090C34: using guessed type float flt_10090C34[];

//----- (10015180) --------------------------------------------------------
char __cdecl sub_10015180(int a1)
{
  int v1; // ebp@1
  int v2; // eax@1
  int v3; // edx@1
  int v4; // eax@5
  int v5; // eax@5
  char *v6; // eax@5
  int v7; // edi@5
  int v8; // esi@5
  signed int v9; // ecx@7
  signed int v10; // eax@9
  float *v11; // eax@11
  float *v12; // ecx@11
  signed int v13; // edx@11
  double v14; // st7@12
  unsigned __int8 v15; // al@13
  _BYTE *v16; // ecx@13
  int v17; // eax@16
  int v18; // edx@16
  int v19; // eax@16
  int v20; // edx@16
  int v21; // esi@16
  int v22; // esi@18
  char result; // al@18
  int v24; // [sp+14h] [bp-44h]@5
  char *v25; // [sp+18h] [bp-40h]@5
  int v26; // [sp+18h] [bp-40h]@16
  signed int v27; // [sp+1Ch] [bp-3Ch]@5
  signed int v28; // [sp+1Ch] [bp-3Ch]@16
  int v29; // [sp+20h] [bp-38h]@1
  int v30; // [sp+24h] [bp-34h]@5
  int v31; // [sp+28h] [bp-30h]@5
  int v32; // [sp+2Ch] [bp-2Ch]@5
  int v33; // [sp+30h] [bp-28h]@5
  int v34; // [sp+34h] [bp-24h]@5
  int v35; // [sp+38h] [bp-20h]@5
  int v36; // [sp+3Ch] [bp-1Ch]@16
  int v37; // [sp+40h] [bp-18h]@16
  float v38; // [sp+44h] [bp-14h]@16
  float v39; // [sp+48h] [bp-10h]@16
  int v40; // [sp+4Ch] [bp-Ch]@16
  float v41; // [sp+50h] [bp-8h]@16
  float v42; // [sp+54h] [bp-4h]@16

  v1 = sub_10003D50(a1, *(char **)(a1 + 56), 1540, 9);
  sub_10002870(a1, 0, 0, 1024, 768, 3);
  sub_100374D0(*(_DWORD *)(a1 + 56), (char *)&unk_10091430);
  *(_BYTE *)(v1 + 48) = 1;
  *(_BYTE *)(v1 + 49) = 0;
  v2 = *(_DWORD *)(a1 + 56);
  v3 = *(_DWORD *)(v2 + 60);
  *(_BYTE *)(v2 + 230) = -1;
  v29 = v3;
  sub_10003F00(a1, *(_DWORD *)(a1 + 56), 1);
  *(_DWORD *)(v1 + 68) = 49;
  *(_DWORD *)(v1 + 72) = -16777216;
  *(_BYTE *)(v1 + 80) = *(_BYTE *)a1;
  *(_BYTE *)(v1 + 81) = 0;
  memset((void *)(v1 + 84), 0, 0x88u);
  *(_BYTE *)(v1 + 84) = 0;
  *(_BYTE *)(v1 + 90) = 0;
  *(_BYTE *)(v1 + 91) = 0;
  *(_BYTE *)(v1 + 556) = 1;
  if ( sub_1006A0A0(6448, v1 + 388, 84) )
  {
    memset((void *)(v1 + 388), 0, 0x54u);
    *(_BYTE *)(v1 + 556) = 0;
  }
  if ( sub_1006A0A0(6449, v1 + 472, 84) )
  {
    memset((void *)(v1 + 472), 0, 0x54u);
    *(_BYTE *)(v1 + 556) = 0;
  }
  qmemcpy((void *)(v1 + 220), (const void *)(v1 + 388), 0x54u);
  qmemcpy((void *)(v1 + 304), (const void *)(v1 + 472), 0x54u);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v4 = sub_10037130(0);
  v5 = sub_10036DA0(v4);
  sub_1006A0A0(v5, (int)&v30, 24);
  v6 = (char *)&v30 + 2;
  v7 = 0;
  v25 = (char *)&v30 + 2;
  v24 = v1 + 388;
  v8 = v1 + 118;
  v27 = 2;
  while ( 1 )
  {
    *(_BYTE *)(v8 - 2) = *(_BYTE *)(v7 + dword_10789FA0 + 30246);
    *(_BYTE *)v8 = 1;
    v9 = *(_WORD *)v6 * ((((unsigned int)(unsigned __int8)v6[8] >> 1) & 1) + 1);
    if ( v9 <= 480 )
      LOWORD(v9) = 480;
    *(_WORD *)(v8 - 6) = v9;
    v10 = *((_WORD *)v6 + 2);
    if ( v10 <= 720 )
      LOWORD(v10) = 720;
    *(_WORD *)(v8 - 4) = v10;
    *(_BYTE *)(v8 + 2) = *(_BYTE *)(v24 + 27);
    *(_BYTE *)(v8 + 5) = 1;
    *(_BYTE *)(v8 + 6) = 0;
    *(_BYTE *)(v8 + 1) = 1;
    *(_BYTE *)(v8 - 1) = 1;
    *(float *)(v8 - 10) = *(float *)(v7 + dword_10789FA0 + 30236);
    sub_100365D0(v8 + 7, (_BYTE *)(v7 + dword_10789FA0 + 30248), 20);
    v11 = (float *)v24;
    v12 = (float *)(v8 - 26);
    v13 = 4;
    do
    {
      v14 = *v11;
      ++v11;
      *v12 = v14;
      ++v12;
      --v13;
    }
    while ( v13 );
    *(_BYTE *)(v8 + 3) = 1;
    *(_BYTE *)(v8 + 4) = 1;
    *(_BYTE *)(v8 + 27) = *(_BYTE *)(v7 + dword_10789FA0 + 30270);
    *(_BYTE *)(v8 + 28) = 0;
    *(_BYTE *)(v8 + 29) = 4;
    *(_BYTE *)(v8 + 30) = 0;
    v15 = 0;
    v16 = (_BYTE *)(v8 + 31);
    do
      *v16++ = v15++;
    while ( v15 < 5u );
    v25 += 12;
    v24 += 84;
    v7 += 84;
    v8 += 64;
    if ( !--v27 )
      break;
    v6 = v25;
  }
  v38 = 12.0;
  *(_BYTE *)(v1 + 85) = 0;
  *(_BYTE *)(v1 + 87) = 50;
  *(_BYTE *)(v1 + 88) = 50;
  *(_BYTE *)(v1 + 89) = 50;
  *(_BYTE *)(v1 + 86) = 0;
  v37 = 0;
  v36 = -16711681;
  v17 = sub_1003CED0(12.0);
  *(_DWORD *)(v1 + 557) = 0;
  v39 = 0.0;
  *(_DWORD *)(v1 + 561) = 0;
  v41 = 0.0;
  *(_DWORD *)(v1 + 565) = 0;
  *(_DWORD *)(v1 + 569) = 0;
  v42 = 0.5;
  *(_DWORD *)(v1 + 573) = 0;
  *(_DWORD *)(v1 + 577) = 0;
  *(_DWORD *)(v1 + 581) = 0;
  *(_WORD *)(v1 + 585) = 0;
  v40 = v17;
  *(_DWORD *)(v1 + 587) = 0;
  *(_DWORD *)(v1 + 591) = 0;
  *(_WORD *)(v1 + 595) = 0;
  *(float *)(v1 + 604) = 9.8999998e24;
  *(float *)(v1 + 672) = 12.0;
  qmemcpy((void *)(v1 + 608), &v36, 0x1Cu);
  *(_DWORD *)(v1 + 12) = v1 + 557;
  *(_DWORD *)(v1 + 20) = v1 + 587;
  *(_BYTE *)(v1 + 640) = 1;
  *(_DWORD *)(v1 + 660) = 0;
  *(_WORD *)(v1 + 600) = 42;
  *(_DWORD *)(v1 + 636) = 0;
  *(_DWORD *)(v1 + 16) = v1 + 577;
  *(_DWORD *)(v1 + 24) = v1 + 600;
  *(_WORD *)(v1 + 664) = 2;
  *(_WORD *)(v1 + 666) = 0;
  *(_DWORD *)(v1 + 668) = sub_1003CED0(12.0);
  *(float *)(v1 + 684) = 30.0;
  *(float *)(v1 + 688) = 939.0;
  *(_DWORD *)(v1 + 676) = -16777216;
  *(_DWORD *)(v1 + 680) = -16711681;
  *(float *)(v1 + 692) = 185.0;
  *(_DWORD *)(v1 + 704) = sub_10014A40;
  *(float *)(v1 + 696) = 0.0;
  *(float *)(v1 + 700) = 0.5;
  *(_DWORD *)v29 = v1 + 664;
  *(_WORD *)(v1 + 708) = 10;
  *(_DWORD *)(v1 + 712) = 0;
  *(_BYTE *)(v1 + 716) = 1;
  *(_BYTE *)(v1 + 718) = 1;
  *(_BYTE *)(v1 + 717) = 0;
  v18 = *(_BYTE *)(v1 + 85);
  *(float *)(v1 + 720) = 939.0;
  *(float *)(v1 + 724) = 292.0;
  *(float *)(v1 + 736) = 0.0;
  *(float *)(v1 + 740) = 0.5;
  *(float *)(v1 + 744) = 12.0;
  *(float *)(v1 + 748) = 40.0;
  *(_DWORD *)(v1 + 728) = -16777216;
  *(_DWORD *)(v1 + 732) = -16711681;
  *(float *)(v1 + 752) = 0.0;
  *(float *)(v1 + 756) = 1024.0;
  *(float *)(v1 + 760) = 1.0;
  *(float *)(v1 + 764) = (double)*(_WORD *)(84 * v18 + dword_10789FA0 + 30242);
  v19 = sub_1003CED0(12.0);
  v20 = *(_BYTE *)(v1 + 85);
  *(float *)(v1 + 792) = 939.0;
  *(float *)(v1 + 796) = 314.0;
  *(float *)(v1 + 808) = 0.0;
  *(float *)(v1 + 812) = 0.5;
  *(float *)(v1 + 816) = 12.0;
  *(float *)(v1 + 820) = 40.0;
  *(_DWORD *)(v1 + 768) = v19;
  *(float *)(v1 + 824) = 0.0;
  *(_BYTE *)(v1 + 772) = 0;
  *(float *)(v1 + 828) = 1024.0;
  *(_DWORD *)(v1 + 776) = -16711681;
  *(_WORD *)(v1 + 780) = 10;
  *(float *)(v1 + 832) = 1.0;
  *(_DWORD *)(v1 + 784) = 0;
  *(_BYTE *)(v1 + 788) = 1;
  *(_BYTE *)(v1 + 790) = 1;
  *(_BYTE *)(v1 + 789) = 0;
  *(_DWORD *)(v1 + 800) = -16777216;
  *(_DWORD *)(v1 + 804) = -16711681;
  *(float *)(v1 + 836) = (double)*(_WORD *)(84 * (v20 + 360) + dword_10789FA0);
  *(_DWORD *)(v1 + 840) = sub_1003CED0(12.0);
  *(_BYTE *)(v1 + 844) = 0;
  *(_DWORD *)(v1 + 848) = -16711681;
  *(_DWORD *)(v29 + 4) = v1 + 708;
  *(_DWORD *)(v29 + 8) = v1 + 780;
  v26 = 0;
  v21 = v1 + 856;
  v28 = 4;
  do
  {
    *(_WORD *)(v21 - 4) = 9;
    *(float *)(v21 + 24) = 0.0;
    *(_DWORD *)v21 = 0;
    *(_BYTE *)(v21 + 4) = 1;
    *(float *)(v21 + 28) = 0.5;
    *(_BYTE *)(v21 + 6) = 1;
    *(_BYTE *)(v21 + 5) = 0;
    *(float *)(v21 + 32) = 12.0;
    *(_DWORD *)(v21 + 16) = -16777216;
    *(_DWORD *)(v21 + 20) = -16711681;
    *(float *)(v21 + 36) = 40.0;
    *(float *)(v21 + 40) = 0.0;
    *(float *)(v21 + 44) = 0.49000001;
    *(float *)(v21 + 48) = 0.0049999999;
    *(float *)(v21 + 52) = *(float *)(v1 + 4 * (v26 + 16 * *(_BYTE *)(v1 + 85)) + 92);
    *(_DWORD *)(v21 + 56) = sub_1003CED0(12.0);
    ++v26;
    *(_BYTE *)(v21 + 60) = 0;
    *(_DWORD *)(v21 + 64) = -16711681;
    v21 += 72;
    --v28;
  }
  while ( v28 );
  *(float *)(v1 + 864) = 939.0;
  *(float *)(v1 + 868) = 377.0;
  *(float *)(v1 + 936) = 939.0;
  *(float *)(v1 + 940) = 399.0;
  *(float *)(v1 + 1008) = 939.0;
  *(float *)(v1 + 1012) = 421.0;
  *(float *)(v1 + 1080) = 939.0;
  *(float *)(v1 + 1084) = 443.0;
  *(_DWORD *)(v29 + 12) = v1 + 852;
  *(_DWORD *)(v29 + 16) = v1 + 924;
  *(_DWORD *)(v29 + 20) = v1 + 996;
  *(_DWORD *)(v29 + 24) = v1 + 1068;
  *(float *)(v1 + 1152) = 939.0;
  *(_WORD *)(v1 + 1140) = 8;
  *(float *)(v1 + 1156) = 506.0;
  *(_DWORD *)(v1 + 1144) = 0;
  *(_BYTE *)(v1 + 1148) = 1;
  *(_BYTE *)(v1 + 1150) = 1;
  *(_BYTE *)(v1 + 1149) = 0;
  *(_DWORD *)(v1 + 1160) = -16777216;
  *(_DWORD *)(v1 + 1164) = -16711681;
  *(float *)(v1 + 1168) = 0.0;
  *(float *)(v1 + 1172) = 0.5;
  *(float *)(v1 + 1176) = 12.0;
  *(float *)(v1 + 1180) = 40.0;
  *(float *)(v1 + 1184) = 0.0999;
  *(float *)(v1 + 1188) = 0.5;
  *(float *)(v1 + 1192) = 0.0099999998;
  *(float *)(v1 + 1196) = *(float *)(84 * *(_BYTE *)(v1 + 85) + dword_10789FA0 + 30236);
  *(_DWORD *)(v1 + 1200) = sub_1003CED0(12.0);
  *(_BYTE *)(v1 + 1204) = 0;
  *(_DWORD *)(v1 + 1208) = -16711681;
  *(_WORD *)(v1 + 1212) = 10;
  *(_DWORD *)(v1 + 1216) = 0;
  *(_BYTE *)(v1 + 1220) = 1;
  *(_BYTE *)(v1 + 1222) = 1;
  *(_BYTE *)(v1 + 1221) = 0;
  *(float *)(v1 + 1224) = 939.0;
  *(float *)(v1 + 1228) = 528.0;
  *(_DWORD *)(v1 + 1232) = -16777216;
  *(_DWORD *)(v1 + 1236) = -16711681;
  *(float *)(v1 + 1240) = 0.0;
  *(float *)(v1 + 1244) = 0.5;
  *(float *)(v1 + 1248) = 12.0;
  *(float *)(v1 + 1252) = 40.0;
  *(float *)(v1 + 1256) = 0.0;
  *(float *)(v1 + 1260) = 10.0;
  *(float *)(v1 + 1264) = 1.0;
  *(float *)(v1 + 1268) = (double)*(_BYTE *)(84 * *(_BYTE *)(v1 + 85) + dword_10789FA0 + 30270);
  *(_DWORD *)(v1 + 1272) = sub_1003CED0(12.0);
  *(_BYTE *)(v1 + 1276) = 0;
  *(_DWORD *)(v1 + 1280) = -16711681;
  *(_DWORD *)(v29 + 28) = v1 + 1140;
  *(_DWORD *)(v29 + 32) = v1 + 1212;
  *(_BYTE *)(v1 + 1324) = 1;
  *(float *)(v1 + 1288) = 9.8999998e24;
  *(_DWORD *)(v1 + 1344) = 0;
  *(_WORD *)(v1 + 1284) = 8;
  *(_DWORD *)(v1 + 1320) = 0;
  qmemcpy((void *)(v1 + 1292), &v36, 0x1Cu);
  *(_BYTE *)(v1 + 1388) = 1;
  *(float *)(v1 + 1352) = 9.8999998e24;
  *(_DWORD *)(v1 + 1408) = 0;
  *(_WORD *)(v1 + 1348) = 8;
  *(_DWORD *)(v1 + 1384) = 0;
  qmemcpy((void *)(v1 + 1356), &v36, 0x1Cu);
  *(_BYTE *)(v1 + 1452) = 1;
  *(float *)(v1 + 1416) = 9.8999998e24;
  *(_DWORD *)(v1 + 1472) = 0;
  *(_WORD *)(v1 + 1412) = 8;
  *(_DWORD *)(v1 + 1448) = 0;
  qmemcpy((void *)(v1 + 1420), &v36, 0x1Cu);
  *(_BYTE *)(v1 + 1516) = 1;
  *(float *)(v1 + 1480) = 9.8999998e24;
  *(_DWORD *)(v1 + 1536) = 0;
  *(_WORD *)(v1 + 1476) = 44;
  *(_DWORD *)(v1 + 1512) = 0;
  qmemcpy((void *)(v1 + 1484), &v36, 0x1Cu);
  v22 = a1;
  *(_DWORD *)(v1 + 28) = v1 + 1284;
  *(_DWORD *)(v1 + 32) = v1 + 1348;
  *(_DWORD *)(v1 + 36) = v1 + 1412;
  *(_DWORD *)(v1 + 40) = v1 + 1476;
  sub_10014D70(a1);
  *(_DWORD *)(v1 + 44) = v1 + 52;
  *(_BYTE *)(v1 + 52) = 1;
  *(_BYTE *)(v1 + 53) = 0;
  *(_DWORD *)(v1 + 60) = v1 + 68;
  *(_DWORD *)(v1 + 64) = v1 + 84;
  *(_DWORD *)v1 = 50529027;
  *(_DWORD *)(v1 + 4) = 50529027;
  *(_BYTE *)(v1 + 8) = 3;
  sub_10014A90(a1);
  sub_10018E40(a1, &unk_10091610, 0x1Fu, 16, 0);
  sub_100370D0(1);
  sub_10018B50(a1, 0, 1);
  sub_10018B50(a1, 2u, 1);
  sub_1003D0A0(v22, *(_WORD **)(v22 + 52), (char *)&unk_10091480, v1 + 12, 0, 255);
  sub_1003D0A0(
    v22,
    *(_WORD **)(v22 + 52),
    (char *)&unk_10091430,
    *(_DWORD *)(*(_DWORD *)(v22 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(v22 + 56) + 230));
  result = sub_10004590(v22, *(_DWORD *)(v22 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 10014A40: using guessed type int sub_10014A40();
// 10789FA0: using guessed type int dword_10789FA0;

//----- (10015B90) --------------------------------------------------------
char __usercall sub_10015B90@<al>(int a1@<edi>)
{
  int v1; // esi@1
  int v2; // eax@1
  unsigned __int8 v3; // bl@1
  int v4; // eax@9
  int v5; // ecx@9
  _BYTE *v6; // ebx@15
  int v7; // eax@31
  unsigned __int8 v8; // cl@31
  int v9; // ecx@33
  unsigned __int8 v10; // cl@33
  __int16 v12; // [sp+8h] [bp-16Ch]@15
  int v13; // [sp+Ch] [bp-168h]@15
  char v14; // [sp+10h] [bp-164h]@15
  __int16 v15; // [sp+12h] [bp-162h]@15
  __int16 v16; // [sp+14h] [bp-160h]@15
  int v17; // [sp+1Ch] [bp-158h]@12
  __int16 v18; // [sp+A4h] [bp-D0h]@13

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  v3 = *(_BYTE *)(v1 + 85);
  switch ( v2 )
  {
    case 0:
      *(_BYTE *)(v1 + 85) = 0;
      sub_10018B50(a1, 1u, 0);
      sub_10018B50(a1, 0, 1);
      *(_BYTE *)(v1 + 91) = 1;
      *(_BYTE *)((v3 << 6) + v1 + 146) = 0;
      LOBYTE(v2) = sub_10014A90(a1);
      return v2;
    case 1:
      *(_BYTE *)(v1 + 85) = 1;
      sub_10018B50(a1, 0, 0);
      sub_10018B50(a1, 1u, 1);
      *(_BYTE *)(v1 + 91) = 1;
      *(_BYTE *)((v3 << 6) + v1 + 146) = 0;
      LOBYTE(v2) = sub_10014A90(a1);
      return v2;
    case 2:
      *(_BYTE *)(v1 + 86) = 0;
      sub_10018B50(a1, 3u, 0);
      sub_10018B50(a1, 4u, 0);
      sub_10018B50(a1, 2u, 1);
      goto LABEL_5;
    case 3:
      *(_BYTE *)(v1 + 86) = 1;
      sub_10018B50(a1, 2u, 0);
      sub_10018B50(a1, 4u, 0);
      sub_10018B50(a1, 3u, 1);
      goto LABEL_5;
    case 4:
      *(_BYTE *)(v1 + 86) = 2;
      sub_10018B50(a1, 3u, 0);
      sub_10018B50(a1, 2u, 0);
      sub_10018B50(a1, 4u, 1);
LABEL_5:
      *(_BYTE *)(v1 + 91) = 1;
      sub_10014D70(a1);
      LOBYTE(v2) = sub_1002CAF0(v1 + 68, v1 + 54, v1 + 84, COERCE_FLOAT(1));
      *(_BYTE *)(v1 + 48) = 1;
      break;
    case 5:
      ++*(_BYTE *)(v1 + 49);
      sub_10014D70(a1);
      LOBYTE(v2) = sub_1002CAF0(v1 + 68, v1 + 54, v1 + 84, COERCE_FLOAT(1));
      break;
    case 6:
      v4 = v3 << 6;
      v5 = *(_BYTE *)(v4 + v1 + 120);
      v2 = v4 + v1 + 120;
      *(_BYTE *)v2 = (v5 + 1) % 4;
      break;
    case 9:
      LOBYTE(v2) = j_HWM_pvg_set_decoder_cfg(0);
      break;
    case 10:
      *(_BYTE *)(v1 + 85) = 2;
      *(_BYTE *)(v1 + 91) = 1;
      v2 = (v3 << 6) + v1;
      *(_BYTE *)(v2 + 120) = 0;
      *(_BYTE *)(v2 + 146) = 0;
      break;
    case 11:
      v17 = 0;
      BYTE1(v17) = 2;
      LOBYTE(v2) = sub_1002CAF0(v1 + 68, v1 + 54, (int)&v17, 0.0);
      break;
    case 12:
      v18 = -32734;
      LOBYTE(v2) = sub_1003D0A0(a1, &v18, (char *)&unk_10091480, v1 + 12, v1, 255);
      break;
    case 13:
      v18 = -32685;
      LOBYTE(v2) = sub_1003D0A0(a1, &v18, (char *)&unk_10091480, v1 + 12, v1, 255);
      break;
    case 14:
      v6 = (_BYTE *)((v3 << 6) + v1 + 119);
      *v6 = 0;
      v13 = 0;
      v12 = -32696;
      v15 = 46;
      v16 = 0;
      v14 = 1;
      LOBYTE(v2) = sub_1003D0A0(a1, &v12, (char *)&unk_10091480, v1 + 12, v1, 255);
      *v6 = 1;
      break;
    case 15:
      v13 = 0;
      v16 = 0;
      v12 = -32696;
      v15 = 16458;
      v14 = 1;
      LOBYTE(v2) = sub_1003D0A0(a1, &v12, (char *)&unk_10091480, v1 + 12, v1, 255);
      break;
    case 16:
      v2 = (v3 << 6) + v1;
      *(_BYTE *)(v2 + 146) = *(_BYTE *)(v2 + 147) + 1;
      break;
    case 17:
      v2 = v1 + (v3 << 6);
      *(_BYTE *)(v2 + 148) = 1;
      *(_BYTE *)(v2 + 146) = 0;
      break;
    case 20:
      LOBYTE(v2) = *(_BYTE *)(v1 + 88);
      if ( *(_BYTE *)(v1 + 88) + 5 <= 100 )
      {
        LOBYTE(v2) = v2 + 5;
        *(_BYTE *)(v1 + 88) = v2;
        *(_BYTE *)(v1 + 91) = 1;
      }
      break;
    case 21:
      LOBYTE(v2) = *(_BYTE *)(v1 + 88);
      if ( *(_BYTE *)(v1 + 88) - 5 >= 0 )
      {
        LOBYTE(v2) = v2 - 5;
        *(_BYTE *)(v1 + 88) = v2;
        *(_BYTE *)(v1 + 91) = 1;
      }
      break;
    case 22:
      LOBYTE(v2) = *(_BYTE *)(v1 + 87);
      if ( *(_BYTE *)(v1 + 87) + 5 <= 100 )
      {
        LOBYTE(v2) = v2 + 5;
        *(_BYTE *)(v1 + 87) = v2;
        *(_BYTE *)(v1 + 91) = 1;
      }
      break;
    case 23:
      LOBYTE(v2) = *(_BYTE *)(v1 + 87);
      if ( *(_BYTE *)(v1 + 87) - 5 >= 0 )
      {
        LOBYTE(v2) = v2 - 5;
        *(_BYTE *)(v1 + 87) = v2;
        *(_BYTE *)(v1 + 91) = 1;
      }
      break;
    case 24:
      LOBYTE(v2) = *(_BYTE *)(v1 + 89);
      if ( *(_BYTE *)(v1 + 89) + 5 <= 100 )
      {
        LOBYTE(v2) = v2 + 5;
        *(_BYTE *)(v1 + 89) = v2;
        *(_BYTE *)(v1 + 91) = 1;
      }
      break;
    case 25:
      LOBYTE(v2) = *(_BYTE *)(v1 + 89);
      if ( *(_BYTE *)(v1 + 89) - 5 >= 0 )
      {
        LOBYTE(v2) = v2 - 5;
        *(_BYTE *)(v1 + 89) = v2;
        *(_BYTE *)(v1 + 91) = 1;
      }
      break;
    case 26:
      v7 = v3 << 6;
      v8 = *(_BYTE *)(v7 + v1 + 146);
      v2 = v1 + v7;
      if ( v8 < *(_BYTE *)(v2 + 147) )
        *(_BYTE *)(v2 + 146) = v8 + 1;
      break;
    case 27:
      v9 = v3 << 6;
      v2 = v9 + v1;
      v10 = *(_BYTE *)(v9 + v1 + 146);
      if ( v10 > *(_BYTE *)(v2 + 148) )
        *(_BYTE *)(v2 + 146) = v10 - 1;
      break;
    case 28:
      LOBYTE(v2) = 50;
      *(_BYTE *)(v1 + 91) = 1;
      *(_BYTE *)((v3 << 6) + v1 + 146) = 7;
      *(_BYTE *)(v1 + 87) = 50;
      *(_BYTE *)(v1 + 88) = 50;
      *(_BYTE *)(v1 + 89) = 50;
      break;
    case 29:
      *(_BYTE *)(v1 + 8) = *(_BYTE *)(v1 + 8) == 3 ? 0 : 3;
      LOBYTE(v2) = sub_10004590(a1, *(_DWORD *)(a1 + 56), -32734);
      break;
    default:
      return v2;
  }
  return v2;
}
// 1006BBF0: using guessed type int __cdecl j_HWM_pvg_set_decoder_cfg(_DWORD);

//----- (10016210) --------------------------------------------------------
int __usercall sub_10016210@<eax>(int a1@<esi>)
{
  int v1; // edi@1
  int result; // eax@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10014F40(a1);
  if ( *(_BYTE *)(v1 + 48) )
  {
    *(_BYTE *)(v1 + 48) = 0;
    sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)&unk_10090C50, (int)&unk_10091574, 0, 255);
  }
  sub_1003D0A0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10090C88, (int)&unk_10091580, 0, 255);
  result = sub_1003D0A0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10091480, v1 + 12, v1, 255);
  if ( !*(_BYTE *)(v1 + 49) )
    result = sub_1003D0A0(
               a1,
               *(_WORD **)(a1 + 52),
               (char *)&unk_10091430,
               *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
               0,
               *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  *(_BYTE *)(v1 + 91) = 0;
  *(_BYTE *)(a1 + 392) = 1;
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (100162C0) --------------------------------------------------------
char __cdecl sub_100162C0(int a1)
{
  int v1; // eax@1

  v1 = **(_WORD **)(a1 + 52);
  switch ( v1 )
  {
    case 32792:
      LOBYTE(v1) = sub_10012920(a1);
      break;
    case 32802:
      LOBYTE(v1) = sub_10014B70(a1);
      break;
    case 32833:
      LOBYTE(v1) = sub_10015180(a1);
      break;
    case 32840:
      LOBYTE(v1) = sub_10014BB0(a1);
      break;
    case 32878:
      LOBYTE(v1) = sub_10015B90(a1);
      break;
    case 32888:
      LOBYTE(v1) = sub_10016210(a1);
      break;
    default:
      return v1;
  }
  return v1;
}

//----- (100163A0) --------------------------------------------------------
void __cdecl sub_100163A0(unsigned int a1, char a2, _BYTE *a3, char a4)
{
  int v4; // ebx@1
  void *v5; // ecx@1
  void *v6; // ecx@1
  void *v7; // ecx@2
  void *v8; // ecx@3
  __int16 v9; // [sp+Ch] [bp-D0h]@1
  int v10; // [sp+10h] [bp-CCh]@1
  char v11; // [sp+14h] [bp-C8h]@1
  __int16 v12; // [sp+16h] [bp-C6h]@5
  __int16 v13; // [sp+18h] [bp-C4h]@5
  int v14; // [sp+1Ch] [bp-C0h]@1
  __int16 v15; // [sp+20h] [bp-BCh]@1
  char v16; // [sp+22h] [bp-BAh]@1

  v4 = sub_10003CE0(a1, (int)sub_10030410);
  sub_100365D0(a1 + 84, a3, 180);
  LOBYTE(v5) = a2;
  v10 = v4;
  v9 = -32740;
  v11 = a2;
  v16 = a4;
  v14 = 4096;
  v15 = 296;
  if ( sub_10036FE0(v5) != 8 && sub_10036FE0(v6) != 2 && (sub_10037130(v7) & 3 || sub_10037080(v8) == 1) )
  {
    v12 = 5;
    v13 = 111;
  }
  else
  {
    v12 = 728;
    v13 = 343;
  }
  sub_10003E50(a1, (int)&v9, 204);
  sub_100352A0(a1, 0, (int (__cdecl *)(int))sub_10030410, 0);
}

//----- (10016490) --------------------------------------------------------
int __cdecl sub_10016490(int a1, int a2, _DWORD *a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // edi@1
  int v6; // ecx@1
  char v7; // bl@2
  char v8; // dl@2
  int v9; // edx@3
  int v10; // eax@10
  int v11; // ecx@10
  unsigned __int16 v12; // dx@10
  int v13; // edx@14
  _DWORD *v14; // edx@16
  unsigned int v15; // [sp+10h] [bp-8h]@1
  int v16; // [sp+14h] [bp-4h]@1
  int v17; // [sp+1Ch] [bp+4h]@1

  result = -1;
  v4 = 0;
  v5 = a1;
  v15 = 1;
  v17 = 0;
  v16 = 0;
  v6 = 255;
  while ( 2 )
  {
    v7 = *(_BYTE *)(v6 + v5 + 8);
    v8 = *(_BYTE *)(v6 + v5 + 8);
    switch ( *(_BYTE *)(v6 + v5 + 8) & 0xF0 )
    {
      case 0x80:
        v9 = v8 & 0xF;
        goto LABEL_18;
      case 0xF0:
        v17 += 16;
        goto LABEL_19;
      case 0xC0:
        if ( v15 < 2 )
          result = *(_DWORD *)(v5 + 4 * v15);
        --v15;
        goto LABEL_14;
      case 0x90:
      case 0xD0:
        if ( (v7 & 0xF0) == -48 )
          --v15;
        v10 = *(_BYTE *)(v6 + v5 + 7);
        v11 = v6 - 1;
        v16 = v8 & 0xF;
        LOBYTE(v12) = 0;
        HIBYTE(v12) = *(_BYTE *)(v11 + v5 + 7);
        v6 = v11 - 3;
        result = (*(_BYTE *)(v6 + v5 + 8) << 24) | (*(_BYTE *)(v6 + v5 + 9) << 16) | v12 | v10;
        goto LABEL_14;
      default:
        if ( v7 < 0 )
        {
          *a3 = v4;
          return result;
        }
        if ( v7 )
        {
          result = 4 * ((unsigned int)*(_BYTE *)(v6 + v5 + 8) >> 4);
          v16 = *(_BYTE *)(v6 + v5 + 8) & 0xF;
LABEL_14:
          v13 = v17;
          if ( v17 )
          {
            *(_DWORD *)(a2 + 4 * v4++) = result + 4 * v17;
            v13 = 0;
            if ( v4 == *a3 )
            {
              *a3 = v4;
              return result;
            }
          }
          *(_DWORD *)(a2 + 4 * v4) = result + 4 * v13;
          v14 = a3;
          if ( ++v4 == *a3 )
            goto LABEL_23;
          v9 = v16;
LABEL_18:
          v17 = v9;
LABEL_19:
          if ( --v6 < 0 )
          {
            result = (int)a3;
            *a3 = v4;
            return result;
          }
          continue;
        }
        v14 = a3;
LABEL_23:
        *v14 = v4;
        return result;
    }
  }
}

//----- (10016670) --------------------------------------------------------
char __cdecl sub_10016670(char a1)
{
  return sub_1001C450(a1, -122);
}

//----- (10016690) --------------------------------------------------------
char sub_10016690()
{
  sub_1001EE70();
  return sub_10016670(0);
}

//----- (100166A0) --------------------------------------------------------
int __cdecl sub_100166A0(int a1, char a2, void (__cdecl *a3)(int, char *, int), int a4)
{
  unsigned int v4; // eax@1
  char *v5; // eax@4
  unsigned int v6; // ST40_4@4
  int v7; // eax@4
  double v8; // ST48_8@4
  int v9; // ST44_4@4
  unsigned int v10; // ST3C_4@4
  int v11; // eax@4
  int result; // eax@4
  int v13; // eax@7
  int v14; // eax@8
  int v15; // eax@8
  int v16; // eax@10
  int v17; // eax@10
  int v18; // eax@10
  int v19; // eax@10
  int v20; // eax@10
  int v21; // eax@10
  int v22; // eax@11
  int v23; // esi@12
  int v24; // ebx@14
  int v25; // eax@19
  int v26; // [sp+2Ch] [bp-1A0h]@10
  float v27; // [sp+30h] [bp-19Ch]@4
  int v28; // [sp+34h] [bp-198h]@1
  unsigned int v29; // [sp+38h] [bp-194h]@1
  char v30[4]; // [sp+3Ch] [bp-190h]@10
  int v31; // [sp+40h] [bp-18Ch]@14
  int v32; // [sp+44h] [bp-188h]@14
  int v33; // [sp+48h] [bp-184h]@14
  int v34[60]; // [sp+4Ch] [bp-180h]@14
  char v35[4]; // [sp+13Ch] [bp-90h]@1
  int v36; // [sp+140h] [bp-8Ch]@1
  int v37; // [sp+144h] [bp-88h]@1
  int v38; // [sp+148h] [bp-84h]@1
  int v39; // [sp+14Ch] [bp-80h]@1
  char v40[4]; // [sp+150h] [bp-7Ch]@1
  int v41; // [sp+154h] [bp-78h]@1
  int v42; // [sp+158h] [bp-74h]@1
  int v43; // [sp+15Ch] [bp-70h]@1
  int v44; // [sp+160h] [bp-6Ch]@1
  char v45; // [sp+164h] [bp-68h]@1

  v29 = 0;
  memset(&v45, 0, 0x64u);
  *(_DWORD *)v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  *(_DWORD *)v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v4 = *(_DWORD *)(a1 + 16);
  v28 = 0;
  if ( v4 >= 0x40 )
    sprintf(v35, "%lu", v4);
  else
    sub_10069720((int)v35, 1, v4, 20);
  v5 = sub_1003CEB0(*(_DWORD *)a1);
  strncpy(v40, v5, 0x14u);
  v6 = *(_DWORD *)(a1 + 4);
  BYTE3(v44) = 0;
  sub_10038E00((int)&v29, v6);
  sub_10038FE0((int)&v28, *(_DWORD *)(a1 + 4));
  v7 = sub_10036790(
         &v45,
         0x64u,
         "%02u/%02u/%02u %02u:%02u:%02u PwrCnt:%-6lu %-20s %-15s\r\n",
         (unsigned __int8)v29,
         BYTE1(v29),
         HIWORD(v29) % 100,
         (signed __int16)v28,
         BYTE2(v28),
         BYTE3(v28),
         *(_DWORD *)(a1 + 8),
         v40,
         v35);
  a3(a4, &v45, v7);
  LODWORD(v27) = *(_WORD *)(a1 + 594);
  v8 = (double)SLODWORD(v27) / 100.0;
  v9 = *(_BYTE *)(a1 + 600);
  v10 = *(_DWORD *)(a1 + 12) / 0xE10u;
  v27 = (double)*(unsigned int *)(a1 + 596) / 1000.0;
  v11 = sub_10036790(
          &v45,
          0x64u,
          "    OnSecs:%-9.3f PwrHrs:%-5lu  SwVer:%s Rpt:%-3u Temp:%5.2fC\r\n",
          v27,
          v10,
          a1 + 585,
          v9,
          v8);
  a3(a4, &v45, v11);
  result = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == -5 || result == -44 )
  {
    v14 = sub_10036790(&v45, 0x64u, "    F:%-30s L:%-5ld\r\n", a1 + 464, *(_DWORD *)(a1 + 460));
    a3(a4, &v45, v14);
    v15 = sub_10036790(&v45, 0x64u, "    MSG:%-60s\r\n", a1 + 485);
    result = ((int (__cdecl *)(int, char *, int))a3)(a4, &v45, v15);
  }
  else if ( result == -45 )
  {
    v13 = sub_10036790(&v45, 0x64u, "    MSG:%-60s\r\n", a1 + 485);
    result = ((int (__cdecl *)(int, char *, int))a3)(a4, &v45, v13);
  }
  if ( a2 )
  {
    v16 = sub_10036790(
            &v45,
            0x64u,
            "    R0=0x%08lX  R5=0x%08lX R10= 0x%08lX PC=   0x%08lX\r\n",
            *(_DWORD *)(a1 + 20),
            *(_DWORD *)(a1 + 40),
            *(_DWORD *)(a1 + 60),
            *(_DWORD *)(a1 + 84));
    a3(a4, &v45, v16);
    v17 = sub_10036790(
            &v45,
            0x64u,
            "    R1=0x%08lX  R6=0x%08lX R11= 0x%08lX LR=   0x%08lX\r\n",
            *(_DWORD *)(a1 + 24),
            *(_DWORD *)(a1 + 44),
            *(_DWORD *)(a1 + 64),
            *(_DWORD *)(a1 + 76));
    a3(a4, &v45, v17);
    v18 = sub_10036790(
            &v45,
            0x64u,
            "    R2=0x%08lX  R7=0x%08lX R12= 0x%08lX FSR=  0x%08lX\r\n",
            *(_DWORD *)(a1 + 28),
            *(_DWORD *)(a1 + 48),
            *(_DWORD *)(a1 + 68),
            *(_DWORD *)(a1 + 88));
    a3(a4, &v45, v18);
    v19 = sub_10036790(
            &v45,
            0x64u,
            "    R3=0x%08lX  R8=0x%08lX CPSR=0x%08lX FADDR=0x%08lX\r\n",
            *(_DWORD *)(a1 + 32),
            *(_DWORD *)(a1 + 52),
            *(_DWORD *)(a1 + 80),
            *(_DWORD *)(a1 + 92));
    a3(a4, &v45, v19);
    v20 = sub_10036790(
            &v45,
            0x64u,
            "    R4=0x%08lX  R9=0x%08lX SP=  0x%08lX\r\n",
            *(_DWORD *)(a1 + 36),
            *(_DWORD *)(a1 + 56),
            *(_DWORD *)(a1 + 72));
    a3(a4, &v45, v20);
    v26 = 64;
    sub_10016490(a1 + 96, (int)v30, &v26);
    v21 = v26;
    if ( v26 > 0 )
    {
      v22 = sub_10036790(&v45, 0x64u, "CPU Trace:\r\n");
      a3(a4, &v45, v22);
      v21 = v26;
    }
    v23 = 0;
    if ( v21 > 0 )
    {
      do
      {
        if ( v21 - v23 < 5 )
        {
          v24 = sub_10036790(&v45, 0x64u, "    0x%08lX", *(_DWORD *)&v30[4 * v23]);
          if ( v23 == v26 - 1 )
          {
            sub_100367C0(&v45, "\r\n", 100);
            v24 += 2;
          }
          ++v23;
        }
        else
        {
          v24 = sub_10036790(
                  &v45,
                  0x64u,
                  "    0x%08lX    0x%08lX    0x%08lX    0x%08lX    0x%08lX\r\n",
                  *(_DWORD *)&v30[4 * v23],
                  *(&v31 + v23),
                  *(&v32 + v23),
                  *(&v33 + v23),
                  v34[v23]);
          v23 += 5;
        }
        a3(a4, &v45, v24);
        v21 = v26;
      }
      while ( v23 < v26 );
    }
    v25 = sub_10036790(&v45, 0x64u, "--------------------------------------------------------------------\r\n");
    result = ((int (__cdecl *)(_DWORD, _DWORD, _DWORD))a3)(a4, &v45, v25);
  }
  return result;
}
// 100166A0: using guessed type int var_180[60];

//----- (10016B60) --------------------------------------------------------
int __cdecl sub_10016B60(_DWORD *a1, unsigned int a2)
{
  int result; // eax@2

  if ( a2 > 0x63 )
  {
    sub_100364C0("..\\lib\\acl\\kernel\\hwm_fil.c", 779, 0, 0);
    result = -15;
  }
  else
  {
    result = sub_1006A0A0(a2 + 7000, (int)a1, 640);
    if ( !result )
    {
      if ( *a1 > 0 || *a1 <= -62 )
        result = -24;
      else
        result = 0;
    }
  }
  return result;
}

//----- (10016BC0) --------------------------------------------------------
int __cdecl sub_10016BC0(int a1, unsigned int a2)
{
  int result; // eax@2

  if ( a2 > 0x63 )
  {
    sub_100364C0("..\\lib\\acl\\kernel\\hwm_fil.c", 953, 0, 0);
    result = -15;
  }
  else
  {
    result = sub_1006A190(a2 + 7000, a1, 640);
  }
  return result;
}

//----- (10016C10) --------------------------------------------------------
int __cdecl sub_10016C10(unsigned int a1)
{
  int v2; // [sp+0h] [bp-284h]@1

  v2 = 62;
  return sub_10016BC0((int)&v2, a1);
}

//----- (10016C60) --------------------------------------------------------
int sub_10016C60()
{
  int v0; // edi@1
  signed int v1; // esi@1
  int v2; // eax@3
  char v4; // [sp+8h] [bp-68h]@4

  v0 = 0;
  v1 = 0;
  do
  {
    if ( v0 )
      break;
    v2 = sub_10016C10(v1++);
    v0 = v2;
  }
  while ( v1 < 100 );
  _snprintf(&v4, 0x64u, "Err log cleared with SW PN %s", "006-B0319-C1");
  sub_100364C0("..\\lib\\acl\\kernel\\hwm_fil.c", 622, 0, &v4);
  return v0;
}

//----- (10016CD0) --------------------------------------------------------
signed int __cdecl sub_10016CD0(_BYTE *a1)
{
  unsigned int v1; // kr00_4@1
  char *v2; // kr04_4@1
  int v3; // eax@1
  signed int result; // eax@2
  unsigned int v5; // ebx@3
  unsigned int v6; // eax@4
  unsigned int v7; // esi@4
  signed int v8; // edi@6
  char v9; // [sp+0h] [bp-304h]@7
  _BYTE v10[3]; // [sp+27Dh] [bp-87h]@4
  char v11[128]; // [sp+280h] [bp-84h]@1

  sub_100365D0((int)v11, a1, 128);
  sub_100367C0(v11, &word_10092290, 128);
  v1 = strlen(v11);
  v2 = &v11[strlen(v11)];
  v3 = sub_10037130((void *)(128 - v1));
  sub_10036AA0(v3, (int)v2, 128 - v1);
  if ( sub_100367C0(v11, "_err_rpt.dat", 128) >= 0 )
  {
    sub_1006B540(v11, 0x80u, 10000, 4);
    v5 = sub_1006B4B0((int)v11, (int)"/mnt/sys_nand0/err_rpt.dat");
    if ( !v5 )
    {
      *(_DWORD *)&v10[strlen(v11)] = 7633012;
      v6 = j_FIL_vfs_open(v11, 14, 0);
      v7 = v6;
      if ( v6 < 0xFFFFFFC2 && v6 )
      {
        v8 = 0;
        do
        {
          if ( !sub_10016B60(&v9, v8) )
            sub_100166A0((int)&v9, 1, (void (__cdecl *)(int, char *, int))&j_j_FIL_vfs_write, v7);
          ++v8;
        }
        while ( v8 < 100 );
      }
      else
      {
        v5 = v6;
      }
      sub_1006B210(v7);
      j_FIL_vfs_sync_all();
    }
    result = v5;
  }
  else
  {
    result = -27;
  }
  return result;
}
// 1006B2E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1006B450: using guessed type int j_FIL_vfs_sync_all(void);
// 10092290: using guessed type __int16 word_10092290;
// 10016CD0: using guessed type char var_84[128];

//----- (10016E90) --------------------------------------------------------
int __cdecl sub_10016E90(char a1, void *a2, size_t a3, int a4)
{
  int v4; // eax@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v4 = 21;
    }
    else
    {
      if ( a1 != 2 )
        goto LABEL_9;
      v4 = 23;
    }
  }
  else
  {
    v4 = 10;
  }
  if ( !sub_1006B970(v4, a4, a3, (int)a2) )
    return 0;
LABEL_9:
  memset(a2, 0, a3);
  return 1;
}

//----- (10016F00) --------------------------------------------------------
void __cdecl sub_10016F00(int a1)
{
  int v1; // eax@1
  int v2; // eax@5

  v1 = *(_DWORD *)(a1 + 56);
  if ( v1 && **(_WORD **)(a1 + 52) == -32703 && !*(_BYTE *)(v1 + 329) )
    sub_10018E40(a1, 0, 0, 0, 0);
  v2 = *(_DWORD *)(a1 + 56);
  if ( v2 && !*(_BYTE *)(a1 + 4) && (*(_BYTE *)(v2 + 330) || **(_WORD **)(a1 + 52) == -32665) )
  {
    *(_BYTE *)(v2 + 330) = 0;
    sub_10018A30(a1);
  }
}

//----- (10016F70) --------------------------------------------------------
char __cdecl sub_10016F70(int a1)
{
  int v1; // eax@1
  int v2; // ecx@3
  int v3; // ST08_4@4
  int v4; // ecx@17
  __int16 v6; // [sp+4h] [bp-Ch]@14
  int v7; // [sp+8h] [bp-8h]@14
  char v8; // [sp+Ch] [bp-4h]@12
  char v9; // [sp+Dh] [bp-3h]@14

  v1 = *(_DWORD *)(a1 + 52);
  if ( *(_WORD *)v1 == 32840 )
  {
    if ( *(_WORD *)(v1 + 10) & 0xC000 )
      *(_BYTE *)(a1 + 6) = 2;
    if ( dword_10756F54 == 2 )
    {
      *(_BYTE *)(a1 + 6) = 2;
    }
    else
    {
      switch ( *(_WORD *)(v1 + 10) )
      {
        case 0x21:
          v1 = *(_DWORD *)(a1 + 56);
          v8 = *(_BYTE *)(v1 + 230);
          if ( *(_BYTE *)(v1 + 230) != -1 )
          {
            *(_BYTE *)(a1 + 6) = sub_1002F6C0(a1, *(_BYTE *)(v1 + 230), 1);
            v1 = *(_DWORD *)(a1 + 56);
            if ( *(_BYTE *)(v1 + 236) )
            {
              v7 = *(_DWORD *)(a1 + 56);
              v6 = -32705;
              v9 = *(_BYTE *)(v1 + 230);
              LOBYTE(v1) = sub_10003E50(a1, (int)&v6, 12);
            }
          }
          break;
        case 0x38:
          if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) == -1 )
            LOBYTE(v1) = sub_100053F0(a1, *(_BYTE *)(v1 + 8));
          break;
        case 0x39:
          v4 = *(_DWORD *)(a1 + 56);
          if ( *(_BYTE *)(v4 + 230) == -1 )
          {
            LOBYTE(v1) = sub_100052E0(a1, *(_BYTE *)(v1 + 8));
          }
          else
          {
            v8 = *(_BYTE *)(v4 + 230);
            *(_BYTE *)(a1 + 6) = sub_1002F6C0(a1, *(_BYTE *)(v4 + 230), *(_BYTE *)(v1 + 8));
            v1 = *(_DWORD *)(a1 + 56);
            if ( *(_BYTE *)(v1 + 236) )
            {
              v7 = *(_DWORD *)(a1 + 56);
              v6 = -32705;
              v9 = *(_BYTE *)(v1 + 230);
              LOBYTE(v1) = sub_10003E50(a1, (int)&v6, 12);
            }
          }
          break;
        case 0x28:
          v1 = *(_DWORD *)(a1 + 56);
          v8 = *(_BYTE *)(v1 + 230);
          if ( *(_BYTE *)(v1 + 230) == -1 )
          {
            sub_1002F6C0(a1, *(_BYTE *)(v1 + 231), 0);
            v1 = *(_DWORD *)(a1 + 56);
            if ( *(_BYTE *)(v1 + 236) )
            {
              v7 = *(_DWORD *)(a1 + 56);
              v6 = -32705;
              v9 = *(_BYTE *)(v1 + 230);
              LOBYTE(v1) = sub_10003E50(a1, (int)&v6, 12);
            }
          }
          else if ( *(_WORD *)(v1 + 240) == -128 )
          {
            sub_1002F560(a1, *(_BYTE *)(v1 + 230));
            v1 = *(_DWORD *)(a1 + 56);
            if ( *(_BYTE *)(v1 + 236) )
            {
              v7 = *(_DWORD *)(a1 + 56);
              v6 = -32705;
              v9 = *(_BYTE *)(v1 + 230);
              LOBYTE(v1) = sub_10003E50(a1, (int)&v6, 12);
            }
          }
          else
          {
            *(_WORD *)(v1 + 240) = -128;
          }
          break;
        default:
          break;
      }
    }
    if ( *(_BYTE *)(a1 + 6) == 1 )
      *(_BYTE *)(a1 + 6) = 0;
  }
  else if ( *(_WORD *)v1 == 32841 )
  {
    v2 = *(_DWORD *)(a1 + 56);
    if ( *(_BYTE *)(v2 + 68) )
    {
      v3 = *(_DWORD *)(a1 + 52);
      *(_BYTE *)(a1 + 5) = 1;
      LOBYTE(v1) = sub_100375A0(a1, (char *)v2, v3);
      *(_BYTE *)(a1 + 6) = v1;
      if ( (_BYTE)v1 == 1 )
      {
        LOBYTE(v1) = sub_100375A0(a1, *(char **)(a1 + 56), (int)&unk_100B096C);
        *(_BYTE *)(a1 + 6) = v1;
      }
      *(_BYTE *)(a1 + 5) = 0;
    }
  }
  return v1;
}
// 10756F54: using guessed type int dword_10756F54;

//----- (10017210) --------------------------------------------------------
void __cdecl sub_10017210(int a1)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 52);
  if ( *(_WORD *)v1 == 32840 )
  {
    switch ( *(_WORD *)(v1 + 10) )
    {
      case 0xF:
      case 0x10:
      case 0x11:
      case 0x12:
      case 0x13:
      case 0x14:
      case 0x15:
      case 0x16:
      case 0x17:
      case 0x18:
      case 0x19:
      case 0x1A:
      case 0x46:
      case 0x47:
      case 0x48:
        sub_10019770(a1);
        break;
      default:
        return;
    }
  }
  else if ( *(_WORD *)v1 == 32879 )
  {
    sub_10018A30(a1);
  }
}

//----- (100172B0) --------------------------------------------------------
unsigned int __cdecl sub_100172B0(int a1)
{
  int v1; // esi@1
  unsigned int result; // eax@3
  float v3; // ST28_4@4
  float v4; // ST30_4@4
  float v5; // ST2C_4@4
  float v6; // [sp+24h] [bp+4h]@4

  v1 = a1;
  if ( **(_WORD **)(a1 + 52) == 32802 )
    goto LABEL_9;
  if ( **(_WORD **)(a1 + 52) == 32833 )
  {
    sub_10002870(a1, 0, 0, 1024, 768, 3);
    result = sub_10003F00(a1, *(_DWORD *)(a1 + 56), 1);
    *(_BYTE *)(a1 + 6) = 2;
    return result;
  }
  result = **(_WORD **)(a1 + 52) - 32888;
  if ( **(_WORD **)(a1 + 52) == 32888 )
  {
LABEL_9:
    sub_100029B0(a1, *(_DWORD *)(a1 + 56));
    v3 = (double)BYTE3(dword_10319588) / 255.0;
    v4 = (double)BYTE2(dword_10319588) / 255.0;
    v5 = (double)BYTE1(dword_10319588) / 255.0;
    v6 = (double)(unsigned __int8)dword_10319588 / 255.0;
    j_gdi_pvg_make_window_current(*(_DWORD *)(v1 + 24));
    sub_10069A80(v4, v5, v6, v3);
    result = j_gdi_pvg_clear(0x4000);
    *(_BYTE *)(v1 + 1) = 1;
    *(_BYTE *)(v1 + 6) = 2;
  }
  return result;
}
// 10069A70: using guessed type int __cdecl j_gdi_pvg_clear(_DWORD);
// 10069CB0: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 10319588: using guessed type int dword_10319588;

//----- (100173B0) --------------------------------------------------------
unsigned int __cdecl sub_100173B0(int a1)
{
  unsigned int result; // eax@3
  float v2; // ST1C_4@4

  if ( **(_WORD **)(a1 + 52) == 32802 )
    goto LABEL_9;
  if ( **(_WORD **)(a1 + 52) == 32833 )
  {
    sub_10002870(a1, 0, 0, 1024, 768, 3);
    result = sub_10003F00(a1, *(_DWORD *)(a1 + 56), 1);
    *(_BYTE *)(a1 + 6) = 2;
    return result;
  }
  result = **(_WORD **)(a1 + 52) - 32888;
  if ( **(_WORD **)(a1 + 52) == 32888 )
  {
LABEL_9:
    sub_100029B0(a1, *(_DWORD *)(a1 + 56));
    sub_1005FF20();
    j_gdi_pvg_bind_video_cap_as_textmap();
    j_gdi_pvg_enable(34);
    j_gdi_pvg_push_matrix();
    sub_10069AB0(1.0, 1.0, 1.0, 1.0);
    j_gdi_pvg_begin(72);
    sub_10069DB0(0.0, 0.0);
    sub_10069EF0(0.0, 0.0);
    sub_10069DB0(1.0, 0.0);
    sub_10069EF0(1024.0, 0.0);
    sub_10069DB0(1.0, 1.0);
    sub_10069EF0(1024.0, 768.0);
    sub_10069DB0(0.0, 1.0);
    sub_10069EF0(0.0, 768.0);
    j_gdi_pvg_end(LODWORD(v2));
    j_gdi_pvg_pop_matrix();
    result = j_gdi_pvg_disable(34);
    *(_BYTE *)(a1 + 1) = 1;
    *(_BYTE *)(a1 + 6) = 2;
  }
  return result;
}
// 100699C0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100699F0: using guessed type int j_gdi_pvg_bind_video_cap_as_textmap(void);
// 10069B40: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10069BC0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10069BE0: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 10069D20: using guessed type int j_gdi_pvg_pop_matrix(void);
// 10069D40: using guessed type int j_gdi_pvg_push_matrix(void);

//----- (100174F0) --------------------------------------------------------
char __cdecl sub_100174F0(int a1)
{
  int v1; // ecx@1
  __int16 v2; // dx@2
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v1 = *(_DWORD *)(a1 + 52);
  if ( *(_WORD *)v1 == -32696 )
  {
    LOWORD(v4) = 12;
    HIBYTE(v2) = *(_BYTE *)(v1 + 8);
    LOBYTE(v2) = *(_BYTE *)(v1 + 10);
    HIWORD(v4) = v2;
    v5 = sub_10069700();
    sub_10019BD0(0, 22530, &v4, 8);
  }
  return 0;
}
// 10019BD0: using guessed type _DWORD __cdecl sub_10019BD0(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10017550) --------------------------------------------------------
void __cdecl sub_10017550(int a1)
{
  dword_10319588 = 0;
  sub_10001240();
  sub_1002F540();
  sub_10005150(a1);
  sub_10034E70();
  byte_103D96C0 = 0;
}
// 10319588: using guessed type int dword_10319588;
// 103D96C0: using guessed type char byte_103D96C0;

//----- (10017580) --------------------------------------------------------
int __cdecl sub_10017580(int a1, int a2)
{
  int result; // eax@1
  double v3; // st7@2
  int v4; // ecx@2
  signed int v5; // edi@2
  double v6; // st6@2
  double v7; // st5@2
  double v8; // rt1@4
  double v9; // st5@4
  signed int v10; // edx@4
  char *v11; // eax@4
  double v12; // st4@4
  double v13; // st6@4
  float v14; // ST58_4@4
  double v15; // st4@4
  double v16; // st7@4
  float v17; // ST54_4@4
  double v18; // st4@4
  double v19; // st3@4
  double v20; // st3@5
  double v21; // rt2@5
  double v22; // st1@6
  double v23; // rt1@8
  int v24; // eax@8
  double v25; // st2@8
  double v26; // st1@8
  double v27; // st7@8
  double v28; // rt1@8
  double v29; // st1@8
  double v30; // st5@8
  double v31; // st6@8
  double v32; // st1@8
  double v33; // st4@8
  double v34; // rt0@8
  double v35; // st1@8
  double v36; // st7@8
  double v37; // rt1@8
  double v38; // st1@8
  double v39; // st3@8
  double v40; // rt2@8
  double v41; // st1@8
  double v42; // st6@8
  double v43; // st4@9
  double v44; // st1@9
  double v45; // st6@9
  double v46; // rtt@9
  double v47; // st3@9
  double v48; // st1@9
  double v49; // rt0@9
  unsigned int v50; // esi@20
  int v51; // [sp+1Ch] [bp-2Ch]@0
  float v52; // [sp+20h] [bp-28h]@4
  float v53; // [sp+24h] [bp-24h]@2
  float v54; // [sp+28h] [bp-20h]@2
  double v55; // [sp+2Ch] [bp-1Ch]@4
  double v56; // [sp+34h] [bp-14h]@4
  int v57; // [sp+3Ch] [bp-Ch]@1
  char v58; // [sp+40h] [bp-8h]@22
  float v59; // [sp+50h] [bp+8h]@4
  float v60; // [sp+50h] [bp+8h]@20

  j_HWM_pvg_read_keys(&v57);
  result = a2;
  if ( a2 )
  {
    if ( a2 == 2 )
    {
      result = j_gdi_pvg_destroy_window(dword_10141FFC);
    }
    else if ( a2 == 1 )
    {
      j_gdi_pvg_make_window_current(dword_10141FFC);
      j_gdi_pvg_matrix_mode(51);
      j_gdi_pvg_load_identity();
      sub_1006A470(512.0, 50.0, 1024.0, 768.0, 45.0, 0.1, 10000.0);
      j_gdi_pvg_matrix_mode(52);
      j_gdi_pvg_load_identity();
      sub_10069A80(1.0, 0.0, 0.0, 0.0);
      j_gdi_pvg_clear(16640);
      j_gdi_pvg_push_attrib(0x2000);
      j_gdi_pvg_enable(34);
      sub_10069E10(84, 82, 79.0);
      j_gdi_pvg_disable(35);
      j_gdi_pvg_enable(33);
      if ( v57 & 1 )
        j_gdi_pvg_disable(33);
      if ( v57 & 0x100 )
        j_gdi_pvg_enable(35);
      j_gdi_pvg_bind_texture(34, dword_103D9590);
      sub_10069EB0(0.0, -14.0, 0.0);
      sub_10069D50(70.0, -1.0, 0.0, 0.0);
      v60 = (double)(unsigned int)sub_10069700() * 0.001000000047497451 * 10.0;
      sub_10069D50(v60, 0.0, 0.0, 1.0);
      sub_10069D80(300.0, 300.0, 1.0);
      v50 = 0;
      do
      {
        j_gdi_pvg_push_matrix();
        sub_10069EB0(flt_100932EC[v50], flt_100932F0[v50], 0.0);
        sub_1006A5C0((int)&dword_103D9594);
        j_gdi_pvg_draw_arrays(69, 0, dword_10141FF8);
        sub_1006A6B0();
        j_gdi_pvg_pop_matrix();
        v50 += 2;
      }
      while ( v50 < 10 );
      j_gdi_pvg_pop_attrib();
      j_gdi_pvg_finish();
      j_gdi_pvg_make_window_current(a1);
      j_gdi_pvg_matrix_mode(51);
      j_gdi_pvg_load_identity();
      sub_10069CD0(0.0, 1024.0, 0.0, 768.0, 0.0, 1.0);
      j_gdi_pvg_matrix_mode(52);
      j_gdi_pvg_load_identity();
      if ( v58 & 0x10 )
        j_gdi_pvg_clear(16640);
      sub_10069AB0(1.0, 1.0, 1.0, 1.0);
      j_gdi_pvg_enable(35);
      j_gdi_pvg_blend_func(4, 5);
      sub_1006AAF0(6, (int)"GPU Memory Stress Test", 450.0, 20.0, 18.0);
      sub_1006AAF0(6, (int)"any red pixels mean failure", 480.0, 45.0, 15.0);
      j_gdi_pvg_disable(35);
      j_gdi_pvg_disable(34);
      j_gdi_pvg_begin(71);
      sub_10069AB0(0.0, 0.0, 0.0, 0.0);
      sub_10069EF0(0.0, 0.0);
      sub_10069EF0(30.0, 0.0);
      sub_10069EF0(30.0, 5.0);
      sub_10069EF0(0.0, 5.0);
      result = j_gdi_pvg_end(v51);
    }
  }
  else
  {
    sub_10069FD0();
    sub_1006A020(1);
    sub_1006A030(1);
    sub_1006A040(3929600);
    dword_10141FFC = sub_10069F90(1024, 768, 59);
    j_gdi_pvg_make_window_current(dword_10141FFC);
    v3 = 0.0;
    v54 = 0.0;
    v4 = 0;
    v53 = -1.0;
    v5 = 200;
    v6 = 0.03999999910593033;
    v7 = 0.009999999776482582;
    while ( 1 )
    {
      v8 = v7;
      v9 = v3;
      v52 = v3;
      v10 = 0;
      v11 = (char *)&unk_10142008 + 24 * v4;
      v59 = -1.0;
      v12 = v6 + v54;
      v13 = v54;
      v56 = v12;
      v14 = v12;
      v15 = v8 + v53;
      v16 = v53;
      v55 = v15;
      v17 = v15;
      v18 = v14;
      v19 = v17;
      while ( 1 )
      {
        v22 = v59;
        if ( !v10 )
        {
          *((_DWORD *)v11 + 3) = -15132391;
          *((float *)v11 + 4) = v52;
          ++v4;
          v11 += 24;
          *((float *)v11 - 1) = v13;
          *((float *)v11 - 6) = v59;
          *((float *)v11 - 5) = v16;
          *((float *)v11 - 4) = v9;
          v22 = v59;
        }
        *((_DWORD *)v11 + 3) = -15132391;
        v23 = v22;
        *((float *)v11 + 4) = v52;
        v24 = (int)(v11 + 24);
        *(float *)(v24 - 4) = v13;
        v4 += 2;
        v25 = v13;
        v11 = (char *)(v24 + 24);
        *((float *)v11 - 12) = v22;
        v26 = v16;
        v27 = v23;
        *((float *)v11 - 11) = v26;
        v28 = v26;
        v29 = v9;
        v30 = v28;
        *((float *)v11 - 10) = v29;
        *((_DWORD *)v11 - 3) = -15132391;
        v31 = v29;
        *((float *)v11 - 2) = v52;
        v32 = v18;
        v33 = v52;
        *((float *)v11 - 1) = v32;
        v34 = v32;
        v35 = v27;
        v36 = v34;
        *((float *)v11 - 6) = v35;
        v37 = v35;
        v38 = v19;
        v39 = v37;
        *((float *)v11 - 5) = v38;
        v40 = v38;
        v41 = v31;
        v42 = v40;
        *((float *)v11 - 4) = v41;
        if ( v10 == 199 )
        {
          *((_DWORD *)v11 + 3) = -15132391;
          v43 = v41;
          *((float *)v11 + 4) = v52;
          ++v4;
          v11 += 24;
          *((float *)v11 - 1) = v36;
          *((float *)v11 - 6) = v39;
          v44 = v42;
          v45 = v39;
          *((float *)v11 - 5) = v44;
          v46 = v44;
          *((float *)v11 - 4) = v43;
          v47 = v43;
          v33 = v52;
          v48 = v45;
          v42 = v46;
          v49 = v48;
          v41 = v47;
          v39 = v49;
        }
        ++v10;
        v59 = v39 + 0.009999999776482582;
        v52 = v33 + 0.03999999910593033;
        if ( v10 >= 200 )
          break;
        v20 = v36;
        v16 = v30;
        v21 = v20;
        v19 = v42;
        v13 = v25;
        v9 = v41;
        v18 = v21;
      }
      --v5;
      v6 = 0.03999999910593033;
      v53 = v55;
      v54 = v56;
      if ( !v5 )
        break;
      v7 = 0.009999999776482582;
      v3 = v41;
    }
    dword_10141FF8 = v4;
    dword_103D9594 = 0;
    dword_103D9598 = 0;
    dword_103D959C = 0;
    sub_1006A620(&dword_103D9594, 7, (int)&unk_10142008, (_DWORD *)0x1D7180, 0x1D7180u);
    j_gdi_pvg_gen_textures(1, &dword_103D9590);
    j_gdi_pvg_bind_texture(34, dword_103D9590);
    j_gdi_pvg_tex_parameteri(34, 95, 98);
    j_gdi_pvg_tex_parameteri(34, 96, 98);
    j_gdi_pvg_tex_parameteri(34, 93, 86);
    j_gdi_pvg_tex_parameteri(34, 94, 86);
    sub_1006B180("terrain.tga_crc");
    j_gdi_pvg_make_window_current(a1);
    sub_10069A80(0.0, 0.0, 0.0, 0.0);
    j_gdi_pvg_clear(16640);
    j_gdi_pvg_gen_textures(1, &dword_10142000);
    j_gdi_pvg_bind_texture(34, dword_10142000);
    j_gdi_pvg_tex_parameteri(34, 95, 97);
    j_gdi_pvg_tex_parameteri(34, 96, 97);
    j_gdi_pvg_tex_parameteri(34, 93, 86);
    result = j_gdi_pvg_tex_parameteri(34, 94, 86);
  }
  return result;
}
// 100699C0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100699E0: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 10069A50: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10069A70: using guessed type int __cdecl j_gdi_pvg_clear(_DWORD);
// 10069B40: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10069B60: using guessed type int __cdecl j_gdi_pvg_draw_arrays(_DWORD, _DWORD, _DWORD);
// 10069BC0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10069BE0: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 10069BF0: using guessed type int j_gdi_pvg_finish(void);
// 10069C60: using guessed type int __cdecl j_gdi_pvg_gen_textures(_DWORD, _DWORD);
// 10069CB0: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 10069CC0: using guessed type int __cdecl j_gdi_pvg_matrix_mode(_DWORD);
// 10069D10: using guessed type int j_gdi_pvg_pop_attrib(void);
// 10069D20: using guessed type int j_gdi_pvg_pop_matrix(void);
// 10069D30: using guessed type int __cdecl j_gdi_pvg_push_attrib(_DWORD);
// 10069D40: using guessed type int j_gdi_pvg_push_matrix(void);
// 10069E90: using guessed type int __cdecl j_gdi_pvg_tex_parameteri(_DWORD, _DWORD, _DWORD);
// 10069FC0: using guessed type int __cdecl j_gdi_pvg_destroy_window(_DWORD);
// 1006BBC0: using guessed type int __cdecl j_HWM_pvg_read_keys(_DWORD);
// 100932EC: using guessed type float flt_100932EC[];
// 100932F0: using guessed type float flt_100932F0[];
// 10141FF8: using guessed type int dword_10141FF8;
// 10141FFC: using guessed type int dword_10141FFC;
// 10142000: using guessed type int dword_10142000;
// 103D9590: using guessed type int dword_103D9590;
// 103D9594: using guessed type int dword_103D9594;
// 103D9598: using guessed type int dword_103D9598;
// 103D959C: using guessed type int dword_103D959C;

//----- (10017C00) --------------------------------------------------------
int __cdecl sub_10017C00(int a1)
{
  sub_10069AB0(1.0, 1.0, 1.0, 1.0);
  j_gdi_pvg_bind_texture(34, dword_1031958C);
  j_gdi_pvg_begin(72);
  sub_10069DB0(0.0, 0.0);
  sub_10069F10(-1.0, 0.89999998, 0.0);
  sub_10069DB0(1.0, 0.0);
  sub_10069F10(1.0, 0.89999998, 0.0);
  sub_10069DB0(1.0, 1.0);
  sub_10069F10(1.0, -1.1, 0.0);
  sub_10069DB0(0.0, 1.0);
  sub_10069F10(-1.0, -1.1, 0.0);
  return j_gdi_pvg_end(a1);
}
// 100699C0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100699E0: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 10069BE0: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 1031958C: using guessed type int dword_1031958C;

//----- (10017CF0) --------------------------------------------------------
#error "10017E34: call analysis failed (funcsize=99)"

//----- (10017E40) --------------------------------------------------------
int sub_10017E40()
{
  void *v0; // esi@1
  signed int v1; // edi@1
  int v2; // eax@2
  int v3; // eax@2
  int v4; // eax@2
  int v5; // eax@2
  int v6; // eax@2
  int v7; // eax@2
  int result; // eax@2

  v0 = &unk_103D95A8;
  v1 = 8;
  do
  {
    v2 = rand();
    *((float *)v0 - 2) = (double)v2 / 32767.0 + (double)v2 / 32767.0 - 1.0;
    v3 = rand();
    *((float *)v0 - 1) = (double)v3 / 32767.0 + (double)v3 / 32767.0 - 1.0;
    v4 = rand();
    *(float *)v0 = (double)v4 / 32767.0 + (double)v4 / 32767.0 - 1.0;
    v5 = rand();
    *((float *)v0 + 1) = (double)v5 / 32767.0 + (double)v5 / 32767.0 - 1.0;
    v6 = rand();
    *((float *)v0 + 2) = (double)v6 / 32767.0 + (double)v6 / 32767.0 - 1.0;
    v7 = rand();
    *((float *)v0 + 3) = (double)v7 / 32767.0 + (double)v7 / 32767.0 - 1.0;
    *((float *)v0 + 4) = (double)rand() / 32767.0 * 0.1000000238418579 + 1.0;
    *((float *)v0 + 5) = (double)rand() / 32767.0 * 5.0 + 7.0;
    result = rand();
    v0 = (char *)v0 + 36;
    --v1;
    *((float *)v0 - 3) = (double)result / 32767.0 * 360.0;
  }
  while ( v1 );
  return result;
}

//----- (10017F80) --------------------------------------------------------
int sub_10017F80()
{
  void *v0; // esi@1
  float v1; // ST28_4@4
  float v2; // ST28_4@4
  float v3; // ST10_4@4
  float v4; // ST28_4@6
  float v5; // ST28_4@10
  float v6; // ST0C_4@10
  float v8; // [sp+1Ch] [bp-2Ch]@2
  float v9; // [sp+1Ch] [bp-2Ch]@4
  signed int v10; // [sp+1Ch] [bp-2Ch]@6
  signed int v11; // [sp+20h] [bp-28h]@1
  int v12; // [sp+24h] [bp-24h]@4
  float v13; // [sp+28h] [bp-20h]@10
  float v14; // [sp+2Ch] [bp-1Ch]@10
  int v15; // [sp+30h] [bp-18h]@4
  float v16; // [sp+34h] [bp-14h]@10
  float v17; // [sp+38h] [bp-10h]@10
  int v18; // [sp+3Ch] [bp-Ch]@4

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  v0 = &unk_103D95AC;
  v11 = 8;
  do
  {
    v8 = sub_10022D70((int)v0);
    if ( v8 <= 0.001 )
      sub_100364C0(".\\cdp_test\\cdp_main_prj.c", 1298, 1, 0);
    v1 = 1.0 / v8;
    sub_10022DB0(v1, (int)v0, (int)&v12);
    v2 = sub_10022D40((int)&v12, (int)v0 - 12);
    v3 = -v2;
    sub_10022DB0(v3, (int)&v12, (int)&v18);
    sub_10022D10((int)v0 - 12, (int)&v18, (int)&v15);
    v9 = sub_10022D70((int)&v15);
    if ( v9 <= 0.001 )
      sub_100364C0(".\\cdp_test\\cdp_main_prj.c", 1313, 1, 0);
    v4 = *((float *)v0 + 3) / v9;
    sub_10022DB0(v4, (int)&v15, (int)&v15);
    v10 = 1;
    if ( sub_10022D40((int)&v12, (int)&v15) >= 0.001 )
      v10 = 0;
    if ( fabs((double)v10) == 0.0 )
      sub_100364C0(".\\cdp_test\\cdp_main_prj.c", 1320, 1, 0);
    v5 = (double)(unsigned int)sub_10069700() * 0.001000000047497451 * *((float *)v0 + 4);
    j_gdi_pvg_push_matrix();
    sub_10069D50(v5, *(float *)&v12, v13, v14);
    sub_10069EB0(*(float *)&v15, v16, v17);
    v6 = -v5;
    sub_10069D50(v6, *(float *)&v12, v13, v14);
    sub_10069D50(*((float *)v0 + 5), 0.0, 0.0, 1.0);
    sub_10017CF0();
    j_gdi_pvg_pop_matrix();
    v0 = (char *)v0 + 36;
    --v11;
  }
  while ( v11 );
  return j_gdi_pvg_disable(35);
}
// 10069A50: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10069B40: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10069BC0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10069D20: using guessed type int j_gdi_pvg_pop_matrix(void);
// 10069D40: using guessed type int j_gdi_pvg_push_matrix(void);

//----- (100181D0) --------------------------------------------------------
int __cdecl sub_100181D0(int a1)
{
  int result; // eax@1

  result = **(_WORD **)(a1 + 52);
  switch ( result )
  {
    case 32833:
      sub_10002870(a1, 0, 0, 1024, 768, 3);
      sub_10003F00(a1, *(_DWORD *)(a1 + 56), 1);
      result = sub_10017580(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 52), 0);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 32802:
    case 32888:
      sub_100029B0(a1, *(_DWORD *)(a1 + 56));
      result = sub_10017580(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 52), 1);
      *(_BYTE *)(a1 + 1) = 1;
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 32792:
      result = sub_10017580(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 52), 2);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    default:
      return result;
  }
  return result;
}

//----- (100182E0) --------------------------------------------------------
int sub_100182E0()
{
  int v0; // ST38_4@3

  if ( !byte_103D96C0 )
  {
    j_gdi_pvg_gen_textures(1, &dword_1031958C);
    j_gdi_pvg_bind_texture(34, dword_1031958C);
    j_gdi_pvg_tex_parameteri(34, 95, 97);
    j_gdi_pvg_tex_parameteri(34, 96, 97);
    j_gdi_pvg_tex_parameteri(34, 93, 86);
    j_gdi_pvg_tex_parameteri(34, 94, 90);
    sub_1006B180("garmin_earth.dds");
    j_gdi_pvg_gen_textures(1, &dword_10142004);
    j_gdi_pvg_bind_texture(34, dword_10142004);
    j_gdi_pvg_tex_parameteri(34, 95, 97);
    j_gdi_pvg_tex_parameteri(34, 96, 97);
    j_gdi_pvg_tex_parameteri(34, 93, 86);
    j_gdi_pvg_tex_parameteri(34, 94, 90);
    sub_1006B180("satellite.dds");
    sub_10017E40();
    byte_103D96C0 = 1;
  }
  j_gdi_pvg_matrix_mode(51);
  j_gdi_pvg_push_matrix();
  j_gdi_pvg_load_identity();
  sub_10069C10(-0.0128, 0.028159998, -0.018048, 0.012672, 0.020479999, 50.0);
  j_gdi_pvg_matrix_mode(52);
  j_gdi_pvg_push_matrix();
  j_gdi_pvg_load_identity();
  sub_10069A80(0.0, 0.0, 0.0, 0.0);
  j_gdi_pvg_clear(16640);
  j_gdi_pvg_enable(33);
  j_gdi_pvg_depth_func(20);
  j_gdi_pvg_enable(34);
  j_gdi_pvg_enable(32);
  sub_100699A0(23, 0.0);
  sub_10069EB0(0.0, 0.0, -2.0);
  sub_10017C00(v0);
  sub_10017F80();
  j_gdi_pvg_disable(34);
  j_gdi_pvg_disable(33);
  j_gdi_pvg_disable(32);
  j_gdi_pvg_matrix_mode(51);
  j_gdi_pvg_pop_matrix();
  j_gdi_pvg_matrix_mode(52);
  return j_gdi_pvg_pop_matrix();
}
// 100699E0: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 10069A70: using guessed type int __cdecl j_gdi_pvg_clear(_DWORD);
// 10069B30: using guessed type int __cdecl j_gdi_pvg_depth_func(_DWORD);
// 10069B40: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10069BC0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10069C60: using guessed type int __cdecl j_gdi_pvg_gen_textures(_DWORD, _DWORD);
// 10069CC0: using guessed type int __cdecl j_gdi_pvg_matrix_mode(_DWORD);
// 10069D20: using guessed type int j_gdi_pvg_pop_matrix(void);
// 10069D40: using guessed type int j_gdi_pvg_push_matrix(void);
// 10069E90: using guessed type int __cdecl j_gdi_pvg_tex_parameteri(_DWORD, _DWORD, _DWORD);
// 10142004: using guessed type int dword_10142004;
// 1031958C: using guessed type int dword_1031958C;
// 103D96C0: using guessed type char byte_103D96C0;

//----- (100184B0) --------------------------------------------------------
int __cdecl sub_100184B0(int a1)
{
  int result; // eax@3

  if ( **(_WORD **)(a1 + 52) == 32802 )
    goto LABEL_9;
  if ( **(_WORD **)(a1 + 52) == 32833 )
  {
    sub_10002870(a1, 0, 0, 1024, 768, 3);
    result = sub_10003F00(a1, *(_DWORD *)(a1 + 56), 1);
    *(_BYTE *)(a1 + 6) = 2;
    return result;
  }
  result = **(_WORD **)(a1 + 52) - 32888;
  if ( **(_WORD **)(a1 + 52) == 32888 )
  {
LABEL_9:
    sub_100029B0(a1, *(_DWORD *)(a1 + 56));
    result = sub_100182E0();
    *(_BYTE *)(a1 + 1) = 1;
    *(_BYTE *)(a1 + 6) = 2;
  }
  return result;
}

//----- (10018520) --------------------------------------------------------
int __usercall sub_10018520@<eax>(int a1@<ecx>, int a2@<ebx>, unsigned int a3)
{
  int result; // eax@3
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  sub_1001C1E0(a1, a2);
  sub_10019CE0(&v4, &v5);
  switch ( v4 )
  {
    case 4:
      if ( dword_10756F54 == 4 )
        goto LABEL_13;
      sub_100352A0(a3, -1, sub_100181D0, 0);
      sub_10019CB0();
      result = v4;
      dword_10756F54 = v4;
      break;
    case 3:
      if ( dword_10756F54 == 3 )
        goto LABEL_13;
      sub_100352A0(a3, -1, sub_100184B0, 0);
      sub_10019CB0();
      result = v4;
      dword_10756F54 = v4;
      break;
    case 1:
      dword_10319588 = v5;
      if ( dword_10756F54 == 1 )
        goto LABEL_13;
      sub_100352A0(a3, -1, (int (__cdecl *)(int))sub_100172B0, 0);
      sub_10019CB0();
      result = v4;
      dword_10756F54 = v4;
      break;
    case 5:
      if ( dword_10756F54 == 5 )
        goto LABEL_13;
      sub_100352A0(a3, -1, (int (__cdecl *)(int))sub_100173B0, 0);
      sub_10019CB0();
      result = v4;
      dword_10756F54 = v4;
      break;
    case 0:
    case 2:
      if ( v4 == dword_10756F54 )
        goto LABEL_13;
      sub_100352A0(a3, -1, (int (__cdecl *)(int))sub_10014950, 0);
      sub_10019CB0();
      result = v4;
      dword_10756F54 = v4;
      break;
    default:
      sub_100364C0(".\\cdp_test\\cdp_main_prj.c", 637, 1, 0);
LABEL_13:
      sub_10019CB0();
      result = v4;
      dword_10756F54 = v4;
      break;
  }
  return result;
}
// 10319588: using guessed type int dword_10319588;
// 10756F54: using guessed type int dword_10756F54;

//----- (100186A0) --------------------------------------------------------
char sub_100186A0()
{
  char result; // al@1

  result = 0;
  byte_10756F5C = 0;
  byte_10756F5D = 0;
  return result;
}
// 10756F5C: using guessed type char byte_10756F5C;
// 10756F5D: using guessed type char byte_10756F5D;

//----- (100186B0) --------------------------------------------------------
void __cdecl sub_100186B0(unsigned int a1)
{
  sub_100352A0(a1, -1, (int (__cdecl *)(int))sub_10014950, 0);
}

//----- (100186E0) --------------------------------------------------------
char __cdecl sub_100186E0(int a1, unsigned __int8 a2)
{
  return *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * a2 + 2);
}

//----- (10018700) --------------------------------------------------------
int __cdecl sub_10018700(int a1, unsigned __int8 a2, char a3)
{
  int result; // eax@1
  int v4; // ecx@2

  result = *(_DWORD *)(a1 + 56);
  if ( result == *(_DWORD *)(a1 + 48) )
  {
    v4 = *(_DWORD *)(result + 264);
    if ( v4 )
    {
      result = 10 * a2;
      if ( *(_BYTE *)(result + v4 + 4) != a3 )
      {
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + result + 4) = a3;
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 330) = 1;
      }
    }
  }
  return result;
}

//----- (10018750) --------------------------------------------------------
char __cdecl sub_10018750(int a1, unsigned __int8 a2, __int16 a3)
{
  int v3; // esi@1
  char result; // al@1
  int v5; // ecx@2

  v3 = *(_DWORD *)(a1 + 56);
  result = 0;
  if ( v3 == *(_DWORD *)(a1 + 48) )
  {
    v5 = 10 * a2;
    if ( *(_WORD *)(v5 + *(_DWORD *)(v3 + 264)) != a3 )
    {
      *(_WORD *)(v5 + *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264)) = a3;
      result = 1;
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 330) = 1;
    }
  }
  return result;
}

//----- (100187A0) --------------------------------------------------------
int __cdecl sub_100187A0(int a1, unsigned __int8 a2)
{
  int v2; // ebp@1
  int v3; // ecx@1
  int v4; // edi@1
  char v5; // bl@1
  char v6; // cl@1
  int result; // eax@1
  bool v8; // zf@1
  unsigned __int8 v9; // dl@4
  int v10; // esi@5
  int v11; // ecx@5
  char v12; // [sp+10h] [bp+4h]@1

  v2 = a1;
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264);
  v4 = 10 * a2;
  v5 = *(_BYTE *)(v3 + v4 + 7);
  v6 = *(_BYTE *)(v3 + v4 + 6);
  result = *(_DWORD *)(a1 + 56);
  v8 = result == *(_DWORD *)(a1 + 48);
  v12 = v6;
  if ( v8 )
  {
    if ( v6 == -1 )
    {
      result = *(_DWORD *)(result + 264) + v4 + 2;
      *(_BYTE *)result = *(_BYTE *)result == 0;
      *(_BYTE *)(*(_DWORD *)(v2 + 56) + 330) = 1;
    }
    else
    {
      v9 = 0;
      if ( *(_BYTE *)(result + 257) )
      {
        do
        {
          v10 = *(_DWORD *)(result + 264);
          v11 = v10 + 10 * v9;
          if ( *(_BYTE *)(v10 + 10 * v9 + 7) == v5 && *(_BYTE *)(v11 + 6) == v12 )
          {
            if ( v9 == a2 )
            {
              if ( !*(_BYTE *)(v10 + v4 + 2) )
                *(_BYTE *)(v11 + 2) = 1;
            }
            else
            {
              *(_BYTE *)(v11 + 2) = 0;
            }
          }
          result = *(_DWORD *)(v2 + 56);
          ++v9;
        }
        while ( v9 < *(_BYTE *)(result + 257) );
      }
      *(_BYTE *)(*(_DWORD *)(v2 + 56) + 330) = 1;
    }
  }
  return result;
}

//----- (10018870) --------------------------------------------------------
bool __usercall sub_10018870@<al>(int a1@<eax>, char a2)
{
  int v2; // ecx@2
  void *v3; // ecx@3
  void *v4; // ecx@5
  bool result; // al@7

  result = a2 == 11
        && (v2 = *(_DWORD *)(a1 + 56), !*(_BYTE *)(v2 + 245))
        && (sub_10036FE0((void *)v2) == 4 || sub_10036FE0(v3) == 1)
        && (sub_10037130(v3) & 3 || sub_10037080(v4) == 1);
  return result;
}

//----- (100188B0) --------------------------------------------------------
char __usercall sub_100188B0@<al>(int a1@<eax>, int a2@<esi>, char a3)
{
  int v3; // ebx@1
  int v4; // eax@3
  unsigned __int8 v5; // cl@3

  v3 = a3 + (unsigned __int8)a1;
  if ( v3 < 12 )
  {
    while ( v3 >= 0 )
    {
      v4 = *(_DWORD *)(a2 + 56);
      v5 = *(_BYTE *)(v4 + v3 + 316);
      if ( v5 != -1
        && !*(_BYTE *)(*(_DWORD *)(v4 + 264) + 10 * v5 + 4)
        && v3 < 12
        && (!*(_BYTE *)(v4 + 245) || v3 != 11)
        || (LOBYTE(a1) = sub_10018870(a2, v3), (_BYTE)a1) )
      {
        a1 = *(_DWORD *)(a2 + 56);
        *(_BYTE *)(a1 + 259) = v3;
        return a1;
      }
      v3 += a3;
      if ( v3 >= 12 )
        return a1;
    }
  }
  return a1;
}

//----- (10018920) --------------------------------------------------------
char __usercall sub_10018920@<al>(int a1@<eax>, int a2@<ecx>, char a3)
{
  _BYTE *v3; // edx@2
  signed int v4; // esi@2
  unsigned __int8 v5; // bl@4
  int v6; // edx@5

  if ( a2 == *(_DWORD *)(a1 + 48) )
  {
    v3 = (_BYTE *)(a2 + 316);
    a1 = a2 + 268;
    v4 = 12;
    do
    {
      *(_DWORD *)a1 = 0;
      *v3 = -1;
      a1 += 4;
      ++v3;
      --v4;
    }
    while ( v4 );
    v5 = 0;
    if ( *(_BYTE *)(a2 + 257) )
    {
      do
      {
        v6 = *(_DWORD *)(a2 + 264) + 10 * v5;
        LOBYTE(a1) = a3;
        if ( *(_BYTE *)(v6 + 7) == a3 )
        {
          a1 = (unsigned __int8)(*(_BYTE *)(v6 + 5) - 1);
          *(_DWORD *)(a2 + 4 * a1 + 268) = v6;
          *(_BYTE *)(a1 + a2 + 316) = v5;
        }
        ++v5;
      }
      while ( v5 < *(_BYTE *)(a2 + 257) );
    }
    *(_BYTE *)(a2 + 330) = 1;
  }
  return a1;
}

//----- (100189B0) --------------------------------------------------------
bool __usercall sub_100189B0@<al>(unsigned __int8 a1@<al>, int a2@<esi>)
{
  signed int v2; // ebx@1
  signed int v3; // edi@1
  int v4; // eax@4
  unsigned __int8 v5; // cl@4
  bool result; // al@9

  v2 = a1;
  v3 = 0;
  while ( 1 )
  {
    if ( v2 >= 12 )
      v2 = 0;
    v4 = *(_DWORD *)(a2 + 56);
    v5 = *(_BYTE *)(v4 + v2 + 316);
    if ( v5 != -1 && !*(_BYTE *)(*(_DWORD *)(v4 + 264) + 10 * v5 + 4) && v2 < 12 && (!*(_BYTE *)(v4 + 245) || v2 != 11) )
      break;
    result = sub_10018870(a2, v2);
    if ( result )
      break;
    ++v3;
    ++v2;
    if ( v3 > 12 )
    {
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 258) = 0;
      return result;
    }
  }
  *(_BYTE *)(*(_DWORD *)(a2 + 56) + 259) = v2;
  result = 1;
  *(_BYTE *)(*(_DWORD *)(a2 + 56) + 258) = 1;
  return result;
}

//----- (10018A30) --------------------------------------------------------
void __cdecl sub_10018A30(int a1)
{
  int v1; // ecx@1
  char *v2; // eax@2
  _DWORD **v3; // edx@2
  signed int v4; // edi@2
  _DWORD *v5; // ecx@4
  int v6; // eax@7
  int v7; // eax@9
  __int16 v8; // [sp+4h] [bp-88h]@2
  int v9; // [sp+8h] [bp-84h]@2
  char v10; // [sp+Ch] [bp-80h]@2
  char v11; // [sp+10h] [bp-7Ch]@2
  char v12; // [sp+88h] [bp-4h]@9
  char v13; // [sp+89h] [bp-3h]@9
  char v14; // [sp+8Ah] [bp-2h]@2

  v1 = *(_DWORD *)(a1 + 48);
  if ( v1 )
  {
    v9 = 0;
    v8 = -32657;
    v14 = *(_BYTE *)(v1 + 260);
    v10 = *(_BYTE *)(v1 + 328);
    v2 = &v11;
    v3 = (_DWORD **)(v1 + 268);
    v4 = 12;
    do
    {
      if ( *v3 )
      {
        v5 = *v3;
        *(_DWORD *)v2 = **v3;
        *((_DWORD *)v2 + 1) = v5[1];
        LOWORD(v5) = *((_WORD *)v5 + 4);
        *((_WORD *)v2 + 4) = (_WORD)v5;
      }
      else
      {
        v5 = 0;
        *(_DWORD *)v2 = 0;
        *((_DWORD *)v2 + 1) = 0;
        *((_WORD *)v2 + 4) = 0;
        *(_WORD *)v2 = -1;
      }
      ++v3;
      v2 += 10;
      --v4;
    }
    while ( v4 );
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 258) = sub_10037000((int)v5, (int)v3);
    v6 = *(_DWORD *)(a1 + 56);
    if ( *(_BYTE *)(v6 + 258) )
      sub_100189B0(*(_BYTE *)(v6 + 259), a1);
    v7 = *(_DWORD *)(a1 + 56);
    v12 = *(_BYTE *)(v7 + 258);
    v13 = *(_BYTE *)(v7 + 259);
    sub_10069800(11, (int)&v8, 1, 1);
  }
}

//----- (10018B20) --------------------------------------------------------
char __cdecl sub_10018B20(int a1, unsigned __int8 a2)
{
  char result; // al@1

  result = a1;
  if ( *(_DWORD *)(a1 + 56) == *(_DWORD *)(a1 + 48) )
  {
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * a2 + 7) = -1;
    result = sub_10018920(a1, *(_DWORD *)(a1 + 56), 0);
  }
  return result;
}

//----- (10018B50) --------------------------------------------------------
char __cdecl sub_10018B50(int a1, unsigned __int8 a2, char a3)
{
  char result; // al@1

  result = 0;
  if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * a2 + 2) != a3 )
  {
    sub_100187A0(a1, a2);
    result = 1;
  }
  return result;
}

//----- (10018B90) --------------------------------------------------------
int __usercall sub_10018B90@<eax>(int a1@<eax>, char a2@<bl>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-4h]@0

  sub_10018920(a1, *(_DWORD *)(a1 + 56), v4);
  result = a3;
  *(_BYTE *)(a3 + 260) = a2;
  return result;
}

//----- (10018BB0) --------------------------------------------------------
int __cdecl sub_10018BB0(int a1, char a2)
{
  return sub_10018B90(a1, a2, *(_DWORD *)(a1 + 56));
}

//----- (10018BD0) --------------------------------------------------------
int __cdecl sub_10018BD0(int a1)
{
  void *v1; // ecx@1
  int result; // eax@3
  int v3; // ebp@3
  int v4; // edi@11
  int v5; // ecx@15
  int v6; // ecx@17
  char v7; // [sp+1h] [bp-7h]@1
  char v8; // [sp+2h] [bp-6h]@9
  char v9; // [sp+3h] [bp-5h]@11
  char v10; // [sp+4h] [bp-4h]@7

  sub_1006BA40(9, &v7);
  if ( v7 == 8 )
    v7 = sub_10037080(v1) != 1 ? 6 : 0;
  result = *(_DWORD *)(a1 + 48);
  v3 = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 56) = result;
  if ( result )
  {
    if ( *(_BYTE *)(result + 328) )
    {
      result = sub_10069690();
      if ( result != 1 )
      {
        if ( v7 == 7 )
        {
          if ( sub_1003D540(0, &v10) )
          {
            sub_10018700(a1, 0x1Au, 0);
            sub_1006A0A0(10016, (int)&v8, 1);
            sub_10018B50(a1, 0x1Au, v8 != 0);
          }
          else
          {
            sub_10018700(a1, 0x1Au, 1);
          }
        }
        if ( sub_1003C1D0(16) )
        {
          v4 = sub_1003B860(&v7, 1u, (int)&unk_10095B10, 2, 3, 0);
          if ( sub_10038DD0(0xBCu, &v9) && v9 )
            sub_10018700(a1, byte_10095B11[2 * v4], 0);
          else
            sub_10018700(a1, byte_10095B11[2 * v4], 1);
        }
        sub_10018700(a1, 1u, 1);
        sub_10018700(a1, 2u, 1);
        sub_10018700(a1, 4u, 1);
        sub_10018700(a1, 9u, 1);
        sub_10018700(a1, 3u, 1);
        sub_10018700(a1, 8u, 1);
        if ( byte_103D96C1 )
        {
          v5 = *(_DWORD *)(a1 + 56);
          *(_BYTE *)(*(_DWORD *)(v5 + 264) + 247) = 0;
        }
        if ( sub_10036EF0((void *)v5) )
        {
          sub_10018700(a1, 1u, 0);
          sub_10018700(a1, 2u, 0);
          sub_10018700(a1, 4u, 0);
          sub_10018700(a1, 9u, 0);
          if ( byte_103D96C1 )
          {
            v6 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264);
            *(_BYTE *)(v6 + 247) = -1;
          }
        }
        if ( sub_10036F10((void *)v6) )
        {
          sub_10018700(a1, 1u, 0);
          sub_10018700(a1, 2u, 0);
          sub_10018700(a1, 3u, 0);
          sub_10018700(a1, 8u, 0);
          if ( byte_103D96C1 )
            *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 247) = -1;
        }
        if ( sub_1003D480(1u) )
        {
          sub_10018750(a1, 0x11u, 5253);
          sub_10018750(a1, 0x12u, 1910);
        }
        else
        {
          sub_10018750(a1, 0x11u, 4718);
          sub_10018750(a1, 0x12u, 7152);
        }
        result = sub_10018B90(a1, *(_BYTE *)(*(_DWORD *)(a1 + 56) + 260), *(_DWORD *)(a1 + 56));
      }
    }
  }
  *(_DWORD *)(a1 + 56) = v3;
  return result;
}
// 103D96C1: using guessed type char byte_103D96C1;

//----- (10018E40) --------------------------------------------------------
int __cdecl sub_10018E40(int a1, void *a2, unsigned __int8 a3, char a4, unsigned __int8 a5)
{
  void *v5; // ecx@3
  signed int v6; // ecx@10
  signed int v7; // edx@10
  signed int v8; // ecx@13
  signed int v9; // edx@13
  signed int v10; // ecx@16
  signed int v11; // edx@16
  signed int v12; // ecx@19
  signed int v13; // edx@19
  signed int v14; // ecx@22
  signed int v15; // edx@22
  signed int v16; // ecx@25
  signed int v17; // edx@25
  signed int v18; // ecx@30
  signed int v19; // edx@30
  signed int v20; // ecx@39
  signed int v21; // edx@39
  signed int v22; // ecx@42
  signed int v23; // edx@42
  int v24; // eax@45
  signed int v25; // ecx@45
  signed int v26; // edx@45
  signed int v27; // ecx@48
  signed int v28; // edx@48
  signed int v29; // ecx@52
  signed int v30; // edx@52
  signed int v31; // ecx@55
  signed int v32; // edx@55
  int v33; // eax@59
  signed int v34; // ecx@59
  signed int v35; // edx@59
  signed int v36; // ecx@62
  signed int v37; // edx@62
  signed int v38; // ecx@65
  signed int v39; // edx@65
  char v40; // al@84
  void *v41; // ecx@85
  void *v42; // ecx@90
  void *v43; // ecx@94
  void *v44; // ecx@97
  void *v45; // ecx@98
  void *v46; // ecx@99
  int result; // eax@108
  int v48; // [sp+0h] [bp-1560h]@0
  char v49; // [sp+Dh] [bp-1553h]@3
  char v50; // [sp+Eh] [bp-1552h]@1
  char v51; // [sp+Fh] [bp-1551h]@72
  void *v52; // [sp+10h] [bp-1550h]@84
  void *v53; // [sp+14h] [bp-154Ch]@1
  int v54; // [sp+18h] [bp-1548h]@1
  char v55; // [sp+1Ch] [bp-1544h]@27
  char v56; // [sp+ABCh] [bp-AA4h]@27
  char v57; // [sp+AF9h] [bp-A67h]@28

  v53 = a2;
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 257) = a3 + (a5 << 6);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 328) = a5;
  v50 = 0;
  v54 = a3;
  if ( 10 * (a3 + (unsigned __int8)(a5 << 6)) > 0 )
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) = sub_10004F90(a1, 10 * (a3 + (unsigned __int8)(a5 << 6)));
  sub_1006BA40(9, &v49);
  if ( sub_10037080(v5) == 1 )
  {
    switch ( v49 )
    {
      case 8:
        v49 = 0;
        break;
      case 0xD:
        v49 = 14;
        break;
      case 0x13:
      case 0x15:
      case 0x16:
        v49 = 2;
        break;
      default:
        break;
    }
  }
  if ( a5 << 6 )
  {
    memcpy_0(*(void **)(*(_DWORD *)(a1 + 56) + 264), &unk_100952A0, 0xF0u);
    switch ( v49 )
    {
      case 0:
      case 1:
      case 2:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_10095390, 0xBEu);
        v6 = 430;
        v7 = 21;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v6 + 7) = -1;
          v6 += 10;
          --v7;
        }
        while ( v7 );
        break;
      case 0xE:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_10095450, 0x28u);
        v8 = 280;
        v9 = 36;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v8 + 7) = -1;
          v8 += 10;
          --v9;
        }
        while ( v9 );
        break;
      case 3:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_10095478, 0xBEu);
        v10 = 430;
        v11 = 21;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v10 + 7) = -1;
          v10 += 10;
          --v11;
        }
        while ( v11 );
        break;
      case 4:
      case 5:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100956A0, 0x122u);
        v12 = 530;
        v13 = 11;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v12 + 7) = -1;
          v12 += 10;
          --v13;
        }
        while ( v13 );
        break;
      case 0xF:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100957C8, 0xA0u);
        v14 = 400;
        v15 = 24;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v14 + 7) = -1;
          v14 += 10;
          --v15;
        }
        while ( v15 );
        break;
      case 0xB:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_10095538, 0xB4u);
        v16 = 420;
        v17 = 22;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v16 + 7) = -1;
          v16 += 10;
          --v17;
        }
        while ( v17 );
        memset(&v55, 0, 0xAA0u);
        sub_1006A100(6767, &v56, 2720, &v55);
        if ( *(_BYTE *)(dword_10789F98 + 1716) && v57 != 47 )
        {
          sub_10018700(a1, 0x1Bu, 2);
          sub_10018700(a1, 0x1Cu, 2);
        }
        break;
      case 0x14:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100955F0, 0xAAu);
        v18 = 410;
        v19 = 23;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v18 + 7) = -1;
          v18 += 10;
          --v19;
        }
        while ( v19 );
        break;
      case 6:
      case 8:
      case 0xD:
      case 0x13:
      case 0x15:
      case 0x16:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_10095868, 0x1Eu);
        if ( v49 == 8 || v49 == 13 || v49 == 19 || v49 == 21 || v49 == 22 )
        {
          sub_10018750(a1, 0x18u, 2405);
          sub_10018750(a1, 0x19u, 2405);
        }
        v20 = 270;
        v21 = 37;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v20 + 7) = -1;
          v20 += 10;
          --v21;
        }
        while ( v21 );
        break;
      case 7:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_10095888, 0x28u);
        v22 = 280;
        v23 = 36;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v22 + 7) = -1;
          v22 += 10;
          --v23;
        }
        while ( v23 );
        break;
      case 9:
        v24 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240;
        *(_DWORD *)v24 = 886;
        *(_DWORD *)(v24 + 4) = 16711938;
        *(_WORD *)(v24 + 8) = 255;
        v25 = 250;
        v26 = 39;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v25 + 7) = -1;
          v25 += 10;
          --v26;
        }
        while ( v26 );
        break;
      case 0xA:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100958C0, 0x104u);
        v27 = 500;
        v28 = 14;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v27 + 7) = -1;
          v27 += 10;
          --v28;
        }
        while ( v28 );
        if ( sub_10037080((void *)v27) == 1 )
        {
          sub_10018700(a1, 0x1Cu, 2);
          sub_10018700(a1, 0x1Du, 2);
          sub_10018700(a1, 0x1Eu, 2);
          sub_10018700(a1, 0x1Fu, 2);
          sub_10018700(a1, 0x20u, 2);
          sub_10018700(a1, 0x21u, 2);
        }
        break;
      case 0x11:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_100959C4, 0x3Cu);
        v29 = 300;
        v30 = 34;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v29 + 7) = -1;
          v29 += 10;
          --v30;
        }
        while ( v30 );
        break;
      case 0xC:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_10095A00, 0x64u);
        v31 = 340;
        v32 = 30;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v31 + 7) = -1;
          v31 += 10;
          --v32;
        }
        while ( v32 );
        if ( sub_10037080((void *)v31) == 1 )
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 248) = 3;
        break;
      case 0x10:
        v33 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240;
        *(_DWORD *)v33 = 6274;
        *(_DWORD *)(v33 + 4) = 16711938;
        *(_WORD *)(v33 + 8) = 255;
        v34 = 250;
        v35 = 39;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v34 + 7) = -1;
          v34 += 10;
          --v35;
        }
        while ( v35 );
        break;
      case 0x12:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_10095A70, 0xA0u);
        v36 = 400;
        v37 = 24;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v36 + 7) = -1;
          v36 += 10;
          --v37;
        }
        while ( v37 );
        break;
      default:
        v38 = 240;
        v39 = 40;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v38 + 7) = -1;
          v38 += 10;
          --v39;
        }
        while ( v39 );
        break;
    }
  }
  if ( a3 )
    memcpy_0((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 640 * a5), v53, 10 * v54);
  if ( a5 )
  {
    nullsub_1(a1, v48);
    if ( v49 == 1 )
    {
      sub_10018750(a1, 0x1Au, 6274);
      sub_10018750(a1, 0x20u, 6274);
      sub_10018750(a1, 0x25u, 6274);
      sub_10018750(a1, 0x1Bu, 2801);
      sub_10018750(a1, 0x21u, 2801);
      sub_10018750(a1, 0x26u, 2801);
    }
    sub_1006BA40(133, &v51);
    if ( sub_1003C1D0(16) != 1 || v51 != 1 )
    {
      if ( v49 == 6 || v49 == 8 || v49 == 13 || v49 == 19 || v49 == 21 || v49 == 22 )
      {
        sub_10018700(a1, 0x1Au, 2);
      }
      else if ( v49 == 7 )
      {
        sub_10018700(a1, 0x1Bu, 2);
      }
      else
      {
        sub_10018700(a1, 0x17u, 2);
      }
    }
    sub_1006BA40(39, &v52);
    v40 = (char)v52;
    if ( !((unsigned __int8)v52 & 4) )
      goto LABEL_96;
    v41 = v52;
    LOBYTE(v41) = (unsigned __int8)v52 & 3;
    if ( ((unsigned __int8)v52 & 3) == 1 )
    {
      if ( sub_10037080(v41) != 1 && sub_10037130(v41) & 3 )
        goto LABEL_96;
      v40 = (char)v52;
    }
    if ( v40 & 3 )
      goto LABEL_93;
    if ( sub_10037080(v41) == 1 || sub_10037130(v42) & 3 )
    {
      v40 = (char)v52;
LABEL_93:
      if ( v40 < 0 )
      {
        sub_10018B20(a1, 3u);
        sub_10018B20(a1, 4u);
        v50 = 1;
      }
      else
      {
        sub_10018B20(a1, 1u);
        sub_10018B20(a1, 2u);
        sub_10018B20(a1, 0x18u);
      }
      goto LABEL_97;
    }
LABEL_96:
    sub_10018B20(a1, 1u);
    sub_10018B20(a1, 2u);
    sub_10018B20(a1, 3u);
    sub_10018B20(a1, 4u);
LABEL_97:
    if ( !sub_1003D5E0(v43) || sub_10037130(v44) & 3 || sub_10036FE0(v45) & 2 || sub_10037080(v46) == 1 )
    {
      sub_10018B20(a1, 6u);
      if ( v49 == 10 )
        sub_10018B20(a1, 0x1Au);
    }
    else if ( v50 )
    {
      if ( (unsigned __int16)v52 & 0x200 )
        sub_10018B20(a1, 0x18u);
      else
        byte_103D96C1 = 1;
    }
    sub_10018BD0(a1);
  }
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 259) = 0;
  result = sub_10018BB0(a1, a4);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 329) = 1;
  return result;
}
// 103D96C1: using guessed type char byte_103D96C1;
// 10789F98: using guessed type int dword_10789F98;

//----- (10019770) --------------------------------------------------------
char __cdecl sub_10019770(int a1)
{
  int v1; // esi@1
  int v2; // eax@4
  int v3; // eax@12
  __int16 v4; // cx@12
  unsigned __int16 v5; // bx@13
  char v6; // cl@16
  int v7; // edi@17
  char v8; // al@18
  int v9; // eax@22
  __int16 v11; // [sp+4h] [bp-10h]@22
  int v12; // [sp+8h] [bp-Ch]@22
  char v13; // [sp+Ch] [bp-8h]@22
  char v14; // [sp+Dh] [bp-7h]@22
  char v15; // [sp+Eh] [bp-6h]@22
  char v16; // [sp+Fh] [bp-5h]@22
  char v17; // [sp+10h] [bp-4h]@22
  unsigned __int8 v18; // [sp+18h] [bp+4h]@16

  v1 = a1;
  if ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) == 70 )
  {
    v2 = *(_DWORD *)(a1 + 56);
    if ( *(_BYTE *)(v2 + 258) )
    {
      if ( sub_10018870(a1, *(_BYTE *)(v2 + 259)) )
      {
        *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) = 26;
        LOBYTE(v2) = sub_10069800(11, *(_DWORD *)(a1 + 52), 1, 1);
        return v2;
      }
      goto LABEL_12;
    }
LABEL_8:
    *(_BYTE *)(a1 + 6) = 2;
    return v2;
  }
  if ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) == 71 )
  {
    v2 = *(_DWORD *)(a1 + 56);
    if ( !*(_BYTE *)(v2 + 258) )
      return v2;
    LOBYTE(v2) = *(_BYTE *)(v2 + 259);
    LOBYTE(v2) = sub_100188B0(v2, a1, -1);
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 330) = 1;
    goto LABEL_8;
  }
  if ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) == 72 )
  {
    v2 = *(_DWORD *)(a1 + 56);
    if ( *(_BYTE *)(v2 + 258) )
    {
      LOBYTE(v2) = *(_BYTE *)(v2 + 259);
      LOBYTE(v2) = sub_100188B0(v2, a1, 1);
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 330) = 1;
      *(_BYTE *)(a1 + 6) = 2;
    }
    return v2;
  }
LABEL_12:
  v3 = *(_DWORD *)(a1 + 52);
  v4 = *(_WORD *)(v3 + 10);
  if ( v4 == 70 )
  {
    v5 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 259);
    *(_WORD *)(v3 + 10) = v5 + 15;
  }
  else
  {
    v5 = v4 - 15;
  }
  v2 = *(_DWORD *)(a1 + 56);
  if ( *(_BYTE *)(v2 + 257) )
  {
    v6 = *(_BYTE *)(v5 + v2 + 316);
    v18 = *(_BYTE *)(v5 + v2 + 316);
    if ( v6 != -1 )
    {
      v7 = 10 * (unsigned __int8)v6;
      v2 = v7 + *(_DWORD *)(v2 + 264);
      if ( !*(_BYTE *)(v2 + 4) )
      {
        v8 = *(_BYTE *)(v2 + 8);
        if ( v8 != -1 )
        {
          sub_10018BB0(v1, v8);
          v6 = v18;
        }
        if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v1 + 56) + 264) + v7 + 3) == 1 )
        {
          sub_100187A0(v1, v18);
          v6 = v18;
        }
        v9 = *(_DWORD *)(v1 + 56);
        v13 = v6;
        v12 = 0;
        v11 = -32658;
        v14 = v5 + 1;
        v16 = *(_BYTE *)(v7 + *(_DWORD *)(v9 + 264) + 6);
        v17 = *(_BYTE *)(v7 + *(_DWORD *)(v9 + 264) + 7);
        v15 = *(_BYTE *)(v7 + *(_DWORD *)(v9 + 264) + 2);
        LOBYTE(v2) = sub_10003E50(v1, (int)&v11, 16);
      }
    }
  }
  return v2;
}

//----- (10019950) --------------------------------------------------------
__int16 __cdecl sub_10019950(char a1)
{
  int v1; // eax@1
  __int16 result; // ax@2

  v1 = sub_1003B860(&a1, 2u, (int)&unk_100960E0, 4, 794, 793);
  if ( v1 == 793 )
    result = -1;
  else
    result = word_100960E2[2 * v1];
  return result;
}
// 100960E2: using guessed type __int16 word_100960E2[];

//----- (10019990) --------------------------------------------------------
int *sub_10019990()
{
  int *result; // eax@1

  result = dword_104D9AD8;
  do
  {
    *((_BYTE *)result - 4) = 2;
    *result = 0;
    result[1] = 1036;
    result[2] = (int)(result - 260);
    result += 522;
  }
  while ( (signed int)result < (signed int)&unk_104DAB28 );
  return result;
}
// 104D9AD8: using guessed type int dword_104D9AD8[];

//----- (100199D0) --------------------------------------------------------
char __cdecl sub_100199D0(char a1, int a2, _DWORD *a3)
{
  unsigned __int16 v3; // ax@2
  unsigned __int16 v4; // di@13

  *a3 = 0;
  if ( !*(_BYTE *)a2 )
  {
    LOBYTE(v3) = a1;
    if ( a1 == 16 )
    {
      *(_BYTE *)a2 = 1;
      goto LABEL_12;
    }
    *(_BYTE *)(*(_DWORD *)(a2 + 12) + *(_DWORD *)(a2 + 4)) = a1;
LABEL_11:
    ++*(_DWORD *)(a2 + 4);
LABEL_12:
    if ( *a3 != 2 )
      return v3;
    goto LABEL_13;
  }
  LOBYTE(v3) = *(_BYTE *)a2 - 1;
  if ( *(_BYTE *)a2 != 1 )
  {
    if ( a1 != 16 )
      return v3;
    *(_BYTE *)a2 = 1;
    goto LABEL_12;
  }
  LOBYTE(v3) = a1;
  if ( a1 != 3 )
  {
    *(_BYTE *)(*(_DWORD *)(a2 + 12) + *(_DWORD *)(a2 + 4)) = a1;
    *(_BYTE *)a2 = 0;
    goto LABEL_11;
  }
  *a3 = 2;
LABEL_13:
  v4 = *(_BYTE *)(*(_DWORD *)(a2 + 12) + 2) + (*(_BYTE *)(*(_DWORD *)(a2 + 12) + 3) << 8);
  v3 = sub_10022DE0(*(_BYTE **)(a2 + 12), *(_DWORD *)(a2 + 4), 0xFFFFu, 2);
  if ( v3 || *(_DWORD *)(a2 + 4) != v4 + 6 )
    *a3 = 3;
  return v3;
}

//----- (10019A80) --------------------------------------------------------
int __usercall sub_10019A80@<eax>(_BYTE *a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>)
{
  _BYTE *v3; // esi@1
  int i; // edi@1

  v3 = a1;
  for ( i = (unsigned __int16)a2; (_WORD)a2; ++v3 )
  {
    if ( *v3 == 16 )
    {
      *a3++ = 16;
      ++i;
    }
    *a3 = *v3;
    a2 += 0xFFFF;
    ++a3;
  }
  return i;
}

//----- (10019AC0) --------------------------------------------------------
signed int __cdecl sub_10019AC0(int a1, int a2, _BYTE *a3, int a4)
{
  unsigned __int16 v4; // ax@1
  int v5; // ebx@1
  __int16 v6; // ax@1
  int v7; // esi@1
  int v8; // eax@1
  int v9; // edi@1
  unsigned __int16 v10; // ax@1
  unsigned __int16 v11; // ax@1
  int v12; // edi@1

  v4 = __ROL2__(a2, 8);
  a2 = v4;
  sub_100697D0(94, 60000);
  v5 = a1;
  v6 = a2;
  v7 = 2088 * (unsigned __int8)a1;
  byte_104D9AE4[v7] = 16;
  byte_104D9AE5[v7] = v6;
  byte_104D9AE6[v7] = HIBYTE(v6);
  v8 = sub_10019A80(&a4, 2, &byte_104D9AE7[v7]);
  v9 = sub_10019A80(a3, a4, &byte_104D9AE4[v7 + 3] + v8) + v8 + 3;
  v10 = sub_10022DE0(&a2, 2, 0xFFFFu, 2);
  v11 = sub_10022DE0(&a4, 2, v10, 2);
  a1 = sub_10022DE0(a3, (unsigned __int16)a4, v11, 2);
  v12 = sub_10019A80(&a1, 2, &byte_104D9AE4[v7] + v9) + v9;
  *(&byte_104D9AE4[v7] + v12++) = 16;
  *(&byte_104D9AE4[v7] + v12) = 3;
  j_HWM_pvg_put_uart(v5, &byte_104D9AE4[v7], v12 + 1);
  sub_100697B0(94);
  return 1;
}
// 1006BBB0: using guessed type int __cdecl j_HWM_pvg_put_uart(_DWORD, _DWORD, _DWORD);

//----- (10019BE0) --------------------------------------------------------
bool __cdecl sub_10019BE0(int a1, char *a2)
{
  unsigned int v2; // ebp@2
  int v3; // ebx@3
  bool result; // al@5
  unsigned __int16 v5; // dx@6
  int v6; // [sp+Ch] [bp-Ch]@1
  int v7; // [sp+10h] [bp-8h]@3
  int v8; // [sp+14h] [bp-4h]@6

  if ( j_HWM_pvg_get_uart(a1, &v6, 1) )
  {
    v2 = 2088 * (unsigned __int8)a1;
    while ( 1 )
    {
      sub_100199D0(v6, (int)&byte_104D9AD4[v2], &v7);
      v3 = v7;
      if ( v7 )
        break;
      if ( !j_HWM_pvg_get_uart(a1, &v6, 1) )
        goto LABEL_5;
    }
    HIBYTE(v5) = byte_104D96C9[v2];
    LOBYTE(v5) = *((_BYTE *)&unk_104D96C8 + v2);
    qmemcpy(a2, (char *)&unk_104D96C8 + v2, 0x40Cu);
    v8 = v5;
    if ( v3 == 3 )
      sub_10019BD0(a1, 5376, &v8, 2);
    byte_104D9AD4[v2] = 2;
    dword_104D9AD8[v2 / 4] = 0;
    result = v3 == 2;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}
// 10019BD0: using guessed type _DWORD __cdecl sub_10019BD0(_DWORD, _DWORD, _DWORD, _DWORD);
// 1006BB40: using guessed type int __cdecl j_HWM_pvg_get_uart(_DWORD, _DWORD, _DWORD);
// 104D9AD8: using guessed type int dword_104D9AD8[];

//----- (10019CB0) --------------------------------------------------------
int sub_10019CB0()
{
  int result; // eax@1

  result = (unsigned __int8)byte_104DA742;
  if ( byte_104DA742 )
  {
    result = (unsigned __int8)byte_104DA742 - 2;
    if ( byte_104DA742 != 2 )
      byte_104DA742 = 1;
  }
  else if ( !dword_104DA718 )
  {
    byte_104DA742 = 1;
  }
  return result;
}
// 104DA718: using guessed type int dword_104DA718;
// 104DA742: using guessed type char byte_104DA742;

//----- (10019CE0) --------------------------------------------------------
int __cdecl sub_10019CE0(_DWORD *a1, _DWORD *a2)
{
  int result; // eax@1

  *a1 = dword_104DAB54;
  result = dword_104DA71C;
  *a2 = dword_104DA71C;
  return result;
}
// 104DA71C: using guessed type int dword_104DA71C;
// 104DAB54: using guessed type int dword_104DAB54;

//----- (10019D00) --------------------------------------------------------
int sub_10019D00()
{
  int result; // eax@1

  byte_104DA741 = 8;
  dword_104DAB54 = 0;
  dword_104DA71C = 0;
  result = j_HWM_pvg_set_uart(0, 8, 4, 23);
  word_10756F50 = -1;
  byte_104DA743 = 0;
  return result;
}
// 1006BC10: using guessed type int __cdecl j_HWM_pvg_set_uart(_DWORD, _DWORD, _DWORD, _DWORD);
// 104DA71C: using guessed type int dword_104DA71C;
// 104DA741: using guessed type char byte_104DA741;
// 104DA743: using guessed type char byte_104DA743;
// 104DAB54: using guessed type int dword_104DAB54;
// 10756F50: using guessed type __int16 word_10756F50;

//----- (10019D40) --------------------------------------------------------
__int16 __usercall sub_10019D40@<ax>(int a1@<ebx>, int a2@<edi>, __int16 a3)
{
  int v3; // ebp@1
  __int16 v4; // si@1
  __int16 v5; // dx@1
  float v6; // ST08_4@1
  double v7; // st7@1
  double v8; // st7@3
  __int16 v9; // ax@5
  __int16 result; // ax@13
  float v11; // [sp+Ch] [bp-Ch]@3
  __int16 v12; // [sp+10h] [bp-8h]@1
  float v13; // [sp+1Ch] [bp+4h]@1
  float v14; // [sp+1Ch] [bp+4h]@3
  float v15; // [sp+1Ch] [bp+4h]@5

  a2 = (signed __int16)a2;
  a1 = (signed __int16)a1;
  v3 = a3;
  v4 = abs(a2 - a1);
  v5 = abs(a1 - a3);
  v12 = abs(a2 - a3);
  v6 = (double)v4;
  v13 = (double)v12;
  v7 = v6;
  if ( v13 <= (double)v6 )
    v7 = v13;
  v14 = v7;
  v11 = (double)v5;
  v8 = v14;
  if ( v11 <= (double)v14 )
    v8 = v11;
  v15 = v8;
  v9 = (signed int)v15;
  if ( (v4 == v12) == v5 || v4 == v12 && v4 == v9 || v4 == v5 && v4 == v9 || v12 == v5 && v12 == v9 )
  {
    result = (signed __int16)(a2 + a1 + v3) / 3;
  }
  else if ( v9 == v4 )
  {
    result = (a1 + a2) / 2;
  }
  else if ( v9 == v12 )
  {
    result = (a2 + v3) / 2;
  }
  else if ( v9 == v5 )
  {
    result = (a1 + v3) / 2;
  }
  else
  {
    result = LOWORD(v15);
  }
  return result;
}

//----- (10019E90) --------------------------------------------------------
int __fastcall sub_10019E90(__int16 a1, __int16 *a2)
{
  __int16 v2; // di@1
  __int16 *v3; // esi@1
  __int16 v4; // ax@2
  int v5; // ecx@2
  int v6; // eax@3
  char v7; // cl@4
  int result; // eax@8
  signed int v9; // ebx@10
  __int16 v10; // [sp+8h] [bp-198h]@5
  char v11; // [sp+Fh] [bp-191h]@3
  char v12[4]; // [sp+10h] [bp-190h]@6
  int v13; // [sp+14h] [bp-18Ch]@7
  char v14; // [sp+18h] [bp-188h]@3
  char v15; // [sp+1Ch] [bp-184h]@5
  char v16; // [sp+20h] [bp-180h]@5
  char v17; // [sp+24h] [bp-17Ch]@5
  char v18; // [sp+28h] [bp-178h]@5
  int v19; // [sp+2Ch] [bp-174h]@7
  __int16 v20; // [sp+30h] [bp-170h]@2
  char v21; // [sp+32h] [bp-16Eh]@3
  char v22; // [sp+33h] [bp-16Dh]@5
  char v23[33]; // [sp+3Bh] [bp-165h]@4
  int v24; // [sp+5Ch] [bp-144h]@9
  int v25; // [sp+60h] [bp-140h]@10
  int v26; // [sp+64h] [bp-13Ch]@10
  int v27; // [sp+68h] [bp-138h]@10
  int v28; // [sp+6Ch] [bp-134h]@10
  int v29; // [sp+70h] [bp-130h]@10
  char v30; // [sp+80h] [bp-120h]@10
  char v31; // [sp+9Ch] [bp-104h]@10
  char v32[4]; // [sp+D0h] [bp-D0h]@10
  int v33; // [sp+D4h] [bp-CCh]@10
  int v34; // [sp+D8h] [bp-C8h]@10
  int v35; // [sp+DCh] [bp-C4h]@10
  int v36; // [sp+E0h] [bp-C0h]@10
  int v37; // [sp+E4h] [bp-BCh]@10
  char v38; // [sp+F4h] [bp-ACh]@10
  char v39; // [sp+110h] [bp-90h]@10
  int v40; // [sp+14Ch] [bp-54h]@7
  char v41[20]; // [sp+154h] [bp-4Ch]@3
  int v42; // [sp+168h] [bp-38h]@7
  int v43; // [sp+17Ch] [bp-24h]@7

  v2 = a1;
  v3 = a2;
  if ( a1 == 258 )
  {
    memset(&v20, 0, 0x2Cu);
    v4 = *v3;
    v5 = (unsigned __int16)*v3 - 6;
    v20 = *v3;
    switch ( v5 )
    {
      case 0:
        v21 = sub_1006B9E0(6, &v14, &v11) == 0;
        sub_1003E670((int)v41);
        v6 = 0;
        do
        {
          v7 = v41[v6];
          v23[v6++] = v7;
        }
        while ( v7 );
        sub_1003E320(&v10, (int)&v17, (int)&v16, (int)&v15, (int)&v18);
        sprintf(&v22, "%04d", v10);
        break;
      case 1:
        v21 = sub_1002E390(7, v23, 32, (int)v12);
        sprintf(&v22, "%d", *(signed __int16 *)v12);
        break;
      case 4:
      case 15:
        v12[0] = v4 != 10;
        v21 = sub_10022410(
                v4 != 10,
                v23,
                0x20u,
                (int)&v22,
                8u,
                (int)&v42,
                0x14u,
                (int)&v43,
                0x20u,
                (int)&v19,
                (int)&v13,
                (int)&v40,
                5u) == 0;
        break;
      default:
        break;
    }
    result = sub_10019BD0(0, 514, &v20, 44);
  }
  else
  {
    memset(&v24, 0, 0x74u);
    if ( v2 == 257 )
    {
      v9 = 513;
      sub_100370F0(v32);
      v25 = v33;
      v24 = *(_DWORD *)v32;
      v26 = v34;
      v28 = v36;
      v27 = v35;
      v29 = v37;
      qmemcpy(&v30, &v38, 0x1Cu);
      qmemcpy(&v31, &v39, 0x20u);
    }
    else if ( v2 == 259 )
    {
      v9 = 515;
      sub_10039390((char *)&v24, 1);
    }
    else
    {
      v9 = 512;
      sub_10039390((char *)&v24, 0);
    }
    result = sub_10019BD0(0, v9, &v24, 116);
  }
  return result;
}
// 10019BD0: using guessed type _DWORD __cdecl sub_10019BD0(_DWORD, _DWORD, _DWORD, _DWORD);
// 10019E90: using guessed type char var_4C[20];
// 10019E90: using guessed type char var_165[33];

//----- (1001A140) --------------------------------------------------------
int __cdecl sub_1001A140(const char *a1, int a2, int a3, char a4)
{
  const char *v4; // edi@1
  signed int v5; // ebx@1
  unsigned int v6; // eax@5
  unsigned int v7; // esi@5
  int v8; // ebp@7
  char *v9; // ecx@12
  const char *v10; // ebx@13
  int v11; // esi@15
  _BYTE *v12; // ecx@16
  signed int v13; // eax@16
  char *v14; // edi@22
  char v15; // al@23
  unsigned int v16; // eax@24
  char *v17; // edi@24
  char v18; // cl@25
  int v19; // eax@27
  int v20; // eax@31
  bool v21; // zf@31
  bool v22; // sf@31
  int result; // eax@41
  char v24; // [sp+13h] [bp-279h]@12
  int v25; // [sp+14h] [bp-278h]@10
  char *v26; // [sp+18h] [bp-274h]@12
  int v27; // [sp+1Ch] [bp-270h]@1
  signed int v28; // [sp+28h] [bp-264h]@2
  unsigned int v29; // [sp+2Ch] [bp-260h]@5
  char v30; // [sp+30h] [bp-25Ch]@22
  char v31; // [sp+B0h] [bp-1DCh]@8

  v4 = a1;
  v5 = 0;
  v27 = 0;
  do
  {
    v28 = ++v5;
    if ( a4 && j_FIL_vfs_rmdir(v4) != -30 || v5 >= 200000 )
      break;
    v6 = j_FIL_vfs_open(v4, 260, 0);
    v7 = v6;
    v29 = v6;
    if ( v6 < 0xFFFFFFC2 && v6 )
      v8 = sub_1006B740(v6, (int)&v31, 469);
    else
      v8 = v6;
    if ( v8 >= 0 )
    {
      v25 = v8;
      v8 = 0;
    }
    else
    {
      v25 = 0;
    }
    v9 = &v31;
    v26 = &v31;
    v24 = 0;
    if ( v25 > 0 )
    {
      do
      {
        v10 = v9 + 24;
        if ( memcmp(&unk_10084574, v9 + 24, 2u) && memcmp("..", v10, 3u) )
        {
          v11 = 0;
          if ( a3 <= 0 )
          {
LABEL_22:
            v24 = 1;
            strcpy(&v30, a1);
            v14 = (char *)&v29 + 3;
            do
              v15 = (v14++)[1];
            while ( v15 );
            *(_WORD *)v14 = 47;
            v16 = strlen(v10) + 1;
            v17 = (char *)&v29 + 3;
            do
              v18 = (v17++)[1];
            while ( v18 );
            qmemcpy(v17, v10, v16);
            if ( *((_DWORD *)v26 + 5) & 0x1000 )
              v19 = sub_1001A140(&v30, a2, a3, 1);
            else
              v19 = j_FIL_vfs_delete(&v30);
            v8 = v19;
            if ( v19 )
            {
              v27 = v19;
              v8 = 0;
            }
          }
          else
          {
            while ( 1 )
            {
              v12 = *(_BYTE **)(a2 + 4 * v11);
              v13 = 0;
              if ( *v12 )
              {
                do
                {
                  if ( v12[v13] == 47 )
                  {
                    v12 += v13 + 1;
                    v13 = -1;
                  }
                  ++v13;
                }
                while ( v12[v13] );
              }
              if ( !sub_10036620(v12, v10, 200) )
                break;
              if ( ++v11 >= a3 )
                goto LABEL_22;
            }
          }
        }
        v20 = *((_WORD *)v26 + 2);
        v9 = &v26[v20];
        v21 = v25 == v20;
        v22 = v25 - v20 < 0;
        v25 -= v20;
        v26 += v20;
      }
      while ( !v22 && !v21 );
      v7 = v29;
      v5 = v28;
      v4 = a1;
    }
    if ( v7 < 0xFFFFFFC2 && v7 )
      sub_1006B1D0(v7);
    if ( v8 )
      goto LABEL_40;
  }
  while ( v24 || a4 );
  v8 = v27;
LABEL_40:
  if ( v8 == -24 )
    result = 0;
  else
    result = v8;
  return result;
}
// 1006B250: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);
// 1006B2E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1006B3D0: using guessed type int __cdecl j_FIL_vfs_rmdir(_DWORD);

//----- (1001A3E0) --------------------------------------------------------
unsigned int __usercall sub_1001A3E0@<eax>(int a1@<edi>)
{
  unsigned int result; // eax@2
  unsigned int v2; // esi@4
  unsigned int v3; // [sp+4h] [bp-8h]@7
  int v4; // [sp+8h] [bp-4h]@7

  if ( *(_BYTE *)a1 )
    result = j_FIL_vfs_open("/dev/sd_card1", 4, 0);
  else
    result = j_FIL_vfs_open("/dev/sd_card0", 4, 0);
  v2 = result;
  if ( result < 0xFFFFFFC2 )
  {
    if ( result )
    {
      v4 = *(_BYTE *)(a1 + 1);
      v3 = j_FIL_vfs_ioctl(result, 105, &v4, 4);
      sub_1006B1D0(v2);
      sub_10019BD0(0, 25091, &v3, 4);
      result = v3;
    }
  }
  return result;
}
// 10019BD0: using guessed type _DWORD __cdecl sub_10019BD0(_DWORD, _DWORD, _DWORD, _DWORD);
// 1006B270: using guessed type int __cdecl j_FIL_vfs_ioctl(_DWORD, _DWORD, _DWORD, _DWORD);
// 1006B2E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1001A460) --------------------------------------------------------
int __cdecl sub_1001A460(unsigned __int16 a1)
{
  int v1; // ecx@0
  int v2; // esi@1
  int result; // eax@2
  void *v4; // ecx@4
  int v5; // eax@4
  void *v6; // ecx@4
  int v7; // eax@4
  int v8; // eax@5
  int v9; // eax@12
  int v10; // ecx@12
  unsigned __int16 v11; // ax@16
  unsigned __int16 v12; // dx@16
  unsigned __int16 v13; // cx@16
  int v14; // edi@17
  int v15; // eax@18
  signed int v16; // esi@25
  signed int v17; // esi@35
  int v18; // edx@38
  unsigned int v19; // eax@38
  unsigned int v20; // ecx@38
  void *v21; // ecx@44
  int v22; // eax@44
  void *v23; // ecx@44
  int v24; // eax@44
  int *v25; // [sp-14h] [bp-10Ch]@7
  signed int v26; // [sp-10h] [bp-108h]@7
  signed int v27; // [sp-8h] [bp-100h]@20
  signed int v28; // [sp-4h] [bp-FCh]@20
  int v29; // [sp+Ch] [bp-ECh]@1
  char v30; // [sp+13h] [bp-E5h]@4
  int v31; // [sp+14h] [bp-E4h]@10
  char v32; // [sp+18h] [bp-E0h]@4
  char v33; // [sp+1Ah] [bp-DEh]@4
  double v34; // [sp+20h] [bp-D8h]@41
  double v35; // [sp+28h] [bp-D0h]@38
  double v36; // [sp+30h] [bp-C8h]@38
  double v37; // [sp+38h] [bp-C0h]@41
  int v38; // [sp+40h] [bp-B8h]@4
  int v39; // [sp+44h] [bp-B4h]@4
  int v40; // [sp+48h] [bp-B0h]@4
  int v41; // [sp+4Ch] [bp-ACh]@4
  char v42; // [sp+ACh] [bp-4Ch]@11
  char v43; // [sp+ADh] [bp-4Bh]@4
  int v44; // [sp+C4h] [bp-34h]@12
  int v45; // [sp+C8h] [bp-30h]@12
  int v46; // [sp+CCh] [bp-2Ch]@12
  int v47; // [sp+D0h] [bp-28h]@12
  unsigned int v48; // [sp+D4h] [bp-24h]@12
  __int64 v49; // [sp+D8h] [bp-20h]@16
  int v50; // [sp+E0h] [bp-18h]@16
  int v51; // [sp+E4h] [bp-14h]@29
  int v52; // [sp+E8h] [bp-10h]@12
  int v53; // [sp+ECh] [bp-Ch]@12
  int v54; // [sp+F0h] [bp-8h]@12

  v2 = v1;
  v29 = 0;
  if ( sub_1006C1E0() )
  {
    result = a1;
    switch ( a1 )
    {
      case 0x6209u:
        dword_104DAB54 = 6;
        memset(&dword_104DAB58, -1, 0x7Cu);
        v5 = sub_10037130(v4);
        sub_1006C4A0(0, (int)&v32, v5);
        v33 = 1;
        v7 = sub_10037130(v6);
        j_HWM_pvg_dspl_bklt_set_cnfg(0, &v32, v7);
        j_HWM_pvg_dspl_bklt_get_actv_led_calib(&v38);
        v38 = 0;
        v39 = 0;
        v40 = 0;
        v41 = 0;
        v43 = 0;
        v29 = j_HWM_pvg_dspl_bklt_set_led_calib(&v38, 0);
        j_HWM_pvg_set_anlg_outp(4, 10000, 0);
        v30 = 1;
        sub_1006A190(9223, (int)&v30, 1);
        return sub_10019BD0(0, 25103, &v29, 4);
      case 0x6213u:
        qmemcpy(&dbl_104DABF4, (const void *)(v2 + 4), 0x1Cu);
        v8 = sub_1006A190(33002, (int)&dbl_104DABF4, 28);
        goto LABEL_6;
      case 0x6216u:
        v31 = *(_DWORD *)(v2 + 4);
        v8 = sub_1006A190(33003, (int)&v31, 4);
LABEL_6:
        v29 = v8;
        j_FIL_vfs_sync_all();
        goto LABEL_7;
      case 0x621Du:
        v29 = sub_1006A0A0(33000, (int)&v38, 124);
        return sub_10019BD0(0, 25118, &v42, 1);
      case 0x621Fu:
        v9 = *(_DWORD *)(v2 + 8);
        v10 = *(_DWORD *)(v2 + 12);
        v52 = *(_DWORD *)(v2 + 4);
        v53 = v9;
        v54 = v10;
        LOWORD(v44) = 20;
        sub_100365D0((int)&v44 + 2, &v52, 12);
        v48 = sub_10022E80((unsigned int *)&v44, 16, 0xFFFFFFFF);
        v29 = sub_1006A190(33001, (int)&v44, 20);
        j_FIL_vfs_sync_all();
        v44 = 0;
        v45 = 0;
        v46 = 0;
        v47 = 0;
        v48 = 0;
        LOBYTE(v52) = 0;
        sub_1006A0A0(33001, (int)&v44, 20);
        sub_100365D0((int)&v52, (_BYTE *)&v44 + 2, 12);
        return sub_10019BD0(0, 25120, &v52, 12);
      case 0x6221u:
        v44 = 0;
        v45 = 0;
        v46 = 0;
        v47 = 0;
        v48 = 0;
        LOBYTE(v52) = 0;
        sub_1006A0A0(33001, (int)&v44, 20);
        sub_100365D0((int)&v52, (_BYTE *)&v44 + 2, 12);
        return sub_10019BD0(0, 25122, &v52, 12);
      case 0x6214u:
        v29 = sub_1006A0A0(33002, (int)&dbl_104DABF4, 28);
        return sub_10019BD0(0, 25109, &dbl_104DABF4, 28);
      case 0x6217u:
        v29 = sub_1006A0A0(33003, (int)&v31, 4);
        return sub_10019BD0(0, 25112, &v31, 4);
      case 0x620Au:
        HIBYTE(v11) = *(_BYTE *)(v2 + 8);
        HIBYTE(v12) = *(_BYTE *)(v2 + 6);
        HIBYTE(v13) = *(_BYTE *)(v2 + 4);
        LOBYTE(v11) = *(_BYTE *)(v2 + 9);
        LOBYTE(v12) = *(_BYTE *)(v2 + 7);
        LOBYTE(v13) = *(_BYTE *)(v2 + 5);
        v50 = v11;
        LODWORD(v49) = (signed int)(65525.0 * ((double)v13 / 10000.0));
        v26 = 4;
        v29 = j_HWM_pvg_dspl_bklt_set_rgb_pwm(
                (unsigned __int16)v49,
                (unsigned __int16)(signed int)((double)v12 / 10000.0 * 65525.0),
                (unsigned __int16)(signed int)((double)v11 / 10000.0 * 65525.0));
        v25 = &v29;
        return sub_10019BD0(0, 25103, v25, v26);
      case 0x620Bu:
        v14 = *(_BYTE *)(v2 + 4);
        if ( *(_BYTE *)(v2 + 4) )
        {
          if ( v14 == 1 )
          {
            v28 = 0;
            v27 = 65525;
          }
          else
          {
            if ( v14 != 2 )
              goto LABEL_25;
            v28 = 65525;
            v27 = 0;
          }
          v15 = j_HWM_pvg_dspl_bklt_set_rgb_pwm(0, v27, v28);
        }
        else
        {
          v15 = j_HWM_pvg_dspl_bklt_set_rgb_pwm(65525, 0, 0);
        }
        v29 = v15;
LABEL_25:
        v16 = 10;
        do
        {
          sub_10069880(1000);
          --v16;
        }
        while ( v16 );
        do
        {
          *(_WORD *)((char *)&v49 + v16) = j_HWM_pvg_dspl_bklt_get_intnsty(v14);
          *(_WORD *)((char *)&v50 + v16) = j_HWM_pvg_dspl_bklt_calc_led_temp();
          v16 += 2;
        }
        while ( v16 < 6 );
        if ( v14 )
        {
          if ( v14 == 1 )
          {
            dword_104DA720 = sub_10019D40(*(int *)((char *)&v49 + 2), v49, SWORD2(v49));
            LODWORD(v49) = sub_10019D40(*(int *)((char *)&v50 + 2), v50, v51);
            flt_104DA724 = (double)(signed int)v49 / 100.0 * 1.799999952316284 + 32.0;
          }
          else if ( v14 == 2 )
          {
            dword_104DAC10 = sub_10019D40(*(int *)((char *)&v49 + 2), v49, SWORD2(v49));
            LODWORD(v49) = sub_10019D40(*(int *)((char *)&v50 + 2), v50, v51);
            flt_104DAC14 = (double)(signed int)v49 / 100.0 * 1.799999952316284 + 32.0;
          }
        }
        else
        {
          dword_104DABD4 = sub_10019D40(*(int *)((char *)&v49 + 2), v49, SWORD2(v49));
          LODWORD(v49) = sub_10019D40(*(int *)((char *)&v50 + 2), v50, v51);
          flt_104DABD8 = (double)(signed int)v49 / 100.0 * 1.799999952316284 + 32.0;
        }
        result = sub_10019BD0(0, 25103, &v29, 4);
        break;
      case 0x620Cu:
        dbl_104DABDC = *(double *)(v2 + 4);
        dbl_104DABE4 = *(double *)(v2 + 12);
        dbl_104DABEC = *(double *)(v2 + 20);
        dbl_104DA728 = *(double *)(v2 + 28);
        dbl_104DA730 = *(double *)(v2 + 36);
        dbl_104DA738 = *(double *)(v2 + 44);
        dbl_104DAC18 = *(double *)(v2 + 52);
        dbl_104DAC20 = *(double *)(v2 + 60);
        dbl_104DAC28 = *(double *)(v2 + 68);
        dbl_104DABEC = dbl_104DABEC / 3.4262591;
        dbl_104DA738 = dbl_104DA738 / 3.4262591;
        dbl_104DAC28 = dbl_104DAC28 / 3.4262591;
        dbl_104DABDC = dbl_104DABDC - dbl_104DABEC * 0.0000199999994947575 - 0.00007000000186963007 * flt_104DABD8;
        dbl_104DABE4 = dbl_104DABE4 - dbl_104DABEC * -0.0000199999994947575 - flt_104DABD8 * -0.00007000000186963007;
        dbl_104DA728 = dbl_104DA728 - dbl_104DA738 * 0.00004999999873689376 - 0.0001400000037392601 * flt_104DA724;
        dbl_104DA730 = dbl_104DA730 - -0.00007000000186963007 * dbl_104DA738 - flt_104DA724 * -0.000199999994947575;
        dbl_104DAC18 = dbl_104DAC18 - dbl_104DAC28 * -0.000003999999989900971 - -0.0000199999994947575 * flt_104DAC14;
        dbl_104DAC20 = dbl_104DAC20 - dbl_104DAC28 * 0.000009999999747378752 - flt_104DAC14 * 0.00003999999898951501;
        dword_104DAB8C = (signed int)(dbl_104DABF4 * dbl_104DABEC * 1000000.0);
        dword_104DAB94 = (signed int)(dbl_104DABFC * dbl_104DA738 * 1000000.0);
        dword_104DAB9C = (signed int)(1000000.0 * (dbl_104DAC04 * dbl_104DAC28));
        dword_104DAB90 = (signed int)((dbl_104DABEC - dbl_104DABF4 * dbl_104DABEC * (double)dword_104DABD4) * 1000.0);
        dword_104DAB98 = (signed int)((dbl_104DA738 - dbl_104DABFC * dbl_104DA738 * (double)dword_104DA720) * 1000.0);
        dword_104DABA0 = (signed int)(1000.0 * (dbl_104DAC28 - dbl_104DAC04 * dbl_104DAC28 * (double)dword_104DAC10));
        dword_104DABA4 = dword_104DABD4;
        dword_104DABA8 = dword_104DA720;
        dword_104DABAC = dword_104DAC10;
        dword_104DAB84 = 2849;
        dword_104DAB88 = 2932;
        dword_104DABB0 = 0;
        dword_104DABB4 = 0;
        dword_104DAB6C = (signed __int64)(dbl_104DABDC * 10000.0);
        byte_104DABC4 = 1;
        byte_104DABC6 = 1;
        byte_104DABC5 = 1;
        dword_104DAB70 = (signed __int64)(dbl_104DABE4 * 10000.0);
        dword_104DAB74 = (signed __int64)(dbl_104DA728 * 10000.0);
        dword_104DAB78 = (signed __int64)(dbl_104DA730 * 10000.0);
        dword_104DAB7C = (signed __int64)(dbl_104DAC18 * 10000.0);
        v49 = (signed __int64)(10000.0 * dbl_104DAC20);
        dword_104DAB80 = v49;
        v29 = j_HWM_pvg_dspl_bklt_set_led_calib(&dword_104DAB58, 0);
        j_HWM_pvg_set_anlg_outp(4, 10000, 0);
        v17 = 60;
        do
        {
          sub_10069880(1000);
          j_HWM_pvg_set_anlg_outp(4, 10000, 0);
          --v17;
        }
        while ( v17 );
        return sub_10019BD0(0, 25103, &v29, 4);
      case 0x620Du:
        v18 = *(_DWORD *)(v2 + 8);
        v19 = *(_DWORD *)(v2 + 12);
        LODWORD(v35) = *(_DWORD *)(v2 + 4);
        v20 = *(_DWORD *)(v2 + 16);
        HIDWORD(v35) = v18;
        v36 = COERCE_DOUBLE(__PAIR__(v20, v19));
        v29 = j_HWM_pvg_dspl_bklt_get_actv_led_calib(&dword_104DAB58);
        if ( !v29 )
        {
          dword_104DABB0 = (signed int)((0.2849 - v35) * 10000.0);
          dword_104DABB4 = (signed int)(10000.0 * (0.2932 - v36));
          v29 = j_HWM_pvg_dspl_bklt_set_led_calib(&dword_104DAB58, 0);
        }
        j_HWM_pvg_set_anlg_outp(4, 10000, 0);
LABEL_7:
        v26 = 4;
        v25 = &v29;
        return sub_10019BD0(0, 25103, v25, v26);
      case 0x6223u:
        v34 = *(double *)(v2 + 4);
        v35 = *(double *)(v2 + 12);
        v36 = *(double *)(v2 + 20);
        v37 = *(double *)(v2 + 28);
        v29 = j_HWM_pvg_dspl_bklt_get_actv_led_calib(&dword_104DAB58);
        dword_104DAB58 = (signed __int64)(v34 / 3.4262591 * 100.0);
        dword_104DAB5C = (signed __int64)(v35 / 3.4262591 * 100.0);
        dword_104DAB60 = (signed __int64)(v36 / 3.4262591 * 100.0);
        v49 = (signed __int64)(100.0 * (v37 / 3.4262591));
        dword_104DAB64 = v49;
        v29 |= j_HWM_pvg_dspl_bklt_set_led_calib(&dword_104DAB58, 0);
        v26 = 4;
        v25 = &v29;
        return sub_10019BD0(0, 25103, v25, v26);
      case 0x620Eu:
        LOBYTE(v50) = *(_BYTE *)(v2 + 4);
        v29 = j_HWM_pvg_dspl_bklt_get_actv_led_calib(&dword_104DAB58);
        if ( !(_BYTE)v50 )
        {
          byte_104DABC4 = 0;
          byte_104DABC6 = 0;
          byte_104DABC5 = 0;
        }
        v29 |= j_HWM_pvg_dspl_bklt_set_led_calib(&dword_104DAB58, 1);
        v22 = sub_10037130(v21);
        v29 |= sub_1006C4A0(0, (int)&v32, v22);
        v33 = 0;
        v24 = sub_10037130(v23);
        v29 |= j_HWM_pvg_dspl_bklt_set_cnfg(0, &v32, v24);
        v30 = 0;
        v29 |= sub_1006A190(9223, (int)&v30, 1);
        dword_104DAB54 = 0;
        dword_104DA71C = 0;
        return sub_10019BD0(0, 25103, &v29, 4);
      case 0x6224u:
        memset(&v38, 0, 0x7Cu);
        sub_1006A0A0(16, (int)&v38, 124);
        return sub_10019BD0(0, 25103, &v38, 124);
      default:
        return result;
    }
  }
  else
  {
    v29 = -31;
    result = sub_10019BD0(0, 25103, &v29, 4);
  }
  return result;
}
// 10019BD0: using guessed type _DWORD __cdecl sub_10019BD0(_DWORD, _DWORD, _DWORD, _DWORD);
// 1006B450: using guessed type int j_FIL_vfs_sync_all(void);
// 1006BA90: using guessed type int j_HWM_pvg_dspl_bklt_calc_led_temp(void);
// 1006BAA0: using guessed type int __cdecl j_HWM_pvg_dspl_bklt_get_actv_led_calib(_DWORD);
// 1006BAB0: using guessed type int __cdecl j_HWM_pvg_dspl_bklt_get_intnsty(_DWORD);
// 1006BAC0: using guessed type int __cdecl j_HWM_pvg_dspl_bklt_set_led_calib(_DWORD, _DWORD);
// 1006BAD0: using guessed type int __cdecl j_HWM_pvg_dspl_bklt_set_rgb_pwm(_DWORD, _DWORD, _DWORD);
// 1006BBE0: using guessed type int __cdecl j_HWM_pvg_set_anlg_outp(_DWORD, _DWORD, _DWORD);
// 1006C320: using guessed type int __cdecl j_HWM_pvg_dspl_bklt_set_cnfg(_DWORD, _DWORD, _DWORD);
// 104DA71C: using guessed type int dword_104DA71C;
// 104DA720: using guessed type int dword_104DA720;
// 104DA724: using guessed type float flt_104DA724;
// 104DA728: using guessed type double dbl_104DA728;
// 104DA730: using guessed type double dbl_104DA730;
// 104DA738: using guessed type double dbl_104DA738;
// 104DAB54: using guessed type int dword_104DAB54;
// 104DAB58: using guessed type int dword_104DAB58;
// 104DAB5C: using guessed type int dword_104DAB5C;
// 104DAB60: using guessed type int dword_104DAB60;
// 104DAB64: using guessed type int dword_104DAB64;
// 104DAB6C: using guessed type int dword_104DAB6C;
// 104DAB70: using guessed type int dword_104DAB70;
// 104DAB74: using guessed type int dword_104DAB74;
// 104DAB78: using guessed type int dword_104DAB78;
// 104DAB7C: using guessed type int dword_104DAB7C;
// 104DAB80: using guessed type int dword_104DAB80;
// 104DAB84: using guessed type int dword_104DAB84;
// 104DAB88: using guessed type int dword_104DAB88;
// 104DAB8C: using guessed type int dword_104DAB8C;
// 104DAB90: using guessed type int dword_104DAB90;
// 104DAB94: using guessed type int dword_104DAB94;
// 104DAB98: using guessed type int dword_104DAB98;
// 104DAB9C: using guessed type int dword_104DAB9C;
// 104DABA0: using guessed type int dword_104DABA0;
// 104DABA4: using guessed type int dword_104DABA4;
// 104DABA8: using guessed type int dword_104DABA8;
// 104DABAC: using guessed type int dword_104DABAC;
// 104DABB0: using guessed type int dword_104DABB0;
// 104DABB4: using guessed type int dword_104DABB4;
// 104DABC4: using guessed type char byte_104DABC4;
// 104DABC5: using guessed type char byte_104DABC5;
// 104DABC6: using guessed type char byte_104DABC6;
// 104DABD4: using guessed type int dword_104DABD4;
// 104DABD8: using guessed type float flt_104DABD8;
// 104DABDC: using guessed type double dbl_104DABDC;
// 104DABE4: using guessed type double dbl_104DABE4;
// 104DABEC: using guessed type double dbl_104DABEC;
// 104DABF4: using guessed type double dbl_104DABF4;
// 104DABFC: using guessed type double dbl_104DABFC;
// 104DAC04: using guessed type double dbl_104DAC04;
// 104DAC10: using guessed type int dword_104DAC10;
// 104DAC14: using guessed type float flt_104DAC14;
// 104DAC18: using guessed type double dbl_104DAC18;
// 104DAC20: using guessed type double dbl_104DAC20;
// 104DAC28: using guessed type double dbl_104DAC28;

//----- (1001B310) --------------------------------------------------------
int __cdecl sub_1001B310(__int16 a1)
{
  char v1; // bl@2
  int result; // eax@2

  if ( a1 == 1026 )
  {
    v1 = byte_104DA740;
    result = j_HWM_pvg_set_uart(0, (unsigned __int8)byte_104DA740, 4, 23);
    byte_104DA741 = v1;
  }
  return result;
}
// 1006BC10: using guessed type int __cdecl j_HWM_pvg_set_uart(_DWORD, _DWORD, _DWORD, _DWORD);
// 104DA740: using guessed type char byte_104DA740;
// 104DA741: using guessed type char byte_104DA741;

//----- (1001B340) --------------------------------------------------------
void __fastcall sub_1001B340(char a1)
{
  char v1; // bl@1
  signed int v2; // ebx@13
  int v3; // [sp+Ch] [bp-384h]@1
  int v4; // [sp+10h] [bp-380h]@8
  int v5; // [sp+14h] [bp-37Ch]@3
  int v6; // [sp+18h] [bp-378h]@4
  int v7; // [sp+1Ch] [bp-374h]@4
  int v8; // [sp+20h] [bp-370h]@4
  int v9; // [sp+24h] [bp-36Ch]@4
  int v10; // [sp+28h] [bp-368h]@15
  int v11; // [sp+2Ch] [bp-364h]@15
  int v12; // [sp+30h] [bp-360h]@15
  int v13; // [sp+34h] [bp-35Ch]@15
  int v14; // [sp+38h] [bp-358h]@15
  char v15; // [sp+3Ch] [bp-354h]@15
  int v16; // [sp+88h] [bp-308h]@15
  int v17; // [sp+8Ch] [bp-304h]@15
  int v18; // [sp+90h] [bp-300h]@15
  int v19; // [sp+94h] [bp-2FCh]@15
  int v20; // [sp+98h] [bp-2F8h]@15
  int v21; // [sp+9Ch] [bp-2F4h]@15
  char v22; // [sp+A0h] [bp-2F0h]@15
  char v23; // [sp+A1h] [bp-2EFh]@15
  int v24; // [sp+108h] [bp-288h]@14
  int v25; // [sp+10Ch] [bp-284h]@15
  int v26; // [sp+110h] [bp-280h]@15
  int v27; // [sp+114h] [bp-27Ch]@15
  int v28; // [sp+118h] [bp-278h]@15
  char v29; // [sp+11Ch] [bp-274h]@15
  int v30; // [sp+2D4h] [bp-BCh]@15
  int v31; // [sp+2D8h] [bp-B8h]@15
  int v32; // [sp+2DCh] [bp-B4h]@15
  int v33; // [sp+2E0h] [bp-B0h]@15
  int v34; // [sp+2E4h] [bp-ACh]@15
  int v35; // [sp+2E8h] [bp-A8h]@15
  char v36; // [sp+2ECh] [bp-A4h]@15
  char v37; // [sp+2EDh] [bp-A3h]@15

  v1 = a1;
  v3 = 0;
  if ( a1 == 8 || !a1 )
  {
    if ( sub_1006A0A0(3, (int)&v5, 20) )
    {
      v5 = 0;
      v6 = 0;
      v7 = 0;
      v8 = 0;
      v9 = 0;
    }
    sub_10019BD0(0, 25347, &v5, 20);
  }
  if ( v1 == 8 || v1 == 2 )
  {
    if ( sub_1006A0A0(14, (int)&v4, 4) )
      v4 = 0;
    sub_10019BD0(0, 25348, &v4, 4);
  }
  if ( v1 == 8 || v1 == 1 )
  {
    v2 = 0;
    do
    {
      if ( !sub_10016B60(&v24, v2) )
      {
        v10 = v24;
        v12 = v26;
        v11 = v25;
        v13 = v27;
        v14 = v28;
        qmemcpy(&v15, &v29, 0x4Cu);
        v17 = v31;
        v16 = v30;
        v20 = v34;
        v19 = v33;
        v18 = v32;
        v22 = v36;
        v21 = v35;
        qmemcpy(&v23, &v37, 0x64u);
        sub_10019BD0(0, 25345, &v10, 224);
        ++v3;
      }
      ++v2;
    }
    while ( v2 < 100 );
    sub_10019BD0(0, 25346, &v3, 4);
  }
}
// 10019BD0: using guessed type _DWORD __cdecl sub_10019BD0(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1001B530) --------------------------------------------------------
int __usercall sub_1001B530@<eax>(char a1@<bl>)
{
  int v1; // eax@15
  int v2; // eax@17
  int v4; // [sp+4h] [bp-2Ch]@5
  int v5; // [sp+8h] [bp-28h]@1
  char v6; // [sp+Ch] [bp-24h]@1
  int v7; // [sp+10h] [bp-20h]@7
  int v8; // [sp+14h] [bp-1Ch]@7
  int v9; // [sp+18h] [bp-18h]@7
  int v10; // [sp+1Ch] [bp-14h]@3
  int v11; // [sp+20h] [bp-10h]@3
  int v12; // [sp+24h] [bp-Ch]@3
  int v13; // [sp+28h] [bp-8h]@3
  int v14; // [sp+2Ch] [bp-4h]@3

  v5 = -15;
  v6 = a1;
  if ( !a1 || a1 == 3 )
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    sub_1006A190(3, (int)&v10, 20);
    v5 = sub_10016C60();
  }
  if ( a1 == 5 )
  {
    v4 = 0;
    v5 = sub_1006A190(14, (int)&v4, 4);
    goto LABEL_22;
  }
  if ( a1 == 4 )
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    LOWORD(v7) = 32640;
    v5 = sub_1006A190(10, (int)&v7, 12);
    goto LABEL_22;
  }
  if ( a1 == 1 || a1 == 3 )
  {
    v5 = sub_1006B7A0("/mnt/sys_nand0/usr");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/reg_lvl_b.reg");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/reg_lvl_c.reg");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/reg_lvl_d.reg");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/udb_sms.reg");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/udb_rtes.reg");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/udb_wpt.dat");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/udb_wifi.reg");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/udb_contacts.reg");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/udb_freq.reg");
  }
  if ( a1 == 2 || a1 == 3 )
  {
    v5 = j_FIL_vfs_delete("/mnt/sys_nand0/reg_sys_cnfg.reg");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/reg_arfrm_alerts.reg");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/reg_arfrm_alert_nodes.reg");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/reg_arfrm_triggers.reg");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/reg_cmc_alerts.reg");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/reg_cmc_alert_nodes.reg");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/reg_cmc_triggers.reg");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/reg_system_alerts.reg");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/reg_system_alert_nodes.reg");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/reg_system_triggers.reg");
    v5 |= j_FIL_vfs_delete("/mnt/sys_nand0/reg_log_folders.reg");
    j_FIL_vfs_delete("/mnt/sys_nand0/avtn_db.bin");
    j_FIL_vfs_delete("/mnt/sys_nand0/avtn_db_stby.bin");
  }
  if ( a1 == 6 )
  {
    v5 = 0;
    v1 = j_FIL_vfs_delete("/mnt/sys_nand0/sys_files.gca");
  }
  else
  {
    if ( a1 == 7 )
    {
      v2 = sub_1001A140("/mnt/sys_nand0", (int)off_100986B0, 3, 0);
    }
    else
    {
      if ( a1 != 3 )
        goto LABEL_22;
      v2 = sub_1001A140("/mnt/sys_nand0", (int)off_100986BC, 6, 0);
    }
    v5 |= v2;
    v1 = sub_1001A140("/mnt/card2", 0, 0, 0);
  }
  v5 |= v1;
LABEL_22:
  if ( v5 == -24 )
    v5 = 0;
  sub_10019BD0(0, 25089, &v5, 8);
  return v5;
}
// 10019BD0: using guessed type _DWORD __cdecl sub_10019BD0(_DWORD, _DWORD, _DWORD, _DWORD);
// 1006B250: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);
// 100986B0: using guessed type char *off_100986B0[9];
// 100986BC: using guessed type char *off_100986BC[6];

//----- (1001B7C0) --------------------------------------------------------
void __usercall sub_1001B7C0(int a1@<ebx>, int a2)
{
  void *v2; // ecx@1
  int v3; // eax@1
  signed int v4; // esi@25
  int v5; // ebx@26
  int v6; // eax@38
  int v7; // eax@39
  int v8; // eax@41
  __int16 v9; // dx@41
  void *v10; // ecx@50
  char v11; // cl@52
  char v12; // al@55
  __int16 v13; // ax@58
  int v14; // eax@61
  int v15; // eax@62
  int v16; // edx@64
  int v17; // eax@64
  int v18; // eax@66
  int v19; // eax@73
  int v20; // eax@74
  int v21; // eax@77
  char v22; // cl@87
  char v23; // dl@87
  char v24; // al@87
  char v25; // cl@87
  int v26; // esi@90
  int *v27; // [sp-Ch] [bp-744h]@46
  signed int v28; // [sp-8h] [bp-740h]@46
  int v29; // [sp+8h] [bp-730h]@1
  char v30; // [sp+Fh] [bp-729h]@90
  int v31; // [sp+10h] [bp-728h]@41
  __int16 v32; // [sp+14h] [bp-724h]@41
  char v33; // [sp+18h] [bp-720h]@52
  int v34; // [sp+19h] [bp-71Fh]@52
  char v35; // [sp+20h] [bp-718h]@87
  char v36; // [sp+21h] [bp-717h]@87
  char v37; // [sp+22h] [bp-716h]@87
  char v38; // [sp+23h] [bp-715h]@87
  char v39; // [sp+24h] [bp-714h]@87
  int v40; // [sp+28h] [bp-710h]@58
  int v41; // [sp+32h] [bp-706h]@32
  int v42; // [sp+38h] [bp-700h]@49
  int v43; // [sp+40h] [bp-6F8h]@1
  int v44; // [sp+44h] [bp-6F4h]@1
  int v45; // [sp+48h] [bp-6F0h]@34
  int v46; // [sp+4Ch] [bp-6ECh]@35
  char v47; // [sp+50h] [bp-6E8h]@96
  int v48; // [sp+54h] [bp-6E4h]@84
  int v49; // [sp+58h] [bp-6E0h]@85
  int v50; // [sp+5Ch] [bp-6DCh]@85
  int v51; // [sp+60h] [bp-6D8h]@1
  int v52; // [sp+64h] [bp-6D4h]@1
  int v53; // [sp+68h] [bp-6D0h]@1
  char v54; // [sp+6Ch] [bp-6CCh]@24
  char v55; // [sp+70h] [bp-6C8h]@97
  __int16 v56; // [sp+200h] [bp-538h]@22
  char v57[4]; // [sp+728h] [bp-10h]@64
  int v58; // [sp+72Ch] [bp-Ch]@64
  int v59; // [sp+730h] [bp-8h]@64

  v51 = 0;
  v52 = 0;
  v53 = 0;
  v43 = 0;
  v44 = 0;
  BYTE1(v3) = *(_BYTE *)a2;
  v29 = 0;
  LOBYTE(v3) = *(_BYTE *)(a2 + 1);
  v2 = (void *)(unsigned __int16)v3;
  v3 = (unsigned __int16)v3;
  if ( (signed int)(unsigned __int16)v3 > 25088 )
  {
    switch ( (unsigned __int16)v3 )
    {
      default:
        return;
      case 0x6204u:
        if ( sub_1006A0A0(10, (int)&v48, 12) )
        {
          v48 = 0;
          v49 = 0;
          v50 = 0;
        }
        sub_10019BD0(0, 25093, &v48, 12);
        break;
      case 0x6206u:
        dword_104DAB54 = 5;
        dword_104DA71C = *(_DWORD *)(a2 + 8);
        v22 = *(_BYTE *)(a2 + 5);
        v23 = *(_BYTE *)(a2 + 6);
        v35 = *(_BYTE *)(a2 + 4);
        v24 = *(_BYTE *)(a2 + 7);
        v36 = v22;
        v25 = *(_BYTE *)(a2 + 8);
        v37 = v23;
        v38 = v24;
        v39 = v25;
        v29 = j_HWM_pvg_set_decoder_cfg(&v35);
        sub_10019BD0(0, 25096, &v29, 4);
        break;
      case 0x6207u:
        dword_104DAB54 = 0;
        dword_104DA71C = 0;
        v29 = 0;
        sub_10019BD0(0, 25096, &v29, 4);
        break;
      case 0x6210u:
        if ( !sub_1006C1E0() )
          goto LABEL_91;
        v26 = *(_BYTE *)(a2 + 4);
        v30 = 0;
        v29 = sub_1006A190(9222, (int)&v30, 1);
        j_HWM_pvg_set_reg(21, v26);
        v29 |= j_HWM_pvg_set_reg(19, 1);
        v29 |= j_HWM_pvg_set_reg(20, 1);
        goto LABEL_92;
      case 0x6211u:
        if ( sub_1006C1E0() )
        {
          v30 = *(_BYTE *)(a2 + 4);
          v29 = sub_1006A190(9222, (int)&v30, 1);
          v29 |= j_HWM_pvg_set_reg(19, 0);
          v29 |= j_HWM_pvg_set_reg(20, 0);
        }
        else
        {
LABEL_91:
          v29 = -31;
        }
LABEL_92:
        sub_10019BD0(0, 25106, &v29, 4);
        break;
      case 0x6209u:
      case 0x620Au:
      case 0x620Bu:
      case 0x620Cu:
      case 0x620Du:
      case 0x620Eu:
      case 0x6213u:
      case 0x6214u:
      case 0x6216u:
      case 0x6217u:
      case 0x621Du:
      case 0x621Fu:
      case 0x6221u:
      case 0x6223u:
      case 0x6224u:
        sub_1001A460(v3);
        break;
      case 0x6219u:
        sub_1006A0A0(9312, (int)&v47, 4);
        sub_10019BD0(0, 25114, &v47, 4);
        break;
      case 0x621Bu:
        sub_1006A0A0(9357, (int)&v55, 400);
        sub_10019BD0(0, 25116, &v55, 400);
        break;
      case 0x6202u:
        sub_1001A3E0(a2 + 4);
        break;
      case 0x6300u:
        sub_1001B340(*(_BYTE *)(a2 + 4));
        break;
    }
    return;
  }
  if ( (unsigned __int16)v3 == 25088 )
  {
    sub_1001B530(*(_BYTE *)(a2 + 4));
    return;
  }
  if ( (signed int)(unsigned __int16)v3 > 2325 )
  {
    if ( (signed int)(unsigned __int16)v3 > 22530 )
    {
      v19 = (unsigned __int16)v3 - 22532;
      if ( v19 )
      {
        v20 = v19 - 2300;
        if ( v20 )
        {
          if ( v20 == 1 )
          {
            dword_104DAB54 = 0;
            dword_104DA71C = 0;
          }
        }
        else
        {
          dword_104DAB54 = *(_DWORD *)(a2 + 4);
          v21 = dword_104DAB54;
          if ( (unsigned int)dword_104DAB54 >= 7 )
          {
            sub_100364C0("..\\lib\\adl\\iop_inst_prj.c", 919, 1, 0);
            v21 = dword_104DAB54;
          }
          if ( v21 == 1 )
            dword_104DA71C = *(_DWORD *)(a2 + 8);
        }
      }
      else
      {
        sub_1003CCC0(*(_BYTE *)(a2 + 4), *(_BYTE *)(a2 + 5));
      }
      return;
    }
    if ( (unsigned __int16)v3 == 22530 )
      return;
    v14 = (unsigned __int16)v3 - 2326;
    if ( v14 )
    {
      v15 = v14 - 2;
      if ( v15 )
      {
        if ( v15 == 2 )
        {
          v16 = *(_DWORD *)(a2 + 8);
          v17 = *(_DWORD *)(a2 + 12);
          *(_DWORD *)v57 = *(_DWORD *)(a2 + 4);
          v58 = v16;
          v59 = v17;
          sub_100370E0(v57);
          v57[0] = 0;
          sub_10037150(v57);
          sub_10019BD0(0, 2331, v57, 12);
        }
      }
      else
      {
        LOWORD(v43) = *(_WORD *)(a2 + 4);
        v44 = sub_1006C0E0((__int16 *)&v43, 0);
        sub_10019BD0(0, 2329, &v43, 8);
      }
      return;
    }
    v18 = *(_DWORD *)(a2 + 4);
    v32 = *(_WORD *)(a2 + 8);
    v31 = v18;
    if ( (unsigned __int8)v18 < 0x18u && BYTE1(v18) == 1 && (_BYTE)v18 != 15 )
    {
      if ( !j_HWM_pvg_set_reg(v18, *(int *)((char *)&v31 + 2)) )
      {
        BYTE1(v31) = 1;
        *(int *)((char *)&v31 + 2) = j_HWM_pvg_read_reg(v31);
        v28 = 6;
        v27 = &v31;
LABEL_47:
        sub_10019BD0(0, 2311, v27, v28);
        return;
      }
      sub_100364C0("..\\lib\\adl\\iop_inst_prj.c", 773, 0, 0);
    }
    v28 = 6;
    *(int *)((char *)&v31 + 2) = 0;
    BYTE1(v31) = 0;
    v27 = &v31;
    goto LABEL_47;
  }
  if ( (unsigned __int16)v3 == 2325 )
  {
    HIBYTE(v13) = *(_BYTE *)(a2 + 6);
    LOBYTE(v40) = *(_BYTE *)(a2 + 4);
    LOBYTE(v13) = *(_BYTE *)(a2 + 5);
    *(_WORD *)((char *)&v40 + 1) = v13;
    j_HWM_pvg_set_anlg_outp(v40, *(int *)((char *)&v40 + 1), 4);
    sub_10019BD0(0, 2324, &v40, 1);
    return;
  }
  if ( (signed int)(unsigned __int16)v3 <= 1536 )
  {
    if ( (unsigned __int16)v3 == 1536 )
    {
      sub_1001B310(*(_BYTE *)(a2 + 5) + (*(_BYTE *)(a2 + 4) << 8));
    }
    else if ( (signed int)(unsigned __int16)v3 > 1026 )
    {
      if ( (unsigned __int16)v3 == 1284 )
      {
        if ( sub_1006A0A0(2, (int)&v45, 8) )
        {
          v45 = 0;
          v46 = 0;
        }
        sub_10019BD0(0, 1792, &v45, 8);
      }
    }
    else if ( (unsigned __int16)v3 == 1026 )
    {
      while ( (unsigned __int8)j_HWM_pvg_uart_tx_busy(0) )
        sub_10069910(&v54);
      v4 = *(_DWORD *)(a2 + 4);
      dword_104DA744 = v4;
      if ( v4 < 57600 )
      {
        if ( v4 < 38400 )
        {
          if ( v4 < 28800 )
          {
            LOBYTE(a1) = v4 >= 19200;
            v5 = 2 * a1 + 6;
          }
          else
          {
            LOBYTE(v5) = 9;
          }
        }
        else
        {
          LOBYTE(v5) = 10;
        }
      }
      else
      {
        LOBYTE(v5) = 11;
      }
      LOBYTE(v41) = v5;
      j_HWM_pvg_set_uart(0, v41, 4, 23);
      byte_104DA741 = v5;
    }
    else if ( (signed int)(unsigned __int16)v3 >= 256 )
    {
      if ( (signed int)(unsigned __int16)v3 <= 259 )
      {
        sub_10019E90(v3, (__int16 *)(a2 + 4));
        v56 = -32703;
        sub_1003EB70((int)&v56);
      }
      else if ( (unsigned __int16)v3 == 1025 )
      {
        dword_104DA744 = *(_DWORD *)(a2 + 4);
        if ( dword_104DA744 < 115200 )
        {
          if ( dword_104DA744 < 57600 )
          {
            if ( dword_104DA744 < 38400 )
            {
              if ( dword_104DA744 < 28800 )
              {
                LOBYTE(v3) = dword_104DA744 >= 19200;
                v3 = 2 * v3 + 6;
              }
              else
              {
                LOBYTE(v3) = 9;
              }
            }
            else
            {
              LOBYTE(v3) = 10;
            }
          }
          else
          {
            LOBYTE(v3) = 11;
          }
        }
        else
        {
          LOBYTE(v3) = 12;
        }
        byte_104DA740 = v3;
        dword_104DA744 = j_HWM_pvg_get_real_baud(v3, 0);
        sub_10019BD0(0, 1026, &dword_104DA744, 4);
      }
    }
    return;
  }
  v6 = (unsigned __int16)v3 - 2312;
  if ( v6 )
  {
    v7 = v6 - 1;
    if ( !v7 )
    {
      LOBYTE(v42) = *(_BYTE *)(a2 + 4);
      *(int *)((char *)&v42 + 2) = (signed __int16)j_HWM_pvg_get_raw_adc(v42);
      BYTE1(v42) = 0;
      sub_10019BD0(0, 2307, &v42, 6);
      return;
    }
    if ( v7 == 3 )
    {
      v8 = *(_DWORD *)(a2 + 4);
      v9 = *(_WORD *)(a2 + 8);
      v31 = *(_DWORD *)(a2 + 4);
      v32 = v9;
      if ( (unsigned __int8)v31 >= 0x18u || BYTE1(v8) != 1 || (_BYTE)v31 == 15 )
      {
        BYTE1(v31) = 0;
        *(int *)((char *)&v31 + 2) = 0;
      }
      else
      {
        BYTE1(v31) = 1;
        *(int *)((char *)&v31 + 2) = j_HWM_pvg_read_reg(v31);
      }
      v28 = 6;
      v27 = &v31;
      goto LABEL_47;
    }
  }
  else if ( sub_10036FE0(v2) == 8 || sub_10036FE0(v10) == 2 )
  {
    v11 = *(_BYTE *)(a2 + 5);
    v33 = *(_BYTE *)(a2 + 4);
    LOBYTE(v34) = v11;
    *(_WORD *)((char *)&v34 + 1) = 1;
    if ( v33 )
    {
      if ( v33 != 1 )
      {
        BYTE1(v34) = 0;
        sub_10019BD0(0, 2317, &v33, 4);
        return;
      }
      v12 = j_HWM_pvg_lpbk_ethr(v34);
    }
    else
    {
      v12 = j_HWM_pvg_lpbk_uart(v34);
    }
    BYTE2(v34) = v12;
    sub_10019BD0(0, 2317, &v33, 4);
  }
}
// 10019BD0: using guessed type _DWORD __cdecl sub_10019BD0(_DWORD, _DWORD, _DWORD, _DWORD);
// 1006BB20: using guessed type int __cdecl j_HWM_pvg_get_raw_adc(_DWORD);
// 1006BB30: using guessed type int __cdecl j_HWM_pvg_get_real_baud(_DWORD, _DWORD);
// 1006BB90: using guessed type int __cdecl j_HWM_pvg_lpbk_ethr(_DWORD);
// 1006BBA0: using guessed type int __cdecl j_HWM_pvg_lpbk_uart(_DWORD);
// 1006BBD0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1006BBE0: using guessed type int __cdecl j_HWM_pvg_set_anlg_outp(_DWORD, _DWORD, _DWORD);
// 1006BBF0: using guessed type int __cdecl j_HWM_pvg_set_decoder_cfg(_DWORD);
// 1006BC00: using guessed type int __cdecl j_HWM_pvg_set_reg(_DWORD, _DWORD);
// 1006BC10: using guessed type int __cdecl j_HWM_pvg_set_uart(_DWORD, _DWORD, _DWORD, _DWORD);
// 1006BC20: using guessed type int __cdecl j_HWM_pvg_uart_tx_busy(_DWORD);
// 104DA71C: using guessed type int dword_104DA71C;
// 104DA740: using guessed type char byte_104DA740;
// 104DA741: using guessed type char byte_104DA741;
// 104DA744: using guessed type int dword_104DA744;
// 104DAB54: using guessed type int dword_104DAB54;

//----- (1001C1E0) --------------------------------------------------------
void __usercall sub_1001C1E0(int a1@<ecx>, int a2@<ebx>)
{
  __int16 v2; // dx@3
  __int16 v3; // si@3
  int v4; // [sp+0h] [bp-4h]@1

  v4 = a1;
  if ( !byte_104DA743 && sub_10019BE0(0, &byte_104DA748) )
  {
    LOBYTE(v2) = 0;
    HIBYTE(v2) = byte_104DA748;
    v3 = (unsigned __int8)byte_104DA749 | v2;
    LOBYTE(v2) = 0;
    HIBYTE(v2) = byte_104DA749;
    v4 = (unsigned __int16)((unsigned __int8)byte_104DA748 | v2);
    if ( v3 == 30979 )
    {
      byte_104DA743 = 1;
    }
    else
    {
      if ( v3 != 1536 && v3 != 5376 )
        sub_10019BD0(0, 1536, &v4, 2);
      sub_1001B7C0(a2, (int)&byte_104DA748);
    }
  }
}
// 10019BD0: using guessed type _DWORD __cdecl sub_10019BD0(_DWORD, _DWORD, _DWORD, _DWORD);
// 104DA743: using guessed type char byte_104DA743;
// 104DA744: using guessed type int dword_104DA744;
// 104DA748: using guessed type char byte_104DA748;
// 104DA749: using guessed type char byte_104DA749;

//----- (1001C270) --------------------------------------------------------
#error "1001C289: call analysis failed (funcsize=34)"

//----- (1001C300) --------------------------------------------------------
int __cdecl sub_1001C300(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@17

  if ( a2 < 0 )
    a2 = 0;
  if ( a3 < 0 )
    a3 = 0;
  if ( a4 < 1 )
    a4 = 1;
  if ( a5 < 1 )
    a5 = 1;
  if ( a2 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a2 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - 1;
  if ( a4 + a2 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a4 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - a2;
  if ( a3 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a3 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - 1;
  if ( a5 + a3 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a5 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - a3;
  *(_WORD *)(a1 + 26) = a2;
  HIWORD(result) = HIWORD(a1);
  *(_WORD *)(a1 + 30) = a4;
  LOWORD(result) = a3;
  *(_WORD *)(a1 + 24) = a3;
  *(_WORD *)(a1 + 28) = a5;
  return result;
}

//----- (1001C410) --------------------------------------------------------
int __cdecl sub_1001C410(int a1, _BYTE *a2, int a3)
{
  int result; // eax@2

  if ( *(_BYTE *)(a1 + 2) )
    result = 0;
  else
    result = sub_1001CE60(a1, a2, a3);
  return result;
}

//----- (1001C450) --------------------------------------------------------
char __cdecl sub_1001C450(char a1, char a2)
{
  char result; // al@1

  result = a1;
  byte_104DACB1 = a1;
  byte_104DACB0 = a2;
  return result;
}
// 104DACB0: using guessed type char byte_104DACB0;
// 104DACB1: using guessed type char byte_104DACB1;

//----- (1001C470) --------------------------------------------------------
int __cdecl sub_1001C470(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7)
{
  int result; // eax@12
  __int16 v8; // ST1C_2@20
  __int16 v9; // ST1E_2@43
  __int16 v10; // ST1C_2@56
  __int16 v11; // [sp+8h] [bp-8Ch]@17
  __int16 v12; // [sp+8h] [bp-8Ch]@43
  __int16 v13; // [sp+Ah] [bp-8Ah]@17
  __int16 v14; // [sp+Ah] [bp-8Ah]@43
  __int16 *v15; // [sp+10h] [bp-84h]@3
  unsigned __int8 v16; // [sp+17h] [bp-7Dh]@1
  int v17; // [sp+18h] [bp-7Ch]@47
  int v18; // [sp+1Ch] [bp-78h]@17
  int v19; // [sp+20h] [bp-74h]@11
  __int16 v20; // [sp+28h] [bp-6Ch]@29
  int v21; // [sp+2Ch] [bp-68h]@50
  int v22; // [sp+30h] [bp-64h]@47
  int i; // [sp+34h] [bp-60h]@13
  signed int v24; // [sp+38h] [bp-5Ch]@15
  unsigned __int8 v25; // [sp+3Eh] [bp-56h]@1
  bool v26; // [sp+3Fh] [bp-55h]@1
  char v27; // [sp+40h] [bp-54h]@45
  __int16 v28; // [sp+44h] [bp-50h]@43
  __int16 v29; // [sp+46h] [bp-4Eh]@56
  char v30; // [sp+48h] [bp-4Ch]@43
  char v31; // [sp+49h] [bp-4Bh]@46
  __int16 v32; // [sp+4Ah] [bp-4Ah]@56
  unsigned __int8 v33; // [sp+4Fh] [bp-45h]@1
  int v34; // [sp+50h] [bp-44h]@15
  __int16 v35; // [sp+54h] [bp-40h]@22
  int v36; // [sp+58h] [bp-3Ch]@45
  int v37; // [sp+5Ch] [bp-38h]@44
  int v38; // [sp+60h] [bp-34h]@28
  __int16 v39; // [sp+64h] [bp-30h]@17
  __int16 v40; // [sp+66h] [bp-2Eh]@17
  __int16 v41; // [sp+68h] [bp-2Ch]@55
  __int16 v42; // [sp+6Ah] [bp-2Ah]@55
  unsigned __int16 v43; // [sp+6Ch] [bp-28h]@24
  int v44; // [sp+70h] [bp-24h]@29
  char v45; // [sp+75h] [bp-1Fh]@43
  unsigned __int8 v46; // [sp+76h] [bp-1Eh]@1
  char v47; // [sp+77h] [bp-1Dh]@43
  int v48; // [sp+78h] [bp-1Ch]@22
  int v49; // [sp+7Ch] [bp-18h]@23
  __int16 v50; // [sp+80h] [bp-14h]@55
  __int16 v51; // [sp+82h] [bp-12h]@55
  __int16 v52; // [sp+84h] [bp-10h]@24
  int v53; // [sp+88h] [bp-Ch]@4
  int v54; // [sp+8Ch] [bp-8h]@19
  __int16 v55; // [sp+90h] [bp-4h]@17

  v16 = (a5 & 0xE000u) >> 13;
  v46 = (unsigned __int8)(a5 & 0x70) >> 4;
  v25 = (a5 & 0x380u) >> 7;
  v33 = (a5 & 0x1C00u) >> 10;
  v26 = 1;
  if ( a5 & 0x40000000 || a5 & 0x80000000 )
  {
    v15 = &a6;
    if ( a5 & 0x40000000 )
    {
      v15 = (__int16 *)&a7;
      v53 = a6;
      v16 = (a6 & 0xFF000000) >> 24;
      v46 = a6;
      v25 = (unsigned __int16)(a6 & 0xFF00) >> 8;
      v33 = (a6 & 0xFF0000u) >> 16;
    }
    if ( a5 & 0x80000000 )
    {
      if ( *(_DWORD *)v15 )
      {
        if ( *(_DWORD *)v15 == 2 )
          v26 = sub_1001CCB0(a3) == 0;
        else
          v26 = 0;
      }
      else
      {
        v26 = 1;
      }
    }
  }
  v19 = 0;
  if ( *(_BYTE *)(a2 + 3) & 3 )
  {
    result = 0;
  }
  else
  {
    i = sub_1001C410(a2, a3, a5);
    if ( !a4 )
      a4 = i;
    v34 = a4;
    v24 = ((a5 & 0x3F0000u) >> 16) - 1;
    if ( v24 < 0 )
      v24 = *(_WORD *)(a2 + 28);
    v18 = *(_WORD *)(a2 + 22);
    v11 = *(_WORD *)(a1 + 46);
    v55 = *(_WORD *)(a1 + 44);
    v13 = v55 - (*(_WORD *)(a2 + 24) - 1);
    v39 = *(_WORD *)(a1 + 42);
    v40 = *(_WORD *)(a1 + 40);
    if ( a5 & 3 )
    {
      if ( (a5 & 3) == 1 )
      {
        v54 = v11 - v34 / 2;
        v11 -= i / 2;
      }
      else
      {
        v54 = v11;
      }
    }
    else
    {
      v8 = v11 + 1;
      v54 = v8 - v34;
      v11 = v8 - i;
    }
    v35 = v13;
    v48 = v18;
    if ( a5 & 0xC )
    {
      v35 += *(_WORD *)(a2 + 26);
      v48 -= v18 - *(_WORD *)(a2 + 24) + *(_WORD *)(a2 + 26);
      v54 -= v46;
      v49 = v25;
      v34 += v25 + v46;
      if ( (a5 & 0xC) == 4 )
      {
        v52 = *(_WORD *)(a1 + 6);
        v43 = *(_WORD *)(a1 + 50);
        *(_WORD *)(a1 + 6) = 3;
        *(_WORD *)(a1 + 50) = *(_WORD *)(a1 + 36);
        v49 = v33;
        v35 -= v33;
        v48 += v33;
        if ( v33 > (signed int)*(_WORD *)(a2 + 26) )
          sub_1001F350(a1, v54, v35, v34, v49 - *(_WORD *)(a2 + 26));
        v49 = v16;
        v48 += v16;
        if ( v16 > v18 - *(_WORD *)(a2 + 24) )
          sub_1001F350(a1, v54, v18 + v13, v34, v49 - (v18 - *(_WORD *)(a2 + 24)));
        v38 = v11 - v54;
        if ( i > a4 )
        {
          v20 = a4 + v11;
          v44 = v25;
        }
        else
        {
          v20 = i + v11;
          v44 = v34 - (i + v38);
        }
        if ( v38 > 0 )
          sub_1001F350(a1, v54, v35, v38, v48);
        if ( v44 > 0 )
          sub_1001F350(a1, v20, v35, v44, v48);
        *(_WORD *)(a1 + 50) = v43;
        *(_WORD *)(a1 + 6) = v52;
      }
    }
    if ( v35 <= v13 )
      v35 = 0;
    else
      v35 -= v13;
    if ( v48 >= v18 - v35 )
      v48 = v18 - v35;
    if ( i < a4 )
      a4 = i;
    v30 = 1;
    v47 = 0;
    v45 = (*(_BYTE *)(a2 + 3) & 3) << 6;
    v12 = v39 + v11;
    v9 = v40 + v13;
    v52 = *(_WORD *)(a1 + 4);
    *(_WORD *)(a1 + 4) = 2;
    v14 = v35 + v9;
    v28 = v18;
    if ( i )
    {
      v37 = (a5 & 0x3FC00000u) >> 22;
      for ( i = 0; !sub_1001CD50(a2, &a3, &v27, &v36, v26); i += v21 + (signed __int16)v36 )
      {
        v31 = v47;
        if ( v37 <= v36 )
        {
          v22 = 0;
          v17 = 0;
        }
        else
        {
          v22 = (v37 - v36) / 2;
          v17 = v37 - v36 - v22;
        }
        v21 = i <= 0 ? v22 : v22 + v24 + v19;
        if ( v36 + v21 + i > a4 )
          break;
        v19 = v17;
        v43 = *(_WORD *)(a1 + 38);
        if ( v21 > 0 && v43 != 0xFFFF )
        {
          *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
          v50 = v14;
          v51 = v12;
          v41 = v48;
          v42 = v21;
          sub_1001EE80(a1, (signed __int16)v21 + (v12 << 16), (signed __int16)v48 + (v14 << 16));
          *(_WORD *)(a1 + 38) = v43;
        }
        v10 = v21 + v12;
        *(_WORD *)(a1 + 8) = v14;
        *(_WORD *)(a1 + 10) = v10;
        *(_WORD *)(a1 + 16) = v48;
        *(_WORD *)(a1 + 18) = v36;
        v29 = v36;
        *(_WORD *)(a1 + 14) = 0;
        *(_WORD *)(a1 + 12) = v35;
        v32 = (v29 + 7) / 8;
        *(_DWORD *)(a1 + 56) = &v27;
        sub_1001D580(a1);
        v12 = v36 + v10;
      }
    }
    v43 = *(_WORD *)(a1 + 38);
    if ( i < a4 && v43 != 0xFFFF )
    {
      *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
      v50 = v14;
      v51 = v12;
      v41 = v48;
      v42 = a4 - i;
      sub_1001EE80(a1, (signed __int16)(a4 - i) + (v12 << 16), (signed __int16)v48 + (v14 << 16));
      *(_WORD *)(a1 + 38) = v43;
    }
    *(_WORD *)(a1 + 4) = v52;
    *(_WORD *)(a1 + 46) = v19 + v12 - v39;
    *(_WORD *)(a1 + 44) = v55;
    result = v19 + i;
  }
  return result;
}

//----- (1001CCB0) --------------------------------------------------------
bool __cdecl sub_1001CCB0(_BYTE *a1)
{
  char v3; // [sp+6h] [bp-2h]@1
  char v4; // [sp+7h] [bp-1h]@1

  v3 = 0;
  v4 = 0;
  while ( *a1 )
  {
    if ( (signed int)*a1 < 48 || (signed int)*a1 > 57 )
    {
      if ( (signed int)*a1 >= 97 && (signed int)*a1 <= 122 || (signed int)*a1 >= 65 && (signed int)*a1 <= 90 )
        v3 = 1;
    }
    else
    {
      v4 = 1;
    }
    ++a1;
  }
  return v3 && v4;
}

//----- (1001CD50) --------------------------------------------------------
bool __cdecl sub_1001CD50(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5)
{
  int v5; // ST18_4@9
  int v7; // [sp+4h] [bp-1Ch]@7
  bool v8; // [sp+Bh] [bp-15h]@1
  unsigned int v9; // [sp+10h] [bp-10h]@7
  int v10; // [sp+14h] [bp-Ch]@1

  v10 = *(_BYTE *)(*a2)++;
  v8 = v10 == 0;
  if ( byte_104DACB1 && a5 && v10 == 48 )
    v10 = (unsigned __int8)byte_104DACB0;
  if ( !v8 )
  {
    if ( *(_BYTE *)(a1 + 2) )
    {
      v8 = 1;
    }
    else
    {
      v7 = *(_DWORD *)(a1 + 8) + a1;
      v9 = v10 - *(_BYTE *)(v7 + 2);
      if ( v9 >= *(_WORD *)v7 )
        v9 = *(_BYTE *)(v7 + 3);
      v5 = *(_DWORD *)(a1 + 12) + a1 + 4 * v9;
      *a3 = ((*(_BYTE *)(v5 + 2) << 16) | *(_WORD *)v5) + *(_DWORD *)(a1 + 16) + a1;
      *a4 = *(_BYTE *)(v5 + 3);
    }
  }
  return v8;
}
// 104DACB0: using guessed type char byte_104DACB0;
// 104DACB1: using guessed type char byte_104DACB1;

//----- (1001CE60) --------------------------------------------------------
int __cdecl sub_1001CE60(int a1, _BYTE *a2, int a3)
{
  int v3; // ST00_4@5
  unsigned int v5; // [sp+0h] [bp-20h]@5
  int v6; // [sp+4h] [bp-1Ch]@3
  int v7; // [sp+8h] [bp-18h]@3
  int v8; // [sp+Ch] [bp-14h]@3
  signed int v9; // [sp+10h] [bp-10h]@1
  signed int v10; // [sp+14h] [bp-Ch]@8
  signed int v11; // [sp+18h] [bp-8h]@1
  _BYTE *v12; // [sp+1Ch] [bp-4h]@3

  v11 = (a3 & 0x3FC00000u) >> 22;
  v9 = ((a3 & 0x3F0000u) >> 16) - 1;
  if ( v9 < 0 )
    v9 = *(_WORD *)(a1 + 28);
  v12 = a2;
  v6 = *(_DWORD *)(a1 + 12) + a1;
  v7 = *(_DWORD *)(a1 + 8) + a1;
  v8 = 0;
  while ( *v12 )
  {
    v3 = *v12++;
    v5 = v3 - *(_BYTE *)(v7 + 2);
    if ( v8 > 0 )
      v8 += v9;
    if ( v5 < *(_WORD *)v7 )
      v10 = *(_BYTE *)(v6 + 4 * v5 + 3);
    else
      v10 = *(_BYTE *)(v6 + 4 * *(_BYTE *)(v7 + 3) + 3);
    if ( v11 <= v10 )
      v8 += v10;
    else
      v8 += v11;
  }
  return v8;
}

//----- (1001CF50) --------------------------------------------------------
int __cdecl sub_1001CF50(int a1, __int16 a2, __int16 a3, char a4)
{
  int result; // eax@25
  signed int v5; // [sp+4h] [bp-30h]@29
  int v6; // [sp+8h] [bp-2Ch]@44
  int v7; // [sp+8h] [bp-2Ch]@54
  __int16 v8; // [sp+Ch] [bp-28h]@31
  char (__cdecl *v9)(int); // [sp+10h] [bp-24h]@2
  char *(__cdecl *v10)(int); // [sp+14h] [bp-20h]@5
  __int16 v11; // [sp+18h] [bp-1Ch]@31
  signed int v12; // [sp+1Ch] [bp-18h]@31
  __int16 v13; // [sp+20h] [bp-14h]@41
  __int16 v14; // [sp+28h] [bp-Ch]@29
  __int16 v15; // [sp+2Ch] [bp-8h]@29
  __int16 v16; // [sp+30h] [bp-4h]@41

  if ( *(_DWORD *)(a1 + 72) )
    v9 = *(char (__cdecl **)(int))(a1 + 72);
  else
    v9 = sub_1001F4F0;
  if ( *(_DWORD *)(a1 + 76) )
    v10 = *(char *(__cdecl **)(int))(a1 + 76);
  else
    v10 = sub_1001F6C0;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + *(_WORD *)(a1 + 46);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + *(_WORD *)(a1 + 44);
  *(_WORD *)(a1 + 14) = *(_WORD *)(a1 + 42) + a2;
  *(_WORD *)(a1 + 12) = *(_WORD *)(a1 + 40) + a3;
  *(_WORD *)(a1 + 46) = a2;
  *(_WORD *)(a1 + 44) = a3;
  if ( a4 & 1 )
  {
    if ( (signed int)*(_WORD *)(a1 + 10) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 10) < -8192 )
        *(_WORD *)(a1 + 10) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 10) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 8) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 8) < -8192 )
        *(_WORD *)(a1 + 8) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 8) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 14) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 14) < -8192 )
        *(_WORD *)(a1 + 14) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 14) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 12) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 12) < -8192 )
        *(_WORD *)(a1 + 12) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 12) = 0x1FFF;
    }
  }
  if ( *(_WORD *)(a1 + 10) != *(_WORD *)(a1 + 14) || (result = *(_WORD *)(a1 + 12), *(_WORD *)(a1 + 8) != result) )
  {
    v14 = *(_WORD *)(a1 + 14) - *(_WORD *)(a1 + 10);
    v15 = v14;
    v5 = 1;
    if ( v14 < 0 )
    {
      v5 = -1;
      v15 = -v14;
    }
    v8 = *(_WORD *)(a1 + 12) - *(_WORD *)(a1 + 8);
    v11 = v8;
    v12 = 1;
    if ( v8 < 0 )
    {
      v12 = -1;
      v11 = -v8;
    }
    if ( v15 )
    {
      if ( v11 )
      {
        v13 = 2 * v15;
        v16 = 2 * v11;
        if ( v15 <= v11 )
        {
          *(_WORD *)(a1 + 16) = 0;
          *(_WORD *)(a1 + 18) = 1;
          if ( v13 >= v11 )
            *(_WORD *)(a1 + 16) -= (v12 ^ v5) + 1;
          v7 = v13 - v11 - (v5 < 0);
          *(_WORD *)(a1 + 12) = 0;
          while ( v11 )
          {
            *(_WORD *)(a1 + 12) += v12;
            if ( v7 >= 0 )
            {
              v10(a1);
              *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
              *(_WORD *)(a1 + 12) = 0;
              *(_WORD *)(a1 + 10) += v5;
              v7 -= v16;
            }
            v7 += v13;
            --v11;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 12) += v12;
          v10(a1);
          result = a1;
          *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
        }
        else
        {
          *(_WORD *)(a1 + 16) = 1;
          *(_WORD *)(a1 + 18) = 0;
          if ( v16 >= v15 )
            *(_WORD *)(a1 + 18) -= (v12 ^ v5) + 1;
          v6 = v16 - v15 - (v12 < 0);
          *(_WORD *)(a1 + 14) = 0;
          while ( v15 )
          {
            *(_WORD *)(a1 + 14) += v5;
            if ( v6 >= 0 )
            {
              v9(a1);
              *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
              *(_WORD *)(a1 + 14) = 0;
              *(_WORD *)(a1 + 8) += v12;
              v6 -= v13;
            }
            v6 += v16;
            --v15;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 14) += v5;
          v9(a1);
          result = a1;
          *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
        }
      }
      else
      {
        *(_WORD *)(a1 + 16) = 1;
        *(_WORD *)(a1 + 18) = 0;
        *(_WORD *)(a1 + 14) = v14;
        if ( a4 & 2 )
          *(_WORD *)(a1 + 14) += v5;
        result = v9(a1);
      }
    }
    else
    {
      *(_WORD *)(a1 + 16) = 0;
      *(_WORD *)(a1 + 18) = 1;
      *(_WORD *)(a1 + 12) = v8;
      if ( a4 & 2 )
        *(_WORD *)(a1 + 12) += v12;
      result = (int)v10(a1);
    }
  }
  else if ( a4 & 2 )
  {
    *(_WORD *)(a1 + 12) = 1;
    result = (int)v10(a1);
  }
  return result;
}

//----- (1001D4A0) --------------------------------------------------------
unsigned int __cdecl sub_1001D4A0(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  unsigned int result; // eax@2
  int v9; // [sp+8h] [bp+8h]@1

  v9 = sub_1001DFE0(a1, a2, a3, a4, a5, a6, a7, a8);
  if ( *(_BYTE *)(*(_DWORD *)(v9 + 52) + 8) == 8 )
  {
    if ( *(_DWORD *)(v9 + 68) )
    {
      if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 1 )
      {
        *(_WORD *)(v9 + 38) = **(_WORD **)(v9 + 68);
        *(_WORD *)(v9 + 36) = *(_WORD *)(*(_DWORD *)(v9 + 68) + 2);
        result = sub_1001D580(v9);
      }
      else
      {
        result = sub_1001DAB0(v9);
      }
    }
    else if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 8 )
    {
      result = sub_1001D8D0(v9);
    }
    else
    {
      result = sub_1001DAB0(v9);
    }
  }
  else
  {
    result = sub_1001DAB0(v9);
  }
  return result;
}

//----- (1001D580) --------------------------------------------------------
int __cdecl sub_1001D580(int a1)
{
  int result; // eax@1
  int v2; // ST1C_4@10
  int v3; // [sp+0h] [bp-44h]@3
  unsigned int v4; // [sp+4h] [bp-40h]@5
  unsigned int v5; // [sp+4h] [bp-40h]@9
  unsigned __int16 v6; // [sp+8h] [bp-3Ch]@3
  int v7; // [sp+Ch] [bp-38h]@5
  unsigned __int16 v8; // [sp+10h] [bp-34h]@3
  unsigned __int16 v9; // [sp+14h] [bp-30h]@2
  signed int v10; // [sp+1Ch] [bp-28h]@9
  unsigned int *v11; // [sp+20h] [bp-24h]@9
  int v12; // [sp+24h] [bp-20h]@11
  int v13; // [sp+28h] [bp-1Ch]@9
  unsigned int v14; // [sp+2Ch] [bp-18h]@9
  unsigned __int16 v15; // [sp+30h] [bp-14h]@2
  unsigned int *v16; // [sp+34h] [bp-10h]@3
  int v17; // [sp+38h] [bp-Ch]@4
  unsigned int v18; // [sp+3Ch] [bp-8h]@2
  unsigned __int16 v19; // [sp+40h] [bp-4h]@2
  int v20; // [sp+4Ch] [bp+8h]@1

  result = sub_10020740(a1);
  v20 = result;
  if ( result )
  {
    v19 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v18 = ((unsigned int)*(_WORD *)(result + 14) >> 3)
        + *(_WORD *)(result + 12) * *(_WORD *)(*(_DWORD *)(result + 56) + 10)
        + **(_DWORD **)(result + 56);
    v9 = 8 * (*(_WORD *)(result + 14) >> 3) - *(_WORD *)(result + 14) + 8;
    v15 = *(_WORD *)(*(_DWORD *)(result + 52) + 10);
    if ( !(*(_WORD *)(*(_DWORD *)(result + 52) + 10) << 30) )
    {
      v16 = (unsigned int *)(**(_DWORD **)(result + 52)
                           + *(_WORD *)(result + 8) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                           + 4 * (8 * *(_WORD *)(result + 10) >> 5));
      v8 = 32 * (8 * *(_WORD *)(result + 10) >> 5) - 8 * *(_WORD *)(result + 10) + 32;
      v3 = *(_WORD *)(result + 16);
      v6 = *(_WORD *)(result + 18);
      do
      {
        v17 = v9;
        if ( v18 << 31 )
        {
          v4 = *(_BYTE *)v18;
          v7 = v18 + 1;
        }
        else if ( v18 << 30 )
        {
          v4 = *(_WORD *)v18;
          v7 = v18 + 2;
          v17 = v9 + 8;
        }
        else
        {
          v4 = *(_DWORD *)v18;
          v7 = v18 + 4;
          v17 = v9 + 24;
        }
        v5 = (v4 >> ((-v9 + 8) & 0x1F)) | (v4 << (32 - ((-v9 + 8) & 0x1F)));
        v10 = v8;
        v11 = v16;
        v14 = (*v16 >> ((32 - v8) & 0x1F)) | (*v16 << (32 - ((32 - v8) & 0x1F)));
        v13 = v6;
        do
        {
          v2 = 2 * v5 & 3;
          v5 >>= 1;
          if ( v2 )
            v12 = *(_WORD *)(v20 + 38);
          else
            v12 = *(_WORD *)(v20 + 36);
          if ( (signed __int16)v12 >= 0 )
            v14 = (v14 >> 8) | (v12 << 24);
          else
            v14 = (v14 >> 8) | (v14 << 24);
          if ( --v13 )
          {
            v10 -= 8;
            if ( !v10 )
            {
              *v11 = v14;
              ++v11;
              v10 = 32;
              v14 = *v11;
            }
            if ( !--v17 )
            {
              if ( v7 << 30 )
              {
                v17 = 16;
                v5 = *(_WORD *)v7;
                v7 += 2;
              }
              else
              {
                v17 = 32;
                v5 = *(_DWORD *)v7;
                v7 += 4;
              }
            }
          }
        }
        while ( v13 );
        *v11 = (v14 >> ((v10 - 8) & 0x1F)) | (v14 << (32 - ((v10 - 8) & 0x1F)));
        v18 += v19;
        result = (int)v16 + v15;
        v16 = (unsigned int *)((char *)v16 + v15);
        --v3;
      }
      while ( v3 );
    }
  }
  return result;
}

//----- (1001D8D0) --------------------------------------------------------
int __cdecl sub_1001D8D0(int a1)
{
  int result; // eax@1
  signed int v2; // [sp+4h] [bp-30h]@16
  int v3; // [sp+8h] [bp-2Ch]@9
  char *v4; // [sp+Ch] [bp-28h]@4
  _BYTE *v5; // [sp+Ch] [bp-28h]@10
  _BYTE *v6; // [sp+Ch] [bp-28h]@12
  _BYTE *v7; // [sp+Ch] [bp-28h]@14
  char *v8; // [sp+10h] [bp-24h]@4
  _BYTE *v9; // [sp+10h] [bp-24h]@10
  _BYTE *v10; // [sp+10h] [bp-24h]@12
  _BYTE *v11; // [sp+10h] [bp-24h]@14
  unsigned int v12; // [sp+14h] [bp-20h]@4
  int v13; // [sp+14h] [bp-20h]@10
  int v14; // [sp+14h] [bp-20h]@12
  int v15; // [sp+18h] [bp-1Ch]@2
  int v16; // [sp+1Ch] [bp-18h]@2
  int v17; // [sp+20h] [bp-14h]@2
  size_t v18; // [sp+24h] [bp-10h]@2
  char *v19; // [sp+28h] [bp-Ch]@2
  int v20; // [sp+2Ch] [bp-8h]@2
  char *v21; // [sp+30h] [bp-4h]@2
  _BYTE *v22; // [sp+3Ch] [bp+8h]@1

  result = sub_10020740(a1);
  v22 = (_BYTE *)result;
  if ( result )
  {
    v18 = *(_WORD *)(result + 18);
    v15 = *(_WORD *)(result + 16);
    v17 = *(_WORD *)(*(_DWORD *)(result + 52) + 10);
    v16 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v21 = (char *)(*(_WORD *)(result + 14) + v16 * *(_WORD *)(result + 12) + **(_DWORD **)(result + 56));
    v19 = (char *)(*(_WORD *)(result + 10) + v17 * *(_WORD *)(result + 8) + **(_DWORD **)(result + 52));
    v20 = 0;
    do
    {
      if ( v20 )
        goto LABEL_26;
      v12 = v18;
      v8 = v21;
      v4 = v19;
      while ( v12 >= 4 )
      {
        if ( *(_DWORD *)v4 != *(_DWORD *)v8 )
          goto LABEL_9;
        v12 -= 4;
        v8 += 4;
        v4 += 4;
      }
      if ( !v12 )
      {
LABEL_16:
        v2 = 0;
        goto LABEL_19;
      }
LABEL_9:
      v3 = (unsigned __int8)*v4 - (unsigned __int8)*v8;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v8 )
      {
        v13 = v12 - 1;
        v9 = v8 + 1;
        v5 = v4 + 1;
        if ( !v13 )
          goto LABEL_16;
        v3 = *v5 - *v9;
        if ( *v5 == *v9 )
        {
          v14 = v13 - 1;
          v10 = v9 + 1;
          v6 = v5 + 1;
          if ( !v14 )
            goto LABEL_16;
          v3 = *v6 - *v10;
          if ( *v6 == *v10 )
          {
            v11 = v10 + 1;
            v7 = v6 + 1;
            if ( v14 == 1 )
              goto LABEL_16;
            v3 = *v7 - *v11;
            if ( *v7 == *v11 )
              goto LABEL_16;
          }
        }
      }
      v2 = 1;
      if ( v3 <= 0 )
        v2 = -1;
LABEL_19:
      if ( v2 )
      {
LABEL_26:
        ++v20;
        memcpy_0(v19, v21, v18);
      }
      v21 += v16;
      v19 += v17;
      result = v15-- - 1;
    }
    while ( v15 );
    if ( !v20 )
      *v22 = 0;
  }
  return result;
}

//----- (1001DAB0) --------------------------------------------------------
unsigned int __cdecl sub_1001DAB0(int a1)
{
  unsigned int result; // eax@1
  unsigned int v2; // ST08_4@5
  unsigned int v3; // ST28_4@6
  int v4; // ST28_4@13
  int v5; // [sp+0h] [bp-50h]@4
  unsigned int v6; // [sp+4h] [bp-4Ch]@5
  int v7; // [sp+8h] [bp-48h]@4
  unsigned __int16 v8; // [sp+Ch] [bp-44h]@4
  int *v9; // [sp+10h] [bp-40h]@5
  unsigned __int16 v10; // [sp+14h] [bp-3Ch]@4
  int v11; // [sp+18h] [bp-38h]@3
  int v12; // [sp+18h] [bp-38h]@5
  unsigned __int16 v13; // [sp+20h] [bp-30h]@3
  unsigned int *v14; // [sp+2Ch] [bp-24h]@5
  signed int v15; // [sp+30h] [bp-20h]@13
  int v16; // [sp+34h] [bp-1Ch]@5
  unsigned int v17; // [sp+38h] [bp-18h]@5
  unsigned __int16 v18; // [sp+3Ch] [bp-14h]@3
  unsigned int *v19; // [sp+40h] [bp-10h]@4
  int v20; // [sp+48h] [bp-8h]@2
  int v21; // [sp+48h] [bp-8h]@3
  unsigned __int16 v22; // [sp+4Ch] [bp-4h]@2
  unsigned int v23; // [sp+58h] [bp+8h]@1

  result = sub_10020740(a1);
  v23 = result;
  if ( result )
  {
    v22 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v20 = **(_DWORD **)(result + 56) + *(_WORD *)(result + 12) * *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    result = *(_DWORD *)(result + 56);
    if ( (unsigned int)*(_BYTE *)(result + 8) < 9 )
    {
      v21 = v20 + 4 * ((signed int)*(_WORD *)(v23 + 14) << byte_10099608[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)] >> 5);
      v13 = 32 - ((*(_WORD *)(v23 + 14) << byte_10099608[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)]) & 0x1F);
      v18 = *(_WORD *)(*(_DWORD *)(v23 + 52) + 10);
      v11 = *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8) | (*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8) << 8);
      result = *(_BYTE *)(*(_DWORD *)(v23 + 52) + 8);
      if ( result < 9 )
      {
        v19 = (unsigned int *)(**(_DWORD **)(v23 + 52)
                             + *(_WORD *)(v23 + 8) * *(_WORD *)(*(_DWORD *)(v23 + 52) + 10)
                             + 4
                             * ((signed int)*(_WORD *)(v23 + 10) << byte_10099608[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)] >> 5));
        v10 = 32 - ((*(_WORD *)(v23 + 10) << byte_10099608[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)]) & 0x1F);
        v8 = *(_WORD *)(v23 + 18);
        v5 = *(_WORD *)(v23 + 16);
        v7 = (1 << *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)) - 1;
        do
        {
          v2 = *(_DWORD *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5));
          v9 = (int *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 4);
          v6 = (v2 >> (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)) | (v2 << (32 - (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)));
          v14 = v19;
          v17 = (*v19 >> (31 * v10 & 0x1F)) | (*v19 << (32 - (31 * v10 & 0x1F)));
          v12 = (unsigned __int16)v11 | (((v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 127) | ((v10 + 127) << 8)) << 16);
          v16 = v8;
          if ( *(_DWORD *)(v23 + 68) )
          {
            do
            {
              v4 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v15 = *(_WORD *)(*(_DWORD *)(v23 + 68) + 2 * v4);
              if ( (signed __int16)v15 >= 0 )
                v17 = (v15 >> (BYTE1(v12) & 0x1F)) | (v15 << (32 - (BYTE1(v12) & 0x1F))) | ((unsigned __int64)v17 >> SBYTE1(v12));
              else
                v17 = (v17 >> (BYTE1(v12) & 0x1F)) | (v17 << (32 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( (signed __int16)v16 > 0 );
          }
          else
          {
            do
            {
              v3 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v17 = ((unsigned __int64)v17 >> SBYTE1(v12)) | (v3 >> (BYTE1(v12) & 0x1F)) | (v3 << (32
                                                                                                 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( v16 );
          }
          v11 = -65535 * v12;
          *v14 = (v17 >> ((BYTE3(v11) - 127) & 0x1F)) | (v17 << (32 - ((BYTE3(v11) - 127) & 0x1F)));
          v21 += v22;
          result = (unsigned int)v19 + v18;
          v19 = (unsigned int *)((char *)v19 + v18);
          --v5;
        }
        while ( v5 );
      }
    }
  }
  return result;
}

//----- (1001DFE0) --------------------------------------------------------
int __cdecl sub_1001DFE0(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  *(_DWORD *)(a1 + 56) = a2;
  *(_WORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 12) = a4;
  *(_WORD *)(a1 + 10) = a5;
  *(_WORD *)(a1 + 8) = a6;
  *(_WORD *)(a1 + 18) = a7;
  *(_WORD *)(a1 + 16) = a8;
  return a1;
}

//----- (1001E040) --------------------------------------------------------
_WORD *__cdecl sub_1001E040(int a1)
{
  _WORD *result; // eax@1

  result = (_WORD *)a1;
  if ( *(_WORD *)(a1 + 36) != 0xFFFF )
  {
    result = *(_WORD **)(a1 + 52);
    if ( !(result[5] << 30) )
    {
      *(_BYTE *)a1 = 1;
      result = memset(
                 **(void ***)(a1 + 52),
                 *(_WORD *)(a1 + 36),
                 *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 4));
    }
  }
  return result;
}

//----- (1001E0A0) --------------------------------------------------------
int __cdecl sub_1001E0A0(int a1, int a2, char a3)
{
  int result; // eax@1

  *(_DWORD *)(a1 + 52) = a2;
  sub_1001C300(a1, 0, 0, *(_WORD *)(a2 + 6), *(_WORD *)(a2 + 4));
  *(_WORD *)(a1 + 42) = 0;
  *(_WORD *)(a1 + 40) = 0;
  *(_WORD *)(a1 + 46) = 0;
  *(_WORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_WORD *)(a1 + 2) = 1;
  *(_WORD *)(a1 + 34) = 1;
  *(_WORD *)(a1 + 32) = 1;
  *(_WORD *)(a1 + 4) = 3;
  *(_WORD *)(a1 + 36) = -1;
  *(_WORD *)(a1 + 38) = -1;
  *(_WORD *)(a1 + 6) = 3;
  *(_WORD *)(a1 + 48) = -1;
  *(_WORD *)(a1 + 50) = -1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  result = a1;
  *(_BYTE *)a1 = a3;
  return result;
}

//----- (1001E190) --------------------------------------------------------
char __cdecl sub_1001E190(int a1, __int16 a2, __int16 a3, __int16 a4, char a5)
{
  int v5; // ST3C_4@5
  char result; // al@5
  char v7; // [sp+0h] [bp-64h]@52
  char v8; // [sp+4h] [bp-60h]@46
  char v9; // [sp+8h] [bp-5Ch]@40
  char v10; // [sp+Ch] [bp-58h]@34
  char v11; // [sp+10h] [bp-54h]@28
  char v12; // [sp+14h] [bp-50h]@22
  char v13; // [sp+18h] [bp-4Ch]@16
  char v14; // [sp+1Ch] [bp-48h]@10
  __int16 v15; // [sp+24h] [bp-40h]@1
  int v16; // [sp+28h] [bp-3Ch]@58
  __int16 v17; // [sp+2Ch] [bp-38h]@58
  __int16 v18; // [sp+30h] [bp-34h]@58
  __int16 v19; // [sp+34h] [bp-30h]@58
  __int16 v20; // [sp+38h] [bp-2Ch]@6
  __int16 v21; // [sp+3Ch] [bp-28h]@1
  char v22; // [sp+40h] [bp-24h]@56
  char v23; // [sp+41h] [bp-23h]@64
  char v24; // [sp+42h] [bp-22h]@68
  char v25; // [sp+43h] [bp-21h]@76
  char v26; // [sp+44h] [bp-20h]@72
  char v27; // [sp+45h] [bp-1Fh]@66
  char v28; // [sp+46h] [bp-1Eh]@62
  char v29; // [sp+47h] [bp-1Dh]@70
  int v30; // [sp+48h] [bp-1Ch]@54
  __int16 v31; // [sp+4Ch] [bp-18h]@6
  char v32; // [sp+50h] [bp-14h]@48
  char v33; // [sp+51h] [bp-13h]@18
  char v34; // [sp+52h] [bp-12h]@30
  char v35; // [sp+53h] [bp-11h]@54
  char v36; // [sp+54h] [bp-10h]@42
  char v37; // [sp+55h] [bp-Fh]@24
  char v38; // [sp+56h] [bp-Eh]@12
  char v39; // [sp+57h] [bp-Dh]@36
  char v40; // [sp+5Fh] [bp-5h]@54
  __int16 v41; // [sp+60h] [bp-4h]@6

  v15 = *(_WORD *)(a1 + 42) + a2;
  v21 = *(_WORD *)(a1 + 40) + a3;
  if ( a5 & 1 )
    sub_100220B0(a1, a2, a3, a4);
  if ( *(_WORD *)(a1 + 4) != 4 || (signed int)*(_WORD *)(a1 + 2) <= 1 )
  {
    v31 = 46341 * a4 / 0x10000;
    v20 = v31 - 1;
    v41 = v31 + 1;
    if ( v15 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v41 + v15 < *(_WORD *)(a1 + 26)
      || v20 + v21 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || a4 + v21 < *(_WORD *)(a1 + 24) )
    {
      v14 = 0;
    }
    else
    {
      v14 = -1;
    }
    v38 = v14;
    if ( v15 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v41 + v15 < *(_WORD *)(a1 + 26)
      || v21 - a4 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v21 - v20 < *(_WORD *)(a1 + 24) )
    {
      v13 = 0;
    }
    else
    {
      v13 = -1;
    }
    v33 = v13;
    if ( v15 - v41 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v15 < (signed int)*(_WORD *)(a1 + 26)
      || v20 + v21 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || a4 + v21 < *(_WORD *)(a1 + 24) )
    {
      v12 = 0;
    }
    else
    {
      v12 = -1;
    }
    v37 = v12;
    if ( v15 - v41 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v15 < (signed int)*(_WORD *)(a1 + 26)
      || v21 - a4 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v21 - v20 < *(_WORD *)(a1 + 24) )
    {
      v11 = 0;
    }
    else
    {
      v11 = -1;
    }
    v34 = v11;
    if ( v20 + v15 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || a4 + v15 < *(_WORD *)(a1 + 26)
      || v21 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v41 + v21 < *(_WORD *)(a1 + 24) )
    {
      v10 = 0;
    }
    else
    {
      v10 = -1;
    }
    v39 = v10;
    if ( v15 - a4 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v15 - v20 < *(_WORD *)(a1 + 26)
      || v21 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v41 + v21 < *(_WORD *)(a1 + 24) )
    {
      v9 = 0;
    }
    else
    {
      v9 = -1;
    }
    v36 = v9;
    if ( v20 + v15 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || a4 + v15 < *(_WORD *)(a1 + 26)
      || v21 - v41 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v21 < (signed int)*(_WORD *)(a1 + 24) )
    {
      v8 = 0;
    }
    else
    {
      v8 = -1;
    }
    v32 = v8;
    if ( v15 - a4 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v15 - v20 < *(_WORD *)(a1 + 26)
      || v21 - v41 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v21 < (signed int)*(_WORD *)(a1 + 24) )
    {
      v7 = 0;
    }
    else
    {
      v7 = -1;
    }
    result = v7;
    v35 = v7;
    v30 = 0;
    v40 = 0;
    while ( v30 < 8 )
    {
      *(&v22 + v30) = *(_BYTE *)(a1 + 1);
      result = *(&v32 + v30);
      v40 |= result;
      ++v30;
    }
    if ( v40 )
    {
      v18 = 0;
      v19 = 0;
      v17 = a4;
      v16 = 1 - a4;
      while ( v19 < v17 )
      {
        if ( v16 >= 0 )
        {
          *(_WORD *)(a1 + 10) = v18 + v15;
          *(_WORD *)(a1 + 14) = v19 + 1 - v18;
          if ( v38 )
          {
            *(_WORD *)(a1 + 8) = v17 + v21;
            *(_BYTE *)(a1 + 1) = v28;
            sub_1001F4F0(a1);
            v28 = *(_BYTE *)(a1 + 1);
          }
          if ( v33 )
          {
            *(_WORD *)(a1 + 8) = v21 - v17;
            *(_BYTE *)(a1 + 1) = v23;
            sub_1001F4F0(a1);
            v23 = *(_BYTE *)(a1 + 1);
          }
          *(_WORD *)(a1 + 10) = v15 - v18;
          *(_WORD *)(a1 + 14) = v18 - v19 - 1;
          if ( v37 )
          {
            *(_WORD *)(a1 + 8) = v17 + v21;
            *(_BYTE *)(a1 + 1) = v27;
            sub_1001F4F0(a1);
            v27 = *(_BYTE *)(a1 + 1);
          }
          if ( v34 )
          {
            *(_WORD *)(a1 + 8) = v21 - v17;
            *(_BYTE *)(a1 + 1) = v24;
            sub_1001F4F0(a1);
            v24 = *(_BYTE *)(a1 + 1);
          }
          *(_WORD *)(a1 + 8) = v18 + v21;
          *(_WORD *)(a1 + 12) = v19 + 1 - v18;
          if ( v39 )
          {
            *(_WORD *)(a1 + 10) = v17 + v15;
            *(_BYTE *)(a1 + 1) = v29;
            sub_1001F6C0(a1);
            v29 = *(_BYTE *)(a1 + 1);
          }
          if ( v36 )
          {
            *(_WORD *)(a1 + 10) = v15 - v17;
            *(_BYTE *)(a1 + 1) = v26;
            sub_1001F6C0(a1);
            v26 = *(_BYTE *)(a1 + 1);
          }
          *(_WORD *)(a1 + 8) = v21 - v18;
          *(_WORD *)(a1 + 12) = v18 - v19 - 1;
          if ( v32 )
          {
            *(_WORD *)(a1 + 10) = v17 + v15;
            *(_BYTE *)(a1 + 1) = v22;
            sub_1001F6C0(a1);
            v22 = *(_BYTE *)(a1 + 1);
          }
          if ( v35 )
          {
            *(_WORD *)(a1 + 10) = v15 - v17;
            *(_BYTE *)(a1 + 1) = v25;
            sub_1001F6C0(a1);
            v25 = *(_BYTE *)(a1 + 1);
          }
          v18 = v19 + 1;
          v16 -= 2 * v17-- - 2;
        }
        v16 += 2 * v19++ + 3;
      }
      result = v17;
      if ( v19 == v17 )
      {
        *(_WORD *)(a1 + 10) = v18 + v15;
        *(_WORD *)(a1 + 14) = v19 + 1 - v18;
        if ( v38 )
        {
          *(_WORD *)(a1 + 8) = v17 + v21;
          *(_BYTE *)(a1 + 1) = v28;
          sub_1001F4F0(a1);
          v28 = *(_BYTE *)(a1 + 1);
        }
        if ( v33 )
        {
          *(_WORD *)(a1 + 8) = v21 - v17;
          *(_BYTE *)(a1 + 1) = v23;
          sub_1001F4F0(a1);
          v23 = *(_BYTE *)(a1 + 1);
        }
        *(_WORD *)(a1 + 10) = v15 - v18;
        *(_WORD *)(a1 + 14) = v18 - v19 - 1;
        if ( v37 )
        {
          *(_WORD *)(a1 + 8) = v17 + v21;
          *(_BYTE *)(a1 + 1) = v27;
          sub_1001F4F0(a1);
          v27 = *(_BYTE *)(a1 + 1);
        }
        if ( v34 )
        {
          *(_WORD *)(a1 + 8) = v21 - v17;
          *(_BYTE *)(a1 + 1) = v24;
          sub_1001F4F0(a1);
          v24 = *(_BYTE *)(a1 + 1);
        }
        *(_WORD *)(a1 + 8) = v18 + v21;
        *(_WORD *)(a1 + 12) = v19 + 1 - v18;
        if ( v39 )
        {
          *(_WORD *)(a1 + 10) = v17 + v15;
          *(_BYTE *)(a1 + 1) = v29;
          sub_1001F6C0(a1);
          v29 = *(_BYTE *)(a1 + 1);
        }
        if ( v36 )
        {
          *(_WORD *)(a1 + 10) = v15 - v17;
          *(_BYTE *)(a1 + 1) = v26;
          sub_1001F6C0(a1);
          v26 = *(_BYTE *)(a1 + 1);
        }
        *(_WORD *)(a1 + 8) = v21 - v18;
        result = a1;
        *(_WORD *)(a1 + 12) = v18 - v19 - 1;
        if ( v32 )
        {
          *(_WORD *)(a1 + 10) = v17 + v15;
          *(_BYTE *)(a1 + 1) = v22;
          sub_1001F6C0(a1);
          result = *(_BYTE *)(a1 + 1);
          v22 = *(_BYTE *)(a1 + 1);
        }
        if ( v35 )
        {
          *(_WORD *)(a1 + 10) = v15 - v17;
          *(_BYTE *)(a1 + 1) = v25;
          sub_1001F6C0(a1);
          result = *(_BYTE *)(a1 + 1);
        }
      }
    }
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 44);
    *(_WORD *)(a1 + 46) = a2;
    *(_WORD *)(a1 + 44) = a3 - a4;
    sub_10020910(a1, a2, a3, a4, 1, a2, a4 + a3);
    sub_10020910(a1, a2, a3, a4, 1, a2, a3 - a4);
    result = v5;
    *(_DWORD *)(a1 + 44) = v5;
  }
  return result;
}

//----- (1001EC10) --------------------------------------------------------
int __cdecl sub_1001EC10(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int result; // eax@1
  __int16 v7; // ST1C_2@8
  int v8; // [sp+0h] [bp-14h]@4
  int v9; // [sp+Ch] [bp-8h]@4
  __int16 v10; // [sp+10h] [bp-4h]@8
  __int16 v11; // [sp+28h] [bp+14h]@8
  __int16 v12; // [sp+2Ch] [bp+18h]@8

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v8 = *(_DWORD *)(a1 + 36);
    v9 = *(_DWORD *)(a1 + 36);
    if ( a6 & 1 )
      sub_1001F350(a1, a2, a3, a4, a5);
    if ( !(a6 & 2) )
      LOWORD(v9) = HIWORD(v9);
    v12 = a5 - 1;
    v11 = a4 - 1;
    v10 = a2;
    v10 = *(_WORD *)(a1 + 42) + a2;
    v7 = *(_WORD *)(a1 + 40) + a3;
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_10099614[0]);
    *(_WORD *)(a1 + 10) = byte_10099614[1] + v10;
    *(_WORD *)(a1 + 8) = v7;
    *(_WORD *)(a1 + 14) = byte_10099614[2] + v11 - byte_10099614[1] + 1;
    sub_1001F4F0(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_10099614[3]);
    *(_WORD *)(a1 + 8) = byte_10099614[4] + v7;
    *(_WORD *)(a1 + 10) = v11 + v10;
    *(_WORD *)(a1 + 12) = byte_10099614[5] + v12 - byte_10099614[4] + 1;
    sub_1001F6C0(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_10099614[6]);
    *(_WORD *)(a1 + 10) = byte_10099614[8] + v11 + v10;
    *(_WORD *)(a1 + 8) = v12 + v7;
    *(_WORD *)(a1 + 14) = byte_10099614[7] - (byte_10099614[8] + v11) - 1;
    sub_1001F4F0(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_10099614[9]);
    *(_WORD *)(a1 + 8) = byte_10099614[11] + v12 + v7;
    *(_WORD *)(a1 + 10) = v10;
    *(_WORD *)(a1 + 12) = byte_10099614[10] - (byte_10099614[11] + v12) - 1;
    sub_1001F6C0(a1);
    result = v8;
    *(_DWORD *)(a1 + 36) = v8;
  }
  return result;
}

//----- (1001EE70) --------------------------------------------------------
void sub_1001EE70()
{
  ;
}

//----- (1001EE80) --------------------------------------------------------
int __cdecl sub_1001EE80(int a1, signed int a2, signed int a3)
{
  int result; // eax@5
  int v4; // edx@10
  unsigned int v5; // ST04_4@15
  unsigned int v6; // ST20_4@16
  int v7; // ST28_4@26
  unsigned int v8; // ST18_4@32
  int v9; // [sp+0h] [bp-44h]@28
  unsigned int v10; // [sp+4h] [bp-40h]@15
  int v11; // [sp+8h] [bp-3Ch]@1
  int v12; // [sp+Ch] [bp-38h]@1
  int v13; // [sp+10h] [bp-34h]@31
  unsigned int v14; // [sp+14h] [bp-30h]@13
  int v15; // [sp+1Ch] [bp-28h]@30
  int v16; // [sp+20h] [bp-24h]@17
  int i; // [sp+20h] [bp-24h]@32
  int v18; // [sp+20h] [bp-24h]@34
  int v19; // [sp+24h] [bp-20h]@1
  unsigned int v20; // [sp+28h] [bp-1Ch]@14
  int v21; // [sp+2Ch] [bp-18h]@15
  unsigned int *v22; // [sp+30h] [bp-14h]@15
  int *v23; // [sp+30h] [bp-14h]@32
  int v24; // [sp+34h] [bp-10h]@15
  unsigned int v25; // [sp+38h] [bp-Ch]@15
  unsigned int *v26; // [sp+3Ch] [bp-8h]@13
  int v27; // [sp+40h] [bp-4h]@1

  v11 = (signed __int16)a3;
  v27 = a3 >> 16;
  v12 = (signed __int16)a2;
  v19 = a2 >> 16;
  if ( *(_WORD *)(a1 + 26) > a2 >> 16 )
  {
    v12 = (signed __int16)a2 - (*(_WORD *)(a1 + 26) - v19);
    v19 = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > v27 )
  {
    v11 = (signed __int16)a3 - (*(_WORD *)(a1 + 24) - v27);
    v27 = *(_WORD *)(a1 + 24);
  }
  result = *(_WORD *)(a1 + 30);
  if ( result + *(_WORD *)(a1 + 26) > v19 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v19 <= v12 )
      v12 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v19;
    result = *(_WORD *)(a1 + 28);
    if ( result + *(_WORD *)(a1 + 24) > v27 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v27 <= v11 )
      {
        v4 = *(_WORD *)(a1 + 28);
        result = v4 + *(_WORD *)(a1 + 24) - v27;
        v11 = v4 + *(_WORD *)(a1 + 24) - v27;
      }
      if ( v11 > 0 && v12 > 0 )
      {
        *(_BYTE *)a1 = 1;
        v14 = 32 - (8 * v19 & 0x1F);
        v26 = (unsigned int *)(v27 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                             + **(_DWORD **)(a1 + 52)
                             + 4 * ((unsigned int)(8 * v19) >> 5));
        if ( *(_WORD *)(a1 + 4) == 2 )
        {
          v9 = v11;
          if ( v14 >= 8 * v12 )
            v14 = 8 * v12;
          v15 = 8 * v12 - v14;
          result = *(_WORD *)(a1 + 38) << 16;
          if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
          {
            v13 = *(&dword_10099668 + *(_WORD *)(a1 + 38));
            do
            {
              v8 = ~(((unsigned int)(0xFFFFFFFFui64 >> v14) >> ((32 - (8 * v19 & 0x1F) - v14) & 0x1F)) | ((unsigned int)(0xFFFFFFFFui64 >> v14) << (32 - ((32 - (8 * v19 & 0x1F) - v14) & 0x1F))));
              *v26 = *v26 & ~v8 | v13 & v8;
              v23 = (int *)(v26 + 1);
              for ( i = v15 - 32; i >= 0; i -= 32 )
              {
                *v23 = v13;
                ++v23;
              }
              v18 = i + 32;
              if ( v18 )
                *v23 = *v23 & ~((1 << v18) - 1) | v13 & ((1 << v18) - 1);
              result = *(_DWORD *)(a1 + 52);
              v26 = (unsigned int *)((char *)v26 + *(_WORD *)(result + 10));
              --v9;
            }
            while ( v9 );
          }
        }
        else
        {
          v20 = (v19 << 16) & 0x1FFFFF | v11 | (v27 << 27);
          do
          {
            v5 = *(_DWORD *)(*(_DWORD *)(a1 + 60) + (v20 >> 25));
            v10 = (v5 >> ((v20 >> 16) & 0x1F)) | (v5 << (32 - ((v20 >> 16) & 0x1F)));
            v22 = v26;
            v21 = 32 - (8 * v19 & 0x1F);
            v25 = (*v26 >> (31 * v14 & 0x1F)) | (*v26 << (32 - (31 * v14 & 0x1F)));
            v24 = v12;
            do
            {
              v6 = v10 << 31;
              v10 = (v10 << 31) | (v10 >> 1);
              if ( v6 >> 31 )
                v16 = *(_WORD *)(a1 + 38);
              else
                v16 = *(_WORD *)(a1 + 36);
              if ( (signed __int16)v16 >= 0 )
                v25 = (v16 << 24) | (v25 >> 8);
              else
                v25 = (v25 >> 8) | (v25 << 24);
              if ( --v24 )
              {
                v21 -= 8;
                if ( !v21 )
                {
                  *v22 = v25;
                  ++v22;
                  v21 = 32;
                  v25 = *v22;
                }
              }
            }
            while ( v24 );
            *v22 = (v25 >> ((v21 - 8) & 0x1F)) | (v25 << (32 - ((v21 - 8) & 0x1F)));
            v26 = (unsigned int *)((char *)v26 + *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
            v7 = v20 + 0x8000000;
            result = v7 - 1;
            v20 = v7 - 1;
          }
          while ( v20 << 16 );
        }
      }
    }
  }
  return result;
}

//----- (1001F350) --------------------------------------------------------
int __cdecl sub_1001F350(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@1
  int v6; // [sp+0h] [bp-8h]@4
  __int16 v7; // [sp+4h] [bp-4h]@6

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v6 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 48);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + a2;
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + a3;
    if ( *(_WORD *)(a1 + 6) == 3 || *(_WORD *)(a1 + 6) == 1 )
    {
      v7 = *(_WORD *)(a1 + 4);
      if ( *(_WORD *)(a1 + 6) == 3 )
        *(_WORD *)(a1 + 4) = 2;
      else
        *(_WORD *)(a1 + 4) = 0;
      sub_1001EE80(a1, a4 + (*(_WORD *)(a1 + 10) << 16), a5 + (*(_WORD *)(a1 + 8) << 16));
      *(_WORD *)(a1 + 4) = v7;
    }
    result = a1;
    *(_DWORD *)(a1 + 36) = v6;
  }
  return result;
}

//----- (1001F440) --------------------------------------------------------
char __cdecl sub_1001F440(int a1)
{
  int v1; // eax@3
  int v3; // [sp+0h] [bp-30h]@3
  __int16 v4; // [sp+4h] [bp-2Ch]@1
  char v5; // [sp+8h] [bp-28h]@6
  int v6; // [sp+14h] [bp-1Ch]@1

  v6 = *(_WORD *)(a1 + 10);
  v4 = *(_WORD *)(a1 + 14) - *(_WORD *)(a1 + 10);
  if ( v4 < 0 )
  {
    v6 = *(_WORD *)(a1 + 14);
    v4 = -v4;
  }
  v1 = (signed __int16)(v4 + 1);
  v6 = v1 + (v6 << 16);
  v3 = *(_WORD *)(a1 + 6);
  if ( v3 == 1 )
  {
    LOBYTE(v1) = sub_1001F810(a1, v6, *(_WORD *)(a1 + 8), (int)&v5);
  }
  else if ( v3 == 3 )
  {
    LOBYTE(v1) = sub_1001FD00(a1, v6, *(_WORD *)(a1 + 8), (int)&v5);
  }
  return v1;
}

//----- (1001F4F0) --------------------------------------------------------
char __cdecl sub_1001F4F0(int a1)
{
  __int16 v1; // ax@1
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@8
  int v5; // [sp+18h] [bp-1Ch]@1

  v5 = *(_WORD *)(a1 + 10);
  v1 = *(_WORD *)(a1 + 14);
  v3 = *(_WORD *)(a1 + 14);
  if ( *(_WORD *)(a1 + 14) )
  {
    if ( v3 < 0 )
    {
      v5 += v3 + 1;
      v3 = 0x8000 - v3;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) > 1 )
    {
      LOBYTE(v1) = a1;
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
        case 2:
          LOBYTE(v1) = sub_1001FB90(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
        case 4:
          LOBYTE(v1) = sub_100204C0(a1, v5, (int)&v4);
          break;
        default:
          return v1;
      }
    }
    else
    {
      v1 = *(_WORD *)(a1 + 4);
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
          LOBYTE(v1) = sub_1001FB90(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 2:
          LOBYTE(v1) = sub_1001FB90(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
          LOBYTE(v1) = sub_1001FD00(a1, v5, *(_WORD *)(a1 + 8), (int)&v4);
          break;
        case 4:
          LOBYTE(v1) = (unsigned int)sub_10020130(a1, v5, *(_WORD *)(a1 + 8), *(int **)(a1 + 64));
          break;
        default:
          return v1;
      }
    }
  }
  return v1;
}

//----- (1001F660) --------------------------------------------------------
int __cdecl sub_1001F660(int a1)
{
  int result; // eax@1
  int v2; // [sp+0h] [bp-4h]@1

  result = a1;
  v2 = *(_WORD *)(a1 + 4);
  if ( *(_WORD *)(a1 + 4) && v2 != 2 )
  {
    if ( v2 == 3 )
      result = sub_1001FE10(a1, *(_WORD *)(a1 + 10), *(_WORD *)(a1 + 8));
  }
  else
  {
    result = sub_1001FC10(a1, *(_WORD *)(a1 + 10), *(_WORD *)(a1 + 8));
  }
  return result;
}

//----- (1001F6C0) --------------------------------------------------------
char *__cdecl sub_1001F6C0(int a1)
{
  char *result; // eax@1
  int v2; // ST18_4@3
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@7
  int v5; // [sp+1Ch] [bp-18h]@1

  v5 = *(_WORD *)(a1 + 8);
  result = (char *)*(_WORD *)(a1 + 12);
  v3 = *(_WORD *)(a1 + 12);
  if ( *(_WORD *)(a1 + 12) )
  {
    if ( v3 < 0 )
    {
      v2 = -v3;
      v5 = v5 - v2 + 1;
      v3 = v2 + 0x8000;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) <= 1 )
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_1001FC80(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
          result = (char *)sub_1001FF00(a1, v5, *(_WORD *)(a1 + 10), (int)&v4);
          break;
        case 4u:
          result = sub_10020270(a1, v5, *(_WORD *)(a1 + 10), *(int **)(a1 + 64));
          break;
        default:
          return result;
      }
    }
    else
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_1001FC80(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
        case 4u:
          result = (char *)sub_10020600(a1, v5, (int)&v4);
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

//----- (1001F810) --------------------------------------------------------
unsigned int __cdecl sub_1001F810(int a1, signed int a2, int a3, int a4)
{
  unsigned int result; // eax@1

  *(_DWORD *)(a4 + 20) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 12) = a2 >> 16;
  *(_DWORD *)(a4 + 16) = a3;
  result = sub_1001F8D0(a1, a4);
  if ( *(_DWORD *)a4 )
  {
    *(_DWORD *)(a4 + 32) = (*(_DWORD *)(*(_DWORD *)(a1 + 60) + 4 * (a3 & 0x1F)) >> (*(_BYTE *)(a4 + 12) & 0x1F)) | (*(_DWORD *)(*(_DWORD *)(a1 + 60) + 4 * (a3 & 0x1F)) << (32 - (*(_BYTE *)(a4 + 12) & 0x1F)));
    *(_DWORD *)(a4 + 36) = 1;
    result = sub_1001F9F0(a1, a4);
  }
  return result;
}

//----- (1001F8D0) --------------------------------------------------------
int __cdecl sub_1001F8D0(int a1, int a2)
{
  int result; // eax@2

  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = *(_WORD *)(a1 + 26) - *(_DWORD *)(a2 + 12);
  if ( *(_DWORD *)(a2 + 24) <= 0
    || (*(_DWORD *)(a2 + 12) += *(_DWORD *)(a2 + 24),
        result = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 24),
        *(_DWORD *)(a2 + 20) = result,
        *(_DWORD *)(a2 + 20) > 0) )
  {
    result = *(_WORD *)(a1 + 26);
    if ( result + *(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
    {
      if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12) <= *(_DWORD *)(a2 + 20) )
        *(_DWORD *)(a2 + 20) = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12);
      result = a1;
      if ( (signed int)*(_WORD *)(a1 + 24) <= *(_DWORD *)(a2 + 16) )
      {
        result = *(_WORD *)(a1 + 24);
        if ( result + *(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
        {
          *(_DWORD *)(a2 + 24) &= ~(*(_DWORD *)(a2 + 24) >> 31);
          *(_BYTE *)a1 = 1;
          result = a2;
          *(_DWORD *)a2 = 1;
        }
      }
    }
  }
  return result;
}

//----- (1001F9F0) --------------------------------------------------------
unsigned int __cdecl sub_1001F9F0(int a1, int a2)
{
  unsigned int v2; // ST04_4@1
  __int16 v3; // ST0C_2@2
  char v4; // ST04_1@9
  unsigned int result; // eax@9
  unsigned int v6; // [sp+0h] [bp-1Ch]@1
  int v7; // [sp+4h] [bp-18h]@1
  int v8; // [sp+8h] [bp-14h]@2
  int v9; // [sp+10h] [bp-Ch]@1
  unsigned int v10; // [sp+14h] [bp-8h]@1
  unsigned int *v11; // [sp+18h] [bp-4h]@1

  v9 = *(_DWORD *)(a2 + 20);
  v2 = 8 * *(_DWORD *)(a2 + 12);
  v11 = (unsigned int *)(**(_DWORD **)(a1 + 52)
                       + *(_DWORD *)(a2 + 16) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                       + 4 * (v2 >> 5));
  v7 = 32 - (v2 & 0x1F);
  v10 = (*v11 >> (31 * v7 & 0x1F)) | (*v11 << (32 - (31 * v7 & 0x1F)));
  v6 = *(_DWORD *)(a2 + 32);
  do
  {
    v8 = 2 * v6 & 3;
    v6 = (v6 >> (*(_BYTE *)(a2 + 36) & 0x1F)) | (v6 << (32 - (*(_BYTE *)(a2 + 36) & 0x1F)));
    v3 = *(_WORD *)(v8 + a1 + 36);
    if ( v3 >= 0 )
      v10 = (v10 >> 8) | (*(_WORD *)(v8 + a1 + 36) << 24);
    else
      v10 = (v10 >> 8) | (v10 << 24);
    if ( --v9 )
    {
      v7 -= 8;
      if ( !v7 )
      {
        *v11 = v10;
        ++v11;
        v7 = 32;
        v10 = *v11;
      }
    }
  }
  while ( v9 );
  v4 = v7 - 8;
  result = v10 >> (v4 & 0x1F);
  *v11 = result | (v10 << (32 - (v4 & 0x1F)));
  return result;
}

//----- (1001FB90) --------------------------------------------------------
int __cdecl sub_1001FB90(int a1, int a2, int a3)
{
  return sub_1001EE80(
           a1,
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 34) - 1 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1 << 16),
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1)) << 16) + *(_WORD *)(a1 + 32));
}

//----- (1001FC10) --------------------------------------------------------
int __cdecl sub_1001FC10(int a1, int a2, int a3)
{
  return sub_1001EE80(
           a1,
           (a2 << 16) + *(_WORD *)(a1 + 34) - ((unsigned int)*(_WORD *)(a1 + 34) >> 1 << 16),
           (a3 << 16) + *(_WORD *)(a1 + 32) - ((unsigned int)*(_WORD *)(a1 + 32) >> 1 << 16));
}

//----- (1001FC80) --------------------------------------------------------
int __cdecl sub_1001FC80(int a1, int a2, int a3)
{
  return sub_1001EE80(
           a1,
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1)) << 16) + *(_WORD *)(a1 + 34),
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 32) - 1 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1 << 16));
}

//----- (1001FD00) --------------------------------------------------------
char __cdecl sub_1001FD00(int a1, signed int a2, int a3, int a4)
{
  char result; // al@2
  int v5; // [sp+0h] [bp-Ch]@7
  unsigned int v6; // [sp+4h] [bp-8h]@5
  _BYTE *v7; // [sp+8h] [bp-4h]@5

  *(_DWORD *)(a4 + 20) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 12) = a2 >> 16;
  *(_DWORD *)(a4 + 16) = a3;
  if ( *(_DWORD *)(a4 + 20) == 1 )
  {
    result = sub_1001FE10(a1, *(_DWORD *)(a4 + 12), *(_DWORD *)(a4 + 16));
  }
  else
  {
    result = sub_1001F8D0(a1, a4);
    if ( *(_DWORD *)a4 )
    {
      result = a1;
      if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
      {
        v7 = (_BYTE *)(*(_DWORD *)(a4 + 12) + **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
        v6 = *(_DWORD *)(a4 + 20);
        if ( v6 <= 0x10 )
        {
          v5 = *(&dword_10099668 + *(_WORD *)(a1 + 38));
          do
          {
            result = v5;
            *v7++ = v5;
            --v6;
          }
          while ( v6 );
        }
        else
        {
          result = (unsigned int)memset(v7, *(&dword_10099668 + *(_WORD *)(a1 + 38)), v6);
        }
      }
    }
  }
  return result;
}

//----- (1001FE10) --------------------------------------------------------
int __cdecl sub_1001FE10(int a1, signed int a2, signed int a3)
{
  int result; // eax@1
  _BYTE *v4; // ST08_4@5
  unsigned int v5; // [sp+18h] [bp+Ch]@5

  result = a1;
  if ( *(_WORD *)(a1 + 26) <= a2 )
  {
    result = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30);
    if ( result > a2 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 24) <= a3 )
      {
        result = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28);
        if ( result > a3 )
        {
          *(_BYTE *)a1 = 1;
          v5 = 8 * a2;
          v4 = (_BYTE *)(**(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3));
          result = **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3);
          *v4 = ((unsigned __int64)*(_WORD *)(a1 + 38) << (v5 & 7)) | ~(unsigned __int8)(255i64 << (v5 & 7)) & *v4;
        }
      }
    }
  }
  return result;
}

//----- (1001FF00) --------------------------------------------------------
int __cdecl sub_1001FF00(int a1, signed int a2, int a3, int a4)
{
  int result; // eax@1
  _BYTE *v5; // [sp+Ch] [bp-4h]@2
  int v6; // [sp+18h] [bp+8h]@1

  *(_DWORD *)(a4 + 8) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 16) = a2 >> 16;
  *(_DWORD *)(a4 + 12) = a3;
  result = sub_10020000(a1, a4);
  v6 = result;
  if ( *(_DWORD *)(a4 + 4) )
  {
    v5 = (_BYTE *)((a3 & 0x1FFFFFFF)
                 + *(_DWORD *)(a4 + 16) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                 + **(_DWORD **)(result + 52));
    do
    {
      *v5;
      *v5 = *(_WORD *)(v6 + 38);
      v5 += *(_WORD *)(*(_DWORD *)(v6 + 52) + 10);
      result = *(_DWORD *)(a4 + 8) - 1;
      *(_DWORD *)(a4 + 8) = result;
    }
    while ( *(_DWORD *)(a4 + 8) > 0 );
  }
  return result;
}

//----- (10020000) --------------------------------------------------------
int __cdecl sub_10020000(int a1, int a2)
{
  int result; // eax@3

  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 28) = *(_WORD *)(a1 + 24) - *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 28) <= 0
    || (*(_DWORD *)(a2 + 16) += *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) -= *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) > 0) )
  {
    if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
    {
      if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16) <= *(_DWORD *)(a2 + 8) )
        *(_DWORD *)(a2 + 8) = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16);
      if ( (signed int)*(_WORD *)(a1 + 26) <= *(_DWORD *)(a2 + 12) )
      {
        if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
        {
          *(_DWORD *)(a2 + 28) &= ~(*(_DWORD *)(a2 + 28) >> 31);
          *(_BYTE *)a1 = 1;
          *(_DWORD *)(a2 + 4) = 1;
          result = a1;
        }
        else
        {
          result = a1;
        }
      }
      else
      {
        result = a1;
      }
    }
    else
    {
      result = a1;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10020130) --------------------------------------------------------
char *__cdecl sub_10020130(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-30h]@1
  signed int v6; // [sp+Ch] [bp-24h]@1
  int v7; // [sp+10h] [bp-20h]@1
  int v8; // [sp+14h] [bp-1Ch]@1
  int v9; // [sp+20h] [bp-10h]@1
  int v10; // [sp+24h] [bp-Ch]@1
  char *v11; // [sp+28h] [bp-8h]@1
  int v12; // [sp+2Ch] [bp-4h]@1
  signed int v13; // [sp+3Ch] [bp+Ch]@1
  int v14; // [sp+3Ch] [bp+Ch]@4

  v11 = &v5;
  v8 = a2 & 0x7FFF;
  v6 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v8 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v13 = (a2 - *((_DWORD *)v11 + 5)) << 16;
  if ( v13 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v13 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v13 + 1;
  sub_1001F8D0(a1, (int)v11);
  result = v11;
  if ( *(_DWORD *)v11 )
  {
    v14 = *((_DWORD *)v11 + 6) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v14 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v14 & 0x1F)));
    result = (char *)sub_1001F9F0(a1, (int)v11);
  }
  return result;
}

//----- (10020270) --------------------------------------------------------
char *__cdecl sub_10020270(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-3Ch]@1
  int v6; // [sp+8h] [bp-34h]@1
  int v7; // [sp+Ch] [bp-30h]@1
  signed int v8; // [sp+10h] [bp-2Ch]@1
  int v9; // [sp+20h] [bp-1Ch]@1
  int v10; // [sp+24h] [bp-18h]@1
  char *v11; // [sp+28h] [bp-14h]@1
  int v12; // [sp+2Ch] [bp-10h]@1
  __int16 v13; // [sp+30h] [bp-Ch]@5
  char v14; // [sp+37h] [bp-5h]@6
  char *v15; // [sp+38h] [bp-4h]@4
  int v16; // [sp+44h] [bp+8h]@3
  signed int v17; // [sp+48h] [bp+Ch]@1
  int v18; // [sp+48h] [bp+Ch]@4
  unsigned int v19; // [sp+4Ch] [bp+10h]@4
  int v20; // [sp+4Ch] [bp+10h]@4

  v11 = &v5;
  v6 = a2 & 0x7FFF;
  v8 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v6 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v17 = (a2 - *((_DWORD *)v11 + 2)) << 16;
  if ( v17 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v17 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v17 + 1;
  v16 = sub_10020000(a1, (int)v11);
  result = v11;
  if ( *((_DWORD *)v11 + 1) )
  {
    v18 = *((_DWORD *)v11 + 7) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v18 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v18 & 0x1F)));
    v19 = 8 * a3;
    v15 = (char *)(**(_DWORD **)(v16 + 52) + (v19 >> 3) + *((_DWORD *)v11 + 4) * *(_WORD *)(*(_DWORD *)(v16 + 52) + 10));
    v20 = v19 & 7;
    do
    {
      v12 = 2 * *((_DWORD *)v11 + 8) & 3;
      *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v11[36] & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v11[36] & 0x1F)));
      v12 += v16 + 36;
      v13 = *(_WORD *)v12;
      if ( v13 >= 0 )
      {
        v14 = *v15;
        v13 <<= v20;
        v14 &= ~(unsigned __int8)(255 << v20);
        v14 |= v13;
        *v15 = v14;
      }
      v15 += *(_WORD *)(*(_DWORD *)(v16 + 52) + 10);
      --*((_DWORD *)v11 + 2);
      result = v11;
    }
    while ( *((_DWORD *)v11 + 2) );
  }
  return result;
}

//----- (100204C0) --------------------------------------------------------
int __cdecl sub_100204C0(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  unsigned int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int *v10; // [sp+10h] [bp-4h]@1

  v7 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 16) = v7 >> 1;
  *(_DWORD *)(a3 + 12) = a2 - (*(_DWORD *)(a3 + 16) * *(_WORD *)(a1 + 18) << 16);
  *(_DWORD *)(a3 + 16) = *(_WORD *)(a1 + 8) - *(_DWORD *)(a3 + 16);
  v9 = *(_WORD *)(a1 + 18) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = -256 * (8 * (*(_DWORD *)(a3 + 12) << 16 >> 31) + 4);
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v10 = *(int **)(a1 + 64);
  if ( v5 )
    v10 = (int *)((char *)v10 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_10020130(a1, *(_DWORD *)(a3 + 12), *(_DWORD *)(a3 + 16), v10);
    else
      sub_1001FD00(a1, a2, *(_DWORD *)(a3 + 16), a3);
    ++*(_DWORD *)(a3 + 16);
    *(_DWORD *)(a3 + 12) += v9;
    result = (int)v10 + (v8 >> 8);
    v10 = (int *)((char *)v10 + (v8 >> 8));
    --v7;
  }
  while ( v7 );
  return result;
}

//----- (10020600) --------------------------------------------------------
int __cdecl sub_10020600(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int *v9; // [sp+Ch] [bp-8h]@1
  unsigned int v10; // [sp+10h] [bp-4h]@1

  v10 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 12) = v10 >> 1;
  *(_DWORD *)(a3 + 16) = a2 - (*(_DWORD *)(a3 + 12) * *(_WORD *)(a1 + 16) << 16);
  *(_DWORD *)(a3 + 12) = *(_WORD *)(a1 + 10) - *(_DWORD *)(a3 + 12);
  v7 = *(_WORD *)(a1 + 16) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = (8 * (*(_DWORD *)(a3 + 16) << 16 >> 31) + 4) << 8;
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v9 = *(int **)(a1 + 64);
  if ( v5 )
    v9 = (int *)((char *)v9 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_10020270(a1, *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 12), v9);
    else
      sub_1001FF00(a1, a2, *(_DWORD *)(a3 + 12), a3);
    ++*(_DWORD *)(a3 + 12);
    *(_DWORD *)(a3 + 16) += v7;
    result = (int)v9 + (v8 >> 8);
    v9 = (int *)((char *)v9 + (v8 >> 8));
    --v10;
  }
  while ( v10 );
  return result;
}

//----- (10020740) --------------------------------------------------------
int __cdecl sub_10020740(int a1)
{
  int result; // eax@6
  __int16 v2; // [sp+0h] [bp-8h]@1
  __int16 v3; // [sp+4h] [bp-4h]@1

  v2 = *(_WORD *)(a1 + 10);
  v3 = *(_WORD *)(a1 + 8);
  if ( *(_WORD *)(a1 + 26) > (signed int)*(_WORD *)(a1 + 10) )
  {
    *(_WORD *)(a1 + 18) -= *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 14) += *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > (signed int)*(_WORD *)(a1 + 8) )
  {
    *(_WORD *)(a1 + 16) -= *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 12) += *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 24);
  }
  if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) > v2 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v2 < *(_WORD *)(a1 + 18) )
      *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v2;
    if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) > v3 )
    {
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v3 < *(_WORD *)(a1 + 16) )
        *(_WORD *)(a1 + 16) = *(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 24) - v3;
      if ( (signed int)*(_WORD *)(a1 + 18) > 0 )
      {
        if ( (signed int)*(_WORD *)(a1 + 16) > 0 )
        {
          *(_BYTE *)a1 = 1;
          result = a1;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10020910) --------------------------------------------------------
char __cdecl sub_10020910(int a1, __int16 a2, __int16 a3, __int16 a4, int a5, __int16 a6, __int16 a7)
{
  char result; // al@4
  char v8; // [sp+0h] [bp-17Ch]@55
  char v9; // [sp+4h] [bp-178h]@49
  char v10; // [sp+8h] [bp-174h]@43
  char v11; // [sp+Ch] [bp-170h]@37
  char v12; // [sp+10h] [bp-16Ch]@31
  char v13; // [sp+14h] [bp-168h]@25
  char v14; // [sp+18h] [bp-164h]@19
  char v15; // [sp+1Ch] [bp-160h]@13
  char v16; // [sp+20h] [bp-15Ch]@98
  char v17; // [sp+21h] [bp-15Bh]@98
  __int16 v18; // [sp+22h] [bp-15Ah]@98
  __int16 v19; // [sp+24h] [bp-158h]@98
  __int16 v20; // [sp+26h] [bp-156h]@98
  int v21; // [sp+2Ch] [bp-150h]@98
  char v22; // [sp+30h] [bp-14Ch]@96
  char v23; // [sp+31h] [bp-14Bh]@96
  __int16 v24; // [sp+32h] [bp-14Ah]@96
  __int16 v25; // [sp+34h] [bp-148h]@96
  __int16 v26; // [sp+36h] [bp-146h]@96
  int v27; // [sp+3Ch] [bp-140h]@96
  char v28; // [sp+40h] [bp-13Ch]@94
  char v29; // [sp+41h] [bp-13Bh]@94
  __int16 v30; // [sp+42h] [bp-13Ah]@94
  __int16 v31; // [sp+44h] [bp-138h]@94
  __int16 v32; // [sp+46h] [bp-136h]@94
  int v33; // [sp+4Ch] [bp-130h]@94
  char v34; // [sp+50h] [bp-12Ch]@92
  char v35; // [sp+51h] [bp-12Bh]@92
  __int16 v36; // [sp+52h] [bp-12Ah]@92
  __int16 v37; // [sp+54h] [bp-128h]@92
  __int16 v38; // [sp+56h] [bp-126h]@92
  int v39; // [sp+5Ch] [bp-120h]@92
  char v40; // [sp+60h] [bp-11Ch]@90
  char v41; // [sp+61h] [bp-11Bh]@90
  __int16 v42; // [sp+62h] [bp-11Ah]@90
  __int16 v43; // [sp+64h] [bp-118h]@90
  __int16 v44; // [sp+66h] [bp-116h]@90
  int v45; // [sp+6Ch] [bp-110h]@90
  char v46; // [sp+70h] [bp-10Ch]@88
  char v47; // [sp+71h] [bp-10Bh]@88
  __int16 v48; // [sp+72h] [bp-10Ah]@88
  __int16 v49; // [sp+74h] [bp-108h]@88
  __int16 v50; // [sp+76h] [bp-106h]@88
  int v51; // [sp+7Ch] [bp-100h]@88
  char v52; // [sp+80h] [bp-FCh]@86
  char v53; // [sp+81h] [bp-FBh]@86
  __int16 v54; // [sp+82h] [bp-FAh]@86
  __int16 v55; // [sp+84h] [bp-F8h]@86
  __int16 v56; // [sp+86h] [bp-F6h]@86
  int v57; // [sp+8Ch] [bp-F0h]@86
  char v58; // [sp+90h] [bp-ECh]@84
  char v59; // [sp+91h] [bp-EBh]@84
  __int16 v60; // [sp+92h] [bp-EAh]@84
  __int16 v61; // [sp+94h] [bp-E8h]@84
  __int16 v62; // [sp+96h] [bp-E6h]@84
  int v63; // [sp+9Ch] [bp-E0h]@84
  char v64; // [sp+A0h] [bp-DCh]@79
  char v65; // [sp+A1h] [bp-DBh]@79
  __int16 v66; // [sp+A2h] [bp-DAh]@79
  __int16 v67; // [sp+A4h] [bp-D8h]@79
  __int16 v68; // [sp+A6h] [bp-D6h]@79
  int v69; // [sp+ACh] [bp-D0h]@79
  char v70; // [sp+B0h] [bp-CCh]@77
  char v71; // [sp+B1h] [bp-CBh]@77
  __int16 v72; // [sp+B2h] [bp-CAh]@77
  __int16 v73; // [sp+B4h] [bp-C8h]@77
  __int16 v74; // [sp+B6h] [bp-C6h]@77
  int v75; // [sp+BCh] [bp-C0h]@77
  char v76; // [sp+C0h] [bp-BCh]@75
  char v77; // [sp+C1h] [bp-BBh]@75
  __int16 v78; // [sp+C2h] [bp-BAh]@75
  __int16 v79; // [sp+C4h] [bp-B8h]@75
  __int16 v80; // [sp+C6h] [bp-B6h]@75
  int v81; // [sp+CCh] [bp-B0h]@75
  char v82; // [sp+D0h] [bp-ACh]@73
  char v83; // [sp+D1h] [bp-ABh]@73
  __int16 v84; // [sp+D2h] [bp-AAh]@73
  __int16 v85; // [sp+D4h] [bp-A8h]@73
  __int16 v86; // [sp+D6h] [bp-A6h]@73
  int v87; // [sp+DCh] [bp-A0h]@73
  char v88; // [sp+E0h] [bp-9Ch]@71
  char v89; // [sp+E1h] [bp-9Bh]@71
  __int16 v90; // [sp+E2h] [bp-9Ah]@71
  __int16 v91; // [sp+E4h] [bp-98h]@71
  __int16 v92; // [sp+E6h] [bp-96h]@71
  int v93; // [sp+ECh] [bp-90h]@71
  char v94; // [sp+F0h] [bp-8Ch]@69
  char v95; // [sp+F1h] [bp-8Bh]@69
  __int16 v96; // [sp+F2h] [bp-8Ah]@69
  __int16 v97; // [sp+F4h] [bp-88h]@69
  __int16 v98; // [sp+F6h] [bp-86h]@69
  int v99; // [sp+FCh] [bp-80h]@69
  char v100; // [sp+100h] [bp-7Ch]@67
  char v101; // [sp+101h] [bp-7Bh]@67
  __int16 v102; // [sp+102h] [bp-7Ah]@67
  __int16 v103; // [sp+104h] [bp-78h]@67
  __int16 v104; // [sp+106h] [bp-76h]@67
  int v105; // [sp+10Ch] [bp-70h]@67
  char v106; // [sp+110h] [bp-6Ch]@65
  char v107; // [sp+111h] [bp-6Bh]@65
  __int16 v108; // [sp+112h] [bp-6Ah]@65
  __int16 v109; // [sp+114h] [bp-68h]@65
  __int16 v110; // [sp+116h] [bp-66h]@65
  int v111; // [sp+11Ch] [bp-60h]@65
  __int16 v112; // [sp+120h] [bp-5Ch]@1
  char v113; // [sp+127h] [bp-55h]@64
  __int16 v114; // [sp+128h] [bp-54h]@1
  int v115; // [sp+12Ch] [bp-50h]@61
  __int16 v116; // [sp+130h] [bp-4Ch]@1
  char v117; // [sp+137h] [bp-45h]@57
  __int16 v118; // [sp+138h] [bp-44h]@61
  __int16 v119; // [sp+13Ah] [bp-42h]@61
  __int16 v120; // [sp+13Ch] [bp-40h]@8
  __int16 v121; // [sp+140h] [bp-3Ch]@61
  __int16 v122; // [sp+144h] [bp-38h]@8
  char v123; // [sp+148h] [bp-34h]@9
  char v124; // [sp+149h] [bp-33h]@21
  char v125; // [sp+14Ah] [bp-32h]@33
  char v126; // [sp+14Bh] [bp-31h]@57
  char v127; // [sp+14Ch] [bp-30h]@45
  char v128; // [sp+14Dh] [bp-2Fh]@27
  char v129; // [sp+14Eh] [bp-2Eh]@15
  char v130; // [sp+14Fh] [bp-2Dh]@39
  __int16 v131; // [sp+150h] [bp-2Ch]@9
  __int16 v132; // [sp+154h] [bp-28h]@1
  __int16 v133; // [sp+158h] [bp-24h]@61
  __int16 v134; // [sp+15Ah] [bp-22h]@61
  char v135; // [sp+15Ch] [bp-20h]@59
  char v136; // [sp+15Dh] [bp-1Fh]@67
  char v137; // [sp+15Eh] [bp-1Eh]@71
  char v138; // [sp+15Fh] [bp-1Dh]@79
  char v139; // [sp+160h] [bp-1Ch]@75
  char v140; // [sp+161h] [bp-1Bh]@69
  char v141; // [sp+162h] [bp-1Ah]@65
  char v142; // [sp+163h] [bp-19h]@73
  __int16 v143; // [sp+168h] [bp-14h]@1
  int v144; // [sp+16Ch] [bp-10h]@57
  __int16 v145; // [sp+170h] [bp-Ch]@1
  __int16 v146; // [sp+174h] [bp-8h]@9
  __int16 v147; // [sp+178h] [bp-4h]@9

  v114 = a2;
  v132 = a3;
  v112 = a6;
  v143 = a7;
  v116 = *(_WORD *)(a1 + 42) + *(_WORD *)(a1 + 46);
  v145 = *(_WORD *)(a1 + 40) + *(_WORD *)(a1 + 44);
  *(_WORD *)(a1 + 46) = a6;
  *(_WORD *)(a1 + 44) = v143;
  v112 += *(_WORD *)(a1 + 42);
  v143 += *(_WORD *)(a1 + 40);
  v114 += *(_WORD *)(a1 + 42);
  v132 += *(_WORD *)(a1 + 40);
  if ( v116 != v112 || v145 != v143 )
  {
    if ( a5 & 1 )
    {
      v122 = v116;
      v116 = v112;
      v112 = v122;
      v120 = v145;
      v145 = v143;
      v143 = v120;
    }
    sub_10021B60((int)&v123, v116 - v114, v145 - v132, v112 - v114, v143 - v132);
    v146 = (unsigned int)(46341 * a4) >> 16;
    v131 = v146 - 1;
    v147 = v146 + 1;
    if ( v114 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v147 + v114 < *(_WORD *)(a1 + 26)
      || v131 + v132 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || a4 + v132 < *(_WORD *)(a1 + 24) )
    {
      v15 = 0;
    }
    else
    {
      v15 = -1;
    }
    v129 &= v15;
    if ( v114 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v147 + v114 < *(_WORD *)(a1 + 26)
      || v132 - a4 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v132 - v131 < *(_WORD *)(a1 + 24) )
    {
      v14 = 0;
    }
    else
    {
      v14 = -1;
    }
    v124 &= v14;
    if ( v114 - v147 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v114 < (signed int)*(_WORD *)(a1 + 26)
      || v131 + v132 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || a4 + v132 < *(_WORD *)(a1 + 24) )
    {
      v13 = 0;
    }
    else
    {
      v13 = -1;
    }
    v128 &= v13;
    if ( v114 - v147 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v114 < (signed int)*(_WORD *)(a1 + 26)
      || v132 - a4 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v132 - v131 < *(_WORD *)(a1 + 24) )
    {
      v12 = 0;
    }
    else
    {
      v12 = -1;
    }
    v125 &= v12;
    if ( v131 + v114 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || a4 + v114 < *(_WORD *)(a1 + 26)
      || v132 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v147 + v132 < *(_WORD *)(a1 + 24) )
    {
      v11 = 0;
    }
    else
    {
      v11 = -1;
    }
    v130 &= v11;
    if ( v114 - a4 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v114 - v131 < *(_WORD *)(a1 + 26)
      || v132 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v147 + v132 < *(_WORD *)(a1 + 24) )
    {
      v10 = 0;
    }
    else
    {
      v10 = -1;
    }
    v127 &= v10;
    if ( v131 + v114 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || a4 + v114 < *(_WORD *)(a1 + 26)
      || v132 - v147 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v132 < (signed int)*(_WORD *)(a1 + 24) )
    {
      v9 = 0;
    }
    else
    {
      v9 = -1;
    }
    v123 &= v9;
    if ( v114 - a4 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v114 - v131 < *(_WORD *)(a1 + 26)
      || v132 - v147 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v132 < (signed int)*(_WORD *)(a1 + 24) )
    {
      v8 = 0;
    }
    else
    {
      v8 = -1;
    }
    v126 &= v8;
    v144 = 0;
    v117 = 0;
    while ( v144 < 8 )
    {
      *(&v135 + v144) = *(_BYTE *)(a1 + 1);
      v117 |= *(&v123 + v144++);
    }
    result = v117;
    if ( v117 )
    {
      v121 = 0;
      v122 = 0;
      v120 = a4;
      v115 = 1 - a4;
      v119 = v116;
      v118 = v145;
      v134 = v112;
      v133 = v143;
      while ( v122 < v120 )
      {
        if ( v115 >= 0 )
        {
          v113 = 0;
          if ( v129 )
          {
            v106 = 6;
            v107 = v129;
            v108 = v120 + v132;
            v109 = v121 + v114;
            v110 = v122 + v114;
            v111 = a5;
            *(_BYTE *)(a1 + 1) = v141;
            *(_WORD *)(a1 + 16) = v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_10021A50(a1, (int)&v106, (int)&v118, (int)&v133);
            v141 = *(_BYTE *)(a1 + 1);
          }
          if ( v124 )
          {
            v100 = 1;
            v101 = v124;
            v102 = v132 - v120;
            v103 = v122 + v114;
            v104 = v121 + v114;
            v105 = a5;
            *(_BYTE *)(a1 + 1) = v136;
            *(_WORD *)(a1 + 16) = -v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_10021A50(a1, (int)&v100, (int)&v118, (int)&v133);
            v136 = *(_BYTE *)(a1 + 1);
          }
          if ( v128 )
          {
            v94 = 5;
            v95 = v128;
            v96 = v120 + v132;
            v97 = v114 - v122;
            v98 = v114 - v121;
            v99 = a5;
            *(_BYTE *)(a1 + 1) = v140;
            *(_WORD *)(a1 + 16) = -v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_10021A50(a1, (int)&v94, (int)&v118, (int)&v133);
            v140 = *(_BYTE *)(a1 + 1);
          }
          if ( v125 )
          {
            v88 = 2;
            v89 = v125;
            v90 = v132 - v120;
            v91 = v114 - v121;
            v92 = v114 - v122;
            v93 = a5;
            *(_BYTE *)(a1 + 1) = v137;
            *(_WORD *)(a1 + 16) = v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_10021A50(a1, (int)&v88, (int)&v118, (int)&v133);
            v137 = *(_BYTE *)(a1 + 1);
          }
          if ( v130 )
          {
            v82 = 7;
            v83 = v130;
            v84 = v120 + v114;
            v85 = v122 + v132;
            v86 = v121 + v132;
            v87 = a5;
            *(_BYTE *)(a1 + 1) = v142;
            *(_WORD *)(a1 + 16) = v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_10021A50(a1, (int)&v82, (int)&v118, (int)&v133);
            v142 = *(_BYTE *)(a1 + 1);
          }
          if ( v127 )
          {
            v76 = 4;
            v77 = v127;
            v78 = v114 - v120;
            v79 = v121 + v132;
            v80 = v122 + v132;
            v81 = a5;
            *(_BYTE *)(a1 + 1) = v139;
            *(_WORD *)(a1 + 16) = -v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_10021A50(a1, (int)&v76, (int)&v118, (int)&v133);
            v139 = *(_BYTE *)(a1 + 1);
          }
          if ( v123 )
          {
            v70 = 0;
            v71 = v123;
            v72 = v120 + v114;
            v73 = v132 - v121;
            v74 = v132 - v122;
            v75 = a5;
            *(_BYTE *)(a1 + 1) = v135;
            *(_WORD *)(a1 + 16) = -v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_10021A50(a1, (int)&v70, (int)&v118, (int)&v133);
            v135 = *(_BYTE *)(a1 + 1);
          }
          if ( v126 )
          {
            v64 = 3;
            v65 = v126;
            v66 = v114 - v120;
            v67 = v132 - v122;
            v68 = v132 - v121;
            v69 = a5;
            *(_BYTE *)(a1 + 1) = v138;
            *(_WORD *)(a1 + 16) = v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_10021A50(a1, (int)&v64, (int)&v118, (int)&v133);
            v138 = *(_BYTE *)(a1 + 1);
          }
          v121 = v122 + 1;
          v115 -= 2 * v120-- - 2;
        }
        v115 += 2 * v122++ + 3;
      }
      result = v120;
      if ( v122 == v120 )
      {
        v113 = 0;
        if ( v129 )
        {
          v58 = 6;
          v59 = v129;
          v60 = v120 + v132;
          v61 = v121 + v114;
          v62 = v122 + v114;
          v63 = a5;
          *(_BYTE *)(a1 + 1) = v141;
          *(_WORD *)(a1 + 16) = v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_10021A50(a1, (int)&v58, (int)&v118, (int)&v133);
          v141 = *(_BYTE *)(a1 + 1);
        }
        if ( v124 )
        {
          v52 = 1;
          v53 = v124;
          v54 = v132 - v120;
          v55 = v122 + v114;
          v56 = v121 + v114;
          v57 = a5;
          *(_BYTE *)(a1 + 1) = v136;
          *(_WORD *)(a1 + 16) = -v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_10021A50(a1, (int)&v52, (int)&v118, (int)&v133);
          v136 = *(_BYTE *)(a1 + 1);
        }
        if ( v128 )
        {
          v46 = 5;
          v47 = v128;
          v48 = v120 + v132;
          v49 = v114 - v122;
          v50 = v114 - v121;
          v51 = a5;
          *(_BYTE *)(a1 + 1) = v140;
          *(_WORD *)(a1 + 16) = -v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_10021A50(a1, (int)&v46, (int)&v118, (int)&v133);
          v140 = *(_BYTE *)(a1 + 1);
        }
        if ( v125 )
        {
          v40 = 2;
          v41 = v125;
          v42 = v132 - v120;
          v43 = v114 - v121;
          v44 = v114 - v122;
          v45 = a5;
          *(_BYTE *)(a1 + 1) = v137;
          *(_WORD *)(a1 + 16) = v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_10021A50(a1, (int)&v40, (int)&v118, (int)&v133);
          v137 = *(_BYTE *)(a1 + 1);
        }
        if ( v130 )
        {
          v34 = 7;
          v35 = v130;
          v36 = v120 + v114;
          v37 = v122 + v132;
          v38 = v121 + v132;
          v39 = a5;
          *(_BYTE *)(a1 + 1) = v142;
          *(_WORD *)(a1 + 16) = v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_10021A50(a1, (int)&v34, (int)&v118, (int)&v133);
          v142 = *(_BYTE *)(a1 + 1);
        }
        if ( v127 )
        {
          v28 = 4;
          v29 = v127;
          v30 = v114 - v120;
          v31 = v121 + v132;
          v32 = v122 + v132;
          v33 = a5;
          *(_BYTE *)(a1 + 1) = v139;
          *(_WORD *)(a1 + 16) = -v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_10021A50(a1, (int)&v28, (int)&v118, (int)&v133);
          v139 = *(_BYTE *)(a1 + 1);
        }
        if ( v123 )
        {
          v22 = 0;
          v23 = v123;
          v24 = v120 + v114;
          v25 = v132 - v121;
          v26 = v132 - v122;
          v27 = a5;
          *(_BYTE *)(a1 + 1) = v135;
          *(_WORD *)(a1 + 16) = -v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_10021A50(a1, (int)&v22, (int)&v118, (int)&v133);
          v135 = *(_BYTE *)(a1 + 1);
        }
        result = v126;
        if ( v126 )
        {
          v16 = 3;
          v17 = v126;
          v18 = v114 - v120;
          v19 = v132 - v122;
          v20 = v132 - v121;
          v21 = a5;
          *(_BYTE *)(a1 + 1) = v138;
          *(_WORD *)(a1 + 16) = v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_10021A50(a1, (int)&v16, (int)&v118, (int)&v133);
          result = a1;
          v138 = *(_BYTE *)(a1 + 1);
        }
      }
    }
  }
  else if ( a5 & 2 )
  {
    result = sub_1001E190(a1, a2, a3, a4, 0);
  }
  else
  {
    result = sub_10022310(a1, a6, a7);
  }
  return result;
}

//----- (10021A50) --------------------------------------------------------
char *__cdecl sub_10021A50(int a1, int a2, int a3, int a4)
{
  if ( (*(_BYTE *)a2 + 1) & 2 )
  {
    *(_WORD *)(a2 + 8) = *(_WORD *)(a3 + 2);
    *(_WORD *)(a2 + 10) = *(_WORD *)(a4 + 2);
  }
  else
  {
    *(_WORD *)(a2 + 8) = *(_WORD *)a3;
    *(_WORD *)(a2 + 10) = *(_WORD *)a4;
  }
  return off_10099620[*(_BYTE *)a2](a1, a2);
}
// 10099620: using guessed type int (__cdecl *off_10099620[16])(int, int);

//----- (10021AC0) --------------------------------------------------------
char __cdecl sub_10021AC0(int a1, int a2)
{
  *(_WORD *)(a1 + 8) = *(_WORD *)a2;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a2 + 2);
  *(_WORD *)(a1 + 14) = *(_WORD *)(a2 + 4) - *(_WORD *)(a2 + 2);
  return sub_1001F4F0(a1);
}

//----- (10021B10) --------------------------------------------------------
char *__cdecl sub_10021B10(int a1, int a2)
{
  *(_WORD *)(a1 + 10) = *(_WORD *)a2;
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 2);
  *(_WORD *)(a1 + 12) = *(_WORD *)(a2 + 4) - *(_WORD *)(a2 + 2);
  return sub_1001F6C0(a1);
}

//----- (10021B60) --------------------------------------------------------
signed int __cdecl sub_10021B60(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  signed int result; // eax@3
  int v6; // edx@7
  int v7; // eax@11
  char v8; // [sp+5h] [bp-3h]@1
  char i; // [sp+5h] [bp-3h]@2
  unsigned __int8 v10; // [sp+5h] [bp-3h]@3
  bool v11; // [sp+6h] [bp-2h]@7
  char v12; // [sp+7h] [bp-1h]@1

  v8 = sub_10021CB0(a2, a3);
  v12 = sub_10021CB0(a4, a5);
  if ( (unsigned __int8)v8 == (unsigned __int8)v12 )
  {
    switch ( v8 )
    {
      case 0:
      case 7:
        v6 = a5 < a3;
        v11 = a5 > a3;
        break;
      case 1:
      case 2:
        v6 = a4 < a2;
        v11 = a4 > a2;
        break;
      case 3:
      case 4:
        v6 = a5 < a3;
        v11 = a5 < a3;
        break;
      default:
        v6 = a4 < a2;
        v11 = a4 < a2;
        break;
    }
    LOBYTE(v6) = v11;
    BYTE1(v6) = v11;
    v7 = v6 << 16;
    LOWORD(v7) = v6;
    *(_DWORD *)a1 = v7;
    *(_DWORD *)(a1 + 4) = v7;
    result = v11 != 0 ? 10 : 13;
    *(_BYTE *)(a1 + (unsigned __int8)v8) = result;
  }
  else
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_BYTE *)(a1 + (unsigned __int8)v8) = 5;
    *(_BYTE *)(a1 + (unsigned __int8)v12) = 9;
    for ( i = v8 + 1; ; i = v10 + 1 )
    {
      v10 = i & 7;
      result = v10;
      if ( v10 == (unsigned __int8)v12 )
        break;
      *(_BYTE *)(a1 + v10) = 1;
    }
  }
  return result;
}

//----- (10021CB0) --------------------------------------------------------
char __cdecl sub_10021CB0(__int16 a1, __int16 a2)
{
  char v3; // [sp+1h] [bp-1h]@3

  if ( a1 >= 0 )
  {
    if ( a1 <= 0 )
    {
      v3 = 4 * (a2 >= 0) + 2;
    }
    else if ( a2 > 0 )
    {
      v3 = (a1 >= a2) + 6;
    }
    else
    {
      v3 = a1 <= -a2;
    }
  }
  else if ( a2 >= 0 )
  {
    v3 = (a1 >= -a2) + 4;
  }
  else
  {
    v3 = (a1 <= a2) + 2;
  }
  return v3;
}

//----- (10021D50) --------------------------------------------------------
char *__cdecl sub_10021D50(int a1, int a2)
{
  __int16 v2; // ST08_2@7
  char *result; // eax@11
  __int16 v4; // ST08_2@20
  int v5; // [sp+4h] [bp-8h]@3
  __int16 v6; // [sp+8h] [bp-4h]@3

  if ( (*(_BYTE *)(a2 + 1) & 3) == 2 )
  {
    if ( *(_WORD *)(a2 + 8) >= (signed int)*(_WORD *)(a2 + 6) )
    {
      v5 = *(_DWORD *)(a2 + 2);
      v6 = *(_WORD *)(a2 + 6);
      if ( *(_WORD *)(a2 + 8) < (signed int)*(_WORD *)(a2 + 4) )
        HIWORD(v5) = *(_WORD *)(a2 + 8);
      --v6;
      if ( *(_WORD *)(a1 + 4) == 4 && *(_DWORD *)(a2 + 12) & 1 )
      {
        v2 = HIWORD(v5);
        HIWORD(v5) = v6;
        v6 = v2;
      }
      off_10099640[*(_BYTE *)a2](a1, (int)&v5);
    }
  }
  else if ( *(_BYTE *)(a2 + 1) & 4 )
  {
    result = (char *)*(_WORD *)(a2 + 6);
    if ( *(_WORD *)(a2 + 8) < (signed int)result )
      return result;
    if ( *(_WORD *)(a2 + 8) < (signed int)*(_WORD *)(a2 + 4) )
      *(_WORD *)(a2 + 4) = *(_WORD *)(a2 + 8);
  }
  if ( *(_BYTE *)(a2 + 1) & 8 )
  {
    result = (char *)a2;
    if ( *(_WORD *)(a2 + 10) > (signed int)*(_WORD *)(a2 + 4) )
      return result;
    if ( *(_WORD *)(a2 + 10) > (signed int)*(_WORD *)(a2 + 6) )
      *(_WORD *)(a2 + 6) = *(_WORD *)(a2 + 10);
  }
  --*(_WORD *)(a2 + 6);
  v5 = *(_DWORD *)(a2 + 2);
  v6 = *(_WORD *)(a2 + 6);
  if ( *(_WORD *)(a1 + 4) == 4 )
  {
    if ( *(_DWORD *)(a2 + 12) & 1 )
    {
      v4 = HIWORD(v5);
      HIWORD(v5) = v6;
      v6 = v4;
    }
  }
  return off_10099640[*(_BYTE *)a2](a1, (int)&v5);
}
// 10099640: using guessed type int (__cdecl *off_10099640[8])(int, int);

//----- (10021F00) --------------------------------------------------------
char *__cdecl sub_10021F00(int a1, int a2)
{
  __int16 v2; // ST08_2@7
  char *result; // eax@11
  __int16 v4; // ST08_2@20
  int v5; // [sp+4h] [bp-8h]@3
  __int16 v6; // [sp+8h] [bp-4h]@3

  if ( (*(_BYTE *)(a2 + 1) & 3) == 2 )
  {
    if ( *(_WORD *)(a2 + 8) <= (signed int)*(_WORD *)(a2 + 6) )
    {
      v5 = *(_DWORD *)(a2 + 2);
      v6 = *(_WORD *)(a2 + 6);
      if ( *(_WORD *)(a2 + 8) > (signed int)*(_WORD *)(a2 + 4) )
        HIWORD(v5) = *(_WORD *)(a2 + 8);
      ++v6;
      if ( *(_WORD *)(a1 + 4) == 4 && *(_DWORD *)(a2 + 12) & 1 )
      {
        v2 = HIWORD(v5);
        HIWORD(v5) = v6;
        v6 = v2;
      }
      off_10099640[*(_BYTE *)a2](a1, (int)&v5);
    }
  }
  else if ( *(_BYTE *)(a2 + 1) & 4 )
  {
    result = (char *)*(_WORD *)(a2 + 6);
    if ( *(_WORD *)(a2 + 8) > (signed int)result )
      return result;
    if ( *(_WORD *)(a2 + 8) > (signed int)*(_WORD *)(a2 + 4) )
      *(_WORD *)(a2 + 4) = *(_WORD *)(a2 + 8);
  }
  if ( *(_BYTE *)(a2 + 1) & 8 )
  {
    result = (char *)a2;
    if ( *(_WORD *)(a2 + 10) < (signed int)*(_WORD *)(a2 + 4) )
      return result;
    if ( *(_WORD *)(a2 + 10) < (signed int)*(_WORD *)(a2 + 6) )
      *(_WORD *)(a2 + 6) = *(_WORD *)(a2 + 10);
  }
  ++*(_WORD *)(a2 + 6);
  v5 = *(_DWORD *)(a2 + 2);
  v6 = *(_WORD *)(a2 + 6);
  if ( *(_WORD *)(a1 + 4) == 4 )
  {
    if ( *(_DWORD *)(a2 + 12) & 1 )
    {
      v4 = HIWORD(v5);
      HIWORD(v5) = v6;
      v6 = v4;
    }
  }
  return off_10099640[*(_BYTE *)a2](a1, (int)&v5);
}
// 10099640: using guessed type int (__cdecl *off_10099640[8])(int, int);

//----- (100220B0) --------------------------------------------------------
int __cdecl sub_100220B0(int a1, __int16 a2, __int16 a3, __int16 a4)
{
  int result; // eax@5
  int v5; // [sp+0h] [bp-18h]@6
  __int16 v6; // [sp+4h] [bp-14h]@6
  int v7; // [sp+8h] [bp-10h]@1
  __int16 v8; // [sp+Ch] [bp-Ch]@6
  __int16 v9; // [sp+10h] [bp-8h]@1
  __int16 v10; // [sp+14h] [bp-4h]@1

  v7 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 48);
  v10 = *(_WORD *)(a1 + 42) + a2;
  v9 = *(_WORD *)(a1 + 40) + a3;
  if ( v10 - a4 < *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
    && a4 + v10 >= *(_WORD *)(a1 + 26)
    && v9 - a4 < *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
    && a4 + v9 >= *(_WORD *)(a1 + 24) )
  {
    v8 = 0;
    v6 = a4;
    v5 = 1 - a4;
    while ( v8 < v6 )
    {
      if ( v5 >= 0 )
      {
        *(_WORD *)(a1 + 10) = v8 + v10;
        *(_WORD *)(a1 + 8) = v6 + v9;
        *(_WORD *)(a1 + 14) = v10 - v8;
        sub_1001F440(a1);
        *(_WORD *)(a1 + 8) = v9 - v6;
        sub_1001F440(a1);
        v5 -= 2 * v6-- - 2;
      }
      *(_WORD *)(a1 + 10) = v6 + v10;
      *(_WORD *)(a1 + 8) = v8 + v9;
      *(_WORD *)(a1 + 14) = v10 - v6;
      sub_1001F440(a1);
      *(_WORD *)(a1 + 8) = v9 - v8;
      sub_1001F440(a1);
      v5 += 2 * v8++ + 3;
    }
    result = v8;
    if ( v8 == v6 )
    {
      *(_WORD *)(a1 + 10) = v6 + v10;
      *(_WORD *)(a1 + 8) = v8 + v9;
      *(_WORD *)(a1 + 14) = v10 - v6;
      sub_1001F440(a1);
      *(_WORD *)(a1 + 8) = v9 - v8;
      LOBYTE(result) = sub_1001F440(a1);
    }
    *(_DWORD *)(a1 + 36) = v7;
  }
  else
  {
    result = v7;
    *(_DWORD *)(a1 + 36) = v7;
  }
  return result;
}

//----- (10022310) --------------------------------------------------------
int __cdecl sub_10022310(int a1, __int16 a2, __int16 a3)
{
  *(_WORD *)(a1 + 46) = a2;
  *(_WORD *)(a1 + 44) = a3;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 46) + *(_WORD *)(a1 + 42);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 44) + *(_WORD *)(a1 + 40);
  return sub_1001F660(a1);
}

//----- (10022370) --------------------------------------------------------
void *sub_10022370()
{
  void *v0; // esi@1
  signed int v1; // edi@1
  void *result; // eax@3

  byte_107896CC = 1;
  byte_107896D2 = 1;
  word_107896D4 = 0;
  word_107896D0 = 0;
  word_107896CE = 0;
  byte_107896D6 = 0;
  sub_10022720();
  sub_100227E0((int)&unk_104DAD18, 80, 80);
  sub_10022830();
  sub_100227E0((int)&unk_104E5054, 60, 60);
  memset(&unk_104E5028, 0, 0x2Cu);
  dword_104E6C74 = 0;
  dword_104E6C78 = 0;
  dword_104E6C7C = 0;
  dword_104E6C80 = 0;
  dword_104E6C84 = 0;
  dword_104E6C88 = 0;
  dword_104E6C8C = 0;
  dword_104E6C90 = 0;
  dword_104E6C94 = 0;
  dword_104E6C98 = 0;
  dword_104E6C9C = 0;
  dword_104E6CA0 = 0;
  dword_104E6CAC = -536868000;
  dword_104E6CB0 = -1073736000;
  dword_104E6CA4 = 536868000;
  dword_104E6CA8 = 1073736000;
  memset(&unk_104DDF28, 0, 0x2Cu);
  v0 = &unk_104DDF54;
  v1 = 4;
  do
  {
    sub_100227E0((int)v0, 60, 60);
    v0 = (char *)v0 + 7200;
    --v1;
  }
  while ( v1 );
  result = memset(&unk_104E4FD4, 0, 0x50u);
  dword_104E5024 = 0;
  return result;
}
// 104E5024: using guessed type int dword_104E5024;
// 104E6C74: using guessed type int dword_104E6C74;
// 104E6C78: using guessed type int dword_104E6C78;
// 104E6C7C: using guessed type int dword_104E6C7C;
// 104E6C80: using guessed type int dword_104E6C80;
// 104E6C84: using guessed type int dword_104E6C84;
// 104E6C88: using guessed type int dword_104E6C88;
// 104E6C8C: using guessed type int dword_104E6C8C;
// 104E6C90: using guessed type int dword_104E6C90;
// 104E6C94: using guessed type int dword_104E6C94;
// 104E6C98: using guessed type int dword_104E6C98;
// 104E6C9C: using guessed type int dword_104E6C9C;
// 104E6CA0: using guessed type int dword_104E6CA0;
// 104E6CA4: using guessed type int dword_104E6CA4;
// 104E6CA8: using guessed type int dword_104E6CA8;
// 104E6CAC: using guessed type int dword_104E6CAC;
// 104E6CB0: using guessed type int dword_104E6CB0;
// 107896CC: using guessed type char byte_107896CC;
// 107896CE: using guessed type __int16 word_107896CE;
// 107896D0: using guessed type __int16 word_107896D0;
// 107896D2: using guessed type char byte_107896D2;
// 107896D4: using guessed type __int16 word_107896D4;
// 107896D6: using guessed type char byte_107896D6;

//----- (100223A0) --------------------------------------------------------
int __cdecl sub_100223A0(char a1, void *a2, size_t a3, int a4)
{
  int result; // eax@1

  result = sub_10016E90(a1, a2, a3, *(_DWORD *)a4);
  if ( !result )
    *(_DWORD *)a4 += a3;
  return result;
}

//----- (100223D0) --------------------------------------------------------
int __usercall sub_100223D0@<eax>(int a1@<esi>)
{
  int result; // eax@1
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 152;
  result = sub_100223A0(1, (void *)a1, 0x14u, (int)&v2);
  if ( !result )
  {
    result = 4;
    if ( *(_DWORD *)(a1 + 8) )
    {
      if ( *(_DWORD *)(a1 + 12) )
        result = 0;
    }
  }
  return result;
}

//----- (10022410) --------------------------------------------------------
int __cdecl sub_10022410(char a1, void *a2, size_t a3, int a4, size_t a5, int a6, size_t a7, int a8, size_t a9, int a10, int a11, int a12, size_t a13)
{
  int result; // eax@4
  const char *v14; // ebp@6
  char v15; // dl@9
  __int16 v16; // ax@9
  char v17; // dl@14
  __int16 v18; // ax@14
  int v19; // [sp+10h] [bp-298h]@5
  void *v20; // [sp+14h] [bp-294h]@1
  void *v21; // [sp+18h] [bp-290h]@1
  void *v22; // [sp+1Ch] [bp-28Ch]@1
  void *v23; // [sp+20h] [bp-288h]@1
  int v24; // [sp+24h] [bp-284h]@5
  int v25; // [sp+28h] [bp-280h]@8
  int v26; // [sp+2Ch] [bp-27Ch]@19
  char v27; // [sp+30h] [bp-278h]@6
  char v28; // [sp+43h] [bp-265h]@6
  char v29; // [sp+44h] [bp-264h]@6
  char v30; // [sp+6Bh] [bp-23Dh]@6
  char v31; // [sp+6Ch] [bp-23Ch]@6
  char v32; // [sp+8Bh] [bp-21Dh]@6
  char v33; // [sp+9Ah] [bp-20Eh]@6
  char v34; // [sp+9Fh] [bp-209h]@6
  int v35; // [sp+A6h] [bp-202h]@11
  int v36; // [sp+AAh] [bp-1FEh]@13
  char v37; // [sp+B0h] [bp-1F8h]@19
  char v38; // [sp+B8h] [bp-1F0h]@20

  v21 = (void *)a6;
  v23 = (void *)a4;
  v22 = (void *)a8;
  v20 = (void *)a12;
  memset(a2, 0, a3);
  memset((void *)a4, 0, a5);
  memset((void *)a6, 0, a7);
  memset((void *)a8, 0, a9);
  memset((void *)a12, 0, a13);
  *(_BYTE *)(a10 + 1) = 0;
  *(_BYTE *)a10 = 0;
  *(_WORD *)(a10 + 2) = 0;
  *(_BYTE *)(a11 + 1) = 0;
  *(_BYTE *)a11 = 0;
  *(_WORD *)(a11 + 2) = 0;
  if ( a1 && a1 != 1 && a1 != 2 )
  {
    result = 4;
  }
  else
  {
    v19 = 16;
    v19 = sub_100223A0(a1, &v24, 0x88u, (int)&v19);
    if ( !v19 )
    {
      v32 = 0;
      v34 = 0;
      v28 = 0;
      v30 = 0;
      sub_100365D0((int)a2, &v31, a3);
      v14 = (const char *)v23;
      sub_100365D0((int)v23, &v33, a5);
      sub_100365D0((int)v21, &v27, a7);
      sub_100365D0((int)v22, &v29, a9);
      if ( (unsigned __int16)(v24 - 1) <= 0x1Eu
        && (unsigned __int16)(HIWORD(v24) - 1) <= 0xBu
        && (unsigned __int16)(v25 - 1990) <= 0x6Eu )
      {
        v15 = BYTE2(v24);
        v16 = v25;
        *(_BYTE *)(a10 + 1) = v24;
        *(_BYTE *)a10 = v15;
        *(_WORD *)(a10 + 2) = v16;
      }
      if ( a1 == 1
        && (unsigned __int16)(v35 - 1) <= 0x1Eu
        && (unsigned __int16)(HIWORD(v35) - 1) <= 0xBu
        && (unsigned __int16)(v36 - 1990) <= 0x6Eu )
      {
        v17 = BYTE2(v35);
        v18 = v36;
        *(_BYTE *)(a11 + 1) = v35;
        *(_BYTE *)a11 = v17;
        *(_WORD *)(a11 + 2) = v18;
      }
      sub_100365D0((int)v20, "____", a13);
      if ( !memcmp(v14, "2.00", 5u) )
      {
        if ( (unsigned __int8)a1 < 3u )
          sub_100365D0((int)v20, off_10099A80[(unsigned __int8)a1], a13);
      }
      else if ( memcmp(v14, "2.01", 5) >= 0 )
      {
        v19 = v26 - 501;
        v19 = sub_100223A0(a1, &v37, 0x1F4u, (int)&v19);
        if ( !v19 )
          sub_100365D0((int)v20, &v38, a13);
      }
    }
    result = v19;
  }
  return result;
}
// 10099A80: using guessed type char *off_10099A80[3];

//----- (10022720) --------------------------------------------------------
char sub_10022720()
{
  int v0; // edi@1
  int v1; // ebp@1
  int v2; // eax@1
  int v4; // [sp+10h] [bp-18h]@1
  char v5; // [sp+14h] [bp-14h]@1
  __int16 v6; // [sp+24h] [bp-4h]@2

  word_107896CE = 0;
  word_107896D0 = 0;
  word_107896D4 = 0;
  memset(&unk_104DACB4, 0, 0x2Cu);
  byte_104DACE0 = 0;
  v4 = 152;
  v0 = sub_100223A0(2, &word_107896D0, 2u, (int)&v4);
  v4 = 152;
  v1 = sub_100223A0(0, &word_107896D4, 2u, (int)&v4);
  v2 = sub_100223D0((int)&v5);
  if ( v2 )
    byte_107896CC = 7;
  else
    word_107896CE = v6;
  if ( v0 || v2 || v1 )
  {
    byte_107896D2 = 0;
    byte_107896D6 = 0;
  }
  else
  {
    LOBYTE(v2) = 1;
    byte_107896D2 = 1;
    byte_107896D6 = 1;
  }
  return v2;
}
// 104DACE0: using guessed type char byte_104DACE0;
// 107896CC: using guessed type char byte_107896CC;
// 107896CE: using guessed type __int16 word_107896CE;
// 107896D0: using guessed type __int16 word_107896D0;
// 107896D2: using guessed type char byte_107896D2;
// 107896D4: using guessed type __int16 word_107896D4;
// 107896D6: using guessed type char byte_107896D6;

//----- (100227E0) --------------------------------------------------------
void __cdecl sub_100227E0(int a1, signed int a2, signed int a3)
{
  int v3; // ebx@1
  int v4; // ecx@2
  int v5; // edx@3
  int v6; // ecx@4
  int v7; // eax@4

  v3 = 0;
  if ( a2 > 0 )
  {
    v4 = 0;
    do
    {
      v5 = 0;
      if ( a3 > 0 )
      {
        v6 = a3 * v4;
        v7 = 0;
        do
        {
          ++v5;
          *(_WORD *)(a1 + 2 * (v6 + v7)) = -32767;
          v7 = (unsigned __int16)v5;
        }
        while ( (unsigned __int16)v5 < a3 );
      }
      v4 = (unsigned __int16)++v3;
    }
    while ( (unsigned __int16)v3 < a2 );
  }
}

//----- (10022830) --------------------------------------------------------
signed int sub_10022830()
{
  signed int result; // eax@1

  memset(&unk_104DACE8, 0, 0x30u);
  dword_104DACF0 = 1073736000;
  dword_104DACF4 = 1073736000;
  result = -1073736000;
  byte_104DDF18 = 0;
  dword_104DAD08 = -1;
  dword_104DACF8 = -1073736000;
  dword_104DACFC = -1073736000;
  return result;
}
// 104DACF0: using guessed type int dword_104DACF0;
// 104DACF4: using guessed type int dword_104DACF4;
// 104DACF8: using guessed type int dword_104DACF8;
// 104DACFC: using guessed type int dword_104DACFC;
// 104DAD08: using guessed type int dword_104DAD08;
// 104DDF18: using guessed type char byte_104DDF18;

//----- (10022970) --------------------------------------------------------
int __cdecl sub_10022970(signed int a1, signed int a2)
{
  int result; // eax@2
  int v3; // eax@3

  if ( a2 > 0 )
  {
    v3 = a2 * (a1 / a2);
    if ( a1 == v3 )
      result = a1;
    else
      result = (a1 < 0 ? 0 : a2) + v3;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (100229B0) --------------------------------------------------------
double __cdecl sub_100229B0(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 != v4 && (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v11 = v2 + v9;
        result = v11;
      }
      else
      {
        v10 = v4;
        result = v10;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10022A50) --------------------------------------------------------
int __cdecl sub_10022A50(signed int a1, signed int a2)
{
  int result; // eax@2

  if ( a2 > 0 )
  {
    result = a2 * (a1 / a2);
    if ( a1 == result )
    {
      result = a1;
    }
    else if ( a1 < 0 )
    {
      result -= a2;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10022A90) --------------------------------------------------------
double __cdecl sub_10022A90(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 == v4 || (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v10 = v4;
        result = v10;
      }
      else
      {
        v11 = v9 - v2;
        result = v11;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10022B30) --------------------------------------------------------
double __cdecl sub_10022B30(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@5
  float v6; // [sp+8h] [bp+8h]@3
  float v7; // [sp+8h] [bp+8h]@3
  float v8; // [sp+8h] [bp+8h]@4
  float v9; // [sp+8h] [bp+8h]@6

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v6 = v2 + v2;
    v4 = v6;
    v7 = a1 - (double)(signed int)(a1 / v6) * v6;
    if ( v7 < v2 )
    {
      v5 = v2;
      result = v7;
      if ( -v5 > v7 )
      {
        v9 = result + v4;
        result = v9;
      }
    }
    else
    {
      v8 = v7 - v4;
      result = v8;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (10022BB0) --------------------------------------------------------
double __cdecl sub_10022BB0(float a1)
{
  double result; // st7@3

  if ( a1 == -3.141592741012573 || a1 == 3.141592741012573 )
    result = -3.1415925;
  else
    result = sub_10022B30(a1, 3.1415927);
  return result;
}

//----- (10022BF0) --------------------------------------------------------
int __cdecl sub_10022BF0(float a1)
{
  double v1; // st7@1
  int result; // eax@2

  v1 = a1;
  if ( a1 >= 0.0 )
    result = (signed int)(v1 + 0.5);
  else
    result = (signed int)(v1 - 0.5);
  return result;
}

//----- (10022C20) --------------------------------------------------------
int __cdecl sub_10022C20(signed int a1, signed int a2)
{
  int result; // eax@2
  int v3; // [sp+4h] [bp-4h]@4

  if ( a2 > 0 )
  {
    if ( a1 >= 0 )
      v3 = a2;
    else
      v3 = -a2;
    result = a2 * (signed int)(((double)v3 * 0.5 + (double)a1) / (double)a2);
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10022C70) --------------------------------------------------------
double __cdecl sub_10022C70(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  float v4; // [sp+8h] [bp+8h]@5

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    if ( a1 < 0.0 )
      a2 = -v2;
    v4 = v2 * (double)(signed int)((a1 + a2 * 0.5) / v2);
    result = v4;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10022CE0) --------------------------------------------------------
int __cdecl sub_10022CE0(float a1)
{
  int result; // eax@2

  if ( a1 <= 0.0 )
  {
    if ( a1 >= 0.0 )
      result = 0;
    else
      result = -1;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10022D10) --------------------------------------------------------
int __cdecl sub_10022D10(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(float *)a3 = *(float *)a1 + *(float *)a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) + *(float *)(a2 + 4);
  *(float *)(a3 + 8) = *(float *)(a1 + 8) + *(float *)(a2 + 8);
  return result;
}

//----- (10022D40) --------------------------------------------------------
double __cdecl sub_10022D40(int a1, int a2)
{
  return (float)(*(float *)(a1 + 4) * *(float *)(a2 + 4)
               + *(float *)a1 * *(float *)a2
               + *(float *)(a1 + 8) * *(float *)(a2 + 8));
}

//----- (10022D70) --------------------------------------------------------
double __cdecl sub_10022D70(int a1)
{
  float v1; // ST00_4@1
  float v2; // ST00_4@1
  float v3; // ST00_4@1

  v1 = *(float *)a1 * *(float *)a1 + 0.0;
  v2 = *(float *)(a1 + 4) * *(float *)(a1 + 4) + v1;
  v3 = *(float *)(a1 + 8) * *(float *)(a1 + 8) + v2;
  return (float)sqrt(v3);
}

//----- (10022DB0) --------------------------------------------------------
int __cdecl sub_10022DB0(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(float *)a3 = *(float *)a2 * a1;
  *(float *)(a3 + 4) = *(float *)(a2 + 4) * a1;
  *(float *)(a3 + 8) = a1 * *(float *)(a2 + 8);
  return result;
}

//----- (10022DE0) --------------------------------------------------------
unsigned __int16 __cdecl sub_10022DE0(_BYTE *a1, int a2, unsigned __int16 a3, char a4)
{
  _BYTE *v4; // ecx@1
  int v5; // esi@2
  unsigned __int16 result; // ax@3
  __int16 v7; // bx@4
  unsigned int v8; // edx@4
  int v9; // edx@6
  int v10; // esi@8

  v4 = a1;
  if ( a4 == 1 )
  {
    v5 = a2;
    if ( a2 )
    {
      result = a3;
      do
      {
        LOBYTE(v7) = 0;
        HIBYTE(v7) = result;
        v8 = *v4 ^ ((unsigned int)result >> 8);
        --v5;
        ++v4;
        result = word_10099C78[v8] ^ v7;
      }
      while ( v5 );
      return result;
    }
    return a3;
  }
  v9 = a2;
  if ( !a2 )
    return a3;
  result = a3;
  do
  {
    v10 = (unsigned __int8)result ^ *v4;
    --v9;
    ++v4;
    result = word_10099E78[v10] ^ HIBYTE(result);
  }
  while ( v9 );
  return result;
}
// 10099C78: using guessed type __int16 word_10099C78[];
// 10099E78: using guessed type __int16 word_10099E78[];

//----- (10022E60) --------------------------------------------------------
int __cdecl sub_10022E60(unsigned __int8 a1, unsigned int a2)
{
  return dword_1009A078[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 1009A078: using guessed type int dword_1009A078[];

//----- (10022E80) --------------------------------------------------------
unsigned int __cdecl sub_10022E80(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_1009A078[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_1009A078[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_1009A078[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_1009A078[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_1009A078[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_1009A078[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_1009A078[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_1009A078[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_1009A078[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_1009A078[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 1009A078: using guessed type int dword_1009A078[];

//----- (10022FB0) --------------------------------------------------------
bool __thiscall sub_10022FB0(void *this)
{
  bool result; // al@3
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  if ( byte_104E6CB4 && sub_10036FE0(this) != 8 )
  {
    sub_100396A0((bool *)&v2 + 3);
    result = BYTE3(v2) == 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 104E6CB4: using guessed type char byte_104E6CB4;

//----- (10022FE0) --------------------------------------------------------
char __cdecl sub_10022FE0(char a1)
{
  char result; // al@1

  result = a1;
  byte_104E6CB4 = a1;
  return result;
}
// 104E6CB4: using guessed type char byte_104E6CB4;

//----- (10022FF0) --------------------------------------------------------
_WORD *__usercall sub_10022FF0@<eax>(_WORD *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, __int16 a5)
{
  _WORD *result; // eax@1
  _WORD *v6; // [sp+0h] [bp-4h]@1

  v6 = a1;
  sub_10037480(*(char **)(a2 + 8), (int *)&v6, 0);
  result = v6;
  *(_WORD *)a4 = *(_WORD *)a3 + *v6;
  *(_WORD *)(a4 + 2) = *(_WORD *)(a3 + 2) + result[1] + a5 * *(_WORD *)(a2 + 18);
  return result;
}

//----- (10023030) --------------------------------------------------------
__int16 __usercall sub_10023030@<ax>(int a1@<eax>, _WORD *a2@<ecx>, int a3, int a4)
{
  _WORD *v4; // edi@1
  int v5; // ebp@1
  _WORD *v6; // ebx@1
  signed int v7; // eax@1
  __int16 v8; // ax@3
  __int16 v9; // cx@3
  __int16 result; // ax@5
  char v11; // [sp+10h] [bp-4h]@1
  __int16 v12; // [sp+12h] [bp-2h]@1

  v4 = (_WORD *)a1;
  v5 = *(_DWORD *)(a4 + 12);
  v6 = a2;
  sub_10022FF0(a2, (int)a2, a1, (int)&v11, 0);
  *(_WORD *)(a3 + 284) = 0;
  *(_WORD *)(a3 + 286) = 0;
  *(_WORD *)(a3 + 288) = 0;
  *(_WORD *)(a3 + 290) = v12 + v6[9] * v6[8];
  ((void (__cdecl *)(int, _DWORD, char *, _DWORD, void *))dword_10789180[2 * (**((_DWORD **)v6 + 2) & 0xFF)])(
    a3,
    *((_DWORD *)v6 + 2),
    &v11,
    *(_DWORD *)(a4 + 16),
    &unk_100B0974);
  v7 = *(_WORD *)(a3 + 276);
  if ( *v4 < v7 )
    LOWORD(v7) = *v4;
  *(_WORD *)(v5 + 36) = v7;
  v8 = *(_WORD *)(a3 + 278);
  *(_WORD *)(v5 + 38) = v8;
  v9 = *(_WORD *)(a3 + 280);
  *(_DWORD *)(v5 + 8) = 99;
  *(_WORD *)(v5 + 40) = v9;
  *(_DWORD *)(v5 + 12) = 5;
  *(_DWORD *)(v5 + 16) = 1;
  *(_WORD *)(v5 + 42) = v8;
  *(_WORD *)(v5 + 16) = *v4 + v6[10];
  if ( !v6[10] )
    *(_WORD *)(v5 + 16) = *(_WORD *)(v5 + 40) + 2;
  *(_WORD *)(v5 + 18) = v8;
  result = *(_WORD *)(a3 + 282) + v6[9] * (v6[8] - 1) - *(_WORD *)(a3 + 278) + 1;
  *(_WORD *)(v5 + 14) = result;
  *(_WORD *)(v5 + 22) = v6[8];
  return result;
}
// 10789180: using guessed type int dword_10789180[];

//----- (10023150) --------------------------------------------------------
int __usercall sub_10023150@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  int result; // eax@1

  result = (unsigned __int16)(*(_WORD *)(a1 + 38) + *(_WORD *)(a2 + 16) * *(_WORD *)(a2 + 18));
  if ( *(_WORD *)(a2 + 4) & 0x800 )
  {
    if ( (signed __int16)result >= (signed int)*(_WORD *)(a3 + 290) )
      LOWORD(result) = *(_WORD *)(a3 + 290);
    result = (unsigned __int16)result;
  }
  return result;
}

//----- (10023180) --------------------------------------------------------
__int16 __usercall sub_10023180@<ax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4, int a5, __int16 a6, __int16 a7)
{
  _DWORD *v7; // ecx@1
  void (__cdecl *v8)(int, _DWORD, int *, int, void *, int); // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  int v12; // [sp+0h] [bp-4h]@1

  v12 = a1;
  v7 = *(_DWORD **)(a2 + 8);
  v12 = 0;
  v8 = (void (__cdecl *)(int, _DWORD, int *, int, void *, int))dword_10789180[2 * (*v7 & 0xFF)];
  *(_WORD *)(a3 + 284) = 0;
  *(_WORD *)(a3 + 286) = 0;
  *(_WORD *)(a3 + 288) = 0;
  *(_WORD *)(a3 + 290) = *(_WORD *)(a2 + 18) * *(_WORD *)(a2 + 16) - a7;
  *(_WORD *)(a4 + 6) = a6;
  v8(a3, *(_DWORD *)(a2 + 8), &v12, a5, &unk_100B0974, v12);
  v9 = *(_WORD *)(a3 + 282) - *(_WORD *)(a3 + 278);
  v10 = *(_WORD *)(a2 + 18);
  if ( v10 > v9 )
    LOWORD(v9) = *(_WORD *)(a2 + 18);
  return v9;
}
// 10789180: using guessed type int dword_10789180[];

//----- (10023210) --------------------------------------------------------
char __usercall sub_10023210@<al>(__int16 a1@<ax>, int a2@<edx>, int a3, int a4)
{
  char result; // al@3

  if ( a1 < 0 || a1 >= (signed int)*(_WORD *)(a2 + 8) )
    result = 0;
  else
    result = (*(int (__cdecl **)(int, int, __int16))(*(_DWORD *)(a2 + 12) + 28))(a3, a4, a1);
  return result;
}

//----- (10023240) --------------------------------------------------------
signed int __usercall sub_10023240@<eax>(__int16 a1@<ax>, int a2@<ecx>, int a3@<edi>, char a4, char a5)
{
  __int16 v5; // si@1
  __int16 v6; // ax@1
  signed int result; // eax@2
  int v8; // eax@6

  v5 = a1;
  v6 = *(_WORD *)(a2 + 4);
  *(_WORD *)(a2 + 2) = v5;
  if ( v5 < v6 || (result = a3 + v6, v5 >= result) || a5 )
  {
    *(_WORD *)(a2 + 4) = v5;
    if ( a4 )
      *(_WORD *)(a2 + 4) = v5 - (a3 + 1) / 2 + 1;
    v8 = *(_WORD *)(a2 + 8) - a3;
    if ( *(_WORD *)(a2 + 4) < v8 )
      LOWORD(v8) = *(_WORD *)(a2 + 4);
    result = (signed __int16)v8 < 0 ? 0 : (signed __int16)v8;
    *(_WORD *)(a2 + 4) = result;
  }
  return result;
}

//----- (100232B0) --------------------------------------------------------
BOOL __usercall sub_100232B0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@1

  v2 = *(_BYTE *)(a1 + 4) & 0x60;
  return v2 == 64 || v2 == 32 && *(_WORD *)(a2 + 10) < *(_WORD *)(a2 + 8);
}

//----- (100232E0) --------------------------------------------------------
__int16 __usercall sub_100232E0@<ax>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>, int a5, int a6, __int16 a7)
{
  int v7; // ebp@1
  int v8; // eax@1
  char v9; // cl@1
  __int16 v10; // cx@1
  int v11; // ecx@1
  __int16 v12; // cx@8
  __int16 v13; // dx@10
  __int16 v14; // ax@10
  __int16 v15; // cx@15
  char v16; // al@15
  _WORD *v17; // ST10_4@15
  char v18; // ST18_1@15
  int v19; // eax@17
  __int16 result; // ax@20
  bool v21; // [sp+4h] [bp-34h]@6
  char v22; // [sp+5h] [bp-33h]@1
  bool v23; // [sp+6h] [bp-32h]@3
  char v24; // [sp+7h] [bp-31h]@1
  int v25; // [sp+8h] [bp-30h]@1
  __int16 v26; // [sp+Ch] [bp-2Ch]@8
  __int16 v27; // [sp+10h] [bp-28h]@14
  __int16 v28; // [sp+14h] [bp-24h]@15
  __int16 v29; // [sp+16h] [bp-22h]@15
  void (__cdecl *v30)(int, _DWORD, int, _DWORD, void *); // [sp+18h] [bp-20h]@1
  int v31; // [sp+1Ch] [bp-1Ch]@1
  int v32; // [sp+20h] [bp-18h]@1
  _WORD *v33; // [sp+24h] [bp-14h]@1
  int v34; // [sp+28h] [bp-10h]@1
  __int16 v35; // [sp+2Ch] [bp-Ch]@15
  __int16 v36; // [sp+2Eh] [bp-Ah]@15
  __int16 v37; // [sp+30h] [bp-8h]@1

  v31 = a5;
  v7 = *(_DWORD *)(a5 + 12);
  v8 = *(_DWORD *)v7;
  v33 = (_WORD *)a1;
  v9 = *(_BYTE *)(a4 + 3);
  v32 = a6;
  v25 = v8;
  v24 = v9;
  LOWORD(v8) = *(_WORD *)(a3 + 4);
  v22 = *(_BYTE *)(a4 + 9);
  v10 = *(_WORD *)(a3 + 4);
  v30 = (void (__cdecl *)(int, _DWORD, int, _DWORD, void *))dword_10789180[2 * (**(_DWORD **)(a3 + 8) & 0xFF)];
  v11 = v10 & 0x300;
  v34 = 96;
  v37 = v8 & 0x1F | 32 * (v8 & 0x1F | 0x40);
  if ( a6 )
  {
    *(_BYTE *)(a4 + 3) = 0;
    *(_BYTE *)(a4 + 9) = 0;
  }
  v23 = *(_BYTE *)(a6 + *(_DWORD *)(v7 + 4)) != 0;
  v21 = v11 == 512 || v11 == 256 && !*(_BYTE *)(a6 + *(_DWORD *)(v7 + 4));
  *(_WORD *)(a4 + 284) = 0;
  *(_WORD *)(a4 + 286) = 0;
  *(_WORD *)(a4 + 288) = 0;
  *(_WORD *)(a4 + 290) = *(_WORD *)(v7 + 38) + *(_WORD *)(a3 + 16) * *(_WORD *)(a3 + 18) - *(_WORD *)(a2 + 2);
  *(_WORD *)(v31 + 6) = a7;
  v30(a4, *(_DWORD *)(a3 + 8), a2, *(_DWORD *)(v25 + 4 * a6), &unk_100B0974);
  v12 = *(_WORD *)(a4 + 278);
  v26 = *(_WORD *)(a3 + 18);
  if ( *(_WORD *)(a3 + 18) <= *(_WORD *)(a4 + 282) - (signed int)*(_WORD *)(a4 + 278) )
    v26 = *(_WORD *)(a4 + 282) - *(_WORD *)(a4 + 278);
  v13 = *(_WORD *)(a2 + 2);
  v14 = *(_WORD *)(a4 + 278);
  if ( v12 > v13 )
  {
    if ( *(_WORD *)(a4 + 282) > *(_WORD *)(a3 + 18) + v13 )
      v14 = *(_WORD *)(a4 + 278);
    else
      v14 = *(_WORD *)(a2 + 2);
  }
  v27 = v26 + v12;
  if ( v21 )
  {
    v15 = *(_WORD *)(v7 + 36);
    v29 = v14;
    v16 = *(_BYTE *)(a4 + 3);
    v36 = v26;
    v28 = v15;
    v17 = v33;
    v35 = *(_WORD *)(v7 + 16) - *(_WORD *)(v7 + 36) - 2;
    v18 = v16;
    *(_BYTE *)(a4 + 3) = 0;
    sub_10031840(a4, (int)&v34, (int)&v28, 0, v17);
    *(_BYTE *)(a4 + 3) = v18;
  }
  if ( v23 )
  {
    v19 = v32;
    if ( *(_BYTE *)(v32 + *(_DWORD *)(v7 + 4)) == 2 )
      *(_BYTE *)(*(_DWORD *)(v25 + 4 * v32) + 4) |= 8u;
    *(_WORD *)(a4 + 284) = 0;
    *(_WORD *)(a4 + 286) = 0;
    *(_WORD *)(a4 + 288) = 0;
    *(_WORD *)(a4 + 290) = *(_WORD *)(v7 + 38) + *(_WORD *)(a3 + 16) * *(_WORD *)(a3 + 18) - *(_WORD *)(a2 + 2);
    *(_WORD *)(v31 + 6) = a7;
    v30(a4, *(_DWORD *)(a3 + 8), a2, *(_DWORD *)(v25 + 4 * v19), v33);
  }
  *(_BYTE *)(a4 + 9) = v22;
  result = v27;
  *(_BYTE *)(a4 + 3) = v24;
  *(_WORD *)(a2 + 2) += v26;
  return result;
}
// 10789180: using guessed type int dword_10789180[];

//----- (10023550) --------------------------------------------------------
unsigned int __usercall sub_10023550@<eax>(_WORD *a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  int v5; // edx@1
  int v6; // eax@1
  char *v7; // ecx@1
  int v8; // edi@1
  unsigned int result; // eax@1
  bool v10; // zf@1
  int v11; // esi@2
  int v12; // eax@2
  __int16 v13; // ax@5
  bool v14; // sf@5
  int v15; // eax@6
  __int16 v16; // ax@9
  __int16 v17; // dx@13
  char v18; // cl@13
  char v19; // ST27_1@13
  int v20; // eax@14
  __int16 v21; // ax@18
  int v22; // [sp+14h] [bp-34h]@2
  int v23; // [sp+14h] [bp-34h]@6
  int v24; // [sp+18h] [bp-30h]@1
  int v25; // [sp+1Ch] [bp-2Ch]@1
  _WORD *v26; // [sp+20h] [bp-28h]@1
  __int16 v27; // [sp+24h] [bp-24h]@1
  int v28; // [sp+2Ch] [bp-1Ch]@1
  __int16 v29; // [sp+30h] [bp-18h]@13
  __int16 v30; // [sp+32h] [bp-16h]@13
  char v31; // [sp+34h] [bp-14h]@1
  int v32; // [sp+38h] [bp-10h]@1
  __int16 v33; // [sp+3Ch] [bp-Ch]@13
  __int16 v34; // [sp+3Eh] [bp-Ah]@13
  __int16 v35; // [sp+40h] [bp-8h]@1

  v26 = a1;
  v5 = *(_DWORD *)(a2 + 12);
  v25 = a2;
  v6 = *(_WORD *)(a4 + 16) - *(_WORD *)(a2 + 10);
  v7 = (char *)*(_WORD *)(v5 + 34);
  v24 = v5;
  v28 = (int)&v7[v6];
  v27 = *(_WORD *)(v5 + 38);
  sub_10022FF0(v7, a4, a5, (int)&v31, 0);
  v8 = v25;
  result = *(_WORD *)(a4 + 4) & 0xFFFF001F;
  v10 = *(_WORD *)(v25 + 10) == 0;
  v32 = 96;
  v35 = result | 32 * (result | 0x40);
  if ( v10 )
  {
    if ( *(_WORD *)(a4 + 4) & 0x800 )
      return result;
    v11 = v24;
  }
  else
  {
    v11 = v24;
    v12 = *(_WORD *)(v24 + 34);
    v22 = *(_WORD *)(v24 + 34);
    if ( v12 >= 0 )
    {
      while ( 1 )
      {
        v13 = sub_100232E0((int)v26, (int)&v31, a4, a3, v8, v12, *(_WORD *)(v11 + 34) + *(_WORD *)(v8 + 4) - v12);
        v11 = v24;
        v8 = v25;
        v14 = v22-- - 1 < 0;
        v27 = v13;
        if ( v14 )
          break;
        v12 = v22;
      }
    }
    v15 = *(_WORD *)(a4 + 16) - 1;
    v23 = *(_WORD *)(a4 + 16) - 1;
    if ( v15 > v28 )
    {
      while ( 1 )
      {
        v16 = sub_100232E0(
                (int)v26,
                (int)&v31,
                a4,
                a3,
                v8,
                v15,
                *(_WORD *)(v11 + 34) + *(_WORD *)(v8 + 4) + *(_WORD *)(a4 + 16) - v15);
        v11 = v24;
        v8 = v25;
        v27 = v16;
        if ( --v23 <= v28 )
          break;
        v15 = v23;
      }
    }
  }
  v17 = *(_WORD *)(a4 + 16) * *(_WORD *)(a4 + 18) - v27;
  v29 = *(_WORD *)(v11 + 36);
  v18 = *(_BYTE *)(a3 + 3);
  v30 = v27;
  v19 = v18;
  v34 = *(_WORD *)(v11 + 38) + v17 - 1;
  v33 = *(_WORD *)(v11 + 16) - *(_WORD *)(v11 + 36) - 2;
  *(_BYTE *)(a3 + 3) = 0;
  sub_10031840(a3, (int)&v32, (int)&v29, 0, v26);
  *(_BYTE *)(a3 + 3) = v19;
  result = sub_100232B0(a4, v8);
  if ( (_BYTE)result )
  {
    v20 = *(_WORD *)(a4 + 16) + *(_WORD *)(v8 + 8) - *(_WORD *)(v8 + 10);
    if ( v20 >= 0xFFFF )
      LOWORD(v20) = -1;
    *(_WORD *)(v11 + 20) = v20;
    *(_WORD *)(v11 + 24) = *(_WORD *)(v8 + 4);
    result = sub_10037530(a3, (int)v26, (char *)(v11 + 8), v11 + 20);
  }
  else if ( (*(_BYTE *)(a4 + 4) & 0x60) == 32 )
  {
    *(_WORD *)(a3 + 396) = 3;
    v21 = word_1065DED0[*(_BYTE *)(a4 + 4) & 0x1F];
    *(_WORD *)(a3 + 440) = v21;
    *(_WORD *)(a3 + 442) = v21;
    result = sub_1001F350(a3 + 392, *(_WORD *)(v11 + 16), *(_WORD *)(v11 + 18), 5, *(_WORD *)(v11 + 14));
  }
  return result;
}
// 1065DED0: using guessed type __int16 word_1065DED0[];

//----- (100237E0) --------------------------------------------------------
__int16 __cdecl sub_100237E0(int a1, int a2, int a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // ebp@1
  int v7; // esi@1
  int v8; // eax@1
  int v9; // ebp@3
  __int16 v10; // ax@7
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v4 = a3;
  v5 = *(_DWORD *)(a3 + 12);
  v6 = *(_WORD *)(v5 + 34);
  v7 = *(_DWORD *)v5;
  v8 = v6 + *(_WORD *)(a2 + 16) - *(_WORD *)(a3 + 10);
  v12 = *(_DWORD *)v5;
  v13 = v6 + *(_WORD *)(a2 + 16) - *(_WORD *)(a3 + 10);
  if ( *(_WORD *)(v5 + 42) < a4 && *(_WORD *)(a3 + 10) < *(_WORD *)(a3 + 8) )
  {
    v9 = v6 + 1;
    if ( v9 <= v8 )
    {
      while ( 1 )
      {
        *(_BYTE *)(*(_DWORD *)(v5 + 4) + v9) = sub_10023210(
                                                 *(_WORD *)(v4 + 4) + *(_WORD *)(v5 + 34) - v9,
                                                 v4,
                                                 a1,
                                                 *(_DWORD *)(v7 + 4 * v9));
        if ( !*(_BYTE *)(*(_DWORD *)(v5 + 4) + v9) )
          break;
        v10 = sub_10023180(
                *(_WORD *)(v4 + 4),
                a2,
                a1,
                v4,
                *(_DWORD *)(v7 + 4 * v9),
                *(_WORD *)(v4 + 4) + *(_WORD *)(v5 + 34) - v9,
                0);
        if ( v10 + (signed int)*(_WORD *)(v5 + 42) > a4
          || (++*(_WORD *)(a3 + 10), *(_WORD *)(v5 + 42) += v10, ++v9, v9 > v13) )
        {
          v4 = a3;
          break;
        }
        v7 = v12;
        v4 = a3;
      }
    }
    LOWORD(v8) = *(_WORD *)(v5 + 34) - v9 + 1;
    *(_WORD *)(v4 + 4) += v8;
    *(_WORD *)(v5 + 34) = v9 - 1;
  }
  return v8;
}

//----- (100238E0) --------------------------------------------------------
__int16 __usercall sub_100238E0@<ax>(int a1@<eax>, int a2, int a3, __int16 a4)
{
  int v4; // esi@1
  int v5; // ebp@1
  int v6; // edi@1
  int v7; // ebx@1
  int v8; // eax@1
  int v9; // ebx@1
  int v11; // [sp+10h] [bp-8h]@1
  int v12; // [sp+14h] [bp-4h]@1

  v4 = a3;
  v5 = *(_DWORD *)(a3 + 12);
  v6 = a1;
  v7 = *(_WORD *)(a1 + 16);
  v8 = *(_DWORD *)v5;
  v9 = v7 - 1;
  v11 = *(_DWORD *)v5;
  v12 = *(_DWORD *)(v5 + 4);
  if ( v9 > *(_WORD *)(v5 + 34) )
  {
    while ( 1 )
    {
      *(_BYTE *)(v9 + v12) = sub_10023210(
                               *(_WORD *)(v6 + 16) + *(_WORD *)(v5 + 34) + *(_WORD *)(v4 + 4) - v9,
                               v4,
                               a2,
                               *(_DWORD *)(v11 + 4 * v9));
      if ( !*(_BYTE *)(v9 + *(_DWORD *)(v5 + 4)) )
      {
        LOWORD(v8) = sub_100237E0(a2, v6, v4, a4);
        goto LABEL_10;
      }
      LOWORD(v8) = sub_10023180(
                     *(_WORD *)(v6 + 16),
                     v6,
                     a2,
                     v4,
                     *(_DWORD *)(v11 + 4 * v9),
                     *(_WORD *)(v6 + 16) + *(_WORD *)(v5 + 34) + *(_WORD *)(v4 + 4) - v9,
                     *(_WORD *)(v5 + 42) - *(_WORD *)(v5 + 38));
      if ( (signed __int16)v8 + (signed int)*(_WORD *)(v5 + 42) > a4 )
        break;
      ++*(_WORD *)(a3 + 10);
      *(_WORD *)(v5 + 42) += v8;
      if ( --v9 <= *(_WORD *)(v5 + 34) )
        goto LABEL_10;
      v4 = a3;
    }
    LOWORD(v8) = sub_100237E0(a2, v6, a3, a4);
  }
LABEL_10:
  if ( v9 > *(_WORD *)(v5 + 34) )
  {
    LOWORD(v8) = v12;
    do
      *(_BYTE *)(v9-- + v12) = 0;
    while ( v9 > *(_WORD *)(v5 + 34) );
  }
  return v8;
}

//----- (10023A00) --------------------------------------------------------
char __cdecl sub_10023A00(int a1, int a2, int a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@1
  int v8; // ebp@1
  int v10; // [sp+10h] [bp-8h]@1
  int v11; // [sp+14h] [bp-4h]@1

  v4 = a3;
  v5 = *(_DWORD *)(a3 + 12);
  v6 = *(_DWORD *)v5;
  v7 = *(_DWORD *)(v5 + 4);
  v8 = 0;
  v10 = *(_DWORD *)v5;
  v11 = *(_DWORD *)(v5 + 4);
  if ( *(_WORD *)(v5 + 34) >= 0 )
  {
    while ( 1 )
    {
      LOBYTE(v7) = sub_10023210(*(_WORD *)(v5 + 34) + *(_WORD *)(v4 + 4) - v8, v4, a1, *(_DWORD *)(v6 + 4 * v8));
      *(_BYTE *)(v11 + v8) = v7;
      if ( !*(_BYTE *)(*(_DWORD *)(v5 + 4) + v8) )
        break;
      LOWORD(v7) = sub_10023180(
                     *(_WORD *)(v5 + 34),
                     a2,
                     a1,
                     v4,
                     *(_DWORD *)(v6 + 4 * v8),
                     *(_WORD *)(v5 + 34) + *(_WORD *)(v4 + 4) - v8,
                     0);
      if ( (signed __int16)v7 + (signed int)*(_WORD *)(v5 + 42) > a4
        || (++*(_WORD *)(a3 + 10), *(_WORD *)(v5 + 42) += v7, v7 = *(_WORD *)(v5 + 34), ++v8, v8 > v7) )
      {
        v4 = a3;
        break;
      }
      v6 = v10;
      v4 = a3;
    }
    if ( v8 )
    {
      *(_WORD *)(v4 + 4) += *(_WORD *)(v5 + 34) - v8 + 1;
      *(_WORD *)(v5 + 34) = v8 - 1;
    }
  }
  return v7;
}

//----- (10023AE0) --------------------------------------------------------
__int16 __usercall sub_10023AE0@<ax>(__int16 a1@<bx>, int a2@<edi>, int a3@<esi>, int a4)
{
  int v4; // eax@1

  v4 = *(_DWORD *)(a3 + 12);
  *(_WORD *)(v4 + 42) = *(_WORD *)(v4 + 38);
  *(_WORD *)(a3 + 10) = 0;
  if ( !(*(_WORD *)(a2 + 4) & 0x800) || !*(_BYTE *)a3 )
  {
    sub_10023A00(a4, a2, a3, a1);
    LOWORD(v4) = sub_100238E0(a2, a4, a3, a1);
  }
  return v4;
}

//----- (10023B20) --------------------------------------------------------
int __cdecl sub_10023B20(int a1, int a2, int a3, int a4, int a5, int a6, char a7)
{
  int v7; // ebp@1
  int v8; // eax@1
  void **v9; // ecx@1
  int v10; // edx@1
  int v11; // eax@1
  _WORD *v12; // ecx@1
  signed __int16 v13; // cx@2
  unsigned __int16 v14; // di@4
  char v15; // al@5
  bool v16; // zf@7
  int (__cdecl *v17)(int, _DWORD, char *, void *, int); // ebx@12
  int v18; // eax@12
  unsigned __int16 v19; // cx@14
  unsigned __int16 v20; // ax@21
  __int16 v21; // cx@25
  int v22; // eax@25
  signed int v23; // eax@25
  signed int v24; // eax@26
  unsigned __int16 v25; // cx@27
  unsigned __int16 v26; // dx@27
  int v27; // esi@33
  void **v28; // esi@37
  char v30; // [sp+10h] [bp-38h]@2
  char v31; // [sp+11h] [bp-37h]@1
  char v32; // [sp+12h] [bp-36h]@2
  char v33; // [sp+13h] [bp-35h]@1
  signed __int16 v34; // [sp+14h] [bp-34h]@4
  void *v35; // [sp+18h] [bp-30h]@1
  signed __int16 v36; // [sp+1Ch] [bp-2Ch]@4
  int v37; // [sp+20h] [bp-28h]@1
  char v38; // [sp+24h] [bp-24h]@1
  int v39; // [sp+28h] [bp-20h]@1
  int (__cdecl *v40)(int, _DWORD, char *, void *, int); // [sp+2Ch] [bp-1Ch]@1
  void **v41; // [sp+30h] [bp-18h]@1
  int v42; // [sp+34h] [bp-14h]@1
  int v43; // [sp+38h] [bp-10h]@1
  __int16 v44; // [sp+3Ch] [bp-Ch]@1
  int v45; // [sp+40h] [bp-8h]@1
  char v46; // [sp+44h] [bp-4h]@12
  char v47; // [sp+54h] [bp+Ch]@1

  v7 = a3;
  v8 = *(_DWORD *)(a4 + 12);
  v9 = *(void ***)v8;
  v40 = (int (__cdecl *)(int, _DWORD, char *, void *, int))dword_10789180[2 * (**(_DWORD **)(a3 + 8) & 0xFF)];
  v10 = *(_DWORD *)(v8 + 4);
  v37 = v8;
  v11 = *(_WORD *)(a3 + 6);
  v41 = v9;
  v33 = 0;
  v43 = v10;
  v45 = 0;
  v35 = (void *)sub_10004F90(a1, v11);
  v44 = -32650;
  sub_10022FF0(v12, a3, a5, (int)&v38, 0);
  v42 = (unsigned __int16)sub_10023150(v37, a3, a1);
  v47 = 0;
  v39 = 0;
  v31 = 0;
  if ( a2 >= 0 )
  {
    v13 = 1;
    v32 = -1;
    v30 = 0;
  }
  else
  {
    v13 = -1;
    v32 = 0;
    v30 = -1;
  }
  v14 = *(_WORD *)(a4 + 2);
  v34 = v13;
  v36 = v13;
  if ( a2 )
  {
    while ( 1 )
    {
      v15 = sub_10023210(v14 + v34, a4, a1, (int)v35);
      if ( !v15 )
        break;
      if ( v15 == 1 )
      {
        ++v39;
        v16 = a2 == v36;
        v14 += v34;
        v34 = v36;
        v47 = 0;
        a2 -= v36;
        if ( v16 )
          goto LABEL_14;
        if ( !(*(_BYTE *)(v7 + 4) & 0x80)
          && !a7
          && (v14 & 0x8000u) == 0
          && (signed __int16)v14 < (signed int)*(_WORD *)(a4 + 8) )
        {
          v17 = v40;
          v18 = *(_DWORD *)(v7 + 8);
          v46 = v30;
          v40(a1, v18, &v38, v35, (int)&v44);
          *(_WORD *)(a4 + 6) = v14;
          if ( (unsigned __int8)v17(a1, *(_DWORD *)(v7 + 8), &v38, v35, a6) == 2 )
          {
            v33 = 1;
            goto LABEL_14;
          }
        }
      }
      else
      {
        v34 += v36;
        ++v47;
      }
    }
    if ( v36 == -1 && v47 && *(_WORD *)(a4 + 4) == *(_WORD *)(a4 + 2) )
    {
      v14 += v34;
      *(_BYTE *)(v37 + 44) = 0;
      v31 = 1;
    }
  }
LABEL_14:
  v19 = *(_WORD *)(a4 + 4);
  if ( (signed __int16)v14 >= (signed __int16)v19 )
  {
    v20 = *(_WORD *)(a4 + 10);
    if ( v20 && (signed __int16)v14 >= (signed __int16)v19 + v20 )
      *(_WORD *)(a4 + 4) = v14 - v20 + 1;
  }
  else
  {
    *(_WORD *)(a4 + 4) = (signed __int16)v14 <= 0 ? 0 : v14;
  }
  if ( v31 )
  {
    v21 = *(_WORD *)(a4 + 2);
    v22 = *(_WORD *)(a4 + 2) - *(_WORD *)(a4 + 10) + 1;
    v23 = v22 <= 0 ? 0 : v22;
    *(_WORD *)(a4 + 4) = v23;
    *(_WORD *)(v37 + 34) = v21 - v23;
  }
  else
  {
    v24 = (signed __int16)v14 <= 0 ? 0 : (signed __int16)v14;
    *(_WORD *)(a4 + 2) = v24;
    if ( *(_WORD *)(v7 + 4) & 0x400 )
    {
      v25 = *(_WORD *)(a4 + 8);
      v26 = *(_WORD *)(v7 + 16);
      if ( v25 > v26 && (_WORD)v24 && (signed __int16)v24 != v25 - *(_WORD *)(a4 + 4) )
        sub_10023240(v24, a4, v26, 1, 1);
    }
    *(_WORD *)(v37 + 34) = *(_WORD *)(a4 + 2) - *(_WORD *)(a4 + 4);
  }
  if ( v39 )
  {
    sub_10023AE0(v42, v7, a4, a1);
    v27 = *(_WORD *)(v7 + 16) - 1;
    v16 = *(_WORD *)(v7 + 16) == 1;
    v46 = v32;
    if ( v27 >= 0 && !v16 )
    {
      do
      {
        if ( *(_BYTE *)(v27 + v43) == 1 )
          v40(a1, *(_DWORD *)(v7 + 8), &v38, v41[v27], (int)&v44);
        --v27;
      }
      while ( v27 > 0 );
    }
    v28 = v41;
    if ( !a7 )
    {
      v46 = v30;
      v40(a1, *(_DWORD *)(v7 + 8), &v38, *v41, (int)&v44);
    }
    if ( v33 )
      memcpy_0(*v28, v35, *(_WORD *)(v7 + 6));
    sub_10023210(*(_WORD *)(a4 + 2), a4, a1, (int)*v28);
    sub_10023550(&unk_100B096C, a4, a1, v7, a5);
  }
  sub_10004BF0(a1, (unsigned int)v35);
  return v39;
}
// 10789180: using guessed type int dword_10789180[];

//----- (10023EE0) --------------------------------------------------------
char __cdecl sub_10023EE0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ebp@1
  _DWORD *v6; // ecx@1
  unsigned __int16 v7; // ax@1
  char v8; // dl@1
  int v9; // ebx@1
  int v10; // eax@1
  __int16 v11; // cx@2
  int v12; // edi@4
  bool *v13; // esi@4
  char v14; // al@6
  int v16; // eax@15
  char v17; // cl@18
  char v18; // [sp+12h] [bp-16h]@1
  char v19; // [sp+13h] [bp-15h]@1
  char v20; // [sp+14h] [bp-14h]@1
  _DWORD *v21; // [sp+18h] [bp-10h]@1
  char v22; // [sp+1Ch] [bp-Ch]@1
  int (__cdecl *v23)(int, _DWORD, char *, _DWORD, int); // [sp+20h] [bp-8h]@1
  int v24; // [sp+24h] [bp-4h]@1

  v5 = *(_DWORD *)(a4 + 12);
  v6 = *(_DWORD **)v5;
  v23 = (int (__cdecl *)(int, _DWORD, char *, _DWORD, int))dword_10789180[2 * (**(_DWORD **)(a2 + 8) & 0xFF)];
  v21 = v6;
  v18 = 1;
  v7 = sub_10023150(v5, a2, a1);
  v8 = *(_BYTE *)(a5 + 8);
  v24 = v7;
  v19 = v8;
  v20 = 0;
  sub_10022FF0((_WORD *)a5, a2, a3, (int)&v22, *(_WORD *)(v5 + 34));
  v9 = a1;
  v10 = a5;
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 256) && ((v11 = *(_WORD *)(a5 + 10), v11 == 47) || v11 == 51) )
  {
    v12 = a2;
    v13 = (bool *)a4;
    v20 = 1;
  }
  else
  {
    v12 = a2;
    v13 = (bool *)a4;
    if ( !(*(_BYTE *)(a2 + 4) & 0x80) )
    {
      *(_DWORD *)(a1 + 284) = *(_DWORD *)(v5 + 36);
      *(_DWORD *)(a1 + 288) = *(_DWORD *)(v5 + 40);
      *(_WORD *)(a4 + 6) = *(_WORD *)(a4 + 2);
      v14 = v23(a1, *(_DWORD *)(a2 + 8), &v22, *v21, a5);
      v18 = v14;
      if ( v14 != 1 )
      {
        *(_WORD *)(a4 + 2) = *(_WORD *)(v5 + 34) + *(_WORD *)(a4 + 4);
        if ( v14 != 3 )
        {
          sub_10023AE0(v24, a2, a4, a1);
          v9 = a1;
        }
        sub_10023550(&unk_100B096C, a4, v9, a2, a3);
        return v18;
      }
      v10 = a5;
    }
  }
  switch ( *(_WORD *)(v10 + 10) )
  {
    case 0x21:
      if ( !(*(_WORD *)(v12 + 4) & 0x800) )
        goto LABEL_15;
      if ( *(_BYTE *)(a1 + 3) )
        goto LABEL_12;
      *v13 = *v13 == 0;
      return 2;
    case 0x38:
    case 0x39:
LABEL_12:
      if ( *(_WORD *)(v12 + 4) & 0x800 && (*v13 || !*(_BYTE *)(a1 + 3)) )
        return v18;
LABEL_15:
      v16 = sub_10023B20(a1, v19, v12, (int)v13, a3, v10, 0);
      goto LABEL_16;
    case 0x2F:
    case 0x35:
      v17 = -v19;
      break;
    case 0x31:
    case 0x33:
      v17 = v19;
      break;
    default:
      return v18;
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 256) && (!*v13 || !(*(_WORD *)(v12 + 4) & 0x800)) )
  {
    v16 = sub_10023B20(a1, v17, v12, (int)v13, a3, v10, v20);
LABEL_16:
    if ( v16 )
      return 2;
  }
  return v18;
}
// 10789180: using guessed type int dword_10789180[];

//----- (10024110) --------------------------------------------------------
char __cdecl sub_10024110(int a1, int a2, int a3, int a4, __int16 *a5)
{
  int v5; // ebp@1
  _DWORD *v6; // ecx@1
  __int16 v7; // ax@1
  int v8; // esi@3
  int v9; // edx@3
  int v10; // edi@3
  int v11; // edi@6
  _DWORD *v12; // eax@6
  int v13; // ST0C_4@6
  signed int v14; // esi@6
  _WORD *v15; // ecx@6
  int v16; // eax@7
  signed int v17; // esi@8
  bool v18; // zf@8
  _DWORD *v19; // edi@10
  _WORD *v20; // ecx@11
  signed int v21; // esi@12
  char result; // al@14
  __int16 v23; // ax@15
  int v24; // ecx@15
  _DWORD *v25; // ecx@16
  __int16 v26; // ax@16
  __int16 v27; // di@17
  __int16 v28; // ax@17
  __int16 v29; // bx@22
  signed int v30; // esi@22
  int v31; // edi@24
  int v32; // eax@31
  int v33; // edi@32
  int v34; // ebx@35
  int v35; // [sp+Ch] [bp-20h]@1
  int v36; // [sp+10h] [bp-1Ch]@3
  void (__cdecl *v37)(int, _DWORD, int *, _DWORD, __int16 *); // [sp+14h] [bp-18h]@1
  _DWORD *v38; // [sp+18h] [bp-14h]@3
  int v39; // [sp+1Ch] [bp-10h]@3
  __int16 v40; // [sp+20h] [bp-Ch]@1
  int v41; // [sp+24h] [bp-8h]@1
  char v42; // [sp+28h] [bp-4h]@1
  char v43; // [sp+34h] [bp+8h]@1
  int v44; // [sp+34h] [bp+8h]@6

  v5 = a2;
  v6 = *(_DWORD **)(a2 + 8);
  v35 = 0;
  v37 = (void (__cdecl *)(int, _DWORD, int *, _DWORD, __int16 *))dword_10789180[2 * (*v6 & 0xFF)];
  v41 = 0;
  v42 = 0;
  v7 = *a5;
  v43 = 1;
  v40 = -32650;
  if ( v7 == -32671 || v7 == -32703 )
  {
    v8 = a4;
    v9 = v36;
  }
  else
  {
    v8 = a4;
    v9 = *(_DWORD *)(a4 + 12);
    v38 = *(_DWORD **)v9;
    v10 = *(_DWORD *)(v9 + 4);
    v36 = v9;
    v39 = v10;
  }
  switch ( v7 )
  {
    case 0x8041:
      v11 = sub_10004F90(a1, 48);
      *(_DWORD *)(v8 + 12) = v11;
      v44 = v11;
      v12 = (_DWORD *)sub_10004F90(a1, 4 * *(_WORD *)(v5 + 16));
      *(_DWORD *)v11 = v12;
      v13 = *(_WORD *)(v5 + 16);
      v38 = v12;
      v14 = 0;
      *(_DWORD *)(v11 + 4) = sub_10004F90(a1, v13);
      if ( *(_WORD *)(v5 + 16) )
      {
        do
        {
          v16 = sub_10004F90(a1, *(_WORD *)(v5 + 6));
          HIWORD(v15) = HIWORD(v38);
          v38[v14++] = v16;
        }
        while ( v14 < *(_WORD *)(v5 + 16) );
      }
      *(_DWORD *)(v11 + 28) = *(_DWORD *)(v5 + 12);
      LOWORD(v15) = *(_WORD *)(v5 + 6);
      *(_WORD *)(v11 + 32) = (_WORD)v15;
      sub_10022FF0(v15, v5, a3, (int)&v35, 0);
      v17 = 0;
      v18 = (*(_WORD *)(v5 + 4) & 0x1000) == 0;
      HIWORD(v35) = 0;
      if ( !v18 && *(_WORD *)(a4 + 8) > 0u )
      {
        do
        {
          v19 = v38;
          (*(void (__cdecl **)(int, _DWORD, signed int))(v44 + 28))(a1, *v38, v17);
          v37(a1, *(_DWORD *)(v5 + 8), &v35, *v19, a5);
          ++v17;
        }
        while ( v17 < *(_WORD *)(a4 + 8) );
      }
      *(_BYTE *)(v44 + 44) = 0;
      sub_10023030(a3, (_WORD *)v5, a1, a4);
      sub_10022FF0(v20, v5, a3, (int)&v35, 0);
      *(_BYTE *)(v44 + 45) = 0;
      if ( **(_BYTE **)(v5 + 8) == 108 )
      {
        v21 = 0;
        if ( *(_WORD *)(v5 + 16) )
        {
          do
            v37(a1, *(_DWORD *)(v5 + 8), &v35, v38[v21++], &v40);
          while ( v21 < *(_WORD *)(v5 + 16) );
        }
      }
      result = 2;
      break;
    case 0x8040:
      v23 = sub_10023150(v9, v5, a1);
      sub_10023AE0(v23, v5, v8, a1);
      v24 = v36;
      *(_DWORD *)(a1 + 276) = *(_DWORD *)(v36 + 36);
      *(_DWORD *)(a1 + 280) = *(_DWORD *)(v24 + 40);
      result = 2;
      break;
    case 0x8022:
      v25 = v38;
      *(_WORD *)(v9 + 34) = *(_WORD *)(v8 + 2) - *(_WORD *)(v8 + 4);
      *(_DWORD *)(v8 + 16) = *v25;
      v26 = sub_10023150(v9, v5, a1);
      sub_10023AE0(v26, v5, v8, a1);
      sub_10023550(a5, a4, a1, v5, a3);
      result = 1;
      break;
    case 0x8078:
      v27 = *(_WORD *)(v8 + 8);
      v28 = *(_WORD *)(v8 + 2);
      if ( *(_WORD *)(v8 + 2) < (signed int)*(_WORD *)(v8 + 8) )
      {
        if ( v28 == -1 && v27 )
          *(_WORD *)(v8 + 2) = 0;
      }
      else
      {
        *(_WORD *)(v8 + 4) += v27 - v28 - 1;
        *(_WORD *)(v8 + 4) &= ((signed int)*(_WORD *)(v8 + 4) < 0) - 1;
        *(_WORD *)(v8 + 2) = v27 - 1;
      }
      *(_WORD *)(v9 + 34) = *(_WORD *)(v8 + 2) - *(_WORD *)(v8 + 4);
      v29 = sub_10023150(v9, v5, a1);
      sub_10023AE0(v29, v5, v8, a1);
      v30 = 0;
      if ( *(_WORD *)(v5 + 16) )
      {
        do
        {
          if ( *(_BYTE *)(v30 + v39) == 1 )
          {
            v31 = v36;
            if ( v30 || *(_BYTE *)(v36 + 45) )
            {
              if ( v30 <= *(_WORD *)(v36 + 34) && v30 )
              {
                v42 = -1;
                v37(a1, *(_DWORD *)(v5 + 8), &v35, v38[v30], &v40);
              }
              else
              {
                v42 = 0;
                v37(a1, *(_DWORD *)(v5 + 8), &v35, v38[v30], &v40);
                *(_BYTE *)(v31 + 45) = 0;
              }
            }
          }
          ++v30;
        }
        while ( v30 < *(_WORD *)(v5 + 16) );
      }
      v32 = v36;
      if ( *(_WORD *)(v36 + 34) >= 0 )
      {
        *(_DWORD *)(a4 + 16) = *v38;
        v33 = a4;
      }
      else
      {
        v33 = a4;
        *(_DWORD *)(a4 + 16) = 0;
      }
      if ( !*(_BYTE *)(v32 + 44) )
      {
        v34 = sub_10004F90(a1, *(_WORD *)(v5 + 6));
        if ( sub_10023210(*(_WORD *)(v33 + 2), v33, a1, v34) == 2 )
          sub_10023B20(a1, 1, v5, v33, a3, (int)a5, 0);
        sub_10004BF0(a1, v34);
        *(_BYTE *)(v36 + 44) = 1;
      }
      sub_10023550(a5, v33, a1, v5, a3);
      result = 2;
      break;
    case 0x8048:
      v43 = sub_10023EE0(a1, v5, a3, v8, (int)a5);
      goto LABEL_40;
    default:
LABEL_40:
      result = v43;
      break;
  }
  return result;
}
// 10789180: using guessed type int dword_10789180[];

//----- (100245E0) --------------------------------------------------------
char __usercall sub_100245E0@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, const char *a4, char a5)
{
  unsigned int v5; // ST14_4@1
  int *v6; // eax@1
  int v7; // ST10_4@1
  signed int v8; // eax@1
  unsigned int v9; // ST08_4@1
  int v10; // eax@1
  unsigned int v11; // ST04_4@1
  signed int v12; // eax@1
  __int16 v13; // dx@1
  int v15; // [sp+0h] [bp-18h]@1
  int v16; // [sp+4h] [bp-14h]@1
  int v17; // [sp+8h] [bp-10h]@1
  __int16 v18; // [sp+Ch] [bp-Ch]@1
  int v19; // [sp+Eh] [bp-Ah]@1
  int v20; // [sp+14h] [bp-4h]@1

  v5 = *(_DWORD *)(a3 + 8);
  v18 = *(_WORD *)(a3 + 12);
  v6 = sub_10002E60(v5);
  v7 = *(_DWORD *)(a3 + 8);
  v15 = *v6;
  v8 = sub_10002EA0(v7);
  v9 = *(_DWORD *)(a3 + 8);
  v16 = v8;
  v10 = sub_100035F0(v9, 0);
  v11 = *(_DWORD *)(a3 + 8);
  v17 = v10;
  v19 = sub_10002E30(v11);
  v12 = sub_10002ED0(*(_DWORD *)(a3 + 8));
  *(_WORD *)(a2 + 438) = *(_WORD *)a1;
  v13 = *(_WORD *)(a1 + 2);
  v20 = v12 | 1;
  *(_WORD *)(a2 + 436) = v13;
  if ( !a5 )
    HIWORD(v19) = word_1065DED0[0];
  return sub_10003650(a2, a4, &v15, *(_WORD *)(v15 + 30));
}
// 1065DED0: using guessed type __int16 word_1065DED0[];

//----- (10024680) --------------------------------------------------------
char __usercall sub_10024680@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5)
{
  char v5; // al@1
  int v6; // edi@1
  char v7; // al@1
  int v8; // esi@1
  int v9; // ecx@6
  unsigned __int16 v10; // ax@6
  char v11; // dl@7
  __int16 v12; // bx@11
  __int16 v13; // ax@15
  unsigned int v14; // ecx@15
  __int16 v15; // bx@15
  __int16 v16; // ax@21
  signed int v17; // esi@21
  int v18; // ecx@21
  __int16 v19; // ax@22
  int v20; // edx@23
  int v21; // esi@24
  int v22; // ST20_4@24
  __int16 v23; // ax@26
  __int16 v24; // si@26
  int v25; // ebx@26
  __int16 v26; // cx@26
  __int16 v27; // ST20_2@26
  char v29; // [sp+13h] [bp-49h]@1
  char *v30; // [sp+14h] [bp-48h]@2
  int v31; // [sp+18h] [bp-44h]@7
  int v32; // [sp+1Ch] [bp-40h]@16
  int v33; // [sp+20h] [bp-3Ch]@1
  int v34; // [sp+24h] [bp-38h]@1
  int v35; // [sp+28h] [bp-34h]@6
  int v36; // [sp+2Ch] [bp-30h]@1
  int v37; // [sp+30h] [bp-2Ch]@11
  int v38; // [sp+34h] [bp-28h]@15
  int v39; // [sp+38h] [bp-24h]@11
  int v40; // [sp+3Ch] [bp-20h]@21
  int v41; // [sp+40h] [bp-1Ch]@21
  int v42; // [sp+44h] [bp-18h]@21
  int v43; // [sp+48h] [bp-14h]@21
  int v44; // [sp+4Ch] [bp-10h]@24
  char v45; // [sp+50h] [bp-Ch]@24

  v5 = *(_BYTE *)(a4 + 4);
  v6 = a2;
  LOBYTE(v33) = (*(_BYTE *)(a4 + 4) & 8) != 8;
  v7 = v5 & 7;
  v8 = a1;
  v34 = a1;
  v36 = a4;
  v29 = 1;
  if ( v7 == 1 )
  {
    v30 = sub_10037280(*(_WORD *)a4);
  }
  else if ( v7 == 2 )
  {
    v30 = sub_10037280(*(_WORD *)a4);
  }
  else
  {
    v30 = *(char **)a4;
  }
  v9 = (unsigned __int16)sub_10003480(v30, *(_DWORD *)(v8 + 8));
  v10 = *(_WORD *)(v8 + 12);
  v35 = v9;
  if ( v10 )
  {
    v31 = v10;
  }
  else
  {
    v11 = *(_BYTE *)(a4 + 4) & 7;
    v31 = (unsigned __int16)v9;
    if ( v11 == 2 )
      v31 = (unsigned __int16)(v35 + sub_10003480("  ", *(_DWORD *)(v8 + 8)));
  }
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v12 = sub_10003930(
              v30,
              *(_DWORD *)(v8 + 8),
              *(_WORD *)(dword_10789600[5 * ((*(_DWORD *)(v8 + 8) >> 10) & 0xF)] + 30),
              (int)&v37,
              (int)&v39);
      sub_10003860(v6 + 276, *(_DWORD *)a3, *(_DWORD *)(v8 + 8), (signed __int16)v31);
      *(_WORD *)(v6 + 282) = v12 + *(_WORD *)(v6 + 278) - 1;
      goto LABEL_27;
    case 0x8048:
      if ( *(_WORD *)(a5 + 10) == 33 )
      {
        v29 = 0;
        if ( (_BYTE)v33 )
          v29 = 3;
      }
      break;
    case 0x8022:
    case 0x8078:
      v13 = sub_10003930(
              v30,
              *(_DWORD *)(v8 + 8),
              *(_WORD *)(dword_10789600[5 * ((*(_DWORD *)(v8 + 8) >> 10) & 0xF)] + 30),
              (int)&v37,
              (int)&v39);
      v14 = *(_DWORD *)(v8 + 8);
      v15 = v13;
      v38 = (unsigned __int16)v13;
      if ( v14 & 0x8000 )
      {
        v32 = (signed __int16)v31 / 2;
      }
      else if ( v14 & 0x4000 )
      {
        v32 = (signed __int16)v31;
      }
      else
      {
        v32 = 0;
      }
      if ( *(_BYTE *)(v8 + 4) == 1 )
      {
        *(_WORD *)(v6 + 442) = sub_10002E30(v14);
        HIWORD(v41) = word_1065DED0[0];
        v16 = word_1065DED0[14];
        LOWORD(v42) = word_1065DED0[15];
        LOWORD(v43) = v42;
        LOWORD(v41) = v16;
        HIWORD(v42) = v16;
        HIWORD(v43) = v16;
        v17 = 0;
        v18 = v31 + 20;
        *(_WORD *)(v6 + 426) = 1;
        *(_WORD *)(v6 + 424) = 1;
        v40 = v18;
        do
        {
          v19 = *((_WORD *)&v41 + 2 * v17 + 1);
          *(_WORD *)(v6 + 428) = *((_WORD *)&v41 + 2 * v17);
          *(_WORD *)(v6 + 430) = v19;
          sub_1001EC10(
            v6 + 392,
            v17 + *(_WORD *)a3 - v32 - 10,
            *(_WORD *)(a3 + 2) + v17 - v15 - 5,
            v40,
            v15 - 2 * v17 + 15,
            3);
          ++v17;
        }
        while ( v17 < 3 );
      }
      sub_100245E0(a3, v6, v34, v30, v33);
      v20 = v36;
      if ( (*(_BYTE *)(v36 + 4) & 7) == 2 )
      {
        v30 = *(char **)a3;
        LOWORD(v30) = v35 + (_WORD)v30;
        v41 = *(_DWORD *)v34;
        v42 = *(_DWORD *)(v34 + 4);
        v21 = *(_DWORD *)(v34 + 8);
        v44 = *(_DWORD *)(v34 + 12);
        LOWORD(v44) = v44 - v35;
        v22 = *(_WORD *)(v36 + 2);
        v43 = v21;
        _snprintf(&v45, 7u, " %d", v22);
        sub_100245E0((int)&v30, v6, (int)&v41, &v45, v33);
        v20 = v36;
      }
      if ( *(_BYTE *)(v20 + 4) & 0x10 )
      {
        v23 = v38;
        v24 = *(_WORD *)(v6 + 398);
        v25 = *(_DWORD *)(v6 + 452);
        v26 = v31;
        v27 = v38 - 4;
        *(_WORD *)(v6 + 440) = -1;
        *(_WORD *)(v6 + 442) = 0;
        *(_WORD *)(v6 + 398) = 1;
        *(_DWORD *)(v6 + 452) = &unk_10091E38;
        sub_1001F350(v6 + 392, *(_WORD *)a3 - v32, *(_WORD *)(a3 + 2) - v23 + 5, v26, v27);
        *(_WORD *)(v6 + 398) = v24;
        *(_DWORD *)(v6 + 452) = v25;
      }
LABEL_27:
      v29 = 2;
      break;
    default:
      return v29;
  }
  return v29;
}
// 1065DED0: using guessed type __int16 word_1065DED0[];
// 10789600: using guessed type int dword_10789600[];

//----- (10024AC0) --------------------------------------------------------
char __cdecl sub_10024AC0(int a1, int a2, int a3, __int16 *a4, int a5)
{
  __int16 v6; // [sp+0h] [bp-8h]@1
  char v7; // [sp+4h] [bp-4h]@1

  v6 = *a4;
  v7 = 1;
  return sub_10024680(a2, a1, a3, (int)&v6, a5);
}

//----- (10024B00) --------------------------------------------------------
char __cdecl sub_10024B00(int a1, int a2, int a3, int a4, int a5)
{
  return sub_10024680(a2, a1, a3, a4, a5);
}

//----- (10024B20) --------------------------------------------------------
char __cdecl sub_10024B20(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char result; // al@4
  signed int v6; // eax@5
  unsigned int v7; // edx@5
  int v8; // eax@5
  unsigned int v9; // ST48_4@5
  int v10; // edx@5
  __int16 v11; // di@5
  signed int v12; // eax@9
  unsigned int v13; // ST48_4@9
  int v14; // eax@9
  unsigned int v15; // ST40_4@9
  int *v16; // eax@9
  int v17; // ST3C_4@9
  __int16 v18; // ax@9
  __int16 v19; // bp@9
  __int16 v20; // bx@9
  __int16 v21; // cx@9
  __int16 v22; // dx@9
  __int16 v23; // cx@9
  __int16 v24; // ax@9
  int v25; // edx@9
  __int16 v26; // cx@9
  char *v27; // [sp+8h] [bp-68h]@7
  __int16 v28; // [sp+8h] [bp-68h]@9
  __int16 v29; // [sp+Ch] [bp-64h]@9
  __int16 v30; // [sp+10h] [bp-60h]@9
  __int16 v31; // [sp+14h] [bp-5Ch]@9
  unsigned int v32; // [sp+18h] [bp-58h]@9
  int v33; // [sp+18h] [bp-58h]@10
  __int16 v34; // [sp+1Ch] [bp-54h]@9
  __int16 v35; // [sp+20h] [bp-50h]@9
  int v36; // [sp+24h] [bp-4Ch]@12
  __int16 v37; // [sp+28h] [bp-48h]@9
  __int16 v38; // [sp+2Ch] [bp-44h]@9
  __int16 v39; // [sp+30h] [bp-40h]@12
  __int16 v40; // [sp+32h] [bp-3Eh]@12
  __int16 v41; // [sp+34h] [bp-3Ch]@12
  __int16 v42; // [sp+36h] [bp-3Ah]@12
  __int16 v43; // [sp+38h] [bp-38h]@12
  __int16 v44; // [sp+3Ah] [bp-36h]@12
  __int16 v45; // [sp+3Ch] [bp-34h]@12
  __int16 v46; // [sp+3Eh] [bp-32h]@12
  int v47; // [sp+40h] [bp-30h]@5
  int v48; // [sp+44h] [bp-2Ch]@5
  int v49; // [sp+48h] [bp-28h]@5
  __int16 v50; // [sp+4Ch] [bp-24h]@5
  int v51; // [sp+4Eh] [bp-22h]@5
  int v52; // [sp+54h] [bp-1Ch]@9
  __int16 v53; // [sp+58h] [bp-18h]@11
  __int16 v54; // [sp+5Ah] [bp-16h]@11
  __int16 v55; // [sp+5Ch] [bp-14h]@11
  __int16 v56; // [sp+5Eh] [bp-12h]@11
  __int16 v57; // [sp+60h] [bp-10h]@11
  __int16 v58; // [sp+62h] [bp-Eh]@11
  __int16 v59; // [sp+64h] [bp-Ch]@11
  __int16 v60; // [sp+66h] [bp-Ah]@11
  __int16 v61; // [sp+68h] [bp-8h]@11
  __int16 v62; // [sp+6Ah] [bp-6h]@11
  __int16 v63; // [sp+6Ch] [bp-4h]@11
  __int16 v64; // [sp+6Eh] [bp-2h]@11
  int v65; // [sp+84h] [bp+14h]@9

  if ( *a5 != 32802 )
  {
    if ( *a5 == 32832 )
    {
      v6 = sub_10002EA0(*(_DWORD *)(a2 + 12));
      v7 = *(_DWORD *)(a2 + 12);
      v48 = v6;
      v49 = sub_100035F0(v7, 0);
      v8 = sub_10002E30(*(_DWORD *)(a2 + 12));
      v9 = *(_DWORD *)(a2 + 12);
      v51 = v8;
      v10 = *sub_10002E60(v9);
      *(_WORD *)(a1 + 276) = *(_WORD *)a3;
      v11 = *(_WORD *)(a3 + 2);
      v47 = v10;
      v50 = 0;
      *(_WORD *)(a1 + 278) = v11 - *(_WORD *)(v10 + 24) - 1;
      *(_WORD *)(a1 + 280) = *(_WORD *)a3 + *(_WORD *)(a2 + 4) - 1;
      result = 2;
      *(_WORD *)(a1 + 282) = *(_WORD *)(a3 + 2) + *(_WORD *)(a2 + 6) - 1;
      return result;
    }
    if ( *a5 != 32888 )
      return 1;
  }
  if ( *(_DWORD *)a2 == 110 )
    v27 = *(char **)a4;
  else
    v27 = sub_10037280(*a4);
  v12 = sub_10002EA0(*(_DWORD *)(a2 + 12));
  v13 = *(_DWORD *)(a2 + 12);
  v48 = v12;
  v49 = sub_100035F0(v13, 0);
  v14 = sub_10002E30(*(_DWORD *)(a2 + 12));
  v15 = *(_DWORD *)(a2 + 12);
  v51 = v14;
  v16 = sub_10002E60(v15);
  v17 = *(_DWORD *)(a2 + 12);
  v47 = *v16;
  v50 = 0;
  v52 = sub_10002ED0(v17);
  v18 = sub_1001C410(v47, v27, v48);
  v19 = *(_WORD *)a3;
  v20 = *(_WORD *)(a3 + 2);
  v30 = *(_WORD *)a3 + *(_WORD *)(a2 + 4);
  v21 = *(_BYTE *)(a2 + 16);
  v35 = v20 + *(_WORD *)(a2 + 6);
  v22 = v21 + *(_WORD *)a3;
  v23 = v18 + v21 + *(_WORD *)a3 + 6;
  v65 = (unsigned __int16)(v20 + (*(_WORD *)(v47 + 22) >> 1));
  v24 = v51;
  *(_WORD *)(a1 + 428) = v51;
  *(_WORD *)(a1 + 430) = v24;
  *(_WORD *)(a1 + 440) = v24;
  *(_WORD *)(a1 + 442) = v24;
  v31 = v23;
  v38 = v23 - v22;
  v29 = v22;
  *(_WORD *)(a1 + 396) = 3;
  sub_1001EC10(a1 + 392, v22 + 1, v20, v23 - v22 - 1, v65 - v20, 1);
  sub_1001EC10(a1 + 392, v19, v65 - *(_WORD *)(v47 + 22), v30 - v19 + 1, v20 + *(_WORD *)(v47 + 22) - v65, 1);
  v25 = v47;
  *(_WORD *)(a1 + 436) = v65 - 3;
  *(_WORD *)(a1 + 438) = v29 + 4;
  sub_10003650(a1, v27, &v47, *(_WORD *)(v25 + 26));
  v32 = (((unsigned int)*(_WORD *)(a2 + 8) >> 12) & 3) + 1;
  v26 = word_1065DED0[(unsigned __int8)sub_100397E0(*(_BYTE *)(a2 + 8) & 0x1F)];
  v37 = word_1065DED0[((unsigned int)*(_WORD *)(a2 + 8) >> 5) & 0x1F];
  *(_WORD *)(a1 + 440) = v37;
  *(_WORD *)(a1 + 442) = v37;
  v34 = v26;
  v28 = 0;
  if ( (signed int)(2 - v32) < 2 )
  {
    v33 = 2 - (2 - v32);
    do
    {
      *(_WORD *)(a1 + 428) = v26;
      *(_WORD *)(a1 + 430) = v26;
      v53 = v29 - v28;
      v54 = v28 + v20;
      v55 = v28 + v19;
      v56 = v28 + v20;
      v57 = v28 + v19;
      v58 = v35 - v28;
      v60 = v35 - v28;
      v59 = v30 - v28;
      v61 = v30 - v28;
      v63 = v31 + v28;
      v62 = v28 + v20;
      v64 = v28 + v20;
      sub_10081460(a1 + 392, 6, (int)&v53, 2);
      v26 = v34;
      ++v28;
      --v33;
    }
    while ( v33 );
  }
  v39 = v31;
  v41 = v31;
  *(_WORD *)(a1 + 428) = v26;
  *(_WORD *)(a1 + 430) = v26;
  v43 = v29;
  v45 = v29;
  v40 = v20;
  v42 = v65;
  v44 = v65;
  v46 = v20;
  v36 = a1 + 392;
  sub_10081460(a1 + 392, 4, (int)&v39, 2);
  *(_WORD *)(a1 + 428) = v37;
  *(_WORD *)(a1 + 430) = v37;
  if ( !(*(_WORD *)(a2 + 8) & 0xC000) )
  {
    sub_1001EC10(v36, v28 + *(_WORD *)a3, v28 + *(_WORD *)(a3 + 2), *(_BYTE *)(a2 + 16) - 1, v35 - 2 * v28 - v20 + 1, 3);
    sub_1001EC10(v36, v29, v65 + v28, v38 + 1, v35 - 2 * v28 - v65 + 1, 3);
    sub_1001EC10(v36, v31 + v28, v20 + v28, v30 - 2 * v28 - v31 + 1, v35 - 2 * v28 - v20 + 1, 3);
  }
  return 2;
}
// 1065DED0: using guessed type __int16 word_1065DED0[];

//----- (10025000) --------------------------------------------------------
char __usercall sub_10025000@<al>(int a1@<eax>, char *a2@<ecx>)
{
  char *v2; // esi@1
  char v3; // bl@1
  char *v5; // [sp+8h] [bp-8h]@1
  char v6; // [sp+Ch] [bp-4h]@1

  v2 = a2;
  v3 = *a2;
  if ( sub_10037480(*(char **)(a1 + 4), (int *)&v6, &v5) )
  {
    do
    {
      if ( *v2 > v3 )
        v3 = *v2;
      ++v2;
    }
    while ( sub_10037480(v5, (int *)&v6, &v5) );
  }
  return v3;
}

//----- (10025060) --------------------------------------------------------
char __usercall sub_10025060@<al>(int a1@<esi>, int a2, int a3, int a4, _WORD *a5)
{
  int v5; // edx@1
  char *v6; // edi@1
  char v7; // bl@1
  int v8; // ebp@1
  _BYTE *v9; // ecx@2
  bool v10; // al@9
  bool v11; // al@14
  char v13; // [sp+Fh] [bp-19h]@1
  _DWORD *v14; // [sp+10h] [bp-18h]@2
  int v15; // [sp+14h] [bp-14h]@1
  __int16 v16; // [sp+18h] [bp-10h]@6
  __int16 v17; // [sp+1Ah] [bp-Eh]@6
  char *v18; // [sp+1Ch] [bp-Ch]@1
  int v19; // [sp+20h] [bp-8h]@1
  int v20; // [sp+24h] [bp-4h]@1
  char v21; // [sp+2Ch] [bp+4h]@1

  v5 = *(_DWORD *)(a4 + 4);
  v6 = *(char **)(a2 + 4);
  v20 = *(_DWORD *)(a4 + 8);
  v21 = *(_BYTE *)(a1 + 3);
  v15 = v5;
  v7 = 1;
  v8 = 0;
  v13 = *(_BYTE *)(a1 + 9);
  if ( sub_10037480(v6, &v19, &v18) )
  {
    v9 = (_BYTE *)a4;
    v14 = (_DWORD *)(a4 + 12);
    while ( 1 )
    {
      if ( *a5 != -32696 || *(_BYTE *)(*v9 + v20) == v8 )
      {
        v16 = *(_WORD *)a3 + *(_WORD *)v19;
        v17 = *(_WORD *)(a3 + 2) + *(_WORD *)(v19 + 2);
        v10 = v21 && *(_BYTE *)(v15 + v8) == *v9 && *v9 >= 0;
        *(_BYTE *)(a1 + 3) = v10;
        v11 = v13 && *(_BYTE *)(v15 + v8) == *v9 && *v9 >= 0;
        *(_BYTE *)(a1 + 9) = v11;
        v7 = ((int (__cdecl *)(int, char *, __int16 *, _DWORD, _WORD *))dword_10789180[2 * (*(_DWORD *)v6 & 0xFF)])(
               a1,
               v6,
               &v16,
               *v14,
               a5);
        *(_BYTE *)(a1 + 3) = v21;
        *(_BYTE *)(a1 + 9) = v13;
      }
      v6 = v18;
      ++v14;
      ++v8;
      if ( !sub_10037480(v18, &v19, &v18) )
        break;
      v9 = (_BYTE *)a4;
    }
  }
  return v7;
}
// 10789180: using guessed type int dword_10789180[];

//----- (100251B0) --------------------------------------------------------
char __cdecl sub_100251B0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // edx@1
  char v6; // al@1
  char *v7; // ebp@1
  int v8; // ecx@1
  char *v9; // edi@1
  char v10; // bl@1
  int v11; // edi@5
  char v12; // al@8
  char v13; // al@10
  char v14; // al@16
  char *v15; // edi@18
  signed __int16 v16; // bx@18
  signed __int16 v17; // bp@18
  _WORD *v18; // eax@20
  signed int v19; // eax@20
  signed int v20; // eax@22
  signed __int16 v21; // cx@24
  signed int v22; // eax@24
  signed __int16 v23; // dx@26
  signed int v24; // eax@26
  __int16 v25; // dx@29
  char *v26; // eax@32
  char v27; // cl@33
  bool v28; // zf@37
  signed int v30; // [sp+10h] [bp-1Ch]@1
  _DWORD *v31; // [sp+14h] [bp-18h]@19
  signed __int16 v32; // [sp+18h] [bp-14h]@18
  signed __int16 v33; // [sp+1Ch] [bp-10h]@18
  char *v34; // [sp+20h] [bp-Ch]@18
  _WORD *v35; // [sp+24h] [bp-8h]@18
  char *v36; // [sp+28h] [bp-4h]@1
  char v37; // [sp+3Ch] [bp+10h]@32

  v5 = a5;
  v6 = *(_BYTE *)(a5 + 8);
  v7 = (char *)a4;
  v30 = *(_BYTE *)(a5 + 8);
  v8 = *(_WORD *)a5 - 32832;
  v9 = *(char **)(a4 + 4);
  v36 = *(char **)(a4 + 4);
  v10 = 1;
  if ( v8 )
  {
    if ( v8 == 54 )
    {
      if ( v6 )
      {
        if ( v6 == -1 )
        {
          v14 = sub_10025000(a2, v9);
          v5 = a5;
          *(_BYTE *)a4 = v14 <= 0 ? 0 : v14;
        }
        else
        {
          *(_BYTE *)a4 = v6;
        }
      }
      else
      {
        *(_BYTE *)a4 = 0;
      }
    }
    v11 = a3;
  }
  else
  {
    v15 = *(char **)(a2 + 4);
    v16 = 0x7FFF;
    v17 = -32768;
    v33 = -32768;
    v32 = 0x7FFF;
    if ( sub_10037480(*(char **)(a2 + 4), (int *)&v35, &v34) )
    {
      v31 = (_DWORD *)(a4 + 12);
      do
      {
        v18 = v35;
        *(_WORD *)(a1 + 276) = *v35;
        *(_WORD *)(a1 + 278) = v18[1];
        *(_WORD *)(a1 + 280) = *v18;
        *(_WORD *)(a1 + 282) = v18[1];
        ((void (__cdecl *)(int, char *, _WORD *, _DWORD, int))dword_10789180[2 * (*(_DWORD *)v15 & 0xFF)])(
          a1,
          v15,
          v18,
          *v31,
          a5);
        v19 = *(_WORD *)(a1 + 276);
        if ( v16 < v19 )
          LOWORD(v19) = v16;
        v16 = v19;
        v20 = *(_WORD *)(a1 + 280);
        if ( v33 > v20 )
          LOWORD(v20) = v33;
        v21 = v20;
        v22 = *(_WORD *)(a1 + 278);
        v33 = v21;
        if ( v32 < v22 )
          LOWORD(v22) = v32;
        v23 = v22;
        v24 = *(_WORD *)(a1 + 282);
        v32 = v23;
        if ( v17 > v24 )
          LOWORD(v24) = v17;
        v15 = v34;
        ++v31;
        v17 = v24;
      }
      while ( sub_10037480(v34, (int *)&v35, &v34) );
    }
    v11 = a3;
    *(_WORD *)(a1 + 276) = v16 + *(_WORD *)a3;
    v10 = 2;
    *(_WORD *)(a1 + 278) = v32 + *(_WORD *)(a3 + 2);
    *(_WORD *)(a1 + 280) = v33 + *(_WORD *)a3;
    v25 = v17 + *(_WORD *)(a3 + 2);
    v7 = (char *)a4;
    *(_WORD *)(a1 + 282) = v25;
    v5 = a5;
  }
  if ( *(_WORD *)v5 != -32704 && *(_WORD *)v5 != -32650 )
  {
    v12 = sub_10025000(a2, v36);
    if ( *v7 < v12 )
      v12 = *v7;
    *v7 = v12;
    v13 = sub_10025060(a1, a2, v11, (int)v7, (_WORD *)a5);
    v5 = a5;
    v10 = v13;
  }
  if ( *(_WORD *)v5 == -32696 && v10 == 1 && *(_BYTE *)(v5 + 8) )
  {
    switch ( *(_WORD *)(v5 + 10) )
    {
      case 0x2F:
      case 0x35:
        v30 = -v30;
        goto LABEL_31;
      case 0x31:
      case 0x33:
LABEL_31:
        if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 256) )
          goto LABEL_32;
        return v10;
      case 0x21:
      case 0x38:
      case 0x39:
LABEL_32:
        v37 = sub_10025000(a2, v36);
        v26 = (char *)(abs(v30) / v30);
        v36 = v26;
        break;
      default:
        return v10;
    }
    while ( 1 )
    {
      v27 = *v7;
      if ( (*v7 <= 0 || (signed int)v26 >= 0) && (v27 >= v37 || (signed int)v26 <= 0) )
        break;
      v28 = v30 == (_DWORD)v26;
      v30 -= (signed int)v26;
      *v7 = (_BYTE)v26 + v27;
      if ( v28 )
        return 2;
      v10 = sub_10025060(a1, a2, v11, (int)v7, (_WORD *)a5);
      if ( v10 != 1 )
        return v10;
      v26 = v36;
    }
  }
  return v10;
}
// 10789180: using guessed type int dword_10789180[];

//----- (100254C0) --------------------------------------------------------
int __cdecl sub_100254C0(unsigned int a1, char a2)
{
  int v2; // eax@1
  int v3; // esi@1

  v2 = ((a2 & 0x3F) - 46) << 6;
  v3 = *(int *)((char *)&dword_1009CAD8 + v2);
  if ( a2 & 0x40 )
    ++v3;
  return v3 * BYTE1(dword_10789600[5 * ((a1 >> 10) & 0xF) + 4])
       + *(int *)((char *)&dword_1009CAD0 + v2) * BYTE3(dword_10789600[5 * ((a1 >> 10) & 0xF) + 3])
       + *(_WORD *)(dword_10789600[5 * ((a1 >> 10) & 0xF) + 1] + 28) * (*(int *)((char *)&dword_1009CAD0 + v2) + v3 - 1);
}
// 1009CAD0: using guessed type int dword_1009CAD0;
// 1009CAD8: using guessed type int dword_1009CAD8;
// 10789600: using guessed type int dword_10789600[];

//----- (10025520) --------------------------------------------------------
char __cdecl sub_10025520(signed __int16 *a1, _BYTE *a2)
{
  void *v2; // ecx@0
  signed __int16 v3; // ax@1
  void *v4; // ecx@1
  signed __int16 v5; // dx@7

  LOBYTE(v3) = sub_10036D40(v2);
  if ( (_BYTE)v3 )
  {
    if ( sub_10036D10(v4) )
    {
      *a2 = 35;
      v3 = *a1;
      if ( *a1 < 0x7FFF )
      {
        if ( v3 / 12 & 1 )
          *a2 = 36;
        v3 = *a1 / 12;
        v5 = *a1 % 12;
        *a1 = v5;
        if ( !v5 )
          *a1 = 12;
      }
    }
    else
    {
      LOBYTE(v3) = (_BYTE)a2;
      *a2 = 37;
    }
  }
  else
  {
    *a2 = 38;
  }
  return v3;
}

//----- (10025590) --------------------------------------------------------
__int16 __usercall sub_10025590@<ax>(int a1@<eax>, int a2@<esi>, unsigned int a3)
{
  unsigned int v3; // edx@1
  unsigned int v4; // ecx@1
  unsigned int v5; // ecx@1
  __int16 result; // ax@1

  v3 = a3 % (3600 * (word_1009CAD4[32 * ((*(_BYTE *)(a1 + 8) & 0x3F) - 46)] + 1));
  v4 = v3;
  v3 /= 0xE10u;
  *(_WORD *)a2 = v3;
  v5 = -3600 * (unsigned __int16)v3 + v4;
  *(_BYTE *)(a2 + 2) = v5 / 0x3C;
  result = 60 * (char)(v5 / 0x3C);
  *(_BYTE *)(a2 + 3) = v5 % 0x3C;
  return result;
}
// 1009CAD4: using guessed type __int16 word_1009CAD4[];

//----- (100255F0) --------------------------------------------------------
char *__usercall sub_100255F0@<eax>(int a1@<ebx>, int a2@<edi>, int a3, int a4)
{
  int v4; // esi@1
  void *v5; // ecx@1
  __int16 v6; // ax@2
  char v8; // [sp+4h] [bp-4h]@1
  char v9; // [sp+6h] [bp-2h]@1

  strncpy(&v8, (const char *)(a2 + *(_DWORD *)(a1 + 56) + 69), 2u);
  v9 = 0;
  v4 = a4 + (unsigned __int8)j__atol(&v8);
  if ( sub_10036D10(v5) != 1
    || (v6 = *(_WORD *)(a3 + 8) & 0x3F, v6 == 49)
    || v6 == 48
    || v6 == 47
    || v6 == 50
    || v6 == 51
    || v6 == 46 )
  {
    if ( v4 <= 23 )
    {
      if ( v4 < 0 )
        v4 = 23;
    }
    else
    {
      v4 = 0;
    }
  }
  else if ( v4 <= 12 )
  {
    if ( v4 <= 0 )
      v4 = 12;
  }
  else
  {
    v4 = 1;
  }
  sprintf(&v8, "%02u", v4);
  return strncpy((char *)(a2 + *(_DWORD *)(a1 + 56) + 69), &v8, 2u);
}

//----- (100256B0) --------------------------------------------------------
int __usercall sub_100256B0@<eax>(unsigned int a1@<eax>, char a2@<cl>)
{
  char v2; // bl@1
  int v3; // ebp@1
  __int16 v4; // bx@1
  int v5; // edi@1
  signed int v6; // esi@6
  _BYTE *v7; // eax@7
  int v8; // eax@7

  v2 = a2;
  v3 = sub_10002E60(a1)[1];
  v4 = v2 & 0x3F;
  v5 = 0;
  if ( v4 == 52 || v4 == 53 || v4 == 54 || v4 == 55 || v4 == 56 )
  {
    v6 = 0;
    do
    {
      v7 = (_BYTE *)sub_10037710(byte_1009CD60[v6]);
      v8 = sub_1001C410(v3, v7, 0);
      if ( v5 <= v8 )
        v5 = v8;
      ++v6;
    }
    while ( v6 < 4 );
  }
  return v5;
}

//----- (10025720) --------------------------------------------------------
char __usercall sub_10025720@<al>(int *a1@<ebx>, int a2@<edi>, _DWORD *a3)
{
  int v3; // esi@1
  int v4; // eax@1
  char v5; // cl@1

  v3 = ((*(_BYTE *)(a2 + 8) & 0x3F) - 46) << 6;
  v4 = *(int *)((char *)&dword_1009CAD8 + v3) + *(int *)((char *)&dword_1009CAD0 + v3);
  *a1 = v4;
  v5 = *(_BYTE *)(a2 + 8) & 0x3F;
  if ( v5 == 52 || (*(_BYTE *)(a2 + 8) & 0x3F) == 54 )
  {
    LOBYTE(v4) = sub_10036D10((void *)v5);
    if ( (_BYTE)v4 == 1 )
      ++*a1;
  }
  if ( byte_1009CADD[v3] && *(_BYTE *)(a2 + 8) & 0x40 )
  {
    *a3 = 1;
    ++*a1;
  }
  else
  {
    *a3 = 0;
  }
  return v4;
}
// 1009CAD0: using guessed type int dword_1009CAD0;
// 1009CAD8: using guessed type int dword_1009CAD8;

//----- (10025790) --------------------------------------------------------
char __usercall sub_10025790@<al>(signed int *a1@<ecx>, int a2@<ebx>, int a3, int a4)
{
  int v4; // ebp@1
  signed int v5; // eax@1
  int v6; // edi@3
  void *v7; // ecx@5
  __int16 v8; // ax@6
  signed __int16 v9; // ax@8
  __int16 v10; // cx@16
  __int16 v11; // ax@17
  __int16 v12; // cx@22
  __int16 v13; // ax@26
  int v14; // eax@31
  char result; // al@32
  signed int v16; // [sp+Ch] [bp-8h]@1
  signed int v17; // [sp+10h] [bp-4h]@3

  v4 = a3;
  v5 = 0;
  v16 = 0;
  if ( a1 )
  {
    v5 = *a1;
    v16 = *a1;
  }
  v17 = 1;
  v6 = (*(_BYTE *)(a3 + 8) & 0x3F) - 46;
  if ( v5 < 0 )
  {
    v5 = -v5;
    v16 = v5;
    v17 = -1;
  }
  sub_10025590(a3, (int)&a3, v5);
  if ( sub_10036D10(v7) != 1 || (v8 = *(_WORD *)(v4 + 8) & 0x3F, v8 != 52) && v8 != 54 )
  {
    v9 = a3;
  }
  else
  {
    v9 = a3;
    if ( (_WORD)a3 == 12 )
    {
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 90) = -107;
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 91) = 0;
    }
    else if ( (signed __int16)a3 <= 12 )
    {
      if ( !(_WORD)a3 )
        v9 = 12;
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 90) = -108;
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 91) = 0;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 90) = -107;
      v9 -= 12;
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 91) = 0;
    }
  }
  v10 = *(_WORD *)(v4 + 8);
  if ( v10 & 0x40 )
  {
    sprintf((char *)(*(_DWORD *)(a2 + 56) + 69), &a03d02u[64 * v6], v17 * v9, BYTE2(a3), BYTE3(a3));
    v11 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( (v11 == 46 || v11 == 47) && !v16 || v17 < 0 )
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 69) = 45;
  }
  else
  {
    v12 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( v12 != 50 && v12 != 51 )
      sprintf((char *)(*(_DWORD *)(a2 + 56) + 69), off_1009CAA0[16 * v6], v17 * v9, BYTE2(a3), BYTE3(a3));
    else
      sprintf(
        (char *)(*(_DWORD *)(a2 + 56) + 69),
        off_1009CAA0[16 * v6],
        BYTE2(a3),
        (unsigned __int8)(BYTE3(a3) / 10 + 48),
        (unsigned __int8)((unsigned __int16)(BYTE3(a3) % 10) + 48));
  }
  *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) = 0;
  v13 = *(_WORD *)(v4 + 8) & 0x3F;
  if ( v13 != 46 && v13 != 47 && v13 != 52 && v13 != 48 && v13 != 54
    || (v14 = *(_DWORD *)(a2 + 56), *(_WORD *)(v14 + 240) != a4) )
  {
    *(_BYTE *)(*(_DWORD *)(a2 + 56) + 242) = 1;
    result = 4;
  }
  else
  {
    *(_BYTE *)(v14 + 242) = 2;
    result = 4;
  }
  return result;
}
// 1009CAA0: using guessed type char *off_1009CAA0[2];

//----- (10025980) --------------------------------------------------------
char __cdecl sub_10025980(signed __int16 *a1, _BYTE *a2)
{
  void *v2; // ecx@1
  char v3; // bl@1
  char result; // al@4
  char v5[4]; // [sp+8h] [bp-4h]@1

  v3 = sub_10039160(v5);
  if ( v3 == 1 )
  {
    if ( sub_10036D40(v2) == 1 )
      sub_1003F730((int *)v5, *(int *)v5);
    sub_10038FE0((int)a1, *(unsigned int *)v5);
    sub_10025520(a1, a2);
    result = 1;
  }
  else
  {
    *a1 = 0x7FFF;
    sub_10025520(a1, a2);
    result = v3;
  }
  return result;
}

//----- (10025A00) --------------------------------------------------------
char __usercall sub_10025A00@<al>(int a1@<eax>, int a2@<ecx>, signed int *a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  void *v6; // ecx@1
  int v7; // eax@1
  char v8; // bl@1
  unsigned __int16 v9; // ax@4
  __int16 v10; // ax@7
  __int16 v11; // ax@10
  char result; // al@12
  unsigned __int16 v13; // ax@15
  int v14; // ebp@17
  int v15; // eax@18
  __int16 v16; // ax@19
  int v17; // eax@26
  char *v18; // eax@27
  int v19; // ebx@27
  char v20; // dl@28
  char v21; // bl@29
  char *v22; // eax@29
  char v23; // dl@29
  char v24; // cl@30
  __int16 v25; // bp@33
  void *v26; // ecx@34
  __int16 v27; // di@35
  char *v28; // eax@42
  int v29; // edi@42
  char v30; // dl@43
  char v31; // bl@44
  char *v32; // eax@44
  char v33; // dl@44
  char v34; // cl@45
  int v35; // ecx@46
  unsigned int v36; // kr00_4@48
  __int32 v37; // eax@48
  int v38; // ebx@49
  char *v39; // eax@53
  char v40; // dl@54
  char v41; // bl@55
  char *v42; // eax@55
  char v43; // dl@55
  char v44; // cl@56
  int v45; // ecx@57
  __int16 v46; // ax@57
  const char *v47; // ecx@58
  char v48; // kr08_1@58
  char *v49; // eax@58
  char v50; // dl@58
  char v51; // cl@59
  int v52; // ecx@60
  char v53; // cl@62
  int v54; // edx@65
  __int16 v55; // di@75
  bool v56; // zf@79
  unsigned __int16 v57; // ax@82
  __int16 v58; // ax@85
  __int16 v59; // bp@88
  unsigned __int16 v60; // ax@89
  int v61; // ebp@91
  void *v62; // ecx@91
  __int16 v63; // ax@92
  char *v64; // eax@99
  int v65; // edx@99
  char v66; // cl@100
  char v67; // bl@101
  char *v68; // eax@101
  char v69; // bp@101
  char v70; // cl@102
  int v71; // eax@103
  _BYTE *v72; // ecx@103
  __int16 v73; // ax@103
  __int16 v74; // di@109
  signed __int16 v75; // di@114
  const char *v76; // ecx@117
  char *v77; // eax@117
  int v78; // edi@117
  char v79; // dl@118
  __int16 v80; // bp@123
  __int16 v81; // ax@123
  char v82[2]; // [sp+10h] [bp-10h]@33
  char v83; // [sp+12h] [bp-Eh]@34
  char v84; // [sp+13h] [bp-Dh]@33
  int v85; // [sp+14h] [bp-Ch]@1
  int v86; // [sp+18h] [bp-8h]@1
  int v87; // [sp+1Ch] [bp-4h]@1

  v4 = a1;
  v5 = a2;
  v86 = (*(_BYTE *)(a1 + 8) & 0x3F) - 46;
  sub_10025720(&v87, a1, &v85);
  v7 = *(_DWORD *)(v5 + 56);
  v8 = 1;
  if ( *(_WORD *)(v7 + 240) != -128 )
  {
    if ( *(_WORD *)(a4 + 10) == 84 )
      *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)(v7 + 69) != 45) + 43;
    v9 = *(_WORD *)(a4 + 14);
    if ( v9 >= 0x41u && v9 <= 0x5Au || v9 == 32 )
    {
      v10 = *(_WORD *)(v4 + 8) & 0x3F;
      if ( (v10 == 52 || v10 == 54) && sub_10036D10(v6) == 1 )
      {
        v11 = *(_WORD *)(a4 + 14);
        goto LABEL_11;
      }
    }
    v13 = *(_WORD *)(a4 + 14);
    if ( v13 >= 0x30u && v13 <= 0x39u )
    {
      v14 = v85;
      if ( *(_BYTE *)(v4 + 8) & 0x40 )
      {
        v15 = *(_DWORD *)(v5 + 56);
        if ( *(_WORD *)(v15 + 240) == v85 - 1 )
        {
          *(_WORD *)(v15 + 240) = v85;
          v16 = *(_WORD *)(v4 + 8) & 0x3F;
          if ( v16 != 46 && v16 != 47 && v16 != 52 && v16 != 48 && v16 != 54 )
            *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
          else
            *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 2;
        }
      }
      v17 = *(_DWORD *)(v5 + 56);
      if ( *(_BYTE *)(v17 + 242) == 2 )
      {
        *(_WORD *)(v17 + v14 + 69) = 12336;
        v18 = (char *)(*(_DWORD *)(v5 + 56) + 69);
        v19 = *(_DWORD *)(v5 + 56) + 70;
        do
          v20 = *v18++;
        while ( v20 );
        v21 = (_BYTE)v18 - v19;
        v22 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 58);
        v23 = (_BYTE)v22 + 1;
        do
          v24 = *v22++;
        while ( v24 );
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)(v21 - ((_BYTE)v22 - v23)) - 1;
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
      }
      if ( (*(_BYTE *)(v4 + 8) & 0x3F) == 49 )
      {
        strncpy(v82, (const char *)(*(_DWORD *)(v5 + 56) + v85 + 69), 3u);
        v25 = word_1009CAD4[32 * v86];
        v84 = 0;
      }
      else
      {
        strncpy(v82, (const char *)(*(_DWORD *)(v5 + 56) + v14 + 69), 2u);
        v83 = 0;
        if ( sub_10036D10(v26) != 1
          || (v27 = *(_WORD *)(v4 + 8) & 0x3F, v27 == 49)
          || v27 == 48
          || v27 == 47
          || v27 == 50
          || v27 == 51
          || (v25 = 12, v27 == 46) )
        {
          v25 = 23;
        }
      }
      v28 = (char *)(*(_DWORD *)(v5 + 56) + 69);
      v29 = *(_DWORD *)(v5 + 56) + 70;
      do
        v30 = *v28++;
      while ( v30 );
      v31 = (_BYTE)v28 - v29;
      v32 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 58);
      v33 = (_BYTE)v32 + 1;
      do
        v34 = *v32++;
      while ( v34 );
      v35 = *(_DWORD *)(v5 + 56);
      if ( *(_WORD *)(v35 + 240) == (char)(v31 - ((_BYTE)v32 - v33)) - 1 )
      {
        if ( v82[0] == 48 )
        {
          v36 = strlen(v82);
          v37 = j__atol(v82);
          sprintf(v82, "%0*i", v36, 10 * v37);
        }
        v38 = v85;
        v82[*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) - v85] = *(_BYTE *)(a4 + 14);
        if ( j__atol(v82) > v25 )
          *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) + *(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a4 + 14);
        else
          memcpy_0((void *)(*(_DWORD *)(v5 + 56) + v38 + 69), v82, strlen(v82));
        if ( 10 * j__atol((const char *)(*(_DWORD *)(v5 + 56) + v38 + 69)) <= v25 )
        {
LABEL_69:
          if ( *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) + *(_DWORD *)(v5 + 56) + 69) == 58 )
          {
            ++*(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
            return 2;
          }
          return 2;
        }
        v39 = (char *)(*(_DWORD *)(v5 + 56) + 69);
        do
          v40 = *v39++;
        while ( v40 );
        v41 = (_BYTE)v39 - (*(_BYTE *)(v5 + 56) + 70);
        v42 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 58);
        v43 = (_BYTE)v42 + 1;
        do
          v44 = *v42++;
        while ( v44 );
        v45 = *(_DWORD *)(v5 + 56);
        v46 = (char)(v41 - ((_BYTE)v42 - v43)) + 1;
      }
      else
      {
        v47 = (const char *)(v35 + 69);
        v48 = strlen(v47);
        v49 = strchr(v47, 58);
        v50 = (_BYTE)v49 + 1;
        do
          v51 = *v49++;
        while ( v51 );
        v52 = *(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
        if ( v52 >= (char)(v48 - ((_BYTE)v49 - v50)) - 1 )
        {
          if ( *(_WORD *)(a4 + 14) > (unsigned __int16)(unsigned __int8)*(&byte_1009CAA8[(v86 << 6) - v85] + v52) )
            goto LABEL_69;
          v53 = *(_BYTE *)(a4 + 14);
        }
        else
        {
          v82[v52 - v85] = *(_BYTE *)(a4 + 14);
          if ( j__atol(v82) > v25 )
            goto LABEL_69;
          v53 = *(_BYTE *)(a4 + 14);
        }
        *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v5 + 56) + 240))++ + *(_DWORD *)(v5 + 56) + 69) = v53;
        v54 = *(_DWORD *)(v5 + 56);
        LOBYTE(v46) = v87 - 1;
        if ( *(_WORD *)(v54 + 240) < v87 - 1 )
          v46 = *(_WORD *)(v54 + 240);
        v45 = *(_DWORD *)(v5 + 56);
        v46 = (char)v46;
      }
      *(_WORD *)(v45 + 240) = v46;
      goto LABEL_69;
    }
    if ( v13 != 43 && v13 != 45 || !(*(_BYTE *)(v4 + 8) & 0x40) )
      return v8;
    *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a4 + 14);
    if ( *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) != v85 - 1 )
      return 2;
    *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = v85;
    v55 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( v55 == 46 || v55 == 47 || v55 == 52 || v55 == 48 )
      goto LABEL_129;
    v56 = v55 == 54;
LABEL_128:
    if ( v56 )
      goto LABEL_129;
    *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
    return 2;
  }
  if ( *(_WORD *)(a4 + 10) == 84 )
    *(_WORD *)(a4 + 14) = 45;
  v57 = *(_WORD *)(a4 + 14);
  if ( v57 >= 0x41u && v57 <= 0x5Au || v57 == 32 )
  {
    v58 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( (v58 == 52 || v58 == 54) && sub_10036D10(v6) == 1 )
    {
      v59 = v85;
      sub_10025790(a3, v5, v4, v85);
      *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = v59;
      v11 = *(_WORD *)(a4 + 14);
LABEL_11:
      if ( v11 == 80 )
      {
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 90) = -107;
        return 2;
      }
      if ( v11 == 65 )
      {
        result = 2;
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 90) = -108;
        return result;
      }
      return 2;
    }
  }
  v60 = *(_WORD *)(a4 + 14);
  if ( v60 < 0x30u || v60 > 0x39u )
  {
    if ( v60 != 43 && v60 != 45 || !(*(_BYTE *)(v4 + 8) & 0x40) )
      return v8;
    v80 = v85;
    v86 = 0;
    sub_10025790(&v86, v5, v4, v85);
    *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a4 + 14);
    *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = v80;
    v81 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( v81 == 46 || v81 == 47 || v81 == 52 || v81 == 48 )
    {
LABEL_129:
      result = 2;
      *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 2;
      return result;
    }
    v56 = v81 == 54;
    goto LABEL_128;
  }
  v61 = v85;
  v86 = 0;
  sub_10025790(&v86, v5, v4, v85);
  if ( sub_10036D10(v62) == 1 )
  {
    v63 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( v63 != 49 && v63 != 48 && v63 != 47 && v63 != 50 && v63 != 51 && v63 != 46 )
      *(_WORD *)(*(_DWORD *)(v5 + 56) + v61 + 69) = 12336;
  }
  *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
  v64 = (char *)(*(_DWORD *)(v5 + 56) + 69);
  v65 = *(_DWORD *)(v5 + 56) + 70;
  do
    v66 = *v64++;
  while ( v66 );
  v67 = (_BYTE)v64 - v65;
  v68 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 58);
  v69 = (_BYTE)v68 + 1;
  do
    v70 = *v68++;
  while ( v70 );
  *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)(v67 - ((_BYTE)v68 - v69)) - 1;
  v71 = *(_DWORD *)(v5 + 56);
  v72 = (_BYTE *)*(_WORD *)(v71 + 240);
  v72[v71 + 69] = *(_BYTE *)(a4 + 14);
  v73 = *(_WORD *)(v4 + 8) & 0x3F;
  if ( v73 != 46 && v73 != 47 && v73 != 52 && v73 != 48 && v73 != 54 )
    return 2;
  if ( sub_10036D10(v72) != 1
    || (v74 = *(_WORD *)(v4 + 8) & 0x3F, v74 == 49)
    || v74 == 48
    || v74 == 47
    || v74 == 50
    || v74 == 51
    || (v56 = v74 == 46, v75 = 12, v56) )
  {
    v75 = 23;
  }
  if ( 10 * j__atol((const char *)(*(_DWORD *)(v5 + 56) + v85 + 69)) <= v75 )
    return 2;
  v76 = (const char *)(*(_DWORD *)(v5 + 56) + 69);
  v77 = (char *)(*(_DWORD *)(v5 + 56) + 69);
  v78 = *(_DWORD *)(v5 + 56) + 70;
  do
    v79 = *v77++;
  while ( v79 );
  *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)((_BYTE)v77 - v78 - strlen(strchr(v76, 58))) + 1;
  return 2;
}
// 1009CAD4: using guessed type __int16 word_1009CAD4[];
// 10025A00: using guessed type char var_10[2];

//----- (100261F0) --------------------------------------------------------
char __usercall sub_100261F0@<al>(int a1@<eax>, signed int *a2@<edx>, int a3, _BYTE *a4)
{
  _BYTE *v4; // edi@1
  int v5; // esi@1
  int v6; // ebx@1
  signed int v7; // ebp@2
  int v8; // ecx@8
  signed int v9; // esi@8
  int v10; // ebx@10
  _BYTE *v11; // edx@11
  __int16 v12; // dx@12
  int v13; // esi@29
  int v14; // esi@33
  char *v15; // ebx@38
  void *v16; // ecx@41
  const char *v17; // ST18_4@49
  char *v18; // ebx@57
  void *v19; // ecx@60
  char *v20; // ebx@68
  _BYTE *v21; // edx@71
  char v22; // cl@72
  int v24; // [sp-8h] [bp-30h]@21
  signed int v25; // [sp-8h] [bp-30h]@28
  int v26; // [sp-4h] [bp-2Ch]@21
  signed int v27; // [sp-4h] [bp-2Ch]@32
  __int16 v28; // [sp+10h] [bp-18h]@8
  unsigned __int8 v29; // [sp+12h] [bp-16h]@8
  unsigned __int8 v30; // [sp+13h] [bp-15h]@8
  int v31; // [sp+14h] [bp-14h]@1
  int v32; // [sp+18h] [bp-10h]@1
  char *v33; // [sp+1Ch] [bp-Ch]@10
  char v34[4]; // [sp+20h] [bp-8h]@10
  int v35; // [sp+24h] [bp-4h]@1

  v4 = (_BYTE *)a1;
  v5 = *(_BYTE *)(a3 + 8) & 0x3F;
  LOBYTE(a1) = 0;
  *(_DWORD *)v4 = 0;
  *((_DWORD *)v4 + 1) = 0;
  *((_DWORD *)v4 + 2) = 0;
  *((_DWORD *)v4 + 3) = 0;
  *((_DWORD *)v4 + 4) = 0;
  v35 = v5;
  v6 = v5 - 46;
  v32 = 1;
  LOBYTE(v31) = 31;
  v4[20] = 0;
  if ( v5 == 54 )
    v7 = 0;
  else
    v7 = *a2;
  switch ( v5 )
  {
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
      if ( v7 >= 0x7FFFFFFF )
        goto LABEL_78;
      if ( v7 < 0 )
      {
        v7 = -v7;
        v32 = -1;
      }
      sub_10025590(a3, (int)&v28, v7);
      v8 = v28;
      v9 = v29;
      if ( v30 + 60 * (v29 + 60 * v28) != v7 || v7 >= 0x7FFFFFFF )
      {
LABEL_78:
        v15 = (&off_1009CAA4)[64 * v6];
        do
        {
          LOBYTE(a1) = *v15;
          *v4++ = *v15++;
        }
        while ( (_BYTE)a1 );
      }
      else
      {
        v10 = v6 << 6;
        v33 = (&off_1009CAA4)[v10];
        *(_DWORD *)v34 = v4;
        do
        {
          LOBYTE(a1) = *v33;
          v11 = *(_BYTE **)v34;
          ++v33;
          ++*(_DWORD *)v34;
          *v11 = a1;
        }
        while ( (_BYTE)a1 );
        v12 = *(__int16 *)((char *)word_1009CAD4 + v10);
        if ( v28 <= v12 )
        {
          if ( (a1 = *(_WORD *)(a3 + 8), *(_DWORD *)v34 = a1, LOWORD(a1) = a1 & 0x3F, (_WORD)a1 != 50)
            && (_WORD)a1 != 51
            || v9 <= v12 )
          {
            if ( v28 || v35 != 47 )
            {
              if ( (_WORD)a1 != 50 && (_WORD)a1 != 51 )
              {
                if ( v35 == 46 || v35 == 47 )
                {
                  v27 = v9;
                  if ( v34[0] & 0x40 )
                  {
                    v14 = v32;
                    LOBYTE(a1) = sprintf(v4, &a03d02u[v10], v32 * v8, v27);
                    if ( !v7 || v14 < 0 )
                      *v4 = 45;
                  }
                  else
                  {
                    LOBYTE(a1) = sprintf(v4, *(char **)((char *)off_1009CAA0 + v10), v32 * v8, v9);
                  }
                }
                else
                {
                  v25 = v9;
                  if ( v34[0] & 0x40 )
                  {
                    v13 = v32;
                    LOBYTE(a1) = sprintf(v4, &a03d02u[v10], v32 * v8, v25, v30);
                    if ( v13 < 0 )
                      *v4 = 45;
                  }
                  else
                  {
                    LOBYTE(a1) = sprintf(v4, *(char **)((char *)off_1009CAA0 + v10), v32 * v8, v9, v30);
                  }
                }
              }
              else
              {
                v26 = (unsigned __int8)((unsigned __int16)(v30 % 10) + 48);
                v24 = (unsigned __int8)(v30 / 10 + 48);
                if ( v34[0] & 0x40 )
                {
                  LOBYTE(a1) = sprintf(v4, &a03d02u[v10], v9, v24, v26);
                  if ( !v7 || v32 < 0 )
                    *v4 = 45;
                }
                else
                {
                  LOBYTE(a1) = sprintf(v4, *(char **)((char *)off_1009CAA0 + v10), v9, v24, v26);
                }
              }
            }
            else
            {
              LOBYTE(a1) = sprintf(
                             v4,
                             "%02u:%c%c",
                             v9,
                             (unsigned __int8)(v30 / 10 + 48),
                             (unsigned __int8)((unsigned __int16)(v30 % 10) + 48));
            }
          }
        }
      }
      break;
    case 55:
      if ( !sub_10039160(v34) || v7 >= 86400 )
        goto LABEL_53;
      if ( sub_10036D40(v16) == 1 )
        sub_1003F730((int *)v34, *(int *)v34);
      v7 += 86400
          * (((signed int)(((unsigned __int64)(1037155065i64 * (*(_DWORD *)v34 + v7)) >> 32) - (*(_DWORD *)v34 + v7)) >> 16)
           + ((unsigned int)(((unsigned __int64)(1037155065i64 * (*(_DWORD *)v34 + v7)) >> 32) - (*(_DWORD *)v34 + v7)) >> 31))
          + *(_DWORD *)v34;
      goto LABEL_46;
    case 52:
    case 53:
    case 56:
LABEL_46:
      if ( v7 == -1 || v7 >= 86400 )
      {
LABEL_53:
        v28 = 0x7FFF;
        if ( v5 == 53 || v5 == 56 )
          LOBYTE(v31) = 38;
        else
          sub_10025520(&v28, &v31);
        v18 = (&off_1009CAA4)[64 * (v5 - 46)];
        do
        {
          LOBYTE(a1) = *v18;
          *v4++ = *v18++;
        }
        while ( (_BYTE)a1 );
      }
      else
      {
        sub_10038FE0((int)&v28, v7);
        if ( v5 == 53 )
        {
          v17 = off_1009CAA0[16 * (v5 - 46)];
          LOBYTE(v31) = 38;
          LOBYTE(a1) = sprintf(v4, v17, v28, v29, v30);
        }
        else if ( v5 == 56 )
        {
          LOBYTE(v31) = 38;
          LOBYTE(a1) = sprintf(v4, off_1009CAA0[16 * (v5 - 46)], v28, v29);
        }
        else
        {
          sub_10025520(&v28, &v31);
          LOBYTE(a1) = sprintf(v4, off_1009CAA0[16 * (v5 - 46)], v28, v29);
        }
      }
      break;
    case 54:
      if ( sub_10025980(&v28, &v31) )
      {
        if ( sub_10036D10(v19) == 1 )
        {
          if ( v28 && v28 != 12 )
          {
            LOBYTE(a1) = sprintf(v4, "%d:%02d:%02d", v28 % 12, v29, v30);
          }
          else
          {
            sprintf(v4, "%02d:%02d:%02d", 12, v29, v30);
            LOBYTE(a1) = sprintf(v4, "%02d:%02d:%02d", 12, v29, v30);
          }
        }
        else
        {
          LOBYTE(a1) = sprintf(v4, off_1009CAA0[16 * (v5 - 46)], v28, v29, v30);
        }
      }
      else
      {
        v20 = (&off_1009CAA4)[64 * (v5 - 46)];
        do
        {
          LOBYTE(a1) = *v20;
          *v4++ = *v20++;
        }
        while ( (_BYTE)a1 );
      }
      break;
    default:
      break;
  }
  if ( ~(unsigned __int8)(*(_WORD *)(a3 + 8) >> 9) & 1 )
  {
    a1 = sub_10037710(v31);
    v21 = a4;
    do
    {
      v22 = *(_BYTE *)a1;
      *v21++ = *(_BYTE *)a1++;
    }
    while ( v22 );
  }
  else
  {
    *a4 = 0;
  }
  return a1;
}
// 1009CAA0: using guessed type char *off_1009CAA0[2];
// 1009CAA4: using guessed type char *off_1009CAA4;
// 1009CAD4: using guessed type __int16 word_1009CAD4[];

//----- (100266F0) --------------------------------------------------------
char __usercall sub_100266F0@<al>(signed int *a1@<edx>, int a2@<ecx>, int a3@<edi>, int a4@<esi>)
{
  int v4; // ebx@1
  __int16 v5; // cx@1
  int v6; // ebx@2
  __int16 v7; // ax@4
  char v9; // [sp+4h] [bp-24h]@1
  char v10; // [sp+Ch] [bp-1Ch]@1

  v4 = a2;
  sub_100261F0((int)&v10, a1, a4, &v9);
  *(_WORD *)(a3 + 438) = *(_WORD *)v4;
  *(_WORD *)(a3 + 436) = *(_WORD *)(v4 + 2);
  v5 = *(_WORD *)(a4 + 8);
  if ( ~((unsigned int)*(_WORD *)(a4 + 8) >> 9) & 1 )
    v6 = sub_100256B0(*(_DWORD *)(a4 + 4), v5);
  else
    v6 = 0;
  v7 = *(_WORD *)(a4 + 10) - v6;
  if ( v6 > 0 )
    v7 -= *(_WORD *)(dword_10789604[5 * ((*(_DWORD *)(a4 + 4) >> 10) & 0xF)] + 28);
  if ( !*(_WORD *)(a4 + 10) )
    v7 = sub_100254C0(*(_DWORD *)(a4 + 4), *(_WORD *)(a4 + 8));
  return sub_100039C0(a3, &v10, &v9, v7, v6, *(_DWORD *)(a4 + 4), *(_WORD *)(a4 + 8));
}
// 10789604: using guessed type int dword_10789604[];

//----- (100267B0) --------------------------------------------------------
char __cdecl sub_100267B0(int a1, int a2, int *a3, signed int *a4, int a5)
{
  signed int *v5; // ecx@1
  int v6; // edx@2
  int v7; // ebx@4
  bool v8; // zf@4
  __int16 v9; // ax@8
  _WORD *v10; // esi@8
  unsigned int v11; // ebx@9
  int v12; // eax@9
  int v13; // eax@11
  __int16 v14; // dx@15
  __int16 v15; // cx@15
  __int64 v16; // rax@18
  int v17; // eax@20
  __int16 v18; // bx@20
  signed int v19; // eax@21
  signed int v20; // edx@29
  int v21; // edx@31
  int v22; // edx@32
  int *v23; // ecx@34
  int v24; // esi@34
  signed int v25; // eax@35
  __int16 v26; // ax@37
  int v27; // esi@39
  void *v28; // ecx@39
  signed __int16 v29; // bx@39
  __int16 v30; // ax@41
  int v31; // edi@55
  int v32; // esi@57
  char v33; // al@58
  __int16 v34; // ax@63
  int v35; // edi@67
  char v36; // al@68
  __int16 v37; // ax@75
  int v38; // eax@77
  char v39; // cl@77
  char v40; // al@79
  int v41; // eax@85
  signed int *v42; // edx@85
  const char *v43; // edx@89
  char v44; // kr00_1@89
  char *v45; // eax@89
  char v46; // dl@89
  char v47; // cl@90
  int v48; // ecx@91
  __int16 v49; // ax@92
  int v50; // ebx@97
  __int16 v51; // ax@101
  int v52; // eax@105
  int v53; // esi@105
  __int16 v54; // cx@107
  char v55; // dl@114
  int v56; // edi@120
  int v57; // edi@129
  __int16 v58; // ax@129
  char v59; // al@131
  char v60; // cl@132
  int v61; // ebx@136
  int v62; // ecx@137
  int v63; // edx@137
  unsigned __int8 v64; // al@137
  __int16 v65; // ax@139
  __int16 v66; // ax@146
  int v67; // eax@151
  int v68; // esi@155
  __int16 v69; // cx@156
  signed int *v70; // edx@156
  int v71; // ecx@156
  int v72; // ecx@157
  int v73; // edx@157
  unsigned __int8 v74; // al@157
  __int16 v75; // ax@159
  int v76; // eax@167
  unsigned __int8 v77; // cl@167
  __int16 v78; // ax@171
  int v79; // eax@176
  int v80; // ebx@181
  int *v81; // eax@194
  unsigned __int8 v82; // ST10_1@194
  const char *v83; // ebx@194
  int v84; // esi@194
  __int16 v85; // ax@194
  char v87; // [sp+13h] [bp-3Dh]@4
  int v88; // [sp+14h] [bp-3Ch]@5
  int v89; // [sp+18h] [bp-38h]@4
  signed int *v90; // [sp+1Ch] [bp-34h]@1
  int v91; // [sp+20h] [bp-30h]@1
  int *v92; // [sp+24h] [bp-2Ch]@1
  int v93; // [sp+28h] [bp-28h]@4
  int v94; // [sp+2Ch] [bp-24h]@5
  int v95; // [sp+30h] [bp-20h]@85
  char v96[24]; // [sp+34h] [bp-1Ch]@35

  v5 = a4;
  v92 = a3;
  v91 = a2;
  v90 = a4;
  if ( a4 )
    v6 = *a4;
  else
    v6 = 0;
  v7 = (*(_BYTE *)(a2 + 8) & 0x3F) - 46;
  v8 = *(_WORD *)a5 == -32703;
  v89 = v6;
  v87 = 1;
  v93 = v7;
  if ( v8 )
  {
    v88 = 0;
    v94 = 0;
  }
  else
  {
    sub_10025720(&v94, a2, &v88);
    v5 = v90;
    v6 = v89;
  }
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v9 = *(_WORD *)(a2 + 10);
      v10 = (_WORD *)(a1 + 276);
      if ( v9 )
      {
        sub_10003860(a1 + 276, *v92, *(_DWORD *)(a2 + 4), v9);
      }
      else
      {
        v11 = *(_DWORD *)(a2 + 4);
        v12 = sub_100254C0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8));
        sub_10003860(a1 + 276, *v92, v11, v12);
      }
      v13 = sub_100256B0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8));
      if ( (!*(_WORD *)(a2 + 10) || (*(_DWORD *)(a2 + 4) & 0xC000) == 0x4000)
        && ~(unsigned __int8)(*(_WORD *)(a2 + 8) >> 9) & 1
        && v13 > 0 )
      {
        v14 = *(_WORD *)(dword_10789604[5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF)] + 28);
        *(_WORD *)(a1 + 280) += v13 + v14;
        v15 = *(_WORD *)(a1 + 280);
        if ( *(_WORD *)(a2 + 10) > 0 )
          *v10 += v13 + v14;
        if ( (*(_DWORD *)(a2 + 4) & 0xC000) == 0x8000 )
        {
          v16 = (signed __int16)v13 + (signed int)v14 + 1;
          LODWORD(v16) = ((signed int)v16 - HIDWORD(v16)) >> 1;
          *v10 -= v16;
          *(_WORD *)(a1 + 280) = v15 - v16;
        }
      }
      return 2;
    case 0x8048:
      v17 = *(_DWORD *)(a1 + 56);
      v18 = *(_WORD *)(v17 + 240);
      if ( v18 == -128 )
      {
        v19 = *(_WORD *)(a5 + 10);
        if ( v19 > 84 )
        {
          if ( v19 != 0x2000 )
            return v87;
        }
        else if ( v19 != 84 )
        {
          if ( v19 == 32 )
          {
            v93 = 0;
            v87 = sub_10025790(&v93, a1, a2, v88);
          }
          else if ( v19 == 56 )
          {
            v87 = sub_10025790(v5, a1, a2, v88);
          }
          return v87;
        }
        return sub_10025A00(a2, a1, v5, a5);
      }
      v20 = *(_WORD *)(a5 + 10);
      if ( v20 > 56 )
      {
        if ( v20 == 57 )
        {
          v60 = *(_BYTE *)(a5 + 8);
          if ( v60 < 0 )
          {
            if ( v18 )
            {
              --*(_WORD *)(v17 + 240);
              if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) )
              {
                v61 = v88;
                do
                {
                  v62 = *(_DWORD *)(a1 + 56);
                  v63 = *(_WORD *)(v62 + 240);
                  v64 = *(_BYTE *)(v63 + v62 + 69);
                  if ( v64 >= 0x30u && v64 <= 0x39u )
                  {
                    v65 = *(_WORD *)(a2 + 8) & 0x3F;
                    if ( v65 != 46 && v65 != 47 && v65 != 52 && v65 != 48 && v65 != 54 )
                      break;
                    if ( v63 != v61 + 1 )
                      break;
                  }
                  --*(_WORD *)(v62 + 240);
                }
                while ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) );
              }
              v66 = *(_WORD *)(a2 + 8) & 0x3F;
              v87 = 2;
              if ( v66 != 46 && v66 != 47 && v66 != 52 && v66 != 48 && v66 != 54
                || (v67 = *(_DWORD *)(a1 + 56), *(_WORD *)(v67 + 240) != v88) )
              {
                *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
              }
              else
              {
                *(_BYTE *)(v67 + 242) = 2;
              }
            }
            else
            {
              v87 = 2;
            }
            goto LABEL_127;
          }
          if ( v60 <= 0 )
            return v87;
          v68 = v94 - 1;
          if ( v18 >= v94 - 1 )
            return 0;
          v69 = *(_WORD *)(v17 + 240);
          v70 = (signed int *)v69;
          *(_WORD *)(v17 + 240) = v69 + 1;
          v71 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
          v90 = v70;
          if ( v71 < v68 )
          {
            do
            {
              v72 = *(_DWORD *)(a1 + 56);
              v73 = *(_WORD *)(v72 + 240);
              v74 = *(_BYTE *)(v73 + v72 + 69);
              if ( v74 >= 0x30u && v74 <= 0x39u )
              {
                v75 = *(_WORD *)(a2 + 8) & 0x3F;
                if ( v75 != 46 && v75 != 47 && v75 != 52 && v75 != 48 && v75 != 54 )
                  break;
                if ( v73 != v88 + 1 )
                  break;
              }
              ++*(_WORD *)(v72 + 240);
            }
            while ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v68 );
          }
          if ( byte_1009CADC[64 * v93]
            || (v76 = *(_DWORD *)(a1 + 56), v77 = *(_BYTE *)(*(_WORD *)(v76 + 240) + v76 + 69), v77 >= 0x30u)
            && v77 <= 0x39u )
          {
            v87 = 2;
          }
          else
          {
            *(_WORD *)(v76 + 240) = (char)v90;
            v87 = 0;
          }
          v78 = *(_WORD *)(a2 + 8) & 0x3F;
          if ( v78 != 46 && v78 != 47 && v78 != 52 && v78 != 48 && v78 != 54
            || (v79 = *(_DWORD *)(a1 + 56), *(_WORD *)(v79 + 240) != v88) )
          {
            *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
          }
          else
          {
            *(_BYTE *)(v79 + 242) = 2;
          }
        }
        else
        {
          if ( v20 != 84 && v20 != 0x2000 )
            return v87;
          v87 = sub_10025A00(a2, a1, v5, a5);
        }
        if ( v87 != 4 && v87 != 2 )
          return v87;
LABEL_127:
        if ( v89 < 0 )
          v89 = -v89;
        v57 = v91;
        sub_10025590(v91, (int)&v89, v89);
        v58 = *(_WORD *)(v57 + 8) & 0x3F;
        LOBYTE(v88) = 31;
        if ( v58 == 52 || v58 == 54 )
        {
          v59 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 90);
          goto LABEL_187;
        }
        goto LABEL_192;
      }
      if ( v20 == 56 )
      {
        v90 = (signed int *)(2 * (*(_BYTE *)(a5 + 8) >= 0) - 1);
        if ( v18 >= v88 )
        {
          v43 = (const char *)(v17 + 69);
          v44 = strlen((const char *)(v17 + 69));
          v45 = strchr(v43, 58);
          v46 = (_BYTE)v45 + 1;
          do
            v47 = *v45++;
          while ( v47 );
          v48 = *(_DWORD *)(a1 + 56);
          if ( *(_WORD *)(v48 + 240) < (signed __int16)(char)(v44 - ((_BYTE)v45 - v46)) )
          {
            v49 = *(_WORD *)(a2 + 8) & 0x3F;
            if ( v49 == 46 || v49 == 47 || v49 == 52 || v49 == 48 || v49 == 54 )
            {
              v50 = v88;
              *(_WORD *)(v48 + 240) = v88;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 2;
              goto LABEL_100;
            }
            *(_BYTE *)(v48 + 242) = 1;
          }
        }
        v50 = v88;
LABEL_100:
        if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != v94 - 1
          || (v51 = *(_WORD *)(a2 + 8) & 0x3F, v51 != 52) && v51 != 54
          || sub_10036D10((void *)(v94 - 1)) != 1 )
        {
          v52 = *(_DWORD *)(a1 + 56);
          v53 = *(_WORD *)(v52 + 240);
          if ( v53 == v50 - 1 )
          {
            v87 = 2;
            *(_BYTE *)(v52 + 69) = 2 * (*(_BYTE *)(v52 + 69) != 45) + 43;
          }
          else
          {
            v54 = *(_WORD *)(a2 + 8) & 0x3F;
            if ( v54 != 46 && v54 != 47 && v54 != 52 && v54 != 48 && v54 != 54 || v53 != v50 )
            {
              v55 = *(_BYTE *)(v53 + v52 + 69);
              if ( v55 != 48 || v90 != (signed int *)-1 )
              {
                if ( *(_BYTE *)(*(_WORD *)(v52 + 240) + v52 + 69) < (unsigned __int8)*(&byte_1009CAA8[(v93 << 6) - v50]
                                                                                     + *(_WORD *)(v52 + 240))
                  || v90 != (signed int *)1 )
                {
                  v56 = *(_DWORD *)(a1 + 56);
                  *(_BYTE *)(*(_WORD *)(v56 + 240) + v56 + 69) = sub_10038B70(v55, 0x10u, (char)v90);
                  v87 = 2;
                }
                else
                {
                  *(_BYTE *)(v53 + v52 + 69) = 48;
                  v87 = 2;
                }
              }
              else
              {
                *(_BYTE *)(*(_WORD *)(v52 + 240) + v52 + 69) = *(&byte_1009CAA8[(v93 << 6) - v50] + *(_WORD *)(v52 + 240));
                v87 = 2;
              }
            }
            else
            {
              sub_100255F0(a1, v50, v91, (int)v90);
              v87 = 2;
            }
          }
        }
        else
        {
          v87 = 2;
          *(_BYTE *)(*(_DWORD *)(a1 + 56) + 90) = (*(_BYTE *)(*(_DWORD *)(a1 + 56) + 90) == -108) - 108;
        }
        goto LABEL_127;
      }
      v21 = v20 - 32;
      if ( !v21 )
        goto LABEL_34;
      v22 = v21 - 1;
      if ( v22 )
      {
        if ( v22 != 7 )
          return v87;
LABEL_34:
        v23 = v92;
        v24 = v91;
        *(_WORD *)(v17 + 240) = -128;
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
        sub_100266F0(v90, (int)v23, a1, v24);
        return 6;
      }
      *(_WORD *)(v17 + 240) = -128;
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
      sub_100365D0((int)v96, (_BYTE *)(*(_DWORD *)(a1 + 56) + 69), 21);
      v25 = v94;
      if ( (unsigned int)v94 >= 0x14 )
        v25 = 20;
      v96[v25] = 0;
      v26 = *(_WORD *)(a2 + 8) & 0x3F;
      BYTE3(v89) = 0;
      if ( v26 != 50 && v26 != 51 )
      {
        v27 = v88;
        BYTE2(v89) = 0;
        v29 = j__atol(&v96[v88]);
      }
      else
      {
        v27 = v88;
        BYTE2(v89) = j__atol(&v96[v88]);
        v29 = 0;
      }
      v30 = *(_WORD *)(a2 + 8) & 0x3F;
      LOWORD(v89) = v29;
      if ( v30 != 49
        && v30 != 48
        && v30 != 47
        && v30 != 50
        && v30 != 51
        && v30 != 46
        && v30 != 56
        && v30 != 53
        && sub_10036D10(v28) == 1 )
      {
        if ( !v29 )
        {
          v29 = 12;
LABEL_54:
          LOWORD(v89) = v29;
          goto LABEL_55;
        }
        if ( v29 > 12 )
        {
          v29 -= 12;
          goto LABEL_54;
        }
      }
LABEL_55:
      v31 = v27 + 3;
      if ( word_1009CAD4[32 * v93] <= 99 )
        v31 = v27 + 2;
      v32 = v94;
      if ( v31 < v94 )
      {
        while ( 1 )
        {
          v33 = v96[v31];
          if ( (unsigned __int8)v33 >= 0x30u && (unsigned __int8)v33 <= 0x39u )
            break;
          if ( ++v31 >= v94 )
            goto LABEL_67;
        }
        if ( v31 < v94 )
        {
          v34 = *(_WORD *)(v91 + 8) & 0x3F;
          if ( v34 != 50 && v34 != 51 )
            BYTE2(v89) = j__atol(&v96[v31]);
          else
            BYTE3(v89) = j__atol(&v96[v31]);
        }
      }
LABEL_67:
      v35 = v31 + 2;
      if ( v35 < v32 )
      {
        while ( 1 )
        {
          v36 = v96[v35];
          if ( (unsigned __int8)v36 >= 0x30u && (unsigned __int8)v36 <= 0x39u )
            break;
          if ( ++v35 >= v32 )
            goto LABEL_74;
        }
        if ( v35 < v32 )
          BYTE3(v89) = j__atol(&v96[v35]);
      }
LABEL_74:
      if ( sub_10036D10(v28) == 1 )
      {
        v37 = *(_WORD *)(v91 + 8) & 0x3F;
        if ( v37 == 52 || v37 == 54 )
        {
          v38 = *(_DWORD *)(a1 + 56);
          v39 = *(_BYTE *)(v38 + 90);
          *(_BYTE *)(v38 + 90) = -108;
          if ( v29 )
            *(_BYTE *)(*(_DWORD *)(a1 + 56) + 90) = v39;
          v40 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 90);
          if ( v40 == -107 && v29 < 12 )
          {
            v29 += 12;
            LOWORD(v89) = v29;
          }
          if ( v40 == -108 && v29 == 12 )
            LOWORD(v89) = 0;
        }
      }
      sub_10039030(&v95, v89);
      v41 = v95;
      v42 = v90;
      *v90 = v95;
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 69) == 45 )
        *v42 = -v41;
      sub_100266F0(v42, (int)v92, a1, v91);
      return 3;
    case 0x8022:
    case 0x8078:
      if ( *(_BYTE *)(a1 + 3) && (v80 = *(_DWORD *)(a1 + 56), *(_WORD *)(v80 + 240) != -128) )
      {
        if ( v6 < 0 )
          v89 = -v6;
        v57 = v91;
        sub_10025590(v91, (int)&v89, v89);
        v58 = *(_WORD *)(v57 + 8) & 0x3F;
        LOBYTE(v88) = 31;
        if ( v58 != 52 && v58 != 54 )
        {
LABEL_192:
          if ( v58 == 56 )
            LOBYTE(v88) = 38;
        }
        else
        {
          v59 = *(_BYTE *)(v80 + 90);
LABEL_187:
          if ( v59 == -108 )
          {
            LOBYTE(v88) = 35;
          }
          else if ( v59 == -107 )
          {
            LOBYTE(v88) = 36;
          }
          else
          {
            sub_10025520((signed __int16 *)&v89, &v88);
          }
        }
        sprintf(v96, (const char *)(*(_DWORD *)(a1 + 56) + 69));
        v81 = v92;
        *(_WORD *)(a1 + 438) = *(_WORD *)v92;
        v82 = v88;
        *(_WORD *)(a1 + 436) = *((_WORD *)v81 + 1);
        v83 = (const char *)sub_10037710(v82);
        v84 = sub_100256B0(*(_DWORD *)(v57 + 4), *(_WORD *)(v57 + 8));
        v85 = *(_WORD *)(v57 + 10) - v84;
        if ( v84 > 0 )
          v85 -= *(_WORD *)(dword_10789604[5 * ((*(_DWORD *)(v57 + 4) >> 10) & 0xF)] + 28);
        if ( !*(_WORD *)(v57 + 10) )
          v85 = sub_100254C0(*(_DWORD *)(v57 + 4), *(_WORD *)(v57 + 8));
        sub_100039C0(a1, v96, v83, v85, v84, *(_DWORD *)(v57 + 4), *(_WORD *)(v57 + 8));
      }
      else
      {
        sub_100266F0(v90, (int)v92, a1, v91);
      }
      return v87;
    default:
      return v87;
  }
}
// 1009CAD4: using guessed type __int16 word_1009CAD4[];
// 10789604: using guessed type int dword_10789604[];
// 100267B0: using guessed type char var_1C[24];

//----- (100272B0) --------------------------------------------------------
char __usercall sub_100272B0@<al>(signed int *a1@<eax>, int a2@<edi>, int a3@<esi>)
{
  signed int v3; // eax@1
  signed int v4; // ecx@1
  const char *v5; // eax@3

  v3 = *a1;
  v4 = 0;
  if ( v3 < 0x7FFFFFFF )
    v4 = v3;
  v5 = "%+0*d";
  if ( !(*(_BYTE *)(a3 + 8) & 0x40) )
    v5 = "%0*d";
  sprintf((char *)(*(_DWORD *)(a2 + 56) + 69), v5, *(_BYTE *)(a3 + 10), v4);
  *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) = (char)(*(_BYTE *)(a3 + 10) - 1);
  return 4;
}

//----- (10027300) --------------------------------------------------------
char __cdecl sub_10027300(int a1)
{
  int v1; // ecx@0
  __int16 v2; // ax@1
  int v4; // [sp+0h] [bp-18h]@0
  char v5; // [sp+4h] [bp-14h]@1
  int v6; // [sp+8h] [bp-10h]@1
  __int16 v7; // [sp+Ch] [bp-Ch]@1
  char v8; // [sp+Eh] [bp-Ah]@1
  char v9; // [sp+Fh] [bp-9h]@1
  __int16 v10; // [sp+10h] [bp-8h]@1

  v6 = *(_DWORD *)(a1 + 4);
  v7 = *(_WORD *)(a1 + 8);
  v2 = *(_WORD *)(a1 + 12);
  v8 = *(_BYTE *)(a1 + 10);
  v9 = 0;
  v10 = v2;
  return sub_10028C60(v1, (int)&v5, v4);
}

//----- (10027360) --------------------------------------------------------
char __usercall sub_10027360@<al>(float *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  return sub_10028D30(a4, a2, a3, a1);
}

//----- (10027380) --------------------------------------------------------
char __usercall sub_10027380@<al>(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  int v3; // esi@1
  bool v4; // zf@1
  int v5; // edi@1
  char result; // al@1
  signed int v7; // ebp@1
  int v8; // ecx@4
  unsigned __int16 v9; // cx@8
  int v10; // ecx@10
  __int16 v11; // ax@10
  char v12; // al@13
  __int32 v13; // eax@19
  int v14; // eax@25
  int v15; // edx@30
  int v16; // edx@47
  int v17; // ecx@48
  int v18; // ecx@50
  char *v19; // [sp+Ch] [bp-8h]@1
  int v20; // [sp+10h] [bp-4h]@1

  v3 = a1;
  v4 = (*(_BYTE *)(a1 + 8) & 0x40) == 0;
  v5 = a2;
  result = 1;
  v7 = 1;
  v20 = 0;
  v19 = "%+0*d";
  if ( v4 )
    v19 = "%0*d";
  if ( *(_WORD *)(a3 + 10) == 84 )
  {
    v8 = *(_DWORD *)(a2 + 56);
    if ( *(_WORD *)(v8 + 240) == -128 || *(_BYTE *)(v8 + 69) != 45 )
      *(_WORD *)(a3 + 14) = 45;
    else
      *(_WORD *)(a3 + 14) = 43;
  }
  v9 = *(_WORD *)(a3 + 14);
  if ( v9 < 0x30u || v9 > 0x39u )
  {
    if ( v9 == 43 || v9 == 45 )
    {
      v15 = *(_DWORD *)(v3 + 16);
      if ( v15 < 0 && (v9 == 45 || v15 < 0 && *(_DWORD *)(v3 + 20) > 0 && v9 == 43) )
      {
        if ( *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) == -128 )
          sub_100272B0(&v20, v5, v3);
        if ( *(_WORD *)(a3 + 14) == 45 && j__atol((const char *)(*(_DWORD *)(v5 + 56) + 69)) >= 0
          || *(_WORD *)(a3 + 14) == 43 && j__atol((const char *)(*(_DWORD *)(v5 + 56) + 69)) <= 0 )
        {
          if ( *(_BYTE *)(v3 + 8) & 0x40 )
          {
            *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a3 + 14);
          }
          else if ( *(_WORD *)(a3 + 14) == 45 )
          {
            *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = 45;
          }
          else
          {
            *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = 48;
          }
        }
        result = 2;
      }
      v16 = *(_DWORD *)(v5 + 56);
      if ( !*(_WORD *)(v16 + 240) )
      {
        v17 = *(_DWORD *)(v5 + 56);
        if ( *(_BYTE *)(*(_WORD *)(v16 + 240) + v17 + 69) == 43 || *(_BYTE *)(*(_WORD *)(v17 + 240) + v17 + 69) == 45 )
        {
          ++*(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
          v18 = *(_BYTE *)(v3 + 10) - 1;
          if ( *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) < v18 )
            LOWORD(v18) = *(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
          *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)v18;
        }
      }
    }
  }
  else
  {
    v10 = *(_DWORD *)(v5 + 56);
    v11 = *(_WORD *)(v10 + 240);
    if ( v11 == -128 )
    {
      sub_100272B0(&v20, v5, v3);
      *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) + *(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a3 + 14);
      result = 2;
    }
    else if ( v11 == (char)(*(_BYTE *)(v3 + 10) - 1) )
    {
      v12 = *(_BYTE *)(v10 + 69);
      if ( v12 == 48 || (v12 == 43 || v12 == 45) && *(_BYTE *)(v10 + 70) == 48 )
      {
        if ( v12 == 45 )
        {
          *(_BYTE *)(v10 + 69) = 48;
          v7 = -1;
        }
        v13 = j__atol((const char *)(*(_DWORD *)(v5 + 56) + 69));
        sprintf((char *)(*(_DWORD *)(v5 + 56) + 69), v19, *(_BYTE *)(v3 + 10), 10 * v13);
        if ( v7 == -1 )
          *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = 45;
      }
      *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) + *(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a3 + 14);
      result = 2;
    }
    else
    {
      if ( *(_BYTE *)(v3 + 8) & 0x40 && !v11 )
        *(_WORD *)(v10 + 240) = 1;
      *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v5 + 56) + 240))++ + *(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a3 + 14);
      v14 = *(_BYTE *)(v3 + 10) - 1;
      if ( *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) < v14 )
        LOWORD(v14) = *(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
      *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)v14;
      result = 2;
    }
  }
  return result;
}

//----- (10027610) --------------------------------------------------------
char __cdecl sub_10027610(int a1, int a2, int a3, float *a4, int a5)
{
  int v5; // ebp@1
  char v6; // bl@1
  char result; // al@6
  signed int v8; // ecx@7
  int v9; // ecx@9
  int v10; // ecx@10
  __int16 v11; // si@12
  int v12; // edx@13
  int v13; // edx@13
  int v14; // ecx@15
  int v15; // eax@15
  int v16; // eax@18
  int v17; // esi@25
  int v18; // eax@26
  float *v19; // esi@27
  float v20; // ecx@27
  int v21; // edi@27
  int v22; // edx@27
  int v23; // ebx@29
  int v24; // eax@32
  int v25; // edx@32
  int v26; // edx@34
  float v27; // eax@38
  int v28; // eax@43
  int v29; // esi@45
  int v30; // edx@48
  int v31; // eax@48
  __int32 v32; // eax@51
  int v33; // eax@54
  float v34; // eax@59
  char v35; // al@66
  const void *v36; // [sp+18h] [bp+8h]@1

  v5 = a2;
  v6 = 1;
  v36 = (const void *)sub_10037720(*(_WORD *)(a2 + 8), 0);
  if ( *(_WORD *)a5 == 32802 )
    goto LABEL_4;
  if ( *(_WORD *)a5 != 32840 )
  {
    if ( *(_WORD *)a5 == 32888 )
    {
LABEL_4:
      if ( *(_BYTE *)(a1 + 3) && *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128 )
      {
        sub_10027300(v5);
        return 1;
      }
      sub_10027360(a4, v5, a3, a1);
    }
    return v6;
  }
  v8 = *(_WORD *)(a5 + 10);
  if ( v8 > 57 )
  {
    if ( v8 == 84 || v8 == 0x2000 )
    {
      v35 = sub_10027380(v5, a1, a5);
      v6 = v35;
      if ( v35 == 3 )
      {
        sub_10027360(a4, v5, a3, a1);
        return v6;
      }
      if ( v35 == 2 )
      {
        sub_10027300(v5);
        return 2;
      }
    }
    return v6;
  }
  if ( v8 == 57 )
    goto LABEL_74;
  v9 = v8 - 32;
  if ( !v9 )
  {
    v28 = *(_DWORD *)(a1 + 56);
    if ( *(_WORD *)(v28 + 240) != -128 )
    {
      *(_WORD *)(v28 + 240) = -128;
      sub_10027360(a4, v5, a3, a1);
      return 3;
    }
    return v6;
  }
  v10 = v9 - 1;
  if ( v10 )
  {
    if ( v10 != 23 )
      return v6;
    v11 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
    if ( v11 == -128 )
    {
      v18 = *(_BYTE *)(a5 + 8);
      if ( *(_BYTE *)(v5 + 26) )
      {
        v19 = a4;
        v20 = *a4;
        v21 = v18 * *(_WORD *)(v5 + 24) + *(_DWORD *)a4;
        v22 = *(_DWORD *)(v5 + 20);
        if ( v21 <= v22 )
        {
          v23 = *(_DWORD *)(v5 + 16);
          if ( v21 >= v23 )
            *(_DWORD *)a4 = v21;
          else
            *(_DWORD *)a4 = LODWORD(v20) + v22 + *(_WORD *)(v5 + 24) * (v18 + 1) - v23;
        }
        else
        {
          *(_DWORD *)a4 = LODWORD(v20) + *(_DWORD *)(v5 + 16) + *(_WORD *)(v5 + 24) * (v18 - 1) - v22;
        }
      }
      else
      {
        v24 = *(_DWORD *)a4 + *(_WORD *)(v5 + 24) * v18;
        v25 = *(_DWORD *)(v5 + 20);
        if ( v24 <= v25 )
        {
          v26 = *(_DWORD *)(v5 + 16);
          if ( v24 >= v26 )
            *(_DWORD *)a4 = v24;
          else
            *(_DWORD *)a4 = v26;
        }
        else
        {
          *(_DWORD *)a4 = v25;
        }
        v19 = a4;
      }
      v27 = *v19;
      if ( *(_DWORD *)(v5 + 16) > *(_DWORD *)v19 )
        v27 = *(float *)(v5 + 16);
      *v19 = v27;
      if ( *(_DWORD *)(v5 + 20) < SLODWORD(v27) )
        v27 = *(float *)(v5 + 20);
      *v19 = v27;
      *(_DWORD *)v19 = sub_10022C20(SLODWORD(v27), *(_WORD *)(v5 + 24));
      sub_10027360(v19, v5, a3, a1);
      result = 3;
    }
    else
    {
      v12 = *(_BYTE *)(a5 + 8) < 0;
      LOBYTE(v12) = *(_BYTE *)(a5 + 8) >= 0;
      v13 = 2 * v12 - 1;
      if ( !(*(_BYTE *)(v5 + 8) & 0x40) || v11 )
      {
        v16 = *(_DWORD *)(a1 + 56);
        if ( (*(_BYTE *)(*(_WORD *)(v16 + 240) + v16 + 69) != 48 || v13 >= 0)
          && (*(_BYTE *)(*(_WORD *)(v16 + 240) + v16 + 69) != 57 || v13 <= 0)
          || v11
          || *(_DWORD *)(v5 + 16) >= 0 )
        {
          v17 = *(_DWORD *)(a1 + 56);
          *(_BYTE *)(*(_WORD *)(v17 + 240) + v17 + 69) = sub_10038B70(
                                                           *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240)
                                                                    + *(_DWORD *)(a1 + 56)
                                                                    + 69),
                                                           0x10u,
                                                           v13);
          sub_10027300(v5);
          result = 2;
        }
        else
        {
          *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) = 45;
          sub_10027300(v5);
          result = 2;
        }
      }
      else
      {
        v14 = *(_DWORD *)(a1 + 56);
        v15 = *(_WORD *)(v14 + 240);
        if ( *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) == 45 )
        {
          *(_BYTE *)(v15 + v14 + 69) = 43;
          sub_10027300(v5);
          result = 2;
        }
        else
        {
          *(_BYTE *)(v15 + v14 + 69) = 45;
          sub_10027300(v5);
          result = 2;
        }
      }
    }
  }
  else
  {
LABEL_74:
    v29 = *(_DWORD *)(a1 + 56);
    if ( *(_WORD *)(v29 + 240) == -128 )
      return v6;
    if ( *(_WORD *)(a5 + 10) != 57 || *(_BYTE *)(v5 + 10) <= 1u )
    {
      *(_WORD *)(v29 + 240) = -128;
      v32 = j__atol((const char *)(*(_DWORD *)(a1 + 56) + 69));
      *(_DWORD *)a4 = v32;
      if ( !memcmp(v36, "", 2u) && !v32 || v32 == 360 )
      {
        v33 = *(_DWORD *)(v5 + 16);
        if ( *(_DWORD *)(v5 + 20) - v33 == 359 )
        {
          if ( !v33 )
            *(_DWORD *)a4 = 0;
          if ( *(_DWORD *)(v5 + 20) == 360 )
            *(_DWORD *)a4 = 360;
        }
      }
      v34 = *a4;
      if ( *(_DWORD *)(v5 + 16) > *(_DWORD *)a4 )
        v34 = *(float *)(v5 + 16);
      *a4 = v34;
      if ( *(_DWORD *)(v5 + 20) < SLODWORD(v34) )
        v34 = *(float *)(v5 + 20);
      *a4 = v34;
      *(_DWORD *)a4 = sub_10022C20(SLODWORD(v34), *(_WORD *)(v5 + 24));
      sub_10027360(a4, v5, a3, a1);
      result = 3;
    }
    else
    {
      *(_WORD *)(v29 + 240) += *(_BYTE *)(a5 + 8);
      v30 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
      *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = (char)(v30 <= 0 ? 0 : v30);
      v31 = *(_BYTE *)(v5 + 10) - 1;
      if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v31 )
        LOWORD(v31) = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
      *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = (char)v31;
      sub_10027300(v5);
      result = 2;
    }
  }
  return result;
}

//----- (10027AA0) --------------------------------------------------------
double __cdecl sub_10027AA0(float a1, float a2)
{
  double result; // st7@1

  result = a1;
  if ( a2 >= (double)a1 )
    result = a2;
  return result;
}

//----- (10027AC0) --------------------------------------------------------
double __cdecl sub_10027AC0(float a1, float a2)
{
  double result; // st7@1

  result = a1;
  if ( a2 <= (double)a1 )
    result = a2;
  return result;
}

//----- (10027AE0) --------------------------------------------------------
signed int __fastcall sub_10027AE0(int a1)
{
  signed int result; // eax@1

  result = 1;
  if ( a1 > 0 )
  {
    do
    {
      result *= 10;
      --a1;
    }
    while ( a1 );
  }
  return result;
}

//----- (10027B00) --------------------------------------------------------
char __usercall sub_10027B00@<al>(int a1@<eax>, float *a2@<edi>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  const char *v5; // eax@7
  int v6; // eax@9
  char result; // al@10
  int v8; // [sp+14h] [bp+4h]@1

  v3 = a3;
  *(float *)&v8 = 0.0;
  v4 = a1;
  if ( *a2 < 1.0e25 && *a2 > -1.0e25 && 9.8999998e24 != *a2 )
    v8 = *(int *)a2;
  if ( (*(_WORD *)(a1 + 8) & 0x3F) != 16 )
    *(float *)&v8 = sub_10040160(v8, *(_WORD *)(a1 + 8));
  v5 = "%+0*.*f";
  if ( !(*(_BYTE *)(v4 + 8) & 0x40) )
    v5 = "%0*.*f";
  sprintf((char *)(*(_DWORD *)(v3 + 56) + 69), v5, *(_BYTE *)(v4 + 10), *(_BYTE *)(v4 + 11), v8);
  v6 = *(_DWORD *)(v3 + 56);
  if ( *(_BYTE *)(v4 + 11) )
  {
    *(_WORD *)(*(_DWORD *)(v3 + 56) + 240) = (char)(strlen((const char *)(v6 + 69))
                                                  - strlen(strchr((const char *)(v6 + 69), 46)))
                                           - 1;
    result = 4;
  }
  else
  {
    *(_WORD *)(v6 + 240) = (char)(*(_BYTE *)(v4 + 10) - 1);
    result = 4;
  }
  return result;
}

//----- (10027C10) --------------------------------------------------------
char __cdecl sub_10027C10(int a1)
{
  int v1; // ecx@0
  __int16 v2; // ax@1
  int v4; // [sp+0h] [bp-18h]@0
  char v5; // [sp+4h] [bp-14h]@1
  int v6; // [sp+8h] [bp-10h]@1
  __int16 v7; // [sp+Ch] [bp-Ch]@1
  char v8; // [sp+Eh] [bp-Ah]@1
  char v9; // [sp+Fh] [bp-9h]@1
  __int16 v10; // [sp+10h] [bp-8h]@1

  v6 = *(_DWORD *)(a1 + 4);
  v7 = *(_WORD *)(a1 + 8) | 0x100;
  v8 = *(_BYTE *)(a1 + 10);
  v2 = *(_WORD *)(a1 + 12);
  v9 = *(_BYTE *)(a1 + 11);
  v10 = v2;
  return sub_10028C60(v1, (int)&v5, v4);
}

//----- (10027C70) --------------------------------------------------------
char __usercall sub_10027C70@<al>(int a1@<ecx>, float *a2@<edi>, int a3@<esi>, int a4)
{
  int v4; // edx@1
  __int16 v5; // ax@1
  double v7; // [sp+0h] [bp-1Ch]@1
  int v8; // [sp+8h] [bp-14h]@1
  int v9; // [sp+Ch] [bp-10h]@1
  __int16 v10; // [sp+10h] [bp-Ch]@1
  char v11; // [sp+12h] [bp-Ah]@1
  char v12; // [sp+13h] [bp-9h]@1
  __int16 v13; // [sp+14h] [bp-8h]@1

  v4 = *(_DWORD *)(a4 + 4);
  v7 = *a2;
  v9 = v4;
  v10 = *(_WORD *)(a4 + 8);
  v11 = *(_BYTE *)(a4 + 10);
  v5 = *(_WORD *)(a4 + 12);
  v12 = *(_BYTE *)(a4 + 11);
  v13 = v5;
  v8 = 89;
  return sub_10031980(a1, (int)&v8, a3, &v7);
}

//----- (10027CE0) --------------------------------------------------------
int __cdecl sub_10027CE0(float a1)
{
  int v1; // ecx@0
  double v2; // ST04_8@1

  v2 = (double)sub_10027AE0(v1) * a1;
  return (signed int)((double)sub_10022CE0(a1) * 0.5 + v2);
}

//----- (10027D20) --------------------------------------------------------
char __usercall sub_10027D20@<al>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // ebp@1
  int v5; // esi@1
  int v6; // eax@4
  unsigned __int16 v7; // cx@8
  int v8; // ecx@10
  __int16 v9; // di@10
  bool v11; // zf@12
  const char *v12; // ecx@13
  char v13; // kr00_1@13
  char *v14; // eax@13
  char v15; // dl@13
  char v16; // cl@14
  char v17; // al@19
  bool v18; // sf@25
  char *v19; // eax@26
  int v20; // edi@26
  char v21; // dl@27
  char v22; // bl@28
  char *v23; // eax@28
  char v24; // dl@28
  char v25; // cl@29
  double v26; // st7@30
  int v27; // edx@34
  unsigned __int8 v28; // al@34
  const char *v29; // ecx@34
  char *v30; // eax@38
  char v31; // di@38
  char v32; // dl@39
  int v33; // edx@44
  int v34; // eax@44
  int v35; // ecx@67
  int v36; // edx@70
  int v37; // eax@70
  const char *v38; // ecx@77
  char *v39; // eax@77
  int v40; // edi@77
  char v41; // dl@78
  float v42; // [sp+18h] [bp-Ch]@1
  char *v43; // [sp+1Ch] [bp-8h]@1
  int v44; // [sp+20h] [bp-4h]@1
  char v45; // [sp+28h] [bp+4h]@1
  __int32 v46; // [sp+28h] [bp+4h]@25
  float v47; // [sp+28h] [bp+4h]@30

  v3 = a3;
  v42 = 0.0;
  v4 = a2;
  v11 = (*(_BYTE *)(a2 + 8) & 0x40) == 0;
  v5 = a1;
  v45 = 1;
  v44 = 1;
  v43 = "%+0*.*f";
  if ( v11 )
    v43 = "%0*.*f";
  if ( *(_WORD *)(a3 + 10) == 84 )
  {
    v6 = *(_DWORD *)(a1 + 56);
    if ( *(_WORD *)(v6 + 240) == -128 || *(_BYTE *)(v6 + 69) != 45 )
      *(_WORD *)(a3 + 14) = 45;
    else
      *(_WORD *)(a3 + 14) = 43;
  }
  v7 = *(_WORD *)(a3 + 14);
  if ( v7 >= 0x30u && v7 <= 0x39u )
  {
    v8 = *(_DWORD *)(v5 + 56);
    v9 = *(_WORD *)(v8 + 240);
    if ( v9 == -128 )
    {
      sub_10027B00(v4, &v42, v5);
      *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) + *(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a3 + 14);
      return 2;
    }
    v11 = *(_BYTE *)(v4 + 11) == 0;
    if ( *(_BYTE *)(v4 + 11) > 0 )
    {
      v12 = (const char *)(v8 + 69);
      v13 = strlen(v12);
      v14 = strchr(v12, 46);
      v15 = (_BYTE)v14 + 1;
      do
        v16 = *v14++;
      while ( v16 );
      v8 = *(_DWORD *)(v5 + 56);
      v9 = *(_WORD *)(v8 + 240);
      v3 = a3;
      if ( *(_WORD *)(v8 + 240) == (char)(v13 - ((_BYTE)v14 - v15)) - 1 )
        goto LABEL_19;
      v11 = *(_BYTE *)(v4 + 11) == 0;
    }
    if ( !v11 || v9 != (char)(*(_BYTE *)(v4 + 10) - 1) )
    {
      if ( *(_BYTE *)(v4 + 8) & 0x40 && !v9 )
        *(_WORD *)(v8 + 240) = 1;
      *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v5 + 56) + 240))++ + *(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(v3 + 14);
      v33 = *(_DWORD *)(v5 + 56);
      v34 = *(_BYTE *)(v4 + 10) - 1;
      if ( *(_WORD *)(v33 + 240) < v34 )
        LOWORD(v34) = *(_WORD *)(v33 + 240);
      *(_WORD *)(v33 + 240) = (char)v34;
      return 2;
    }
LABEL_19:
    v17 = *(_BYTE *)(v8 + 69);
    if ( v17 == 48 || (v17 == 43 || v17 == 45) && *(_BYTE *)(v8 + 70) == 48 )
    {
      if ( v17 == 45 )
      {
        *(_BYTE *)(v8 + 69) = 48;
        v44 = -1;
      }
      v46 = j__atol((const char *)(*(_DWORD *)(v5 + 56) + 69));
      v11 = *(_BYTE *)(v4 + 11) == 0;
      v18 = *(_BYTE *)(v4 + 11) < 0;
      v42 = (double)v46 * 10.0;
      if ( !v18 && !v11 )
      {
        v19 = (char *)(*(_DWORD *)(v5 + 56) + 69);
        v20 = *(_DWORD *)(v5 + 56) + 70;
        do
          v21 = *v19++;
        while ( v21 );
        v22 = (_BYTE)v19 - v20;
        v23 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 46);
        v24 = (_BYTE)v23 + 1;
        do
          v25 = *v23++;
        while ( v25 );
        v26 = atof((const char *)((char)(v22 - ((_BYTE)v23 - v24)) + *(_DWORD *)(v5 + 56) + 69));
        v3 = a3;
        v47 = v26;
        v42 = v47 + v42;
      }
      sprintf((char *)(*(_DWORD *)(v5 + 56) + 69), v43, *(_BYTE *)(v4 + 10), *(_BYTE *)(v4 + 11), v42);
      if ( v44 == -1 )
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = 45;
    }
    *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) + *(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(v3 + 14);
    if ( *(_BYTE *)(v4 + 11) > 0 )
    {
      v27 = *(_DWORD *)(v5 + 56);
      v28 = *(_BYTE *)(v27 + 69);
      v29 = (const char *)(v27 + 69);
      if ( v28 > 0x30u || (v28 == 43 || v28 == 45) && *(_BYTE *)(v27 + 70) != 48 )
      {
        v30 = (char *)(v27 + 69);
        v31 = v27 + 70;
        do
          v32 = *v30++;
        while ( v32 );
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)((_BYTE)v30 - v31 - strlen(strchr(v29, 46))) + 1;
        return 2;
      }
    }
    return 2;
  }
  if ( v7 != 43 && v7 != 45 )
  {
    if ( v7 == 46 && *(_BYTE *)(v4 + 11) > 0 )
    {
      if ( *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) == -128 )
        sub_10027B00(v4, &v42, v5);
      v38 = (const char *)(*(_DWORD *)(v5 + 56) + 69);
      v39 = (char *)(*(_DWORD *)(v5 + 56) + 69);
      v40 = *(_DWORD *)(v5 + 56) + 70;
      do
        v41 = *v39++;
      while ( v41 );
      *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)((_BYTE)v39 - v40 - strlen(strchr(v38, 46))) + 1;
    }
    return v45;
  }
  if ( *(float *)(v4 + 16) < 0.0 && v7 == 45 || *(float *)(v4 + 16) < 0.0 && *(float *)(v4 + 20) > 0.0 && v7 == 43 )
  {
    if ( *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) == -128 )
      sub_10027B00(v4, &v42, v5);
    if ( *(_WORD *)(a3 + 14) == 45 && atof((const char *)(*(_DWORD *)(v5 + 56) + 69)) >= 0.0
      || *(_WORD *)(a3 + 14) == 43 && atof((const char *)(*(_DWORD *)(v5 + 56) + 69)) <= 0.0 )
    {
      if ( *(_BYTE *)(v4 + 8) & 0x40 )
      {
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a3 + 14);
        v45 = 2;
        goto LABEL_67;
      }
      if ( *(_WORD *)(a3 + 14) == 45 )
      {
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = 45;
        v45 = 2;
        goto LABEL_67;
      }
      *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = 48;
    }
    v45 = 2;
  }
LABEL_67:
  v35 = *(_DWORD *)(v5 + 56);
  if ( *(_WORD *)(v35 + 240)
    || *(_BYTE *)(*(_WORD *)(v35 + 240) + v35 + 69) != 43
    && *(_BYTE *)(*(_WORD *)(v35 + 240) + *(_DWORD *)(v5 + 56) + 69) != 45 )
  {
    return v45;
  }
  ++*(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
  v36 = *(_DWORD *)(v5 + 56);
  v37 = *(_BYTE *)(v4 + 10) - 1;
  if ( *(_WORD *)(v36 + 240) < v37 )
    LOWORD(v37) = *(_WORD *)(v36 + 240);
  *(_WORD *)(v36 + 240) = (char)v37;
  return v45;
}

//----- (100281F0) --------------------------------------------------------
char __cdecl sub_100281F0(int a1, int a2, int *a3, float *a4, int a5)
{
  int v5; // esi@1
  __int16 v6; // ax@1
  int v7; // edi@1
  int v8; // ebp@1
  char result; // al@8
  float *v10; // edi@9
  signed int v11; // eax@9
  int v12; // eax@11
  int v13; // eax@12
  int v14; // ebp@14
  int v15; // eax@14
  __int16 v16; // cx@14
  double v17; // st7@16
  double v18; // st7@23
  int v19; // ebx@30
  int v20; // ecx@31
  int v21; // eax@31
  int v22; // ecx@31
  int v23; // eax@31
  int v24; // ecx@31
  int v25; // ebx@31
  int v26; // eax@31
  int v27; // ecx@31
  int v28; // eax@31
  double v29; // st7@34
  float v30; // ST0C_4@43
  double v31; // st7@43
  int v32; // ST08_4@44
  int v33; // ecx@44
  int v34; // eax@45
  int v35; // eax@47
  int v36; // edx@50
  int v37; // eax@50
  int v38; // eax@52
  float v39; // ST0C_4@55
  float v40; // [sp+4h] [bp-20h]@43
  float v41; // [sp+18h] [bp-Ch]@1
  float v42; // [sp+1Ch] [bp-8h]@1
  int v43; // [sp+20h] [bp-4h]@31
  char v44; // [sp+2Ch] [bp+8h]@1
  float v45; // [sp+2Ch] [bp+8h]@23
  float v46; // [sp+2Ch] [bp+8h]@31
  float v47; // [sp+2Ch] [bp+8h]@43
  float v48; // [sp+2Ch] [bp+8h]@43
  float v49; // [sp+2Ch] [bp+8h]@55
  float v50; // [sp+2Ch] [bp+8h]@55
  float v51; // [sp+2Ch] [bp+8h]@55
  int v52; // [sp+38h] [bp+14h]@31

  v5 = a2;
  v41 = sub_10040160(COERCE_INT(*(float *)(a2 + 16)), *(_WORD *)(a2 + 8));
  v42 = sub_10040160(COERCE_INT(*(float *)(v5 + 20)), *(_WORD *)(v5 + 8));
  v6 = *(_WORD *)(a2 + 12);
  v7 = 0;
  v44 = 1;
  v8 = v6;
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      if ( !v6 )
        v8 = sub_10031920(*(_DWORD *)(v5 + 4), *(_WORD *)(v5 + 8), *(_BYTE *)(v5 + 10), *(_BYTE *)(v5 + 11));
      if ( ~((unsigned int)*(_WORD *)(v5 + 8) >> 9) & 1 )
      {
        v7 = (signed __int16)sub_100034E0(*(_DWORD *)(v5 + 4), *(_WORD *)(v5 + 8), a4);
        if ( (*(_DWORD *)(v5 + 4) & 0xC000) != 0x4000 )
        {
          v8 -= v7;
          if ( v7 > 0 )
            v8 -= *(_WORD *)(dword_10789604[5 * ((*(_DWORD *)(v5 + 4) >> 10) & 0xF)] + 28);
        }
      }
      sub_10003860(a1 + 276, *a3, *(_DWORD *)(v5 + 4), v8 + v7);
      return 2;
    case 0x8048:
      v10 = a4;
      v11 = *(_WORD *)(a5 + 10);
      if ( v11 > 57 )
      {
        if ( v11 != 84 && v11 != 0x2000 )
          return v44;
        v44 = sub_10027D20(a1, v5, a5);
        if ( v44 != 3 )
        {
          if ( v44 == 2 )
          {
            sub_10027C10(v5);
            return 2;
          }
          return v44;
        }
        v33 = a1;
        goto LABEL_66;
      }
      if ( v11 == 57 )
        goto LABEL_47;
      v12 = v11 - 32;
      if ( !v12 )
      {
        v34 = *(_DWORD *)(a1 + 56);
        if ( *(_WORD *)(v34 + 240) == -128 )
          return v44;
        *(_WORD *)(v34 + 240) = -128;
        v44 = 3;
        v33 = a1;
LABEL_66:
        sub_10027C70(v33, v10, (int)a3, v5);
        return v44;
      }
      v13 = v12 - 1;
      if ( v13 )
      {
        if ( v13 != 23 )
          return v44;
        v14 = a1;
        v15 = *(_DWORD *)(a1 + 56);
        v16 = *(_WORD *)(v15 + 240);
        if ( v16 != -128 )
        {
          if ( *(_BYTE *)(a5 + 8) >= 0 )
            v17 = 1.0;
          else
            v17 = -1.0;
          if ( !(*(_BYTE *)(v5 + 8) & 0x40) || v16 )
          {
            v45 = v17;
            v18 = v45;
            if ( (*(_BYTE *)(*(_WORD *)(v15 + 240) + v15 + 69) != 48 || v18 >= 0.0)
              && (*(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) != 57 || v18 <= 0.0)
              || v16
              || *(float *)(v5 + 16) >= 0.0 )
            {
              v19 = *(_DWORD *)(a1 + 56);
              *(_BYTE *)(*(_WORD *)(v19 + 240) + v19 + 69) = sub_10038B70(
                                                               *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240)
                                                                        + *(_DWORD *)(a1 + 56)
                                                                        + 69),
                                                               0x10u,
                                                               (signed int)v18);
              sub_10027C10(v5);
              result = 2;
            }
            else
            {
              *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) = 45;
              sub_10027C10(v5);
              result = 2;
            }
          }
          else if ( *(_BYTE *)(*(_WORD *)(v15 + 240) + v15 + 69) == 45 )
          {
            *(_BYTE *)(*(_WORD *)(v15 + 240) + v15 + 69) = 43;
            sub_10027C10(v5);
            result = 2;
          }
          else
          {
            *(_BYTE *)(*(_WORD *)(v15 + 240) + v15 + 69) = 45;
            sub_10027C10(v5);
            result = 2;
          }
          return result;
        }
        *a4 = sub_10040160(COERCE_INT(*a4), *(_WORD *)(v5 + 8));
        v20 = *(_BYTE *)(v5 + 11);
        v46 = (double)*(_BYTE *)(a5 + 8) * *(float *)(v5 + 24);
        v21 = sub_10027CE0(v46);
        v22 = *(_BYTE *)(v5 + 11);
        v52 = v21;
        v23 = sub_10027CE0(*a4);
        v24 = *(_BYTE *)(v5 + 11);
        v25 = v23;
        v26 = sub_10027CE0(v42);
        v27 = *(_BYTE *)(v5 + 11);
        v43 = v26;
        v28 = sub_10027CE0(v41);
        if ( *(_BYTE *)(v5 + 28) )
        {
          if ( v25 + v52 > v43 )
          {
            if ( v25 != v43 )
            {
              v29 = *a4 + v46 - (v42 - v41);
              goto LABEL_43;
            }
LABEL_34:
            v29 = v41;
LABEL_43:
            *a4 = v29;
            v30 = sub_10027AA0(v41, *a4);
            v47 = sub_10027AC0(v42, v30);
            *a4 = v47;
            v48 = sub_10022C70(v47, *(float *)(v5 + 24));
            v31 = v48;
            *a4 = v48;
            LODWORD(v40) = *(_WORD *)(v5 + 8);
LABEL_44:
            *(float *)&v32 = v31;
            *a4 = sub_10040790(v32, LODWORD(v40));
            v44 = 3;
            v33 = v14;
            goto LABEL_66;
          }
          if ( v25 + v52 < v28 )
          {
            if ( v25 != v28 )
            {
              v29 = *a4 + v46 + v42 - v41;
              goto LABEL_43;
            }
            goto LABEL_38;
          }
        }
        else
        {
          if ( v25 + v52 > v43 )
          {
LABEL_38:
            v29 = v42;
            goto LABEL_43;
          }
          if ( v25 + v52 < v28 )
            goto LABEL_34;
        }
        v29 = *a4 + v46;
        goto LABEL_43;
      }
LABEL_47:
      v14 = a1;
      v35 = *(_DWORD *)(a1 + 56);
      if ( *(_WORD *)(v35 + 240) == -128 )
        return v44;
      if ( *(_WORD *)(a5 + 10) != 57 || *(_BYTE *)(v5 + 10) <= 1u )
      {
        *(_WORD *)(v35 + 240) = -128;
        v49 = atof((const char *)(*(_DWORD *)(a1 + 56) + 69));
        v39 = sub_10027AA0(v41, v49);
        v50 = sub_10027AC0(v42, v39);
        *a4 = v50;
        v51 = sub_10022C70(v50, *(float *)(v5 + 24));
        v31 = v51;
        *a4 = v51;
        LODWORD(v40) = *(_WORD *)(v5 + 8);
        goto LABEL_44;
      }
      *(_WORD *)(v35 + 240) += *(_BYTE *)(a5 + 8);
      *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = (char)((signed int)*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) <= 0 ? 0 : *(_WORD *)(*(_DWORD *)(a1 + 56) + 240));
      v36 = *(_DWORD *)(a1 + 56);
      v37 = *(_BYTE *)(v5 + 10) - 1;
      if ( *(_WORD *)(v36 + 240) < v37 )
        LOWORD(v37) = *(_WORD *)(v36 + 240);
      *(_WORD *)(v36 + 240) = (char)v37;
      v38 = *(_DWORD *)(a1 + 56);
      if ( *(_BYTE *)(*(_WORD *)(v38 + 240) + v38 + 69) == 46 )
        *(_WORD *)(v38 + 240) += *(_BYTE *)(a5 + 8);
      sub_10027C10(v5);
      return 2;
    case 0x8022:
    case 0x8078:
      v33 = a1;
      if ( *(_BYTE *)(a1 + 3) && *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128 )
      {
        sub_10027C10(v5);
        return 1;
      }
      v10 = a4;
      goto LABEL_66;
    default:
      return v44;
  }
}
// 10789604: using guessed type int dword_10789604[];

//----- (10028840) --------------------------------------------------------
int __usercall sub_10028840@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  int v4; // esi@1
  __int16 v5; // di@2
  __int16 v6; // cx@2
  signed __int16 v7; // ax@2
  int v8; // ebp@2
  int v9; // ebx@2
  __int16 v10; // ax@2
  __int16 v11; // cx@2
  int v12; // ebp@2
  signed __int16 v13; // bx@2
  int v14; // eax@2
  signed __int16 v15; // ax@2
  __int16 v16; // dx@4
  __int16 v17; // ax@4
  int v18; // eax@4
  int v19; // ebx@4
  __int16 v20; // ST7C_2@13
  int v21; // edx@13
  int v22; // ST70_4@13
  __int16 v23; // ax@14
  __int16 v24; // ax@17
  int result; // eax@19
  char v26; // [sp+Ah] [bp-72h]@1
  bool v27; // [sp+Bh] [bp-71h]@4
  int v28; // [sp+Ch] [bp-70h]@2
  __int16 v29; // [sp+Ch] [bp-70h]@4
  __int16 v30; // [sp+Ch] [bp-70h]@13
  __int16 v31; // [sp+14h] [bp-68h]@4
  signed __int16 v32; // [sp+18h] [bp-64h]@4
  __int16 v33; // [sp+18h] [bp-64h]@13
  __int16 v34; // [sp+1Ch] [bp-60h]@2
  int v35; // [sp+20h] [bp-5Ch]@2
  __int16 v36; // [sp+24h] [bp-58h]@2
  __int16 v37; // [sp+26h] [bp-56h]@2
  __int16 v38; // [sp+28h] [bp-54h]@2
  __int16 v39; // [sp+2Ah] [bp-52h]@2
  __int16 v40; // [sp+2Ch] [bp-50h]@2
  __int16 v41; // [sp+2Eh] [bp-4Eh]@2
  __int16 v42; // [sp+30h] [bp-4Ch]@2
  __int16 v43; // [sp+32h] [bp-4Ah]@2
  __int16 v44; // [sp+34h] [bp-48h]@2
  __int16 v45; // [sp+36h] [bp-46h]@2
  __int16 v46; // [sp+38h] [bp-44h]@2
  __int16 v47; // [sp+3Ah] [bp-42h]@2
  __int16 v48; // [sp+3Ch] [bp-40h]@2
  __int16 v49; // [sp+3Eh] [bp-3Eh]@2
  __int16 v50; // [sp+40h] [bp-3Ch]@2
  __int16 v51; // [sp+42h] [bp-3Ah]@2
  char v52; // [sp+44h] [bp-38h]@16

  v4 = a3;
  v26 = 0;
  if ( *(_WORD *)a4 <= *(_WORD *)(a4 + 2) )
  {
    *(_WORD *)(a3 + 440) = word_1065DED0[15];
    *(_WORD *)(a3 + 442) = word_1065DED0[15];
    result = sub_1001F350(a3 + 392, *(_WORD *)a1, *(_WORD *)(a1 + 2), *(_WORD *)(a2 + 4), *(_WORD *)(a2 + 6));
  }
  else
  {
    v5 = *(_WORD *)a1;
    v6 = *(_WORD *)(a1 + 2);
    v7 = *(_WORD *)(a2 + 4);
    v34 = v7;
    v8 = *(_WORD *)(a2 + 6);
    v9 = (unsigned __int16)((v7 + 1) / 2);
    v38 = v7 + v5 - 1;
    v10 = v5 + v7 / 2;
    v40 = v10;
    v48 = v10;
    v37 = v9 + v6 - 1;
    v39 = v9 + v6 - 1;
    v43 = v9 + v6 - 1;
    v45 = v6 + v8 - v9;
    v47 = v6 + v8 - v9;
    v51 = v6 + v8 - v9;
    v46 = v38;
    v49 = v6 + v8 - 1;
    v41 = v6;
    v11 = v9 + v6 + 1;
    v12 = -2 - 2 * v9 + v8;
    v13 = *(_WORD *)a4;
    v14 = (signed __int16)v12 - 2;
    v28 = v14;
    v35 = *(_WORD *)(a4 + 2);
    v15 = v35 * v14 / *(_WORD *)a4;
    v36 = v5;
    v42 = v5;
    v44 = v5;
    v50 = v5;
    if ( v15 <= 3 )
      v15 = 3;
    v32 = v15;
    v16 = v12 - v15 + v11 - 1;
    v17 = *(_WORD *)(a4 + 4);
    v31 = v17;
    v29 = (unsigned int)(v28 * v17 / (unsigned __int16)v13) + v11 + 1;
    v18 = v11 + 1;
    v27 = v29 == v18;
    v19 = (unsigned __int16)v13 - v35;
    if ( v31 >= v19 || v29 > v16 )
    {
      v29 = v16;
      v26 = 1;
    }
    if ( v31 >= v19 || v29 != v16 )
    {
      if ( v31 > 0 && v29 == v18 )
      {
        v29 = v11 + 2;
        v27 = 0;
      }
    }
    else
    {
      v29 = v16 - 1;
      v26 = 0;
    }
    v33 = v32 + 2;
    v20 = *(_WORD *)(v4 + 398);
    v21 = *(_DWORD *)(v4 + 452);
    v30 = v29 - 1;
    *(_WORD *)(v4 + 398) = 1;
    *(_DWORD *)(v4 + 452) = &unk_10091E38;
    v22 = v21;
    *(_WORD *)(v4 + 440) = word_1065DED0[15];
    *(_WORD *)(v4 + 442) = word_1065DED0[14];
    sub_1001F350(v4 + 392, v5, v11, v34, v12);
    *(_WORD *)(v4 + 398) = v20;
    *(_DWORD *)(v4 + 452) = v22;
    if ( v27 )
      v23 = word_1065DED0[0];
    else
      v23 = word_1065DED0[14];
    *(_WORD *)(v4 + 440) = v23;
    *(_WORD *)(v4 + 442) = v23;
    *(_WORD *)(v4 + 428) = v23;
    *(_WORD *)(v4 + 430) = v23;
    sub_10081460(v4 + 392, 4, (int)&v36, 0);
    sub_100818F0(v4 + 392, 3, (int)&v36, 56, (int)&v52);
    if ( v26 )
      v24 = word_1065DED0[0];
    else
      v24 = word_1065DED0[14];
    *(_WORD *)(v4 + 440) = v24;
    *(_WORD *)(v4 + 442) = v24;
    *(_WORD *)(v4 + 428) = v24;
    *(_WORD *)(v4 + 430) = v24;
    sub_10081460(v4 + 392, 4, (int)&v44, 0);
    sub_100818F0(v4 + 392, 3, (int)&v44, 56, (int)&v52);
    *(_WORD *)(v4 + 428) = word_1065DED0[0];
    *(_WORD *)(v4 + 430) = word_1065DED0[1];
    sub_1001EC10(v4 + 392, v5, v30, v34, v33, 2);
    *(_WORD *)(v4 + 428) = word_1065DED0[15];
    *(_WORD *)(v4 + 430) = word_1065DED0[0];
    *(_WORD *)(v4 + 440) = word_1065DED0[14];
    *(_WORD *)(v4 + 442) = word_1065DED0[14];
    result = sub_1001EC10(v4 + 392, v5 + 1, v30 + 1, v34 - 2, v33 - 2, 3);
  }
  return result;
}
// 1065DED0: using guessed type __int16 word_1065DED0[];

//----- (10028C20) --------------------------------------------------------
char __cdecl sub_10028C20(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1

  result = 1;
  if ( *a5 == 32802 || *a5 == 32888 )
  {
    sub_10028840(a3, a2, a1, a4);
    result = 2;
  }
  return result;
}

//----- (10028C60) --------------------------------------------------------
char __cdecl sub_10028C60(int a1, int a2, int a3)
{
  __int16 v3; // ax@1
  unsigned int v4; // ecx@1
  int v5; // ebp@1
  __int16 v6; // ax@1
  const char *v8; // [sp+1Ch] [bp+Ch]@1

  *(_WORD *)(a1 + 438) = *(_WORD *)a3;
  *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
  v8 = (const char *)sub_10037720(*(_WORD *)(a2 + 8), 0);
  v3 = sub_100034E0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), 0);
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  v6 = *(_WORD *)(a2 + 12);
  if ( (*(_DWORD *)(a2 + 4) & 0xC000) != 0x4000 )
  {
    v6 -= v5;
    if ( v5 > 0 )
      v6 -= *(_WORD *)(dword_10789604[5 * ((v4 >> 10) & 0xF)] + 28);
  }
  if ( !*(_WORD *)(a2 + 12) )
    v6 = sub_10031920(v4, *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 10), *(_BYTE *)(a2 + 11));
  return sub_100039C0(a1, (char *)(*(_DWORD *)(a1 + 56) + 69), v8, v6, v5, *(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8));
}
// 10789604: using guessed type int dword_10789604[];

//----- (10028D30) --------------------------------------------------------
char __cdecl sub_10028D30(int a1, int a2, int a3, float *a4)
{
  bool v4; // sf@1
  unsigned __int8 v5; // of@1
  __int16 v6; // ax@1
  __int16 v7; // dx@1
  bool v8; // cl@3
  __int16 v9; // ax@5
  char *v10; // edi@12
  char v11; // cl@13
  char *v12; // edi@15
  char v13; // al@16
  char v14; // al@18
  int v15; // eax@21
  size_t v16; // edi@24
  const char *v17; // ebx@25
  __int16 v18; // ax@25
  unsigned int v19; // ecx@25
  int v20; // ebp@25
  __int16 v21; // ax@25
  __int16 v23; // [sp+Ch] [bp-24h]@1
  int v24; // [sp+10h] [bp-20h]@1
  char v25[2]; // [sp+14h] [bp-1Ch]@10
  char v26[12]; // [sp+20h] [bp-10h]@23

  v5 = __OFSUB__(*(_DWORD *)a4, 0x7FFFFFFF);
  v4 = *(_DWORD *)a4 - 0x7FFFFFFF < 0;
  v6 = *(_WORD *)(a2 + 8);
  v7 = *(_WORD *)(a2 + 8);
  v24 = a1;
  v23 = v7;
  v8 = v4 ^ v5 || (v6 & 0x3F) == 8;
  v9 = v6 & 0x3F;
  if ( v9 == 4 )
  {
    v7 &= 0xFDFFu;
    v23 = v7;
  }
  if ( !v8 )
    goto LABEL_33;
  if ( *(_DWORD *)a4 || !(v7 & 0x8000) )
  {
    strcpy(v25, "%");
    if ( v7 & 0x40 )
    {
      v10 = (char *)&v24 + 3;
      do
        v11 = (v10++)[1];
      while ( v11 );
      *(_WORD *)v10 = 43;
    }
  }
  else
  {
    strcpy(v25, "-%");
  }
  v12 = (char *)&v24 + 3;
  if ( v9 == 8 )
  {
    do
      v13 = (v12++)[1];
    while ( v13 );
    *(_DWORD *)v12 = 5777968;
  }
  else
  {
    do
      v14 = (v12++)[1];
    while ( v14 );
    *(_DWORD *)v12 = 6564400;
  }
  v15 = v7 & 0x100 ? *(_BYTE *)(a2 + 10) : 0;
  if ( sprintf(v26, v25, v15, *(_DWORD *)a4) > *(_BYTE *)(a2 + 10) )
  {
LABEL_33:
    v16 = *(_BYTE *)(a2 + 10);
    memset(v26, 95, v16);
    v26[v16] = 0;
  }
  *(_WORD *)(a1 + 438) = *(_WORD *)a3;
  *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
  v17 = (const char *)sub_10037720(*(_WORD *)(a2 + 8), a4);
  v18 = sub_100034E0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), a4);
  v19 = *(_DWORD *)(a2 + 4);
  v20 = v18;
  v21 = *(_WORD *)(a2 + 12);
  if ( (*(_DWORD *)(a2 + 4) & 0xC000) != 0x4000 )
  {
    v21 -= v20;
    if ( v20 > 0 )
      v21 -= *(_WORD *)(dword_10789604[5 * ((v19 >> 10) & 0xF)] + 28);
  }
  if ( !*(_WORD *)(a2 + 12) )
    v21 = sub_10031920(v19, *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 10), 0);
  return sub_100039C0(v24, v26, v17, v21, v20, *(_DWORD *)(a2 + 4), v23);
}
// 10789604: using guessed type int dword_10789604[];
// 10028D30: using guessed type char var_10[12];

//----- (10028F20) --------------------------------------------------------
char __usercall sub_10028F20@<al>(_DWORD *a1@<eax>, int a2@<ebx>, int a3@<esi>)
{
  const char *v3; // edi@1
  signed int v4; // eax@1
  int v5; // eax@3
  int v6; // ecx@3

  v3 = "%+0*d";
  v4 = *a1 >= 0x7FFFFFFF ? 0 : *a1;
  if ( !(*(_BYTE *)(a3 + 8) & 0x40) )
    v3 = "%0*d";
  v5 = sprintf((char *)(*(_DWORD *)(a2 + 56) + 69), v3, *(_BYTE *)(a3 + 10), v4);
  v6 = *(_BYTE *)(a3 + 10);
  if ( v5 > v6 )
    sprintf((char *)(*(_DWORD *)(a2 + 56) + 69), v3, v6, 0);
  *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) = 0;
  return 4;
}

//----- (10028F90) --------------------------------------------------------
char __usercall sub_10028F90@<al>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  bool v5; // zf@1
  int v6; // edi@1
  signed int v7; // ebx@1
  int v8; // eax@4
  unsigned __int16 v9; // ax@7
  int v10; // eax@9
  __int16 v11; // cx@9
  char result; // al@10
  char v13; // cl@12
  __int32 v14; // eax@18
  int v15; // eax@21
  int v16; // edx@39
  int v17; // eax@42
  char *v18; // [sp+10h] [bp-8h]@1
  int v19; // [sp+14h] [bp-4h]@1
  char v20; // [sp+1Ch] [bp+4h]@1

  v3 = a3;
  v4 = a1;
  v5 = (*(_BYTE *)(a1 + 8) & 0x40) == 0;
  v6 = a2;
  v20 = 1;
  v7 = 1;
  v19 = 0;
  v18 = "%+0*d";
  if ( v5 )
    v18 = "%0*d";
  if ( *(_WORD *)(v3 + 10) == 84 )
  {
    v8 = *(_DWORD *)(a2 + 56);
    if ( *(_WORD *)(v8 + 240) == -128 )
      *(_WORD *)(v3 + 14) = 45;
    else
      *(_WORD *)(v3 + 14) = 2 * (*(_BYTE *)(v8 + 69) != 45) + 43;
  }
  v9 = *(_WORD *)(v3 + 14);
  if ( v9 < 0x30u || v9 > 0x39u )
  {
    if ( v9 != 43 && v9 != 45 )
    {
      result = 1;
    }
    else if ( sub_100376E0(*(_WORD *)(v4 + 8)) || *(_BYTE *)(v4 + 8) & 0x40 )
    {
      if ( *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) == -128 )
      {
        sub_10028F20(&v19, v6, v4);
        *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) = (char)(*(_BYTE *)(v4 + 10) - 1);
      }
      if ( *(_WORD *)(v3 + 14) == 45 && j__atol((const char *)(*(_DWORD *)(v6 + 56) + 69)) >= 0
        || *(_WORD *)(v3 + 14) == 43 && j__atol((const char *)(*(_DWORD *)(v6 + 56) + 69)) <= 0 )
      {
        if ( *(_BYTE *)(v4 + 8) & 0x40 || *(_WORD *)(v3 + 14) == 45 )
          *(_BYTE *)(*(_DWORD *)(v6 + 56) + 69) = *(_BYTE *)(v3 + 14);
        else
          *(_BYTE *)(*(_DWORD *)(v6 + 56) + 69) = 48;
        v20 = 2;
      }
      v16 = *(_DWORD *)(v6 + 56);
      if ( !*(_WORD *)(v16 + 240)
        && (*(_BYTE *)(*(_WORD *)(v16 + 240) + v16 + 69) == 43
         || *(_BYTE *)(*(_WORD *)(v16 + 240) + *(_DWORD *)(v6 + 56) + 69) == 45) )
      {
        ++*(_WORD *)(*(_DWORD *)(v6 + 56) + 240);
        v17 = *(_BYTE *)(v4 + 10) - 1;
        if ( *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) < v17 )
          LOWORD(v17) = *(_WORD *)(*(_DWORD *)(v6 + 56) + 240);
        *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) = (char)v17;
      }
      result = v20;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    v10 = *(_DWORD *)(a2 + 56);
    v11 = *(_WORD *)(v10 + 240);
    if ( v11 == -128 )
    {
      sub_10028F20(&v19, v6, v4);
      *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) = (char)(*(_BYTE *)(v4 + 10) - 1);
      *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v6 + 56) + 240) + *(_DWORD *)(v6 + 56) + 69) = *(_BYTE *)(v3 + 14);
      result = 2;
    }
    else if ( v11 == (unsigned __int8)(*(_BYTE *)(v4 + 10) - 1) )
    {
      v13 = *(_BYTE *)(v10 + 69);
      if ( v13 == 48 || (v13 == 43 || v13 == 45) && *(_BYTE *)(v10 + 70) == 48 )
      {
        if ( v13 == 45 )
        {
          *(_BYTE *)(v10 + 69) = 48;
          v7 = -1;
        }
        v14 = j__atol((const char *)(*(_DWORD *)(v6 + 56) + 69));
        sprintf((char *)(*(_DWORD *)(v6 + 56) + 69), v18, *(_BYTE *)(v4 + 10), 10 * v14);
        if ( v7 == -1 )
          *(_BYTE *)(*(_DWORD *)(v6 + 56) + 69) = 45;
      }
      *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v6 + 56) + 240) + *(_DWORD *)(v6 + 56) + 69) = *(_BYTE *)(v3 + 14);
      result = 2;
    }
    else
    {
      *(_BYTE *)(*(_WORD *)(v10 + 240) + v10 + 69) = *(_BYTE *)(v3 + 14);
      ++*(_WORD *)(*(_DWORD *)(v6 + 56) + 240);
      v15 = *(_BYTE *)(v4 + 10) - 1;
      if ( *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) < v15 )
        LOWORD(v15) = *(_WORD *)(*(_DWORD *)(v6 + 56) + 240);
      *(_WORD *)(*(_DWORD *)(v6 + 56) + 240) = (char)v15;
      result = 2;
    }
  }
  return result;
}

//----- (10029250) --------------------------------------------------------
char __cdecl sub_10029250(int a1, int a2)
{
  int v2; // ecx@0
  __int16 v3; // ax@1
  char v5; // [sp+0h] [bp-14h]@1
  int v6; // [sp+4h] [bp-10h]@1
  __int16 v7; // [sp+8h] [bp-Ch]@1
  char v8; // [sp+Ah] [bp-Ah]@1
  char v9; // [sp+Bh] [bp-9h]@1
  __int16 v10; // [sp+Ch] [bp-8h]@1

  v6 = *(_DWORD *)(a1 + 4);
  v7 = *(_WORD *)(a1 + 8);
  v3 = *(_WORD *)(a1 + 12);
  v8 = *(_BYTE *)(a1 + 10);
  v10 = v3;
  v9 = 0;
  return sub_10028C60(v2, (int)&v5, a2);
}

//----- (100292B0) --------------------------------------------------------
char __cdecl sub_100292B0(int a1, int a2, int *a3, float *a4, int a5)
{
  char v5; // bl@1
  __int16 v6; // ax@2
  _WORD *v7; // ebx@2
  int v8; // eax@3
  int v9; // edx@5
  __int16 v10; // ax@9
  int v11; // eax@10
  __int16 v12; // cx@10
  char result; // al@11
  int v14; // eax@12
  __int16 v15; // bp@12
  signed int v16; // eax@13
  char v17; // al@19
  __int16 v18; // cx@21
  __int16 v19; // ax@25
  signed int v20; // edx@28
  int v21; // edx@30
  int v22; // edx@31
  char v23; // cl@33
  int v24; // ebx@34
  int v25; // ebx@39
  int v26; // edx@42
  __int16 v27; // ax@42

  v5 = 1;
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v6 = *(_WORD *)(a2 + 12);
      v7 = (_WORD *)(a1 + 276);
      if ( v6 )
      {
        sub_10003860(a1 + 276, *a3, *(_DWORD *)(a2 + 4), v6);
      }
      else
      {
        v8 = sub_10031920(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 10), 0);
        sub_10003860((int)v7, *a3, *(_DWORD *)(a2 + 4), v8);
      }
      v9 = (signed __int16)sub_100034E0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), a4);
      if ( (!*(_WORD *)(a2 + 12) || (*(_DWORD *)(a2 + 4) & 0xC000) == 0x4000)
        && ~(unsigned __int8)(*(_WORD *)(a2 + 8) >> 9) & 1
        && v9 > 0 )
      {
        v10 = *(_WORD *)(dword_10789604[5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF)] + 28);
        *(_WORD *)(a1 + 280) += v9 + v10;
        if ( (*(_DWORD *)(a2 + 4) & 0xC000) == 0x8000 )
        {
          v11 = (v10 + v9 + 1) / 2;
          v12 = *(_WORD *)(a1 + 280) - v11;
          *v7 -= v11;
          *(_WORD *)(a1 + 280) = v12;
        }
      }
      return 2;
    case 0x8048:
      v14 = *(_DWORD *)(a1 + 56);
      v15 = *(_WORD *)(v14 + 240);
      if ( v15 == -128 )
      {
        v16 = *(_WORD *)(a5 + 10);
        if ( v16 > 84 )
        {
          if ( v16 != 0x2000 )
            return v5;
        }
        else if ( v16 != 84 )
        {
          if ( v16 == 32 )
          {
            if ( !*(_DWORD *)a4 )
              return v5;
            v18 = *(_WORD *)(a2 + 8);
            if ( *(_WORD *)(a2 + 8) & 0x400 || (v18 & 0x3F) == 27 )
              return v5;
            v5 = sub_10028F20(a4, a1, a2);
            memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, *(_BYTE *)(a2 + 10));
            goto LABEL_50;
          }
          if ( v16 != 56 || *(_WORD *)(a2 + 8) & 0x400 || (*(_WORD *)(a2 + 8) & 0x3F) == 27 )
            return v5;
          v17 = sub_10028F20(a4, a1, a2);
LABEL_49:
          v5 = v17;
LABEL_50:
          if ( v5 != 4 && v5 != 2 )
            return v5;
LABEL_52:
          sub_10029250(a2, (int)a3);
          return v5;
        }
        v19 = *(_WORD *)(a2 + 8);
        if ( *(_WORD *)(a2 + 8) & 0x400 || (v19 & 0x3F) == 27 )
          return v5;
LABEL_48:
        v17 = sub_10028F90(a2, a1, a5);
        goto LABEL_49;
      }
      v20 = *(_WORD *)(a5 + 10);
      if ( v20 > 57 )
      {
        if ( v20 != 84 && v20 != 0x2000 )
          return v5;
        goto LABEL_48;
      }
      if ( v20 == 57 )
      {
        *(_WORD *)(v14 + 240) += *(_BYTE *)(a5 + 8);
        v26 = *(_DWORD *)(a1 + 56);
        v27 = *(_WORD *)(v26 + 240);
        v5 = 2;
        if ( v27 < 0 )
        {
          *(_WORD *)(v26 + 240) = 0;
          sub_10029250(a2, (int)a3);
          return 2;
        }
        if ( v27 > *(_BYTE *)(a2 + 10) - 1 )
        {
          *(_WORD *)(v26 + 240) = (char)(*(_BYTE *)(a2 + 10) - 1);
          sub_10029250(a2, (int)a3);
          return 2;
        }
        goto LABEL_52;
      }
      v21 = v20 - 32;
      if ( v21 )
      {
        v22 = v21 - 1;
        if ( v22 )
        {
          if ( v22 != 23 )
            return v5;
          v23 = *(_BYTE *)(a5 + 8);
          if ( v23 >= 0 )
          {
            if ( v23 <= 0 )
              return v5;
            if ( !(*(_BYTE *)(a2 + 8) & 0x40) || v15 )
            {
              v25 = *(_DWORD *)(a1 + 56);
              *(_BYTE *)(*(_WORD *)(v25 + 240) + v25 + 69) = sub_10038B70(*(_BYTE *)(v15 + v14 + 69), 0x10u, 1);
              sub_10029250(a2, (int)a3);
              result = 2;
            }
            else
            {
              *(_BYTE *)(v14 + 69) = 2 * (*(_BYTE *)(v14 + 69) != 45) + 43;
              sub_10029250(a2, (int)a3);
              result = 2;
            }
          }
          else
          {
            v24 = *(_DWORD *)(a1 + 56);
            *(_BYTE *)(*(_WORD *)(v24 + 240) + v24 + 69) = sub_10038B70(*(_BYTE *)(v15 + v24 + 69), 0x10u, -1);
            sub_10029250(a2, (int)a3);
            result = 2;
          }
        }
        else
        {
          *(_WORD *)(v14 + 240) = -128;
          *(_DWORD *)a4 = j__atol((const char *)(*(_DWORD *)(a1 + 56) + 69));
          sub_10028D30(a1, a2, (int)a3, a4);
          result = 3;
        }
      }
      else
      {
        *(_WORD *)(v14 + 240) = -128;
        sub_10028D30(a1, a2, (int)a3, a4);
        result = 6;
      }
      return result;
    case 0x8022:
    case 0x8078:
      if ( !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
      {
        sub_10028D30(a1, a2, (int)a3, a4);
        return v5;
      }
      sub_10029250(a2, (int)a3);
      return 1;
    default:
      return v5;
  }
}
// 10789604: using guessed type int dword_10789604[];

//----- (10029760) --------------------------------------------------------
char __usercall sub_10029760@<al>(_WORD *a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4, _WORD *a5)
{
  char v5; // bl@1
  _WORD *v6; // ST10_4@7
  int v7; // ecx@7
  unsigned __int16 *v8; // ST0C_4@7
  char result; // al@7
  int v10; // ST10_4@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Bh] [bp-1Dh]@1
  int v14; // [sp+Ch] [bp-1Ch]@8
  int v15; // [sp+10h] [bp-18h]@8
  __int16 v16; // [sp+14h] [bp-14h]@8
  __int16 v17; // [sp+16h] [bp-12h]@8
  int v18; // [sp+18h] [bp-10h]@7
  int v19; // [sp+1Ch] [bp-Ch]@7
  __int16 v20; // [sp+20h] [bp-8h]@7

  v5 = *(_BYTE *)(a3 + 3);
  v13 = byte_10756F5E;
  if ( *(_BYTE *)(a3 + 9) || *(_BYTE *)(*(_DWORD *)(a3 + 56) + 237) && v5 )
  {
    *(_BYTE *)(a3 + 3) = 1;
    byte_10756F5E = 1;
  }
  if ( *(_BYTE *)(a4 + 8) & 1 )
  {
    if ( (*(_BYTE *)(a4 + 8) & 1) == 1 )
    {
      v6 = a1;
      v7 = *a5;
      v19 = *(_DWORD *)(a4 + 4);
      v20 = *(_WORD *)(a4 + 10);
      v8 = (unsigned __int16 *)(*(_DWORD *)(a4 + 16) + 2 * v7);
      v18 = 107;
      result = sub_10030630(a3, (int)&v18, a2, v8, v6);
      byte_10756F5E = v13;
      *(_BYTE *)(a3 + 3) = v5;
    }
    else
    {
      result = v13;
      byte_10756F5E = v13;
      *(_BYTE *)(a3 + 3) = v5;
    }
  }
  else
  {
    v10 = (int)a1;
    v11 = *a5;
    v15 = *(_DWORD *)(a4 + 4);
    v16 = *(_WORD *)(a4 + 10);
    v12 = *(_DWORD *)(a4 + 16);
    v14 = 105;
    v17 = 0;
    result = sub_10031070(a3, (int)&v14, a2, *(char **)(v12 + 4 * v11), v10);
    byte_10756F5E = v13;
    *(_BYTE *)(a3 + 3) = v5;
  }
  return result;
}
// 10756F5E: using guessed type char byte_10756F5E;

//----- (10029890) --------------------------------------------------------
char __cdecl sub_10029890(int a1, int a2, int a3, _WORD *a4, int a5)
{
  int v5; // ecx@5
  int v6; // eax@5
  int v7; // edx@5
  int v8; // ecx@5
  char v9; // ST3F_1@5
  unsigned __int16 v10; // ax@6
  int v11; // eax@8
  __int16 v12; // cx@11
  int v13; // eax@11
  char v15; // [sp+13h] [bp-39h]@1
  __int16 v16; // [sp+14h] [bp-38h]@5
  int v17; // [sp+18h] [bp-34h]@5
  int v18; // [sp+1Ch] [bp-30h]@5
  _WORD *v19; // [sp+20h] [bp-2Ch]@5
  int v20; // [sp+24h] [bp-28h]@5
  int v21; // [sp+28h] [bp-24h]@5
  int v22; // [sp+2Ch] [bp-20h]@5
  int v23; // [sp+30h] [bp-1Ch]@5
  int v24; // [sp+34h] [bp-18h]@7
  int v25; // [sp+38h] [bp-14h]@7
  __int16 v26; // [sp+3Ch] [bp-10h]@7
  __int16 v27; // [sp+3Eh] [bp-Eh]@7
  char v28; // [sp+40h] [bp-Ch]@7

  v15 = 1;
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      sub_10029760((_WORD *)a5, a3, a1, a2, a4);
      v15 = 2;
      break;
    case 0x8048:
      if ( *(_WORD *)(a2 + 12) && *(_WORD *)(a5 + 10) == 56 )
      {
        v5 = *(_DWORD *)(a1 + 56);
        v17 = 0;
        v16 = -32688;
        v18 = a2;
        v19 = a4;
        v22 = 83;
        v23 = *(_DWORD *)(v5 + 8);
        sub_10029760(&unk_100B0974, a3, a1, a2, a4);
        v6 = *(_DWORD *)(a1 + 276);
        v7 = *(_DWORD *)(a1 + 56);
        v8 = *(_DWORD *)(a1 + 280);
        v20 = v6;
        v21 = v8;
        HIWORD(v20) = *(_WORD *)(v7 + 30) + HIWORD(v6);
        HIWORD(v21) = *(_WORD *)(v7 + 30) + HIWORD(v8);
        LOWORD(v20) = *(_WORD *)(v7 + 28) + v6;
        LOBYTE(v6) = *(_BYTE *)(a1 + 3);
        LOWORD(v21) = *(_WORD *)(v7 + 28) + v8;
        *(_BYTE *)(v7 + 237) = 1;
        v9 = v6;
        *(_BYTE *)(a1 + 3) = 1;
        sub_10029760(&unk_100B096C, a3, a1, a2, a4);
        *(_BYTE *)(a1 + 3) = v9;
        sub_10003E50(a1, (int)&v16, 32);
        sub_100352A0(a1, 0, (int (__cdecl *)(int))sub_1000FC40, 0);
        v15 = 2;
      }
      break;
    case 0x8022:
    case 0x8078:
      v10 = *(_WORD *)(a2 + 12);
      if ( v10 )
      {
        v11 = v10 - 1;
        if ( *a4 < v11 )
          LOWORD(v11) = *a4;
        *a4 = (signed __int16)v11 <= 0 ? 0 : (unsigned __int16)v11;
        sub_10029760((_WORD *)a5, a3, a1, a2, a4);
        v15 = 2;
      }
      else
      {
        v25 = *(_DWORD *)(a2 + 4);
        v24 = 105;
        v26 = 0;
        v27 = 4;
        strcpy(&v28, "NONE");
        sub_10030C20(a1, (int)&v24, a3, &v28);
        v15 = 2;
      }
      break;
    case 0x8051:
      v12 = *(_WORD *)(a5 + 10);
      *a4 = v12;
      v13 = *(_WORD *)(a2 + 12) - 1;
      v15 = 3;
      if ( v12 < v13 )
        LOWORD(v13) = v12;
      *a4 = (signed __int16)v13 <= 0 ? 0 : (unsigned __int16)v13;
      sub_10029760(&unk_100B096C, a3, a1, a2, a4);
      break;
    default:
      return v15;
  }
  return v15;
}

//----- (10029B20) --------------------------------------------------------
char __cdecl sub_10029B20(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char v5; // al@3
  __int16 v6; // dx@4
  __int16 v7; // ax@6
  signed __int16 v8; // cx@6
  __int16 v9; // dx@8
  __int16 v10; // bx@8
  __int16 v11; // bp@8
  __int16 v12; // ST2C_2@8
  int v13; // edx@8
  int v14; // ST28_4@8
  __int16 v16; // [sp+0h] [bp-10h]@6
  __int16 v17; // [sp+4h] [bp-Ch]@4

  if ( *a5 == -32734 || *a5 == -32648 )
  {
    v5 = *(_BYTE *)(a2 + 8);
    if ( v5 & 0x20 )
    {
      v6 = *(_WORD *)(a2 + 6);
      v17 = *(_WORD *)(a2 + 4);
    }
    else
    {
      v17 = *(_WORD *)a3 + *(_WORD *)(a2 + 4);
      v6 = *(_WORD *)(a3 + 2) + *(_WORD *)(a2 + 6);
    }
    v16 = v6;
    v7 = word_1065DED0[(unsigned __int8)sub_100397E0(v5 & 0x1F)];
    v8 = 2;
    if ( (*(_BYTE *)(a2 + 8) & 0xC0) != 64 )
      v8 = 1;
    v9 = *(_WORD *)(a1 + 396);
    v10 = *(_WORD *)(a1 + 426);
    v11 = *(_WORD *)(a1 + 424);
    *(_WORD *)(a1 + 426) = v8;
    v12 = v9;
    v13 = *(_DWORD *)(a1 + 428);
    *(_WORD *)(a1 + 424) = v8;
    *(_WORD *)(a1 + 428) = v7;
    *(_WORD *)(a1 + 430) = v7;
    v14 = v13;
    *(_WORD *)(a1 + 396) = 2;
    *(_WORD *)(a1 + 438) = *(_WORD *)a3;
    *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
    sub_1001CF50(a1 + 392, v17, v16, 2);
    *(_WORD *)(a1 + 426) = v10;
    *(_WORD *)(a1 + 424) = v11;
    *(_WORD *)(a1 + 396) = v12;
    *(_WORD *)(a1 + 428) = v14;
    *(_WORD *)(a1 + 430) = HIWORD(v14);
  }
  return 1;
}
// 1065DED0: using guessed type __int16 word_1065DED0[];

//----- (10029C70) --------------------------------------------------------
char __usercall sub_10029C70@<al>(int a1@<edx>, int a2@<esi>, int a3, int *a4, int a5)
{
  char v5; // bl@1
  int v6; // ecx@5
  int v7; // eax@5
  char result; // al@8
  char v9; // [sp+7h] [bp-15h]@1
  int v10; // [sp+8h] [bp-14h]@5
  char v11; // [sp+Ch] [bp-10h]@5
  char v12; // [sp+Dh] [bp-Fh]@5
  __int16 v13; // [sp+Eh] [bp-Eh]@5
  __int16 v14; // [sp+10h] [bp-Ch]@5
  int v15; // [sp+14h] [bp-8h]@6
  int v16; // [sp+18h] [bp-4h]@5

  v9 = byte_10756F5E;
  v5 = *(_BYTE *)(a2 + 3);
  if ( *(_BYTE *)(a2 + 9) || *(_BYTE *)(*(_DWORD *)(a2 + 56) + 237) && v5 )
  {
    *(_BYTE *)(a2 + 3) = 1;
    byte_10756F5E = 1;
  }
  v6 = *(_DWORD *)(a1 + 8);
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v7 = 4 * *(_WORD *)(a1 + 2);
  v10 = 75;
  v16 = *(_DWORD *)(v7 + v6);
  if ( (*(_BYTE *)(a3 + 4) & 1) == 1 )
    v15 = *(_DWORD *)(a1 + 4);
  else
    v15 = *(_DWORD *)(v7 + *(_DWORD *)(a1 + 4));
  sub_10038130(a2, (int)&v10, a4, (int)&v11, a5);
  result = v9;
  byte_10756F5E = v9;
  *(_BYTE *)(a2 + 3) = v5;
  return result;
}
// 10756F5E: using guessed type char byte_10756F5E;

//----- (10029D20) --------------------------------------------------------
char __cdecl sub_10029D20(unsigned int a1, int a2, int *a3, int a4, int a5)
{
  char v5; // bl@1
  int v6; // ecx@3
  int v7; // eax@3
  int v8; // edx@3
  int v9; // ecx@3
  char result; // al@5
  int v11; // eax@6
  __int16 v12; // cx@9
  int v13; // eax@9
  int v14; // eax@9
  int v15; // [sp+8h] [bp-18h]@3
  int v16; // [sp+Ch] [bp-14h]@3
  int v17; // [sp+10h] [bp-10h]@3
  int v18; // [sp+14h] [bp-Ch]@3
  int v19; // [sp+18h] [bp-8h]@3
  int v20; // [sp+1Ch] [bp-4h]@3
  char v21; // [sp+34h] [bp+14h]@3

  v5 = 1;
  switch ( *(_WORD *)a5 )
  {
    case 0x8048:
      if ( *(_WORD *)(a5 + 10) != 56 )
        goto LABEL_12;
      v6 = *(_DWORD *)(a1 + 56);
      v15 = a2;
      v16 = a4;
      v19 = 76;
      v20 = *(_DWORD *)(v6 + 8);
      sub_10029C70(a4, a1, a2, a3, (int)&unk_100B0974);
      v7 = *(_DWORD *)(a1 + 276);
      v8 = *(_DWORD *)(a1 + 56);
      v9 = *(_DWORD *)(a1 + 280);
      v17 = v7;
      v18 = v9;
      HIWORD(v17) = *(_WORD *)(v8 + 30) + HIWORD(v7);
      HIWORD(v18) = *(_WORD *)(v8 + 30) + HIWORD(v9);
      LOWORD(v17) = *(_WORD *)(v8 + 28) + v7;
      LOBYTE(v7) = *(_BYTE *)(a1 + 3);
      LOWORD(v18) = *(_WORD *)(v8 + 28) + v9;
      *(_BYTE *)(v8 + 237) = 1;
      *(_BYTE *)(a1 + 3) = 1;
      v21 = v7;
      if ( !(*(_BYTE *)(a2 + 4) & 0x10) )
      {
        sub_10029C70(a4, a1, a2, a3, (int)&unk_100B096C);
        *(_BYTE *)(a1 + 3) = v21;
      }
      sub_10034EF0(a1, 0, (int (__cdecl *)(int))sub_1000F1E0, 0, (int)&v15);
      result = 2;
      break;
    case 0x8022:
    case 0x8040:
    case 0x8078:
      v11 = *(_WORD *)a4 - 1;
      if ( *(_WORD *)(a4 + 2) < v11 )
        LOWORD(v11) = *(_WORD *)(a4 + 2);
      *(_WORD *)(a4 + 2) = (signed __int16)v11 <= 0 ? 0 : (unsigned __int16)v11;
      sub_10029C70(a4, a1, a2, a3, a5);
      result = 2;
      break;
    case 0x8051:
      v12 = *(_WORD *)(a5 + 10);
      v13 = *(_WORD *)a4;
      *(_WORD *)(a4 + 2) = v12;
      v14 = v13 - 1;
      v5 = 3;
      if ( v12 < v14 )
        LOWORD(v14) = v12;
      *(_WORD *)(a4 + 2) = (signed __int16)v14 <= 0 ? 0 : v14;
      sub_10029C70(a4, a1, a2, a3, (int)&unk_100B096C);
      goto LABEL_12;
    default:
LABEL_12:
      result = v5;
      break;
  }
  return result;
}

//----- (10029F30) --------------------------------------------------------
int __cdecl sub_10029F30(unsigned int a1, unsigned __int8 a2)
{
  int v2; // edx@1
  int v3; // esi@1

  v2 = (unsigned __int8)byte_1009FB4D[28 * a2];
  v3 = (unsigned __int8)byte_1009FB4C[28 * a2];
  return v2 * LOBYTE(dword_10789600[5 * ((a1 >> 10) & 0xF) + 4])
       + v3 * BYTE1(dword_10789600[5 * ((a1 >> 10) & 0xF) + 4])
       + *(_WORD *)(dword_10789604[5 * ((a1 >> 10) & 0xF)] + 28) * (v3 + v2 - 1);
}
// 10789600: using guessed type int dword_10789600[];
// 10789604: using guessed type int dword_10789604[];

//----- (10029F90) --------------------------------------------------------
int __cdecl sub_10029F90(int a1, char *a2, char a3)
{
  int v3; // ST10_4@1
  char *v4; // eax@1

  v3 = *(_WORD *)(a1 + 2) % 100;
  v4 = sub_10037280(word_100A5C36[*(_BYTE *)a1]);
  return sprintf(a2, (&off_1009FB44)[28 * (unsigned __int8)a3], *(_BYTE *)(a1 + 1), v4, v3);
}
// 100A5C36: using guessed type __int16 word_100A5C36[];

//----- (10029FF0) --------------------------------------------------------
int __usercall sub_10029FF0@<eax>(int a1@<eax>, int a2)
{
  int v2; // ecx@1
  int v3; // edx@1
  int result; // eax@1

  v2 = *(_DWORD *)(a2 + 56);
  v3 = *(_WORD *)(v2 + 240);
  result = 7 * *(_BYTE *)(a1 + 8);
  if ( v3 == dword_1009FB50[result] )
    *(_BYTE *)(v2 + 242) = 3;
  else
    *(_BYTE *)(v2 + 242) = (v3 == dword_1009FB54[result]) + 1;
  return result * 4;
}
// 1009FB50: using guessed type int dword_1009FB50[];
// 1009FB54: using guessed type int dword_1009FB54[];

//----- (1002A040) --------------------------------------------------------
char *__usercall sub_1002A040@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4)
{
  int v4; // eax@1
  int v6; // [sp+0h] [bp-4h]@1

  v6 = a1;
  strncpy((char *)&v6, (const char *)(dword_1009FB54[7 * *(_BYTE *)(a3 + 8)] + *(_DWORD *)(a2 + 56) + 69), 2u);
  BYTE2(v6) = 0;
  v4 = a4 + (unsigned __int8)j__atol((const char *)&v6);
  if ( v4 <= 31 )
  {
    if ( v4 <= 0 )
      v4 = 31;
  }
  else
  {
    v4 = 1;
  }
  sprintf((char *)&v6, "%02u", v4);
  return strncpy((char *)(dword_1009FB54[7 * *(_BYTE *)(a3 + 8)] + *(_DWORD *)(a2 + 56) + 69), (const char *)&v6, 2u);
}
// 1009FB54: using guessed type int dword_1009FB54[];

//----- (1002A0E0) --------------------------------------------------------
char *__usercall sub_1002A0E0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4)
{
  signed int v4; // esi@1
  int v5; // esi@4
  char *v6; // eax@8
  int v8; // [sp+0h] [bp-4h]@1

  v8 = a1;
  strncpy((char *)&v8, (const char *)(dword_1009FB50[7 * *(_BYTE *)(a3 + 8)] + *(_DWORD *)(a2 + 56) + 69), 3u);
  BYTE3(v8) = 0;
  v4 = 0;
  do
  {
    if ( !strcmp((const char *)&v8, sub_10037280(word_100A5C38[v4])) )
      break;
    ++v4;
  }
  while ( v4 < 11 );
  v5 = a4 + v4;
  if ( v5 <= 11 )
  {
    if ( v5 < 0 )
      v5 = 11;
  }
  else
  {
    v5 = 0;
  }
  v6 = sub_10037280(word_100A5C38[v5]);
  return strncpy((char *)(dword_1009FB50[7 * *(_BYTE *)(a3 + 8)] + *(_DWORD *)(a2 + 56) + 69), v6, 3u);
}
// 1009FB50: using guessed type int dword_1009FB50[];
// 100A5C38: using guessed type __int16 word_100A5C38[];

//----- (1002A1C0) --------------------------------------------------------
char __usercall sub_1002A1C0@<al>(int a1@<eax>, int a2@<edi>, int a3)
{
  int v3; // esi@1
  int v4; // ebx@1
  int v5; // ecx@2
  int v6; // ebp@2
  int v7; // eax@2
  int v8; // edx@7
  int v9; // eax@7
  unsigned __int16 *v10; // ebp@8
  char *v11; // eax@10
  bool v12; // zf@12
  bool v13; // sf@12
  unsigned __int8 v14; // of@12
  int v16; // ecx@14
  unsigned __int16 *v17; // ebp@15
  char *v18; // eax@18
  unsigned __int16 *v19; // ebp@25
  char *v20; // eax@29

  v3 = a1;
  v4 = 0;
  if ( *(_BYTE *)(a3 + 14) != 32 )
  {
    v5 = dword_1009FB50[7 * *(_BYTE *)(a2 + 8)];
    v6 = *(_DWORD *)(a1 + 56);
    v7 = *(_WORD *)(v6 + 240);
    if ( v7 != v5 )
    {
      if ( v7 != v5 + 1 && v7 != v5 + 2 )
        *(_WORD *)(v6 + 240) = dword_1009FB50[7 * *(_BYTE *)(a2 + 8)];
      v4 = 0;
    }
    *(_BYTE *)(*(_DWORD *)(v3 + 56) + 242) = 1;
    v8 = *(_DWORD *)(v3 + 56);
    v9 = dword_1009FB50[7 * *(_BYTE *)(a2 + 8)];
    if ( *(_WORD *)(v8 + 240) == v9 )
    {
      v10 = (unsigned __int16 *)&unk_100A5C4E;
      do
      {
        if ( *(_WORD *)(a3 + 14) == (unsigned __int8)*sub_10037280(*v10) )
        {
          v11 = sub_10037280(*v10);
          strncpy((char *)(dword_1009FB50[7 * *(_BYTE *)(a2 + 8)] + *(_DWORD *)(v3 + 56) + 69), v11, 3u);
          ++v4;
        }
        --v10;
      }
      while ( (signed int)v10 >= (signed int)word_100A5C38 );
      v14 = __OFSUB__(v4, 1);
      v12 = v4 == 1;
      v13 = v4 - 1 < 0;
      if ( v4 == 1 )
      {
        *(_WORD *)(*(_DWORD *)(v3 + 56) + 240) = dword_1009FB58[7 * *(_BYTE *)(a2 + 8)];
        return 2;
      }
    }
    else
    {
      v16 = *(_WORD *)(v8 + 240);
      if ( v16 != v9 + 1 )
      {
        if ( v16 == v9 + 2 )
        {
          v19 = (unsigned __int16 *)&unk_100A5C4E;
          do
          {
            if ( *(_BYTE *)(dword_1009FB50[7 * *(_BYTE *)(a2 + 8)] + *(_DWORD *)(v3 + 56) + 69) == *sub_10037280(*v19)
              && *(_BYTE *)(dword_1009FB50[7 * *(_BYTE *)(a2 + 8)] + *(_DWORD *)(v3 + 56) + 70) == sub_10037280(*v19)[1]
              && *(_WORD *)(a3 + 14) == (unsigned __int8)sub_10037280(*v19)[2] )
            {
              v20 = sub_10037280(*v19);
              strncpy((char *)(dword_1009FB50[7 * *(_BYTE *)(a2 + 8)] + *(_DWORD *)(v3 + 56) + 69), v20, 3u);
              ++v4;
            }
            --v19;
          }
          while ( (signed int)v19 >= (signed int)word_100A5C38 );
          if ( v4 == 1 )
            *(_WORD *)(*(_DWORD *)(v3 + 56) + 240) = dword_1009FB58[7 * *(_BYTE *)(a2 + 8)];
        }
        return 2;
      }
      v17 = (unsigned __int16 *)&unk_100A5C4E;
      do
      {
        if ( *(_BYTE *)(dword_1009FB50[7 * *(_BYTE *)(a2 + 8)] + *(_DWORD *)(v3 + 56) + 69) == *sub_10037280(*v17)
          && *(_WORD *)(a3 + 14) == (unsigned __int8)sub_10037280(*v17)[1] )
        {
          v18 = sub_10037280(*v17);
          strncpy((char *)(dword_1009FB50[7 * *(_BYTE *)(a2 + 8)] + *(_DWORD *)(v3 + 56) + 69), v18, 3u);
          ++v4;
        }
        --v17;
      }
      while ( (signed int)v17 >= (signed int)word_100A5C38 );
      v14 = __OFSUB__(v4, 1);
      v12 = v4 == 1;
      v13 = v4 - 1 < 0;
      if ( v4 == 1 )
      {
        *(_WORD *)(*(_DWORD *)(v3 + 56) + 240) = dword_1009FB58[7 * *(_BYTE *)(a2 + 8)];
        return 2;
      }
    }
    if ( !((unsigned __int8)(v13 ^ v14) | v12) )
    {
      ++*(_WORD *)(*(_DWORD *)(v3 + 56) + 240);
      return 2;
    }
  }
  return 2;
}
// 1009FB50: using guessed type int dword_1009FB50[];
// 1009FB58: using guessed type int dword_1009FB58[];
// 100A5C38: using guessed type __int16 word_100A5C38[];

//----- (1002A4D0) --------------------------------------------------------
char __usercall sub_1002A4D0@<al>(int a1@<edi>, int a2@<esi>, int a3)
{
  int v3; // ebx@1
  int v4; // edx@1
  int v5; // ecx@1
  int v6; // ebp@1
  char result; // al@1
  int v8; // ecx@3
  int v9; // ecx@6
  __int32 v10; // eax@11
  char v11[2]; // [sp+8h] [bp-4h]@10
  char v12; // [sp+Ah] [bp-2h]@10

  v3 = *(_DWORD *)(a2 + 56);
  v4 = *(_WORD *)(v3 + 240);
  v5 = 7 * *(_BYTE *)(a1 + 8);
  v6 = dword_1009FB58[v5];
  result = 1;
  if ( v4 != v6 && v4 != v6 + 1 )
  {
    v9 = dword_1009FB54[v5];
    if ( v4 == v9 || v4 == v9 + 1 )
    {
      if ( *(_BYTE *)(v3 + 242) == 2 )
      {
        *(_WORD *)(v9 + v3 + 69) = 12336;
        *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) = LOWORD(dword_1009FB54[7 * *(_BYTE *)(a1 + 8)]) + 1;
        *(_BYTE *)(*(_DWORD *)(a2 + 56) + 242) = 1;
      }
      strncpy(v11, (const char *)(dword_1009FB54[7 * *(_BYTE *)(a1 + 8)] + *(_DWORD *)(a2 + 56) + 69), 2u);
      v12 = 0;
      if ( v11[0] == 48 )
      {
        v10 = j__atol(v11);
        sprintf(v11, "%02i", 10 * v10);
      }
      v11[*(_WORD *)(*(_DWORD *)(a2 + 56) + 240) - dword_1009FB54[7 * *(_BYTE *)(a1 + 8)]] = *(_BYTE *)(a3 + 14);
      if ( j__atol(v11) > 31 )
        *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a2 + 56) + 240) + *(_DWORD *)(a2 + 56) + 69) = *(_BYTE *)(a3 + 14);
      else
        *(_WORD *)(dword_1009FB54[7 * *(_BYTE *)(a1 + 8)] + *(_DWORD *)(a2 + 56) + 69) = *(_WORD *)v11;
      strncpy(v11, (const char *)(dword_1009FB54[7 * *(_BYTE *)(a1 + 8)] + *(_DWORD *)(a2 + 56) + 69), 2u);
      if ( 10 * j__atol(v11) > 31 )
      {
        *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) = dword_1009FB50[7 * *(_BYTE *)(a1 + 8)];
        *(_BYTE *)(*(_DWORD *)(a2 + 56) + 242) = 3;
      }
      result = 2;
    }
  }
  else
  {
    *(_BYTE *)(*(_WORD *)(v3 + 240) + v3 + 69) = *(_BYTE *)(a3 + 14);
    v8 = *(_DWORD *)(a2 + 56);
    if ( *(_WORD *)(v8 + 240) == dword_1009FB58[7 * *(_BYTE *)(a1 + 8)] )
      ++*(_WORD *)(v8 + 240);
    *(_BYTE *)(*(_DWORD *)(a2 + 56) + 242) = 1;
    result = 2;
  }
  return result;
}
// 1009FB50: using guessed type int dword_1009FB50[];
// 1009FB54: using guessed type int dword_1009FB54[];
// 1009FB58: using guessed type int dword_1009FB58[];

//----- (1002A6E0) --------------------------------------------------------
char __usercall sub_1002A6E0@<al>(int a1@<edi>, int a2@<esi>, int a3, unsigned int *a4)
{
  unsigned int v4; // ecx@1
  bool v5; // zf@1
  char *v6; // eax@7
  char *v7; // edx@7
  char v8; // cl@8
  int *v9; // eax@13
  int v10; // ST1C_4@13
  signed int v11; // eax@13
  unsigned int v12; // ST14_4@13
  int v13; // eax@13
  int v14; // ST0C_4@13
  signed int v15; // eax@13
  int v17; // [sp+8h] [bp-2Ch]@1
  int v18; // [sp+Ch] [bp-28h]@13
  int v19; // [sp+10h] [bp-24h]@13
  int v20; // [sp+14h] [bp-20h]@13
  __int16 v21; // [sp+18h] [bp-1Ch]@11
  int v22; // [sp+1Ah] [bp-1Ah]@13
  int v23; // [sp+20h] [bp-14h]@13
  char v24[12]; // [sp+24h] [bp-10h]@7

  v4 = *a4;
  v5 = byte_1009FB5C[28 * *(_BYTE *)(a2 + 8)] == 0;
  LOBYTE(v17) = 13;
  if ( v5 )
  {
    if ( v4 == -1 )
      goto LABEL_7;
    sub_10038E00((int)&v17, v4);
  }
  else if ( !sub_10039190((int)&v17) )
  {
    LOBYTE(v17) = 13;
    goto LABEL_7;
  }
  if ( (unsigned __int8)v17 <= 0xCu )
  {
    sub_10029F90((int)&v17, v24, *(_BYTE *)(a2 + 8));
    goto LABEL_11;
  }
LABEL_7:
  v6 = (&off_1009FB48)[28 * *(_BYTE *)(a2 + 8)];
  v7 = (char *)(v24 - v6);
  do
  {
    v8 = *v6;
    v6[(_DWORD)v7] = *v6;
    ++v6;
  }
  while ( v8 );
LABEL_11:
  v21 = *(_WORD *)(a2 + 10);
  if ( !v21 )
    v21 = sub_10029F30(*(_DWORD *)(a2 + 4), *(_BYTE *)(a2 + 8));
  v9 = sub_10002E60(*(_DWORD *)(a2 + 4));
  v10 = *(_DWORD *)(a2 + 4);
  v18 = v9[1];
  v11 = sub_10002EA0(v10);
  v12 = *(_DWORD *)(a2 + 4);
  v19 = v11;
  v20 = sub_100035F0(v12, 0);
  v13 = sub_10002E30(*(_DWORD *)(a2 + 4));
  v14 = *(_DWORD *)(a2 + 4);
  v22 = v13;
  v15 = sub_10002ED0(v14);
  *(_WORD *)(a1 + 438) = *(_WORD *)a3;
  v23 = v15;
  *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
  return sub_100035B0(a1, v24, &v18);
}
// 1009FB48: using guessed type char *off_1009FB48;
// 1002A6E0: using guessed type char var_10[12];

//----- (1002A840) --------------------------------------------------------
char __cdecl sub_1002A840(int a1, int a2, int a3, unsigned int *a4, int a5)
{
  int v5; // esi@1
  char v6; // bl@1
  __int16 v7; // cx@2
  unsigned int v8; // esi@3
  int v9; // eax@3
  char result; // al@3
  int v11; // ecx@5
  __int16 v12; // di@5
  signed int v13; // eax@5
  unsigned __int16 v14; // ax@8
  int v15; // edi@11
  char v16; // al@11
  int v17; // eax@18
  int v18; // eax@19
  int v19; // eax@22
  signed int v20; // ebx@23
  int v21; // eax@28
  int v22; // eax@31
  signed __int16 v23; // ax@32
  int v24; // edx@32
  int v25; // ebx@43
  int v26; // esi@43
  int v27; // eax@43
  int v28; // ebx@43
  int v29; // esi@47
  int v30; // esi@50
  unsigned __int16 v31; // ax@53
  int *v32; // eax@61
  int v33; // ST1C_4@61
  signed int v34; // eax@61
  unsigned int v35; // ST14_4@61
  int v36; // eax@61
  unsigned int v37; // ST10_4@61
  const char *v38; // ST04_4@61
  char v39; // al@65
  __int16 j; // bx@66
  int v41; // edx@67
  int v42; // ecx@67
  int v43; // eax@67
  int v44; // eax@69
  int v45; // eax@72
  char *v46; // eax@76
  char v47; // dl@77
  int v48; // esi@78
  char i; // bl@78
  int v50; // edx@79
  int v51; // ecx@79
  int v52; // eax@79
  int v53; // eax@81
  int v54; // eax@84
  unsigned int v55; // ST20_4@88
  int *v56; // eax@88
  int v57; // ST1C_4@88
  int v58; // eax@88
  unsigned int v59; // ST10_4@88
  int v60; // eax@88
  int v61; // ST0C_4@88
  const char *v62; // ST04_4@88
  char v63; // [sp+Ch] [bp-28h]@32
  char v64; // [sp+Eh] [bp-26h]@32
  int v65; // [sp+10h] [bp-24h]@11
  char v66; // [sp+14h] [bp-20h]@23
  char v67; // [sp+17h] [bp-1Dh]@23
  int v68; // [sp+1Ch] [bp-18h]@61
  int v69; // [sp+20h] [bp-14h]@61
  int v70; // [sp+24h] [bp-10h]@61
  __int16 v71; // [sp+28h] [bp-Ch]@59
  int v72; // [sp+2Ah] [bp-Ah]@61
  int v73; // [sp+30h] [bp-4h]@61

  v5 = a5;
  v6 = 1;
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v7 = *(_WORD *)(a2 + 10);
      if ( v7 )
      {
        sub_10003860(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(a2 + 4), v7);
        result = 2;
      }
      else
      {
        v8 = *(_DWORD *)(a2 + 4);
        v9 = sub_10029F30(*(_DWORD *)(a2 + 4), *(_BYTE *)(a2 + 8));
        sub_10003860(a1 + 276, *(_DWORD *)a3, v8, v9);
        result = 2;
      }
      return result;
    case 0x8048:
      v11 = *(_DWORD *)(a1 + 56);
      v12 = *(_WORD *)(v11 + 240);
      v13 = *(_WORD *)(a5 + 10);
      if ( v12 == -128 )
      {
        if ( v13 != 56 )
        {
          if ( v13 != 0x2000 )
            return v6;
          v14 = *(_WORD *)(a5 + 14);
          if ( (v14 < 0x41u || v14 > 0x5Au) && v14 != 32 )
          {
            if ( v14 < 0x30u || v14 > 0x39u )
              return v6;
            sub_10038E00((int)&v65, *a4);
            v15 = a2;
            sub_10029F90((int)&v65, (char *)(*(_DWORD *)(a1 + 56) + 69), *(_BYTE *)(a2 + 8));
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = dword_1009FB54[7 * *(_BYTE *)(a2 + 8)];
            sub_10029FF0(a2, a1);
            v16 = sub_1002A4D0(a2, a1, v5);
          }
          else
          {
            sub_10038E00((int)&v65, *a4);
            v15 = a2;
            sub_10029F90((int)&v65, (char *)(*(_DWORD *)(a1 + 56) + 69), *(_BYTE *)(a2 + 8));
            v16 = sub_1002A1C0(a1, a2, v5);
          }
LABEL_57:
          v6 = v16;
          if ( v16 != 4 && v16 != 2 )
            return v6;
          goto LABEL_59;
        }
        sub_10038E00((int)&v65, *a4);
        sub_10029F90((int)&v65, (char *)(*(_DWORD *)(a1 + 56) + 69), *(_BYTE *)(a2 + 8));
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = 0;
        sub_10029FF0(a2, a1);
        v6 = 4;
        v15 = a2;
LABEL_59:
        v71 = *(_WORD *)(v15 + 10);
        if ( !v71 )
          v71 = sub_10029F30(*(_DWORD *)(v15 + 4), *(_BYTE *)(v15 + 8));
        v32 = sub_10002E60(*(_DWORD *)(v15 + 4));
        v33 = *(_DWORD *)(v15 + 4);
        v68 = v32[1];
        v34 = sub_10002EA0(v33);
        v35 = *(_DWORD *)(v15 + 4);
        v69 = v34;
        v36 = sub_100035F0(v35, 0);
        v37 = *(_DWORD *)(v15 + 4);
        v70 = v36;
        v72 = sub_10002E30(v37);
        v73 = sub_10002ED0(*(_DWORD *)(v15 + 4));
        *(_WORD *)(a1 + 438) = *(_WORD *)a3;
        v38 = (const char *)(*(_DWORD *)(a1 + 56) + 69);
        *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
        sub_100035B0(a1, v38, &v68);
        return v6;
      }
      if ( v13 > 56 )
      {
        if ( v13 == 57 )
        {
          v39 = *(_BYTE *)(a5 + 8);
          if ( v39 >= 0 )
          {
            if ( v39 <= 0 )
              return v6;
            v46 = (char *)(v11 + 69);
            do
              v47 = *v46++;
            while ( v47 );
            v48 = (int)&v46[-v11 - 70];
            for ( i = (*(_WORD *)(v11 + 240))++; *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v48; ++*(_WORD *)(v50 + 240) )
            {
              v50 = *(_DWORD *)(a1 + 56);
              v51 = *(_WORD *)(v50 + 240);
              v52 = 7 * *(_BYTE *)(a2 + 8);
              if ( v51 == dword_1009FB50[v52] )
                break;
              if ( v51 == dword_1009FB54[v52] )
                break;
              v53 = dword_1009FB58[v52];
              if ( v51 == v53 )
                break;
              if ( v51 == v53 + 1 )
                break;
            }
            v54 = *(_DWORD *)(a1 + 56);
            if ( *(_WORD *)(v54 + 240) >= v48 )
            {
              *(_WORD *)(v54 + 240) = i;
              return 0;
            }
          }
          else
          {
            for ( j = (*(_WORD *)(v11 + 240))--; *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) >= 0; --*(_WORD *)(v41 + 240) )
            {
              v41 = *(_DWORD *)(a1 + 56);
              v42 = *(_WORD *)(v41 + 240);
              v43 = 7 * *(_BYTE *)(a2 + 8);
              if ( v42 == dword_1009FB50[v43] )
                break;
              if ( v42 == dword_1009FB54[v43] )
                break;
              v44 = dword_1009FB58[v43];
              if ( v42 == v44 )
                break;
              if ( v42 == v44 + 1 )
                break;
            }
            v45 = *(_DWORD *)(a1 + 56);
            if ( *(_WORD *)(v45 + 240) < 0 )
            {
              *(_WORD *)(v45 + 240) = (char)j;
              return 0;
            }
          }
          sub_10029FF0(a2, a1);
          v15 = a2;
          v6 = 2;
          goto LABEL_59;
        }
        if ( v13 != 0x2000 )
          return v6;
        v31 = *(_WORD *)(a5 + 14);
        if ( (v31 < 0x41u || v31 > 0x5Au) && v31 != 32 )
        {
          if ( v31 < 0x30u || v31 > 0x39u )
            return v6;
          v15 = a2;
          v16 = sub_1002A4D0(a2, a1, a5);
        }
        else
        {
          v15 = a2;
          v16 = sub_1002A1C0(a1, a2, a5);
        }
        goto LABEL_57;
      }
      if ( v13 == 56 )
      {
        v25 = *(_BYTE *)(a5 + 8) < 0;
        LOBYTE(v25) = *(_BYTE *)(a5 + 8) >= 0;
        v26 = dword_1009FB50[7 * *(_BYTE *)(a2 + 8)];
        v27 = 7 * *(_BYTE *)(a2 + 8);
        v28 = 2 * v25 - 1;
        if ( v12 != v26 && v12 != v26 + 1 && v12 != v26 + 2 )
        {
          v29 = dword_1009FB54[v27];
          if ( v12 != v29 && v12 != v29 + 1 )
          {
            *(_BYTE *)(v11 + 242) = 1;
            v30 = *(_DWORD *)(a1 + 56);
            v15 = a2;
            *(_BYTE *)(*(_WORD *)(v30 + 240) + v30 + 69) = sub_10038B70(
                                                             *(_BYTE *)(*(_WORD *)(v30 + 240) + v30 + 69),
                                                             0x10u,
                                                             v28);
            v6 = 2;
          }
          else
          {
            *(_WORD *)(v11 + 240) = dword_1009FB54[v27];
            *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 2;
            sub_1002A040(v11, a1, a2, v28);
            v6 = 2;
            v15 = a2;
          }
        }
        else
        {
          v15 = a2;
          *(_WORD *)(v11 + 240) = dword_1009FB50[v27];
          *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 3;
          sub_1002A0E0(v11, a1, a2, v28);
          v6 = 2;
        }
        goto LABEL_59;
      }
      v17 = v13 - 32;
      if ( !v17 )
        goto LABEL_21;
      v18 = v17 - 1;
      if ( v18 )
      {
        if ( v18 != 7 )
          return v6;
LABEL_21:
        *(_WORD *)(v11 + 240) = -128;
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
        sub_1002A6E0(a1, a2, a3, a4);
        return 6;
      }
      *(_WORD *)(v11 + 240) = -128;
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
      v19 = dword_1009FB50[7 * *(_BYTE *)(a2 + 8)];
      v65 = 130416897;
      if ( v19 != -1 )
      {
        strncpy(&v66, (const char *)(v19 + *(_DWORD *)(a1 + 56) + 69), 3u);
        v67 = 0;
        v20 = 11;
        do
        {
          if ( !strcmp(&v66, sub_10037280(word_100A5C38[v20])) )
            break;
          --v20;
        }
        while ( v20 >= 0 );
        LOBYTE(v65) = 13;
        if ( v20 >= 0 )
          LOBYTE(v65) = v20 + 1;
      }
      v21 = dword_1009FB54[7 * *(_BYTE *)(a2 + 8)];
      if ( v21 != -1 )
      {
        strncpy((char *)&a5, (const char *)(v21 + *(_DWORD *)(a1 + 56) + 69), 2u);
        BYTE2(a5) = 0;
        BYTE1(v65) = j__atol((const char *)&a5);
        if ( !BYTE1(v65) )
          BYTE1(v65) = 1;
      }
      v22 = dword_1009FB58[7 * *(_BYTE *)(a2 + 8)];
      if ( v22 == -1 )
      {
        LOWORD(v24) = HIWORD(v65);
      }
      else
      {
        strncpy(&v63, (const char *)(v22 + *(_DWORD *)(a1 + 56) + 69), 2u);
        v64 = 0;
        v23 = j__atol(&v63);
        v24 = (unsigned __int16)v23 % 100 + 1900;
        HIWORD(v65) = (unsigned __int16)v23 % 100 + 1900;
        if ( (unsigned __int16)v24 < 0x7C6u )
        {
          LOWORD(v24) = (unsigned __int16)v23 % 100 + 2000;
          HIWORD(v65) = (unsigned __int16)v23 % 100 + 2000;
        }
      }
      if ( (unsigned __int8)(v65 - 1) > 0xBu
        || (unsigned __int8)(BYTE1(v65) - 1) > 0x1Eu
        || BYTE1(v65) > (unsigned __int8)byte_100C7EE7[(unsigned __int8)v65]
        && (BYTE1(v65) != 29 || (_BYTE)v65 != 2 || (unsigned __int16)v24 % 4) )
      {
        sub_1002A6E0(a1, a2, a3, a4);
        result = 0;
      }
      else
      {
        sub_10038EF0((int *)a4, v65);
        sub_1002A6E0(a1, a2, a3, a4);
        result = 3;
      }
      return result;
    case 0x8022:
    case 0x8078:
      if ( !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
      {
        sub_1002A6E0(a1, a2, a3, a4);
        return v6;
      }
      v55 = *(_DWORD *)(a2 + 4);
      v71 = 0;
      v56 = sub_10002E60(v55);
      v57 = *(_DWORD *)(a2 + 4);
      v68 = v56[1];
      v69 = sub_10002EA0(v57);
      v58 = sub_100035F0(*(_DWORD *)(a2 + 4), 0);
      v59 = *(_DWORD *)(a2 + 4);
      v70 = v58;
      v60 = sub_10002E30(v59);
      v61 = *(_DWORD *)(a2 + 4);
      v72 = v60;
      v73 = sub_10002ED0(v61);
      *(_WORD *)(a1 + 438) = *(_WORD *)a3;
      v62 = (const char *)(*(_DWORD *)(a1 + 56) + 69);
      *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
      sub_100035B0(a1, v62, &v68);
      return 1;
    default:
      return v6;
  }
}
// 1009FB50: using guessed type int dword_1009FB50[];
// 1009FB54: using guessed type int dword_1009FB54[];
// 1009FB58: using guessed type int dword_1009FB58[];
// 100A5C38: using guessed type __int16 word_100A5C38[];

//----- (1002B120) --------------------------------------------------------
char __cdecl sub_1002B120(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1

  result = 1;
  if ( *a5 == 32802 || *a5 == 32888 )
  {
    if ( !(*(_WORD *)(a2 + 6) & 0x400) )
    {
      *(_WORD *)(a1 + 440) = *(_WORD *)(a4 + 2);
      *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
      sub_1001E190(a1 + 392, *(_WORD *)a3, *(_WORD *)(a3 + 2), *(_WORD *)(a2 + 4), 1);
    }
    *(_WORD *)(a1 + 428) = *(_WORD *)a4;
    *(_WORD *)(a1 + 430) = *(_WORD *)a4;
    sub_1001E190(a1 + 392, *(_WORD *)a3, *(_WORD *)(a3 + 2), *(_WORD *)(a2 + 4), 0);
    result = 2;
  }
  return result;
}

//----- (1002B1D0) --------------------------------------------------------
char __cdecl sub_1002B1D0(int a1, int a2, int a3, _WORD *a4, _WORD *a5)
{
  bool v5; // zf@1
  int v6; // edx@1
  unsigned int v7; // eax@2
  __int16 v8; // dx@4
  __int16 v9; // ax@4
  int v11; // [sp+0h] [bp-8h]@1
  int v12; // [sp+4h] [bp-4h]@1

  v5 = *(_WORD *)(a2 + 6) == -1;
  v6 = *(_DWORD *)(a2 + 4);
  v11 = *(_DWORD *)a2;
  v12 = v6;
  if ( v5 )
  {
    HIWORD(v12) = *a4;
    v7 = HIWORD(v12);
  }
  else
  {
    v7 = *(_WORD *)(a2 + 6);
  }
  v8 = word_1065DED0[v7 & 0x1F];
  v9 = word_1065DED0[(v7 >> 5) & 0x1F];
  LOWORD(a2) = v8;
  HIWORD(a2) = v9;
  return sub_1002B120(a1, (int)&v11, a3, (int)&a2, a5);
}
// 1065DED0: using guessed type __int16 word_1065DED0[];

//----- (1002B250) --------------------------------------------------------
char __usercall sub_1002B250@<al>(unsigned __int16 *a1@<eax>, int a2@<ebx>, int a3@<edi>, unsigned int a4@<esi>, int a5)
{
  char *v5; // ebp@1
  int *v6; // eax@1
  __int16 v7; // cx@1
  signed int v8; // eax@1
  __int16 v9; // dx@1
  int v10; // ecx@1
  int v12; // [sp+4h] [bp-18h]@1
  int v13; // [sp+8h] [bp-14h]@1
  int v14; // [sp+Ch] [bp-10h]@1
  __int16 v15; // [sp+10h] [bp-Ch]@1
  int v16; // [sp+12h] [bp-Ah]@1
  int v17; // [sp+18h] [bp-4h]@1

  v5 = sub_10037280(*a1);
  v13 = sub_10002EA0(a4);
  v14 = sub_100035F0(a4, 0);
  v16 = sub_10002E30(a4);
  v6 = sub_10002E60(a4);
  v7 = *(_WORD *)(a5 + 8);
  v12 = *v6;
  v15 = v7;
  v8 = sub_10002ED0(a4);
  v9 = *(_WORD *)a2;
  v10 = v12;
  v17 = v8;
  *(_WORD *)(a3 + 438) = v9;
  *(_WORD *)(a3 + 436) = *(_WORD *)(a2 + 2);
  return sub_10003650(a3, v5, &v12, *(_WORD *)(v10 + 30));
}

//----- (1002B2E0) --------------------------------------------------------
char __cdecl sub_1002B2E0(int a1, int a2, int *a3, int a4, _WORD *a5)
{
  int v5; // ebp@1
  char v6; // cl@1
  char v7; // dl@1
  unsigned int v8; // esi@1
  char result; // al@1
  int v10; // edi@2
  int v11; // ecx@3
  int v12; // edx@3
  int v13; // esi@7
  char v14; // bl@9
  char v15; // [sp+14h] [bp+8h]@1

  v5 = a2;
  v6 = (*(_DWORD *)(a2 + 4) >> 5) & 0x1F;
  v7 = *(_BYTE *)(a2 + 4) & 0x1F;
  v8 = *(_DWORD *)(a2 + 4) & 0xFFFFFC00;
  v15 = (*(_DWORD *)(a2 + 4) >> 5) & 0x1F;
  result = 1;
  switch ( *a5 )
  {
    case 0x8015:
      v10 = a4;
      if ( *(_BYTE *)(a4 + 2) )
        return 2;
      v11 = v6 & 0x1F;
      v12 = v7 & 0x1F;
      if ( *(_BYTE *)(a4 + 3) != 1 )
        goto LABEL_14;
      goto LABEL_16;
    case 0x8016:
      v10 = a4;
      if ( !*(_BYTE *)(a4 + 2) )
        goto LABEL_6;
      return 2;
    case 0x8040:
      sub_10003860(a1 + 276, *a3, *(_DWORD *)(v5 + 4), *(_WORD *)(v5 + 8));
      return 2;
    case 0x8022:
    case 0x8078:
      v10 = a4;
      v14 = *(_BYTE *)(a4 + 2);
      if ( v14 == 2 )
      {
        v13 = v6 & 0x1F | 32 * (v7 & 0x1F) | v8;
        goto LABEL_17;
      }
      if ( v14 == 1 )
        goto LABEL_15;
      if ( byte_10756F5E )
      {
        v11 = v6 & 0x1F;
        v12 = v7 & 0x1F;
        if ( *(_BYTE *)(a4 + 3) != 1 )
        {
LABEL_14:
          v13 = v11 | 32 * v12 | v8;
          goto LABEL_17;
        }
      }
      else
      {
LABEL_6:
        if ( *(_BYTE *)(v10 + 3) == 1 )
        {
          v13 = v15 & 0x1F | 32 * (v15 & 0x1F) | v8;
          goto LABEL_17;
        }
LABEL_15:
        v11 = v6 & 0x1F;
        v12 = v7 & 0x1F;
      }
LABEL_16:
      v13 = v12 | 32 * v11 | v8;
LABEL_17:
      sub_1002B250((unsigned __int16 *)v10, (int)a3, a1, v13, v5);
      return 2;
    default:
      return result;
  }
}
// 10756F5E: using guessed type char byte_10756F5E;

//----- (1002B480) --------------------------------------------------------
char __cdecl sub_1002B480(int a1, int a2, int a3, _BYTE *a4, _WORD *a5)
{
  _BYTE *v5; // ebp@1
  __int16 v6; // ax@1
  __int16 v7; // si@1
  __int16 v8; // di@1
  char result; // al@1
  int v10; // eax@3
  __int16 v11; // ax@6
  __int16 v12; // cx@10
  __int16 v13; // di@16
  char v14; // [sp+Fh] [bp-15h]@1
  __int16 v15; // [sp+10h] [bp-14h]@1
  __int16 v16; // [sp+14h] [bp-10h]@3
  __int16 v17; // [sp+16h] [bp-Eh]@3
  __int16 v18; // [sp+18h] [bp-Ch]@3
  __int16 v19; // [sp+1Ah] [bp-Ah]@3
  __int16 v20; // [sp+1Ch] [bp-8h]@3
  __int16 v21; // [sp+1Eh] [bp-6h]@3
  __int16 v22; // [sp+20h] [bp-4h]@3
  __int16 v23; // [sp+22h] [bp-2h]@3
  int v24; // [sp+30h] [bp+Ch]@13
  bool v25; // [sp+34h] [bp+10h]@1
  unsigned int v26; // [sp+38h] [bp+14h]@3

  v5 = a4;
  v6 = word_1065DED0[*a4 & 0x1F];
  v14 = *a4 & 0x60;
  v7 = *(_WORD *)(a3 + 2);
  v25 = (*a4 & 0x80) == -128;
  v8 = *(_WORD *)a3;
  v15 = v6;
  result = 1;
  if ( *a5 == 32802 || *a5 == 32888 )
  {
    v10 = sub_10004F90(a1, 56);
    *(_WORD *)(a1 + 428) = v15;
    *(_WORD *)(a1 + 430) = v15;
    *(_WORD *)(a1 + 440) = v15;
    *(_WORD *)(a1 + 442) = v15;
    v19 = v7 - 14;
    v21 = v7 - 7;
    v26 = v10;
    *(_WORD *)(a1 + 396) = 3;
    v17 = v7;
    v23 = v7;
    v16 = v8;
    v18 = v8;
    v20 = v8 + 7 * (2 * (v25 == 0) - 1);
    v22 = v8;
    sub_100818F0(a1 + 392, 4, (int)&v16, 56, v10);
    if ( v14 == 32 || v14 == 64 )
    {
      v11 = v25 ? v8 : v8 - *((_WORD *)v5 + 1) + 2;
      sub_1001EC10(a1 + 392, v11, v7 - 9, *((_WORD *)v5 + 1) - 2, 5, 3);
      if ( v14 == 64 )
      {
        if ( v25 )
          v12 = v8 + *((_WORD *)v5 + 1) - 5;
        else
          v12 = v8 - *((_WORD *)v5 + 1);
        sub_1001EC10(a1 + 392, v12, v7 - *((_WORD *)v5 + 2) + 2, 5, *((_WORD *)v5 + 2) - 8, 3);
        sub_1001EC10(a1 + 392, v8 - *((_WORD *)v5 + 1) + 2, v7 - *((_WORD *)v5 + 2), *((_WORD *)v5 + 1) + 5, 5, 3);
        if ( v25 )
          v24 = (unsigned __int16)(v8 + *((_WORD *)v5 + 1) - 2);
        else
          v24 = (unsigned __int16)(v8 - *((_WORD *)v5 + 1) + 1);
        sub_10022310(a1 + 392, v24, v7 - 6);
        sub_10022310(a1 + 392, v24, v7 - *((_WORD *)v5 + 2) + 1);
        if ( v25 )
          v13 = v8 + *((_WORD *)v5 + 1) - 6;
        else
          v13 = v8 - *((_WORD *)v5 + 1) + 5;
        sub_10022310(a1 + 392, v13, v7 - 10);
        sub_10022310(a1 + 392, v13, v7 - *((_WORD *)v5 + 2) + 5);
      }
    }
    sub_10004BF0(a1, v26);
    result = 2;
  }
  return result;
}
// 1065DED0: using guessed type __int16 word_1065DED0[];

//----- (1002B700) --------------------------------------------------------
int __cdecl sub_1002B700(float a1, float a2)
{
  float *v2; // ecx@0
  double v3; // st7@1
  double v4; // st7@3
  bool v5; // c0@3
  bool v6; // c3@3
  int result; // eax@4

  v3 = a1;
  if ( (COERCE_UNSIGNED_INT(*v2) & 0x7F800000) != 2139095040
    && *v2 <= v3
    && (v4 = *v2, v5 = a2 < v4, v6 = a2 == v4, v3 = a2, v5 || v6) )
  {
    result = 1;
  }
  else
  {
    *v2 = v3;
    result = 0;
  }
  return result;
}

//----- (1002B750) --------------------------------------------------------
void __cdecl sub_1002B750(int a1)
{
  int v1; // ecx@0
  int v2; // esi@1
  double v3; // st7@1
  int v4; // ecx@1
  int v5; // edx@1
  double v6; // st7@1
  double v7; // st7@1
  double v8; // st7@1
  double v9; // st7@1
  double v10; // st7@1
  size_t v11; // ebp@1
  bool v12; // c3@1
  char *v13; // ebx@1
  int v14; // eax@1
  const char *v15; // edi@20
  char v16; // al@22
  char *v17; // ecx@23
  int v18; // ecx@33
  signed int v19; // ST20_4@33
  _BYTE *v20; // esi@38
  _BYTE *v21; // ST0C_4@39
  float v22; // [sp+20h] [bp-6Ch]@20
  int v23; // [sp+24h] [bp-68h]@1
  int v24; // [sp+28h] [bp-64h]@1
  int v25; // [sp+2Ch] [bp-60h]@1
  float v26; // [sp+30h] [bp-5Ch]@1
  float v27; // [sp+34h] [bp-58h]@1
  int v28; // [sp+38h] [bp-54h]@1
  float v29; // [sp+3Ch] [bp-50h]@1
  int v30; // [sp+40h] [bp-4Ch]@1
  int v31; // [sp+44h] [bp-48h]@1
  float v32; // [sp+48h] [bp-44h]@1
  float v33; // [sp+4Ch] [bp-40h]@1
  float v34; // [sp+50h] [bp-3Ch]@1
  char v35[4]; // [sp+54h] [bp-38h]@1
  int v36; // [sp+58h] [bp-34h]@1
  int v37; // [sp+5Ch] [bp-30h]@1
  int v38; // [sp+60h] [bp-2Ch]@1
  char v39[4]; // [sp+64h] [bp-28h]@1
  int v40; // [sp+68h] [bp-24h]@1
  int v41; // [sp+6Ch] [bp-20h]@1
  int v42; // [sp+70h] [bp-1Ch]@1
  char v43; // [sp+74h] [bp-18h]@22

  v2 = v1;
  v3 = *(float *)(v1 + 12);
  v4 = *(_DWORD *)(v1 + 60);
  v26 = v3;
  v5 = *(_DWORD *)(v2 + 20);
  v6 = *(float *)(v2 + 16);
  v25 = a1;
  v27 = v6;
  v7 = *(float *)(v2 + 36);
  *(_DWORD *)v35 = 0;
  v29 = v7;
  v36 = 0;
  v8 = *(float *)(v2 + 28);
  v37 = 0;
  v32 = v8;
  v38 = 0;
  v9 = *(float *)(v2 + 32);
  *(_DWORD *)v39 = 0;
  v33 = v9;
  v40 = 0;
  v10 = *(float *)(v2 + 40);
  v41 = 0;
  v34 = v10;
  v42 = 0;
  v23 = *(int *)(v2 + 56);
  v31 = *(_DWORD *)(v2 + 24);
  v11 = 0;
  v12 = 9.8999998e24 == *(float *)(v2 + 56);
  v28 = v4;
  v30 = v5;
  LOBYTE(v24) = 31;
  v13 = v35;
  v14 = *(_WORD *)v2;
  if ( v12 )
  {
    v15 = (const char *)sub_10037AC0(v14);
    v22 = sub_1003FD90(COERCE_INT(*(float *)(v2 + 48)), *(_WORD *)v2, *(_BYTE *)(v2 + 8), (char *)&v24);
    switch ( *(_WORD *)v2 )
    {
      case 2:
      case 3:
      case 8:
      case 9:
      case 0xA:
      case 0x1C:
      case 0x32:
        if ( v15 )
        {
          sprintf(&v43, v15, v22);
          v16 = v43;
          if ( v43 )
          {
            v17 = &v43;
            do
            {
              if ( (unsigned __int8)v16 >= 0x30u && (unsigned __int8)v16 <= 0x39u )
                ++v11;
              v16 = (v17++)[1];
            }
            while ( v16 );
          }
        }
        else
        {
          v11 = 5;
        }
        memset(v35, 95, v11);
        v35[v11] = 0;
        break;
      default:
        v13 = 0;
        break;
    }
    if ( *(_BYTE *)(v2 + 64) )
    {
      v18 = *(_DWORD *)(v2 + 68);
      v19 = (signed int)(*(float *)(v2 + 36) * 0.5);
      v30 = 0;
      v31 = v18;
      v27 = v27 - (double)v19;
    }
  }
  else
  {
    switch ( v14 )
    {
      case 3:
        if ( *(float *)(v2 + 56) >= 0.0 )
          strcpy(v35, "UP %.2f");
        else
          strcpy(v35, "DN %.2f");
        break;
      case 2:
        if ( *(float *)(v2 + 56) <= 0.0 )
          strcpy(v35, "L %.0f");
        else
          strcpy(v35, "R %.0f");
        break;
      case 8:
      case 10:
      case 50:
        sub_100365D0((int)v35, "%.0f", 16);
        break;
      case 9:
      case 12:
        sub_100365D0((int)v35, "%.1f", 16);
        break;
      case 28:
        if ( *(float *)(v2 + 56) >= 0.0 )
        {
          if ( *(float *)(v2 + 56) <= 0.0 )
            strcpy(v35, "%.0f");
          else
            strcpy(v35, "%.0f");
        }
        else
        {
          strcpy(v35, "%.0f");
        }
        break;
      default:
        v13 = 0;
        break;
    }
    if ( *(_BYTE *)(v2 + 10) )
      v23 = COERCE_UNSIGNED_INT(*(float *)(v2 + 56)) & 0x7FFFFFFF;
    *(float *)&v23 = sub_1003FD90(v23, *(_WORD *)v2, *(_BYTE *)(v2 + 8), (char *)&v24);
  }
  if ( v13 )
  {
    if ( 9.8999998e24 == *(float *)(v2 + 56) )
      sub_100365D0((int)v39, v35, 16);
    else
      sub_10036790(v39, 0x10u, v35, v23);
    v20 = *(_BYTE **)(v2 + 4);
    if ( v20 )
    {
      sub_100367C0(v39, v20, 16);
    }
    else
    {
      v21 = (_BYTE *)sub_10037710(v24);
      sub_100367C0(v39, v21, 16);
    }
    sub_1003D350(v25, (int)v39, (int)&v26);
  }
}

//----- (1002BB80) --------------------------------------------------------
char __cdecl sub_1002BB80(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // edx@2
  int v6; // ecx@2
  double v7; // st7@2
  int v8; // ecx@2
  double v9; // st7@2
  char result; // al@2
  bool v11; // zf@4
  float *v12; // edi@4
  double v13; // st7@4
  float v14; // [sp+14h] [bp-24h]@2
  float v15; // [sp+18h] [bp-20h]@2
  int v16; // [sp+1Ch] [bp-1Ch]@2
  float v17; // [sp+20h] [bp-18h]@2
  int v18; // [sp+24h] [bp-14h]@2
  int v19; // [sp+28h] [bp-10h]@2
  float v20; // [sp+2Ch] [bp-Ch]@2
  float v21; // [sp+30h] [bp-8h]@2
  float v22; // [sp+34h] [bp-4h]@2
  float v23; // [sp+4Ch] [bp+14h]@4
  float v24; // [sp+4Ch] [bp+14h]@4

  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v5 = *(_DWORD *)(a4 + 20);
      v6 = *(_DWORD *)(a4 + 60);
      v14 = *(float *)(a4 + 12);
      v7 = *(float *)(a4 + 16);
      v18 = v5;
      v15 = v7;
      v17 = *(float *)(a4 + 36);
      v16 = v6;
      v8 = *(_DWORD *)(a4 + 24);
      v20 = *(float *)(a4 + 28);
      v9 = *(float *)(a4 + 32);
      v19 = v8;
      v21 = v9;
      v22 = *(float *)(a4 + 40);
      sub_1003D230(a1, (int)byte_10084570, (int)&v14);
      result = 2;
      break;
    case 0x8048:
      if ( *(_WORD *)(a5 + 10) != 56 )
        goto LABEL_11;
      v11 = *(_BYTE *)(a4 + 9) == 0;
      v12 = (float *)(a4 + 56);
      v23 = (double)*(_BYTE *)(a5 + 8) * *(float *)(a4 + 52);
      v24 = v23 + *(float *)(a4 + 56);
      v13 = v24;
      *(float *)(a4 + 56) = v24;
      if ( !v11 )
      {
        if ( *(float *)(a4 + 48) >= v13 )
        {
          if ( *(float *)(a4 + 44) > v13 )
            *v12 = *(float *)(a4 + 48);
        }
        else
        {
          *v12 = *(float *)(a4 + 44);
        }
      }
      sub_1002B700(*(float *)(a4 + 48), *(float *)(a4 + 44));
      *v12 = sub_10022C70(*v12, COERCE_FLOAT(COERCE_UNSIGNED_INT(*(float *)(a4 + 52)) & 0x7FFFFFFF));
      sub_1002B750(a1);
      result = 3;
      break;
    case 0x8022:
    case 0x8078:
      sub_1002B750(a1);
      goto LABEL_11;
    default:
LABEL_11:
      result = 1;
      break;
  }
  return result;
}

//----- (1002BD50) --------------------------------------------------------
int __usercall sub_1002BD50@<eax>(int a1@<ecx>, int a2@<esi>)
{
  int v2; // edi@1
  int v3; // eax@1
  int v4; // ecx@1
  int v5; // edx@1
  double v6; // st7@1
  double v7; // st7@1
  __int16 v8; // ax@1
  int v9; // ecx@1
  int v10; // edi@1
  float v11; // ST28_4@6
  float v12; // ST24_4@6
  float v13; // ST20_4@6
  float v14; // ST20_4@6
  float v16; // [sp+2Ch] [bp-5Ch]@1
  float v17; // [sp+30h] [bp-58h]@1
  int v18; // [sp+34h] [bp-54h]@1
  float v19; // [sp+38h] [bp-50h]@1
  int v20; // [sp+3Ch] [bp-4Ch]@1
  int v21; // [sp+40h] [bp-48h]@1
  float v22; // [sp+44h] [bp-44h]@1
  float v23; // [sp+48h] [bp-40h]@1
  float v24; // [sp+4Ch] [bp-3Ch]@1
  char v25; // [sp+50h] [bp-38h]@1

  v2 = a1;
  (*(void (__cdecl **)(int, _DWORD, char *))(a2 + 40))(a1, *(_WORD *)(a2 + 2), &v25);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)(a2 + 12);
  v5 = *(_DWORD *)(a2 + 16);
  v16 = *(float *)(a2 + 24);
  v6 = *(float *)(a2 + 28);
  v18 = v3;
  v17 = v6;
  v7 = *(float *)(a2 + 8);
  v20 = v4;
  v19 = v7;
  v22 = *(float *)(a2 + 32);
  v23 = *(float *)(a2 + 36);
  v21 = v5;
  v24 = *(float *)(a2 + 20);
  sub_1003D350(v2, (int)&v25, (int)&v16);
  v8 = *(_WORD *)(a2 + 2);
  v9 = -16711936;
  v10 = -16711936;
  if ( !v8 )
    v9 = -12566464;
  if ( v8 == *(_WORD *)a2 - 1 || !*(_WORD *)a2 )
    v10 = -12566464;
  v11 = *(float *)(a2 + 24) - *(float *)(a2 + 20) * *(float *)(a2 + 32);
  v12 = (0.5 - *(float *)(a2 + 36)) * *(float *)(a2 + 8) + *(float *)(a2 + 28);
  v13 = v11 - *(float *)(a2 + 8) - 5.0;
  sub_10040E80(v13, v12, *(float *)(a2 + 8), *(float *)(a2 + 8), COERCE_FLOAT(2), v9, -16777216);
  v14 = *(float *)(a2 + 20) + v11 + *(float *)(a2 + 8) + 5.0;
  return sub_10040E80(v14, v12, *(float *)(a2 + 8), *(float *)(a2 + 8), COERCE_FLOAT(3), v10, -16777216);
}

//----- (1002BEB0) --------------------------------------------------------
char __cdecl sub_1002BEB0(int a1, int a2, int a3, int a4, int a5)
{
  char result; // al@1
  int v6; // edx@2
  int v7; // eax@2
  int v8; // ecx@2
  double v9; // st7@2
  int v10; // eax@4
  __int16 v11; // di@4
  __int16 v12; // cx@4
  __int16 v13; // cx@4
  int v14; // eax@4
  int v15; // eax@4
  float v16; // [sp+8h] [bp-F4h]@2
  float v17; // [sp+Ch] [bp-F0h]@2
  int v18; // [sp+10h] [bp-ECh]@2
  float v19; // [sp+14h] [bp-E8h]@2
  int v20; // [sp+18h] [bp-E4h]@2
  int v21; // [sp+1Ch] [bp-E0h]@2
  float v22; // [sp+20h] [bp-DCh]@2
  float v23; // [sp+24h] [bp-D8h]@2
  float v24; // [sp+28h] [bp-D4h]@2
  __int16 v25; // [sp+2Ch] [bp-D0h]@7
  int v26; // [sp+30h] [bp-CCh]@7
  __int16 v27; // [sp+34h] [bp-C8h]@7

  result = 1;
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v6 = *(_DWORD *)(a4 + 4);
      v7 = *(_DWORD *)(a4 + 12);
      v16 = *(float *)(a4 + 24);
      v8 = *(_DWORD *)(a4 + 16);
      v17 = *(float *)(a4 + 28);
      v18 = v6;
      v19 = *(float *)(a4 + 8);
      v22 = *(float *)(a4 + 32);
      v9 = *(float *)(a4 + 36);
      v20 = v7;
      v23 = v9;
      v21 = v8;
      v24 = *(float *)(a4 + 20);
      sub_1003D230(a1, (int)byte_10084570, (int)&v16);
      goto LABEL_9;
    case 0x8048:
      if ( *(_WORD *)(a5 + 10) != 56 )
        return result;
      v10 = (signed __int16)(*(_WORD *)(a4 + 2) + *(_BYTE *)(a5 + 8));
      v11 = *(_WORD *)(a4 + 2);
      v12 = v10 < 0;
      LOBYTE(v12) = v10 <= 0;
      v13 = v10 & (v12 - 1);
      v14 = *(_WORD *)a4;
      *(_WORD *)(a4 + 2) = v13;
      v15 = v14 - 1;
      if ( v13 < v15 )
        LOWORD(v15) = v13;
      *(_WORD *)(a4 + 2) = v15;
      sub_1002BD50(a1, a4);
      if ( v11 != *(_WORD *)(a4 + 2) )
      {
        v27 = *(_WORD *)(a4 + 2);
        v26 = 0;
        v25 = -32738;
        sub_10003E50(a1, (int)&v25, 204);
      }
      goto LABEL_9;
    case 0x8022:
    case 0x8078:
      sub_1002BD50(a1, a4);
LABEL_9:
      result = 2;
      break;
    default:
      return result;
  }
  return result;
}

//----- (1002C050) --------------------------------------------------------
int __usercall sub_1002C050@<eax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // edi@1
  int v4; // ebp@1
  int v5; // ebx@2
  int v6; // eax@2
  int v7; // eax@2
  int v8; // eax@3
  float v9; // ST2C_4@3
  float v10; // ST10_4@3
  float v11; // ST2C_4@3
  int v12; // eax@3
  float v13; // ST2C_4@3
  int v14; // eax@3
  float v15; // ST2C_4@3
  int v16; // ST14_4@3
  int v17; // eax@5
  int v18; // eax@6
  double v19; // st7@6
  double v20; // st6@6
  double v21; // st7@6
  int v22; // eax@7
  double v23; // st7@7
  double v24; // st6@7
  int v25; // eax@8
  double v26; // st7@8
  double v27; // rtt@8
  double v28; // st6@8
  double v29; // rt0@8
  int v30; // eax@9
  double v31; // st7@9
  double v32; // st6@9
  float v33; // ST28_4@10
  int v35; // [sp+10h] [bp-1Ch]@0
  float v36; // [sp+1Ch] [bp-10h]@6
  float v37; // [sp+20h] [bp-Ch]@6
  signed int v38; // [sp+28h] [bp-4h]@1
  float v39; // [sp+28h] [bp-4h]@6

  v3 = (*(_BYTE *)(a1 + 1) << 6) + a1 + 8;
  j_gdi_pvg_bind_video_cap_as_textmap();
  j_gdi_pvg_enable(34);
  j_gdi_pvg_push_matrix();
  sub_10069AB0(1.0, 1.0, 1.0, 1.0);
  j_gdi_pvg_begin(72);
  v4 = 0;
  v38 = 4;
  do
  {
    v5 = (v4 + *(_BYTE *)(v3 + 28)) % 4;
    v6 = 2 * (v4 + 4 * *(_BYTE *)(a2 + 12));
    sub_10069DB0(flt_104E6D08[v6], flt_104E6D0C[v6]);
    v7 = 2 * ((unsigned __int8)v5 + 4 * *(_BYTE *)(a2 + 12));
    sub_10069EF0(flt_104E6DB0[v7], flt_104E6DB4[v7]);
    ++v4;
    --v38;
  }
  while ( v38 );
  j_gdi_pvg_end(v35);
  j_gdi_pvg_disable(34);
  j_gdi_pvg_pop_matrix();
  j_gdi_pvg_color_u32(-16777216);
  sub_10069C80(2.0);
  j_gdi_pvg_begin(66);
  v8 = 8 * *(_BYTE *)(a2 + 12);
  v9 = flt_104E6DB4[v8] - 1.0;
  v10 = v9;
  v11 = flt_104E6DB0[v8] - 1.0;
  sub_10069EF0(v11, v10);
  v12 = 8 * *(_BYTE *)(a2 + 12);
  v13 = flt_104E6DB4[v12] - 1.0;
  sub_10069EF0(flt_104E6DC0[v12], v13);
  sub_10069EF0(flt_104E6DC0[8 * *(_BYTE *)(a2 + 12)], flt_104E6DC4[8 * *(_BYTE *)(a2 + 12)]);
  v14 = 8 * *(_BYTE *)(a2 + 12);
  v15 = flt_104E6DB0[v14] - 1.0;
  sub_10069EF0(v15, flt_104E6DC4[v14]);
  j_gdi_pvg_end(v16);
  if ( *(_BYTE *)(v3 + 28) == 1 )
  {
    v30 = 8 * *(_BYTE *)(a2 + 12);
    v31 = flt_104E6DC0[v30] - flt_104E6DB0[v30];
    v39 = flt_104E6DB8[v30] - (flt_104E6CBC[v30] - *(float *)v3) * v31;
    v32 = flt_104E6DC4[v30] - flt_104E6DB4[v30];
    v36 = (flt_104E6CB8[v30] - *(float *)(v3 + 8)) * v32 + flt_104E6DBC[v30];
    v37 = flt_104E6DB8[v30] - v31 * (flt_104E6CCC[v30] + *(float *)(v3 + 4));
    v21 = v32 * (flt_104E6CC8[v30] + *(float *)(v3 + 12)) + flt_104E6DBC[v30];
  }
  else if ( *(_BYTE *)(v3 + 28) == 2 )
  {
    v25 = 8 * *(_BYTE *)(a2 + 12);
    v26 = flt_104E6DC0[v25];
    v27 = v26 - flt_104E6DB0[v25];
    v39 = v26 - (flt_104E6CB8[v25] - *(float *)(v3 + 8)) * v27;
    v28 = flt_104E6DC4[v25];
    v29 = v28 - flt_104E6DB4[v25];
    v36 = v28 - (flt_104E6CBC[v25] - *(float *)v3) * v29;
    v37 = v26 - v27 * (flt_104E6CC8[v25] + *(float *)(v3 + 12));
    v21 = v28 - v29 * (flt_104E6CCC[v25] + *(float *)(v3 + 4));
  }
  else
  {
    v17 = *(_BYTE *)(a2 + 12);
    if ( *(_BYTE *)(v3 + 28) == 3 )
    {
      v22 = 8 * v17;
      v23 = flt_104E6DC0[v22] - flt_104E6DB0[v22];
      v39 = (flt_104E6CBC[v22] - *(float *)v3) * v23 + flt_104E6DC8[v22];
      v24 = flt_104E6DC4[v22] - flt_104E6DB4[v22];
      v36 = flt_104E6DCC[v22] - (flt_104E6CB8[v22] - *(float *)(v3 + 8)) * v24;
      v37 = v23 * (flt_104E6CCC[v22] + *(float *)(v3 + 4)) + flt_104E6DC8[v22];
      v21 = flt_104E6DCC[v22] - v24 * (flt_104E6CC8[v22] + *(float *)(v3 + 12));
    }
    else
    {
      v18 = 8 * v17;
      v19 = flt_104E6DC0[v18] - flt_104E6DB0[v18];
      v39 = (flt_104E6CB8[v18] - *(float *)(v3 + 8)) * v19 + flt_104E6DB0[v18];
      v20 = flt_104E6DC4[v18] - flt_104E6DB4[v18];
      v36 = (flt_104E6CBC[v18] - *(float *)v3) * v20 + flt_104E6DB4[v18];
      v37 = v19 * (flt_104E6CC8[v18] + *(float *)(v3 + 12)) + flt_104E6DB0[v18];
      v21 = v20 * (flt_104E6CCC[v18] + *(float *)(v3 + 4)) + flt_104E6DB4[v18];
    }
  }
  v33 = v21;
  j_gdi_pvg_color_u32(-16711936);
  sub_10069C80(1.0);
  j_gdi_pvg_begin(66);
  sub_10069EF0(v39, v36);
  sub_10069EF0(v37, v36);
  sub_10069EF0(v37, v33);
  sub_10069EF0(v39, v33);
  return j_gdi_pvg_end(a3);
}
// 100699C0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100699F0: using guessed type int j_gdi_pvg_bind_video_cap_as_textmap(void);
// 10069B20: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10069B40: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10069BC0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10069BE0: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 10069D20: using guessed type int j_gdi_pvg_pop_matrix(void);
// 10069D40: using guessed type int j_gdi_pvg_push_matrix(void);
// 104E6CB8: using guessed type float flt_104E6CB8[];
// 104E6CBC: using guessed type float flt_104E6CBC[];
// 104E6CC8: using guessed type float flt_104E6CC8[];
// 104E6CCC: using guessed type float flt_104E6CCC[];
// 104E6D08: using guessed type float flt_104E6D08[];
// 104E6D0C: using guessed type float flt_104E6D0C[];
// 104E6DB0: using guessed type float flt_104E6DB0[];
// 104E6DB4: using guessed type float flt_104E6DB4[];
// 104E6DB8: using guessed type float flt_104E6DB8[];
// 104E6DBC: using guessed type float flt_104E6DBC[];
// 104E6DC0: using guessed type float flt_104E6DC0[];
// 104E6DC4: using guessed type float flt_104E6DC4[];
// 104E6DC8: using guessed type float flt_104E6DC8[];
// 104E6DCC: using guessed type float flt_104E6DCC[];

//----- (1002C470) --------------------------------------------------------
double __usercall sub_1002C470@<st0>(int a1@<eax>, float *a2@<edx>, float a3, float a4)
{
  double v4; // st7@2
  double v5; // st7@4
  double result; // st7@5
  double v7; // st7@6
  float v8; // [sp+4h] [bp+4h]@1
  float v9; // [sp+4h] [bp+4h]@5
  float v10; // [sp+4h] [bp+4h]@7
  float v11; // [sp+8h] [bp+8h]@5
  float v12; // [sp+8h] [bp+8h]@7
  float v13; // [sp+8h] [bp+8h]@9

  v8 = *a2 + a3;
  switch ( LOBYTE(a4) )
  {
    case 3u:
      v4 = *(float *)((*(_BYTE *)(a1 + 1) << 6) + a1 + 16);
      goto LABEL_4;
    case 0u:
      v4 = *(float *)((*(_BYTE *)(a1 + 1) << 6) + a1 + 8);
LABEL_4:
      v5 = v4 + 0.0;
      if ( v8 < v5 )
        goto LABEL_5;
      goto LABEL_9;
    case 1u:
      v7 = 1.0 - *(float *)((*(_BYTE *)(a1 + 1) << 6) + a1 + 20);
      if ( v8 <= v7 )
        goto LABEL_9;
      v10 = v7;
      v12 = v10 - *a2;
      *a2 = v10;
      return v12;
    case 2u:
      v5 = 1.0 - *(float *)((*(_BYTE *)(a1 + 1) << 6) + a1 + 12);
      if ( v8 <= v5 )
        goto LABEL_9;
LABEL_5:
      v9 = v5;
      v11 = v9 - *a2;
      *a2 = v9;
      result = v11;
      break;
    default:
LABEL_9:
      v13 = v8 - *a2;
      *a2 = v8;
      result = v13;
      break;
  }
  return result;
}

//----- (1002C530) --------------------------------------------------------
char __thiscall sub_1002C530(int this)
{
  char result; // al@1

  result = 1;
  if ( *(_BYTE *)(this + 1) >= 2u )
    result = 0;
  return result;
}

//----- (1002C540) --------------------------------------------------------
void __usercall sub_1002C540(int a1@<edi>, int a2@<esi>, char a3)
{
  int v3; // eax@1
  int v4; // ebp@1
  int v5; // ebx@1
  double v6; // st7@2
  float v7; // ebx@2
  float v8; // ST38_4@2
  double v9; // st7@2
  float *v10; // edx@2
  float v11; // ST38_4@3
  float v12; // ST38_4@3
  double v13; // st7@3
  float *v14; // edx@3
  int v15; // eax@4
  float v16; // ST38_4@4
  float v17; // ST38_4@4
  float v18; // ST38_4@4
  int v19; // ecx@5
  double v20; // st7@6
  float v21; // ST38_4@6
  float v22; // ST38_4@6
  float v23; // ST38_4@6
  float v24; // ST38_4@7
  float v25; // [sp+14h] [bp-4h]@0

  v3 = *(_BYTE *)(a2 + 1) << 6;
  v4 = v3 + a2 + 8;
  v5 = sub_1003B860((_DWORD *)(*(_BYTE *)(v3 + a2 + 62) + v4 + 57), 1u, (int)&unk_100A1D5C, 12, 5, 0);
  LOBYTE(v25) = *(&byte_100A1DB8[4 * sub_1003B860(&a3, 1u, (int)byte_100A1DB8, 4, 4, 0)] + *(_BYTE *)(v4 + 28));
  switch ( LOBYTE(v25) )
  {
    case 3u:
      v6 = flt_100A1D64[3 * v5];
      v7 = v25;
      v8 = -v6;
      v9 = sub_1002C470(a2, &flt_104E6CB8[8 * *(_BYTE *)(a1 + 12)], v8, v25);
      v10 = &flt_104E6CC0[8 * *(_BYTE *)(a1 + 12)];
      goto LABEL_3;
    case 0u:
      v15 = 3 * v5;
      v7 = v25;
      v16 = -flt_100A1D64[v15];
      v17 = sub_1002C470(a2, &flt_104E6CBC[8 * *(_BYTE *)(a1 + 12)], v16, v25);
      v18 = sub_1002C470(a2, &flt_104E6CC4[8 * *(_BYTE *)(a1 + 12)], v17, v25);
      v13 = sub_1002C470(a2, &flt_104E6CCC[8 * *(_BYTE *)(a1 + 12)], v18, v25);
      v14 = &flt_104E6CD4[8 * *(_BYTE *)(a1 + 12)];
      goto LABEL_7;
    case 1u:
      v19 = 3 * v5;
      v7 = v25;
      v9 = sub_1002C470(a2, &flt_104E6CC0[8 * *(_BYTE *)(a1 + 12)], flt_100A1D64[v19], v25);
      v10 = &flt_104E6CB8[8 * *(_BYTE *)(a1 + 12)];
LABEL_3:
      v11 = v9;
      v12 = sub_1002C470(a2, v10, v11, v7);
      v13 = sub_1002C470(a2, &flt_104E6CC8[8 * *(_BYTE *)(a1 + 12)], v12, v7);
      v14 = &flt_104E6CD0[8 * *(_BYTE *)(a1 + 12)];
      goto LABEL_7;
    case 2u:
      v20 = flt_100A1D64[3 * v5];
      v7 = v25;
      v21 = v20;
      v22 = sub_1002C470(a2, &flt_104E6CCC[8 * *(_BYTE *)(a1 + 12)], v21, v25);
      v23 = sub_1002C470(a2, &flt_104E6CD4[8 * *(_BYTE *)(a1 + 12)], v22, v25);
      v13 = sub_1002C470(a2, &flt_104E6CBC[8 * *(_BYTE *)(a1 + 12)], v23, v25);
      v14 = &flt_104E6CC4[8 * *(_BYTE *)(a1 + 12)];
LABEL_7:
      v24 = v13;
      sub_1002C470(a2, v14, v24, v7);
      break;
    default:
      return;
  }
}
// 100A1D64: using guessed type float flt_100A1D64[];
// 104E6CB8: using guessed type float flt_104E6CB8[];
// 104E6CBC: using guessed type float flt_104E6CBC[];
// 104E6CC0: using guessed type float flt_104E6CC0[];
// 104E6CC4: using guessed type float flt_104E6CC4[];
// 104E6CC8: using guessed type float flt_104E6CC8[];
// 104E6CCC: using guessed type float flt_104E6CCC[];
// 104E6CD0: using guessed type float flt_104E6CD0[];
// 104E6CD4: using guessed type float flt_104E6CD4[];

//----- (1002C7C0) --------------------------------------------------------
char __usercall sub_1002C7C0@<al>(int a1@<edi>, int a2@<esi>, char a3)
{
  int v3; // ecx@1
  int v4; // eax@1
  char v5; // bl@1
  int v6; // eax@8
  int v7; // ecx@8
  int v8; // eax@9
  double v9; // st7@9
  double v10; // st4@9
  double v11; // st3@9
  float v12; // ST24_4@9
  double v13; // st2@9
  double v14; // st4@9
  double v15; // st0@9
  float v16; // ST28_4@9
  double v17; // st3@9
  double v18; // st7@9
  double v19; // st3@10
  float v20; // ST24_4@10
  double v21; // st3@11
  int v22; // ecx@11
  double v23; // st2@12
  float v24; // ST24_4@12
  float v25; // ST1C_4@12
  double v26; // st6@14
  float v27; // ST28_4@14
  double v28; // st6@14
  double v29; // st5@16
  float v30; // ST28_4@16
  float v31; // ST20_4@16
  double v32; // st5@16
  double v33; // rtt@19
  double v34; // st4@19
  double v35; // rt2@19
  double v36; // st5@19
  float v38; // [sp+4h] [bp-18h]@1
  float v39; // [sp+4h] [bp-18h]@9
  float v40; // [sp+8h] [bp-14h]@9
  float v41; // [sp+Ch] [bp-10h]@1
  float v42; // [sp+10h] [bp-Ch]@1
  float v43; // [sp+14h] [bp-8h]@1
  float v44; // [sp+18h] [bp-4h]@1

  v3 = (*(_BYTE *)(a1 + 1) << 6) + a1;
  v4 = 8 * *(_BYTE *)(a2 + 12);
  v5 = 0;
  v41 = *(float *)(v3 + 16) + 0.0;
  v42 = *(float *)(v3 + 8) + 0.0;
  v38 = 1.0 - *(float *)(v3 + 20);
  v43 = (flt_104E6CC0[v4] - flt_104E6CB8[v4]) * 0.5 + flt_104E6CB8[v4];
  v44 = 0.5 * (flt_104E6CD4[v4] - flt_104E6CBC[v4]) + flt_104E6CBC[v4];
  switch ( a3 )
  {
    case 0:
      if ( *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(a2 + 12) + 3) < *(_BYTE *)(v3 + 63) )
      {
        ++*((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(a2 + 12) + 3);
        v5 = 1;
      }
      break;
    case 1:
      if ( *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(a2 + 12) + 3) > *(_BYTE *)(v3 + 64) )
      {
        --*((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(a2 + 12) + 3);
        v5 = 1;
      }
      break;
    case 2:
      *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(a2 + 12) + 3) = 0;
      break;
    case 3:
      *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(a2 + 12) + 3) = *(_BYTE *)(v3 + 62);
      break;
    default:
      break;
  }
  v6 = sub_1003B860(
         (_DWORD *)(*((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(a2 + 12) + 3) + v3 + 65),
         1u,
         (int)&unk_100A1D5C,
         12,
         5,
         0);
  v7 = 3 * v6;
  if ( 0.0 == flt_100A1D60[3 * v6] )
  {
    v18 = v42;
    v32 = v38;
    v14 = v41;
    v28 = v38;
  }
  else
  {
    v8 = (*(_BYTE *)(a1 + 1) << 6) + a1;
    v9 = *(float *)(v8 + 16) + 0.0;
    v10 = 1.0 - *(float *)(v8 + 20) - v9;
    v11 = flt_100A1D60[v7] + flt_100A1D60[v7];
    v12 = v43 - v10 / v11;
    v13 = v10 / flt_100A1D60[v7] + v12;
    v14 = v12;
    v39 = v13;
    v15 = 1.0 - *(float *)(v8 + 12) - (*(float *)(v8 + 8) + 0.0);
    v16 = v44 - v15 / v11;
    v40 = v15 / flt_100A1D60[v7] + v16;
    v17 = v9;
    v18 = v16;
    if ( v17 > v12 )
    {
      v19 = *(float *)((*(_BYTE *)(a1 + 1) << 6) + a1 + 16) + 0.0;
      v39 = v39 - (v14 - v19);
      v20 = v19;
      v14 = v20;
    }
    v21 = v39;
    v22 = a1 + (*(_BYTE *)(a1 + 1) << 6);
    if ( 1.0 - *(float *)(v22 + 20) < v39 )
    {
      v23 = 1.0 - *(float *)((*(_BYTE *)(a1 + 1) << 6) + a1 + 20);
      v24 = v14 - (v21 - v23);
      v25 = v23;
      v14 = v24;
      v21 = v25;
    }
    if ( *(float *)(v22 + 8) + 0.0 <= v18 )
    {
      v28 = v21;
    }
    else
    {
      v26 = *(float *)((*(_BYTE *)(a1 + 1) << 6) + a1 + 8) + 0.0;
      v40 = v40 - (v18 - v26);
      v27 = v26;
      v18 = v27;
      v28 = v21;
    }
    if ( 1.0 - *(float *)(v22 + 12) >= v40 )
    {
      v32 = v40;
    }
    else
    {
      v29 = 1.0 - *(float *)((*(_BYTE *)(a1 + 1) << 6) + a1 + 12);
      v30 = v18 - (v40 - v29);
      v31 = v29;
      v32 = v31;
      v18 = v30;
    }
  }
  flt_104E6CB8[8 * *(_BYTE *)(a2 + 12)] = v14;
  v33 = v14;
  v34 = v18;
  flt_104E6CBC[8 * *(_BYTE *)(a2 + 12)] = v18;
  flt_104E6CC0[8 * *(_BYTE *)(a2 + 12)] = v28;
  flt_104E6CC4[8 * *(_BYTE *)(a2 + 12)] = *(float *)&v34;
  v35 = v32;
  v36 = v28;
  flt_104E6CC8[8 * *(_BYTE *)(a2 + 12)] = *(float *)&v36;
  flt_104E6CCC[8 * *(_BYTE *)(a2 + 12)] = v35;
  flt_104E6CD0[8 * *(_BYTE *)(a2 + 12)] = v33;
  flt_104E6CD4[8 * *(_BYTE *)(a2 + 12)] = v35;
  return v5;
}
// 100A1D60: using guessed type float flt_100A1D60[];
// 104E6CB8: using guessed type float flt_104E6CB8[];
// 104E6CBC: using guessed type float flt_104E6CBC[];
// 104E6CC0: using guessed type float flt_104E6CC0[];
// 104E6CC4: using guessed type float flt_104E6CC4[];
// 104E6CC8: using guessed type float flt_104E6CC8[];
// 104E6CCC: using guessed type float flt_104E6CCC[];
// 104E6CD0: using guessed type float flt_104E6CD0[];
// 104E6CD4: using guessed type float flt_104E6CD4[];
// 104E6CF8: using guessed type int dword_104E6CF8;

//----- (1002CAF0) --------------------------------------------------------
int __cdecl sub_1002CAF0(int a1, int a2, int a3, float a4)
{
  int v4; // ecx@1
  unsigned __int8 v5; // al@2
  int v6; // ebx@4
  int v7; // ebp@4
  int v8; // ecx@7
  int v9; // ecx@9
  signed int v10; // esi@10
  signed int v11; // edi@10
  int v12; // ecx@14
  double v13; // st7@14
  double v14; // st6@14
  double v15; // st6@14
  double v16; // st7@14
  signed int v17; // ST14_4@16
  int v18; // eax@16
  int v19; // esi@16
  int v20; // edi@16
  int v21; // eax@16
  int v22; // ebp@16
  signed int v23; // eax@16
  double v24; // st7@16
  double v25; // st6@16
  int result; // eax@16
  double v27; // st6@16
  double v28; // st7@16
  int v29; // [sp+1Ch] [bp+4h]@16
  int v30; // [sp+24h] [bp+Ch]@4
  int v31; // [sp+24h] [bp+Ch]@14
  int v32; // [sp+24h] [bp+Ch]@16
  int v33; // [sp+24h] [bp+Ch]@16
  float v34; // [sp+28h] [bp+10h]@5
  float v35; // [sp+28h] [bp+10h]@5
  float v36; // [sp+28h] [bp+10h]@5
  float v37; // [sp+28h] [bp+10h]@5
  float v38; // [sp+28h] [bp+10h]@5
  float v39; // [sp+28h] [bp+10h]@5
  float v40; // [sp+28h] [bp+10h]@5
  float v41; // [sp+28h] [bp+10h]@5
  float v42; // [sp+28h] [bp+10h]@10
  float v43; // [sp+28h] [bp+10h]@11
  float v44; // [sp+28h] [bp+10h]@12
  float v45; // [sp+28h] [bp+10h]@13
  float v46; // [sp+28h] [bp+10h]@14
  float v47; // [sp+28h] [bp+10h]@14
  float v48; // [sp+28h] [bp+10h]@14
  float v49; // [sp+28h] [bp+10h]@14
  float v50; // [sp+28h] [bp+10h]@16
  float v51; // [sp+28h] [bp+10h]@16
  float v52; // [sp+28h] [bp+10h]@16
  float v53; // [sp+28h] [bp+10h]@16
  float v54; // [sp+28h] [bp+10h]@16
  float v55; // [sp+28h] [bp+10h]@16
  float v56; // [sp+28h] [bp+10h]@16
  float v57; // [sp+28h] [bp+10h]@16
  float v58; // [sp+28h] [bp+10h]@16
  float v59; // [sp+28h] [bp+10h]@16

  if ( sub_1002C530(a3) )
    v5 = *(_BYTE *)(v4 + 1);
  else
    v5 = 0;
  v6 = a1;
  v7 = (v5 << 6) + v4 + 8;
  v30 = v5;
  *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(a1 + 12) + 3) = *(_BYTE *)((v5 << 6) + v4 + 62);
  if ( LOBYTE(a4) == 1 )
  {
    v34 = *(float *)((v5 << 6) + v4 + 16) + 0.0;
    flt_104E6CB8[8 * *(_BYTE *)(a1 + 12)] = v34;
    v35 = *(float *)v7 + 0.0;
    flt_104E6CBC[8 * *(_BYTE *)(a1 + 12)] = v35;
    v36 = 1.0 - *(float *)((v5 << 6) + v4 + 20);
    flt_104E6CC0[8 * *(_BYTE *)(a1 + 12)] = v36;
    v37 = *(float *)v7 + 0.0;
    flt_104E6CC4[8 * *(_BYTE *)(a1 + 12)] = v37;
    v38 = 1.0 - *(float *)((v5 << 6) + v4 + 20);
    flt_104E6CC8[8 * *(_BYTE *)(a1 + 12)] = v38;
    v39 = 1.0 - *(float *)((v5 << 6) + v4 + 12);
    flt_104E6CCC[8 * *(_BYTE *)(a1 + 12)] = v39;
    v40 = *(float *)((v5 << 6) + v4 + 16) + 0.0;
    flt_104E6CD0[8 * *(_BYTE *)(a1 + 12)] = v40;
    v41 = 1.0 - *(float *)((v5 << 6) + v4 + 12);
    flt_104E6CD4[8 * *(_BYTE *)(a1 + 12)] = v41;
    qmemcpy(&flt_104E6D08[8 * *(_BYTE *)(a1 + 12)], &flt_104E6CB8[8 * *(_BYTE *)(a1 + 12)], 0x20u);
  }
  if ( *(_BYTE *)((v5 << 6) + v4 + 34) )
  {
    v8 = v5 + 2 * *(_BYTE *)(a1 + 12);
    if ( flt_104E6DF0[v8] <= 0.0 )
      flt_104E6DF0[v8] = 1.0;
    v9 = v5 + 2 * *(_BYTE *)(a1 + 12);
    if ( flt_104E6DF0[v9] < 1.0 )
    {
      v11 = *(_WORD *)(a1 + 10);
      v44 = (double)v11 * flt_104E6DF0[v9];
      v10 = sub_10022BF0(v44);
      if ( v10 > *(_WORD *)(a1 + 8) )
      {
        v10 = *(_WORD *)(a1 + 8);
        v45 = (double)v10 / flt_104E6DF0[v30 + 2 * *(_BYTE *)(a1 + 12)];
        v11 = sub_10022BF0(v45);
      }
    }
    else
    {
      v10 = *(_WORD *)(a1 + 8);
      v42 = (double)v10 / flt_104E6DF0[v9];
      v11 = sub_10022BF0(v42);
      if ( v11 > *(_WORD *)(a1 + 10) )
      {
        v11 = *(_WORD *)(a1 + 10);
        v43 = flt_104E6DF0[v30 + 2 * *(_BYTE *)(a1 + 12)] * (double)v11;
        v10 = sub_10022BF0(v43);
      }
    }
    v12 = *(_WORD *)a2 + *(_WORD *)(a1 + 8) / 2 - v10 / 2;
    v46 = (double)v12;
    v13 = v46;
    v31 = *(_WORD *)(a2 + 2) + *(_WORD *)(a1 + 10) / 2 - v11 / 2;
    flt_104E6D50[8 * *(_BYTE *)(a1 + 12)] = v46;
    v47 = (double)v31;
    v14 = v47;
    flt_104E6D54[8 * *(_BYTE *)(a1 + 12)] = v47;
    v48 = (double)(v10 + v12);
    flt_104E6D58[8 * *(_BYTE *)(a1 + 12)] = v48;
    flt_104E6D5C[8 * *(_BYTE *)(a1 + 12)] = v14;
    flt_104E6D60[8 * *(_BYTE *)(a1 + 12)] = v48;
    v49 = (double)(v11 + v31);
    flt_104E6D64[8 * *(_BYTE *)(a1 + 12)] = v49;
    v15 = v13;
    v16 = v49;
    flt_104E6D68[8 * *(_BYTE *)(a1 + 12)] = v15;
    flt_104E6D6C[8 * *(_BYTE *)(a1 + 12)] = *(float *)&v16;
  }
  else
  {
    flt_104E6D50[8 * *(_BYTE *)(a1 + 12)] = (double)*(_WORD *)a2;
    flt_104E6D54[8 * *(_BYTE *)(a1 + 12)] = (double)*(_WORD *)(a2 + 2);
    flt_104E6D58[8 * *(_BYTE *)(a1 + 12)] = (double)(*(_WORD *)(a1 + 8) + (signed int)*(_WORD *)a2);
    flt_104E6D5C[8 * *(_BYTE *)(a1 + 12)] = (double)*(_WORD *)(a2 + 2);
    flt_104E6D60[8 * *(_BYTE *)(a1 + 12)] = (double)(*(_WORD *)(a1 + 8) + (signed int)*(_WORD *)a2);
    flt_104E6D64[8 * *(_BYTE *)(a1 + 12)] = (double)(*(_WORD *)(a2 + 2) + (signed int)*(_WORD *)(a1 + 10));
    flt_104E6D68[8 * *(_BYTE *)(a1 + 12)] = (double)*(_WORD *)a2;
    flt_104E6D6C[8 * *(_BYTE *)(a1 + 12)] = (double)(*(_WORD *)(a2 + 2) + (signed int)*(_WORD *)(a1 + 10));
  }
  v50 = (flt_104E6D58[8 * *(_BYTE *)(a1 + 12)] - flt_104E6D50[8 * *(_BYTE *)(a1 + 12)]) * 0.01999999955296516;
  v29 = sub_10022BF0(v50);
  v51 = (flt_104E6D64[8 * *(_BYTE *)(v6 + 12)] - flt_104E6D5C[8 * *(_BYTE *)(v6 + 12)]) * 0.01999999955296516;
  v17 = sub_10022BF0(v51);
  v52 = (flt_104E6D60[8 * *(_BYTE *)(v6 + 12)] - flt_104E6D50[8 * *(_BYTE *)(v6 + 12)]) * *(float *)(v7 + 16);
  v18 = sub_10022BF0(v52);
  v19 = v18;
  v53 = *(float *)&v18;
  *(float *)&v32 = (flt_104E6D64[8 * *(_BYTE *)(v6 + 12)] - flt_104E6D54[8 * *(_BYTE *)(v6 + 12)]) * *(float *)(v7 + 16);
  v20 = sub_10022BF0(*(float *)&v32);
  v54 = flt_104E6D58[8 * *(_BYTE *)(v6 + 12)] - (double)SLODWORD(v53) - (double)v29;
  v21 = sub_10022BF0(v54);
  v22 = v21;
  v55 = *(float *)&v21;
  *(float *)&v33 = flt_104E6D5C[8 * *(_BYTE *)(v6 + 12)] + (double)v17;
  v23 = sub_10022BF0(*(float *)&v33);
  v56 = (double)SLODWORD(v55);
  v24 = v56;
  flt_104E6DB0[8 * *(_BYTE *)(v6 + 12)] = v56;
  v57 = (double)v23;
  v25 = v57;
  flt_104E6DB4[8 * *(_BYTE *)(v6 + 12)] = v57;
  v58 = (double)(v19 + v22);
  flt_104E6DB8[8 * *(_BYTE *)(v6 + 12)] = v58;
  flt_104E6DBC[8 * *(_BYTE *)(v6 + 12)] = v25;
  flt_104E6DC0[8 * *(_BYTE *)(v6 + 12)] = v58;
  v59 = (double)(v20 + v23);
  flt_104E6DC4[8 * *(_BYTE *)(v6 + 12)] = v59;
  result = 8 * *(_BYTE *)(v6 + 12);
  v27 = v24;
  v28 = v59;
  flt_104E6DC8[result] = v27;
  flt_104E6DCC[8 * *(_BYTE *)(v6 + 12)] = *(float *)&v28;
  return result * 4;
}
// 104E6CB8: using guessed type float flt_104E6CB8[];
// 104E6CBC: using guessed type float flt_104E6CBC[];
// 104E6CC0: using guessed type float flt_104E6CC0[];
// 104E6CC4: using guessed type float flt_104E6CC4[];
// 104E6CC8: using guessed type float flt_104E6CC8[];
// 104E6CCC: using guessed type float flt_104E6CCC[];
// 104E6CD0: using guessed type float flt_104E6CD0[];
// 104E6CD4: using guessed type float flt_104E6CD4[];
// 104E6CF8: using guessed type int dword_104E6CF8;
// 104E6D08: using guessed type float flt_104E6D08[];
// 104E6D50: using guessed type float flt_104E6D50[];
// 104E6D54: using guessed type float flt_104E6D54[];
// 104E6D58: using guessed type float flt_104E6D58[];
// 104E6D5C: using guessed type float flt_104E6D5C[];
// 104E6D60: using guessed type float flt_104E6D60[];
// 104E6D64: using guessed type float flt_104E6D64[];
// 104E6D68: using guessed type float flt_104E6D68[];
// 104E6D6C: using guessed type float flt_104E6D6C[];
// 104E6DB0: using guessed type float flt_104E6DB0[];
// 104E6DB4: using guessed type float flt_104E6DB4[];
// 104E6DB8: using guessed type float flt_104E6DB8[];
// 104E6DBC: using guessed type float flt_104E6DBC[];
// 104E6DC0: using guessed type float flt_104E6DC0[];
// 104E6DC4: using guessed type float flt_104E6DC4[];
// 104E6DC8: using guessed type float flt_104E6DC8[];
// 104E6DCC: using guessed type float flt_104E6DCC[];
// 104E6DF0: using guessed type float flt_104E6DF0[];

//----- (1002D0C0) --------------------------------------------------------
int __usercall sub_1002D0C0@<eax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // edi@1
  int v4; // ebp@3
  int v5; // ebx@3
  double v6; // st7@5
  float v7; // ST30_4@7
  double v8; // st7@7
  int v9; // edx@7
  _BYTE *v10; // ebp@8
  _BYTE *v11; // ebx@8
  _BYTE *v12; // edi@9
  int v13; // eax@11
  int v15; // [sp-1Ch] [bp-38h]@9
  int v16; // [sp-18h] [bp-34h]@9
  int v17; // [sp+0h] [bp-1Ch]@8
  signed int v18; // [sp+18h] [bp-4h]@3
  _BYTE *v19; // [sp+18h] [bp-4h]@9

  v3 = a1;
  if ( *(_BYTE *)(a2 + 12) >= 2u )
    sub_100364C0("..\\lib\\adl\\cdp_fld_3d_video.c", 722, 1, "Trying to use an invalid instance of the video field");
  dword_104E6D48[*(_BYTE *)(a2 + 12)] = sub_10069700();
  v4 = 0;
  v5 = v3 + 28;
  v18 = 2;
  do
  {
    if ( *(_WORD *)v5 )
      v6 = (double)*(_WORD *)(v5 + 2) / (double)*(_WORD *)v5;
    else
      v6 = 1.0;
    v7 = v6;
    v8 = sub_10022C70(v7, 0.001);
    v9 = v4++ + 2 * *(_BYTE *)(a2 + 12);
    v5 += 64;
    flt_104E6DF0[v9] = v8;
    --v18;
  }
  while ( v18 );
  sub_1002CAF0(a2, a3, v3, COERCE_FLOAT(1));
  dword_104E6D90[2 * *(_BYTE *)(a2 + 12)] = 0;
  byte_104E6D94[8 * *(_BYTE *)(a2 + 12)] = 0;
  byte_104E6D95[8 * *(_BYTE *)(a2 + 12)] = 4;
  dword_104E6DA0[2 * *(_BYTE *)(a2 + 12)] = 0;
  byte_104E6DA4[8 * *(_BYTE *)(a2 + 12)] = 0;
  v10 = (_BYTE *)(v3 + 1);
  v11 = (_BYTE *)(v3 + 4);
  v17 = v3 + 4;
  if ( *(_BYTE *)(v3 + 1) == 1 )
  {
    sub_1006A170(3197, v17, 1);
    v19 = (_BYTE *)(v3 + 3);
    sub_1006A170(3198, v3 + 3, 1);
    v12 = (_BYTE *)(v3 + 5);
    v16 = (int)v12;
    v15 = 3199;
  }
  else
  {
    sub_1006A170(3194, v17, 1);
    v19 = (_BYTE *)(v3 + 3);
    sub_1006A170(3195, v3 + 3, 1);
    v12 = (_BYTE *)(v3 + 5);
    v16 = (int)v12;
    v15 = 3196;
  }
  sub_1006A170(v15, v16, 1);
  v13 = *(_BYTE *)(a2 + 12);
  *(int *)((char *)&dword_104E6CF8 + 5 * v13) = 0;
  *((_BYTE *)&dword_104E6CFC + 5 * v13) = 0;
  *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(a2 + 12)) = *v19;
  *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(a2 + 12) + 1) = *v11;
  *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(a2 + 12) + 2) = *v12;
  *((_BYTE *)&dword_104E6CFC + 5 * *(_BYTE *)(a2 + 12)) = *v10;
  return j_HWM_pvg_set_decoder_cfg(v10);
}
// 1006BBF0: using guessed type int __cdecl j_HWM_pvg_set_decoder_cfg(_DWORD);
// 104E6CF8: using guessed type int dword_104E6CF8;
// 104E6CFC: using guessed type int dword_104E6CFC;
// 104E6D48: using guessed type int dword_104E6D48[];
// 104E6D90: using guessed type int dword_104E6D90[];
// 104E6DA0: using guessed type int dword_104E6DA0[];
// 104E6DF0: using guessed type float flt_104E6DF0[];

//----- (1002D280) --------------------------------------------------------
void __usercall sub_1002D280(int a1@<eax>, int a2@<ecx>, int a3@<ebx>)
{
  int v3; // esi@1
  int v4; // edi@1

  v3 = a1;
  v4 = a2;
  if ( *(_BYTE *)((*(_BYTE *)(a1 + 1) << 6) + a1 + 35) )
  {
    switch ( *(_WORD *)(*(_DWORD *)(a3 + 52) + 10) )
    {
      case 0x2E:
        sub_1002C540(a2, a1, 0);
        sub_1002C540(v4, v3, 3);
        *(_BYTE *)(a3 + 6) = 2;
        break;
      case 0x2F:
        sub_1002C540(a2, a1, 0);
        *(_BYTE *)(a3 + 6) = 2;
        break;
      case 0x30:
        sub_1002C540(a2, a1, 0);
        sub_1002C540(v4, v3, 1);
        *(_BYTE *)(a3 + 6) = 2;
        break;
      case 0x31:
        sub_1002C540(a2, a1, 1);
        *(_BYTE *)(a3 + 6) = 2;
        break;
      case 0x32:
        sub_1002C540(a2, a1, 2);
        sub_1002C540(v4, v3, 1);
        *(_BYTE *)(a3 + 6) = 2;
        break;
      case 0x33:
        sub_1002C540(a2, a1, 2);
        *(_BYTE *)(a3 + 6) = 2;
        break;
      case 0x34:
        sub_1002C540(a2, a1, 2);
        sub_1002C540(v4, v3, 3);
        *(_BYTE *)(a3 + 6) = 2;
        break;
      case 0x35:
        sub_1002C540(a2, a1, 3);
        *(_BYTE *)(a3 + 6) = 2;
        break;
      default:
        return;
    }
  }
}

//----- (1002D380) --------------------------------------------------------
char __usercall sub_1002D380@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4)
{
  int v4; // ebp@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // ebx@1
  unsigned __int8 v10; // al@1
  int v11; // eax@5
  unsigned __int8 v12; // cl@5
  unsigned __int8 v13; // dl@5
  char v14; // al@7
  int v15; // eax@12
  _BYTE *v16; // ebp@12
  _BYTE *v17; // ebx@14
  int v18; // eax@31
  float v19; // ST30_4@36
  float v20; // ST2C_4@36
  float v21; // ST30_4@36
  float v22; // ST44_4@36
  float v23; // ST44_4@36
  float v24; // ST30_4@36
  float v25; // ST44_4@36
  float v26; // ST44_4@36
  float v27; // ST2C_4@36
  _DWORD *v28; // eax@37
  int v29; // ebp@37
  int v30; // ebx@39
  int v31; // eax@39
  int v32; // eax@39
  char *v33; // eax@43
  float v34; // ST50_4@43
  float v35; // ST50_4@43
  float v36; // ST44_4@43
  char *v37; // eax@43
  int v38; // eax@48
  float v39; // ST44_4@50
  float v40; // ST2C_4@50
  float v41; // ST44_4@50
  unsigned int v42; // ecx@52
  int v43; // ebx@55
  float v44; // ST50_4@60
  float v45; // ST44_4@60
  float v46; // ST2C_4@60
  float v47; // ST44_4@60
  float v48; // ST30_4@65
  float v49; // ST2C_4@65
  float v50; // ST30_4@65
  float v51; // ST44_4@65
  float v52; // ST44_4@65
  float v53; // ST30_4@65
  float v54; // ST44_4@65
  float v55; // ST44_4@65
  double v56; // st7@65
  signed int v57; // eax@66
  float v58; // ST30_4@66
  float v59; // ST2C_4@66
  float v60; // ST30_4@66
  float v61; // ST44_4@66
  float v62; // ST44_4@66
  float v63; // ST30_4@66
  float v64; // ST44_4@66
  float v65; // ST44_4@66
  float v66; // ST2C_4@67
  char result; // al@68
  int v68; // [sp-20h] [bp-124h]@29
  int v69; // [sp-1Ch] [bp-120h]@29
  int v70; // [sp-14h] [bp-118h]@18
  int v71; // [sp-10h] [bp-114h]@18
  int v72; // [sp+8h] [bp-FCh]@17
  int v73; // [sp+8h] [bp-FCh]@28
  float v74; // [sp+Ch] [bp-F8h]@65
  int v75; // [sp+10h] [bp-F4h]@0
  int v76; // [sp+10h] [bp-F4h]@36
  char v77; // [sp+27h] [bp-DDh]@1
  char v78; // [sp+27h] [bp-DDh]@34
  int v79; // [sp+28h] [bp-DCh]@1
  int v80; // [sp+30h] [bp-D4h]@1
  char v81; // [sp+38h] [bp-CCh]@55
  char v82; // [sp+9Ch] [bp-68h]@55

  v4 = a4;
  v5 = a2;
  v6 = a1;
  v7 = sub_10069700();
  v8 = *(_BYTE *)(v6 + 1) << 6;
  v9 = v8 + v6 + 8;
  v80 = v7;
  v10 = *(_BYTE *)(v8 + v6 + 62);
  v77 = 1;
  v79 = v8 + v6 + 8;
  if ( v10 == 6 )
  {
    *(_BYTE *)(v8 + v6 + 62) = *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(v5 + 12) + 3);
    sub_1002C7C0(v6, v5, 3);
    byte_104E6D94[8 * *(_BYTE *)(v5 + 12)] = 1;
    dword_104E6D90[2 * *(_BYTE *)(v5 + 12)] = v80;
    v77 = 1;
    byte_104E6D95[8 * *(_BYTE *)(v5 + 12)] = 3;
  }
  else if ( v10 >= 7u )
  {
    *(_BYTE *)(v8 + v6 + 62) = 0;
    sub_1002C7C0(v6, v5, 2);
    v77 = 0;
    byte_104E6D95[8 * *(_BYTE *)(v5 + 12)] = 4;
  }
  v11 = *(_BYTE *)(v5 + 12);
  v12 = *((_BYTE *)&dword_104E6CF8 + 5 * v11 + 3);
  v13 = *(_BYTE *)(v9 + 54);
  if ( v12 != v13 && *((_BYTE *)&dword_104E6CFC + 5 * v11) == *(_BYTE *)(v6 + 1) )
  {
    v14 = sub_1002C7C0(v6, v5, v13 < v12);
    if ( *(_BYTE *)(v9 + 30) )
    {
      if ( v14 && *(_BYTE *)(v9 + 53) )
      {
        byte_104E6D94[8 * *(_BYTE *)(v5 + 12)] = v77;
        dword_104E6D90[2 * *(_BYTE *)(v5 + 12)] = v80;
        byte_104E6D95[8 * *(_BYTE *)(v5 + 12)] = 3;
      }
    }
  }
  if ( *(_BYTE *)(v6 + 7) == 1 )
  {
    *(_BYTE *)(v6 + 7) = 0;
    v15 = *(_BYTE *)(v5 + 12);
    v16 = (_BYTE *)(v6 + 3);
    if ( *((_BYTE *)&dword_104E6CF8 + 5 * v15) == *(_BYTE *)(v6 + 3)
      && *((_BYTE *)&dword_104E6CF8 + 5 * v15 + 1) == *(_BYTE *)(v6 + 4) )
    {
      v17 = (_BYTE *)(v6 + 5);
      if ( *((_BYTE *)&dword_104E6CF8 + 5 * v15 + 2) == *(_BYTE *)(v6 + 5) )
      {
LABEL_27:
        if ( *((_BYTE *)&dword_104E6CFC + 5 * *(_BYTE *)(v5 + 12)) != *(_BYTE *)(v6 + 1) )
        {
          byte_104E6DA4[8 * *(_BYTE *)(v5 + 12)] = *(_BYTE *)(v79 + 32);
          dword_104E6DA0[2 * *(_BYTE *)(v5 + 12)] = v80;
          *((_BYTE *)&dword_104E6CFC + 5 * *(_BYTE *)(v5 + 12)) = *(_BYTE *)(v6 + 1);
          v73 = v6 + 4;
          if ( *(_BYTE *)(v6 + 1) == 1 )
          {
            sub_1006A170(3197, v73, 1);
            sub_1006A170(3198, v6 + 3, 1);
            sub_1006A170(3199, (int)v17, 1);
            v69 = v79 + 54;
            v68 = 9291;
          }
          else
          {
            sub_1006A170(3194, v73, 1);
            sub_1006A170(3195, v6 + 3, 1);
            sub_1006A170(3196, (int)v17, 1);
            v69 = v79 + 54;
            v68 = 9290;
          }
          sub_1006A170(v68, v69, 1);
          v18 = *(_BYTE *)(v5 + 12);
          *(int *)((char *)&dword_104E6CF8 + 5 * v18) = 0;
          *(int *)((char *)&dword_104E6CFC + 5 * v18) = 0;
          *(__int16 *)((char *)&word_104E6D00 + 5 * v18) = 0;
          *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(v5 + 12)) = *v16;
          *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(v5 + 12) + 1) = *(_BYTE *)(v6 + 4);
          *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(v5 + 12) + 2) = *v17;
          *((_BYTE *)&dword_104E6CFC + 5 * *(_BYTE *)(v5 + 12)) = *(_BYTE *)(v6 + 1);
          sub_1002C7C0(v6, v5, 3);
          byte_104E6D94[8 * *(_BYTE *)(v5 + 12)] = 0;
        }
        j_HWM_pvg_set_decoder_cfg(v6 + 1);
        v4 = a4;
        v9 = v79;
        goto LABEL_33;
      }
      v9 = v79;
    }
    if ( !*(_BYTE *)(v5 + 13) )
    {
      v72 = v6 + 3;
      if ( *(_BYTE *)(v6 + 1) == 1 )
      {
        sub_1006A190(3198, v72, 1);
        sub_1006A190(3197, v6 + 4, 1);
        v71 = v6 + 5;
        v70 = 3199;
      }
      else
      {
        sub_1006A190(3195, v72, 1);
        sub_1006A190(3194, v6 + 4, 1);
        v71 = v6 + 5;
        v70 = 3196;
      }
      sub_1006A190(v70, v71, 1);
    }
    if ( *(_BYTE *)(v9 + 29) && *(_BYTE *)(v9 + 53) )
    {
      byte_104E6D94[8 * *(_BYTE *)(v5 + 12)] = v77;
      dword_104E6D90[2 * *(_BYTE *)(v5 + 12)] = v80;
      if ( *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(v5 + 12)) == *v16 )
        byte_104E6D95[8 * *(_BYTE *)(v5 + 12)] = (*((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(v5 + 12) + 1) == *(_BYTE *)(v6 + 4))
                                               + 1;
      else
        byte_104E6D95[8 * *(_BYTE *)(v5 + 12)] = 0;
    }
    *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(v5 + 12)) = *v16;
    *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(v5 + 12) + 1) = *(_BYTE *)(v6 + 4);
    v17 = (_BYTE *)(v6 + 5);
    *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(v5 + 12) + 2) = *(_BYTE *)(v6 + 5);
    goto LABEL_27;
  }
LABEL_33:
  if ( sub_1005FF20() || (v78 = 1, !(unsigned __int8)j_HWM_pvg_is_video_conn()) )
    v78 = 0;
  j_gdi_pvg_color_u32(*(_DWORD *)(v5 + 4));
  j_gdi_pvg_begin(72);
  v19 = (double)*(_WORD *)(v4 + 2);
  v20 = (double)*(_WORD *)v4;
  sub_10069EF0(v20, v19);
  v21 = (double)*(_WORD *)(v4 + 2);
  v22 = (double)*(_WORD *)v4 + (double)*(_WORD *)(v5 + 8);
  sub_10069EF0(v22, v21);
  v23 = (double)*(_WORD *)(v4 + 2) + (double)*(_WORD *)(v5 + 10);
  v24 = v23;
  v25 = (double)*(_WORD *)v4 + (double)*(_WORD *)(v5 + 8);
  sub_10069EF0(v25, v24);
  v26 = (double)*(_WORD *)(v4 + 2) + (double)*(_WORD *)(v5 + 10);
  v27 = (double)*(_WORD *)v4;
  sub_10069EF0(v27, v26);
  j_gdi_pvg_end(v75);
  if ( v78 == 1 )
  {
    v28 = (_DWORD *)sub_1006A450(0x56u);
    j_gdi_pvg_bind_texture(34, *v28);
    j_gdi_pvg_enable(34);
    j_gdi_pvg_push_matrix();
    sub_10069AB0(1.0, 1.0, 1.0, 1.0);
    j_gdi_pvg_begin(72);
    v29 = 0;
    while ( 1 )
    {
      v30 = (v29 + *(_BYTE *)(v9 + 28)) % 4;
      v31 = 2 * (v29 + 4 * *(_BYTE *)(v5 + 12));
      sub_10069DB0(flt_104E6CB8[v31], flt_104E6CBC[v31]);
      v32 = 2 * ((unsigned __int8)v30 + 4 * *(_BYTE *)(v5 + 12));
      sub_10069EF0(flt_104E6D50[v32], flt_104E6D54[v32]);
      if ( ++v29 >= 4 )
        break;
      v9 = v79;
    }
    j_gdi_pvg_end(v76);
    j_gdi_pvg_disable(34);
    j_gdi_pvg_pop_matrix();
    if ( *(_BYTE *)(v79 + 25) && *(_BYTE *)(v79 + 54) > *(_BYTE *)(v79 + 56) )
    {
      sub_1002C050(v6, v5, v76);
      v9 = v79;
    }
    else
    {
      v9 = v79;
    }
    v4 = a4;
  }
  else
  {
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    j_gdi_pvg_color_u32(-256);
    v33 = sub_10037280(0x127Du);
    v34 = sub_1006AC90(6, (int)v33, 18.0);
    v35 = (double)*(_WORD *)(v5 + 8) * 0.5 + (double)*(_WORD *)v4 - v34 * 0.5;
    v36 = 0.5 * (double)*(_WORD *)(v5 + 10) + (double)*(_WORD *)(v4 + 2) - 9.0;
    v37 = sub_10037280(0x127Du);
    sub_1006AAF0(6, (int)v37, v35, v36, 18.0);
    j_gdi_pvg_disable(35);
  }
  if ( *(_BYTE *)(v9 + 31)
    && (!*(_BYTE *)(v9 + 32)
     || (v38 = 2 * *(_BYTE *)(v5 + 12), byte_104E6DA4[v38 * 4])
     && (double)*(_BYTE *)(v9 + 53) * 1000.0 >= (double)(unsigned int)(v80 - dword_104E6DA0[v38])) )
  {
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    j_gdi_pvg_color_u32(-16711936);
    v39 = (double)*(_WORD *)(v4 + 2) + 10.0;
    v40 = v39;
    v41 = (double)*(_WORD *)v4 + 10.0;
    sub_1006AAF0(6, v9 + 33, v41, v40, 18.0);
    j_gdi_pvg_disable(35);
  }
  else
  {
    byte_104E6DA4[8 * *(_BYTE *)(v5 + 12)] = 0;
  }
  v42 = 8 * *(_BYTE *)(v5 + 12);
  if ( byte_104E6D94[v42] != 1
    || (double)*(_BYTE *)(v9 + 53) * 1000.0 < (double)(unsigned int)(v80 - dword_104E6D90[v42 / 4]) )
  {
    byte_104E6D94[v42] = 0;
  }
  else
  {
    switch ( byte_104E6D95[v42] )
    {
      case 3:
        v43 = sub_1003B860((_DWORD *)(*(_BYTE *)(v9 + 54) + v9 + 57), 1u, (int)&unk_100A1D5C, 12, 5, 0);
        sub_10036790(&v81, 0x64u, "ZOOM: Xx");
        sub_10036790(&v82, 0x64u, "ZOOM: %ix", (signed int)flt_100A1D60[3 * v43]);
        v9 = v79;
        break;
      case 0:
        sub_10036790(&v81, 0x64u, "BRIGHTNESS: XXX%%");
        sub_10036790(&v82, 0x64u, "BRIGHTNESS: %i%%", *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(v5 + 12)));
        break;
      case 1:
        sub_10036790(&v81, 0x64u, "CONTRAST: XXX%%");
        sub_10036790(&v82, 0x64u, "CONTRAST: %i%%", *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(v5 + 12) + 1));
        break;
      case 2:
        sub_10036790(&v81, 0x64u, "SATURATION: XXX%%");
        sub_10036790(&v82, 0x64u, "SATURATION: %i%%", *((_BYTE *)&dword_104E6CF8 + 5 * *(_BYTE *)(v5 + 12) + 2));
        break;
      default:
        sub_10036790(&v82, 0x64u, byte_100A1E40);
        sub_10036790(&v81, 0x64u, byte_100A1E40);
        break;
    }
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    j_gdi_pvg_color_u32(-16711936);
    v44 = sub_1006AC90(6, (int)&v81, 18.0);
    v45 = (double)*(_WORD *)(v4 + 2) + (double)*(_WORD *)(v5 + 10) - 20.0 - 18.0;
    v46 = v45;
    v47 = (double)*(_WORD *)(v5 + 8) * 0.5 + (double)*(_WORD *)v4 - 0.5 * v44;
    sub_1006AAF0(6, (int)&v82, v47, v46, 18.0);
    j_gdi_pvg_disable(35);
  }
  if ( *(_BYTE *)v6 == 1 )
  {
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    if ( *(_BYTE *)(v9 + 27) && *(_BYTE *)(v6 + 6) == 1 )
    {
      j_gdi_pvg_color_u32(-16711681);
      sub_10069C80(2.0);
      j_gdi_pvg_begin(66);
      v48 = (double)*(_WORD *)(v4 + 2);
      v49 = (double)*(_WORD *)v4;
      sub_10069EF0(v49, v48);
      v50 = (double)*(_WORD *)(v4 + 2);
      v51 = (double)*(_WORD *)v4 + (double)*(_WORD *)(v5 + 8) - 1.0;
      sub_10069EF0(v51, v50);
      v52 = (double)*(_WORD *)(v4 + 2) + (double)*(_WORD *)(v5 + 10) - 1.0;
      v53 = v52;
      v54 = (double)*(_WORD *)v4 + (double)*(_WORD *)(v5 + 8) - 1.0;
      sub_10069EF0(v54, v53);
      v55 = (double)*(_WORD *)(v4 + 2) + (double)*(_WORD *)(v5 + 10) - 1.0;
      v74 = v55;
      v56 = (double)*(_WORD *)v4;
    }
    else
    {
      v57 = sub_10039810(-1);
      j_gdi_pvg_color_u32(v57);
      sub_10069C80(1.0);
      j_gdi_pvg_begin(66);
      v58 = (double)*(_WORD *)(v4 + 2);
      v59 = (double)*(_WORD *)v4;
      sub_10069EF0(v59, v58);
      v60 = (double)*(_WORD *)(v4 + 2);
      v61 = (double)*(_WORD *)v4 + (double)*(_WORD *)(v5 + 8);
      sub_10069EF0(v61, v60);
      v62 = (double)*(_WORD *)(v4 + 2) + (double)*(_WORD *)(v5 + 10);
      v63 = v62;
      v64 = (double)*(_WORD *)v4 + (double)*(_WORD *)(v5 + 8);
      sub_10069EF0(v64, v63);
      v65 = (double)*(_WORD *)(v4 + 2) + (double)*(_WORD *)(v5 + 10);
      v74 = v65;
      v56 = (double)*(_WORD *)v4;
    }
    v66 = v56;
    sub_10069EF0(v66, v74);
    j_gdi_pvg_end(v76);
    j_gdi_pvg_disable(35);
  }
  dword_104E6D48[*(_BYTE *)(v5 + 12)] = v80;
  result = sub_10038D60(0x13Bu, 1);
  *(_BYTE *)(a3 + 6) = 2;
  return result;
}
// 100699C0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100699E0: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 10069A50: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10069B20: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10069B40: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10069BC0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10069BE0: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 10069D20: using guessed type int j_gdi_pvg_pop_matrix(void);
// 10069D40: using guessed type int j_gdi_pvg_push_matrix(void);
// 1006BB70: using guessed type int j_HWM_pvg_is_video_conn(void);
// 1006BBF0: using guessed type int __cdecl j_HWM_pvg_set_decoder_cfg(_DWORD);
// 100A1D60: using guessed type float flt_100A1D60[];
// 104E6CB8: using guessed type float flt_104E6CB8[];
// 104E6CBC: using guessed type float flt_104E6CBC[];
// 104E6CF8: using guessed type int dword_104E6CF8;
// 104E6CFC: using guessed type int dword_104E6CFC;
// 104E6D00: using guessed type __int16 word_104E6D00;
// 104E6D48: using guessed type int dword_104E6D48[];
// 104E6D50: using guessed type float flt_104E6D50[];
// 104E6D54: using guessed type float flt_104E6D54[];
// 104E6D90: using guessed type int dword_104E6D90[];
// 104E6DA0: using guessed type int dword_104E6DA0[];

//----- (1002E020) --------------------------------------------------------
char __cdecl sub_1002E020(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v5; // ecx@1
  char result; // al@2

  if ( sub_1002C530(a4) == 1 )
  {
    switch ( *a5 )
    {
      case 0x8041:
        sub_1002D0C0(v5, a2, a3);
        result = 1;
        break;
      case 0x8048:
        sub_1002D280(v5, a2, a1);
        result = 1;
        break;
      case 0x8022:
      case 0x8078:
        sub_1002D380(v5, a2, a1, a3);
        goto LABEL_7;
      default:
LABEL_7:
        result = 1;
        break;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002E120) --------------------------------------------------------
BOOL __thiscall sub_1002E120(void *this)
{
  void *v1; // ecx@1
  char v2; // al@1
  void *v4; // [sp-2h] [bp-4h]@1

  v4 = this;
  sub_1006BA40(48, (_BYTE *)&v4 + 3);
  v2 = sub_10036FE0(v1);
  return BYTE3(v4) && (v2 == 1 || v2 == 8 || v2 == 2 || v2 == 4);
}

//----- (1002E160) --------------------------------------------------------
char sub_1002E160()
{
  int v0; // eax@1
  char result; // al@5
  char v2; // [sp+3h] [bp-59h]@1
  char *v3; // [sp+4h] [bp-58h]@1
  int v4; // [sp+8h] [bp-54h]@1
  int v5; // [sp+Ch] [bp-50h]@1
  __int16 *v6; // [sp+10h] [bp-4Ch]@1
  int v7; // [sp+14h] [bp-48h]@1
  int *v8; // [sp+18h] [bp-44h]@1
  int v9; // [sp+1Ch] [bp-40h]@1
  int v10; // [sp+20h] [bp-3Ch]@1
  __int16 v11; // [sp+24h] [bp-38h]@1
  char v12; // [sp+26h] [bp-36h]@1
  char v13; // [sp+28h] [bp-34h]@1

  v5 = 0;
  v13 = 0;
  v6 = &v11;
  v2 = 10;
  v11 = -32754;
  v12 = 1;
  v10 = 4;
  v7 = 5;
  v8 = (int *)&v3;
  v9 = 1000;
  v3 = &v2;
  v4 = 1;
  v0 = sub_10069830(18, (int)&v6);
  if ( v0 || v5 || v4 != 1 )
  {
    if ( v0 == 3 )
      result = 13;
    else
      result = 10;
  }
  else
  {
    result = v2;
  }
  return result;
}

//----- (1002E240) --------------------------------------------------------
char __cdecl sub_1002E240(void *a1)
{
  int v1; // esi@1
  char *v3; // [sp+Ch] [bp-F0h]@1
  int v4; // [sp+10h] [bp-ECh]@1
  int v5; // [sp+14h] [bp-E8h]@1
  __int16 *v6; // [sp+18h] [bp-E4h]@1
  int v7; // [sp+1Ch] [bp-E0h]@1
  int *v8; // [sp+20h] [bp-DCh]@1
  int v9; // [sp+24h] [bp-D8h]@1
  int v10; // [sp+28h] [bp-D4h]@1
  __int16 v11; // [sp+2Ch] [bp-D0h]@1
  char v12; // [sp+2Eh] [bp-CEh]@1
  char v13; // [sp+30h] [bp-CCh]@1
  char v14; // [sp+60h] [bp-9Ch]@1

  memset(&v14, 0, 0x98u);
  v6 = &v11;
  v5 = 0;
  v13 = 0;
  v11 = -32748;
  v12 = 1;
  v10 = 4;
  v7 = 5;
  v8 = (int *)&v3;
  v9 = 1000;
  v3 = &v14;
  v4 = 152;
  v1 = sub_10069830(18, (int)&v6);
  if ( v5 != 3 || sub_1002E160() != 7 )
  {
    if ( !v1 && !v5 && v4 == 152 )
    {
      qmemcpy(a1, &v14, 0x98u);
      return 0;
    }
    memset(a1, 0, 0x98u);
    *(_BYTE *)a1 = 0;
    *((_WORD *)a1 + 69) = 0x7FFF;
    *((_DWORD *)a1 + 35) = -1;
    *((_DWORD *)a1 + 36) = -1;
  }
  else
  {
    qmemcpy(a1, &v14, 0x98u);
  }
  return 3;
}

//----- (1002E390) --------------------------------------------------------
char __cdecl sub_1002E390(__int16 a1, char *a2, __int16 a3, int a4)
{
  __int16 v4; // ax@4
  char result; // al@4
  char *v6; // [sp+Ch] [bp-F0h]@1
  int v7; // [sp+10h] [bp-ECh]@1
  int v8; // [sp+14h] [bp-E8h]@1
  __int16 *v9; // [sp+18h] [bp-E4h]@1
  int v10; // [sp+1Ch] [bp-E0h]@1
  int *v11; // [sp+20h] [bp-DCh]@1
  int v12; // [sp+24h] [bp-D8h]@1
  int v13; // [sp+28h] [bp-D4h]@1
  char v14; // [sp+2Ch] [bp-D0h]@1
  __int16 v15; // [sp+2Eh] [bp-CEh]@4
  char v16; // [sp+30h] [bp-CCh]@4
  __int16 v17; // [sp+64h] [bp-98h]@1
  __int16 v18; // [sp+68h] [bp-94h]@1
  __int16 v19; // [sp+6Ah] [bp-92h]@1

  v8 = 0;
  v9 = &v17;
  v19 = a1;
  v17 = -32754;
  v18 = a3;
  v13 = 4;
  v10 = 8;
  v11 = (int *)&v6;
  v12 = 200;
  v6 = &v14;
  v7 = 56;
  if ( sub_10069830(38, (int)&v9) || v8 || v7 != 56 )
  {
    sub_100365D0((int)a2, "None", (unsigned __int16)a3);
    *(_WORD *)a4 = -1;
    result = 0;
  }
  else
  {
    strncpy(a2, &v16, (unsigned __int16)a3);
    v4 = v15;
    a2[(unsigned __int16)a3 - 1] = 0;
    *(_WORD *)a4 = v4;
    result = v14;
  }
  return result;
}

//----- (1002E4C0) --------------------------------------------------------
const char *__cdecl sub_1002E4C0(const char *a1, int a2)
{
  signed int v2; // eax@1
  const char *result; // eax@6
  int v4; // edx@10
  char v5; // cl@11

  *(_DWORD *)a2 = 757935405;
  *(_BYTE *)(a2 + 4) = 0;
  v2 = strlen(a1) - 1;
  if ( v2 >= 0 )
  {
    while ( a1[v2] != 32 )
    {
      if ( --v2 < 0 )
        goto LABEL_6;
    }
    a1[v2] = 0;
  }
LABEL_6:
  result = (const char *)(strlen(a1) - 1);
  if ( (signed int)result >= 0 )
  {
    while ( a1[(_DWORD)result] != 32 )
    {
      if ( (signed int)--result < 0 )
        return result;
    }
    a1[(_DWORD)result] = 0;
    result = &a1[(_DWORD)result + 1];
    v4 = a2 - (_DWORD)result;
    do
    {
      v5 = *result;
      result[v4] = *result;
      ++result;
    }
    while ( v5 );
  }
  return result;
}

//----- (1002E540) --------------------------------------------------------
char __thiscall sub_1002E540(void *this)
{
  int v1; // eax@1
  bool v2; // zf@1
  char result; // al@1

  v1 = sub_10037130(this);
  v2 = sub_10041650(28, v1) == 1;
  result = 1;
  if ( !v2 )
    result = 2;
  return result;
}

//----- (1002E560) --------------------------------------------------------
char __cdecl sub_1002E560(void *a1, char *a2)
{
  void *v2; // ecx@0
  char v3; // al@1
  char result; // al@2
  int v5; // eax@3
  char v6; // [sp+7h] [bp-1h]@1

  v6 = 3;
  v3 = sub_10038600(v2);
  if ( (_BYTE)a1 == sub_10038390(v3) )
  {
    *a2 = sub_1002E540(a1);
    result = 1;
  }
  else
  {
    v5 = (unsigned __int16)sub_10039660((unsigned __int8)a1);
    if ( (_WORD)v5 == 904 || sub_1003E2C0(2, v5, &v6) != 1 || sub_10042830((unsigned __int8 *)&v6) )
    {
      result = 0;
    }
    else
    {
      *a2 = v6;
      result = 1;
    }
  }
  return result;
}

//----- (1002E5E0) --------------------------------------------------------
char __cdecl sub_1002E5E0(int a1, int a2)
{
  int v2; // ecx@2
  char result; // al@2
  char v4; // [sp+8h] [bp-78h]@1
  int v5; // [sp+18h] [bp-68h]@2
  int v6; // [sp+1Ch] [bp-64h]@2

  memset(&v4, 0, 0x74u);
  if ( sub_10039400(a1, &v4) == 1 )
  {
    v2 = v6;
    *(_DWORD *)a2 = v5;
    *(_DWORD *)(a2 + 4) = v2;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002E660) --------------------------------------------------------
char __cdecl sub_1002E660(unsigned __int8 a1)
{
  char result; // al@1
  char v2[176]; // [sp+4h] [bp-B4h]@1

  memset(v2, 0, 0xB0u);
  result = 0;
  if ( a1 < 0xB0u )
  {
    sub_100395A0(v2);
    result = v2[a1];
  }
  return result;
}
// 1002E660: using guessed type char var_B4[176];

//----- (1002E6D0) --------------------------------------------------------
int __cdecl sub_1002E6D0(unsigned int a1)
{
  return sub_10001160(dword_104E6E10, a1);
}
// 104E6E10: using guessed type int dword_104E6E10;

//----- (1002E6F0) --------------------------------------------------------
int sub_1002E6F0()
{
  _BYTE *v0; // esi@1
  int result; // eax@3

  v0 = sub_100016C0("checklist");
  sub_100012C0((int)v0, 0x20u, 400);
  sub_100012C0((int)v0, 0x40u, 400);
  sub_100012C0((int)v0, 0x80u, 400);
  sub_100012C0((int)v0, 0x100u, 1000);
  sub_100012C0((int)v0, 0x200u, 400);
  sub_100012C0((int)v0, 0x400u, 10);
  sub_100012C0((int)v0, 0x800u, 0);
  sub_100012C0((int)v0, 0x1000u, 0);
  sub_100012C0((int)v0, 0x2000u, 0);
  sub_100012C0((int)v0, 0x4000u, 0);
  sub_100012C0((int)v0, 0x8000u, 8);
  sub_100012C0((int)v0, 0x10000u, 6);
  sub_100012C0((int)v0, 0x20000u, 1);
  sub_100012C0((int)v0, 0x40000u, 0);
  sub_100012C0((int)v0, 0x100000u, 0);
  if ( (unsigned int)sub_10001780((int)v0) > 0x177090 )
    sub_100364C0("..\\lib\\adl\\cdp_utl_chklst.c", 370, 1, 0);
  result = sub_100017A0((int)v0, &unk_104E6E18, 0x177090u);
  dword_104E6E10 = result;
  return result;
}
// 104E6E10: using guessed type int dword_104E6E10;

//----- (1002E810) --------------------------------------------------------
bool __cdecl sub_1002E810(int a1)
{
  void *v1; // eax@5
  bool result; // al@2

  if ( a1 )
  {
    if ( a1 )
    {
      v1 = sub_10001DA0(a1);
      if ( v1 )
        result = sub_10001BD0((int)v1) != 0;
      else
        result = 0;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002E830) --------------------------------------------------------
int sub_1002E830()
{
  return sub_1006A190(41042, (int)&unk_100A4410, 1024);
}

//----- (1002E850) --------------------------------------------------------
char __cdecl sub_1002E850(int a1, unsigned __int8 a2)
{
  char result; // al@2

  if ( dword_1065DECC )
  {
    sub_100365D0(a1, dword_1065DECC, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002E880) --------------------------------------------------------
char __cdecl sub_1002E880(int a1, unsigned __int8 a2)
{
  char result; // al@2

  if ( dword_1065DEC8 )
  {
    sub_100365D0(a1, (_BYTE *)dword_1065DEC8, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1065DEC8: using guessed type int dword_1065DEC8;

//----- (1002E8B0) --------------------------------------------------------
char __cdecl sub_1002E8B0(int a1, unsigned __int8 a2)
{
  char result; // al@2

  if ( dword_1065DEC4 )
  {
    sub_100365D0(a1, (_BYTE *)dword_1065DEC4, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1065DEC4: using guessed type int dword_1065DEC4;

//----- (1002E8E0) --------------------------------------------------------
BOOL __cdecl sub_1002E8E0(char a1)
{
  return a1 == 99 || a1 == 114 || a1 == 110 || a1 == 112 || a1 == 97 || a1 == 119;
}

//----- (1002E910) --------------------------------------------------------
signed int __usercall sub_1002E910@<eax>(int a1@<eax>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 1:
      result = 41072;
      break;
    case 2:
      result = 41073;
      break;
    case 4:
      result = 41074;
      break;
    case 8:
      result = 41075;
      break;
    case 64:
      result = 41076;
      break;
    case 128:
      result = 41077;
      break;
    case 16:
      result = 41078;
      break;
    case 32:
      result = 41079;
      break;
    default:
      result = 42066;
      break;
  }
  return result;
}

//----- (1002EA00) --------------------------------------------------------
signed int __usercall sub_1002EA00@<eax>(int a1@<eax>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 1:
      result = 41080;
      break;
    case 2:
      result = 41081;
      break;
    case 4:
      result = 41082;
      break;
    case 8:
      result = 41083;
      break;
    case 64:
      result = 41084;
      break;
    case 128:
      result = 41085;
      break;
    case 16:
      result = 41086;
      break;
    case 32:
      result = 41087;
      break;
    default:
      result = 42066;
      break;
  }
  return result;
}

//----- (1002EAF0) --------------------------------------------------------
int sub_1002EAF0()
{
  int v0; // esi@1
  int v1; // ebx@2
  char *v2; // edi@2
  unsigned int v3; // eax@3
  int v4; // ecx@4
  int result; // eax@7
  char v6; // [sp+7h] [bp-5h]@7
  int v7; // [sp+8h] [bp-4h]@2

  v0 = 0;
  if ( dword_1065DEA8 )
  {
    v1 = dword_1065DEB4;
    v2 = (char *)dword_1065DEAC + 4;
    v7 = dword_1065DEA8;
    do
    {
      v3 = 0;
      if ( *(_DWORD *)v2 )
      {
        v4 = *((_DWORD *)v2 + 1);
        do
        {
          *(_DWORD *)(v1 + 28 * (v3 + v4) + 20) = v0;
          v4 = *((_DWORD *)v2 + 1);
          v0 += *(_DWORD *)(v1 + 28 * (v4 + v3++) + 16);
        }
        while ( v3 < *(_DWORD *)v2 );
      }
      v2 += 12;
      --v7;
    }
    while ( v7 );
  }
  result = sub_1006A100(41043, &v6, 1, &unk_100A3EE6);
  if ( !v6 )
  {
    v6 = 1;
    sub_1006A190(41043, (int)&v6, 1);
    result = sub_1002E830();
  }
  return result;
}
// 1065DEA8: using guessed type int dword_1065DEA8;
// 1065DEB4: using guessed type int dword_1065DEB4;

//----- (1002EBA0) --------------------------------------------------------
BOOL __usercall sub_1002EBA0@<eax>(char a1@<al>)
{
  return a1 == 99 || a1 == 114;
}

//----- (1002EBC0) --------------------------------------------------------
BOOL __usercall sub_1002EBC0@<eax>(char a1@<al>)
{
  return a1 == 99 || a1 == 114 || a1 == 110 || a1 == 112 || a1 == 116 || a1 == 97 || a1 == 119 || !a1;
}

//----- (1002EBF0) --------------------------------------------------------
char __cdecl sub_1002EBF0(int a1)
{
  int v1; // ecx@0
  int v2; // eax@1
  int v4; // [sp-2h] [bp-4h]@1

  v4 = v1;
  v2 = sub_1002EA00(a1);
  sub_1006A140(v2, (int)&v4 + 3, 1);
  return BYTE3(v4);
}

//----- (1002EC10) --------------------------------------------------------
int __cdecl sub_1002EC10(int a1, char a2)
{
  int v2; // eax@1

  v2 = sub_1002EA00(a1);
  return sub_1006A190(v2, (int)&a2, 1);
}

//----- (1002EC30) --------------------------------------------------------
char sub_1002EC30()
{
  int v0; // edi@1
  unsigned int v1; // esi@1
  char *v2; // eax@2
  _BYTE *v3; // eax@2
  char *v4; // eax@5
  void *v5; // ecx@6
  int v6; // eax@6
  char result; // al@6
  char *v8; // eax@7
  _DWORD *v9; // eax@11
  void *v10; // ecx@12
  int v11; // eax@12
  _BYTE *v12; // ecx@13
  unsigned int i; // esi@15
  char *v14; // ecx@16
  _BYTE *v15; // ecx@16
  char v16; // cl@18
  char *v17; // eax@23
  int v18; // ecx@23
  int v19; // eax@23
  int v20; // eax@25
  char *v21; // ebx@25
  void *v22; // ebp@25
  unsigned int v23; // ecx@27
  int v24; // esi@27
  int v25; // edx@28
  int v26; // ebp@28
  int v27; // ebx@29
  char v28; // al@29
  char *v29; // eax@34
  char v30; // bl@34
  void *v31; // ecx@38
  _DWORD *v32; // edx@39
  int v33; // ecx@39
  int v34; // eax@47
  int v35; // eax@49
  int v36; // eax@50
  int v37; // eax@51
  char v38; // dl@53
  int v39; // eax@53
  int v40; // eax@56
  void *v41; // ecx@57
  int v42; // eax@57
  void *v43; // ecx@58
  int v44; // eax@58
  char v45; // [sp+Bh] [bp-Dh]@27
  int v46; // [sp+Ch] [bp-Ch]@27
  int v47; // [sp+10h] [bp-8h]@27
  unsigned __int16 v48; // [sp+14h] [bp-4h]@1

  v0 = 0;
  v48 = 0;
  dword_1065DEB8[0] = 0;
  dword_104E6E00 = 0;
  dword_104E6E04 = 0;
  dword_1065DEBC[0] = dword_104E6E14 + 10;
  v1 = 1;
  do
  {
    v2 = strchr((const char *)dword_1065DEB8[v1], 13);
    dword_1065DEBC[v1] = (int)v2;
    *v2 = 0;
    v3 = (_BYTE *)(dword_1065DEBC[v1] + 1);
    dword_1065DEBC[v1] = (int)v3;
    if ( *v3 == 10 )
      dword_1065DEBC[v1] = (int)(v3 + 1);
    ++v1;
  }
  while ( v1 < 5 );
  v4 = strchr(dword_1065DECC, 13);
  if ( v4 )
  {
    *v4 = 0;
    v8 = v4 + 1;
    if ( *v8 == 10 )
      ++v8;
    for ( dword_1065DEB0 = (int)v8; v8; v8 = strchr(v8 + 1, 13) )
      ++dword_1065DEB8[0];
    v9 = (_DWORD *)sub_1002E6D0(4 * dword_1065DEB8[0]);
    dword_104E6E08 = (int)v9;
    if ( v9 )
    {
      v12 = (_BYTE *)dword_1065DEB0;
      *v9 = dword_1065DEB0;
      if ( *v12 == 60 )
        ++dword_104E6E04;
      for ( i = 1; i < dword_1065DEB8[0] - 1; ++i )
      {
        v14 = strchr((const char *)v9[i - 1], 13);
        v9 = (_DWORD *)dword_104E6E08;
        *(_DWORD *)(dword_104E6E08 + 4 * i) = v14;
        *v14 = 0;
        v15 = (_BYTE *)++v9[i];
        if ( *v15 == 10 )
          v9[i] = v15 + 1;
        v16 = *(_BYTE *)v9[i];
        if ( v16 == 60 )
          ++dword_104E6E04;
        if ( v16 == 40 )
          ++dword_104E6E00;
      }
      v17 = strchr((const char *)v9[i - 1], 13);
      v18 = dword_104E6E08;
      *(_DWORD *)(dword_104E6E08 + 4 * i) = v17;
      *v17 = 0;
      v19 = dword_104E6E04;
      ++*(_DWORD *)(v18 + 4 * i);
      if ( v19 && dword_104E6E00 )
      {
        dword_1065DEA8 = v19;
        dword_1065DEAC = (void *)sub_1002E6D0(12 * v19);
        v20 = sub_1002E6D0(28 * dword_104E6E00);
        v21 = (char *)dword_1065DEAC;
        v22 = (void *)v20;
        dword_1065DEB4 = v20;
        if ( dword_1065DEAC && v20 )
        {
          memset(dword_1065DEAC, 0, 12 * dword_104E6E04);
          memset(v22, 0, 28 * dword_104E6E00);
          v23 = 0;
          v24 = 0;
          v45 = 0;
          v46 = 0;
          v47 = 0;
          if ( dword_1065DEB8[0] )
          {
            v25 = (int)v22 + 16;
            v26 = (int)(v21 + 4);
            do
            {
              v27 = dword_104E6E08;
              v28 = **(_BYTE **)(dword_104E6E08 + 4 * v23);
              if ( v28 == 60 )
              {
                *(_DWORD *)(v26 - 4) = v23;
              }
              else if ( v28 == 62 )
              {
                if ( !v0 )
                {
                  v35 = sub_10037130((void *)v23);
                  sub_1002EC10(v35, 0);
                  sub_1002E810(dword_1065DEB4);
                  sub_1002E810((int)dword_1065DEAC);
                  sub_1002E810(dword_104E6E08);
                  sub_1002E810(dword_104E6E14);
                  sub_100364C0(
                    "..\\lib\\adl\\cdp_utl_chklst.c",
                    2380,
                    0,
                    "Invalid checklist file.  Group found with no checklist.");
                  return 0;
                }
                ++v47;
                *(_DWORD *)(v26 + 4) = v46 - v0;
                *(_DWORD *)v26 = v0;
                v26 += 12;
                v0 = 0;
              }
              v29 = *(char **)(v27 + 4 * v23);
              v30 = *v29;
              if ( *v29 == 41 )
              {
                if ( !v24 )
                {
                  v36 = sub_10037130((void *)v23);
                  sub_1002EC10(v36, 0);
                  sub_1002E810(dword_1065DEB4);
                  sub_1002E810((int)dword_1065DEAC);
                  sub_1002E810(dword_104E6E08);
                  sub_1002E810(dword_104E6E14);
                  sub_100364C0(
                    "..\\lib\\adl\\cdp_utl_chklst.c",
                    2403,
                    0,
                    "Invalid checklist file.  Checklist found with no entries.");
                  return 0;
                }
                ++v46;
                *(_DWORD *)(v25 - 8) = v24;
                *(_DWORD *)(v25 - 4) = v23 - v24;
                v25 += 28;
                v45 = 0;
                v24 = 0;
              }
              else if ( v45 )
              {
                if ( !(unsigned __int8)sub_1002EBC0(*v29) )
                {
                  v37 = sub_10037130(v31);
                  sub_1002EC10(v37, 0);
                  sub_1002E810(dword_1065DEB4);
                  sub_1002E810((int)dword_1065DEAC);
                  sub_1002E810(dword_104E6E08);
                  sub_1002E810(dword_104E6E14);
                  sub_100364C0(
                    "..\\lib\\adl\\cdp_utl_chklst.c",
                    2443,
                    0,
                    "Invalid checklist file.  Entry with invalid code found.");
                  return 0;
                }
                ++v24;
                if ( (unsigned __int8)sub_1002EBA0(v30) )
                {
                  ++*v32;
                  ++v48;
                }
                if ( (unsigned __int8)sub_1002E8E0(**(_BYTE **)(dword_104E6E08 + 4 * v33)) )
                  *(_DWORD *)(v25 + 8) = v24 - 1;
              }
              if ( **(_BYTE **)(dword_104E6E08 + 4 * v23) == 40 )
              {
                v45 = 1;
                *(_DWORD *)(v25 - 12) = v47;
                *(_DWORD *)(v25 - 16) = v23;
                ++v0;
              }
              ++v23;
            }
            while ( v23 < dword_1065DEB8[0] );
            if ( v48 > 0x800u )
            {
              v34 = sub_10037130((void *)v23);
              sub_1002EC10(v34, 0);
              sub_1002E810(dword_1065DEB4);
              sub_1002E810((int)dword_1065DEAC);
              sub_1002E810(dword_104E6E08);
              sub_1002E810(dword_104E6E14);
              sub_100364C0(
                "..\\lib\\adl\\cdp_utl_chklst.c",
                2472,
                0,
                "Invalid checklist file.  Number of checkable items exceeds 2048.");
              return 0;
            }
            v21 = (char *)dword_1065DEAC;
          }
          LOBYTE(v23) = *(_BYTE *)(dword_104E6E14 + 6);
          v38 = *(_BYTE *)(dword_104E6E14 + 7);
          v39 = (unsigned __int8)v23;
          byte_104E6E0C = *(_BYTE *)(dword_104E6E14 + 6);
          byte_104E6E0D = v38;
          if ( (unsigned __int8)v23 >= (unsigned int)dword_1065DEA8
            || (v23 = (unsigned __int8)v38, (unsigned int)(unsigned __int8)v38 >= *(_DWORD *)&v21[12 * v39 + 4]) )
          {
            byte_104E6E0C = 0;
            byte_104E6E0D = 0;
          }
          v40 = sub_10037130((void *)v23);
          sub_1002EC10(v40, 1);
          sub_1002EAF0();
          result = 1;
        }
        else
        {
          sub_100364C0(
            "..\\lib\\adl\\cdp_utl_chklst.c",
            2348,
            0,
            "Error allocating memory for groups or checklist structure.");
          v42 = sub_10037130(v41);
          sub_1002EC10(v42, 0);
          result = 0;
        }
      }
      else
      {
        sub_100364C0(
          "..\\lib\\adl\\cdp_utl_chklst.c",
          2335,
          0,
          "Invalid checklist file.  Group count or checklist count is 0.");
        v44 = sub_10037130(v43);
        sub_1002EC10(v44, 0);
        sub_1002E810(dword_104E6E08);
        sub_1002E810(dword_104E6E14);
        result = 0;
      }
    }
    else
    {
      sub_100364C0("..\\lib\\adl\\cdp_utl_chklst.c", 2288, 0, "Error allocating memory for checklist entries.");
      v11 = sub_10037130(v10);
      sub_1002EC10(v11, 0);
      result = 0;
    }
  }
  else
  {
    sub_100364C0(
      "..\\lib\\adl\\cdp_utl_chklst.c",
      2255,
      0,
      "Invalid checklist file.  No carriage return after last header line.");
    v6 = sub_10037130(v5);
    sub_1002EC10(v6, 0);
    sub_1002E810(dword_104E6E14);
    result = 0;
  }
  return result;
}
// 104E6E00: using guessed type int dword_104E6E00;
// 104E6E04: using guessed type int dword_104E6E04;
// 104E6E08: using guessed type int dword_104E6E08;
// 104E6E0C: using guessed type char byte_104E6E0C;
// 104E6E0D: using guessed type char byte_104E6E0D;
// 104E6E14: using guessed type int dword_104E6E14;
// 1065DEA8: using guessed type int dword_1065DEA8;
// 1065DEB0: using guessed type int dword_1065DEB0;
// 1065DEB4: using guessed type int dword_1065DEB4;
// 1065DEB8: using guessed type int dword_1065DEB8[];
// 1065DEBC: using guessed type int dword_1065DEBC[];

//----- (1002F1E0) --------------------------------------------------------
int __cdecl sub_1002F1E0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@1
  int result; // eax@1
  void *v5; // ecx@1
  int v6; // eax@2

  v2 = sub_10037130(v1);
  v3 = sub_1002E910(v2);
  result = sub_1006A190(v3, (int)&a1, 4);
  if ( !a1 )
  {
    v6 = sub_10037130(v5);
    result = sub_1002EC10(v6, 0);
  }
  return result;
}

//----- (1002F220) --------------------------------------------------------
char __thiscall sub_1002F220(void *this)
{
  int v1; // eax@1

  v1 = sub_10037130(this);
  return sub_1002EBF0(v1);
}

//----- (1002F230) --------------------------------------------------------
char sub_1002F230()
{
  char *v0; // edi@1
  char v1; // al@2
  unsigned int v2; // eax@3
  char *v3; // edi@3
  char v4; // cl@4
  unsigned int v5; // eax@5
  void *v6; // ecx@5
  unsigned int v7; // esi@5
  char *v8; // edi@7
  char v9; // al@8
  unsigned int v10; // eax@9
  char *v11; // edi@9
  char v12; // cl@10
  int v13; // eax@18
  signed int v15; // edi@23
  void *v16; // eax@24
  char v17; // [sp-4h] [bp-70h]@17
  int v18; // [sp+8h] [bp-64h]@1
  char v19; // [sp+Ch] [bp-60h]@3
  char v20; // [sp+2Bh] [bp-41h]@1
  int v21; // [sp+2Ch] [bp-40h]@1
  int v22; // [sp+30h] [bp-3Ch]@1
  __int16 v23; // [sp+34h] [bp-38h]@1
  char v24; // [sp+36h] [bp-36h]@1

  v21 = *(_DWORD *)"/mnt/card0";
  v18 = 0;
  dword_104E6E14 = 0;
  v22 = *(_DWORD *)"/card0";
  v23 = *(_WORD *)"d0";
  v24 = aMntCard0[10];
  v0 = &v20;
  do
    v1 = (v0++)[1];
  while ( v1 );
  *(_WORD *)v0 = 47;
  sub_1006A0A0(6567, (int)&v19, 30);
  v2 = strlen(&v19) + 1;
  v3 = &v20;
  do
    v4 = (v3++)[1];
  while ( v4 );
  qmemcpy(v3, &v19, v2);
  v5 = j_FIL_vfs_open(&v21, 4, 0);
  v7 = v5;
  if ( v5 >= 0xFFFFFFC2 || !v5 )
  {
    v21 = *(_DWORD *)"/mnt/card1";
    v22 = *(_DWORD *)"/card1";
    v23 = *(_WORD *)"d1";
    v24 = aMntCard1[10];
    v8 = &v20;
    do
      v9 = (v8++)[1];
    while ( v9 );
    *(_WORD *)v8 = 47;
    v10 = strlen(&v19) + 1;
    v11 = &v20;
    do
      v12 = (v11++)[1];
    while ( v12 );
    qmemcpy(v11, &v19, v10);
    v7 = j_FIL_vfs_open(&v21, 4, 0);
  }
  if ( v7 >= 0xFFFFFFC2 || !v7 )
    v7 = j_FIL_vfs_open("/mnt/sys_nand0/chklist.ace", 4, 0);
  if ( v7 >= 0xFFFFFFC2 || !v7 )
  {
    v17 = 2;
LABEL_18:
    v13 = sub_10037130(v6);
    sub_1002EC10(v13, v17);
    return 0;
  }
  if ( sub_1006B760(v7, -4, 2) < 0 )
  {
    sub_100364C0("..\\lib\\adl\\cdp_utl_chklst.c", 2103, 0, "Error seeking to CRC of checklist file.");
    v17 = 0;
    goto LABEL_18;
  }
  if ( sub_1006B2F0(v7, &v18, 4) != 4 )
  {
    sub_100364C0("..\\lib\\adl\\cdp_utl_chklst.c", 2116, 0, "Error reading CRC of checklist file.");
    v17 = 0;
    goto LABEL_18;
  }
  sub_1002F1E0(v18);
  v15 = sub_1006B760(v7, 0, 2);
  if ( (unsigned int)(v15 - 18) <= 0xFFFED )
  {
    v16 = (void *)sub_1002E6D0(v15);
    dword_104E6E14 = (int)v16;
    if ( !v16 )
    {
      sub_100364C0("..\\lib\\adl\\cdp_utl_chklst.c", 2143, 0, "Error allocating memory for checklist file.");
      v17 = 0;
      goto LABEL_18;
    }
    if ( sub_1006B340(v7, v16, v15, 0, 0) != v15 || sub_10022E80((unsigned int *)dword_104E6E14, v15, 0xFFFFFFFF) )
    {
      sub_100364C0("..\\lib\\adl\\cdp_utl_chklst.c", 2158, 0, "Error calculating CRC of checklist file.");
      sub_1002E810(dword_104E6E14);
      dword_104E6E14 = 0;
      sub_1002F1E0(0);
    }
  }
  sub_1006B1D0(v7);
  if ( !dword_104E6E14 )
  {
    sub_100364C0("..\\lib\\adl\\cdp_utl_chklst.c", 2178, 0, "Error reading checklist file.  CRC invalid?");
    v17 = 0;
    goto LABEL_18;
  }
  return 1;
}
// 1006B2E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 104E6E14: using guessed type int dword_104E6E14;

//----- (1002F540) --------------------------------------------------------
char sub_1002F540()
{
  char result; // al@1

  sub_1002E6F0();
  result = sub_1002F230();
  if ( result )
    result = sub_1002EC30();
  return result;
}

//----- (1002F560) --------------------------------------------------------
int __cdecl sub_1002F560(int a1, int a2)
{
  int v2; // eax@1
  void (__cdecl *v3)(int, _DWORD, signed int, signed int); // ecx@1
  int v4; // eax@3
  int v5; // eax@3
  void (__cdecl *v6)(int, _DWORD, signed int, _DWORD); // ecx@3
  int result; // eax@5

  v2 = *(_DWORD *)(a1 + 56);
  v3 = *(void (__cdecl **)(int, _DWORD, signed int, signed int))(v2 + 232);
  if ( v3 )
    v3(a1, *(_BYTE *)(v2 + 230), 255, 1);
  v4 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(a1 + 3) = 0;
  *(_BYTE *)(a1 + 5) = 1;
  sub_10037530(
    a1,
    (int)&unk_100B096C,
    *(char **)(*(_DWORD *)(v4 + 56) + 4 * a2),
    *(_DWORD *)(*(_DWORD *)(v4 + 60) + 4 * a2));
  v5 = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(a1 + 5) = 0;
  v6 = *(void (__cdecl **)(int, _DWORD, signed int, _DWORD))(v5 + 232);
  if ( v6 )
    v6(a1, *(_BYTE *)(v5 + 230), 255, 0);
  result = *(_DWORD *)(a1 + 56);
  *(_BYTE *)(result + 231) = *(_BYTE *)(result + 230);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  return result;
}

//----- (1002F600) --------------------------------------------------------
int __usercall sub_1002F600@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  int result; // eax@1
  void (__cdecl *v4)(int, int, int, signed int); // eax@2
  int v5; // eax@5
  int v6; // eax@6
  int v7; // edx@6

  *(_WORD *)(*(_DWORD *)(a3 + 56) + 240) = -128;
  *(_BYTE *)(*(_DWORD *)(a3 + 56) + 242) = 1;
  *(_BYTE *)(*(_DWORD *)(a3 + 56) + 230) = a1;
  *(_BYTE *)(*(_DWORD *)(a3 + 56) + 231) = *(_BYTE *)(*(_DWORD *)(a3 + 56) + 230);
  result = *(_DWORD *)(a3 + 56);
  if ( result == *(_DWORD *)(a3 + 48) )
  {
    v4 = *(void (__cdecl **)(int, int, int, signed int))(result + 232);
    if ( v4 )
      v4(a3, a2, a1, 1);
    if ( a2 != 255 )
    {
      v5 = *(_DWORD *)(a3 + 56);
      *(_BYTE *)(a3 + 3) = 0;
      *(_BYTE *)(a3 + 5) = 1;
      sub_10037530(
        a3,
        (int)&unk_100B096C,
        *(char **)(*(_DWORD *)(v5 + 56) + 4 * a2),
        *(_DWORD *)(*(_DWORD *)(v5 + 60) + 4 * a2));
    }
    v6 = *(_DWORD *)(a3 + 56);
    *(_BYTE *)(a3 + 3) = 1;
    *(_BYTE *)(a3 + 5) = 0;
    sub_10037530(
      a3,
      (int)&unk_100B096C,
      *(char **)(*(_DWORD *)(v6 + 56) + 4 * a1),
      *(_DWORD *)(*(_DWORD *)(v6 + 60) + 4 * a1));
    v7 = *(_DWORD *)(a3 + 56);
    *(_BYTE *)(a3 + 3) = 0;
    result = *(_DWORD *)(v7 + 232);
    if ( result )
      result = ((int (__cdecl *)(int, int, int, _DWORD))result)(a3, a2, a1, 0);
  }
  return result;
}

//----- (1002F6C0) --------------------------------------------------------
char __cdecl sub_1002F6C0(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // ebp@2
  unsigned __int8 v5; // dl@2
  int v6; // eax@4
  int v7; // edi@5
  unsigned __int8 v8; // cl@5
  int v9; // edi@15
  signed int v10; // eax@15
  bool v11; // zf@15
  char result; // al@21
  unsigned __int8 v13; // [sp+10h] [bp+8h]@3

  v3 = a2;
  if ( a2 == 255 )
    return 0;
  v4 = *(_DWORD *)(a1 + 56);
  v5 = *(_BYTE *)(v4 + 68);
  if ( !v5 )
    return 0;
  v13 = *(_BYTE *)(v4 + 230);
  if ( *(_BYTE *)(v4 + 68) > 1u )
  {
    v6 = a3;
    if ( a3 )
    {
      v7 = 2 * (a3 >= 0) - 1;
      v8 = *(_BYTE *)(v4 + 230);
      while ( 1 )
      {
        v3 += v7;
        if ( v3 < 0 || v3 >= v5 )
          break;
        if ( *(_BYTE *)(v3 + *(_DWORD *)(v4 + 64)) & 1 )
        {
          v8 = v3;
          v6 -= v7;
        }
        if ( !v6 )
          goto LABEL_20;
      }
      v3 = v8;
      goto LABEL_20;
    }
    goto LABEL_14;
  }
  if ( !a3 )
  {
LABEL_14:
    if ( *(_BYTE *)(v4 + 230) == -1 )
    {
      v9 = *(_DWORD *)(v4 + 64);
      v10 = v3;
      v11 = (*(_BYTE *)(v9 + v3) & 1) == 0;
      v3 = 255;
      if ( v11 )
      {
        do
        {
          if ( v10 >= v5 )
            break;
          ++v10;
        }
        while ( !(*(_BYTE *)(v9 + v10) & 1) );
      }
      if ( v10 < v5 )
        v3 = v10;
    }
  }
LABEL_20:
  if ( v3 == v13 )
  {
    result = 1;
  }
  else
  {
    sub_1002F600(v3, v13, a1);
    result = 2;
  }
  return result;
}

//----- (1002F790) --------------------------------------------------------
__int16 __cdecl sub_1002F790(char a1, char a2)
{
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  v5 = 0;
  if ( sub_10043610(a2, (int)&v3) )
  {
    if ( a1 == 1 )
      return HIWORD(v4);
    if ( a1 == 2 )
      return v5;
    if ( a1 == 3 )
      return HIWORD(v5);
  }
  return 0;
}

//----- (1002F800) --------------------------------------------------------
__int16 __cdecl sub_1002F800(char a1, char a2)
{
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  v5 = 0;
  if ( sub_10043610(a2, (int)&v3) )
  {
    if ( a1 == 1 )
      return v3;
    if ( a1 == 2 )
      return HIWORD(v3);
    if ( a1 == 3 )
      return v4;
  }
  return 0;
}

//----- (1002F870) --------------------------------------------------------
char __cdecl sub_1002F870(char a1, char a2, __int16 a3)
{
  char result; // al@9
  int v4; // [sp+4h] [bp-Ch]@1
  int v5; // [sp+8h] [bp-8h]@1
  int v6; // [sp+Ch] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  if ( !sub_10043610(a2, (int)&v4) )
    sub_100364C0("..\\lib\\acl\\iop\\gma\\iop_gma_intf.c", 356, 1, 0);
  switch ( a1 )
  {
    case 1:
      HIWORD(v5) = a3;
      break;
    case 2:
      LOWORD(v6) = a3;
      break;
    case 3:
      HIWORD(v6) = a3;
      break;
  }
  result = sub_10043820(a2, (int)&v4);
  if ( !result )
    result = sub_100364C0("..\\lib\\acl\\iop\\gma\\iop_gma_intf.c", 377, 1, 0);
  return result;
}

//----- (1002F920) --------------------------------------------------------
char __cdecl sub_1002F920(char a1, char a2, __int16 a3)
{
  char result; // al@9
  int v4; // [sp+4h] [bp-Ch]@1
  int v5; // [sp+8h] [bp-8h]@1
  int v6; // [sp+Ch] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  if ( !sub_10043610(a2, (int)&v4) )
    sub_100364C0("..\\lib\\acl\\iop\\gma\\iop_gma_intf.c", 417, 1, 0);
  switch ( a1 )
  {
    case 1:
      LOWORD(v4) = a3;
      break;
    case 2:
      HIWORD(v4) = a3;
      break;
    case 3:
      LOWORD(v5) = a3;
      break;
  }
  result = sub_10043820(a2, (int)&v4);
  if ( !result )
    result = sub_100364C0("..\\lib\\acl\\iop\\gma\\iop_gma_intf.c", 438, 1, 0);
  return result;
}

//----- (1002F9D0) --------------------------------------------------------
char __cdecl sub_1002F9D0(char a1, signed __int16 *a2)
{
  int v2; // esi@1
  void *v3; // ecx@1
  int v4; // eax@1
  int v5; // esi@3
  unsigned int v6; // edx@3
  int v7; // esi@3
  __int16 v8; // ax@3
  signed __int16 *v9; // edi@3
  int v10; // esi@3
  unsigned int v11; // edx@3
  int v12; // esi@3
  __int16 v13; // ax@3
  signed __int16 v14; // cx@3
  signed __int16 v15; // ax@3
  bool v16; // sf@3
  unsigned __int8 v17; // of@3
  char result; // al@10

  v2 = sub_1003B860(&a1, 1u, (int)&unk_100A55EC, 12, 3, 2);
  v4 = sub_10037130(v3);
  if ( v4 != dword_100A55F0[3 * v2] && v4 != dword_100A55F4[3 * v2] )
  {
    result = 0;
  }
  else
  {
    v5 = (unsigned __int16)sub_1002F800(1, a1);
    v6 = (signed int)((unsigned __int64)(1374389535i64 * v5 * (unsigned __int16)j_HWM_pvg_get_anlg_outp(0)) >> 32) >> 5;
    v7 = v6 + (v6 >> 31);
    v8 = sub_1002F790(1, a1);
    v9 = a2;
    *a2 = v7 + v8;
    v10 = (unsigned __int16)sub_1002F800(2, a1);
    v11 = (signed int)((unsigned __int64)(1374389535i64 * v10 * (unsigned __int16)j_HWM_pvg_get_anlg_outp(3)) >> 32) >> 5;
    v12 = v11 + (v11 >> 31);
    v13 = sub_1002F790(2, a1);
    v14 = *v9;
    v15 = v12 + v13;
    v17 = __OFSUB__(*v9, 10000);
    v16 = (signed __int16)(*v9 - 10000) < 0;
    v9[1] = v15;
    v9[2] = 0;
    if ( !(v16 ^ v17) )
      v14 = 10000;
    *v9 = v14;
    if ( v14 <= 0 )
      v14 = 0;
    *v9 = v14;
    if ( v15 >= 10000 )
      v15 = 10000;
    v9[1] = v15;
    if ( v15 <= 0 )
    {
      v9[1] = 0;
      result = 1;
    }
    else
    {
      v9[1] = v15;
      result = 1;
    }
  }
  return result;
}
// 1006BAF0: using guessed type int __cdecl j_HWM_pvg_get_anlg_outp(_DWORD);
// 100A55F0: using guessed type int dword_100A55F0[];
// 100A55F4: using guessed type int dword_100A55F4[];

//----- (1002FB00) --------------------------------------------------------
char __cdecl sub_1002FB00(char a1, char a2, _WORD *a3)
{
  int v3; // eax@1
  char result; // al@3
  __int16 v5; // [sp+0h] [bp-8h]@1
  __int16 v6; // [sp+2h] [bp-6h]@8
  __int16 v7; // [sp+4h] [bp-4h]@7

  v3 = sub_1003B860(&a2, 1u, (int)&unk_100A55E0, 4, 3, 2);
  if ( !sub_1003E2C0(1, (unsigned __int16)word_100A55E2[2 * v3], &v5) || sub_10042EA0((int)&v5) )
  {
    result = sub_1002F9D0(a2, &v5);
    if ( !result )
      return result;
  }
  else
  {
    result = 1;
  }
  if ( a1 == 1 )
  {
    *a3 = v5;
  }
  else if ( a1 == 2 )
  {
    *a3 = v6;
  }
  else
  {
    *a3 = v7;
  }
  return result;
}
// 100A55E2: using guessed type __int16 word_100A55E2[];

//----- (1002FBA0) --------------------------------------------------------
bool __usercall sub_1002FBA0@<al>(int a1@<eax>)
{
  return word_100A5BE2[2 * *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 233)] == 6;
}
// 100A5BE2: using guessed type __int16 word_100A5BE2[];

//----- (1002FBC0) --------------------------------------------------------
bool __usercall sub_1002FBC0@<al>(int a1@<esi>)
{
  int v1; // eax@1
  int v2; // ebx@1
  int v3; // edi@1
  char *v4; // edi@2
  bool result; // al@4

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 60);
  v3 = *(_DWORD *)(v1 + 12);
  if ( sub_1002FBA0(a1) )
  {
    sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)(v3 + 8), v3 + 128, (int)&unk_100A5C10, 255);
    v4 = (char *)(v3 + 156);
  }
  else
  {
    sub_10002D30(a1, *(_WORD **)(a1 + 52), (char *)(v3 + 60), v3 + 140, (int)&unk_100A5C14, 255);
    v4 = (char *)(v3 + 180);
  }
  result = sub_10002D30(
             a1,
             *(_WORD **)(a1 + 52),
             v4,
             v2,
             *(_DWORD *)(*(_DWORD *)(a1 + 56) + 64),
             *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (1002FC50) --------------------------------------------------------
void __usercall sub_1002FC50(unsigned int a1@<esi>)
{
  int v1; // ecx@1
  __int16 v2; // dx@1
  int v3; // eax@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@5
  __int16 v7; // [sp+8h] [bp-20h]@5
  int v8; // [sp+Ch] [bp-1Ch]@5
  char v9; // [sp+10h] [bp-18h]@5
  char v10; // [sp+11h] [bp-17h]@5
  __int16 v11; // [sp+14h] [bp-14h]@6
  int v12; // [sp+18h] [bp-10h]@6
  char v13; // [sp+1Ch] [bp-Ch]@6
  __int16 v14; // [sp+1Eh] [bp-Ah]@6
  __int16 v15; // [sp+20h] [bp-8h]@6

  v1 = *(_DWORD *)(a1 + 52);
  v2 = *(_WORD *)(v1 + 10);
  v3 = *(_DWORD *)(a1 + 56);
  v4 = *(_DWORD *)(v3 + 4);
  v5 = *(_DWORD *)(v3 + 12);
  if ( v2 != 40 && v2 != 32 )
    *(_BYTE *)(a1 + 6) = sub_100375A0(a1, (char *)v3, v1);
  switch ( *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) )
  {
    case 0x21:
      v6 = *(_DWORD *)(a1 + 56);
      v8 = v4;
      v7 = -32739;
      v9 = *(&byte_100A5BFC[2 * *(_BYTE *)(v5 + 233)] + *(_BYTE *)(v6 + 230));
      v10 = *(_BYTE *)(v5 + 235);
      sub_10003E50(a1, (int)&v7, 12);
      sub_100352A0(a1, 1, 0, 0);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 0x1D:
      v8 = v4;
      v7 = -32739;
      v9 = 2;
      v10 = *(_BYTE *)(v5 + 235);
      sub_10003E50(a1, (int)&v7, 12);
      sub_100352A0(a1, 1, 0, 0);
      v12 = 0;
      v11 = -32696;
      v14 = 29;
      v15 = 0;
      v13 = 1;
      sub_10003DE0(a1, (int)&v11, 20);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 0x20:
    case 0x28:
      v8 = v4;
      v7 = -32739;
      v9 = 2;
      v10 = *(_BYTE *)(v5 + 235);
      sub_10003E50(a1, (int)&v7, 12);
      sub_100352A0(a1, 1, 0, 0);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    default:
      return;
  }
}

//----- (1002FDD0) --------------------------------------------------------
char __usercall sub_1002FDD0@<al>(int a1@<esi>)
{
  int v1; // edi@1
  int v2; // ebp@1
  __int16 v3; // ax@1
  char v4; // al@2
  unsigned __int8 v5; // cl@3
  char v6; // al@4
  char *v7; // eax@7
  __int16 v9; // [sp+Ch] [bp-298h]@9
  int v10; // [sp+10h] [bp-294h]@9
  char v11; // [sp+14h] [bp-290h]@9
  __int16 v12; // [sp+16h] [bp-28Eh]@9
  __int16 v13; // [sp+18h] [bp-28Ch]@9
  __int16 v14; // [sp+1Ah] [bp-28Ah]@9
  char v15; // [sp+1Ch] [bp-288h]@9
  char v16; // [sp+D8h] [bp-1CCh]@1
  char v17; // [sp+19Ch] [bp-108h]@1
  char v18; // [sp+19Dh] [bp-107h]@1

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 12);
  v16 = 0;
  v17 = 0;
  memset(&v18, 0, 0x100u);
  v3 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 8);
  if ( v3 == *(_WORD *)(v2 + 224) )
  {
    v4 = 0;
    v17 = 1;
  }
  else
  {
    if ( v3 != *(_WORD *)(v2 + 226) )
    {
      v17 = 0;
      sub_100365D0((int)&v18, "This option does not exist - ", 256);
      v7 = sub_10037280(*(_WORD *)(*(_DWORD *)(a1 + 52) + 8));
      sub_100367C0(&v18, v7, 256);
      goto LABEL_10;
    }
    v4 = 1;
    v17 = 1;
  }
  v5 = *(_BYTE *)(v1 + 230);
  if ( v5 <= (unsigned __int8)v4 )
    v6 = v5 < (unsigned __int8)v4;
  else
    v6 = -1;
  v11 = v6;
  v9 = -32696;
  v10 = v1;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v12 = 57;
  sub_10003DE0(a1, (int)&v9, 204);
  v11 = 1;
  v12 = 33;
  sub_10003DE0(a1, (int)&v9, 204);
LABEL_10:
  *(_BYTE *)(a1 + 6) = 2;
  return sub_10036820(&v16);
}

//----- (1002FF20) --------------------------------------------------------
int __usercall sub_1002FF20@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ecx@2
  int v3; // edx@2
  int v4; // eax@2
  int result; // eax@2
  int v6; // eax@3
  signed __int16 v7; // dx@3
  __int16 v8; // cx@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( sub_1002FBA0(a1) )
  {
    v2 = *(_WORD *)(v1 + 2);
    v3 = *(_DWORD *)(v1 + 228);
    v4 = v2 - 40;
    *(_WORD *)(v1 + 28) = v2 - 40;
    LOWORD(v4) = 22 * *(_BYTE *)(v1 + 234);
    *(_WORD *)(v1 + 32) = v4;
    *(_WORD *)(v1 + 16) = 0;
    *(_WORD *)(v1 + 18) = 0;
    *(_BYTE *)(v1 + 48) = 0;
    result = v4 + 28;
    *(_WORD *)(v1 + 46) = 0;
    *(_DWORD *)(v1 + 8) = 66;
    *(_BYTE *)(v1 + 12) = 64;
    *(_DWORD *)(v1 + 20) = 124;
    *(_DWORD *)(v1 + 24) = v3 | 0x40802F;
    *(_WORD *)(v1 + 30) = 17;
    *(_BYTE *)(v1 + 34) = 3;
    *(_BYTE *)(v1 + 35) = 2;
    *(_WORD *)(v1 + 36) = 19;
    *(_WORD *)(v1 + 38) = 18;
    *(_DWORD *)(v1 + 40) = 82;
    *(_WORD *)(v1 + 44) = v2 - 32;
    *(_WORD *)(v1 + 52) = 16;
    *(_WORD *)(v1 + 54) = result;
    *(_DWORD *)(v1 + 56) = 141;
  }
  else
  {
    v6 = *(_DWORD *)(v1 + 228);
    v7 = *(_WORD *)(v1 + 2);
    *(_DWORD *)(v1 + 76) = *(_DWORD *)(v1 + 228) | 0x40802F;
    *(_WORD *)(v1 + 80) = v7 - 40;
    v8 = 22 * *(_BYTE *)(v1 + 234);
    *(_DWORD *)(v1 + 112) = v6 | 0x802F;
    *(_WORD *)(v1 + 84) = v8;
    v8 += 28;
    *(_WORD *)(v1 + 106) = v8;
    *(_WORD *)(v1 + 96) = v7 - 32;
    result = v7 / 2;
    *(_WORD *)(v1 + 68) = 0;
    *(_WORD *)(v1 + 70) = 0;
    *(_BYTE *)(v1 + 100) = 0;
    *(_WORD *)(v1 + 98) = 0;
    *(_WORD *)(v1 + 116) = 0;
    *(_DWORD *)(v1 + 60) = 66;
    *(_BYTE *)(v1 + 64) = 64;
    *(_DWORD *)(v1 + 72) = 124;
    *(_WORD *)(v1 + 82) = 17;
    *(_BYTE *)(v1 + 86) = 3;
    *(_BYTE *)(v1 + 87) = 2;
    *(_WORD *)(v1 + 88) = 19;
    *(_WORD *)(v1 + 90) = 18;
    *(_DWORD *)(v1 + 92) = 82;
    *(_WORD *)(v1 + 104) = 16;
    *(_DWORD *)(v1 + 108) = 107;
    *(_WORD *)(v1 + 120) = result;
    *(_WORD *)(v1 + 122) = v8 + 22;
    *(_DWORD *)(v1 + 124) = 141;
  }
  return result;
}

//----- (10030080) --------------------------------------------------------
__int16 __usercall sub_10030080@<ax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // eax@2
  int v3; // ecx@3
  __int16 v4; // bp@3
  int v5; // edi@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( sub_1002FBA0(a1) )
  {
    v2 = *(_WORD *)(v1 + 2);
    *(_DWORD *)(v1 + 164) = *(_DWORD *)(v1 + 228) | 0x8026;
    *(_WORD *)(v1 + 172) = v2 / 2;
    LOWORD(v2) = *(_WORD *)(v1 + 54) + 22;
    *(_WORD *)(v1 + 168) = 0;
    *(_BYTE *)(v1 + 160) = 0;
    *(_DWORD *)(v1 + 156) = 68;
    *(_WORD *)(v1 + 174) = v2;
    *(_DWORD *)(v1 + 176) = 141;
  }
  else
  {
    v3 = *(_DWORD *)(v1 + 228);
    v4 = *(_WORD *)(v1 + 106);
    v5 = *(_WORD *)(v1 + 2);
    *(_WORD *)(v1 + 196) = *(_WORD *)(v1 + 2) / 4;
    v4 += 22;
    v3 |= 0x8026u;
    *(_WORD *)(v1 + 198) = v4;
    *(_WORD *)(v1 + 218) = v4;
    v2 = 3 * v5 / 4;
    *(_WORD *)(v1 + 192) = 0;
    *(_BYTE *)(v1 + 184) = 0;
    *(_WORD *)(v1 + 212) = 0;
    *(_BYTE *)(v1 + 204) = 0;
    *(_DWORD *)(v1 + 180) = 68;
    *(_DWORD *)(v1 + 188) = v3;
    *(_DWORD *)(v1 + 200) = 68;
    *(_DWORD *)(v1 + 208) = v3;
    *(_WORD *)(v1 + 216) = v2;
    *(_DWORD *)(v1 + 220) = 141;
  }
  return v2;
}

//----- (10030180) --------------------------------------------------------
char __usercall sub_10030180@<al>(int a1@<edi>)
{
  int v1; // eax@1
  int v2; // ebp@1
  int v3; // esi@1
  bool v4; // al@1
  int v5; // edx@1
  int v6; // eax@7
  char v7; // al@7
  char result; // al@11

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 60);
  v3 = *(_DWORD *)(v1 + 12);
  *(_BYTE *)(v1 + 247) = 1;
  **(_BYTE **)(*(_DWORD *)(a1 + 56) + 64) = 1;
  v4 = sub_1002FBA0(a1);
  v5 = v3 + 236;
  if ( v4 )
  {
    *(_DWORD *)(v3 + 128) = 0;
    *(_DWORD *)(v3 + 132) = v5;
    *(_DWORD *)(v3 + 136) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 64) + 1) = 1;
    *(_DWORD *)(v3 + 140) = 0;
    *(_DWORD *)(v3 + 144) = v5;
    *(_DWORD *)(v3 + 148) = 0;
    *(_DWORD *)(v3 + 152) = &unk_100A5C0C;
  }
  sub_1002FF20(a1);
  sub_10030080(a1);
  sub_10002870(a1, *(_WORD *)(v3 + 4), *(_WORD *)(v3 + 6), *(_WORD *)(v3 + 2), *(_WORD *)v3, 0);
  if ( sub_1002FBA0(a1) )
  {
    sub_100374D0(*(_DWORD *)(a1 + 56), (char *)(v3 + 156));
  }
  else
  {
    sub_100374D0(*(_DWORD *)(a1 + 56), (char *)(v3 + 180));
    *(_DWORD *)(v2 + 4) = v3 + 226;
  }
  *(_DWORD *)v2 = v3 + 224;
  v6 = 2 * *(_BYTE *)(v3 + 233);
  *(_WORD *)(v3 + 224) = word_100A5BE0[2 * *(_BYTE *)(v3 + 233)];
  *(_WORD *)(v3 + 226) = word_100A5BE2[v6];
  v7 = *(_BYTE *)(v3 + 232);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = v7 && v7 != 16;
  sub_10002C10(
    a1,
    &unk_100B097C,
    *(char ***)(*(_DWORD *)(a1 + 56) + 56),
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 60),
    0,
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230));
  result = sub_10004590(a1, *(_DWORD *)(a1 + 56), -32734);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 100A5BE0: using guessed type __int16 word_100A5BE0[];
// 100A5BE2: using guessed type __int16 word_100A5BE2[];

//----- (100302E0) --------------------------------------------------------
char __thiscall sub_100302E0(int this)
{
  int v1; // edi@1
  int v2; // eax@4
  int v3; // esi@4
  int *v4; // eax@4
  int v5; // eax@4
  signed __int16 v6; // ax@6
  char *v8; // [sp-Ch] [bp-CCh]@2
  int v9; // [sp-4h] [bp-C4h]@2
  char v10; // [sp+8h] [bp-B8h]@4

  v1 = this;
  if ( (*(_BYTE *)(*(_DWORD *)(this + 52) + 8) & 7) == 2 )
  {
    v9 = 1;
    v8 = *(char **)(this + 56);
  }
  else
  {
    v9 = 2;
    v8 = *(char **)(this + 56);
  }
  v2 = sub_10003D50(this, v8, 416, v9);
  v3 = v2;
  *(_BYTE *)(v2 + 233) = *(_BYTE *)(*(_DWORD *)(v1 + 52) + 8) & 7;
  *(_BYTE *)(v2 + 232) = *(_BYTE *)(*(_DWORD *)(v1 + 52) + 8) & 0x18;
  *(_BYTE *)(v2 + 235) = *(_BYTE *)(*(_DWORD *)(v1 + 52) + 22);
  *(_DWORD *)(v2 + 228) = *(_DWORD *)(*(_DWORD *)(v1 + 52) + 16) & 0x3C00;
  *(_WORD *)(v2 + 2) = *(_WORD *)(*(_DWORD *)(v1 + 52) + 20);
  sub_100365D0(v2 + 236, (_BYTE *)(v1 + 84), 180);
  v4 = sub_10002E60(*(_DWORD *)(v3 + 228));
  v5 = sub_100354B0(v3 + 236, *v4, 0, *(_WORD *)(v3 + 2) - 40, 6, 1, &v10);
  if ( v5 == -1 )
    LOBYTE(v5) = 6;
  *(_BYTE *)(v3 + 234) = v5;
  v6 = 22 * ((unsigned __int8)v5 + 4);
  *(_WORD *)v3 = v6;
  *(_WORD *)(v3 + 4) = *(_WORD *)(*(_DWORD *)(v1 + 52) + 10);
  *(_WORD *)(v3 + 6) = *(_WORD *)(*(_DWORD *)(v1 + 52) + 12) - v6 / 2;
  return sub_10030180(v1);
}

//----- (10030410) --------------------------------------------------------
void __cdecl sub_10030410(unsigned int a1)
{
  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x801C:
      sub_100302E0(a1);
      break;
    case 0x8022:
      sub_1002FBC0(a1);
      break;
    case 0x8048:
      sub_1002FC50(a1);
      break;
    case 0x80AF:
      sub_1002FDD0(a1);
      break;
    default:
      return;
  }
}

//----- (10030500) --------------------------------------------------------
int __cdecl sub_10030500(unsigned __int16 a1, char a2, int a3)
{
  int result; // eax@1
  int v4; // ebp@1
  char v5; // cl@2
  signed int v6; // edi@2
  unsigned __int16 v7; // si@3
  int v8; // ecx@4
  char v9; // dl@5
  int v10; // esi@10
  int v11; // ecx@11
  __int16 v12; // dx@12
  char v13; // bl@13

  result = BMP_get_xfrm(a1);
  v4 = result;
  if ( a2 )
  {
    v5 = *(_BYTE *)(BMP_get_bm_def(a1) + 8);
    result = a3;
    v6 = 1 << v5;
    if ( v4 )
    {
      v10 = 0;
      if ( v6 > 0 )
      {
        v11 = 0;
        do
        {
          v12 = *(_WORD *)(v4 + 2 * v11);
          if ( (unsigned __int16)v12 < 0x100u )
          {
            v13 = byte_1065DEF8[(unsigned __int16)v12];
            if ( v13 != 127 )
              v12 = word_1065DED0[(unsigned __int8)byte_100A61D8[(unsigned __int8)v13]];
          }
          ++v10;
          *(_WORD *)(a3 + 2 * v11) = v12;
          v11 = (unsigned __int16)v10;
        }
        while ( (unsigned __int16)v10 < v6 );
      }
    }
    else
    {
      v7 = 0;
      if ( v6 > 0 )
      {
        v8 = 0;
        do
        {
          v9 = byte_1065DEF8[v8];
          if ( v9 == 127 )
            *(_WORD *)(a3 + 2 * v8) = v7;
          else
            *(_WORD *)(a3 + 2 * v8) = word_1065DED0[(unsigned __int8)byte_100A61D8[(unsigned __int8)v9]];
          v8 = ++v7;
        }
        while ( v7 < v6 );
      }
    }
  }
  return result;
}
// 100820C4: using guessed type int __cdecl BMP_get_bm_def(_DWORD);
// 100820CA: using guessed type int __cdecl BMP_get_xfrm(_DWORD);
// 1065DED0: using guessed type __int16 word_1065DED0[];

//----- (100305D0) --------------------------------------------------------
int sub_100305D0()
{
  int v0; // ebx@1
  void *v1; // esi@1
  int result; // eax@2

  memset(byte_1065DEF8, 127, 0x100u);
  v0 = 0;
  v1 = &unk_100A619D;
  do
  {
    LOBYTE(result) = j_HWM_pvg_get_color(*((char *)v1 - 1), *(_BYTE *)v1, *((_BYTE *)v1 + 1));
    word_1065DED0[v0] = (unsigned __int8)result;
    result = (unsigned __int8)result;
    byte_1065DEF8[(unsigned __int8)result] = v0;
    v1 = (char *)v1 + 3;
    ++v0;
  }
  while ( (signed int)v1 < (signed int)&unk_100A61D6 );
  return result;
}
// 1006BB00: using guessed type int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD);
// 1065DED0: using guessed type __int16 word_1065DED0[];

//----- (10030630) --------------------------------------------------------
char __cdecl sub_10030630(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char result; // al@1
  char *v6; // edi@4
  signed int v7; // eax@4
  unsigned int v8; // ST1C_4@4
  int v9; // eax@4
  unsigned int v10; // ST18_4@4
  int *v11; // eax@4
  __int16 v12; // dx@4
  int v13; // ST10_4@4
  signed int v14; // eax@4
  __int16 v15; // dx@4
  int v16; // edx@4
  int v17; // eax@6
  int v18; // edi@7
  int v19; // ebx@7
  char *v20; // eax@7
  int v21; // [sp+8h] [bp-18h]@4
  int v22; // [sp+Ch] [bp-14h]@4
  int v23; // [sp+10h] [bp-10h]@4
  __int16 v24; // [sp+14h] [bp-Ch]@4
  int v25; // [sp+16h] [bp-Ah]@4
  int v26; // [sp+1Ch] [bp-4h]@4

  result = 1;
  if ( *a5 == 32802 )
  {
LABEL_4:
    v6 = sub_10037280(*a4);
    v7 = sub_10002EA0(*(_DWORD *)(a2 + 4));
    v8 = *(_DWORD *)(a2 + 4);
    v22 = v7;
    v9 = sub_100035F0(v8, 0);
    v10 = *(_DWORD *)(a2 + 4);
    v23 = v9;
    v25 = sub_10002E30(v10);
    v11 = sub_10002E60(*(_DWORD *)(a2 + 4));
    v12 = *(_WORD *)(a2 + 8);
    v13 = *(_DWORD *)(a2 + 4);
    v21 = *v11;
    v24 = v12;
    v14 = sub_10002ED0(v13);
    v15 = *(_WORD *)a3;
    v26 = v14;
    *(_WORD *)(a1 + 438) = v15;
    v16 = v21;
    *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
    sub_10003650(a1, v6, &v21, *(_WORD *)(v16 + 30));
    return 2;
  }
  if ( *a5 != 32832 )
  {
    if ( *a5 != 32888 )
      return result;
    goto LABEL_4;
  }
  LOWORD(v17) = *(_WORD *)(a2 + 8);
  if ( (_WORD)v17 )
  {
    v17 = (signed __int16)v17;
  }
  else
  {
    v18 = sub_10002EA0(*(_DWORD *)(a2 + 4));
    v19 = *sub_10002E60(*(_DWORD *)(a2 + 4));
    v20 = sub_10037280(*a4);
    v17 = sub_1001C410(v19, v20, v18);
  }
  sub_10003860(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(a2 + 4), v17);
  return 2;
}

//----- (10030760) --------------------------------------------------------
void *__cdecl sub_10030760(int a1, __int16 a2)
{
  void *result; // eax@1

  result = memset((void *)(*(_DWORD *)(a1 + 56) + 69), 95, a2);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + a2 + 69) = 0;
  return result;
}

//----- (10030790) --------------------------------------------------------
char __cdecl sub_10030790(int a1, int a2, char *a3)
{
  char *v3; // edx@1
  _BYTE *v4; // eax@1
  char v5; // cl@2

  v3 = a3;
  v4 = (_BYTE *)(*(_DWORD *)(a1 + 56) + 69);
  do
  {
    v5 = *v3;
    *v4++ = *v3++;
  }
  while ( v5 );
  sub_10036580((const char *)(*(_DWORD *)(a1 + 56) + 69), 32, 95);
  sub_10036530((const char *)(*(_DWORD *)(a1 + 56) + 69), *(_WORD *)(a2 + 10), 95);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = 0;
  return 4;
}

//----- (100307F0) --------------------------------------------------------
int __cdecl sub_100307F0(int a1, int a2, int a3, signed int a4, int a5)
{
  int v5; // edi@1
  unsigned int v6; // ecx@1
  char v7; // al@6
  int v8; // eax@8
  __int16 v9; // dx@8
  __int64 v10; // rax@9
  float v11; // ST10_4@9

  v5 = a1;
  v6 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(a1 + 4) & 0xC000 )
  {
    if ( (*(_DWORD *)(a1 + 4) & 0xC000) == 0x4000 )
      LOWORD(a1) = *(_WORD *)a2 + *(_WORD *)(a1 + 8);
    else
      LOWORD(a1) = *(_WORD *)a2 + *(_WORD *)(a1 + 8) / 2;
  }
  else
  {
    LOWORD(a1) = *(_WORD *)a2;
  }
  v7 = *(_BYTE *)(v5 + 15);
  if ( *(_BYTE *)(v5 + 15) & 6 )
  {
    if ( (*(_BYTE *)(v5 + 15) & 6) == 2 )
    {
      v10 = *(_WORD *)(a3 + 24) - *(_WORD *)(a3 + 26);
      v11 = 0.5 * (double)(a5 + 1);
      HIWORD(a1) = (signed int)((double)(*(_WORD *)(v5 + 12) / 2
                                       + (((signed int)v10 - HIDWORD(v10)) >> 1)
                                       + *(_WORD *)(a2 + 2)
                                       - 1)
                              + 0.5
                              + (1.0 - v11) * (double)a4);
      return a1;
    }
    v8 = sub_100035F0(v6, (v7 & 1) == 1);
    v9 = *(_WORD *)(a3 + 24) + *(_WORD *)(v5 + 12) - a4 * a5 - *(_WORD *)(a3 + 26);
  }
  else
  {
    v8 = sub_100035F0(v6, (v7 & 1) == 1);
    v9 = *(_WORD *)(a3 + 24) - *(_WORD *)(a3 + 26);
  }
  HIWORD(a1) = BYTE2(v8) + *(_WORD *)(a2 + 2) + v9 - 1;
  return a1;
}

//----- (10030940) --------------------------------------------------------
char __usercall sub_10030940@<al>(char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>)
{
  int v4; // eax@3
  int v5; // ecx@3
  char result; // al@4
  int v7; // eax@5
  int v8; // eax@7

  if ( *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) == -128 )
  {
    sub_10030790(a4, a3, a1);
    sub_10030760(a4, *(_WORD *)(a3 + 10));
  }
  v4 = *(_DWORD *)(a4 + 56);
  v5 = *(_WORD *)(v4 + 240);
  if ( *(_WORD *)(a2 + 10) == 0x2000 )
  {
    *(_BYTE *)(v5 + v4 + 69) = *(_BYTE *)(a2 + 14);
    v7 = *(_DWORD *)(a4 + 56);
    if ( *(_BYTE *)(*(_WORD *)(v7 + 240) + v7 + 69) == 32 )
      *(_BYTE *)(*(_WORD *)(v7 + 240) + v7 + 69) = 95;
    ++*(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    v8 = *(_WORD *)(a3 + 10) - 1;
    if ( *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) < v8 )
      LOWORD(v8) = *(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) = v8;
    result = 2;
  }
  else
  {
    *(_BYTE *)(v5 + v4 + 69) = 95;
    --*(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) &= ((signed int)*(_WORD *)(*(_DWORD *)(a4 + 56) + 240) <= 0) - 1;
    result = 2;
  }
  return result;
}

//----- (10030A00) --------------------------------------------------------
char __usercall sub_10030A00@<al>(unsigned __int16 a1@<di>, int a2)
{
  char v2; // bl@1
  char v3; // al@1
  int v4; // esi@1
  int v5; // eax@1
  char result; // al@2

  v2 = 0;
  v3 = sub_10038B70(0, a1, 1);
  v4 = (unsigned __int8)v3;
  v5 = (unsigned __int8)sub_10038B70(v3, a1, 1);
  if ( v4 == a2 )
  {
    result = 1;
  }
  else
  {
    if ( v5 != v4 )
    {
      do
      {
        if ( v5 == a2 )
          v2 = 1;
        v5 = (unsigned __int8)sub_10038B70(v5, a1, 1);
      }
      while ( (unsigned __int8)v5 != v4 );
    }
    result = v2;
  }
  return result;
}

//----- (10030A60) --------------------------------------------------------
signed int __usercall sub_10030A60@<eax>(int a1@<edi>, unsigned __int16 a2@<si>, int a3)
{
  char v3; // bl@8
  signed int result; // eax@8
  char v5; // [sp+4h] [bp-4h]@0

  if ( (signed int)a2 <= 177 )
  {
    if ( a2 != 177 )
    {
      switch ( a2 )
      {
        case 0x51u:
        case 0x91u:
          goto LABEL_8;
        case 0x10u:
        case 0x14u:
          goto LABEL_9;
        case 0x92u:
          goto LABEL_11;
        default:
          goto LABEL_12;
      }
      goto LABEL_12;
    }
LABEL_8:
    v3 = 65;
    LOBYTE(result) = sub_10038B70(65, a2, -1);
    goto LABEL_13;
  }
  if ( (signed int)a2 > 528 )
  {
    if ( a2 != 1043 )
      goto LABEL_12;
LABEL_11:
    v3 = 97;
    LOBYTE(result) = sub_10038B70(97, a2, -1);
    goto LABEL_13;
  }
  if ( a2 == 528 )
  {
LABEL_9:
    v3 = 48;
    LOBYTE(result) = sub_10038B70(48, a2, -1);
    goto LABEL_13;
  }
  if ( a2 == 178 )
    goto LABEL_11;
  if ( a2 == 273 )
    goto LABEL_8;
LABEL_12:
  v3 = v5;
  LOBYTE(result) = sub_10038B70(v5, a2, -1);
LABEL_13:
  if ( a3 == 95 )
  {
    if ( a1 > 0 )
      return (unsigned __int8)v3;
  }
  else
  {
    if ( a3 == (unsigned __int8)v3 && a1 < 0 || a3 == (unsigned __int8)result && a1 > 0 )
      return 95;
    do
    {
      LOBYTE(result) = sub_10038B70(a3, a2, a1);
      LOBYTE(a3) = result;
    }
    while ( (_BYTE)result == 95 );
  }
  return (unsigned __int8)result;
}

//----- (10030BC0) --------------------------------------------------------
signed int __cdecl sub_10030BC0(int a1, int a2, signed int a3)
{
  __int16 v3; // si@1
  signed int result; // eax@1
  int v5; // edi@1
  int v6; // ebx@2
  bool v7; // zf@2

  v3 = sub_10037460(*(_DWORD *)(a2 + 4));
  result = a3;
  v5 = 2 * (a3 >= 0) - 1;
  if ( a3 )
  {
    do
    {
      v6 = *(_DWORD *)(a1 + 56);
      result = sub_10030A60(v5, v3, *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69));
      v7 = a3 == v5;
      a3 -= v5;
      *(_BYTE *)(*(_WORD *)(v6 + 240) + v6 + 69) = result;
    }
    while ( !v7 );
  }
  return result;
}

//----- (10030C20) --------------------------------------------------------
char __cdecl sub_10030C20(int a1, int a2, int a3, char *a4)
{
  int v4; // esi@1
  char v5; // bl@1
  bool v6; // zf@1
  signed int v7; // eax@3
  unsigned int v8; // ST24_4@3
  int v9; // eax@3
  int v10; // ST1C_4@3
  __int16 v11; // ax@3
  int v12; // eax@6
  int v13; // eax@6
  char *v14; // ebx@6
  bool v15; // al@9
  int v16; // eax@11
  int v17; // eax@13
  int v18; // eax@13
  int v19; // ST1C_4@18
  int v21; // [sp+10h] [bp-28h]@1
  int v22; // [sp+14h] [bp-24h]@1
  int v23; // [sp+18h] [bp-20h]@1
  int v24; // [sp+1Ch] [bp-1Ch]@6
  int v25; // [sp+20h] [bp-18h]@3
  int v26; // [sp+24h] [bp-14h]@3
  int v27; // [sp+28h] [bp-10h]@3
  __int16 v28; // [sp+2Ch] [bp-Ch]@5
  int v29; // [sp+2Eh] [bp-Ah]@3
  int v30; // [sp+34h] [bp-4h]@3
  int v31; // [sp+40h] [bp+8h]@13

  v4 = a2;
  v5 = 0;
  v6 = *(_BYTE *)a2 == 124;
  LOBYTE(v23) = 0;
  v21 = 0;
  v22 = 0;
  if ( v6 )
  {
    v5 = *(_BYTE *)(a2 + 14);
    LOBYTE(v23) = (*(_BYTE *)(a2 + 15) & 1) == 1;
  }
  v25 = sub_10002E80(*(_DWORD *)(a2 + 4));
  v7 = sub_10002EA0(*(_DWORD *)(a2 + 4));
  v8 = *(_DWORD *)(a2 + 4);
  v26 = v7;
  v27 = sub_100035F0(v8, v23);
  v9 = sub_10002E30(*(_DWORD *)(a2 + 4));
  v10 = *(_DWORD *)(a2 + 4);
  v29 = v9;
  v30 = sub_10002ED0(v10);
  v11 = *(_WORD *)(a2 + 8);
  if ( !v11 )
    v11 = sub_1001C410(v25, a4, v26);
  v6 = *(_BYTE *)a2 == 124;
  v28 = v11;
  if ( v6 )
  {
    sub_10003930(a4, *(_DWORD *)(a2 + 4), *(_BYTE *)(a2 + 14), (int)&v24, (int)&v22);
    v23 = v5;
    v12 = sub_10035440(a4, v25, v27, *(_WORD *)(a2 + 12), v5, &v21);
    v13 = sub_10004F90(a1, v12);
    v14 = (char *)v13;
    if ( v21 > 0 )
    {
      v15 = !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128;
      v16 = sub_100354B0((int)a4, v25, 0, *(_WORD *)(a2 + 8), v21, v15, v14);
      v22 = v16;
      if ( v16 == -1 )
      {
        v16 = v21;
        v22 = v21;
      }
      v17 = sub_100307F0(a2, a3, v25, v24, v16);
      v6 = *(_BYTE *)(a1 + 3) == 0;
      v31 = v17;
      v18 = v29;
      *(_WORD *)(a1 + 396) = 3;
      if ( !v6 && *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 && (byte_10756F5E || byte_10789160) )
      {
        *(_WORD *)(a1 + 428) = HIWORD(v18);
        *(_WORD *)(a1 + 430) = v29;
        v18 = *(_DWORD *)(a1 + 428);
      }
      *(_WORD *)(a1 + 440) = v18;
      *(_WORD *)(a1 + 442) = v18;
      sub_1001F350(a1 + 392, *(_WORD *)a3 - 1, *(_WORD *)(a3 + 2), *(_WORD *)(v4 + 8) + 2, *(_WORD *)(v4 + 12));
      v19 = v23;
      *(_WORD *)(a1 + 438) = v31;
      *(_WORD *)(a1 + 436) = HIWORD(v31);
      LOBYTE(v13) = sub_10003650(a1, v14, &v25, v19);
    }
    if ( v14 )
      LOBYTE(v13) = sub_10004BF0(a1, (unsigned int)v14);
  }
  else
  {
    *(_WORD *)(a1 + 438) = *(_WORD *)a3;
    *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
    LOBYTE(v13) = sub_100035B0(a1, a4, &v25);
  }
  return v13;
}
// 10756F5E: using guessed type char byte_10756F5E;
// 10789160: using guessed type char byte_10789160;

//----- (10030E80) --------------------------------------------------------
char __cdecl sub_10030E80(int a1, int a2, int a3, char *a4)
{
  int v4; // ebp@1
  signed __int16 v5; // di@1
  int v6; // ecx@1
  int v7; // eax@1
  int v8; // ecx@4
  char v9; // bl@4
  char result; // al@10
  char v11; // bl@11
  char v12; // al@13
  int v13; // eax@18
  int v14; // eax@19
  int v15; // eax@24
  int v16; // [sp+18h] [bp+8h]@1

  v4 = a2;
  LOWORD(v7) = sub_10037460(*(_DWORD *)(a2 + 4));
  v5 = *(_WORD *)(a3 + 14);
  v6 = (unsigned __int16)v7;
  LOWORD(v7) = *(_WORD *)(a3 + 10);
  v16 = v6;
  if ( (_WORD)v7 == 0x2000 && v5 == 32 )
    v5 = 95;
  v8 = *(_DWORD *)(a1 + 56);
  v9 = 1;
  if ( *(_WORD *)(v8 + 240) == -128 )
  {
    if ( !(*(_DWORD *)(v4 + 4) & 0x200000) )
    {
      v7 = (unsigned __int16)v7;
      if ( (signed int)(unsigned __int16)v7 <= 73 )
      {
        if ( (unsigned __int16)v7 != 73 )
        {
          if ( v7 == 32 )
          {
            v11 = sub_10030790(a1, v4, a4);
            sub_10030760(a1, *(_WORD *)(v4 + 10));
            return v11;
          }
          if ( v7 == 56 )
            return sub_10030790(a1, v4, a4);
          return v9;
        }
        return sub_10030940(a4, a3, v4, a1);
      }
      if ( v7 == 0x2000 )
      {
        v12 = sub_10030A00(v16, (unsigned __int16)v5);
        goto LABEL_14;
      }
    }
    return v9;
  }
  v7 = (unsigned __int16)v7;
  if ( (signed int)(unsigned __int16)v7 > 57 )
  {
    if ( v7 == 73 )
      return sub_10030940(a4, a3, v4, a1);
    if ( v7 == 0x2000 )
    {
      v12 = sub_10030A00(v16, (unsigned __int16)v5);
LABEL_14:
      if ( v12 )
        return sub_10030940(a4, a3, v4, a1);
    }
    return v9;
  }
  if ( (unsigned __int16)v7 != 57 )
  {
    v13 = v7 - 32;
    if ( !v13 )
    {
      result = 6;
      *(_WORD *)(v8 + 240) = -128;
      return result;
    }
    v14 = v13 - 1;
    if ( !v14 )
    {
      *(_WORD *)(v8 + 240) = -128;
      sub_10036580((const char *)(*(_DWORD *)(a1 + 56) + 69), 95, 32);
      sub_10036800(*(_DWORD *)(a1 + 56) + 69, 0);
      return 3;
    }
    if ( v14 == 23 )
    {
      sub_10030BC0(a1, v4, *(_BYTE *)(a3 + 8));
      return 2;
    }
    return v9;
  }
  *(_WORD *)(v8 + 240) += *(_BYTE *)(a3 + 8);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) &= ((signed int)*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) <= 0) - 1;
  v15 = *(_WORD *)(v4 + 10) - 1;
  if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v15 )
    LOWORD(v15) = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = v15;
  return 2;
}

//----- (10031070) --------------------------------------------------------
char __cdecl sub_10031070(int a1, int a2, int a3, char *a4, int a5)
{
  int v5; // esi@1
  __int16 v6; // ax@1
  char *v7; // edi@1
  __int16 v8; // bx@3
  int v9; // ebp@3
  __int16 v10; // di@5
  int v11; // eax@5
  char result; // al@5
  char *v13; // eax@10
  char *v14; // edx@10
  char v15; // cl@11
  int v16; // ecx@14
  char v17; // [sp+13h] [bp-5h]@1
  int v18; // [sp+14h] [bp-4h]@5

  v5 = a2;
  v6 = *(_WORD *)(a2 + 8);
  v7 = a4;
  v17 = 1;
  if ( !v6 )
    v6 = sub_10003480(a4, *(_DWORD *)(a2 + 4));
  v8 = v6;
  v9 = *sub_10002E60(*(_DWORD *)(v5 + 4));
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      if ( *(_BYTE *)v5 == 124 )
      {
        v10 = sub_10003930(v7, *(_DWORD *)(v5 + 4), *(_BYTE *)(v5 + 14), (int)&v18, (int)&a2);
        v11 = sub_100307F0(v5, a3, v9, v18, a2);
        sub_10003860(a1 + 276, v11, *(_DWORD *)(v5 + 4), v8);
        *(_WORD *)(a1 + 282) = v10 + *(_WORD *)(a1 + 278);
        result = 2;
      }
      else
      {
        sub_10003860(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(v5 + 4), v8);
        result = 2;
      }
      break;
    case 0x8048:
      v17 = sub_10030E80(a1, v5, a5, v7);
      switch ( v17 )
      {
        case 2:
        case 4:
          sub_10030C20(a1, v5, a3, (char *)(*(_DWORD *)(a1 + 56) + 69));
          result = v17;
          break;
        case 6:
          sub_10030C20(a1, v5, a3, v7);
          result = v17;
          break;
        case 3:
          v13 = (char *)(*(_DWORD *)(a1 + 56) + 69);
          v14 = v7;
          do
          {
            v15 = *v13;
            *v14++ = *v13++;
          }
          while ( v15 );
          sub_10030C20(a1, v5, a3, v7);
          result = v17;
          break;
        default:
          goto LABEL_18;
      }
      break;
    case 0x8022:
    case 0x8078:
      if ( *(_BYTE *)(a1 + 3) && (v16 = *(_DWORD *)(a1 + 56), *(_WORD *)(v16 + 240) != -128) )
        sub_10030C20(a1, v5, a3, (char *)(v16 + 69));
      else
        sub_10030C20(a1, v5, a3, v7);
      v17 = 2;
      goto LABEL_18;
    default:
LABEL_18:
      result = v17;
      break;
  }
  return result;
}

//----- (100312D0) --------------------------------------------------------
int __usercall sub_100312D0@<eax>(int a1@<eax>, _WORD *a2@<ecx>)
{
  int result; // eax@3

  if ( *(_BYTE *)(a1 + 35) != 1 || *(_WORD *)(a1 + 2 * *(_BYTE *)(a1 + 34)) >= 0x14Cu )
  {
    *a2 = word_100A72E8[*(_BYTE *)(a1 + 34) + 4 * *(_BYTE *)(a1 + 33)];
    result = BMP_get_bm_def((unsigned __int16)word_100A72E8[*(_BYTE *)(a1 + 34) + 4 * *(_BYTE *)(a1 + 33)]);
  }
  else
  {
    *a2 = *(_WORD *)(a1 + 2 * *(_BYTE *)(a1 + 34));
    result = BMP_get_bm_def(*(_WORD *)(a1 + 2 * *(_BYTE *)(a1 + 34)));
  }
  return result;
}
// 100820C4: using guessed type int __cdecl BMP_get_bm_def(_DWORD);
// 100A72E8: using guessed type __int16 word_100A72E8[];

//----- (10031340) --------------------------------------------------------
__int16 __usercall sub_10031340@<ax>(int a1@<eax>, int a2@<ecx>)
{
  signed __int16 v2; // dx@2
  __int16 result; // ax@5

  if ( *(_BYTE *)(a1 + 35) == 1 )
  {
    *(_WORD *)(a2 + 8) = *(_WORD *)(a1 + 2 * *(_BYTE *)(a1 + 34));
    v2 = 12;
    if ( *(_WORD *)(a1 + 2 * *(_BYTE *)(a1 + 34) + 16) <= 0 )
      *(_WORD *)(a2 + 4) = 12;
    else
      *(_WORD *)(a2 + 4) = *(_WORD *)(a1 + 2 * *(_BYTE *)(a1 + 34) + 16);
    result = *(_WORD *)(a1 + 2 * *(_BYTE *)(a1 + 34) + 8);
    if ( result > 0 )
    {
      *(_WORD *)(a2 + 6) = result;
      return result;
    }
  }
  else
  {
    result = word_100A7388[*(_BYTE *)(a1 + 34) + 4 * *(_BYTE *)(a1 + 33)];
    v2 = 12;
    *(_WORD *)(a2 + 8) = result;
    *(_WORD *)(a2 + 4) = 12;
  }
  *(_WORD *)(a2 + 6) = v2;
  return result;
}
// 100A7388: using guessed type __int16 word_100A7388[];

//----- (100313B0) --------------------------------------------------------
int __usercall sub_100313B0@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@2

  if ( *(_BYTE *)(result + 35) == 1 && (v2 = *(_DWORD *)(result + 4 * *(_BYTE *)(result + 34))) != 0 )
  {
    *(_DWORD *)(a2 + 4) = v2;
  }
  else
  {
    result = dword_100A7308[*(_BYTE *)(result + 34) + 4 * *(_BYTE *)(result + 33)];
    *(_DWORD *)(a2 + 4) = result;
  }
  return result;
}
// 100A7308: using guessed type int dword_100A7308[];

//----- (100313E0) --------------------------------------------------------
char *__usercall sub_100313E0@<eax>(int a1@<eax>)
{
  int v1; // ecx@2
  unsigned __int16 v3; // dx@4

  if ( *(_BYTE *)(a1 + 35) == 1 )
  {
    v1 = *(_BYTE *)(a1 + 34);
    if ( *(_BYTE *)(a1 + 32) == 4 )
      return *(char **)(a1 + 4 * v1 + 16);
    v3 = *(_WORD *)(a1 + 2 * v1 + 16);
    if ( v3 >= 0x1C8Au )
      return sub_10037280(word_100A7368[v1 + 4 * *(_BYTE *)(a1 + 33)]);
    return sub_10037280(v3);
  }
  if ( *(_BYTE *)(a1 + 32) == 3 )
  {
    v3 = word_100A7348[*(_BYTE *)(a1 + 34) + 4 * *(_BYTE *)(a1 + 33)];
    return sub_10037280(v3);
  }
  return sub_10037280(word_100A7368[*(_BYTE *)(a1 + 34) + 4 * *(_BYTE *)(a1 + 33)]);
}
// 100A7348: using guessed type __int16 word_100A7348[];
// 100A7368: using guessed type __int16 word_100A7368[];

//----- (10031460) --------------------------------------------------------
char __usercall sub_10031460@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, _WORD *a4)
{
  char *v4; // eax@2
  char result; // al@2
  __int16 v6; // ax@3
  __int16 v7; // dx@4
  __int16 v8; // [sp+4h] [bp-38h]@3
  __int16 v9; // [sp+6h] [bp-36h]@3
  unsigned __int16 v10[2]; // [sp+8h] [bp-34h]@3
  int v11; // [sp+Ch] [bp-30h]@3
  char v12; // [sp+10h] [bp-2Ch]@4
  int v13; // [sp+14h] [bp-28h]@2
  __int16 v14; // [sp+1Ch] [bp-20h]@2
  int v15; // [sp+1Eh] [bp-1Eh]@2
  int v16; // [sp+24h] [bp-18h]@4
  char v17; // [sp+30h] [bp-Ch]@2

  switch ( *(_BYTE *)(a3 + 32) )
  {
    case 0:
    case 3:
    case 4:
      v13 = 105;
      sub_100313B0(a3, (int)&v13);
      v4 = sub_100313E0(a3);
      sub_100365D0((int)&v17, v4, 8);
      LOWORD(v15) = *(_BYTE *)(a3 + 32) != 3 ? 8 : 2;
      v14 = 10 * v15;
      sub_10030C20(a1, (int)&v13, a2, &v17);
      result = 2;
      break;
    case 1:
      v11 = 63;
      sub_100312D0(a3, v10);
      v6 = *(_WORD *)(a2 + 2) - 13;
      v8 = *(_WORD *)a2 - 1;
      v9 = v6;
      sub_10033B60(a1, (int)&v11, (int)&v8, v10, a4);
      result = 2;
      break;
    case 2:
      v16 = 96;
      sub_10031340(a3, (int)&v16);
      v7 = *(_WORD *)(a2 + 2) - 11;
      v8 = *(_WORD *)a2 - 1;
      v9 = v7;
      sub_10031840(a1, (int)&v16, (int)&v8, &v12, a4);
      result = 2;
      break;
    default:
      result = 1;
      break;
  }
  return result;
}

//----- (100315D0) --------------------------------------------------------
char __cdecl sub_100315D0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@4

  if ( *a5 == 32802 || *a5 == 32832 || *a5 == 32888 )
    result = sub_10031460(a1, a3, a4, a5);
  else
    result = 1;
  return result;
}

//----- (10031610) --------------------------------------------------------
char __cdecl sub_10031610(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1
  __int16 v6; // cx@4
  unsigned int v7; // eax@4
  __int16 v8; // cx@4
  int v9; // eax@4
  int v10; // ecx@8
  __int16 v11; // bp@8
  __int16 *v12; // ebx@9
  char v13; // dl@10
  __int16 v14; // ax@14
  __int16 v15; // cx@16
  int v16; // [sp+4h] [bp-14h]@9
  __int16 v17; // [sp+8h] [bp-10h]@4
  __int16 v18; // [sp+Ch] [bp-Ch]@4
  __int16 v19; // [sp+Eh] [bp-Ah]@4
  __int16 v20; // [sp+10h] [bp-8h]@4
  __int16 v21; // [sp+12h] [bp-6h]@4
  __int16 v22; // [sp+14h] [bp-4h]@4
  __int16 v23; // [sp+16h] [bp-2h]@4
  int v24; // [sp+2Ch] [bp+14h]@9

  result = 1;
  if ( *a5 != 32802 )
  {
    if ( *a5 == 32832 )
    {
      *(_WORD *)(a1 + 276) = *(_WORD *)a3;
      *(_WORD *)(a1 + 278) = *(_WORD *)(a3 + 2);
      *(_WORD *)(a1 + 280) = *(_WORD *)a3 + *(_WORD *)(a2 + 4) - 1;
      result = 2;
      *(_WORD *)(a1 + 282) = *(_WORD *)(a3 + 2) + *(_WORD *)(a2 + 6) - 1;
      return result;
    }
    if ( *a5 != 32888 )
      return result;
  }
  v18 = word_1065DED0[1];
  v19 = word_1065DED0[0];
  v20 = word_1065DED0[0];
  v21 = word_1065DED0[0];
  v22 = word_1065DED0[0];
  v6 = word_1065DED0[(unsigned __int8)sub_100397E0(15)];
  v7 = *(_WORD *)(a2 + 8);
  v23 = v6;
  v8 = v7;
  v9 = ((v7 >> 12) & 3) + 1;
  *(_WORD *)(a1 + 426) = v9;
  *(_WORD *)(a1 + 424) = v9;
  v17 = v8 & 0xC00;
  if ( (*(_WORD *)(a2 + 8) & 0xC000) == -32768 )
  {
    *(_WORD *)(a1 + 398) = 1;
    *(_DWORD *)(a1 + 452) = &unk_10091E38;
    *(_WORD *)(a1 + 440) = 0;
    *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
  }
  else
  {
    *(_WORD *)(a1 + 440) = *(_WORD *)(a4 + 2);
    *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
    *(_WORD *)(a1 + 398) = 3;
  }
  v10 = 3 - v9;
  v11 = 0;
  if ( 3 - v9 < 3 )
  {
    v24 = v10 + 1;
    v12 = &v18 + 2 * v10;
    v16 = 3 - v10;
    do
    {
      v13 = 2;
      if ( v24 >= 3 && (*(_WORD *)(a2 + 8) & 0xC000) != 0x4000 )
        v13 = 3;
      if ( v17 == 2048 )
      {
        *(_WORD *)(a1 + 428) = *(_WORD *)a4;
        v14 = *(_WORD *)a4;
      }
      else
      {
        if ( v17 )
        {
          v15 = v12[1];
          v14 = *v12;
        }
        else
        {
          v15 = *v12;
          v14 = v12[1];
        }
        *(_WORD *)(a1 + 428) = v15;
      }
      *(_WORD *)(a1 + 430) = v14;
      sub_1001EC10(
        a1 + 392,
        v11 + *(_WORD *)a3,
        v11 + *(_WORD *)(a3 + 2),
        *(_WORD *)(a2 + 4) - 2 * v11,
        *(_WORD *)(a2 + 6) - 2 * v11,
        v13);
      ++v24;
      v12 += 2;
      ++v11;
      --v16;
    }
    while ( v16 );
  }
  return 2;
}
// 1065DED0: using guessed type __int16 word_1065DED0[];

//----- (10031840) --------------------------------------------------------
char __cdecl sub_10031840(int a1, int a2, int a3, _BYTE *a4, _WORD *a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  char v7; // ST10_1@2
  __int16 v8; // cx@2
  __int16 v9; // ax@2
  __int16 v11; // [sp+10h] [bp-14h]@4
  __int16 v12; // [sp+12h] [bp-12h]@4
  int v13; // [sp+14h] [bp-10h]@1
  int v14; // [sp+18h] [bp-Ch]@1
  int v15; // [sp+1Ch] [bp-8h]@1

  v5 = *(_DWORD *)(a2 + 8);
  v6 = *(_DWORD *)(a2 + 4);
  v13 = *(_DWORD *)a2;
  v14 = v6;
  v15 = v5;
  if ( (_WORD)v5 == -1 )
  {
    v7 = *a4 & 0x1F;
    LOWORD(v15) = *(_WORD *)a4;
    v8 = word_1065DED0[(unsigned __int8)sub_100397E0(v7)];
    v9 = word_1065DED0[((unsigned int)*(_WORD *)a4 >> 5) & 0x1F];
  }
  else
  {
    v8 = word_1065DED0[(unsigned __int8)sub_100397E0(v5 & 0x1F)];
    v9 = word_1065DED0[((unsigned int)*(_WORD *)(a2 + 8) >> 5) & 0x1F];
  }
  v11 = v8;
  v12 = v9;
  return sub_10031610(a1, (int)&v13, a3, (int)&v11, a5);
}
// 1065DED0: using guessed type __int16 word_1065DED0[];

//----- (10031920) --------------------------------------------------------
int __cdecl sub_10031920(unsigned int a1, char a2, int a3, int a4)
{
  int result; // eax@1

  result = a3 * byte_10789611[20 * ((a1 >> 10) & 0xF)]
         + (a3 - 1) * *(_WORD *)(dword_10789604[5 * ((a1 >> 10) & 0xF)] + 28);
  if ( a4 > 0 )
  {
    if ( a2 & 0x80 )
      result += BYTE3(dword_10789600[5 * ((a1 >> 10) & 0xF) + 3]) - byte_10789611[20 * ((a1 >> 10) & 0xF)];
  }
  return result;
}
// 10789600: using guessed type int dword_10789600[];
// 10789604: using guessed type int dword_10789604[];

//----- (10031980) --------------------------------------------------------
char __cdecl sub_10031980(int a1, int a2, int a3, double *a4)
{
  int v4; // esi@1
  bool v5; // zf@1
  unsigned int v6; // ecx@1
  int v7; // eax@1
  __int16 v8; // bx@1
  double v9; // st7@3
  __int16 v10; // cx@5
  __int16 v11; // cx@5
  int v12; // ebx@8
  size_t v13; // edi@9
  int v14; // eax@9
  int v15; // edx@14
  __int16 v16; // ax@14
  float v17; // ST4C_4@20
  char *v18; // edi@27
  char v19; // al@28
  char *v20; // edi@30
  char v21; // al@31
  char v22; // al@33
  char *v23; // eax@35
  char v24; // cl@36
  signed int v25; // ecx@37
  char v26; // cl@38
  int v27; // ecx@40
  int v28; // edi@43
  int i; // eax@47
  char v30; // dl@50
  signed int v31; // ecx@52
  char v32; // al@53
  int v33; // eax@63
  signed int v34; // ebx@69
  signed int v35; // eax@69
  unsigned int v36; // ST18_4@71
  int *v37; // eax@71
  int v38; // edi@80
  unsigned int v39; // ebx@80
  __int16 v40; // ax@80
  bool v42; // [sp+2Fh] [bp-59h]@21
  int v43; // [sp+30h] [bp-58h]@1
  int v44; // [sp+30h] [bp-58h]@14
  int v45; // [sp+34h] [bp-54h]@1
  char *v46; // [sp+38h] [bp-50h]@14
  char v47; // [sp+3Ch] [bp-4Ch]@71
  char v48; // [sp+3Dh] [bp-4Bh]@71
  char v49; // [sp+3Eh] [bp-4Ah]@71
  int v50; // [sp+40h] [bp-48h]@3
  int v51; // [sp+44h] [bp-44h]@1
  int v52; // [sp+48h] [bp-40h]@1
  int v53; // [sp+4Ch] [bp-3Ch]@1
  double v54; // [sp+50h] [bp-38h]@5
  char v55[2]; // [sp+58h] [bp-30h]@21
  char v56; // [sp+63h] [bp-25h]@12
  char v57; // [sp+64h] [bp-24h]@9
  char v58; // [sp+65h] [bp-23h]@64

  v4 = a2;
  v5 = *(_BYTE *)a2 == 89;
  v45 = *(_BYTE *)(a2 + 10);
  v6 = *(_WORD *)(a2 + 8);
  v53 = a1;
  v7 = *(_BYTE *)(a2 + 11);
  v8 = v6;
  v52 = a2;
  v51 = (unsigned __int16)v6;
  v43 = v7;
  if ( v5 && 9.899999762399947e24 != *a4 )
  {
    *(float *)&v50 = *a4;
    v9 = sub_10040160(v50, v6);
  }
  else
  {
    *(float *)&v50 = 9.8999998e24;
    v9 = *a4;
  }
  v10 = *(_WORD *)(a2 + 8);
  v54 = v9;
  v11 = v10 & 0x3F;
  if ( v11 == 28 )
  {
    if ( v9 > 1.0 || v9 < 0.0 )
    {
LABEL_8:
      v12 = v53;
LABEL_9:
      v13 = *(_BYTE *)(v4 + 10);
      memset(&v57, 95, v13);
      v14 = v43;
      if ( v43 > 0 )
      {
        if ( (signed int)(v13 - v43) <= 1 )
          v14 = v13 - 2;
        *(&v56 + v13 - v14) = 46;
      }
      *(&v57 + v13) = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( v9 >= 1.0e25 )
      goto LABEL_8;
    if ( v9 <= -1.0e25 )
      goto LABEL_8;
    if ( 9.899999762399947e24 == v9 )
      goto LABEL_8;
    v17 = v9;
    if ( v17 == 9.8999998e24 )
      goto LABEL_8;
  }
  v42 = 1;
  strcpy(v55, "%");
  if ( v8 & 0x800 || v8 & 0x40 || v11 == 27 || v11 == 28 )
  {
    ++v45;
    v18 = (char *)&v54 + 7;
    do
      v19 = (v18++)[1];
    while ( v19 );
    *(_WORD *)v18 = 43;
  }
  else if ( v11 == 7 )
  {
    ++v45;
  }
  v20 = (char *)&v54 + 7;
  if ( v8 & 0x100 )
  {
    do
      v21 = (v20++)[1];
    while ( v21 );
    *(_WORD *)v20 = 48;
  }
  else
  {
    do
      v22 = (v20++)[1];
    while ( v22 );
    *(_WORD *)v20 = 45;
  }
  v23 = (char *)&v54 + 7;
  if ( v11 == 7 )
  {
    do
      v24 = (v23++)[1];
    while ( v24 );
    v25 = 1697263146;
  }
  else
  {
    do
      v26 = (v23++)[1];
    while ( v26 );
    v25 = 1714040362;
  }
  *(_DWORD *)v23 = v25;
  v27 = *(_BYTE *)(a2 + 10);
  v23[4] = 0;
  v12 = _snprintf(&v57, 0x1Eu, v55, v27, *(_BYTE *)(a2 + 11), LODWORD(v9), (_DWORD)(*(unsigned __int64 *)&v9 >> 32));
  if ( v12 > v45 )
  {
    v42 = 0;
    if ( !(v51 & 0x80) && v43 > 0 )
    {
      v28 = v43;
      do
      {
        if ( v42 )
          break;
        v12 = sprintf(&v57, v55, *(_BYTE *)(a2 + 10), --v28, v54);
        v42 = v12 <= v45;
      }
      while ( v28 > 0 );
      v43 = v28;
    }
  }
  for ( i = v12 - 1; i >= 0; --i )
  {
    if ( *(&v57 + i) != 32 )
      break;
    *(&v57 + i) = 0;
    --v12;
  }
  v30 = 1;
  if ( v57 == 45 || v57 == 43 )
  {
    v31 = 1;
    if ( v12 <= 1 )
      goto LABEL_89;
    do
    {
      v32 = *(&v57 + v31);
      if ( v32 != 46 && v32 != 48 && v32 != 101 && v32 != 43 )
      {
        v30 = 0;
        v31 = v12;
      }
      ++v31;
    }
    while ( v31 < v12 );
    if ( v30 )
    {
LABEL_89:
      if ( (*(_WORD *)(a2 + 8) & 0x3F) == 17 && *(_WORD *)(a2 + 8) & 0x40 )
      {
        v57 = 43;
      }
      else
      {
        --v12;
        v33 = 0;
        if ( v12 > 0 )
        {
          qmemcpy(&v57, &v58, v12);
          v4 = v52;
          v33 = v12;
        }
        *(&v57 + v33) = 0;
      }
    }
  }
  if ( !v42 )
    goto LABEL_9;
LABEL_14:
  v46 = (char *)sub_10037720(*(_WORD *)(v4 + 8), (float *)&v50);
  v15 = (signed __int16)sub_100034E0(*(_DWORD *)(v4 + 4), *(_WORD *)(v4 + 8), (float *)&v50);
  v16 = *(_WORD *)(v4 + 8) & 0x3F;
  v44 = v15;
  if ( v16 == 27 )
  {
    if ( v57 == 45 )
    {
      v57 = -100;
    }
    else if ( v57 == 43 )
    {
      --v45;
      v34 = v12 - 1;
      v35 = 0;
      if ( v34 > 0 )
      {
        qmemcpy(&v57, &v58, v34);
        v4 = v52;
        v35 = v34;
      }
      *(&v57 + v35) = 0;
      v36 = *(_DWORD *)(v4 + 4);
      v47 = *v46;
      v48 = -99;
      v49 = 0;
      v46 = &v47;
      v37 = sub_10002E60(v36);
      v44 += sub_1001C410(v37[1], "", 0);
    }
  }
  else if ( v16 == 28 && !strncmp(&v57, "+0.", 3u) )
  {
    strncpy(&v57, "M ", 2u);
  }
  if ( v51 & 0x800 )
  {
    if ( v57 == 45 )
    {
      v57 = -92;
    }
    else if ( v57 == 43 )
    {
      v57 = -93;
    }
  }
  v38 = v53;
  *(_WORD *)(v53 + 438) = *(_WORD *)a3;
  *(_WORD *)(v38 + 436) = *(_WORD *)(a3 + 2);
  v39 = *(_DWORD *)(v4 + 4);
  v40 = *(_WORD *)(v4 + 12);
  if ( (*(_DWORD *)(v4 + 4) & 0xC000) != 0x4000 )
  {
    if ( ~(unsigned __int8)(*(_WORD *)(v4 + 8) >> 9) & 1 )
    {
      v40 -= v44;
      if ( v44 > 0 )
        v40 -= *(_WORD *)(dword_10789604[5 * ((v39 >> 10) & 0xF)] + 28);
    }
  }
  if ( !*(_WORD *)(v4 + 12) )
    v40 = sub_10031920(v39, *(_WORD *)(v4 + 8), v45, *(_BYTE *)(v4 + 11));
  return sub_100039C0(v38, &v57, v46, v40, v44, v39, v51);
}
// 10789604: using guessed type int dword_10789604[];

//----- (10031E80) --------------------------------------------------------
char __usercall sub_10031E80@<al>(float *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4)
{
  int v4; // ebp@1
  double v5; // st7@4
  double v6; // st7@6
  __int16 v7; // ax@6
  const char *v8; // esi@8
  int v10; // [sp+14h] [bp+4h]@6
  float v11; // [sp+14h] [bp+4h]@12

  v4 = a4;
  if ( *a1 >= 1.0e25 || *a1 <= -1.0e25 || 9.8999998e24 == *a1 )
    v5 = 0.0;
  else
    v5 = *a1;
  *(float *)&v10 = v5;
  v6 = sub_10040160(v10, *(_WORD *)(a2 + 8));
  v7 = *(_WORD *)(a2 + 8);
  if ( v7 & 0x40 )
  {
    if ( (v7 & 0x3F) == 7 )
      v8 = "%+0*.*e";
    else
      v8 = "%+0*.*f";
  }
  else
  {
    v8 = "%0*.*e";
    if ( (v7 & 0x3F) != 7 )
      v8 = "%0*.*f";
  }
  v11 = v6;
  if ( sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v8, a3, *(_BYTE *)(a2 + 11), v11) > a3 )
    sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v8, a3, *(_BYTE *)(a2 + 11), 0.0);
  *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = 0;
  return 4;
}

//----- (10031F60) --------------------------------------------------------
char __usercall sub_10031F60@<al>(int a1@<eax>, int a2, int a3, int a4)
{
  int v4; // esi@1
  __int16 v5; // ax@1
  int v6; // edi@1
  __int16 v7; // ax@2
  int v8; // ecx@8
  const char *v9; // ecx@11
  char v10; // bl@11
  char *v11; // eax@11
  char v12; // dl@11
  char v13; // cl@12
  const char *v14; // edx@14
  char *v15; // eax@14
  char v16; // di@14
  char v17; // cl@15
  char v18; // bl@16
  char *v19; // eax@16
  char v20; // dl@16
  char v21; // cl@17
  unsigned __int16 v22; // ax@20
  int v23; // ecx@22
  signed __int16 v24; // di@22
  char *v25; // eax@25
  char v26; // dl@26
  char v27; // bl@27
  char *v28; // eax@27
  char v29; // dl@27
  char v30; // cl@28
  int v31; // ecx@32
  unsigned __int8 v32; // al@32
  char *v33; // eax@36
  char v34; // dl@37
  char v35; // bl@38
  char *v36; // eax@38
  char v37; // dl@38
  char v38; // cl@39
  const char *v39; // ecx@42
  char v40; // bl@42
  char *v41; // eax@42
  char v42; // dl@42
  char v43; // cl@43
  int v44; // eax@47
  unsigned __int16 v45; // ax@53
  const char *v46; // ecx@59
  char v47; // bl@59
  char *v48; // eax@59
  char v49; // dl@59
  char v50; // cl@60
  int v51; // edx@62
  char v52; // al@64
  int v53; // ebp@64
  bool v54; // zf@71
  bool v55; // sf@71
  char *v56; // eax@72
  int v57; // edi@72
  char v58; // dl@73
  char v59; // bl@74
  char *v60; // eax@74
  char v61; // dl@74
  char v62; // cl@75
  int v63; // ecx@81
  unsigned __int8 v64; // al@81
  char *v65; // eax@85
  char v66; // dl@86
  char v67; // bl@87
  char *v68; // eax@87
  char v69; // dl@87
  char v70; // cl@88
  const char *v71; // ecx@93
  char v72; // kr00_1@93
  char *v73; // eax@93
  char v74; // dl@93
  char v75; // cl@94
  signed int v76; // eax@96
  char *v77; // eax@104
  int v78; // edi@104
  char v79; // dl@105
  char v80; // bl@106
  char *v81; // eax@106
  char v82; // dl@106
  char v83; // cl@107
  char *v84; // eax@116
  int v85; // edi@116
  char v86; // dl@117
  char v87; // bl@118
  char *v88; // eax@118
  char v89; // dl@118
  char v90; // cl@119
  char *v91; // eax@122
  int v92; // edi@122
  char v93; // dl@123
  char v94; // bl@124
  char *v95; // eax@124
  char v96; // dl@124
  char v97; // cl@125
  int v98; // ecx@126
  const char *v99; // edx@127
  char *v100; // eax@127
  char v101; // di@127
  char v102; // cl@128
  char v103; // bl@129
  char *v104; // eax@129
  char v105; // di@129
  char v106; // cl@130
  char *v107; // eax@131
  int v108; // ecx@131
  char v109; // dl@132
  char v110; // bl@133
  char *v111; // eax@133
  char v112; // dl@133
  char v113; // cl@134
  int v114; // ebp@142
  int v115; // ecx@147
  const char *v116; // edx@152
  char *v117; // eax@152
  char v118; // di@152
  char v119; // cl@153
  char v120; // bl@154
  char *v121; // eax@154
  char v122; // dl@154
  char v123; // cl@155
  int v124; // edx@158
  signed int v125; // eax@158
  char *v126; // eax@165
  int v127; // edi@165
  char v128; // dl@166
  char v129; // bl@167
  char *v130; // eax@167
  char v131; // dl@167
  char v132; // cl@168
  int v133; // eax@170
  char v135; // [sp+1Bh] [bp-Dh]@1
  float v136; // [sp+1Ch] [bp-Ch]@1
  char *v137; // [sp+20h] [bp-8h]@3
  int v138; // [sp+24h] [bp-4h]@1
  __int32 v139; // [sp+2Ch] [bp+4h]@71
  float v140; // [sp+2Ch] [bp+4h]@76

  v4 = a1;
  v136 = 0.0;
  v5 = *(_WORD *)(a2 + 8);
  v6 = a4;
  v135 = 1;
  v138 = 1;
  if ( v5 & 0x40 )
  {
    v7 = v5 & 0x3F;
    if ( v7 == 7 )
      v137 = "%+0*.*e";
    else
      v137 = "%+0*.*f";
  }
  else
  {
    v7 = v5 & 0x3F;
    v137 = "%0*.*e";
    if ( v7 != 7 )
      v137 = "%0*.*f";
  }
  if ( *(_WORD *)(a4 + 10) == 84 )
  {
    v8 = *(_DWORD *)(v4 + 56);
    if ( *(_WORD *)(v8 + 240) == -128 )
    {
      *(_WORD *)(a4 + 14) = 45;
    }
    else
    {
      if ( v7 != 7 )
        goto LABEL_176;
      v9 = (const char *)(v8 + 69);
      v10 = strlen(v9);
      v11 = strchr(v9, 101);
      v12 = (_BYTE)v11 + 1;
      do
        v13 = *v11++;
      while ( v13 );
      v8 = *(_DWORD *)(v4 + 56);
      if ( *(_WORD *)(v8 + 240) <= (signed __int16)(char)(v10 - ((_BYTE)v11 - v12)) )
      {
LABEL_176:
        v6 = a4;
        *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)(v8 + 69) != 45) + 43;
      }
      else
      {
        v14 = (const char *)(v8 + 69);
        v15 = (char *)(v8 + 69);
        v16 = v8 + 70;
        do
          v17 = *v15++;
        while ( v17 );
        v18 = (_BYTE)v15 - v16;
        v19 = strchr(v14, 101);
        v20 = (_BYTE)v19 + 1;
        do
          v21 = *v19++;
        while ( v21 );
        v6 = a4;
        *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)((char)(v18 - ((_BYTE)v19 - v20)) + *(_DWORD *)(v4 + 56) + 70) == 43) + 43;
      }
    }
  }
  v22 = *(_WORD *)(v6 + 14);
  if ( v22 < 0x30u || v22 > 0x39u )
  {
    if ( (*(_WORD *)(a2 + 8) & 0x3F) != 7 || v22 != 69 )
    {
      if ( (v22 == 43 || v22 == 45) && (sub_100376E0(*(_WORD *)(a2 + 8)) || *(_BYTE *)(a2 + 8) & 0x40) )
      {
        if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
        {
          sub_10031E80(&v136, a2, a3, v4);
          if ( *(_BYTE *)(a2 + 11) )
          {
            v84 = (char *)(*(_DWORD *)(v4 + 56) + 69);
            v85 = *(_DWORD *)(v4 + 56) + 70;
            do
              v86 = *v84++;
            while ( v86 );
            v87 = (_BYTE)v84 - v85;
            v88 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
            v89 = (_BYTE)v88 + 1;
            do
              v90 = *v88++;
            while ( v90 );
            *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v87 - ((_BYTE)v88 - v89)) - 1;
          }
          else
          {
            *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = a3 - ((*(_WORD *)(a2 + 8) >> 13) & 3) - 1;
          }
        }
        if ( (*(_BYTE *)(a2 + 8) & 0x3F) != 7 )
          goto LABEL_177;
        v91 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        v92 = *(_DWORD *)(v4 + 56) + 70;
        do
          v93 = *v91++;
        while ( v93 );
        v94 = (_BYTE)v91 - v92;
        v95 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
        v96 = (_BYTE)v95 + 1;
        do
          v97 = *v95++;
        while ( v97 );
        v98 = *(_DWORD *)(v4 + 56);
        if ( *(_WORD *)(v98 + 240) <= (signed __int16)(char)(v94 - ((_BYTE)v95 - v96)) )
        {
LABEL_177:
          if ( (*(_WORD *)(a4 + 14) != 45 || atof((const char *)(*(_DWORD *)(v4 + 56) + 69)) < 0.0)
            && (*(_WORD *)(a4 + 14) != 43 || atof((const char *)(*(_DWORD *)(v4 + 56) + 69)) > 0.0) )
          {
            v114 = a2;
          }
          else
          {
            v114 = a2;
            if ( *(_BYTE *)(a2 + 8) & 0x40 || *(_WORD *)(a4 + 14) == 45 )
            {
              *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
              v135 = 2;
            }
            else
            {
              *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = 48;
              v135 = 2;
            }
          }
          v115 = *(_DWORD *)(v4 + 56);
          if ( !*(_WORD *)(v115 + 240)
            && (*(_BYTE *)(*(_WORD *)(v115 + 240) + v115 + 69) == 43
             || *(_BYTE *)(*(_WORD *)(v115 + 240) + v115 + 69) == 45
             || (*(_BYTE *)(v114 + 8) & 0x3F) == 7) )
          {
            if ( (*(_BYTE *)(v114 + 8) & 0x3F) == 7 )
            {
              v116 = (const char *)(v115 + 69);
              v117 = (char *)(v115 + 69);
              v118 = v115 + 70;
              do
                v119 = *v117++;
              while ( v119 );
              v120 = (_BYTE)v117 - v118;
              v121 = strchr(v116, 46);
              v122 = (_BYTE)v121 + 1;
              do
                v123 = *v121++;
              while ( v123 );
              *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v120 - ((_BYTE)v121 - v122)) - 1;
            }
            else
            {
              ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
            }
            v124 = *(_DWORD *)(v4 + 56);
            v125 = a3 - (((unsigned int)*(_WORD *)(v114 + 8) >> 13) & 3) - 1;
            if ( *(_WORD *)(v124 + 240) < v125 )
              LOWORD(v125) = *(_WORD *)(v124 + 240);
            *(_WORD *)(v124 + 240) = (char)v125;
          }
        }
        else
        {
          v99 = (const char *)(v98 + 69);
          v100 = (char *)(v98 + 69);
          v101 = v98 + 70;
          do
            v102 = *v100++;
          while ( v102 );
          v103 = (_BYTE)v100 - v101;
          v104 = strchr(v99, 101);
          v105 = (_BYTE)v104 + 1;
          do
            v106 = *v104++;
          while ( v106 );
          *(_BYTE *)((char)(v103 - ((_BYTE)v104 - v105)) + *(_DWORD *)(v4 + 56) + 70) = *(_BYTE *)(a4 + 14);
          v107 = (char *)(*(_DWORD *)(v4 + 56) + 69);
          v108 = *(_DWORD *)(v4 + 56) + 70;
          do
            v109 = *v107++;
          while ( v109 );
          v110 = (_BYTE)v107 - v108;
          v111 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
          v112 = (_BYTE)v111 + 1;
          do
            v113 = *v111++;
          while ( v113 );
          if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == (char)(v110 - ((_BYTE)v111 - v112)) + 1 )
            ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
          v135 = 2;
        }
      }
      else if ( *(_WORD *)(v6 + 14) == 46 && *(_BYTE *)(a2 + 11) > 0 )
      {
        if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
          sub_10031E80(&v136, a2, a3, v4);
        v126 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        v127 = *(_DWORD *)(v4 + 56) + 70;
        do
          v128 = *v126++;
        while ( v128 );
        v129 = (_BYTE)v126 - v127;
        v130 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
        v131 = (_BYTE)v130 + 1;
        do
          v132 = *v130++;
        while ( v132 );
        *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v129 - ((_BYTE)v130 - v131)) + 1;
      }
    }
    else
    {
      if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
        sub_10031E80(&v136, a2, a3, v4);
      v77 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      v78 = *(_DWORD *)(v4 + 56) + 70;
      do
        v79 = *v77++;
      while ( v79 );
      v80 = (_BYTE)v77 - v78;
      v81 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
      v82 = (_BYTE)v81 + 1;
      do
        v83 = *v81++;
      while ( v83 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v80 - ((_BYTE)v81 - v82)) + 1;
      v135 = 2;
    }
    goto LABEL_170;
  }
  v23 = *(_DWORD *)(v4 + 56);
  v24 = *(_WORD *)(v23 + 240);
  if ( v24 == -128 )
  {
    sub_10031E80(&v136, a2, a3, v4);
    if ( *(_BYTE *)(a2 + 11) )
    {
      v25 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      do
        v26 = *v25++;
      while ( v26 );
      v27 = (_BYTE)v25 - (*(_BYTE *)(v4 + 56) + 70);
      v28 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
      v29 = (_BYTE)v28 + 1;
      do
        v30 = *v28++;
      while ( v30 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v27 - ((_BYTE)v28 - v29)) - 1;
    }
    else
    {
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = a3 - ((*(_WORD *)(a2 + 8) >> 13) & 3) - 1;
    }
    *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
    if ( *(_BYTE *)(a2 + 11) > 0 )
    {
      if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7
        || (v31 = *(_DWORD *)(v4 + 56), v32 = *(_BYTE *)(v31 + 69), v32 > 0x30u)
        || (v32 == 43 || v32 == 45) && *(_BYTE *)(v31 + 70) != 48 )
      {
        v33 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        do
          v34 = *v33++;
        while ( v34 );
        v35 = (_BYTE)v33 - (*(_BYTE *)(v4 + 56) + 70);
        v36 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
        v37 = (_BYTE)v36 + 1;
        do
          v38 = *v36++;
        while ( v38 );
        *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v35 - ((_BYTE)v36 - v37)) + 1;
        v135 = 2;
        goto LABEL_170;
      }
    }
LABEL_99:
    v135 = 2;
    goto LABEL_170;
  }
  if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7 )
  {
    v39 = (const char *)(v23 + 69);
    v40 = strlen(v39);
    v41 = strchr(v39, 101);
    v42 = (_BYTE)v41 + 1;
    do
      v43 = *v41++;
    while ( v43 );
    v23 = *(_DWORD *)(v4 + 56);
    v24 = *(_WORD *)(v23 + 240);
    if ( v24 > (char)(v40 - ((_BYTE)v41 - v42)) )
    {
      if ( a3 - v24 != 2 )
      {
        if ( a3 - v24 != 3 )
        {
          v44 = *(_DWORD *)(v4 + 56);
          if ( a3 - v24 != 4 )
          {
            if ( *(_BYTE *)(*(_WORD *)(v44 + 240) + v44 + 68) < 0x33u || *(_WORD *)(a4 + 14) < 0x38u )
            {
              *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
              v135 = 2;
              goto LABEL_170;
            }
            goto LABEL_99;
          }
          ++*(_WORD *)(v44 + 240);
        }
        ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
      }
      v45 = *(_WORD *)(a4 + 14);
      if ( v45 >= 0x30u
        && v45 <= 0x33u
        && (*(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 70) < 0x38u || v45 < 0x33u) )
      {
        *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v4 + 56) + 240))++ + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
        v135 = 2;
        goto LABEL_170;
      }
      goto LABEL_99;
    }
  }
  if ( *(_BYTE *)(a2 + 11) <= 0 )
    goto LABEL_178;
  v46 = (const char *)(v23 + 69);
  v47 = strlen(v46);
  v48 = strchr(v46, 46);
  v49 = (_BYTE)v48 + 1;
  do
    v50 = *v48++;
  while ( v50 );
  v23 = *(_DWORD *)(v4 + 56);
  v24 = *(_WORD *)(v23 + 240);
  if ( *(_WORD *)(v23 + 240) != (char)(v47 - ((_BYTE)v48 - v49)) - 1 )
  {
LABEL_178:
    v51 = a2;
    if ( !*(_BYTE *)(a2 + 11) )
    {
      if ( v24 == a3 - (((unsigned int)*(_WORD *)(a2 + 8) >> 13) & 3) - 1 )
        goto LABEL_64;
      v51 = a2;
    }
    if ( (*(_BYTE *)(v51 + 8) & 0x3F) == 7 && !v24 )
    {
      v71 = (const char *)(v23 + 69);
      v72 = strlen(v71);
      v73 = strchr(v71, 46);
      v74 = (_BYTE)v73 + 1;
      do
        v75 = *v73++;
      while ( v75 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v72 - ((_BYTE)v73 - v74)) - 1;
      v51 = a2;
    }
    *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v4 + 56) + 240))++ + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
    v76 = a3 - (((unsigned int)*(_WORD *)(v51 + 8) >> 13) & 3) - 1;
    if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) < v76 )
      LOWORD(v76) = *(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)v76;
    goto LABEL_99;
  }
LABEL_64:
  v52 = *(_BYTE *)(v23 + 69);
  v53 = a2;
  if ( v52 == 48 && (*(_BYTE *)(a2 + 8) & 0x3F) != 7 || (v52 == 43 || v52 == 45) && *(_BYTE *)(v23 + 70) == 48 )
  {
    if ( v52 == 45 )
    {
      *(_BYTE *)(v23 + 69) = 48;
      v138 = -1;
    }
    v139 = j__atol((const char *)(*(_DWORD *)(v4 + 56) + 69));
    v54 = *(_BYTE *)(v53 + 11) == 0;
    v55 = *(_BYTE *)(v53 + 11) < 0;
    v136 = (double)v139 * 10.0;
    if ( !v55 && !v54 )
    {
      v56 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      v57 = *(_DWORD *)(v4 + 56) + 70;
      do
        v58 = *v56++;
      while ( v58 );
      v59 = (_BYTE)v56 - v57;
      v60 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
      v61 = (_BYTE)v60 + 1;
      do
        v62 = *v60++;
      while ( v62 );
      v140 = atof((const char *)((char)(v59 - ((_BYTE)v60 - v61)) + *(_DWORD *)(v4 + 56) + 69));
      v136 = v140 + v136;
    }
    sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v137, a3, *(_BYTE *)(v53 + 11), v136);
    if ( v138 == -1 )
      *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = 45;
  }
  *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
  if ( *(_BYTE *)(v53 + 11) <= 0 )
    goto LABEL_99;
  if ( (*(_BYTE *)(v53 + 8) & 0x3F) != 7 )
  {
    v63 = *(_DWORD *)(v4 + 56);
    v64 = *(_BYTE *)(v63 + 69);
    if ( v64 <= 0x30u && (v64 != 43 && v64 != 45 || *(_BYTE *)(v63 + 70) == 48) )
      goto LABEL_99;
  }
  v65 = (char *)(*(_DWORD *)(v4 + 56) + 69);
  do
    v66 = *v65++;
  while ( v66 );
  v67 = (_BYTE)v65 - (*(_BYTE *)(v4 + 56) + 70);
  v68 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
  v69 = (_BYTE)v68 + 1;
  do
    v70 = *v68++;
  while ( v70 );
  *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v67 - ((_BYTE)v68 - v69)) + 1;
  v135 = 2;
LABEL_170:
  v133 = *(_DWORD *)(v4 + 56);
  if ( *(_BYTE *)(*(_WORD *)(v133 + 240) + v133 + 69) == 101 || *(_BYTE *)(*(_WORD *)(v133 + 240) + v133 + 69) == 46 )
    ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
  return v135;
}

//----- (10032A30) --------------------------------------------------------
char __usercall sub_10032A30@<al>(int a1@<eax>, float *a2@<ecx>, int a3@<ebx>, int a4@<esi>, int a5)
{
  float *v5; // edi@1
  __int16 v6; // ax@1
  unsigned int v7; // edi@1
  int v8; // ebp@1
  __int16 v9; // ax@1
  const char *v11; // [sp+8h] [bp-4h]@1

  v5 = a2;
  *(_WORD *)(a3 + 438) = *(_WORD *)a1;
  *(_WORD *)(a3 + 436) = *(_WORD *)(a1 + 2);
  v11 = (const char *)sub_10037720(*(_WORD *)(a4 + 8), a2);
  v6 = sub_100034E0(*(_DWORD *)(a4 + 4), *(_WORD *)(a4 + 8), v5);
  v7 = *(_DWORD *)(a4 + 4);
  v8 = v6;
  v9 = *(_WORD *)(a4 + 12);
  if ( (*(_DWORD *)(a4 + 4) & 0xC000) != 0x4000 )
  {
    v9 -= v8;
    if ( v8 > 0 )
      v9 -= *(_WORD *)(dword_10789604[5 * ((v7 >> 10) & 0xF)] + 28);
  }
  if ( !*(_WORD *)(a4 + 12) )
    v9 = sub_10031920(v7, *(_WORD *)(a4 + 8), a5, *(_BYTE *)(a4 + 11));
  return sub_100039C0(a3, (char *)(*(_DWORD *)(a3 + 56) + 69), v11, v9, v8, v7, *(_WORD *)(a4 + 8));
}
// 10789604: using guessed type int dword_10789604[];

//----- (10032AF0) --------------------------------------------------------
char __usercall sub_10032AF0@<al>(int a1@<edx>, float *a2@<ecx>, int a3, int a4)
{
  double v4; // st7@2
  double v6; // [sp+0h] [bp-8h]@4

  if ( 9.8999998e24 == *a2 )
    v4 = 9.899999762399947e24;
  else
    v4 = *a2;
  v6 = v4;
  return sub_10031980(a3, a1, a4, &v6);
}

//----- (10032B30) --------------------------------------------------------
char __cdecl sub_10032B30(int a1, int a2, int *a3, float *a4, int a5)
{
  __int16 v5; // cx@2
  __int16 v6; // cx@4
  __int16 v7; // ax@9
  _WORD *v8; // esi@9
  unsigned int v9; // ebp@10
  int v10; // eax@10
  int v11; // edx@12
  __int16 v12; // ax@16
  int v13; // eax@17
  __int16 v14; // cx@17
  int v16; // eax@19
  signed __int16 v17; // si@19
  signed int v18; // eax@20
  char v19; // al@27
  char v20; // al@33
  __int16 v21; // ax@36
  signed int v22; // ecx@40
  int v23; // ecx@42
  int v24; // ecx@43
  int v25; // ecx@45
  int v26; // ecx@47
  int v27; // edi@49
  const char *v28; // eax@50
  char v29; // ST38_1@50
  bool v30; // zf@58
  bool v31; // sf@58
  int v32; // esi@65
  char v33; // dl@68
  bool v34; // zf@73
  bool v35; // sf@73
  bool v36; // zf@80
  bool v37; // sf@80
  char v38; // al@87
  int v39; // esi@94
  double v40; // st7@96
  int v41; // esi@101
  unsigned int v42; // edx@101
  __int16 v43; // bx@101
  unsigned __int8 v44; // cl@103
  int v45; // ecx@109
  _WORD *v46; // eax@109
  char v47; // dl@109
  char *v48; // eax@114
  int v49; // esi@114
  char v50; // dl@115
  char v51; // bl@116
  char *v52; // eax@116
  char v53; // dl@116
  char v54; // cl@117
  char v55; // cl@118
  int v56; // eax@118
  int v57; // edx@118
  char *v58; // eax@120
  int v59; // esi@120
  char v60; // dl@121
  char v61; // bl@122
  char *v62; // eax@122
  char v63; // dl@122
  char v64; // cl@123
  char v65; // cl@124
  int v66; // eax@124
  int v67; // edx@124
  char v68; // [sp-4h] [bp-2Ch]@64
  unsigned __int16 v69; // [sp+0h] [bp-28h]@64
  char v70; // [sp+4h] [bp-24h]@64
  char v71; // [sp+1Bh] [bp-Dh]@1
  size_t v72; // [sp+1Ch] [bp-Ch]@2
  unsigned int v73; // [sp+3Ch] [bp+14h]@50
  int v74; // [sp+3Ch] [bp+14h]@99

  v71 = 1;
  if ( *(_WORD *)a5 == -32703 )
  {
    v72 = 0;
  }
  else
  {
    v72 = *(_BYTE *)(a2 + 10);
    v5 = *(_WORD *)(a2 + 8);
    if ( v5 & 0x40 || *(_WORD *)(a2 + 8) & 0x800 || (v6 = v5 & 0x3F, v6 == 7) || v6 == 28 )
      ++v72;
  }
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v7 = *(_WORD *)(a2 + 12);
      v8 = (_WORD *)(a1 + 276);
      if ( v7 )
      {
        sub_10003860(a1 + 276, *a3, *(_DWORD *)(a2 + 4), v7);
      }
      else
      {
        v9 = *(_DWORD *)(a2 + 4);
        v10 = sub_10031920(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 10), *(_BYTE *)(a2 + 11));
        sub_10003860((int)v8, *a3, v9, v10);
      }
      v11 = (signed __int16)sub_100034E0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), a4);
      if ( (!*(_WORD *)(a2 + 12) || (*(_DWORD *)(a2 + 4) & 0xC000) == 0x4000)
        && ~(unsigned __int8)(*(_WORD *)(a2 + 8) >> 9) & 1
        && v11 > 0 )
      {
        v12 = *(_WORD *)(dword_10789604[5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF)] + 28);
        *(_WORD *)(a1 + 280) += v11 + v12;
        if ( (*(_DWORD *)(a2 + 4) & 0xC000) == 0x8000 )
        {
          v13 = (v12 + v11 + 1) / 2;
          v14 = *(_WORD *)(a1 + 280) - v13;
          *v8 -= v13;
          *(_WORD *)(a1 + 280) = v14;
        }
      }
      return 2;
    case 0x8048:
      v16 = *(_DWORD *)(a1 + 56);
      v17 = *(_WORD *)(v16 + 240);
      if ( v17 == -128 )
      {
        v18 = *(_WORD *)(a5 + 10);
        if ( v18 > 84 )
        {
          if ( v18 != 0x2000 )
            return v71;
        }
        else if ( v18 != 84 )
        {
          if ( v18 == 32 )
          {
            if ( *(_WORD *)(a2 + 8) & 0x400 || (*(_WORD *)(a2 + 8) & 0x3F) == 27 || *(_WORD *)(a2 + 8) & 0x800 )
              return v71;
            v71 = sub_10031E80(a4, a2, v72, a1);
            memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, v72);
            if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7 )
            {
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 71) = 46;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + v72 + 64) = 101;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + v72 + 65) = 43;
            }
            else
            {
              v20 = *(_BYTE *)(a2 + 11);
              if ( v20 > 0 )
                *(_BYTE *)(*(_DWORD *)(a1 + 56) - v20 + v72 + 68) = 46;
            }
            goto LABEL_132;
          }
          if ( v18 != 56
            || *(_WORD *)(a2 + 8) & 0x400
            || (*(_WORD *)(a2 + 8) & 0x3F) == 27
            || *(_WORD *)(a2 + 8) & 0x800 )
          {
            return v71;
          }
          v19 = sub_10031E80(a4, a2, v72, a1);
LABEL_131:
          v71 = v19;
LABEL_132:
          if ( v71 != 4 && v71 != 2 )
            return v71;
          goto LABEL_134;
        }
        v21 = *(_WORD *)(a2 + 8);
        if ( *(_WORD *)(a2 + 8) & 0x400 || (v21 & 0x3F) == 27 || *(_WORD *)(a2 + 8) & 0x800 )
          return v71;
        v19 = sub_10031F60(a1, a2, v72, a5);
        goto LABEL_131;
      }
      v22 = *(_WORD *)(a5 + 10);
      if ( v22 > 57 )
      {
        if ( v22 != 84 && v22 != 0x2000 )
          return v71;
        v19 = sub_10031F60(a1, a2, v72, a5);
        goto LABEL_131;
      }
      if ( v22 == 57 )
      {
        *(_WORD *)(v16 + 240) += *(_BYTE *)(a5 + 8);
        v41 = *(_DWORD *)(a1 + 56);
        v42 = *(_WORD *)(a2 + 8);
        v43 = *(_WORD *)(v41 + 240);
        v71 = 2;
        if ( v43 >= 0 )
        {
          v44 = *(_BYTE *)(a2 + 10);
          if ( v43 <= (signed int)(v44 - ((v42 >> 13) & 3) - 1) || v42 & 0x40 || (v42 & 0x3F) == 7 )
          {
            if ( v43 <= (signed int)v44 )
            {
              while ( 1 )
              {
                v45 = *(_DWORD *)(a1 + 56);
                v46 = (_WORD *)(v45 + 240);
                v47 = *(_BYTE *)(*(_WORD *)(v45 + 240) + v45 + 69);
                if ( v47 != 46 && v47 != 101 )
                {
                  if ( (*(_BYTE *)(a2 + 8) & 0x3F) != 7 || *(_WORD *)(v45 + 240) <= 0 )
                    break;
                  if ( !strchr((const char *)(v45 + 69), 46) )
                    goto LABEL_142;
                  v48 = (char *)(*(_DWORD *)(a1 + 56) + 69);
                  v49 = *(_DWORD *)(a1 + 56) + 70;
                  do
                    v50 = *v48++;
                  while ( v50 );
                  v51 = (_BYTE)v48 - v49;
                  v52 = strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 46);
                  v53 = (_BYTE)v52 + 1;
                  do
                    v54 = *v52++;
                  while ( v54 );
                  v55 = (_BYTE)v52 - v53;
                  v56 = *(_DWORD *)(a1 + 56);
                  v57 = *(_WORD *)(v56 + 240);
                  v46 = (_WORD *)(v56 + 240);
                  if ( v57 >= (char)(v51 - v55) - 1 )
                  {
LABEL_142:
                    if ( strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 46) )
                      break;
                    v58 = (char *)(*(_DWORD *)(a1 + 56) + 69);
                    v59 = *(_DWORD *)(a1 + 56) + 70;
                    do
                      v60 = *v58++;
                    while ( v60 );
                    v61 = (_BYTE)v58 - v59;
                    v62 = strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 101);
                    v63 = (_BYTE)v62 + 1;
                    do
                      v64 = *v62++;
                    while ( v64 );
                    v65 = (_BYTE)v62 - v63;
                    v66 = *(_DWORD *)(a1 + 56);
                    v67 = *(_WORD *)(v66 + 240);
                    v46 = (_WORD *)(v66 + 240);
                    if ( v67 >= (char)(v61 - v65) - 1 )
                      break;
                  }
                }
                if ( *(_BYTE *)(a5 + 8) <= 0 )
                  --*v46;
                else
                  ++*v46;
              }
            }
            else
            {
              *(_WORD *)(v41 + 240) = (char)v44;
            }
          }
          else
          {
            *(_WORD *)(v41 + 240) = (char)(v44 - ((v42 >> 13) & 3) - 1);
          }
        }
        else
        {
          *(_WORD *)(v41 + 240) = 0;
        }
        goto LABEL_134;
      }
      v23 = v22 - 32;
      if ( !v23 )
      {
        *(_WORD *)(v16 + 240) = -128;
        sub_10032AF0(a2, a4, a1, (int)a3);
        return 6;
      }
      v24 = v23 - 1;
      if ( v24 )
      {
        if ( v24 != 23 )
          return v71;
        v25 = *(_WORD *)(a2 + 8);
        if ( v25 & 0x40 && !v17 )
        {
          LOBYTE(v25) = *(_BYTE *)(v16 + 69) != 45;
          v26 = 2 * v25 + 43;
LABEL_48:
          *(_BYTE *)(v16 + 69) = v26;
          v71 = 2;
LABEL_134:
          sub_10032A30((int)a3, a4, a1, a2, v72);
          return v71;
        }
        v27 = 2 * (*(_BYTE *)(a5 + 8) >= 0) - 1;
        if ( (v25 & 0x3F) != 7
          || (v28 = (const char *)(v16 + 69),
              v73 = strlen(v28),
              v29 = strlen(strchr(v28, 101)),
              v16 = *(_DWORD *)(a1 + 56),
              v17 = *(_WORD *)(v16 + 240),
              v17 <= (char)(v73 - v29))
          && v17 )
        {
          v38 = *(_BYTE *)(v17 + v16 + 69);
          if ( (v38 == 48 && v27 < 0 || v38 == 57 && v27 > 0) && !v17 && sub_100376E0(*(_WORD *)(a2 + 8)) )
          {
            *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) = 45;
            v71 = 2;
            goto LABEL_134;
          }
          v39 = *(_DWORD *)(a1 + 56);
          *(_BYTE *)(*(_WORD *)(v39 + 240) + v39 + 69) = sub_10038B70(
                                                           *(_BYTE *)(*(_WORD *)(v39 + 240) + v39 + 69),
                                                           0x10u,
                                                           v27);
        }
        else
        {
          if ( !v17 )
          {
            v71 = 2;
            *(_BYTE *)(v16 + 69) = *(_BYTE *)(v16 + 69) != 45 ? 45 : 48;
            goto LABEL_134;
          }
          if ( v72 - v17 == 2 )
          {
            v16 += v17;
            if ( *(_BYTE *)(v16 + 70) > 0x37u )
            {
              v34 = v27 == 0;
              v35 = v27 < 0;
              if ( v27 < 0 )
              {
                if ( *(_BYTE *)(v16 + 69) == 48 )
                {
                  *(_BYTE *)(v16 + 69) = 50;
                  v71 = 2;
                  goto LABEL_134;
                }
                v34 = v27 == 0;
                v35 = v27 < 0;
              }
              if ( !v35 && !v34 && *(_BYTE *)(v16 + 69) >= 0x32u )
              {
                *(_BYTE *)(v16 + 69) = 48;
                v71 = 2;
                goto LABEL_134;
              }
LABEL_64:
              v70 = v27;
              v69 = 16;
              v68 = *(_BYTE *)(v16 + 69);
LABEL_65:
              v32 = *(_DWORD *)(a1 + 56);
              *(_BYTE *)(*(_WORD *)(v32 + 240) + v32 + 69) = sub_10038B70(v68, v69, v70);
              v71 = 2;
              goto LABEL_134;
            }
            v36 = v27 == 0;
            v37 = v27 < 0;
            if ( v27 < 0 )
            {
              if ( *(_BYTE *)(v16 + 69) == 48 )
              {
                *(_BYTE *)(v16 + 69) = 51;
                v71 = 2;
                goto LABEL_134;
              }
              v36 = v27 == 0;
              v37 = v27 < 0;
            }
            if ( !v37 && !v36 && *(_BYTE *)(v16 + 69) >= 0x33u )
            {
              *(_BYTE *)(v16 + 69) = 48;
              v71 = 2;
              goto LABEL_134;
            }
LABEL_66:
            v70 = v27;
            v69 = 16;
            v68 = *(_BYTE *)(v16 + 69);
            goto LABEL_65;
          }
          if ( v72 - v17 != 3 )
          {
            if ( v72 - v17 == 4 )
            {
              v71 = 2;
              *(_BYTE *)(v17 + v16 + 69) = 2 * (*(_BYTE *)(v17 + v16 + 69) != 45) + 43;
              goto LABEL_134;
            }
            v16 += v17;
            if ( *(_BYTE *)(v16 + 68) >= 0x33u )
            {
              v30 = v27 == 0;
              v31 = v27 < 0;
              LOBYTE(v26) = 48;
              if ( v27 < 0 )
              {
                if ( *(_BYTE *)(v16 + 69) == 48 )
                {
                  *(_BYTE *)(v16 + 69) = 55;
                  v71 = 2;
                  goto LABEL_134;
                }
                v30 = v27 == 0;
                v31 = v27 < 0;
              }
              if ( !v31 && !v30 && *(_BYTE *)(v16 + 69) >= 0x37u )
                goto LABEL_48;
              goto LABEL_64;
            }
            goto LABEL_66;
          }
          v33 = *(_BYTE *)(v17 + v16 + 69);
          if ( v33 == 45 )
          {
            *(_BYTE *)(v17 + v16 + 69) = 43;
            v71 = 2;
            goto LABEL_134;
          }
          if ( v33 == 43 )
          {
            *(_BYTE *)(v17 + v16 + 69) = 45;
            v71 = 2;
            goto LABEL_134;
          }
        }
        v71 = 2;
        goto LABEL_134;
      }
      *(_WORD *)(v16 + 240) = -128;
      v40 = atof((const char *)(*(_DWORD *)(a1 + 56) + 69));
      if ( v40 > 1.0e25 || v40 < -1.0e25 )
        v40 = 9.899999762399947e24;
      *(float *)&v74 = v40;
      *a4 = sub_10040790(v74, *(_WORD *)(a2 + 8));
      sub_10032AF0(a2, a4, a1, (int)a3);
      return 3;
    case 0x8022:
    case 0x8078:
      if ( !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
      {
        sub_10032AF0(a2, a4, a1, (int)a3);
        return v71;
      }
      sub_10032A30((int)a3, a4, a1, a2, v72);
      return 1;
    default:
      return v71;
  }
}
// 10789604: using guessed type int dword_10789604[];

//----- (10033420) --------------------------------------------------------
int __usercall sub_10033420@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int8 a3)
{
  unsigned __int8 v3; // bl@1
  int v4; // edi@1
  int v5; // esi@1

  v3 = 0;
  v4 = a1;
  v5 = a2;
  if ( a3 )
  {
    do
    {
      sub_1001EC10(
        v5 + 392,
        v3,
        v3,
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) - 2 * v3,
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) - 2 * v3,
        0);
      ++v3;
    }
    while ( v3 < a3 );
  }
  *(_WORD *)(v5 + 428) = word_1065DED0[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 430) = word_1065DED0[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 440) = word_1065DED0[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 442) = word_1065DED0[*(_BYTE *)(v4 + 4) & 0x1F];
  return sub_1001EC10(
           v5 + 392,
           a3,
           a3,
           *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) - 2 * a3,
           *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) - 2 * a3,
           1);
}
// 1065DED0: using guessed type __int16 word_1065DED0[];

//----- (10033500) --------------------------------------------------------
char __cdecl sub_10033500(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1
  __int16 v6; // bx@5
  int v7; // ecx@5
  int v8; // eax@8
  signed int v9; // ebp@8
  int v10; // eax@10
  int v11; // eax@15
  int v12; // eax@15
  int v13; // eax@15
  int v14; // eax@17
  char v15; // al@19
  bool v16; // zf@19
  int v17; // eax@23
  int v18; // eax@28
  int v19; // esi@28

  result = 1;
  if ( *a5 == 32802 || *a5 == 32888 )
  {
    if ( *(_DWORD *)(a1 + 64) == 9 )
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 248) = 1;
    v6 = word_1065DED0[(unsigned __int8)sub_100397E0(*(_BYTE *)(a2 + 4) & 0x1F)];
    v7 = *(_BYTE *)(a2 + 4) & 0xE0;
    if ( !(*(_BYTE *)(a2 + 4) & 0xE0) )
    {
      v17 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 428) = v6;
      *(_WORD *)(a1 + 430) = v6;
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      if ( !*(_BYTE *)(v17 + 25)
        && (*(_WORD *)(v17 + 40) || *(_WORD *)(v17 + 42) || *(_WORD *)(v17 + 44) || *(_WORD *)(v17 + 46)) )
      {
        sub_1001EC10(a1 + 392, 0, 0, *(_WORD *)(v17 + 32), *(_WORD *)(v17 + 42), 1);
        sub_1001EC10(
          a1 + 392,
          0,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 42),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 40),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 46),
          1);
        v18 = *(_DWORD *)(a1 + 56);
        sub_1001EC10(
          a1 + 392,
          *(_WORD *)(v18 + 44) + *(_WORD *)(v18 + 40),
          *(_WORD *)(v18 + 42),
          *(_WORD *)(v18 + 32) - *(_WORD *)(v18 + 40) - *(_WORD *)(v18 + 44),
          *(_WORD *)(v18 + 46),
          1);
        v19 = *(_DWORD *)(a1 + 56);
        sub_1001EC10(
          a1 + 392,
          0,
          *(_WORD *)(v19 + 46) + *(_WORD *)(v19 + 42),
          *(_WORD *)(v19 + 32),
          *(_WORD *)(v19 + 34) - *(_WORD *)(v19 + 42) - *(_WORD *)(v19 + 46),
          1);
        return 2;
      }
      sub_1001EC10(a1 + 392, 0, 0, *(_WORD *)(v17 + 32), *(_WORD *)(v17 + 34), 1);
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 25) = 0;
      return 2;
    }
    if ( v7 == 32 )
    {
      *(_WORD *)(a1 + 428) = word_1065DED0[(unsigned __int8)sub_100397E0(15)];
      *(_WORD *)(a1 + 430) = word_1065DED0[(unsigned __int8)sub_100397E0(15)];
      *(_WORD *)(a1 + 440) = word_1065DED0[(unsigned __int8)sub_100397E0(15)];
      *(_WORD *)(a1 + 442) = word_1065DED0[(unsigned __int8)sub_100397E0(15)];
      sub_10033420(a2, a1, 2u);
      return 2;
    }
    if ( v7 != 96 )
    {
      *(_WORD *)(a1 + 428) = word_1065DED0[1];
      *(_WORD *)(a1 + 430) = word_1065DED0[1];
      *(_WORD *)(a1 + 440) = word_1065DED0[1];
      v8 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 442) = word_1065DED0[1];
      sub_1001EC10(a1 + 392, 0, 0, *(_WORD *)(v8 + 32), *(_WORD *)(v8 + 34), 1);
      *(_WORD *)(a1 + 428) = word_1065DED0[15];
      *(_WORD *)(a1 + 430) = word_1065DED0[14];
      sub_1001EC10(a1 + 392, 0, 3, *(_WORD *)(*(_DWORD *)(a1 + 56) + 32), *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 6, 2);
      *(_WORD *)(a1 + 428) = word_1065DED0[13];
      *(_WORD *)(a1 + 430) = word_1065DED0[1];
      sub_1001EC10(
        a1 + 392,
        1,
        4,
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) - 2,
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 8,
        2);
      *(_WORD *)(a1 + 428) = word_1065DED0[14];
      *(_WORD *)(a1 + 430) = word_1065DED0[12];
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      v9 = 2;
      do
      {
        sub_1001EC10(
          a1 + 392,
          v9,
          v9 + 3,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) - 2 * v9,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 2 * (v9 + 3),
          2);
        ++v9;
      }
      while ( v9 < 6 );
      v10 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      if ( !*(_BYTE *)(v10 + 25)
        && (*(_WORD *)(v10 + 40) || *(_WORD *)(v10 + 42) || *(_WORD *)(v10 + 44) || *(_WORD *)(v10 + 46)) )
      {
        sub_1001EC10(a1 + 392, 6, 9, *(_WORD *)(v10 + 32) - 12, *(_WORD *)(v10 + 34) - 18, 2);
        v11 = *(_DWORD *)(a1 + 56);
        *(_WORD *)(a1 + 428) = v6;
        *(_WORD *)(a1 + 430) = v6;
        sub_1001EC10(a1 + 392, 6, 9, *(_WORD *)(v11 + 32) - 12, *(_WORD *)(v11 + 42) - 9, 1);
        sub_1001EC10(
          a1 + 392,
          6,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 42),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 40) - 6,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 46),
          1);
        v12 = *(_DWORD *)(a1 + 56);
        sub_1001EC10(
          a1 + 392,
          *(_WORD *)(v12 + 44) + *(_WORD *)(v12 + 40),
          *(_WORD *)(v12 + 42),
          *(_WORD *)(v12 + 32) - *(_WORD *)(v12 + 40) - *(_WORD *)(v12 + 44) - 6,
          *(_WORD *)(v12 + 46),
          1);
        v13 = *(_DWORD *)(a1 + 56);
        sub_1001EC10(
          a1 + 392,
          6,
          *(_WORD *)(v13 + 46) + *(_WORD *)(v13 + 42),
          *(_WORD *)(v13 + 32) - 12,
          *(_WORD *)(v13 + 34) - *(_WORD *)(v13 + 42) - *(_WORD *)(v13 + 46) - 9,
          1);
      }
      else
      {
        sub_1001EC10(a1 + 392, 6, 9, *(_WORD *)(v10 + 32) - 12, *(_WORD *)(v10 + 34) - 18, 3);
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 25) = 0;
      }
      v14 = *(_DWORD *)(a1 + 56);
      if ( *(_BYTE *)(v14 + 247) )
      {
        *(_WORD *)(a1 + 428) = word_1065DED0[15];
        *(_WORD *)(a1 + 430) = word_1065DED0[15];
        *(_WORD *)(a1 + 440) = word_1065DED0[1];
        *(_WORD *)(a1 + 442) = word_1065DED0[1];
        sub_1001EC10(a1 + 392, 10, 13, *(_WORD *)(v14 + 32) - 20, *(_WORD *)(v14 + 34) - 26, 3);
        return 2;
      }
      return 2;
    }
    *(_WORD *)(a1 + 428) = word_1065DED0[(unsigned __int8)sub_100397E0(15)];
    *(_WORD *)(a1 + 430) = word_1065DED0[(unsigned __int8)sub_100397E0(15)];
    *(_WORD *)(a1 + 440) = word_1065DED0[(unsigned __int8)sub_100397E0(15)];
    v15 = sub_100397E0(15);
    v16 = (*(_BYTE *)(a1 + 22) & 0x1E) == 0;
    *(_WORD *)(a1 + 442) = word_1065DED0[(unsigned __int8)v15];
    if ( v16 )
    {
      sub_10033420(a2, a1, 2u);
      result = 2;
    }
    else
    {
      sub_10033420(a2, a1, 5u);
      result = 2;
    }
  }
  return result;
}
// 1065DED0: using guessed type __int16 word_1065DED0[];

//----- (10033AB0) --------------------------------------------------------
unsigned int __usercall sub_10033AB0@<eax>(int a1@<ebx>, int a2@<esi>, unsigned __int16 *a3)
{
  int v3; // edi@1
  int v4; // ST38_4@1
  int v5; // eax@1
  __int16 v6; // cx@1
  unsigned int result; // eax@1
  char v8; // [sp+Ch] [bp-204h]@1

  v3 = BMP_get_bm_def(*a3);
  v4 = *(_DWORD *)(a2 + 460);
  v5 = sub_10030500(*a3, *(_BYTE *)(a2 + 3), (int)&v8);
  v6 = *(_WORD *)(a2 + 432);
  *(_DWORD *)(a2 + 460) = v5;
  result = sub_1001D4A0(
             a2 + 392,
             v3,
             0,
             0,
             *(_WORD *)a1 + *(_WORD *)(a2 + 434),
             *(_WORD *)(a1 + 2) + v6,
             *(_WORD *)(v3 + 6),
             *(_WORD *)(v3 + 4));
  *(_DWORD *)(a2 + 460) = v4;
  return result;
}
// 100820C4: using guessed type int __cdecl BMP_get_bm_def(_DWORD);

//----- (10033B60) --------------------------------------------------------
char __cdecl sub_10033B60(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char result; // al@1
  int v6; // eax@8
  __int16 v7; // dx@8
  __int16 v8; // si@8

  result = 1;
  if ( *a5 == 32802 )
    goto LABEL_11;
  if ( *a5 == 32832 )
  {
    v6 = BMP_get_bm_def(*a4);
    v7 = *(_WORD *)(v6 + 6);
    v8 = *(_WORD *)(v6 + 4);
    *(_WORD *)(a1 + 276) = *(_WORD *)a3;
    *(_WORD *)(a1 + 278) = *(_WORD *)(a3 + 2);
    *(_WORD *)(a1 + 280) = v7 + *(_WORD *)a3 - 1;
    *(_WORD *)(a1 + 282) = v8 + *(_WORD *)(a3 + 2) - 1;
    return 2;
  }
  if ( *a5 == 32888 )
  {
LABEL_11:
    if ( *a4 != -1 )
      sub_10033AB0(a3, a1, a4);
    result = 2;
  }
  return result;
}
// 100820C4: using guessed type int __cdecl BMP_get_bm_def(_DWORD);

//----- (10033C00) --------------------------------------------------------
char __usercall sub_10033C00@<al>(int ebx0@<ebx>, int a1, int a2, int a3, int *a4, _WORD *a5)
{
  char result; // al@4
  void *v7; // eax@7
  int v8; // edi@7
  float v9; // ST58_4@7
  double v10; // st7@7
  double v11; // st7@7
  double v12; // st7@7
  double v13; // st7@7
  double v14; // st7@7
  int v15; // edi@7
  unsigned int v16; // esi@7
  float v17; // ST58_4@14
  int v18; // ebx@14
  unsigned int v19; // esi@14
  float v20; // ST58_4@16
  float v21; // ST40_4@16
  float v22; // ST58_4@16
  float v23; // ST58_4@16
  float v24; // ST40_4@16
  float v25; // ST58_4@16
  float v26; // ST58_4@16
  float v27; // ST58_4@16
  float v28; // ST40_4@16
  float v29; // ST58_4@16
  float v30; // ST58_4@16
  float v31; // ST40_4@16
  float v32; // ST58_4@16
  float v33; // ST3C_4@16
  float v34; // ST58_4@16
  float v35; // ST58_4@16
  float v36; // ST40_4@16
  float v37; // ST58_4@16
  float v38; // ST58_4@16
  float v39; // ST40_4@16
  float v40; // ST58_4@16
  float v41; // ST58_4@16
  float v42; // ST40_4@16
  float v43; // ST58_4@16
  float v44; // ST58_4@16
  float v45; // ST40_4@16
  float v46; // ST58_4@16
  float v47; // ST3C_4@16
  float v48; // ST58_4@16
  float v49; // ST58_4@16
  float v50; // ST40_4@16
  float v51; // ST58_4@16
  float v52; // ST58_4@16
  float v53; // ST40_4@16
  float v54; // ST58_4@16
  float v55; // ST58_4@16
  float v56; // ST40_4@16
  float v57; // ST58_4@16
  float v58; // ST58_4@16
  float v59; // ST40_4@16
  float v60; // ST58_4@16
  unsigned int v61; // esi@16
  float v62; // ST5C_4@18
  float v63; // ST44_4@18
  float v64; // ST5C_4@18
  float v65; // ST5C_4@18
  float v66; // ST44_4@18
  float v67; // ST5C_4@18
  float v68; // ST5C_4@18
  float v69; // ST5C_4@18
  float v70; // ST44_4@18
  float v71; // ST5C_4@18
  float v72; // ST5C_4@18
  float v73; // ST44_4@18
  float v74; // ST5C_4@18
  float v75; // ST40_4@18
  float v76; // ST60_4@18
  float v77; // ST60_4@18
  float v78; // ST48_4@18
  float v79; // ST60_4@18
  float v80; // ST60_4@18
  float v81; // ST48_4@18
  float v82; // ST60_4@18
  float v83; // ST60_4@18
  float v84; // ST48_4@18
  float v85; // ST60_4@18
  float v86; // ST60_4@18
  float v87; // ST48_4@18
  float v88; // ST60_4@18
  float v89; // ST44_4@18
  float v90; // ST60_4@18
  float v91; // ST60_4@18
  float v92; // ST48_4@18
  float v93; // ST60_4@18
  float v94; // ST60_4@18
  float v95; // ST48_4@18
  float v96; // ST60_4@18
  float v97; // ST60_4@18
  float v98; // ST48_4@18
  float v99; // ST60_4@18
  float v100; // ST60_4@18
  float v101; // ST60_4@18
  double v102; // st7@18
  char *v103; // eax@19
  char v104; // cl@20
  float v105; // ST5C_4@22
  float v106; // ST60_4@22
  float v107; // ST58_4@22
  signed int v108; // ST58_4@22
  float v109; // ST58_4@22
  signed int v110; // eax@25
  float v111; // ST48_4@26
  float v112; // ST44_4@26
  float v113; // ST60_4@26
  float v114; // ST60_4@26
  float v115; // ST44_4@27
  float v116; // [sp+10h] [bp-88h]@0
  float v117; // [sp+14h] [bp-84h]@18
  int v118; // [sp+18h] [bp-80h]@0
  char v119; // [sp+23h] [bp-75h]@0
  float v120; // [sp+28h] [bp-70h]@14
  float v121; // [sp+2Ch] [bp-6Ch]@14
  int v122; // [sp+30h] [bp-68h]@7
  float v123; // [sp+34h] [bp-64h]@7
  int v124; // [sp+38h] [bp-60h]@7
  float v125; // [sp+3Ch] [bp-5Ch]@16
  float v126; // [sp+40h] [bp-58h]@7
  float v127; // [sp+44h] [bp-54h]@7
  float v128; // [sp+48h] [bp-50h]@7
  float v129; // [sp+4Ch] [bp-4Ch]@7
  float v130; // [sp+50h] [bp-48h]@7
  float v131; // [sp+54h] [bp-44h]@16
  float v132; // [sp+58h] [bp-40h]@7
  float v133; // [sp+5Ch] [bp-3Ch]@16
  float v134; // [sp+60h] [bp-38h]@7
  float v135; // [sp+64h] [bp-34h]@7
  float v136; // [sp+68h] [bp-30h]@7
  float v137; // [sp+6Ch] [bp-2Ch]@7
  float v138; // [sp+70h] [bp-28h]@7
  float v139; // [sp+74h] [bp-24h]@16
  float v140; // [sp+78h] [bp-20h]@7
  float v141; // [sp+7Ch] [bp-1Ch]@16
  float v142; // [sp+80h] [bp-18h]@7
  float v143; // [sp+84h] [bp-14h]@7
  float v144; // [sp+88h] [bp-10h]@7
  float v145; // [sp+8Ch] [bp-Ch]@16
  float v146; // [sp+90h] [bp-8h]@7
  float v147; // [sp+94h] [bp-4h]@16
  float vars0; // [sp+98h] [bp+0h]@18

  j_gdi_pvg_push_attrib(0x2000);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  if ( *a5 != 32802 )
  {
    if ( *a5 == 32833 )
    {
      if ( *(_BYTE *)(a2 + 20) && a4 )
      {
        v7 = (void *)sub_10004F90(a1, 96);
        *a4 = (int)v7;
        memset(v7, 0, 0x60u);
        v8 = *a4;
        v122 = *(int *)(a2 + 12);
        v123 = *(float *)(a2 + 8);
        sub_10082080((int)&v122, (int)&v122);
        v9 = *(float *)(a2 + 16) * 0.5;
        sub_10082020(v9, (int)&v122, (int)&v122);
        sub_10082060((int)&v122, (int)&v140);
        v10 = *(float *)(a2 + 24) * 0.5;
        v142 = *(float *)(a2 + 8) * v10 + *(float *)&v122;
        v143 = v10 * *(float *)(a2 + 12) + v123;
        sub_10082040((int)&v140, (int)&v122, (int)&v146);
        sub_10082040((int)&v142, (int)&v122, (int)&v144);
        sub_10082060((int)&v142, (int)&v124);
        sub_10082060((int)&v124, (int)&v126);
        v11 = 1.0 - *(float *)(a2 + 24);
        v126 = *(float *)(a2 + 8) * v11 + v126;
        v127 = v11 * *(float *)(a2 + 12) + v127;
        sub_10082060((int)&v144, (int)&v130);
        sub_10082060((int)&v130, (int)&v128);
        v12 = 1.0 - *(float *)(a2 + 24);
        v128 = *(float *)(a2 + 8) * v12 + v128;
        v129 = v12 * *(float *)(a2 + 12) + v129;
        sub_10082060((int)&v126, (int)&v132);
        sub_10082060((int)&v132, (int)&v134);
        v13 = *(float *)(a2 + 24) * 0.5;
        v134 = *(float *)(a2 + 8) * v13 + v134;
        v135 = v13 * *(float *)(a2 + 12) + v135;
        sub_10082060((int)&v128, (int)&v138);
        sub_10082060((int)&v138, (int)&v136);
        v14 = *(float *)(a2 + 24) * 0.5;
        v15 = v8 + 64;
        v136 = *(float *)(a2 + 8) * v14 + v136;
        v16 = 0;
        v137 = v14 * *(float *)(a2 + 12) + v137;
        do
        {
          sub_10082060((int)&v140 + v16, v15 - 64);
          sub_10082060((int)&v124 + v16, v15 - 32);
          sub_10082060((int)&v132 + v16, v15);
          v16 += 8;
          v15 += 8;
        }
        while ( v16 < 0x20 );
        j_gdi_pvg_pop_attrib();
        result = 2;
      }
      else
      {
        j_gdi_pvg_pop_attrib();
        result = v119;
      }
      return result;
    }
    if ( *a5 != 32888 )
    {
      j_gdi_pvg_pop_attrib();
      return 1;
    }
  }
  if ( *(_BYTE *)(a2 + 20) && *(float *)(a2 + 16) >= 2.0 && a4 && (ebx0 = *a4) != 0 )
  {
    v120 = (double)*(_WORD *)a3;
    v121 = (double)*(_WORD *)(a3 + 2);
    v122 = *(int *)(a2 + 12);
    v123 = *(float *)(a2 + 8);
    sub_10082080((int)&v122, (int)&v122);
    v17 = *(float *)(a2 + 16) * 0.5;
    sub_10082020(v17, (int)&v122, (int)&v122);
    v18 = ebx0 + 64;
    v19 = 0;
    do
    {
      sub_10082060(v18 - 64, (int)&v140 + v19);
      sub_10082060(v18 - 32, (int)&v124 + v19);
      sub_10082060(v18, (int)&v132 + v19);
      v19 += 8;
      v18 += 8;
    }
    while ( v19 < 0x20 );
    j_gdi_pvg_begin(72);
    sub_10069AB0(1.0, 1.0, 1.0, 0.0);
    v20 = v141 + v121;
    v21 = v20;
    v22 = v140 + v120;
    sub_10069EF0(v22, v21);
    v23 = v147 + v121;
    v24 = v23;
    v25 = v146 + v120;
    sub_10069EF0(v25, v24);
    v26 = (double)*(_BYTE *)(a2 + 7) * 0.300000011920929 / 255.0;
    sub_10069AB0(1.0, 1.0, 1.0, v26);
    v27 = v145 + v121;
    v28 = v27;
    v29 = v144 + v120;
    sub_10069EF0(v29, v28);
    v30 = v121 + v143;
    v31 = v30;
    v32 = v120 + v142;
    sub_10069EF0(v32, v31);
    j_gdi_pvg_end(LODWORD(v33));
    v34 = (double)*(_BYTE *)(a2 + 7) * 0.300000011920929 / 255.0;
    sub_10069AB0(1.0, 1.0, 1.0, v34);
    j_gdi_pvg_begin(72);
    v35 = v125 + v121;
    v36 = v35;
    v37 = *(float *)&v124 + v120;
    sub_10069EF0(v37, v36);
    v38 = v131 + v121;
    v39 = v38;
    v40 = v130 + v120;
    sub_10069EF0(v40, v39);
    v41 = v121 + v129;
    v42 = v41;
    v43 = v120 + v128;
    sub_10069EF0(v43, v42);
    v44 = v121 + v127;
    v45 = v44;
    v46 = v120 + v126;
    sub_10069EF0(v46, v45);
    j_gdi_pvg_end(LODWORD(v47));
    j_gdi_pvg_begin(72);
    v48 = (double)*(_BYTE *)(a2 + 7) * 0.300000011920929 / 255.0;
    sub_10069AB0(1.0, 1.0, 1.0, v48);
    v49 = v133 + v121;
    v50 = v49;
    v51 = v132 + v120;
    sub_10069EF0(v51, v50);
    v52 = v139 + v121;
    v53 = v52;
    v54 = v138 + v120;
    sub_10069EF0(v54, v53);
    sub_10069AB0(1.0, 1.0, 1.0, 0.0);
    v55 = v121 + v137;
    v56 = v55;
    v57 = v120 + v136;
    sub_10069EF0(v57, v56);
    v58 = v121 + v135;
    v59 = v58;
    v60 = v120 + v134;
    sub_10069EF0(v60, v59);
    j_gdi_pvg_end(LODWORD(v116));
    v61 = 0;
    do
    {
      sub_10082040((int)&v140 + v61, (int)&v122, (int)&v140 + v61);
      sub_10082040((int)&v124 + v61, (int)&v122, (int)&v124 + v61);
      sub_10082040((int)&v132 + v61, (int)&v122, (int)&v132 + v61);
      v61 += 8;
    }
    while ( v61 < 0x20 );
    j_gdi_pvg_begin(72);
    sub_10069AB0(0.0, 0.0, 0.0, 0.0);
    v62 = v142 + *(float *)&v122;
    v63 = v62;
    v64 = v141 + v121;
    sub_10069EF0(v64, v63);
    v65 = vars0 + *(float *)&v122;
    v66 = v65;
    v67 = v147 + v121;
    sub_10069EF0(v67, v66);
    v68 = (double)*(_BYTE *)(a2 + 7) / 255.0;
    sub_10069AB0(0.0, 0.0, 0.0, v68);
    v69 = v146 + *(float *)&v122;
    v70 = v69;
    v71 = v145 + v121;
    sub_10069EF0(v71, v70);
    v72 = *(float *)&v122 + v144;
    v73 = v72;
    v74 = v121 + v143;
    sub_10069EF0(v74, v73);
    j_gdi_pvg_end(LODWORD(v75));
    v76 = (double)*(_BYTE *)(a2 + 7) / 255.0;
    sub_10069AB0(0.0, 0.0, 0.0, v76);
    j_gdi_pvg_begin(72);
    v77 = v127 + v123;
    v78 = v77;
    v79 = v126 + *(float *)&v122;
    sub_10069EF0(v79, v78);
    v80 = v133 + v123;
    v81 = v80;
    v82 = v132 + *(float *)&v122;
    sub_10069EF0(v82, v81);
    v83 = v123 + v131;
    v84 = v83;
    v85 = *(float *)&v122 + v130;
    sub_10069EF0(v85, v84);
    v86 = v123 + v129;
    v87 = v86;
    v88 = *(float *)&v122 + v128;
    sub_10069EF0(v88, v87);
    j_gdi_pvg_end(LODWORD(v89));
    j_gdi_pvg_begin(72);
    v90 = (double)*(_BYTE *)(a2 + 7) / 255.0;
    sub_10069AB0(0.0, 0.0, 0.0, v90);
    v91 = v135 + v123;
    v92 = v91;
    v93 = v134 + *(float *)&v122;
    sub_10069EF0(v93, v92);
    v94 = v141 + v123;
    v95 = v94;
    v96 = v140 + *(float *)&v122;
    sub_10069EF0(v96, v95);
    sub_10069AB0(0.0, 0.0, 0.0, 0.0);
    v97 = v123 + v139;
    v98 = v97;
    v99 = *(float *)&v122 + v138;
    sub_10069EF0(v99, v98);
    v100 = v123 + v137;
    v117 = v100;
    v101 = *(float *)&v122 + v136;
    v102 = v101;
  }
  else
  {
    v103 = (char *)(a2 + 28);
    do
      v104 = *v103++;
    while ( v104 );
    if ( v103 != (char *)(a2 + 29) )
    {
      v105 = (double)*(_WORD *)a3;
      v106 = (double)*(_WORD *)(a3 + 2);
      v122 = *(int *)(a2 + 12);
      v123 = -*(float *)(a2 + 8);
      sub_10082080((int)&v122, (int)&v122);
      v107 = *(float *)(a2 + 16) * 0.5;
      sub_10082020(v107, (int)&v122, (int)&v122);
      v124 = v122;
      v125 = v123;
      v126 = *(float *)&v122 + *(float *)(a2 + 8);
      v127 = v123 + *(float *)(a2 + 12);
      sub_10082020(-2.0, (int)&v122, (int)&v122);
      v108 = *(_BYTE *)(a2 + 7);
      v130 = *(float *)&v124 + *(float *)&v122;
      v131 = v125 + v123;
      v128 = *(float *)&v122 + v126;
      v129 = v123 + v127;
      v109 = (double)v108 / 255.0;
      sub_10043B40(ebx0, v105, v106, *(_DWORD *)(a1 + 80), (int)&v124, a2 + 28, v109, 0);
      j_gdi_pvg_pop_attrib();
      return 2;
    }
    if ( *(_BYTE *)(a2 + 78) & 1 )
    {
      j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 4));
    }
    else
    {
      v110 = sub_10039810(*(_DWORD *)(a2 + 4));
      j_gdi_pvg_color_u32(v110);
    }
    sub_10069C80(*(float *)(a2 + 16));
    j_gdi_pvg_begin(64);
    v111 = (double)*(_WORD *)(a3 + 2);
    v112 = (double)*(_WORD *)a3;
    sub_10069EF0(v112, v111);
    v113 = *(float *)(a2 + 12) + (double)*(_WORD *)(a3 + 2);
    v117 = v113;
    v114 = *(float *)(a2 + 8) + (double)*(_WORD *)a3;
    v102 = v114;
  }
  v115 = v102;
  sub_10069EF0(v115, v117);
  j_gdi_pvg_end(v118);
  j_gdi_pvg_pop_attrib();
  return 2;
}
// 100699C0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10069A50: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10069B20: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10069BC0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10069BE0: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 10069D10: using guessed type int j_gdi_pvg_pop_attrib(void);
// 10069D30: using guessed type int __cdecl j_gdi_pvg_push_attrib(_DWORD);

//----- (100347F0) --------------------------------------------------------
char __usercall sub_100347F0@<al>(int a1@<edi>, int a2, int a3, int a4, int a5, _WORD *a6)
{
  int v7; // eax@4
  float v8; // ST38_4@5
  float v9; // ST38_4@5
  float v10; // ST08_4@5
  float v11; // ST24_4@5
  float v12; // ST38_4@5
  float v13; // ST20_4@5
  float v14; // ST38_4@5
  float v15; // ST08_4@5
  float v16; // ST28_4@5
  float v17; // ST2C_4@5
  float v18; // ST08_4@5
  float v19; // ST1C_4@5
  float v20; // ST30_4@5
  float v21; // ST08_4@5
  float v22; // ST24_4@5
  float v23; // ST20_4@5
  float v24; // ST08_4@5
  float v25; // ST30_4@5
  float v26; // ST2C_4@5
  float v27; // ST38_4@5
  float v28; // ST28_4@5
  float v29; // ST34_4@5
  float v30; // ST08_4@5
  float v31; // ST38_4@6
  float v32; // ST30_4@6
  float v33; // ST34_4@6
  float v34; // ST38_4@6
  float v35; // ST38_4@6
  float v36; // ST34_4@6
  float v37; // ST38_4@6
  double v38; // st7@6
  float v39; // ST08_4@8
  float v40; // [sp+4h] [bp-30h]@6
  int v41; // [sp+8h] [bp-2Ch]@4
  float v42; // [sp+10h] [bp-24h]@4
  float v43; // [sp+48h] [bp+14h]@4
  float v44; // [sp+48h] [bp+14h]@6

  if ( *a6 != 32802 && *a6 != 32888 )
    return 1;
  v41 = a1;
  v7 = *(_DWORD *)(a2 + 56);
  v42 = (double)*(_WORD *)(v7 + 34);
  v43 = (double)*(_WORD *)(v7 + 32);
  if ( !(*(_BYTE *)(a3 + 4) & 1) )
  {
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(*(_DWORD *)(a3 + 8));
    sub_10069EF0(0.0, 0.0);
    sub_10069EF0(v43, 0.0);
    sub_10069EF0(v43, v42);
    v40 = v42;
    v38 = 0.0;
    goto LABEL_8;
  }
  j_gdi_pvg_begin(72);
  j_gdi_pvg_color_u32(*(_DWORD *)(a3 + 8));
  sub_10069EF0(0.0, 0.0);
  sub_10069EF0(v43, 0.0);
  sub_10069EF0(v43, v42);
  sub_10069EF0(0.0, v42);
  j_gdi_pvg_color_u32(-16777216);
  sub_10069EF0(0.0, 0.0);
  sub_10069EF0(v43, 0.0);
  v8 = 0.0 + 3.0;
  sub_10069EF0(v43, v8);
  sub_10069EF0(0.0, v8);
  v9 = v42 - 3.0;
  sub_10069EF0(0.0, v9);
  sub_10069EF0(v43, v9);
  sub_10069EF0(v43, v42);
  sub_10069EF0(0.0, v42);
  j_gdi_pvg_end(LODWORD(v10));
  sub_10069C80(1.0);
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-1);
  v11 = v42 - 3.5;
  v12 = 0.0 + 0.5;
  sub_10069EF0(v12, v11);
  v13 = 0.0 + 3.5;
  sub_10069EF0(v12, v13);
  v14 = v43 - 0.0;
  sub_10069EF0(v14, v13);
  j_gdi_pvg_end(LODWORD(v15));
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-8355712);
  v16 = 0.0 + 1.5;
  sub_10069EF0(v16, v11);
  v17 = v43 - 0.5;
  sub_10069EF0(v17, v11);
  sub_10069EF0(v17, v13);
  j_gdi_pvg_end(LODWORD(v18));
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-4144960);
  v19 = v42 - 4.5;
  sub_10069EF0(v16, v19);
  v20 = 0.0 + 4.5;
  sub_10069EF0(v16, v20);
  sub_10069EF0(v17, v20);
  j_gdi_pvg_end(LODWORD(v21));
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-16777216);
  v22 = 0.0 + 2.5;
  sub_10069EF0(v22, v19);
  v23 = v43 - 1.5;
  sub_10069EF0(v23, v19);
  sub_10069EF0(v23, v20);
  j_gdi_pvg_end(LODWORD(v24));
  j_gdi_pvg_begin(73);
  j_gdi_pvg_color_u32(-14671840);
  sub_10069EF0(v22, v19);
  v25 = v42 - 9.5;
  v26 = 0.0 + 7.5;
  sub_10069EF0(v26, v25);
  sub_10069EF0(v23, v19);
  v27 = v43 - 6.5;
  sub_10069EF0(v27, v25);
  v28 = 0.0 + 5.5;
  sub_10069EF0(v23, v28);
  v29 = 0.0 + 10.5;
  sub_10069EF0(v27, v29);
  j_gdi_pvg_end(LODWORD(v30));
  j_gdi_pvg_begin(73);
  j_gdi_pvg_color_u32(-8355712);
  sub_10069EF0(v22, v19);
  sub_10069EF0(v26, v25);
  sub_10069EF0(v22, v28);
  sub_10069EF0(v26, v29);
  sub_10069EF0(v23, v28);
  sub_10069EF0(v27, v29);
  j_gdi_pvg_end(a1);
  if ( *(_BYTE *)(*(_DWORD *)(a2 + 56) + 247) )
  {
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(-1);
    v31 = 0.0 + 14.0;
    v32 = 0.0 + 11.0;
    sub_10069EF0(v32, v31);
    v33 = v43 - 11.0;
    sub_10069EF0(v33, v31);
    v34 = v42 - 14.0;
    sub_10069EF0(v33, v34);
    sub_10069EF0(v32, v34);
    j_gdi_pvg_color_u32(*(_DWORD *)(a3 + 8));
    v35 = 0.0 + 15.0;
    v36 = 0.0 + 12.0;
    sub_10069EF0(v36, v35);
    v44 = v43 - 12.0;
    sub_10069EF0(v44, v35);
    v37 = v42 - 15.0;
    sub_10069EF0(v44, v37);
    v40 = v37;
    v38 = v36;
LABEL_8:
    v39 = v38;
    sub_10069EF0(v39, v40);
    j_gdi_pvg_end(v41);
  }
  return 2;
}
// 100347F0: could not find valid save-restore pair for edi
// 100699C0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10069B20: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10069BE0: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (10034E30) --------------------------------------------------------
void __cdecl sub_10034E30(int a1, int (__cdecl *a2)(int))
{
  char v2; // bl@2

  if ( !*(_DWORD *)(a1 + 72) )
  {
    v2 = sub_10005070(*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 32) + 8));
    if ( sub_10005070(a2) != v2 )
      *(_DWORD *)(a1 + 72) = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 8);
  }
}

//----- (10034E70) --------------------------------------------------------
void sub_10034E70()
{
  dword_107896C8 = 0;
}
// 107896C8: using guessed type int dword_107896C8;

//----- (10034E80) --------------------------------------------------------
unsigned int __usercall sub_10034E80@<eax>(unsigned int result@<eax>)
{
  int *v1; // ecx@2
  unsigned int v2; // ecx@3

  if ( !dword_107896C8 )
  {
    dword_107896C8 = *(_DWORD *)(result + 32);
    v1 = *(int **)(result + 32);
    if ( v1 )
    {
      v2 = *v1;
      *(_DWORD *)(result + 32) = v2;
      if ( !v2 || *(_DWORD *)(result + 48) < v2 )
        *(_DWORD *)(result + 48) = v2;
      result = v2;
      if ( v2 )
        *(_DWORD *)(v2 + 4) = 0;
    }
  }
  return result;
}
// 107896C8: using guessed type int dword_107896C8;

//----- (10034EC0) --------------------------------------------------------
int __usercall sub_10034EC0@<eax>(int result@<eax>)
{
  if ( dword_107896C8 )
  {
    *(_DWORD *)(*(_DWORD *)(result + 32) + 4) = dword_107896C8;
    *(_DWORD *)dword_107896C8 = *(_DWORD *)(result + 32);
    *(_DWORD *)(result + 32) = dword_107896C8;
    dword_107896C8 = 0;
  }
  return result;
}
// 107896C8: using guessed type int dword_107896C8;

//----- (10034EF0) --------------------------------------------------------
void __cdecl sub_10034EF0(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4, int a5)
{
  void *v5; // ecx@0
  int v6; // ebx@1
  int v7; // esi@1
  int v8; // edi@1
  int v9; // eax@2
  char v10; // bl@13
  int v11; // eax@22
  int v12; // edx@26
  int v13; // ecx@26
  int v14; // edx@26
  int v15; // ecx@26
  int v16; // edx@26
  int v17; // eax@29
  unsigned int v18; // eax@32
  unsigned int v19; // ebx@34
  int v20; // eax@46
  int v21; // eax@59
  bool v22; // al@63
  int v23; // edx@63
  int (__cdecl *v24)(int); // [sp+10h] [bp-D8h]@1
  unsigned int v25; // [sp+14h] [bp-D4h]@32
  __int16 i; // [sp+18h] [bp-D0h]@25
  unsigned int v27; // [sp+1Ch] [bp-CCh]@25
  int v28; // [sp+20h] [bp-C8h]@25
  int v29; // [sp+24h] [bp-C4h]@25
  int v30; // [sp+28h] [bp-C0h]@26
  int v31; // [sp+2Ch] [bp-BCh]@26
  int v32; // [sp+30h] [bp-B8h]@26
  int v33; // [sp+34h] [bp-B4h]@26
  int v34; // [sp+38h] [bp-B0h]@26
  int v35; // [sp+3Ch] [bp-ACh]@26

  v6 = (int)a3;
  v7 = *(_DWORD *)(a1 + 48);
  v8 = 0;
  v24 = a3;
  if ( v7 )
  {
    v9 = a2;
    switch ( a2 )
    {
      case -1:
        sub_10034EC0(a1);
        goto LABEL_4;
      case -5:
LABEL_4:
        v8 = *(_DWORD *)(a1 + 32);
        v7 = 0;
        goto LABEL_20;
      case -2:
        v8 = 0;
        do
        {
          if ( sub_100050B0(*(int (__cdecl **)(int))(v7 + 8)) != -1 )
            break;
          v8 = v7;
          v7 = *(_DWORD *)(v7 + 4);
        }
        while ( v7 );
        goto LABEL_20;
      case -3:
        do
        {
          if ( sub_100050B0(*(int (__cdecl **)(int))(v7 + 8)) != -1 )
            break;
          v7 = *(_DWORD *)(v7 + 4);
        }
        while ( v7 );
        v8 = v7;
        if ( v7 )
          v7 = *(_DWORD *)(v7 + 4);
        goto LABEL_20;
      case -6:
        v8 = *(_DWORD *)(a1 + 48);
        v10 = sub_100050B0(a3);
        if ( !v7 )
          goto LABEL_16;
        break;
      case -7:
        if ( (unsigned __int8)sub_10036B70(v5) )
        {
          sub_10034E80(a1);
          v8 = *(_DWORD *)(a1 + 32);
          v7 = 0;
        }
        else
        {
          sub_10034E30(a1, a3);
          v8 = *(_DWORD *)(a1 + 32);
          v7 = 0;
        }
        goto LABEL_20;
      case -8:
        if ( (unsigned __int8)sub_10036B70(v5) )
        {
          sub_10034EC0(a1);
LABEL_45:
          v7 = *(_DWORD *)(a1 + 32);
          v8 = *(_DWORD *)v7;
        }
        else
        {
          v20 = *(_DWORD *)(a1 + 72);
          if ( v20 )
          {
            v8 = *(_DWORD *)(a1 + 32);
            v7 = 0;
            v24 = *(int (__cdecl **)(int))(a1 + 72);
            *(_DWORD *)(a1 + 72) = 0;
            v6 = v20;
          }
        }
        goto LABEL_20;
      case -4:
        goto LABEL_45;
      default:
        if ( a2 > 0 )
        {
          do
          {
            if ( !v7 )
              break;
            --v9;
            v8 = v7;
            v7 = *(_DWORD *)(v7 + 4);
          }
          while ( v9 > 0 );
        }
        goto LABEL_20;
    }
    do
    {
      if ( sub_100050B0(*(int (__cdecl **)(int))(v8 + 8)) == v10 )
      {
        if ( *(int (__cdecl **)(int))(v8 + 8) == a3 )
        {
          v8 = *(_DWORD *)v8;
          v24 = 0;
        }
        v7 = *(_DWORD *)(v8 + 4);
        goto LABEL_19;
      }
      v8 = *(_DWORD *)(v8 + 4);
    }
    while ( v8 );
LABEL_16:
    v7 = *(_DWORD *)(a1 + 48);
    v8 = 0;
    if ( v7 )
    {
      while ( sub_100050B0(*(int (__cdecl **)(int))(v7 + 8)) == -1 )
      {
        v7 = *(_DWORD *)(v7 + 4);
        if ( !v7 )
          goto LABEL_19;
      }
      v8 = *(_DWORD *)v7;
    }
LABEL_19:
    v6 = (int)v24;
  }
LABEL_20:
  if ( v6 )
  {
    if ( a4 || (v11 = v7) == 0 )
    {
LABEL_25:
      ++*(_BYTE *)(a1 + 4);
      i = -32703;
      v27 = 0;
      v28 = v6;
      LOBYTE(v29) = 0;
      if ( a5 )
      {
        v12 = *(_DWORD *)(a5 + 4);
        v30 = *(_DWORD *)a5;
        v13 = *(_DWORD *)(a5 + 8);
        v31 = v12;
        v14 = *(_DWORD *)(a5 + 12);
        v32 = v13;
        v15 = *(_DWORD *)(a5 + 16);
        v33 = v14;
        v16 = *(_DWORD *)(a5 + 20);
        v34 = v15;
        v35 = v16;
        LOBYTE(v29) = 1;
      }
      sub_10003E50(a1, (int)&i, 204);
    }
    else
    {
      while ( *(_DWORD *)(v11 + 8) != v6 )
      {
        v11 = *(_DWORD *)(v11 + 4);
        if ( !v11 )
          goto LABEL_25;
      }
      v7 = *(_DWORD *)(v11 + 4);
      v8 = v11;
      v24 = 0;
      v6 = 0;
    }
  }
  if ( v8 )
  {
    v17 = sub_10003CE0(a1, v6);
    if ( !v6 || !v17 || !sub_10002770(a1, v17) )
    {
      v18 = sub_10002840(a1, v7);
      v25 = v18;
      if ( v18 )
        *(_BYTE *)(v18 + 26) = 0;
      v19 = v7;
      if ( v7 )
      {
        while ( v19 >= v18 )
        {
          i = -32734;
          v27 = v19;
          sub_10003E50(a1, (int)&i, 204);
          v19 = *(_DWORD *)(v19 + 4);
          if ( !v19 )
            break;
          v18 = v25;
        }
      }
      v6 = (int)v24;
    }
  }
  if ( !v6 || v8 )
  {
    if ( v7 && v8 )
    {
      i = -32665;
      v27 = v7;
      v22 = sub_10002770(a1, *(_DWORD *)v7);
      v23 = *(_DWORD *)(a1 + 56);
      LOBYTE(v28) = v22;
      v29 = *(_DWORD *)(v8 + 8);
      *(_BYTE *)(v23 + 25) = v22;
      sub_10003E50(a1, (int)&i, 204);
    }
  }
  else
  {
    v21 = *(_DWORD *)(a1 + 48);
    if ( v21 )
    {
      i = -32695;
      v27 = v21;
      sub_10003E50(a1, (int)&i, 204);
    }
  }
  for ( i = -32744; v8; v8 = *(_DWORD *)v8 )
  {
    v27 = v8;
    sub_10003E50(a1, (int)&i, 204);
  }
}

//----- (100352A0) --------------------------------------------------------
void __cdecl sub_100352A0(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4)
{
  sub_10034EF0(a1, a2, a3, a4, 0);
}

//----- (100352C0) --------------------------------------------------------
__int16 __cdecl sub_100352C0(char a1)
{
  int v1; // eax@1
  __int16 result; // ax@2
  int v3; // esi@3
  char v4; // bl@4
  char v5; // al@4
  int v6; // eax@8
  char v7; // [sp+6h] [bp-16h]@8
  char v8; // [sp+7h] [bp-15h]@8
  int v9; // [sp+8h] [bp-14h]@1
  int v10; // [sp+Ch] [bp-10h]@1
  int v11; // [sp+10h] [bp-Ch]@1
  int v12; // [sp+14h] [bp-8h]@1

  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v1 = sub_1003B860(&a1, 1u, (int)&unk_100AA368, 4, 152, 176);
  if ( v1 == 176 )
  {
    v3 = sub_1003B860(&a1, 1u, (int)&unk_100AA1A8, 16, 24, 176);
    if ( v3 == 176 )
    {
      result = -1;
    }
    else
    {
      v4 = 0;
      sub_1003BB60(6, 1, 8, 0, (int)&v9, 16);
      v5 = *((_BYTE *)&v9 + dword_100AA1AC[4 * v3]);
      if ( v5 == 3 )
      {
        v4 = 1;
      }
      else if ( v5 == 8 )
      {
        v4 = 2;
      }
      v8 = 0;
      sub_1006A100(6446, &v7, 1, &v8);
      v6 = sub_1003B860(&a1, 1u, (int)&unk_100AA328, 16, 4, 176);
      if ( v7 != 1 || v6 == 176 )
        result = word_100AA1B0[(unsigned __int8)v4 + 8 * v3];
      else
        result = word_100AA330[(unsigned __int8)v4 + 8 * v6];
    }
  }
  else
  {
    result = word_100AA36A[2 * v1];
  }
  return result;
}
// 100AA1AC: using guessed type int dword_100AA1AC[];
// 100AA1B0: using guessed type __int16 word_100AA1B0[];
// 100AA330: using guessed type __int16 word_100AA330[];
// 100AA36A: using guessed type __int16 word_100AA36A[];

//----- (10035430) --------------------------------------------------------
void sub_10035430()
{
  dword_107896FC = -15;
}
// 107896FC: using guessed type int dword_107896FC;

//----- (10035440) --------------------------------------------------------
unsigned int __cdecl sub_10035440(const char *a1, int a2, signed int a3, int a4, int a5, _DWORD *a6)
{
  int v6; // eax@1
  int v7; // ecx@1
  int v8; // esi@2

  v6 = (a3 >> 24) + *(_WORD *)(a2 + 24) + ((a3 >> 16) & 0xFF) - *(_WORD *)(a2 + 26);
  v7 = 0;
  if ( v6 <= a4 )
  {
    v8 = v6 + a5;
    do
    {
      v6 += v8;
      ++v7;
    }
    while ( v6 <= a4 );
  }
  *a6 = v7;
  return strlen(a1) + 2 * (v7 - 1 <= 0 ? 0 : v7 - 1) + 1;
}

//----- (100354B0) --------------------------------------------------------
int __cdecl sub_100354B0(int a1, int a2, int a3, int a4, int a5, char a6, char *a7)
{
  char *v7; // eax@1
  char *v8; // esi@1
  char *v9; // edx@2
  char v10; // cl@3
  int v11; // ebx@7
  signed int v12; // edi@7
  signed int i; // edx@9
  int v14; // ebp@13
  int v15; // eax@13
  int v16; // ebp@13
  int v17; // edi@13
  char *v18; // eax@14
  char *v19; // ebp@14
  unsigned int v20; // eax@15
  int v21; // ebx@17
  int v22; // eax@17
  int v23; // edi@21
  int j; // ebp@21
  int v25; // ST14_4@22
  int v26; // ST0C_4@22
  char v27; // al@26
  int v28; // edi@29
  char v29; // al@32
  char v30; // al@40
  int v31; // edx@45
  int v32; // ecx@45
  int v33; // edi@55
  char *v34; // eax@58
  char v35; // dl@59
  int v36; // eax@61
  int v37; // edi@61
  int v38; // ecx@67
  char v39; // al@67
  char *v40; // edi@67
  char *v41; // eax@72
  int v42; // edx@72
  char v43; // cl@73
  _BYTE *v44; // ebp@74
  char *v45; // ST2C_4@78
  char v47; // [sp+13h] [bp-25h]@1
  int v48; // [sp+14h] [bp-24h]@14
  char *v49; // [sp+18h] [bp-20h]@26
  int v50; // [sp+1Ch] [bp-1Ch]@1
  signed int v51; // [sp+20h] [bp-18h]@7
  int v52; // [sp+24h] [bp-14h]@21
  int v53; // [sp+24h] [bp-14h]@26
  int v54; // [sp+28h] [bp-10h]@13
  int v55; // [sp+2Ch] [bp-Ch]@1
  signed int v56; // [sp+2Ch] [bp-Ch]@21
  int v57; // [sp+2Ch] [bp-Ch]@26
  int v58; // [sp+30h] [bp-8h]@29
  int v59; // [sp+34h] [bp-4h]@28

  v7 = (char *)a1;
  v8 = a7;
  v47 = 0;
  v55 = 0;
  v50 = 1;
  if ( a7 != (char *)a1 )
  {
    v9 = &a7[-a1];
    do
    {
      v10 = *v7;
      v7[(_DWORD)v9] = *v7;
      ++v7;
    }
    while ( v10 );
  }
  if ( a4 < 1 || a5 < 1 )
  {
    v47 = 1;
    v50 = 0;
    *v8 = 0;
  }
  v11 = a3;
  v12 = (((unsigned int)a3 >> 16) & 0x3F) - 1;
  v51 = v12;
  if ( v12 < 0 )
  {
    v12 = *(_WORD *)(a2 + 28);
    v51 = *(_WORD *)(a2 + 28);
  }
  for ( i = 0; i < (signed int)strlen(v8); ++i )
  {
    if ( v8[i] == 10 )
      ++v55;
  }
  LOWORD(a1) = 10;
  v14 = v12 + sub_1001C410(a2, &a1, a3);
  v15 = sub_1001C410(a2, v8, v11);
  v16 = v55 * v14;
  v17 = a5 * a4 - v16 - v15;
  v54 = a5 * a4 - v16 - v15;
  if ( v47 )
    return -1;
  while ( 1 )
  {
    v18 = strchr(v8, 10);
    v19 = v18;
    v48 = (int)v18;
    if ( v18 )
    {
      LOBYTE(a7) = 1;
      *v18 = 0;
    }
    else
    {
      LOBYTE(a7) = 0;
      v20 = strlen(v8);
      v19 = &v8[v20];
      v48 = (int)&v8[v20];
    }
    v21 = sub_1001C410(a2, v8, a3);
    v22 = a4;
    if ( v21 > a4 )
    {
      if ( v50 >= a5 )
        goto LABEL_79;
      v52 = 0;
      v23 = a4;
      v56 = strlen(v8) - 1;
      for ( j = v56 / 2; ; j = (v56 + j + 1) / 2 )
      {
        while ( 1 )
        {
          v25 = a3;
          LOBYTE(a1) = v8[j + 1];
          v26 = a2;
          v8[j + 1] = 0;
          v21 = sub_1001C410(v26, v8, v25);
          v8[j + 1] = a1;
          if ( v21 <= v23 )
            break;
          v56 = j;
          j = (v52 + j) / 2;
        }
        if ( v51 + v21 + sub_1001C410(a2, &a1, a3) > v23 )
          break;
        v52 = j + 1;
      }
      v57 = v23 - v21;
      v49 = &v8[j];
      v27 = v8[j + 1];
      v53 = j;
      if ( v27 == 32 )
        goto LABEL_67;
      if ( !v27 )
        goto LABEL_67;
      v59 = v54 - v57;
      if ( v54 - v57 <= 0 )
        goto LABEL_67;
      v58 = 0;
      v28 = j;
      if ( j >= 0 )
      {
        while ( 1 )
        {
          if ( !isalnum((unsigned __int8)v8[v28]) || v8[v28] == 45 )
          {
            v29 = v8[v28];
            if ( v29 != 39 && v29 != 40 && v29 != 41 && v29 != 34 )
            {
              if ( v28 <= 0 )
                break;
              if ( v8[v28 - 1] != 32 )
              {
                if ( !isdigit((unsigned __int8)v8[v28 + 1]) || !isdigit((unsigned __int8)v8[v28 - 1]) )
                  break;
                v30 = v8[v28];
                if ( (v30 != 32 || v8[v28 + 2] != 47) && v30 != 47 )
                  break;
              }
            }
          }
          if ( --v28 < 0 )
            goto LABEL_48;
        }
        v31 = a3;
        LOBYTE(a1) = v49[1];
        v32 = a2;
        v49[1] = 0;
        v58 = v51 + sub_1001C410(v32, &v8[v28 + 1], v31);
        v49[1] = a1;
        if ( v8[v28] == 32 && v28 > 0 )
          --v28;
      }
LABEL_48:
      if ( v28 == -1 || v28 == j || v58 > v59 )
      {
        if ( !isalpha((unsigned __int8)*v49) || !isalpha((unsigned __int8)v49[1]) || !a6 )
          goto LABEL_67;
        LOBYTE(a1) = 45;
        v33 = v51 + sub_1001C410(a2, &a1, a3);
        if ( v33 + v21 <= a4 )
        {
          if ( (_BYTE)a7 )
            *(_BYTE *)v48 = 10;
          v34 = v49 + 1;
          do
            v35 = *v34++;
          while ( v35 );
          memcpy(v49 + 2, v49 + 1, v34 - (v49 + 2) + 1);
          v21 += v33;
          *(_BYTE *)(v48++ + 1) = 0;
          v49[1] = 45;
          v53 = j + 1;
          goto LABEL_67;
        }
        LOBYTE(a1) = *v49;
        v36 = v51 + sub_1001C410(a2, &a1, a3);
        v37 = v21 + v33 - v36;
        if ( v37 > a4 || v59 < v36 )
        {
LABEL_67:
          v38 = v53;
          v54 -= v57;
          v39 = v8[v53 + 1];
          v40 = &v8[v53 + 1];
          if ( v39 )
          {
            if ( v39 == 32 )
              v38 = v53++ + 1;
            if ( (_BYTE)a7 )
              *(_BYTE *)v48 = 10;
            v40 = &v8[v38 + 1];
            v41 = &v8[v38 + 1];
            v42 = (int)&v8[v38 + 2];
            do
              v43 = *v41++;
            while ( v43 );
            memcpy(&v8[v53 + 2], v40, (size_t)&v41[-v42 + 1]);
            v44 = (_BYTE *)(v48 + 1);
            *v40 = 10;
            *(_BYTE *)(v48 + 1) = 0;
          }
          else
          {
            v44 = (_BYTE *)v48;
          }
          if ( (_BYTE)a7 )
          {
            LOBYTE(a7) = 0;
            *v44 = 10;
          }
          v22 = a4;
          v45 = v40;
          v17 = v54;
          v19 = v45;
          goto LABEL_79;
        }
        if ( (_BYTE)a7 )
          *(_BYTE *)v48 = 10;
        strcpy(v49 + 1, v49);
        *(_BYTE *)(v48++ + 1) = 0;
        *v49 = 45;
        v21 = v37;
      }
      else
      {
        v53 = v28;
        v21 -= v58;
      }
      v57 = a4 - v21;
      goto LABEL_67;
    }
    if ( !(_BYTE)a7 )
      return v50;
    v17 += v21 - a4;
    v54 = v17;
LABEL_79:
    if ( (_BYTE)a7 )
      *v19 = 10;
    if ( v50 >= a5 )
      break;
    if ( !*v19 )
      goto LABEL_85;
    ++v50;
    v8 = v19 + 1;
  }
  if ( *v19 )
  {
LABEL_86:
    *v19 = 0;
    return -1;
  }
LABEL_85:
  if ( v21 > v22 )
    goto LABEL_86;
  return v50;
}

//----- (10035A40) --------------------------------------------------------
int sub_10035A40()
{
  int result; // eax@2
  unsigned __int8 v1; // [sp+0h] [bp-Ch]@4
  int v2; // [sp+2h] [bp-Ah]@4
  int v3; // [sp+6h] [bp-6h]@4

  if ( sub_10043CE0(0x4Du, 1u) )
  {
    result = dword_10789ADC;
    dword_1065E088 = dword_10789ADC;
    if ( dword_10789ADC )
    {
      (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_107896F0)(dword_10789ADC, 8, &v1);
      word_1065E080 = v1;
      result = v3 & 0x1FF;
      dword_1065E088 += (unsigned __int16)word_10789AE0;
      word_1065E084 = v2 & 0x1FF;
      word_1065E07C = v3 & 0x1FF;
    }
  }
  else
  {
    word_1065E080 = 6;
    word_1065E084 = 6;
    result = dword_1078995C;
    word_1065E07C = 60;
    dword_1065E088 = dword_1078995C;
  }
  return result;
}
// 1065E07C: using guessed type __int16 word_1065E07C;
// 1065E080: using guessed type __int16 word_1065E080;
// 1065E084: using guessed type __int16 word_1065E084;
// 1065E088: using guessed type int dword_1065E088;
// 107896F0: using guessed type int dword_107896F0;
// 1078995C: using guessed type int dword_1078995C;
// 10789ADC: using guessed type int dword_10789ADC;
// 10789AE0: using guessed type __int16 word_10789AE0;

//----- (10035AE0) --------------------------------------------------------
char *__cdecl sub_10035AE0(unsigned __int8 a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *result; // eax@1
  signed int v4; // ebp@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // esi@2
  char v8; // cl@4
  int v9; // ecx@8
  int v10; // [sp+10h] [bp-28h]@2
  int v11; // [sp+14h] [bp-24h]@1
  char v12[28]; // [sp+18h] [bp-20h]@2

  v2 = dword_10789740[3 * a1];
  result = (char *)(12 * a1);
  v4 = *(_DWORD *)&result[(_DWORD)dword_10789748];
  v5 = v1;
  v6 = *(_WORD *)&result[(_DWORD)word_10789744];
  v11 = v1;
  if ( v4 > 0 )
  {
    v7 = v1 - (_DWORD)v12;
    v10 = *(_DWORD *)&result[(_DWORD)dword_10789748];
    do
    {
      (*(void (__cdecl **)(int, int, char *))dword_107896F0)(v2, v6, v12);
      v12[v6] = 0;
      result = v12;
      do
      {
        v8 = *result;
        result[v7] = *result;
        ++result;
      }
      while ( v8 );
      v2 += v6;
      v7 += 25;
      --v10;
    }
    while ( v10 );
    v5 = v11;
  }
  if ( v4 < 64 )
  {
    result = (char *)(v5 + 25 * v4);
    v9 = 64 - v4;
    do
    {
      *result = 0;
      result += 25;
      --v9;
    }
    while ( v9 );
  }
  return result;
}
// 107896F0: using guessed type int dword_107896F0;
// 10789740: using guessed type int dword_10789740[];
// 10789744: using guessed type __int16 word_10789744[];
// 10789748: using guessed type int dword_10789748[];
// 10035AE0: using guessed type char var_20[28];

//----- (10035BA0) --------------------------------------------------------
signed int sub_10035BA0()
{
  signed int result; // eax@1

  result = 0xFFFFFF;
  byte_107896F4 = 0;
  dword_107896F8 = 0xFFFFFF;
  byte_107896E4 = 0;
  dword_107896E8 = 0xFFFFFF;
  return result;
}
// 107896E4: using guessed type char byte_107896E4;
// 107896E8: using guessed type int dword_107896E8;
// 107896F4: using guessed type char byte_107896F4;
// 107896F8: using guessed type int dword_107896F8;

//----- (10035BC0) --------------------------------------------------------
int sub_10035BC0()
{
  int result; // eax@1

  result = (*(int (**)(void))(dword_107896F0 + 16))();
  byte_107896EC = (_BYTE)result == 0;
  return result;
}
// 107896EC: using guessed type char byte_107896EC;
// 107896F0: using guessed type int dword_107896F0;

//----- (10035C20) --------------------------------------------------------
int sub_10035C20()
{
  int result; // eax@1

  *(_DWORD *)(dword_10789F90 + 20812) = 1000;
  *(_DWORD *)(dword_10789F90 + 20816) = dword_107897A8 + *(_DWORD *)(dword_10789F90 + 20812);
  *(_DWORD *)(dword_10789F90 + 20820) = dword_10789808 + *(_DWORD *)(dword_10789F90 + 20816);
  *(_DWORD *)(dword_10789F90 + 20824) = dword_10789838 + *(_DWORD *)(dword_10789F90 + 20820);
  result = dword_10789F90;
  *(_DWORD *)(dword_10789F90 + 20828) = dword_10789880 + *(_DWORD *)(dword_10789F90 + 20824);
  return result;
}
// 107897A8: using guessed type int dword_107897A8;
// 10789808: using guessed type int dword_10789808;
// 10789838: using guessed type int dword_10789838;
// 10789880: using guessed type int dword_10789880;
// 10789F90: using guessed type int dword_10789F90;

//----- (10035C90) --------------------------------------------------------
char *sub_10035C90()
{
  sub_10035AE0(0x40u);
  sub_10035AE0(0x39u);
  sub_10035AE0(0x33u);
  sub_10035AE0(0x31u);
  sub_10035AE0(0x32u);
  sub_10035AE0(0x4Eu);
  sub_10035AE0(0x4Fu);
  sub_10035AE0(0x3Du);
  sub_10035AE0(0x3Eu);
  sub_10035AE0(0x45u);
  return sub_10035AE0(0x38u);
}
// 10789F90: using guessed type int dword_10789F90;

//----- (10035D60) --------------------------------------------------------
int __cdecl sub_10035D60(const void *a1)
{
  int result; // eax@1

  qmemcpy(dword_1065E090, a1, 0x1Cu);
  dword_107896F0 = (int)dword_1065E090;
  dword_10789F90 = (int)&unk_1065E0B0;
  memset(&unk_1065E0B0, 0, 0x516Cu);
  dword_1065E090[5](dword_10789F90 + 20832, dword_10789F90 + 20833, dword_10789F90 + 20836);
  (*(void (__cdecl **)(int))(dword_107896F0 + 24))(dword_10789F90 + 20840);
  sub_1003E920();
  sub_1003E4C0();
  sub_1003E760();
  sub_1003E590();
  sub_10035C90();
  sub_10035BA0();
  sub_10036120();
  sub_10035A40();
  sub_10035BC0();
  sub_10035C20();
  *(_DWORD *)(dword_10789F90 + 20800) = 0;
  *(_DWORD *)(dword_10789F90 + 20804) = dword_10789928;
  result = dword_10789F90;
  *(_DWORD *)(dword_10789F90 + 20808) = dword_10789934 + *(_DWORD *)(dword_10789F90 + 20804);
  return result;
}
// 107896F0: using guessed type int dword_107896F0;
// 10789928: using guessed type int dword_10789928;
// 10789934: using guessed type int dword_10789934;
// 10789F90: using guessed type int dword_10789F90;

//----- (10035E10) --------------------------------------------------------
int __cdecl sub_10035E10(_BYTE *a1, _BYTE *a2)
{
  int result; // eax@1

  result = sub_10043D20(0x2Bu);
  *a1 = result;
  if ( (_BYTE)result )
  {
    result = (int)a2;
    *a2 = 1;
  }
  else
  {
    *a2 = 0;
    *a1 = 1;
  }
  return result;
}

//----- (10035E40) --------------------------------------------------------
int sub_10035E40()
{
  return (*(int (**)(void))(dword_107896F0 + 8))();
}
// 107896F0: using guessed type int dword_107896F0;

//----- (10035E50) --------------------------------------------------------
int __fastcall sub_10035E50(unsigned __int8 a1)
{
  return dword_10789944 + a1 * (unsigned __int16)word_10789948;
}
// 10789944: using guessed type int dword_10789944;
// 10789948: using guessed type __int16 word_10789948;

//----- (10035E70) --------------------------------------------------------
int __fastcall sub_10035E70(unsigned __int8 a1)
{
  return dword_10789950 + a1 * (unsigned __int16)word_10789954;
}
// 10789950: using guessed type int dword_10789950;
// 10789954: using guessed type __int16 word_10789954;

//----- (10035E90) --------------------------------------------------------
void *__cdecl sub_10035E90(char a1, void *a2)
{
  void *result; // eax@2
  int v3; // eax@4
  int v4; // eax@4
  char v5; // [sp+6h] [bp-1Eh]@1
  unsigned __int8 v6; // [sp+7h] [bp-1Dh]@1
  char v7; // [sp+8h] [bp-1Ch]@4
  char v8; // [sp+16h] [bp-Eh]@4

  sub_10035E10(&v6, &v5);
  if ( (unsigned __int8)a1 < v6 )
  {
    if ( v5 )
    {
      v3 = sub_10035E50(a1);
      v4 = (*(int (__cdecl **)(int, signed int, char *))dword_107896F0)(v3, 22, &v7);
      result = (void *)sub_1003E5F0(v4, &v8, 20, (int)a2);
      *((_BYTE *)a2 + 20) = 0;
    }
    else
    {
      result = memcpy(a2, &aWgs84[21 * (unsigned __int8)a1], 0x14u);
      *((_BYTE *)a2 + 20) = 0;
    }
  }
  else
  {
    result = (void *)1600085855;
    *(_DWORD *)a2 = 1600085855;
    *((_DWORD *)a2 + 1) = 1600085855;
    *((_DWORD *)a2 + 2) = 1600085855;
    *((_DWORD *)a2 + 3) = 1600085855;
    *((_DWORD *)a2 + 4) = 1600085855;
    *((_BYTE *)a2 + 20) = 0;
  }
  return result;
}
// 107896F0: using guessed type int dword_107896F0;

//----- (10035F60) --------------------------------------------------------
int __cdecl sub_10035F60(int a1)
{
  bool v1; // zf@1
  int v2; // eax@2
  signed int v3; // eax@2
  float v4; // ST24_4@2
  unsigned __int8 v5; // cl@2
  int v6; // eax@2
  char v7; // al@2
  char v8; // cl@2
  float v9; // ST24_4@3
  double v10; // st6@3
  float v11; // ST24_4@3
  float v12; // ST24_4@3
  double v13; // st7@3
  float v14; // ST24_4@3
  float v16; // [sp+10h] [bp-34h]@2
  char v17; // [sp+14h] [bp-30h]@2
  char v18; // [sp+15h] [bp-2Fh]@2
  char v19; // [sp+16h] [bp-2Eh]@2
  char v20; // [sp+17h] [bp-2Dh]@2
  char v21; // [sp+26h] [bp-1Eh]@2
  char v22; // [sp+28h] [bp-1Ch]@2
  char v23; // [sp+36h] [bp-Eh]@2
  unsigned __int8 v24; // [sp+37h] [bp-Dh]@2
  __int16 v25; // [sp+38h] [bp-Ch]@2
  __int16 v26; // [sp+3Ah] [bp-Ah]@2
  __int16 v27; // [sp+3Ch] [bp-8h]@2

  *(float *)(a1 + 24) = 0.0;
  *(float *)(a1 + 28) = 0.0;
  *(float *)(a1 + 32) = 0.0;
  *(float *)(a1 + 36) = 6378137.0;
  *(float *)(a1 + 40) = 0.0033528106;
  *(_BYTE *)(a1 + 56) = 0;
  memcpy((void *)(a1 + 1), "WGS 84              ", 0x15u);
  v1 = *(_BYTE *)(a1 + 81) == 0;
  *(_BYTE *)(a1 + 80) = 1;
  if ( !v1 )
  {
    v2 = sub_10035E50(*(_BYTE *)a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_107896F0)(v2, 22, &v22);
    sub_1003E5F0((int)&v23, &v23, 20, a1 + 1);
    v3 = v27;
    LODWORD(v4) = v26;
    v5 = v24;
    *(float *)(a1 + 24) = (double)v25;
    *(_BYTE *)(a1 + 21) = 0;
    *(float *)(a1 + 28) = (double)SLODWORD(v4);
    *(float *)(a1 + 32) = (double)v3;
    v6 = sub_10035E70(v5);
    (*(void (__cdecl **)(int, signed int, float *))dword_107896F0)(v6, 23, &v16);
    v7 = v18;
    v8 = v19;
    LOBYTE(v4) = v17;
    *(float *)(a1 + 36) = v16;
    BYTE1(v4) = v7;
    BYTE2(v4) = v8;
    BYTE3(v4) = v20;
    *(float *)(a1 + 40) = v4;
    sub_1003E5F0((int)&v21, &v21, 20, a1 + 56);
    *(_BYTE *)(a1 + 76) = 0;
  }
  *(float *)(a1 + 44) = *(float *)(a1 + 40) + *(float *)(a1 + 40) - *(float *)(a1 + 40) * *(float *)(a1 + 40);
  v9 = *(float *)(a1 + 36) - 6378137.0;
  v10 = v9;
  *(float *)(a1 + 48) = v9;
  v11 = *(float *)(a1 + 40) - 0.003352810628712177;
  v12 = 6378137.0 * v11;
  v13 = v12;
  v14 = v10 * 0.00335281066474748;
  *(float *)(a1 + 52) = v13 + v14;
  return (*(int (__cdecl **)(int))(dword_107896F0 + 12))(a1);
}
// 107896F0: using guessed type int dword_107896F0;

//----- (10036120) --------------------------------------------------------
char sub_10036120()
{
  int v0; // eax@1
  unsigned __int8 v1; // bl@1
  char v2; // al@7
  unsigned __int8 v3; // bl@10
  unsigned __int8 v5; // [sp+6h] [bp-76h]@1
  unsigned __int8 v6; // [sp+7h] [bp-75h]@1
  char v7[4]; // [sp+8h] [bp-74h]@1
  char v8; // [sp+Ch] [bp-70h]@10
  unsigned __int8 v9; // [sp+5Ch] [bp-20h]@5
  char v10; // [sp+5Dh] [bp-1Fh]@8
  char v11; // [sp+5Eh] [bp-1Eh]@6
  char v12; // [sp+60h] [bp-1Ch]@2

  sub_10035E40();
  sub_10035E10(&v6, &v5);
  LOBYTE(v0) = v6;
  v1 = 0;
  v5 = v6;
  v7[0] = 0;
  if ( v6 )
  {
    do
    {
      sub_10035E90(v7[0], &v12);
      v0 = strcmp(&v12, "WGS 84              ");
      if ( !v0 )
        v5 = v1;
      v7[0] = ++v1;
    }
    while ( v1 < v6 );
  }
  if ( !v9 || v5 != v11 )
  {
    v2 = sub_10043D20(0x2Bu);
    v9 = v2;
    if ( v2 )
    {
      v10 = 1;
    }
    else
    {
      v2 = 1;
      v10 = 0;
      v9 = 1;
    }
    v3 = 0;
    v8 = v2;
    v11 = v2;
    v7[0] = 0;
    if ( v2 )
    {
      do
      {
        sub_10035E90(v7[0], &v12);
        if ( !strcmp(&v12, "WGS 84              ") )
        {
          v11 = v3;
          v8 = v3;
        }
        v7[0] = ++v3;
      }
      while ( v3 < v9 );
    }
    LOBYTE(v0) = sub_10035F60((int)&v8);
  }
  return v0;
}

//----- (10036280) --------------------------------------------------------
char *__cdecl sub_10036280(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_10069690();
  *(_DWORD *)(a5 + 596) = sub_10069700();
  sub_10069720((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_100365D0(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_10039160((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (100363B0) --------------------------------------------------------
char sub_100363B0()
{
  char result; // al@1

  result = 0;
  byte_10668788 = 0;
  byte_10668789 = 0;
  return result;
}
// 10668788: using guessed type char byte_10668788;
// 10668789: using guessed type char byte_10668789;

//----- (100363C0) --------------------------------------------------------
char __cdecl sub_100363C0(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_10036280(-5, a1, a2, a4, a5);
  else
    sub_10036280(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_100367C0((const char *)(a5 + 485), " DBGA", 100);
  sub_10069720((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_10668788 )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_10668789 )
LABEL_15:
      result = sub_10069760(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 1006BB80: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 10668788: using guessed type char byte_10668788;
// 10668789: using guessed type char byte_10668789;

//----- (100364C0) --------------------------------------------------------
char __cdecl sub_100364C0(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_100363C0(a1, a2, a3, a4, (int)&v5);
}

//----- (10036530) --------------------------------------------------------
void __cdecl sub_10036530(const char *a1, unsigned int a2, int a3)
{
  unsigned int v3; // eax@2

  if ( a1 )
  {
    v3 = strlen(a1);
    if ( v3 < a2 )
      memset((void *)&a1[v3], a3, a2 - v3);
    a1[a2] = 0;
  }
}

//----- (10036580) --------------------------------------------------------
void __cdecl sub_10036580(const char *a1, char a2, char a3)
{
  unsigned int v3; // esi@4
  unsigned int v4; // ecx@4

  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        v3 = strlen(a1);
        v4 = 0;
        if ( v3 )
        {
          do
          {
            if ( a1[v4] == a2 )
              a1[v4] = a3;
            ++v4;
          }
          while ( v4 < v3 );
        }
      }
    }
  }
}

//----- (100365D0) --------------------------------------------------------
int __cdecl sub_100365D0(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (10036620) --------------------------------------------------------
signed int __cdecl sub_10036620(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebp@1
  _BYTE *v4; // ebx@2
  _BYTE *v5; // edi@2
  int v6; // esi@3
  int v7; // eax@3
  signed int result; // eax@7

  v3 = a3;
  if ( a3 <= 0 )
  {
LABEL_7:
    result = -2;
  }
  else
  {
    v4 = a2;
    v5 = a1;
    while ( 1 )
    {
      v6 = tolower(*v5++);
      v7 = tolower(*v4++);
      if ( v6 > v7 )
        return 1;
      if ( v6 < v7 )
        return -1;
      if ( !v6 )
        break;
      if ( --v3 <= 0 )
        goto LABEL_7;
    }
    result = 0;
  }
  return result;
}

//----- (10036690) --------------------------------------------------------
int __cdecl sub_10036690(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (100366C0) --------------------------------------------------------
void __cdecl sub_100366C0(_BYTE *a1)
{
  _BYTE *v1; // esi@1

  v1 = a1;
  if ( a1 && *a1 )
  {
    do
    {
      *v1 = toupper(*v1);
      ++v1;
    }
    while ( *v1 );
  }
}

//----- (100366F0) --------------------------------------------------------
int __cdecl sub_100366F0(int a1, char *a2, int a3)
{
  int v3; // eax@3
  int i; // esi@5
  int v5; // esi@8
  int result; // eax@8

  if ( a1 && a2 )
  {
    v3 = a3;
    if ( !a3 )
      v3 = strlen((const char *)a1);
    for ( i = v3 - 1; i >= 0; --i )
    {
      if ( !strchr(a2, *(_BYTE *)(i + a1)) )
        break;
    }
    v5 = i + 1;
    *(_BYTE *)(v5 + a1) = 0;
    result = v5;
  }
  else
  {
    result = a3;
  }
  return result;
}

//----- (10036750) --------------------------------------------------------
int __cdecl sub_10036750(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10036790) --------------------------------------------------------
int sub_10036790(char *a1, size_t a2, char *a3, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, a3);
  result = sub_10036750(a1, a2, a3, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (100367C0) --------------------------------------------------------
int __cdecl sub_100367C0(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_100365D0((int)&a1[v3], a2, a3 - v3);
}

//----- (10036800) --------------------------------------------------------
int __cdecl sub_10036800(int a1, int a2)
{
  return sub_100366F0(a1, "_ ", a2);
}

//----- (10036820) --------------------------------------------------------
char __cdecl sub_10036820(const void *a1)
{
  __int16 v2; // [sp+8h] [bp-530h]@1
  char v3; // [sp+Ch] [bp-52Ch]@1

  memset(&v2, 0, 0x528u);
  v2 = -32723;
  qmemcpy(&v3, a1, 0x1C8u);
  return sub_1003EB80((int)&v2);
}

//----- (10036890) --------------------------------------------------------
void sub_10036890()
{
  float v0; // ST00_4@1

  v0 = sub_10044E80();
  sub_10081430(v0);
}
// 10044E80: using guessed type double sub_10044E80(void);

//----- (100368B0) --------------------------------------------------------
char __thiscall sub_100368B0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_1006A3A0(3180, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (100368E0) --------------------------------------------------------
char __thiscall sub_100368E0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 12;
  sub_1006A3A0(3000, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10036910) --------------------------------------------------------
char __thiscall sub_10036910(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 30;
  sub_1006A3A0(3001, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10036940) --------------------------------------------------------
__int16 __cdecl sub_10036940(int a1)
{
  int v1; // ecx@0
  int v2; // eax@1
  __int16 result; // ax@3
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v1;
  v2 = (unsigned __int8)sub_10038500(a1) - 1;
  if ( v2 )
  {
    if ( v2 == 1 )
    {
      sub_1006A140(9953, (int)&v4, 2);
      result = v4;
    }
    else
    {
      sub_1006A140(9950, (int)&v4, 2);
      result = v4;
    }
  }
  else
  {
    sub_1006A140(9951, (int)&v4, 2);
    result = v4;
  }
  return result;
}

//----- (100369B0) --------------------------------------------------------
char __fastcall sub_100369B0(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_1006BA40(3, (_BYTE *)&v2 + 2);
  BYTE2(v2) = byte_100AF235[2 * sub_1003B860((int *)((char *)&v2 + 2), 1u, (int)&unk_100AF234, 2, 5, -1)];
  if ( sub_1006A0A0(3002, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_1006A250(3002, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10036A20) --------------------------------------------------------
char __thiscall sub_10036A20(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_1006A3A0(6077, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10036A50) --------------------------------------------------------
char __fastcall sub_10036A50(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_1006BA40(3, (_BYTE *)&v2 + 2);
  if ( sub_1006A0A0(3003, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_1006A250(3003, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10036AA0) --------------------------------------------------------
int __cdecl sub_10036AA0(int a1, int a2, int a3)
{
  void *v3; // ecx@0
  int v4; // eax@1
  unsigned int v5; // esi@3
  int result; // eax@7

  v4 = a1;
  if ( !a1 )
    v4 = sub_10037130(v3);
  v5 = 0;
  while ( v4 != dword_100AF250[2 * v5] )
  {
    if ( ++v5 >= 0x1C )
      return sub_100365D0(a2, &unk_100AF354, a3);
  }
  result = sub_100365D0(a2, off_100AF254[2 * v5], a3);
  if ( v5 < 0x1C )
    return result;
  return sub_100365D0(a2, &unk_100AF354, a3);
}
// 10036AA0: too many cbuild loops
// 100AF250: using guessed type int dword_100AF250[];

//----- (10036B00) --------------------------------------------------------
char sub_10036B00()
{
  return 18;
}

//----- (10036B10) --------------------------------------------------------
char __thiscall sub_10036B10(void *this)
{
  char result; // al@3
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1006BA40(95, (_BYTE *)&v2 + 2);
  if ( *(_BYTE *)(dword_10789FA0 + 28249) && !sub_1006A0A0(3202, (int)&v2 + 3, 1) )
  {
    result = BYTE3(v2);
  }
  else
  {
    sub_1006A250(3202, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}
// 10789FA0: using guessed type int dword_10789FA0;

//----- (10036B70) --------------------------------------------------------
BOOL __thiscall sub_10036B70(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1006BA40(97, (_BYTE *)&v2 + 3);
  return BYTE3(v2) == 1;
}

//----- (10036B90) --------------------------------------------------------
char __thiscall sub_10036B90(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 18;
  sub_1006A3A0(3005, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10036BC0) --------------------------------------------------------
char __thiscall sub_10036BC0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 23;
  sub_1006A3A0(3006, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10036BF0) --------------------------------------------------------
char __fastcall sub_10036BF0(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_1006BA40(5, (_BYTE *)&v2 + 2);
  if ( sub_1006A0A0(3007, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_1006A250(3007, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10036C40) --------------------------------------------------------
bool __thiscall sub_10036C40(void *this)
{
  int v1; // eax@2
  bool result; // al@2
  unsigned __int16 v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@1

  LOBYTE(v4) = sub_10038600(this);
  v5 = 2;
  sub_1006A100(9129, &v3, 2, &v5);
  if ( sub_1003C180(v4, 4) )
  {
    v1 = sub_1003B860(&v4, 1u, (int)&unk_100AF330, 8, 2, 2);
    result = (v3 & (unsigned __int16)word_100AF334[4 * v1]) != 0;
  }
  else
  {
    result = sub_1003C180(v4, 2) || sub_1003C230(6) || sub_1003C230(8) || sub_1003C180(v4, 12) || sub_1003C180(v4, 16);
  }
  return result;
}
// 100AF334: using guessed type __int16 word_100AF334[];

//----- (10036D10) --------------------------------------------------------
char __thiscall sub_10036D10(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_1006A3A0(3011, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10036D40) --------------------------------------------------------
char __thiscall sub_10036D40(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 1;
  sub_1006A3A0(3008, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10036D70) --------------------------------------------------------
int sub_10036D70()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v1 = 0;
  sub_1006A3A0(3012, &v2, 4, &v1);
  return v2;
}

//----- (10036DA0) --------------------------------------------------------
signed int __cdecl sub_10036DA0(int a1)
{
  signed int result; // eax@4

  switch ( a1 )
  {
    case 1:
      result = 41007;
      break;
    case 2:
      result = 41008;
      break;
    case 4:
      result = 41009;
      break;
    default:
      result = 42066;
      break;
  }
  return result;
}

//----- (10036DD0) --------------------------------------------------------
char __thiscall sub_10036DD0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 11;
  sub_1006A3A0(3009, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10036E00) --------------------------------------------------------
char __fastcall sub_10036E00(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_1006BA40(42, (_BYTE *)&v2 + 2);
  if ( sub_1006A0A0(3162, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_1006A250(3162, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10036E50) --------------------------------------------------------
char __cdecl sub_10036E50(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A2: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);

//----- (10036E70) --------------------------------------------------------
int __cdecl sub_10036E70(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_100364C0("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_100364C0("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D5AE: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (10036ED0) --------------------------------------------------------
char __thiscall sub_10036ED0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10036E70(5, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10036EF0) --------------------------------------------------------
char __thiscall sub_10036EF0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10036E70(10, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10036F10) --------------------------------------------------------
char __thiscall sub_10036F10(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10036E70(11, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10036F30) --------------------------------------------------------
char __thiscall sub_10036F30(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10036E70(18, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10036F50) --------------------------------------------------------
int __thiscall sub_10036F50(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10036E70(15, (char *)&v2);
  return (int)v2;
}

//----- (10036F70) --------------------------------------------------------
__int16 __thiscall sub_10036F70(void *this)
{
  int v1; // eax@1

  v1 = sub_10037130(this);
  return sub_10036940(v1);
}

//----- (10036F80) --------------------------------------------------------
int __thiscall sub_10036F80(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10036E70(16, (char *)&v2);
  return (int)v2;
}

//----- (10036FA0) --------------------------------------------------------
char __thiscall sub_10036FA0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10036E70(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10036FC0) --------------------------------------------------------
int __thiscall sub_10036FC0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10036E70(29, (char *)&v2);
  return (int)v2;
}

//----- (10036FE0) --------------------------------------------------------
char __thiscall sub_10036FE0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10036E70(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10037000) --------------------------------------------------------
bool __fastcall sub_10037000(int a1, int a2)
{
  void *v2; // ecx@1
  char v3; // bl@1
  void *v4; // ecx@3
  bool result; // al@4
  char v6; // [sp+Ch] [bp-4h]@1

  v6 = j_HWM_pvg_hsdb_get_lrus_online(a1, a2);
  v3 = sub_10038600(v2);
  if ( sub_1003C180(v3, 2) || sub_1003C180(v3, 18) )
    goto LABEL_12;
  if ( sub_1003C180(v3, 4) )
    return sub_10036C40(v4);
  if ( sub_1003C180(v3, 6) && (!v3 || !(v6 & 4)) )
LABEL_12:
    result = 1;
  else
    result = 0;
  return result;
}
// 1006BB50: using guessed type int __fastcall j_HWM_pvg_hsdb_get_lrus_online(_DWORD, _DWORD);

//----- (10037080) --------------------------------------------------------
char __thiscall sub_10037080(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10036E70(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (100370A0) --------------------------------------------------------
char sub_100370A0()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 0;
  sub_10036E70(48, &v1);
  return v1;
}

//----- (100370C0) --------------------------------------------------------
int __cdecl sub_100370C0(char a1)
{
  return sub_10036E70(56, &a1);
}

//----- (100370D0) --------------------------------------------------------
int __cdecl sub_100370D0(char a1)
{
  return sub_10036E70(87, &a1);
}

//----- (100370E0) --------------------------------------------------------
int __cdecl sub_100370E0(char *a1)
{
  return sub_10036E70(93, a1);
}

//----- (100370F0) --------------------------------------------------------
int __cdecl sub_100370F0(char *a1)
{
  return sub_10036E70(8, a1);
}

//----- (10037100) --------------------------------------------------------
char __thiscall sub_10037100(void *this)
{
  char result; // al@1
  bool v2; // zf@2
  void *v3; // [sp-2h] [bp-4h]@1

  v3 = this;
  sub_10036E70(4, (char *)&v3 + 3);
  result = BYTE3(v3);
  if ( BYTE3(v3) == 1 )
  {
    v2 = SIM_proc_rqst(50) == 0;
    result = 2;
    if ( v2 )
      result = BYTE3(v3);
  }
  return result;
}
// 1006D596: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (10037130) --------------------------------------------------------
int __thiscall sub_10037130(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10036E70(46, (char *)&v2);
  return (int)v2;
}

//----- (10037150) --------------------------------------------------------
int __cdecl sub_10037150(char *a1)
{
  int result; // eax@1

  result = sub_10036E70(50, a1);
  a1[11] = 0;
  return result;
}

//----- (10037170) --------------------------------------------------------
char sub_10037170()
{
  void *v0; // ecx@1
  int v1; // eax@1
  char result; // al@2
  char v3; // [sp+3h] [bp-5h]@1
  int v4; // [sp+4h] [bp-4h]@1

  sub_10045140(4);
  sub_10045140(1);
  sub_10045140(2);
  v4 = sub_10037130(v0);
  v3 = 0;
  v1 = sub_1003B860(&v4, 4u, (int)&unk_100AF898, 8, 3, 3);
  if ( v1 == 3 )
  {
    sub_1006A140(41107, (int)&v3, 1);
    result = v3;
  }
  else
  {
    sub_1006A140(dword_100AF89C[2 * v1], (int)&v3, 1);
    result = v3;
  }
  return result;
}
// 100AF89C: using guessed type int dword_100AF89C[];

//----- (100371F0) --------------------------------------------------------
bool __cdecl sub_100371F0(char a1)
{
  void *v1; // ecx@0
  bool result; // al@2
  void *v3; // ecx@4

  switch ( a1 )
  {
    case 5:
      result = sub_1003B800(0) == 1;
      break;
    case 6:
      goto LABEL_3;
    case 9:
      if ( sub_10037130(v1) & 3 || sub_10037080(v3) == 1 )
        result = 1;
      else
LABEL_3:
        result = 0;
      break;
    case 8:
      result = sub_10037080(v1) != 1;
      break;
    default:
      result = sub_10037080(v1) == 1;
      break;
  }
  return result;
}

//----- (10037260) --------------------------------------------------------
int __cdecl sub_10037260(unsigned __int16 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 > 0x1C8Au && a1 < 0x1C8Bu )
    result = (unsigned __int16)(a1 - 7307);
  return result;
}

//----- (10037280) --------------------------------------------------------
char *__cdecl sub_10037280(unsigned __int16 a1)
{
  bool v1; // cf@1
  bool v2; // zf@1
  char *result; // eax@1

  v1 = a1 < 0x1C8Au;
  v2 = a1 == 7306;
  result = (char *)&unk_100AF8B0;
  if ( a1 < 0x1C8Au )
  {
    if ( a1 != -1 )
      return (char *)TXT_get_static_string();
    v1 = 0;
    v2 = 0;
  }
  if ( !v1 && !v2 && a1 < 0x1C8Bu )
    result = &byte_10789FA4[(unsigned __int16)sub_10037260(a1)];
  return result;
}
// 100820D0: using guessed type int TXT_get_static_string(void);

//----- (100372C0) --------------------------------------------------------
char __cdecl sub_100372C0(_BYTE *a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  void *v3; // ecx@1
  char result; // al@3
  void *v5; // ecx@6
  __int16 v6; // [sp+8h] [bp-298h]@1
  int v7; // [sp+Ch] [bp-294h]@1
  int v8; // [sp+10h] [bp-290h]@1
  char v9; // [sp+14h] [bp-28Ch]@1
  char v10; // [sp+D4h] [bp-1CCh]@1
  char v11; // [sp+198h] [bp-108h]@1
  char v12; // [sp+199h] [bp-107h]@1

  v2 = sub_10036FE0(v1);
  v6 = -32598;
  v7 = 0;
  v8 = 83;
  sub_100365D0((int)&v9, a1, 64);
  v10 = 9;
  v11 = 0;
  memset(&v12, 0, 0x100u);
  if ( v2 == 8 )
  {
    if ( sub_10069790(21) == 5 )
      return sub_10069800(16, (int)&v6, 1000, 1);
  }
  else if ( v2 == 2 )
  {
    return sub_10069800(3, (int)&v6, 1000, 1);
  }
  if ( sub_10037080(v3) == 1 || sub_10037130(v5) & 3 )
  {
    if ( sub_10036ED0(v5) )
    {
      result = sub_10069800(1, (int)&v6, 1000, 1);
    }
    else
    {
      sub_100365D0((int)&v12, "No available drop down lists on this page.", 256);
      result = sub_10036820(&v10);
    }
  }
  else
  {
    result = sub_10069800(9, (int)&v6, 1000, 1);
  }
  return result;
}

//----- (10037400) --------------------------------------------------------
char __cdecl sub_10037400(int a1, int a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( **(_WORD **)(a1 + 52) == -32744 || !a2 || *(_BYTE *)(a2 + a3) & 2 )
    result = 1;
  return result;
}

//----- (10037430) --------------------------------------------------------
char __cdecl sub_10037430(int a1, _WORD *a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( *a2 == -32665 || !*(_BYTE *)(a1 + 5) && a3 && *(_DWORD *)(a1 + 48) == a3 )
    result = 1;
  return result;
}

//----- (10037460) --------------------------------------------------------
__int16 __cdecl sub_10037460(unsigned int a1)
{
  return word_100B03EC[(a1 >> 17) & 0xF];
}
// 100B03EC: using guessed type __int16 word_100B03EC[];

//----- (10037480) --------------------------------------------------------
bool __cdecl sub_10037480(char *a1, int *a2, _DWORD *a3)
{
  int v3; // ecx@1
  bool v4; // zf@1
  int v5; // eax@2

  v3 = *(_DWORD *)a1 & 0xFF;
  v4 = v3 == 141;
  if ( v3 != 141 )
  {
    v5 = (int)&a1[dword_10789184[8 * v3]];
    if ( a2 )
      *a2 = v5;
    if ( a3 )
      *a3 = v5 + 4;
    v4 = v3 == 141;
  }
  return !v4;
}

//----- (100374D0) --------------------------------------------------------
char __cdecl sub_100374D0(int a1, char *a2)
{
  char *v2; // edi@1
  int v3; // esi@1
  char **v4; // eax@2

  v2 = a2;
  v3 = 0;
  if ( sub_10037480(a2, 0, &a2) )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4 * v3) = v2;
      v2 = a2;
      *(_BYTE *)(v3++ + *(_DWORD *)(a1 + 64)) = 3;
      LOBYTE(v4) = sub_10037480(v2, 0, &a2);
    }
    while ( (_BYTE)v4 );
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4 * v3) = v2;
  }
  else
  {
    v4 = *(char ***)(a1 + 56);
    *v4 = v2;
  }
  return (unsigned int)v4;
}

//----- (10037530) --------------------------------------------------------
int __cdecl sub_10037530(int a1, int a2, char *a3, int a4)
{
  char *v4; // edi@1
  int v5; // eax@1
  int v6; // ecx@1
  int v8; // [sp+8h] [bp-4h]@1

  v4 = a3;
  sub_10037480(a3, &v8, 0);
  sub_100029B0(a1, *(_DWORD *)(a1 + 56));
  v5 = *(_DWORD *)(a1 + 56);
  LOWORD(a3) = *(_WORD *)v8 + *(_WORD *)(v5 + 36);
  v6 = *(_DWORD *)v4;
  HIWORD(a3) = *(_WORD *)(v8 + 2) + *(_WORD *)(v5 + 38);
  return ((int (__cdecl *)(int, char *, char **, int, int))dword_10789180[2 * (unsigned __int8)v6])(a1, v4, &a3, a4, a2);
}
// 10789180: using guessed type int dword_10789180[];

//----- (100375A0) --------------------------------------------------------
char __cdecl sub_100375A0(int a1, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // ebp@3
  signed int v5; // ebx@3
  char result; // al@3
  _WORD *v7; // ST2C_4@6

  v3 = a2;
  if ( !a2 )
    sub_100364C0("..\\lib\\adl\\cdp_fld_utl.c", 323, 1, a2);
  v4 = *(_DWORD *)(a1 + 56);
  v5 = (unsigned __int8)v3[230];
  result = 1;
  if ( (*(_BYTE *)(v4 + 26) || v4 != *(_DWORD *)(a1 + 48)) && v5 < (unsigned __int8)v3[68] )
  {
    v7 = (_WORD *)a3;
    *(_DWORD *)(a1 + 56) = v3;
    *(_BYTE *)(a1 + 3) = sub_10037430(a1, v7, (int)v3);
    sub_10037480(*(char **)(*((_DWORD *)v3 + 14) + 4 * v5), (int *)&a2, 0);
    sub_100029B0(a1, (int)v3);
    result = ((int (__cdecl *)(int, _DWORD, char *, _DWORD, int))dword_10789180[2
                                                                              * (**(_DWORD **)(*((_DWORD *)v3 + 14)
                                                                                             + 4 * v5) & 0xFF)])(
               a1,
               *(_DWORD *)(*((_DWORD *)v3 + 14) + 4 * v5),
               a2,
               *(_DWORD *)(*((_DWORD *)v3 + 15) + 4 * v5),
               a3);
    *(_DWORD *)(a1 + 56) = v4;
    *(_BYTE *)(a1 + 3) = 0;
  }
  return result;
}
// 10789180: using guessed type int dword_10789180[];

//----- (10037650) --------------------------------------------------------
int __cdecl sub_10037650(int a1)
{
  int v1; // eax@1
  int v2; // esi@1
  char v4; // [sp+4h] [bp-68h]@3

  v1 = sub_1003B860(&a1, 4u, (int)&unk_100B0A30, 8, 20, -1);
  v2 = v1;
  if ( v1 < 0 || (unsigned int)v1 >= 0x14 )
  {
    sprintf(&v4, "UNKNOWN EVENT %lu\n", a1);
    sub_100364C0(".\\cdp_evnt_map.c", 328, 1, &v4);
  }
  return (int)*(&off_100B0A34 + 2 * v2);
}
// 100B0A34: using guessed type void *off_100B0A34;

//----- (100376D0) --------------------------------------------------------
int __cdecl sub_100376D0(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10673E48 = a1;
  return result;
}
// 10673E48: using guessed type int dword_10673E48;

//----- (100376E0) --------------------------------------------------------
bool __cdecl sub_100376E0(char a1)
{
  int v1; // eax@1

  v1 = a1 & 0x3F;
  return !(a1 & 0x3F) || v1 == 6 || v1 == 7 || v1 == 21 || v1 == 9 || v1 == 16 || v1 == 20;
}

//----- (10037710) --------------------------------------------------------
int __cdecl sub_10037710(unsigned __int8 a1)
{
  return (int)*(&off_100B1848 + 2 * a1);
}
// 100B1848: using guessed type void *off_100B1848;

//----- (10037720) --------------------------------------------------------
int __cdecl sub_10037720(unsigned int a1, float *a2)
{
  unsigned __int8 v2; // ST0C_1@1

  v2 = sub_1003F970(a1, a2);
  return sub_10037710(v2);
}

//----- (10037750) --------------------------------------------------------
char __cdecl sub_10037750(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char *v5; // eax@1

  v5 = sub_10037280(*a4);
  return sub_100377C0(a1, a2, a3, (int)v5, a5);
}

//----- (10037770) --------------------------------------------------------
int __usercall sub_10037770@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  *(_DWORD *)(result + 16) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a3 + 4);
  *(float *)(result + 12) = *(float *)(a3 + 12);
  *(_DWORD *)(result + 8) = *(_DWORD *)(a3 + 20);
  *(float *)(result + 24) = *(float *)(a3 + 24);
  *(float *)(result + 28) = *(float *)(a3 + 28);
  *(float *)(result + 32) = *(float *)(a3 + 16);
  *(float *)result = (double)*(_WORD *)a2;
  *(float *)(result + 4) = (double)*(_WORD *)(a2 + 2);
  return result;
}

//----- (100377C0) --------------------------------------------------------
char __cdecl sub_100377C0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v6; // eax@5
  int v7; // eax@6
  char v8; // [sp+0h] [bp-24h]@5

  if ( *a5 != 32802 )
  {
    if ( *a5 == 32832 )
    {
      v6 = sub_10037770((int)&v8, a3, a2);
      sub_1003D230(a1, a4, v6);
      return 2;
    }
    if ( *a5 != 32888 )
      return 1;
  }
  v7 = sub_10037770((int)&v8, a3, a2);
  sub_1003D350(a1, a4, v7);
  return 2;
}

//----- (10037840) --------------------------------------------------------
char __usercall sub_10037840@<al>(int a1@<esi>, int a2, int a3, int a4, int a5, _WORD *a6)
{
  char result; // al@3
  signed int v7; // ecx@4
  signed int v8; // edx@4
  signed int v9; // eax@4
  float v10; // ST1C_4@5
  float v11; // ST20_4@5
  double v12; // st7@5
  float v13; // ST0C_4@7
  float v14; // [sp+4h] [bp-24h]@5
  int v15; // [sp+8h] [bp-20h]@7
  float v16; // [sp+Ch] [bp-1Ch]@4
  float v17; // [sp+10h] [bp-18h]@4
  float v18; // [sp+14h] [bp-14h]@4
  float v19; // [sp+18h] [bp-10h]@4
  float v20; // [sp+1Ch] [bp-Ch]@4
  float v21; // [sp+20h] [bp-8h]@4
  float v22; // [sp+24h] [bp-4h]@4
  float v23; // [sp+3Ch] [bp+14h]@4

  if ( *a6 == 32802 || *a6 == 32888 )
  {
    v7 = *(_WORD *)(a4 + 2);
    v8 = *(_WORD *)a4;
    v16 = *(float *)(a3 + 20) + (double)v7;
    v18 = (double)v8;
    v23 = *(float *)(a3 + 16) + (double)v8;
    v17 = (double)v7;
    v22 = v16 - *(float *)(a3 + 24);
    v20 = *(float *)(a3 + 24) + v18;
    v21 = v23 - *(float *)(a3 + 24);
    v19 = *(float *)(a3 + 24) + v17;
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    v9 = sub_10039810(*(_DWORD *)(a3 + 8));
    j_gdi_pvg_color_u32(v9);
    if ( 1.0 == *(float *)(a3 + 24) )
    {
      j_gdi_pvg_begin(66);
      v10 = v17 + 0.5;
      v11 = v18 + 0.5;
      sub_10069EF0(v11, v10);
      sub_10069EF0(v23, v10);
      sub_10069EF0(v23, v16);
      v14 = v16;
      v12 = v11;
    }
    else
    {
      j_gdi_pvg_begin(73);
      sub_10069EF0(v18, v17);
      sub_10069EF0(v20, v19);
      sub_10069EF0(v23, v17);
      sub_10069EF0(v21, v19);
      sub_10069EF0(v23, v16);
      sub_10069EF0(v21, v22);
      sub_10069EF0(v18, v16);
      sub_10069EF0(v20, v22);
      sub_10069EF0(v18, v17);
      v14 = v19;
      v12 = v20;
    }
    v13 = v12;
    sub_10069EF0(v13, v14);
    j_gdi_pvg_end(a1);
    if ( !(*(_BYTE *)(a3 + 4) & 0x10) )
    {
      j_gdi_pvg_begin(72);
      j_gdi_pvg_color_u32(*(_DWORD *)(a3 + 12));
      sub_10069EF0(v20, v19);
      sub_10069EF0(v21, v19);
      sub_10069EF0(v21, v22);
      sub_10069EF0(v20, v22);
      j_gdi_pvg_end(v15);
    }
    j_gdi_pvg_disable(35);
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 10037840: could not find valid save-restore pair for esi
// 100699C0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10069A50: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10069B20: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10069B40: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10069BC0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10069BE0: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (10037AC0) --------------------------------------------------------
int __cdecl sub_10037AC0(unsigned __int16 a1)
{
  return dword_100B3100[a1];
}
// 100B3100: using guessed type int dword_100B3100[];

//----- (10037AD0) --------------------------------------------------------
char __cdecl sub_10037AD0(int a1, int a2, int a3, int a4, __int16 *a5)
{
  __int16 v5; // ax@1
  unsigned __int16 v6; // dx@4
  double v7; // st7@4
  int v8; // ST04_4@4
  double v9; // st7@4
  int v10; // eax@4
  char *v11; // edi@5
  const char *v12; // esi@6
  bool v13; // zf@97
  const char *v14; // ebx@98
  __int16 v15; // cx@98
  __int16 v16; // dx@98
  char v18; // [sp+1Eh] [bp-11Ah]@1
  char v19; // [sp+1Fh] [bp-119h]@1
  __int16 v20; // [sp+20h] [bp-118h]@98
  __int16 v21; // [sp+22h] [bp-116h]@98
  __int16 *v22; // [sp+24h] [bp-114h]@1
  int v23; // [sp+28h] [bp-110h]@1
  int v24; // [sp+2Ch] [bp-10Ch]@1
  int v25; // [sp+30h] [bp-108h]@98
  float v26; // [sp+34h] [bp-104h]@4
  char v27; // [sp+38h] [bp-100h]@4
  char *v28; // [sp+54h] [bp-E4h]@1
  int v29; // [sp+58h] [bp-E0h]@98
  int v30; // [sp+5Ch] [bp-DCh]@98
  char v31; // [sp+60h] [bp-D8h]@1
  char v32; // [sp+6Bh] [bp-CDh]@99

  v23 = a1;
  v22 = a5;
  v5 = *a5;
  v24 = a3;
  v19 = 1;
  v18 = 31;
  v28 = &v31;
  if ( v5 == -32648 || v5 == -32734 || v5 == -32704 )
  {
    v6 = *(_WORD *)a4;
    v7 = *(float *)(a4 + 4);
    qmemcpy(&v27, (const void *)(a4 + 8), 0x1Cu);
    *(float *)&v8 = v7;
    v9 = sub_1003FD90(v8, v6, *(_BYTE *)(a4 + 40), &v18);
    v10 = *(_WORD *)a4;
    v26 = v9;
    switch ( v10 )
    {
      case 0:
        v11 = &v31;
        if ( v18 == 21 )
          v12 = "\a_.__";
        else
          v12 = "\a_.__";
        goto LABEL_97;
      case 42:
      case 46:
        v12 = (const char *)&unk_100B3370;
        goto LABEL_96;
      case 1:
      case 45:
        v12 = (const char *)&unk_100B3440;
        goto LABEL_96;
      case 4:
        v12 = (const char *)&unk_100B3510;
        goto LABEL_96;
      case 5:
        v12 = (const char *)&unk_100B35E0;
        goto LABEL_96;
      case 6:
      case 10:
      case 37:
        v12 = (const char *)&unk_100B36B0;
        goto LABEL_96;
      case 11:
        v12 = (const char *)&unk_100B3780;
        goto LABEL_96;
      case 7:
      case 12:
      case 36:
        v12 = (const char *)&unk_100B3850;
        goto LABEL_96;
      case 13:
        v12 = (const char *)&unk_100B3920;
        goto LABEL_96;
      case 8:
        v12 = (const char *)&unk_100B39F0;
        goto LABEL_96;
      case 9:
        v12 = (const char *)&unk_100B3AC0;
        goto LABEL_96;
      case 14:
        v11 = &v31;
        if ( v18 == 40 )
          v12 = (const char *)&unk_100B36B0;
        else
          v12 = (const char *)&unk_100B3C60;
        goto LABEL_97;
      case 15:
        v11 = &v31;
        if ( v18 == 40 )
          v12 = (const char *)&unk_100B3850;
        else
          v12 = (const char *)&unk_100B3D30;
        goto LABEL_97;
      case 16:
        v11 = &v31;
        if ( v18 == 40 )
          v12 = (const char *)&unk_100B3B90;
        else
          v12 = (const char *)&unk_100B3E00;
        goto LABEL_97;
      case 17:
        v11 = &v31;
        if ( v18 == 10 )
          v12 = (const char *)&unk_100B3ED0;
        else
          v12 = (const char *)&unk_100B4140;
        goto LABEL_97;
      case 19:
        v11 = &v31;
        if ( v18 == 10 )
          v12 = (const char *)&unk_100B3FA0;
        else
          v12 = (const char *)&unk_100B4210;
        goto LABEL_97;
      case 18:
        v11 = &v31;
        if ( v18 == 10 )
          v12 = (const char *)&unk_100B4070;
        else
          v12 = (const char *)&unk_100B42E0;
        goto LABEL_97;
      case 20:
        v12 = (const char *)&unk_100B43B0;
        goto LABEL_96;
      case 21:
        v12 = (const char *)&unk_100B4480;
        goto LABEL_96;
      case 22:
        v12 = (const char *)&unk_100B4550;
        goto LABEL_96;
      case 23:
        v12 = (const char *)&unk_100B4620;
        goto LABEL_96;
      case 24:
        v12 = (const char *)&unk_100B46F0;
        goto LABEL_96;
      case 25:
        v12 = (const char *)&unk_100B47C0;
        goto LABEL_96;
      case 43:
        v11 = &v31;
        switch ( v18 )
        {
          case 12:
            v12 = (const char *)&unk_100B4CA0;
            break;
          case 21:
            v12 = (const char *)&unk_100B4E40;
            break;
          case 30:
            v12 = (const char *)&unk_100B4960;
            break;
          default:
            v12 = (const char *)&unk_100B4FE0;
            break;
        }
        goto LABEL_97;
      case 26:
      case 38:
        v11 = &v31;
        switch ( v18 )
        {
          case 12:
            v12 = (const char *)&unk_100B4A30;
            break;
          case 21:
            v12 = (const char *)&unk_100B4D70;
            break;
          case 30:
            v12 = (const char *)&unk_100B4890;
            break;
          default:
            v12 = (const char *)&unk_100B4F10;
            break;
        }
        goto LABEL_97;
      case 48:
        v12 = (const char *)&unk_100B4B00;
        goto LABEL_96;
      case 49:
        v12 = (const char *)&unk_100B4BD0;
        goto LABEL_96;
      case 27:
        v11 = &v31;
        if ( v18 == 28 )
          v12 = (const char *)&unk_100B50B0;
        else
          v12 = (const char *)&unk_100B5250;
        goto LABEL_97;
      case 29:
        v11 = &v31;
        if ( v18 == 28 )
          v12 = (const char *)&unk_100B5180;
        else
          v12 = (const char *)&unk_100B5320;
        goto LABEL_97;
      case 30:
        switch ( v18 )
        {
          case 0xD:
            v12 = (const char *)&unk_100B53F0;
            break;
          case 0x10:
            v12 = (const char *)&unk_100B5590;
            break;
          case 0x18:
            v12 = (const char *)&unk_100B58D0;
            break;
          default:
            v12 = (const char *)&unk_100B5A70;
            break;
          case 0x13:
            goto LABEL_95;
        }
        goto LABEL_96;
      case 31:
        switch ( v18 )
        {
          case 0xD:
            v12 = (const char *)&unk_100B54C0;
            break;
          case 0x10:
            v12 = (const char *)&unk_100B5660;
            break;
          case 0x13:
            v12 = (const char *)&unk_100B5800;
            break;
          case 0x18:
            v12 = (const char *)&unk_100B59A0;
            break;
          default:
            v12 = (const char *)&unk_100B5B40;
            break;
        }
        goto LABEL_96;
      case 32:
        switch ( v18 )
        {
          case 0xE:
            v12 = (const char *)&unk_100B5C10;
            break;
          case 0x11:
            v12 = (const char *)&unk_100B5DB0;
            break;
          case 0x14:
            v12 = (const char *)&unk_100B5F50;
            break;
          case 0x19:
            v12 = (const char *)&unk_100B60F0;
            break;
          default:
            v12 = (const char *)&unk_100B6290;
            break;
        }
        goto LABEL_96;
      case 33:
        switch ( v18 )
        {
          case 0xE:
            v12 = (const char *)&unk_100B5CE0;
            break;
          case 0x11:
            v12 = (const char *)&unk_100B5E80;
            break;
          case 0x14:
            v12 = (const char *)&unk_100B6020;
            break;
          case 0x19:
            v12 = (const char *)&unk_100B61C0;
            break;
          default:
            v12 = (const char *)&unk_100B6360;
            break;
        }
        goto LABEL_96;
      case 35:
        v12 = (const char *)&unk_100B6430;
        goto LABEL_96;
      case 34:
        v12 = (const char *)&unk_100B6500;
        goto LABEL_96;
      case 39:
        v12 = (const char *)&unk_100B65D0;
        goto LABEL_96;
      case 40:
        v12 = (const char *)&unk_100B66A0;
        goto LABEL_96;
      case 41:
        v12 = (const char *)&unk_100B6770;
        goto LABEL_96;
      case 44:
        v12 = (const char *)&unk_100B6840;
        goto LABEL_96;
      case 47:
        v12 = (const char *)&unk_100B6910;
        goto LABEL_96;
      case 50:
        v12 = (const char *)&unk_100B58D0;
        if ( v18 == 19 )
LABEL_95:
          v12 = (const char *)&unk_100B5730;
LABEL_96:
        v11 = &v31;
LABEL_97:
        v13 = v28 == 0;
        qmemcpy(v11, v12, 0xCCu);
        if ( !v13 )
        {
          v14 = *(const char **)(a4 + 36);
          v30 = *(_DWORD *)(a4 + 60);
          v15 = *(_WORD *)v24;
          v29 = a4 + 41;
          v16 = *(_WORD *)(v24 + 2);
          v25 = 27;
          v20 = v15;
          v21 = v16;
          if ( v14 )
            strcpy(&v32, v14);
          v19 = sub_100473D0(v23, (int)&v25, (int)&v20, (int)&v26, v22);
        }
        break;
      default:
        return v19;
    }
  }
  return v19;
}

//----- (10038130) --------------------------------------------------------
char __cdecl sub_10038130(int a1, int a2, int *a3, int a4, int a5)
{
  int v5; // ecx@1
  char result; // al@1
  bool v7; // zf@2
  __int16 v8; // dx@3

  v5 = a4;
  result = 1;
  if ( *(_DWORD *)(a4 + 8) )
  {
    v7 = *(_BYTE *)a4 == 0;
    a4 = *a3;
    if ( !v7 )
    {
      v8 = *(_WORD *)(v5 + 4);
      if ( *(_BYTE *)(v5 + 1) )
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2) + a4;
        HIWORD(a4) += v8;
      }
      else
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2);
        HIWORD(a4) = v8;
      }
    }
    result = ((int (__cdecl *)(int, _DWORD, int *, _DWORD, int))dword_10789180[2 * (**(_DWORD **)(v5 + 8) & 0xFF)])(
               a1,
               *(_DWORD *)(v5 + 8),
               &a4,
               *(_DWORD *)(v5 + 12),
               a5);
  }
  return result;
}
// 10789180: using guessed type int dword_10789180[];

//----- (100381A0) --------------------------------------------------------
_DWORD *__cdecl sub_100381A0(_DWORD *a1)
{
  _DWORD *result; // eax@1

  result = a1;
  *a1 = 0;
  return result;
}

//----- (100381B0) --------------------------------------------------------
int __cdecl sub_100381B0(int *a1, int a2)
{
  int result; // eax@1
  int i; // esi@1

  result = (int)a1;
  for ( i = *a1; i; i = *(_DWORD *)(i + 4) )
    result = (*(int (__cdecl **)(int, int))i)(i, a2);
  return result;
}

//----- (100381E0) --------------------------------------------------------
_DWORD *__cdecl sub_100381E0(_DWORD *a1, int a2)
{
  _DWORD *result; // eax@1

  result = a1;
  *(_DWORD *)(a2 + 4) = *a1;
  *a1 = a2;
  return result;
}

//----- (100381F0) --------------------------------------------------------
char __cdecl sub_100381F0(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10038230) --------------------------------------------------------
char __cdecl sub_10038230(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 3;
      break;
    case 1:
      result = 4;
      break;
    case 2:
      result = 5;
      break;
    case 3:
      result = 40;
      break;
    case 4:
      result = 41;
      break;
    case 5:
      result = 51;
      break;
    case 6:
      result = 52;
      break;
    default:
      sub_100364C0("..\\lib\\adl\\iop_cdu_unit_intf.c", 490, 0, 0);
      result = 67;
      break;
  }
  return result;
}

//----- (100382A0) --------------------------------------------------------
char __cdecl sub_100382A0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_100364C0("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10038310) --------------------------------------------------------
signed int __cdecl sub_10038310(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_100364C0("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10038390) --------------------------------------------------------
char __cdecl sub_10038390(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_100364C0("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10038400) --------------------------------------------------------
char __cdecl sub_10038400(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_100364C0("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (100384B0) --------------------------------------------------------
bool __cdecl sub_100384B0(char a1, void *a2)
{
  int v2; // eax@1
  int v3; // esi@1

  v2 = sub_1003B860(&a1, 1u, (int)&unk_100B7A40, 4, 7, 1);
  v3 = (int)a2;
  return sub_1003E2C0(2, (unsigned __int16)word_100B7A42[2 * v2], a2) && !sub_10047510(v3);
}
// 100B7A42: using guessed type __int16 word_100B7A42[];

//----- (10038500) --------------------------------------------------------
char __cdecl sub_10038500(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_100364C0("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10038600) --------------------------------------------------------
char __thiscall sub_10038600(void *this)
{
  int v1; // eax@1

  v1 = sub_10037130(this);
  return sub_10038500(v1);
}

//----- (10038610) --------------------------------------------------------
int __cdecl sub_10038610(int *a1)
{
  int result; // eax@1

  result = sub_10049560((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_10069700();
    result = sub_100493A0();
  }
  return result;
}

//----- (10038640) --------------------------------------------------------
char __usercall sub_10038640@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_100697D0(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_1004A620("%i %i\r\n", 13, v2);
    sub_10049BC0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"356", (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    v5 = sub_100697B0(*(_DWORD *)(a1 + 4));
    v6 = sub_1004A620("%i %i\r\n", 14, v5);
    sub_10049BC0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_100B7E64, (int)v6);
    result = 1;
  }
  else
  {
    sub_100364C0(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}

//----- (100386E0) --------------------------------------------------------
int __cdecl sub_100386E0(const char *a1)
{
  int result; // eax@1

  result = sub_100476C0();
  if ( a1 )
    result = sub_10049590(dword_10673E4C[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 10673E4C: using guessed type int dword_10673E4C[];

//----- (10038720) --------------------------------------------------------
char __cdecl sub_10038720(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_100494E0((char *)a1 + 4);
  v1 = sub_1004FF40();
  sub_10049480((int)v1, 0, 0);
  dword_10673E4C[sub_100476C0()] = (int)a1;
  v2 = sub_1004FF00((int)sub_100386E0);
  return sub_100495B0(v2);
}
// 10673E4C: using guessed type int dword_10673E4C[];

//----- (10038770) --------------------------------------------------------
signed int __cdecl sub_10038770(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_10069700();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_10069880(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_10069700() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_10069910(&v23);
          }
          while ( sub_10069700() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_100696E0(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_10069720((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_1004A620("The %s task is loaded.", &v24);
            sub_10049BC0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_1004A620("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_10049BC0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_1004A620("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_10049BC0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_1004A620(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_10049BC0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_10069670(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_1004A620("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_10049BC0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_1004A620("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_10049BC0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_10049BC0(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_10069760(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_1004FF00((int)sub_100386E0);
        sub_10049C90((int)v15);
        v16 = sub_100512E0((int)sub_100386E0);
        sub_10049C90((int)v16);
        v17 = sub_100512E0((int)sub_100386E0);
        sub_100495B0(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_1004FF00((int)sub_100386E0);
        sub_10049C90((int)v18);
        v19 = sub_100512E0((int)sub_100386E0);
        sub_10049C90((int)v19);
        v20 = sub_1004FF00((int)sub_100386E0);
        sub_100495B0(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_10038640(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (10038B10) --------------------------------------------------------
char **sub_10038B10()
{
  return off_100B7E50;
}
// 100B7E50: using guessed type char *off_100B7E50[3];

//----- (10038B30) --------------------------------------------------------
int __cdecl sub_10038B30(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10673E60 = a1;
  return result;
}
// 10673E60: using guessed type int dword_10673E60;

//----- (10038B40) --------------------------------------------------------
#error "10038B45: call analysis failed (funcsize=28)"

//----- (10038B70) --------------------------------------------------------
char __cdecl sub_10038B70(char a1, unsigned __int16 a2, char a3)
{
  char result; // al@1

  result = a1;
  do
    result += a3;
  while ( !(a2 & (unsigned __int16)word_100B8FD0[(unsigned __int8)result]) && result != a1 );
  return result;
}
// 100B8FD0: using guessed type __int16 word_100B8FD0[];

//----- (10038BA0) --------------------------------------------------------
signed int __cdecl sub_10038BA0(int (__cdecl *a1)(int))
{
  signed int result; // eax@1
  int (__cdecl **v2)(int); // ecx@1

  result = 0;
  v2 = &off_10093F10;
  do
  {
    if ( *v2 == a1 )
      break;
    ++result;
    v2 += 14;
  }
  while ( result < 15 );
  if ( result == 15 )
    result = -1;
  return result;
}
// 10093F10: using guessed type int (__cdecl *off_10093F10)(int);

//----- (10038BD0) --------------------------------------------------------
char *__cdecl sub_10038BD0(unsigned __int8 a1)
{
  char *result; // eax@2

  if ( (signed int)a1 >= 15 )
    result = byte_10084570;
  else
    result = &aKeyTest[56 * a1];
  return result;
}

//----- (10038C00) --------------------------------------------------------
bool __cdecl sub_10038C00(unsigned __int16 a1, _BYTE *a2, unsigned __int8 a3)
{
  unsigned __int16 v3; // ax@2
  bool result; // al@5
  char v5[4]; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5[0] = -1;
  v6 = 0;
  result = 0;
  if ( sub_10052230(a1, a3, v5, &v6) == 1 )
  {
    v3 = sub_1003D620(v5[0]);
    if ( (unsigned __int16)v6 < v3 && sub_1003E2C0(v5[0], v6, a2) && !sub_1003F240(a2, 0, 0) )
      result = 1;
  }
  return result;
}

//----- (10038C80) --------------------------------------------------------
char __cdecl sub_10038C80(unsigned __int16 a1)
{
  char result; // al@3
  char v2; // [sp+Bh] [bp-9h]@3
  int v3; // [sp+Ch] [bp-8h]@1
  int v4; // [sp+10h] [bp-4h]@1

  LOBYTE(v4) = 7;
  v3 = 0;
  if ( sub_10052230(a1, 0, &v4, &v3) != 1 && sub_10052230(a1, 1u, &v4, &v3) != 1
    || (result = sub_1003D9B0(v4, v3, &v2), result != 1)
    || v2 != 1 )
  {
    result = 0;
  }
  return result;
}

//----- (10038CF0) --------------------------------------------------------
char __cdecl sub_10038CF0(unsigned __int16 a1)
{
  char result; // al@3
  char v2; // [sp+Bh] [bp-9h]@3
  int v3; // [sp+Ch] [bp-8h]@1
  int v4; // [sp+10h] [bp-4h]@1

  LOBYTE(v4) = 7;
  v3 = 0;
  if ( sub_10052290(a1, 0, &v4, &v3) != 1 && sub_10052290(a1, 1u, &v4, &v3) != 1
    || (result = sub_1003D9B0(v4, v3, &v2), result != 1)
    || v2 != 1 )
  {
    result = 0;
  }
  return result;
}

//----- (10038D60) --------------------------------------------------------
char __cdecl sub_10038D60(unsigned __int16 a1, char a2)
{
  void *v2; // ecx@0
  char v3; // al@1
  unsigned __int16 v4; // ax@1
  int v6; // [sp+0h] [bp-Ch]@1
  int v7; // [sp+4h] [bp-8h]@1
  int v8; // [sp+8h] [bp-4h]@1

  LOBYTE(v6) = -1;
  v7 = 0;
  v3 = sub_10045170(v2);
  LOBYTE(v8) = v3 != 0;
  LOBYTE(v4) = sub_10052290(a1, v3 != 0, &v6, &v7);
  if ( (_BYTE)v4 == 1 )
  {
    v4 = sub_1003D620(v6);
    if ( (unsigned __int16)v7 < v4 )
      LOBYTE(v4) = sub_1003DDF0(v6, v7, &a2, 0, 1, 1);
  }
  return v4;
}

//----- (10038DD0) --------------------------------------------------------
bool __cdecl sub_10038DD0(unsigned __int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  bool v3; // ST0C_1@1

  v3 = sub_10045170(v2) != 0;
  return sub_10038C00(a1, a2, v3);
}

//----- (10038E00) --------------------------------------------------------
int __cdecl sub_10038E00(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= *(_WORD *)&word_100B97FE[2 * *(_BYTE *)a1] );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - word_100B97FE[2 * *(_BYTE *)a1];
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}

//----- (10038EF0) --------------------------------------------------------
int __cdecl sub_10038EF0(int *a1, unsigned int a2)
{
  int result; // eax@1
  int v3; // eax@9
  int v4; // ecx@9
  signed int v5; // eax@9
  int i; // ecx@9
  int v7; // ecx@13

  result = a2 >> 16;
  if ( HIWORD(a2) > 0x7C5u )
  {
    if ( HIWORD(a2) > 0x84Eu
      || HIWORD(a2) == 2126 && (unsigned __int8)a2 > 2u
      || HIWORD(a2) == 2126 && (_BYTE)a2 == 2 && BYTE1(a2) > 5u )
    {
      *a1 = -23296;
    }
    else
    {
      v3 = (HIWORD(a2) - 1990) / 4;
      v4 = v3;
      v5 = 4 * v3 + 1990;
      for ( i = 1461 * v4; v5 < HIWORD(a2); ++v5 )
      {
        i += 365;
        if ( !(v5 % 4) )
          ++i;
      }
      v7 = *(_WORD *)&word_100B97FE[2 * (unsigned __int8)a2] + i;
      if ( (unsigned __int8)a2 > 2u && !(HIWORD(a2) % 4) )
        ++v7;
      result = 86400 * (v7 + BYTE1(a2));
      *a1 = result;
    }
  }
  else
  {
    result = (int)a1;
    *a1 = 0;
  }
  return result;
}

//----- (10038FE0) --------------------------------------------------------
__int16 __cdecl sub_10038FE0(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (10039030) --------------------------------------------------------
int __cdecl sub_10039030(int *a1, unsigned int a2)
{
  int result; // eax@1

  result = (a2 >> 24) + 60 * ((unsigned __int8)(a2 >> 16) + 60 * (unsigned __int16)a2);
  *a1 = result;
  return result;
}

//----- (10039060) --------------------------------------------------------
__int16 __cdecl sub_10039060(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_10038FE0((int)&v5, *a1);
  sub_10038E00((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (100390E0) --------------------------------------------------------
char __cdecl sub_100390E0(void *a1)
{
  void *v1; // ebp@1
  signed int v2; // ebx@1
  char result; // al@2
  char *v4; // edi@2
  char v5; // [sp+10h] [bp-CD0h]@2
  char v6; // [sp+28h] [bp-CB8h]@2

  v1 = a1;
  memset(a1, 0, 0x58D0u);
  v2 = 0;
  do
  {
    result = sub_1003B750(v2, &v5);
    v4 = (char *)v1;
    ++v2;
    v1 = (char *)v1 + 3248;
    qmemcpy(v4, &v6, 0xCB0u);
  }
  while ( v2 < 7 );
  return result;
}

//----- (10039160) --------------------------------------------------------
char __cdecl sub_10039160(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_10036E70(13, (char *)&v3 + 3);
  sub_10036E70(12, a1);
  return BYTE3(v3);
}

//----- (10039190) --------------------------------------------------------
char __cdecl sub_10039190(int a1)
{
  void *v1; // ecx@1
  char v2; // bl@1
  unsigned int v4; // [sp+4h] [bp-4h]@1

  v2 = sub_10039160((char *)&v4);
  if ( v2 )
  {
    if ( sub_10036D40(v1) == 1 )
      sub_1003F730((int *)&v4, v4);
    sub_10038E00(a1, v4);
  }
  return v2;
}

//----- (100391E0) --------------------------------------------------------
unsigned int __cdecl sub_100391E0(int a1, int a2, size_t a3, int a4, int a5)
{
  int v5; // ecx@1
  unsigned int result; // eax@1
  int v7; // ebp@4
  int v8; // ebx@4
  int v9; // esi@6
  char *v10; // ebx@7
  char *v11; // [sp+0h] [bp-190h]@5
  char *v12; // [sp+4h] [bp-18Ch]@7
  char *v13; // [sp+8h] [bp-188h]@5
  int v14; // [sp+10h] [bp-180h]@4
  int v15; // [sp+14h] [bp-17Ch]@3
  size_t v16; // [sp+1Ch] [bp-174h]@5
  char v17; // [sp+24h] [bp-16Ch]@6

  v5 = a1;
  result = a4;
  if ( a1 && (signed int)a3 <= 360 )
  {
    result = 0;
    v15 = 0;
    do
    {
      v7 = *(int *)((char *)&dword_100BA268 + result);
      v8 = *(int *)((char *)&dword_100BA268 + result);
      v14 = *(int *)((char *)&dword_100BA268 + result);
      if ( v7 < a2 )
      {
        v16 = a3 * v7;
        v11 = (char *)(v5 + a3 * v7);
        v13 = (char *)v5;
        do
        {
          memcpy_0(&v17, v11, a3);
          v9 = v8;
          if ( v8 >= v7 )
          {
            v10 = v13;
            v12 = v11;
            do
            {
              if ( ((int (__cdecl *)(char *, char *, int))a4)(&v17, v10, a5) >= 0 )
                break;
              memcpy_0(v12, v10, a3);
              v12 -= v16;
              v9 -= v7;
              v10 -= v16;
            }
            while ( v9 >= v7 );
            v8 = v14;
          }
          memcpy_0((void *)(a1 + a3 * v9), &v17, a3);
          v11 += a3;
          v13 += a3;
          v14 = ++v8;
        }
        while ( v8 < a2 );
        result = v15;
        v5 = a1;
      }
      result += 4;
      v15 = result;
    }
    while ( result < 0x40 );
  }
  return result;
}
// 100BA268: using guessed type int dword_100BA268;

//----- (10039360) --------------------------------------------------------
unsigned int __cdecl sub_10039360(int a1, int a2, size_t a3, int a4)
{
  return sub_100391E0(a1, a2, a3, (int)sub_10039340, a4);
}
// 10039340: using guessed type int sub_10039340();

//----- (10039390) --------------------------------------------------------
int __cdecl sub_10039390(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 1006B9D0: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (10039400) --------------------------------------------------------
bool __cdecl sub_10039400(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_10038600(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_100BA7F8[(unsigned __int8)v4](v3) )
    {
      sub_10039390((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_10039640(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_1003D620(2) )
    result = 0;
  else
    result = sub_1003E2C0(2, v5, a2) == 1 && !sub_100527A0(a2);
  return result;
}
// 100BA7F8: using guessed type int (__cdecl *off_100BA7F8[3])(char);

//----- (100394C0) --------------------------------------------------------
char __cdecl sub_100394C0(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_10039400(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_10039620(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (10039580) --------------------------------------------------------
void sub_10039580()
{
  dword_10673E64 = -15;
}
// 10673E64: using guessed type int dword_10673E64;

//----- (10039590) --------------------------------------------------------
signed int sub_10039590()
{
  return sub_1006C8D0((int)&off_100BA804);
}
// 100BA804: using guessed type char *off_100BA804;

//----- (100395A0) --------------------------------------------------------
signed int __cdecl sub_100395A0(char *a1)
{
  signed int result; // eax@1
  char v2; // [sp+10h] [bp-B8h]@1

  memset(&v2, 0, 0xB0u);
  result = sub_10039590();
  if ( (_BYTE)result == 1 )
    qmemcpy(&v2, (const void *)dword_10673E64, 0xB0u);
  qmemcpy(a1, &v2, 0xB0u);
  return result;
}
// 10673E64: using guessed type int dword_10673E64;

//----- (10039610) --------------------------------------------------------
signed int __fastcall sub_10039610(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (10039620) --------------------------------------------------------
char __cdecl sub_10039620(unsigned __int8 a1)
{
  return byte_100BA81C[6 * sub_10039610(a1)];
}

//----- (10039640) --------------------------------------------------------
__int16 __cdecl sub_10039640(unsigned __int8 a1)
{
  return word_100BA818[3 * sub_10039610(a1)];
}
// 100BA818: using guessed type __int16 word_100BA818[];

//----- (10039660) --------------------------------------------------------
__int16 __cdecl sub_10039660(unsigned __int8 a1)
{
  return word_100BA81A[3 * sub_10039610(a1)];
}
// 100BA81A: using guessed type __int16 word_100BA81A[];

//----- (10039680) --------------------------------------------------------
bool __cdecl sub_10039680(unsigned __int8 a1)
{
  return sub_10039660(a1) != 904;
}

//----- (100396A0) --------------------------------------------------------
char __cdecl sub_100396A0(bool *a1)
{
  unsigned __int8 v1; // bl@1
  unsigned __int16 *v2; // esi@1
  signed int v3; // edi@4
  void *v4; // ecx@5
  char v5; // al@9
  void *v6; // ecx@13
  char v8; // [sp+1h] [bp-Bh]@1
  char v9; // [sp+2h] [bp-Ah]@1
  unsigned __int8 v10; // [sp+3h] [bp-9h]@1
  unsigned __int8 v11; // [sp+4h] [bp-8h]@1
  bool v12; // [sp+5h] [bp-7h]@1
  char v13; // [sp+6h] [bp-6h]@6
  bool v14; // [sp+7h] [bp-5h]@1
  float v15; // [sp+8h] [bp-4h]@1

  v14 = (unsigned __int8)sub_1003EFC0() > 1u;
  v1 = 0;
  v12 = sub_10044160(&v15);
  v8 = 1;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v2 = (unsigned __int16 *)&unk_100BB1F0;
  if ( sub_10038C80(0x2E6u) || sub_10038C80(0x2E7u) )
    v2 = (unsigned __int16 *)&unk_100BB1E8;
  v3 = 4;
  do
  {
    if ( sub_10038C80(*v2) && sub_10038DD0(*v2, &v13) )
    {
      v10 += v13;
      ++v1;
      LOBYTE(v4) = v13 == 0;
      v11 += v13 == 0;
    }
    ++v2;
    --v3;
  }
  while ( v3 );
  v5 = byte_100BB1F8[v1];
  if ( v10 >= (unsigned __int8)v5 )
    goto LABEL_20;
  if ( v11 >= (unsigned __int8)v5 )
    goto LABEL_19;
  if ( v14 )
  {
    if ( !sub_1003EFF0() )
    {
      if ( !v12 )
        goto LABEL_20;
      goto LABEL_18;
    }
LABEL_19:
    v8 = 1;
LABEL_21:
    v9 = 1;
    goto LABEL_22;
  }
  if ( v12 )
  {
LABEL_18:
    if ( v15 > 25.72207 )
      goto LABEL_19;
LABEL_20:
    v8 = 0;
    goto LABEL_21;
  }
  if ( sub_10036FE0(v4) == 2 || sub_10036FE0(v6) == 8 )
  {
    *a1 = 1;
    return 0;
  }
LABEL_22:
  *a1 = v8 == 0;
  return v9;
}

//----- (100397E0) --------------------------------------------------------
char __cdecl sub_100397E0(char a1)
{
  char v1; // bl@1
  char result; // al@4

  v1 = a1;
  sub_1006BA40(69, &a1);
  if ( a1 && (v1 == 15 || v1 == 13) )
    result = 17;
  else
    result = v1;
  return result;
}

//----- (10039810) --------------------------------------------------------
signed int __cdecl sub_10039810(signed int a1)
{
  signed int v1; // esi@1
  signed int result; // eax@4

  v1 = a1;
  sub_1006BA40(69, &a1);
  if ( (_BYTE)a1 && (v1 == -1 || v1 == -4144960) )
    result = -11250604;
  else
    result = v1;
  return result;
}

//----- (10039850) --------------------------------------------------------
char __cdecl sub_10039850(int a1)
{
  char result; // al@1
  int v2; // edx@3
  char v3; // [sp+4h] [bp-5BCh]@1
  int v4; // [sp+9h] [bp-5B7h]@3
  int v5; // [sp+Dh] [bp-5B3h]@3

  sub_10052A40(&v3);
  *(_BYTE *)a1 = 0;
  result = 0;
  if ( *(_BYTE *)dword_10789FA0 != 63 )
  {
    if ( v3 )
    {
      v2 = v4;
      *(_DWORD *)(a1 + 4) = v5;
      *(_DWORD *)a1 = v2;
      *(_BYTE *)(a1 + 4) = 46;
      result = 1;
    }
  }
  return result;
}
// 10789FA0: using guessed type int dword_10789FA0;

//----- (100398C0) --------------------------------------------------------
int __cdecl sub_100398C0(char *a1, char *a2)
{
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  char v4; // al@2
  int result; // eax@4

  v2 = strstr(a1, a2);
  v3 = strlen(a2);
  result = 0;
  if ( v2 )
  {
    v4 = v2[v3];
    if ( !v4 || v4 == 44 )
      result = 1;
  }
  return result;
}

//----- (10039900) --------------------------------------------------------
void *__usercall sub_10039900@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@0
  int v5; // [sp+4h] [bp-8h]@0
  int v6; // [sp+8h] [bp-4h]@0

  result = (void *)sub_1006A0A0(v4, v5, v6);
  if ( a2 == 6011 )
  {
    if ( result || *(_BYTE *)a3 > 0x3Fu )
    {
      *(_BYTE *)a3 = 63;
      result = (void *)sub_1006A210(6011, (int)a3, a1);
    }
  }
  else if ( result )
  {
    result = memset(a3, 204, a1);
  }
  return result;
}

//----- (10039950) --------------------------------------------------------
signed int sub_10039950()
{
  int v0; // edi@5
  void *v1; // esi@5
  signed int v2; // ebp@5
  signed int result; // eax@7
  char v4; // [sp+13h] [bp-1h]@1

  dword_10789FA0 = 0;
  v4 = 0;
  sub_1006BA40(94, &v4);
  if ( v4 == 3 )
  {
    v4 = 1;
    sub_1006A190(3201, (int)&v4, 1);
    sub_1006BA70(94, (int)&v4);
  }
  else if ( v4 == 2 )
  {
    v4 = 0;
    sub_1006A190(3201, (int)&v4, 1);
    sub_1006BA70(94, (int)&v4);
  }
  sub_10039900(1u, 6011, &unk_10673E68);
  sub_10039900(0x16u, 6194, &unk_10673E69);
  sub_10039900(1u, 6012, &unk_10673E7F);
  sub_10039900(1u, 6013, &unk_10673E80);
  sub_10039900(1u, 6014, &unk_10673E81);
  sub_10039900(1u, 6015, &unk_10673E82);
  sub_10039900(4u, 6078, &unk_10673E84);
  sub_10039900(4u, 6104, &unk_10673E88);
  sub_10039900(0x20u, 6016, &unk_10673E8C);
  sub_10039900(0x20u, 6017, &unk_10673EAC);
  sub_10039900(0x20u, 6018, &unk_10673ECC);
  sub_10039900(0x20u, 6019, &unk_10673EEC);
  sub_10039900(0x20u, 6020, &unk_10673F0C);
  sub_10039900(0x20u, 6021, &unk_10673F2C);
  sub_10039900(0x20u, 6022, &unk_10673F4C);
  sub_10039900(0x20u, 6023, &unk_10673F6C);
  sub_10039900(0x20u, 6024, &unk_10673F8C);
  sub_10039900(0x20u, 6025, &unk_10673FAC);
  sub_10039900(0x20u, 6026, &unk_10673FCC);
  sub_10039900(0x20u, 6027, &unk_10673FEC);
  sub_10039900(0x20u, 6028, &unk_1067400C);
  sub_10039900(0x20u, 6029, &unk_1067402C);
  sub_10039900(0x20u, 6030, &unk_1067404C);
  sub_10039900(0x20u, 6031, &unk_1067406C);
  sub_10039900(0x20u, 6032, &unk_1067408C);
  sub_10039900(0x20u, 6033, &unk_106740AC);
  sub_10039900(0x20u, 6034, &unk_106740CC);
  sub_10039900(0x20u, 6035, &unk_106740EC);
  sub_10039900(0x20u, 6036, &unk_1067410C);
  sub_10039900(0x20u, 6037, &unk_1067412C);
  sub_10039900(0x20u, 6038, &unk_1067414C);
  sub_10039900(0x20u, 6039, &unk_1067416C);
  sub_10039900(0x20u, 6040, &unk_1067418C);
  sub_10039900(0x20u, 6041, &unk_106741AC);
  sub_10039900(0x20u, 6042, &unk_106741CC);
  sub_10039900(0x20u, 6043, &unk_106741EC);
  sub_10039900(4u, 6044, &unk_1067420C);
  sub_10039900(4u, 6045, &unk_10674210);
  sub_10039900(4u, 6046, &unk_10674214);
  sub_10039900(4u, 6357, &unk_10674218);
  sub_10039900(4u, 6358, &unk_1067421C);
  sub_10039900(4u, 6359, &unk_10674220);
  sub_10039900(0x20u, 6047, &unk_10674224);
  sub_10039900(0x20u, 6048, &unk_10674244);
  sub_10039900(0x20u, 6049, &unk_10674264);
  sub_10039900(0x20u, 6050, &unk_10674284);
  sub_10039900(0x20u, 6051, &unk_106742A4);
  sub_10039900(0x20u, 6052, &unk_106742C4);
  sub_10039900(0x20u, 6053, &unk_106742E4);
  sub_10039900(0x20u, 6054, &unk_10674304);
  sub_10039900(1u, 6511, &unk_10674324);
  sub_10039900(1u, 6522, &unk_10674325);
  sub_10039900(1u, 6057, &unk_10674326);
  sub_10039900(0x20u, 6075, &unk_10674378);
  sub_10039900(0x20u, 6076, &unk_10674398);
  sub_10039900(1u, 6077, &unk_106743B8);
  sub_10039900(4u, 6079, &unk_106743BC);
  sub_10039900(4u, 6080, &unk_106743C0);
  sub_10039900(0x20u, 6082, &unk_106743C4);
  sub_10039900(0x20u, 6083, &unk_106743E4);
  sub_10039900(0x20u, 6084, &unk_10674404);
  sub_10039900(0x20u, 6085, &unk_10674424);
  sub_10039900(0x20u, 6086, &unk_10674444);
  sub_10039900(0x20u, 6087, &unk_10674464);
  sub_10039900(0x20u, 6088, &unk_10674484);
  sub_10039900(0x20u, 6089, &unk_106744A4);
  sub_10039900(0x20u, 6123, &unk_106744C4);
  sub_10039900(0x48u, 6906, &unk_106744E4);
  sub_10039900(0x48u, 6907, &unk_1067452C);
  sub_10039900(0x48u, 6908, &unk_10674574);
  sub_10039900(0x48u, 6909, &unk_106745BC);
  sub_10039900(0x48u, 6910, &unk_10674604);
  sub_10039900(0x48u, 6911, &unk_1067464C);
  sub_10039900(0x48u, 6912, &unk_10674694);
  sub_10039900(0x48u, 6913, &unk_106746DC);
  sub_10039900(0x48u, 6914, &unk_10674724);
  sub_10039900(0x48u, 6915, &unk_1067476C);
  sub_10039900(0x48u, 6916, &unk_106747B4);
  sub_10039900(0x48u, 6917, &unk_106747FC);
  sub_10039900(0x48u, 6918, &unk_10674844);
  sub_10039900(0x48u, 6919, &unk_1067488C);
  sub_10039900(0x48u, 6920, &unk_106748D4);
  sub_10039900(0x48u, 6921, &unk_1067491C);
  sub_10039900(0x48u, 6922, &unk_10674964);
  sub_10039900(0x48u, 6923, &unk_106749AC);
  sub_10039900(0x48u, 6924, &unk_106749F4);
  sub_10039900(0x48u, 6925, &unk_10674A3C);
  sub_10039900(0x48u, 6926, &unk_10674A84);
  sub_10039900(0x48u, 6927, &unk_10674ACC);
  sub_10039900(0x48u, 6928, &unk_10674B14);
  sub_10039900(0x48u, 6929, &unk_10674B5C);
  sub_10039900(0x48u, 6930, &unk_10674BA4);
  sub_10039900(0x48u, 6931, &unk_10674BEC);
  sub_10039900(0x48u, 6932, &unk_10674C34);
  sub_10039900(0x48u, 6933, &unk_10674C7C);
  sub_10039900(0x48u, 6934, &unk_10674CC4);
  sub_10039900(0x48u, 6935, &unk_10674D0C);
  sub_10039900(0x18u, 6163, &unk_10674D54);
  sub_10039900(0x20u, 6164, &unk_10674D6C);
  sub_10039900(0x20u, 6165, &unk_10674D8C);
  sub_10039900(2u, 6166, &unk_10674DAC);
  sub_10039900(0xA4u, 40100, &unk_10674DB0);
  sub_10039900(0xA4u, 40101, &unk_10674E54);
  sub_10039900(0xA4u, 40102, &unk_10674EF8);
  sub_10039900(0xA4u, 40103, &unk_10674F9C);
  sub_10039900(0xA4u, 40104, &unk_10675040);
  sub_10039900(0xA4u, 40105, &unk_106750E4);
  sub_10039900(0xA4u, 40106, &unk_10675188);
  sub_10039900(0xA4u, 40107, &unk_1067522C);
  sub_10039900(0xA4u, 40108, &unk_106752D0);
  sub_10039900(0xA4u, 40109, &unk_10675374);
  sub_10039900(0xA4u, 40110, &unk_10675418);
  sub_10039900(0xA4u, 40111, &unk_106754BC);
  sub_10039900(0xA4u, 40112, &unk_10675560);
  sub_10039900(0xA4u, 40113, &unk_10675604);
  sub_10039900(0xA4u, 40114, &unk_106756A8);
  sub_10039900(0xA4u, 40115, &unk_1067574C);
  sub_10039900(0xA4u, 40116, &unk_106757F0);
  sub_10039900(0xA4u, 40117, &unk_10675894);
  sub_10039900(0xA4u, 40118, &unk_10675938);
  sub_10039900(0xA4u, 40119, &unk_106759DC);
  sub_10039900(0xA4u, 40120, &unk_10675A80);
  sub_10039900(0xA4u, 40121, &unk_10675B24);
  sub_10039900(0xA4u, 40122, &unk_10675BC8);
  sub_10039900(0xA4u, 40123, &unk_10675C6C);
  sub_10039900(0xA4u, 40124, &unk_10675D10);
  sub_10039900(0xA4u, 40125, &unk_10675DB4);
  sub_10039900(0xA4u, 40126, &unk_10675E58);
  sub_10039900(0xA4u, 40127, &unk_10675EFC);
  sub_10039900(0xA4u, 40128, &unk_10675FA0);
  sub_10039900(0xA4u, 40129, &unk_10676044);
  sub_10039900(0xA4u, 40130, &unk_106760E8);
  sub_10039900(0xA4u, 40131, &unk_1067618C);
  sub_10039900(0xA4u, 40132, &unk_10676230);
  sub_10039900(0xA4u, 40133, &unk_106762D4);
  sub_10039900(0xA4u, 40134, &unk_10676378);
  sub_10039900(0xA4u, 40135, &unk_1067641C);
  sub_10039900(0xA4u, 40136, &unk_106764C0);
  sub_10039900(0xA4u, 40137, &unk_10676564);
  sub_10039900(0xA4u, 40138, &unk_10676608);
  sub_10039900(0xA4u, 40139, &unk_106766AC);
  sub_10039900(0xA4u, 40140, &unk_10676750);
  sub_10039900(0xA4u, 40141, &unk_106767F4);
  sub_10039900(0xA4u, 40142, &unk_10676898);
  sub_10039900(0xA4u, 40143, &unk_1067693C);
  sub_10039900(0xA4u, 40144, &unk_106769E0);
  sub_10039900(0xA4u, 40145, &unk_10676A84);
  sub_10039900(0xA4u, 40146, &unk_10676B28);
  sub_10039900(0xA4u, 40147, &unk_10676BCC);
  sub_10039900(0xA4u, 40148, &unk_10676C70);
  sub_10039900(0xA4u, 40149, &unk_10676D14);
  sub_10039900(0xA4u, 40150, &unk_10676DB8);
  sub_10039900(0xA4u, 40151, &unk_10676E5C);
  sub_10039900(0xA4u, 40152, &unk_10676F00);
  sub_10039900(0xA4u, 40153, &unk_10676FA4);
  sub_10039900(0xA4u, 40154, &unk_10677048);
  sub_10039900(0xA4u, 40155, &unk_106770EC);
  sub_10039900(0xA4u, 40156, &unk_10677190);
  sub_10039900(0xA4u, 40157, &unk_10677234);
  sub_10039900(0xA4u, 40158, &unk_106772D8);
  sub_10039900(0xA4u, 40159, &unk_1067737C);
  sub_10039900(0xA4u, 40160, &unk_10677420);
  sub_10039900(0xA4u, 40161, &unk_106774C4);
  sub_10039900(0xA4u, 40162, &unk_10677568);
  sub_10039900(0xA4u, 40163, &unk_1067760C);
  sub_10039900(0xA4u, 40164, &unk_106776B0);
  sub_10039900(0xA4u, 40165, &unk_10677754);
  sub_10039900(0xA4u, 40166, &unk_106777F8);
  sub_10039900(0xA4u, 40167, &unk_1067789C);
  sub_10039900(0xA4u, 40168, &unk_10677940);
  sub_10039900(0xA4u, 40169, &unk_106779E4);
  sub_10039900(0xA4u, 40170, &unk_10677A88);
  sub_10039900(0xA4u, 40171, &unk_10677B2C);
  sub_10039900(0xA4u, 40172, &unk_10677BD0);
  sub_10039900(0xA4u, 40173, &unk_10677C74);
  sub_10039900(0xA4u, 40174, &unk_10677D18);
  sub_10039900(0xA4u, 40175, &unk_10677DBC);
  sub_10039900(0xA4u, 40176, &unk_10677E60);
  sub_10039900(0xA4u, 40177, &unk_10677F04);
  sub_10039900(0xA4u, 40178, &unk_10677FA8);
  sub_10039900(0xA4u, 40179, &unk_1067804C);
  sub_10039900(0xA4u, 40180, &unk_106780F0);
  sub_10039900(0xA4u, 40181, &unk_10678194);
  sub_10039900(0xA4u, 40182, &unk_10678238);
  sub_10039900(0xA4u, 40183, &unk_106782DC);
  sub_10039900(0xA4u, 40184, &unk_10678380);
  sub_10039900(0xA4u, 40185, &unk_10678424);
  sub_10039900(0xA4u, 40186, &unk_106784C8);
  sub_10039900(0xA4u, 40187, &unk_1067856C);
  sub_10039900(0xA4u, 40188, &unk_10678610);
  sub_10039900(0xA4u, 40189, &unk_106786B4);
  sub_10039900(0xA4u, 40190, &unk_10678758);
  sub_10039900(0xA4u, 40191, &unk_106787FC);
  sub_10039900(0xA4u, 40192, &unk_106788A0);
  sub_10039900(0xA4u, 40193, &unk_10678944);
  sub_10039900(0xA4u, 40194, &unk_106789E8);
  sub_10039900(0xA4u, 40195, &unk_10678A8C);
  sub_10039900(0xA4u, 40196, &unk_10678B30);
  sub_10039900(0xA4u, 40197, &unk_10678BD4);
  sub_10039900(0xA4u, 40198, &unk_10678C78);
  sub_10039900(0xA4u, 40199, &unk_10678D1C);
  sub_10039900(0x20u, 6190, &unk_10678DC0);
  sub_10039900(0x20u, 6191, &unk_10678DE0);
  sub_10039900(0x20u, 6192, &unk_10678E00);
  sub_10039900(0x20u, 6199, &unk_10678E20);
  sub_10039900(0x28u, 6207, &unk_10678E40);
  sub_10039900(4u, 6231, &unk_10679958);
  sub_10039900(4u, 6232, &unk_1067995C);
  sub_10039900(4u, 6233, &unk_10679960);
  sub_10039900(4u, 6234, &unk_10679964);
  sub_10039900(0x1Cu, 40000, &unk_10678E68);
  sub_10039900(0x1Cu, 40001, &unk_10678E84);
  sub_10039900(0x1Cu, 40002, &unk_10678EA0);
  sub_10039900(0x1Cu, 40003, &unk_10678EBC);
  sub_10039900(0x1Cu, 40004, &unk_10678ED8);
  sub_10039900(0x1Cu, 40005, &unk_10678EF4);
  sub_10039900(0x1Cu, 40006, &unk_10678F10);
  sub_10039900(0x1Cu, 40007, &unk_10678F2C);
  sub_10039900(0x1Cu, 40008, &unk_10678F48);
  sub_10039900(0x1Cu, 40009, &unk_10678F64);
  sub_10039900(0x1Cu, 40010, &unk_10678F80);
  sub_10039900(0x1Cu, 40011, &unk_10678F9C);
  sub_10039900(0x1Cu, 40012, &unk_10678FB8);
  sub_10039900(0x1Cu, 40013, &unk_10678FD4);
  sub_10039900(0x1Cu, 40014, &unk_10678FF0);
  sub_10039900(0x1Cu, 40015, &unk_1067900C);
  sub_10039900(0x1Cu, 40016, &unk_10679028);
  sub_10039900(0x1Cu, 40017, &unk_10679044);
  sub_10039900(0x1Cu, 40018, &unk_10679060);
  sub_10039900(0x1Cu, 40019, &unk_1067907C);
  sub_10039900(0x1Cu, 40020, &unk_10679098);
  sub_10039900(0x1Cu, 40021, &unk_106790B4);
  sub_10039900(0x1Cu, 40022, &unk_106790D0);
  sub_10039900(0x1Cu, 40023, &unk_106790EC);
  sub_10039900(0x1Cu, 40024, &unk_10679108);
  sub_10039900(0x1Cu, 40025, &unk_10679124);
  sub_10039900(0x1Cu, 40026, &unk_10679140);
  sub_10039900(0x1Cu, 40027, &unk_1067915C);
  sub_10039900(0x1Cu, 40028, &unk_10679178);
  sub_10039900(0x1Cu, 40029, &unk_10679194);
  sub_10039900(0x1Cu, 40030, &unk_106791B0);
  sub_10039900(0x1Cu, 40031, &unk_106791CC);
  sub_10039900(0x1Cu, 40032, &unk_106791E8);
  sub_10039900(0x1Cu, 40033, &unk_10679204);
  sub_10039900(0x1Cu, 40034, &unk_10679220);
  sub_10039900(0x1Cu, 40035, &unk_1067923C);
  sub_10039900(0x1Cu, 40036, &unk_10679258);
  sub_10039900(0x1Cu, 40037, &unk_10679274);
  sub_10039900(0x1Cu, 40038, &unk_10679290);
  sub_10039900(0x1Cu, 40039, &unk_106792AC);
  sub_10039900(0x1Cu, 40040, &unk_106792C8);
  sub_10039900(0x1Cu, 40041, &unk_106792E4);
  sub_10039900(0x1Cu, 40042, &unk_10679300);
  sub_10039900(0x1Cu, 40043, &unk_1067931C);
  sub_10039900(0x1Cu, 40044, &unk_10679338);
  sub_10039900(0x1Cu, 40045, &unk_10679354);
  sub_10039900(0x1Cu, 40046, &unk_10679370);
  sub_10039900(0x1Cu, 40047, &unk_1067938C);
  sub_10039900(0x1Cu, 40048, &unk_106793A8);
  sub_10039900(0x1Cu, 40049, &unk_106793C4);
  sub_10039900(0x1Cu, 40050, &unk_106793E0);
  sub_10039900(0x1Cu, 40051, &unk_106793FC);
  sub_10039900(0x1Cu, 40052, &unk_10679418);
  sub_10039900(0x1Cu, 40053, &unk_10679434);
  sub_10039900(0x1Cu, 40054, &unk_10679450);
  sub_10039900(0x1Cu, 40055, &unk_1067946C);
  sub_10039900(0x1Cu, 40056, &unk_10679488);
  sub_10039900(0x1Cu, 40057, &unk_106794A4);
  sub_10039900(0x1Cu, 40058, &unk_106794C0);
  sub_10039900(0x1Cu, 40059, &unk_106794DC);
  sub_10039900(0x1Cu, 40060, &unk_106794F8);
  sub_10039900(0x1Cu, 40061, &unk_10679514);
  sub_10039900(0x1Cu, 40062, &unk_10679530);
  sub_10039900(0x1Cu, 40063, &unk_1067954C);
  sub_10039900(0x1Cu, 40064, &unk_10679568);
  sub_10039900(0x1Cu, 40065, &unk_10679584);
  sub_10039900(0x1Cu, 40066, &unk_106795A0);
  sub_10039900(0x1Cu, 40067, &unk_106795BC);
  sub_10039900(0x1Cu, 40068, &unk_106795D8);
  sub_10039900(0x1Cu, 40069, &unk_106795F4);
  sub_10039900(0x1Cu, 40070, &unk_10679610);
  sub_10039900(0x1Cu, 40071, &unk_1067962C);
  sub_10039900(0x1Cu, 40072, &unk_10679648);
  sub_10039900(0x1Cu, 40073, &unk_10679664);
  sub_10039900(0x1Cu, 40074, &unk_10679680);
  sub_10039900(0x1Cu, 40075, &unk_1067969C);
  sub_10039900(0x1Cu, 40076, &unk_106796B8);
  sub_10039900(0x1Cu, 40077, &unk_106796D4);
  sub_10039900(0x1Cu, 40078, &unk_106796F0);
  sub_10039900(0x1Cu, 40079, &unk_1067970C);
  sub_10039900(0x1Cu, 40080, &unk_10679728);
  sub_10039900(0x1Cu, 40081, &unk_10679744);
  sub_10039900(0x1Cu, 40082, &unk_10679760);
  sub_10039900(0x1Cu, 40083, &unk_1067977C);
  sub_10039900(0x1Cu, 40084, &unk_10679798);
  sub_10039900(0x1Cu, 40085, &unk_106797B4);
  sub_10039900(0x1Cu, 40086, &unk_106797D0);
  sub_10039900(0x1Cu, 40087, &unk_106797EC);
  sub_10039900(0x1Cu, 40088, &unk_10679808);
  sub_10039900(0x1Cu, 40089, &unk_10679824);
  sub_10039900(0x1Cu, 40090, &unk_10679840);
  sub_10039900(0x1Cu, 40091, &unk_1067985C);
  sub_10039900(0x1Cu, 40092, &unk_10679878);
  sub_10039900(0x1Cu, 40093, &unk_10679894);
  sub_10039900(0x1Cu, 40094, &unk_106798B0);
  sub_10039900(0x1Cu, 40095, &unk_106798CC);
  sub_10039900(0x1Cu, 40096, &unk_106798E8);
  sub_10039900(0x1Cu, 40097, &unk_10679904);
  sub_10039900(0x1Cu, 40098, &unk_10679920);
  sub_10039900(0x1Cu, 40099, &unk_1067993C);
  sub_10039900(4u, 6238, &unk_10679968);
  sub_10039900(4u, 6239, &unk_1067996C);
  sub_10039900(4u, 6240, &unk_10679970);
  sub_10039900(4u, 6242, &unk_10679974);
  sub_10039900(4u, 6244, &unk_10679978);
  sub_10039900(4u, 6245, &unk_1067997C);
  sub_10039900(4u, 6246, &unk_10679980);
  sub_10039900(4u, 6251, &unk_10679984);
  sub_10039900(4u, 6252, &unk_10679988);
  sub_10039900(4u, 6253, &unk_1067998C);
  sub_10039900(4u, 6254, &unk_10679990);
  sub_10039900(1u, 6255, &unk_10679994);
  sub_10039900(4u, 6256, &unk_10679998);
  sub_10039900(4u, 6257, &unk_1067999C);
  sub_10039900(0xE2u, 6286, &unk_106799A0);
  v0 = 18000;
  v1 = &unk_10679A84;
  v2 = 16;
  do
  {
    sub_10039900(0x11Cu, v0, v1);
    v1 = (char *)v1 + 284;
    ++v0;
    --v2;
  }
  while ( v2 );
  sub_10039900(4u, 6262, &unk_1067AC44);
  sub_10039900(0x28u, 6263, &unk_1067AC48);
  sub_10039900(0x28u, 6264, &unk_1067AC70);
  sub_10039900(0x40u, 6268, &unk_1067AC98);
  sub_10039900(4u, 6272, &unk_1067AD58);
  sub_10039900(4u, 6273, &unk_1067AD5C);
  sub_10039900(1u, 6274, &unk_1067AD60);
  sub_10039900(2u, 6275, &unk_1067AD62);
  sub_10039900(1u, 6276, &unk_1067AD64);
  sub_10039900(1u, 6277, &unk_1067AD65);
  sub_10039900(1u, 6278, &unk_1067AD66);
  sub_10039900(0x40u, 6279, &unk_1067AD68);
  sub_10039900(0x28u, 6753, &unk_1067BC1D);
  sub_10039900(0x30u, 6754, &unk_1067BC48);
  sub_10039900(0x28u, 6958, &unk_1067BC78);
  sub_10039900(0x80u, 6802, &unk_1067ACD8);
  sub_10039900(1u, 6760, &unk_1067BCA0);
  sub_10039900(0x10u, 6312, &unk_1067B0EC);
  sub_10039900(0x10u, 6313, &unk_1067B0FC);
  sub_10039900(0x10u, 6314, &unk_1067B10C);
  sub_10039900(1u, 6307, &unk_1067B11C);
  sub_10039900(1u, 6308, &unk_1067B11D);
  sub_10039900(1u, 6309, &unk_1067B11E);
  sub_10039900(4u, 6285, &unk_1067B120);
  sub_10039900(0xA8u, 6318, &unk_1067B124);
  sub_10039900(4u, 6319, &unk_1067B1CC);
  sub_10039900(1u, 6350, &unk_1067B1D0);
  sub_10039900(0x50u, 6351, &unk_1067B1D4);
  sub_10039900(4u, 6352, &unk_1067B224);
  sub_10039900(4u, 6353, &unk_1067B228);
  sub_10039900(0x54u, 6448, &unk_1067B474);
  sub_10039900(0x54u, 6449, &unk_1067B4C8);
  sub_10039900(8u, 6287, &unk_1067ADCC);
  sub_10039900(8u, 6288, &unk_1067ADD4);
  sub_10039900(8u, 6289, &unk_1067ADDC);
  sub_10039900(8u, 6290, &unk_1067ADE4);
  sub_10039900(8u, 6291, &unk_1067ADEC);
  sub_10039900(8u, 6292, &unk_1067ADF4);
  sub_10039900(8u, 6293, &unk_1067ADFC);
  sub_10039900(8u, 6294, &unk_1067AE04);
  sub_10039900(8u, 6295, &unk_1067AE0C);
  sub_10039900(8u, 6296, &unk_1067AE14);
  sub_10039900(8u, 6297, &unk_1067AE1C);
  sub_10039900(8u, 6298, &unk_1067AE24);
  sub_10039900(8u, 6299, &unk_1067AE2C);
  sub_10039900(8u, 6300, &unk_1067AE34);
  sub_10039900(8u, 6301, &unk_1067AE3C);
  sub_10039900(8u, 6302, &unk_1067AE44);
  sub_10039900(8u, 6303, &unk_1067AE4C);
  sub_10039900(8u, 6304, &unk_1067AE54);
  sub_10039900(8u, 6305, &unk_1067AE5C);
  sub_10039900(8u, 6306, &unk_1067AE64);
  sub_10039900(8u, 6409, &unk_1067AE6C);
  sub_10039900(8u, 6410, &unk_1067AE74);
  sub_10039900(8u, 6411, &unk_1067AE7C);
  sub_10039900(8u, 6412, &unk_1067AE84);
  sub_10039900(8u, 6413, &unk_1067AE8C);
  sub_10039900(8u, 6414, &unk_1067AE94);
  sub_10039900(8u, 6415, &unk_1067AE9C);
  sub_10039900(8u, 6416, &unk_1067AEA4);
  sub_10039900(8u, 6417, &unk_1067AEAC);
  sub_10039900(8u, 6418, &unk_1067AEB4);
  sub_10039900(8u, 6419, &unk_1067AEBC);
  sub_10039900(8u, 6420, &unk_1067AEC4);
  sub_10039900(8u, 6421, &unk_1067AECC);
  sub_10039900(8u, 6422, &unk_1067AED4);
  sub_10039900(8u, 6423, &unk_1067AEDC);
  sub_10039900(8u, 6424, &unk_1067AEE4);
  sub_10039900(8u, 6425, &unk_1067AEEC);
  sub_10039900(8u, 6426, &unk_1067AEF4);
  sub_10039900(8u, 6427, &unk_1067AEFC);
  sub_10039900(8u, 6428, &unk_1067AF04);
  sub_10039900(4u, 6429, &unk_1067B40C);
  sub_10039900(8u, 6430, &unk_1067B410);
  sub_10039900(8u, 6431, &unk_1067B418);
  sub_10039900(8u, 6432, &unk_1067B420);
  sub_10039900(8u, 6433, &unk_1067B428);
  sub_10039900(8u, 6434, &unk_1067B430);
  sub_10039900(8u, 6435, &unk_1067B438);
  sub_10039900(8u, 6436, &unk_1067B440);
  sub_10039900(8u, 6437, &unk_1067B448);
  sub_10039900(8u, 6438, &unk_1067B450);
  sub_10039900(8u, 6439, &unk_1067B458);
  sub_10039900(8u, 6440, &unk_1067B460);
  sub_10039900(0xAu, 6519, &unk_1067B8CC);
  sub_10039900(4u, 6442, &unk_1067B468);
  sub_10039900(4u, 6443, &unk_1067B46C);
  sub_10039900(0xF0u, 6367, &unk_1067B22C);
  sub_10039900(0xF0u, 6368, &unk_1067B31C);
  sub_10039900(1u, 6446, &unk_1067B470);
  sub_10039900(6u, 6452, &unk_1067B51C);
  sub_10039900(4u, 6457, &unk_1067B524);
  sub_10039900(4u, 6458, &unk_1067B528);
  sub_10039900(4u, 6459, &unk_1067B52C);
  sub_10039900(4u, 6460, &unk_1067B530);
  sub_10039900(0x208u, 6515, &unk_1067B534);
  sub_10039900(0x160u, 6516, &unk_1067B73C);
  sub_10039900(0x18u, 6517, &unk_1067B89C);
  sub_10039900(0x18u, 6518, &unk_1067B8B4);
  sub_10039900(1u, 6520, &unk_1067B8D6);
  sub_10039900(0x10u, 6521, &unk_1067B8D8);
  sub_10039900(4u, 6523, &unk_1067B8E8);
  sub_10039900(4u, 6524, &unk_1067B8EC);
  sub_10039900(4u, 6525, &unk_1067B8F0);
  sub_10039900(1u, 6526, &unk_1067B8F4);
  sub_10039900(1u, 6527, &unk_1067B8F5);
  sub_10039900(0x50u, 6528, &unk_1067B8F8);
  sub_10039900(4u, 6529, &unk_1067B948);
  sub_10039900(1u, 6530, &unk_1067B94C);
  sub_10039900(1u, 6531, &unk_1067B94D);
  sub_10039900(1u, 6532, &unk_1067B94E);
  sub_10039900(0x14u, 6533, &unk_1067B94F);
  sub_10039900(0xAu, 6883, &unk_1067C068);
  sub_10039900(0xAu, 6884, &unk_1067C072);
  sub_10039900(0xAu, 6885, &unk_1067C07C);
  sub_10039900(1u, 6664, &unk_1067B963);
  sub_10039900(1u, 6666, &unk_1067B964);
  sub_10039900(1u, 6667, &unk_1067B965);
  sub_10039900(1u, 6668, &unk_1067B966);
  sub_10039900(0xA0u, 6669, &unk_1067B968);
  sub_10039900(2u, 6670, &unk_1067BA58);
  sub_10039900(4u, 6671, &unk_1067BA5C);
  sub_10039900(4u, 6672, &unk_1067BA60);
  sub_10039900(4u, 6673, &unk_1067BA64);
  sub_10039900(4u, 6674, &unk_1067BA68);
  sub_10039900(4u, 6675, &unk_1067BA6C);
  sub_10039900(4u, 6676, &unk_1067BA74);
  sub_10039900(4u, 6677, &unk_1067BA7C);
  sub_10039900(4u, 6678, &unk_1067BA80);
  sub_10039900(1u, 6679, &unk_1067BA84);
  sub_10039900(0x140u, 6680, &unk_1067BA88);
  sub_10039900(4u, 6882, &unk_1067C064);
  sub_10039900(0xCu, 6652, &unk_1067BBC8);
  sub_10039900(0x48u, 6653, &unk_1067BBD4);
  sub_10039900(1u, 6688, &unk_1067BC1C);
  sub_10039900(4u, 6771, &unk_1067BCA4);
  sub_10039900(4u, 6772, &unk_1067BCA8);
  sub_10039900(8u, 6787, &unk_1067BCAC);
  sub_10039900(1u, 6832, &unk_1067BCDC);
  sub_10039900(1u, 6833, &unk_1067BCDD);
  sub_10039900(1u, 6834, &unk_1067BCDE);
  sub_10039900(4u, 6835, &unk_1067BCE0);
  sub_10039900(4u, 6836, &unk_1067BCE4);
  sub_10039900(4u, 6837, &unk_1067BCE8);
  sub_10039900(4u, 6838, &unk_1067BCEC);
  sub_10039900(1u, 6839, &unk_1067BCF0);
  sub_10039900(0x50u, 6840, &unk_1067BA08);
  sub_10039900(4u, 6841, &unk_1067BCF4);
  sub_10039900(4u, 6842, &unk_1067BCF8);
  sub_10039900(4u, 6843, &unk_1067BCFC);
  sub_10039900(1u, 6844, &unk_1067BD00);
  sub_10039900(0x360u, 6845, &unk_1067BD04);
  sub_10039900(4u, 6846, &unk_1067BA70);
  sub_10039900(4u, 6847, &unk_1067BA78);
  result = 1;
  dword_10789FA0 = (int)&unk_10673E68;
  return result;
}
// 10789FA0: using guessed type int dword_10789FA0;

//----- (1003B750) --------------------------------------------------------
char __cdecl sub_1003B750(char a1, void *a2)
{
  int v2; // eax@2
  char result; // al@11
  char *v4; // eax@12
  signed int v5; // ecx@12

  switch ( a1 )
  {
    case 0:
      v2 = 247;
      break;
    case 2:
      v2 = 248;
      break;
    case 3:
      v2 = 1732;
      break;
    case 4:
      v2 = 1733;
      break;
    case 5:
      v2 = 2279;
      break;
    case 6:
      v2 = 2280;
      break;
    default:
      v2 = 246;
      break;
  }
  if ( !sub_1003E2C0(1, v2, a2) || sub_10042F80((int)a2) )
  {
    memset(a2, 0, 0xCCCu);
    v4 = (char *)a2 + 26;
    v5 = 14;
    do
    {
      *v4 = 15;
      v4 += 232;
      --v5;
    }
    while ( v5 );
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1003B800) --------------------------------------------------------
char __cdecl sub_1003B800(char a1)
{
  bool v1; // zf@1
  char result; // al@1
  char v3; // [sp+4h] [bp-CD0h]@1
  char v4; // [sp+11h] [bp-CC3h]@1

  memset(&v3, 0, 0xCCCu);
  v1 = sub_1003B750(a1, &v3) == 0;
  result = v4;
  if ( v1 )
    result = 3;
  return result;
}

//----- (1003B860) --------------------------------------------------------
int __cdecl sub_1003B860(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (1003B9F0) --------------------------------------------------------
int __cdecl sub_1003B9F0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5)
{
  int v5; // edx@1
  int result; // eax@1
  int v7; // ebx@1
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  unsigned int v21; // edx@23
  char *i; // ecx@23
  int v23; // [sp+20h] [bp+14h]@1

  v5 = a5;
  result = a5 - 1;
  v7 = a3 + a4 * (a5 - 1);
  v23 = a5 - 1;
  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && v5 > 0 )
  {
    if ( result > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v23;
        if ( v20 )
        {
          v7 -= a4;
          result = v23 - 1;
          v23 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a2;
    for ( i = (char *)v7; v21 >= 4; i += 4 )
    {
      if ( *(_DWORD *)&i[(_DWORD)a1 - v7] != *(_DWORD *)i )
        break;
      v21 -= 4;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003BB10) --------------------------------------------------------
int __cdecl sub_1003BB10(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1003B860(&a1, 1u, (int)&unk_100C1998, 8, 67, 0);
  if ( v1 )
  {
    result = dword_100C199C[2 * v1];
  }
  else
  {
    sub_100364C0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 100C199C: using guessed type int dword_100C199C[];

//----- (1003BB60) --------------------------------------------------------
char __cdecl sub_1003BB60(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int (__cdecl *v7)(int, int, int, int, int, int); // eax@2

  v6 = sub_1003B860(&a1, 1u, (int)&unk_100C15F8, 16, 58, 57);
  if ( v6 == 57 )
  {
    sub_100364C0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 2231, 0, 0);
  }
  else
  {
    v7 = (int (__cdecl *)(int, int, int, int, int, int))dword_100C15FC[4 * v6];
    if ( v7 )
      return v7(a1, a2, a3, a4, a5, a6);
  }
  return 0;
}
// 100C15FC: using guessed type int dword_100C15FC[];

//----- (1003BBD0) --------------------------------------------------------
signed int sub_1003BBD0()
{
  return sub_1006C8D0((int)&off_100C1BF0);
}
// 100C1BF0: using guessed type char *off_100C1BF0;

//----- (1003BBE0) --------------------------------------------------------
char __usercall sub_1003BBE0@<al>(char a1@<bl>, int a2@<edi>, const void *a3@<esi>, char a4, char a5, char a6, unsigned int a7)
{
  char v7; // dl@12
  __int16 v9; // [sp+4h] [bp-528h]@1
  char v10; // [sp+8h] [bp-524h]@11
  char v11; // [sp+9h] [bp-523h]@11
  char v12; // [sp+Ah] [bp-522h]@11
  char v13; // [sp+Bh] [bp-521h]@11
  __int16 v14; // [sp+Ch] [bp-520h]@12
  char v15; // [sp+Eh] [bp-51Eh]@12
  char v16; // [sp+Fh] [bp-51Dh]@15
  unsigned int v17; // [sp+524h] [bp-8h]@15

  memset(&v9, 0, 0x524u);
  if ( (unsigned __int8)a1 >= 8u )
    sub_100364C0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3425, 0, 0);
  if ( (unsigned __int8)a4 >= 0x39u )
    sub_100364C0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3426, 0, 0);
  if ( (unsigned __int8)a5 >= 2u )
    sub_100364C0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3427, 0, 0);
  if ( (unsigned __int8)a6 >= 0x2Cu )
    sub_100364C0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3428, 0, 0);
  if ( a7 >= 0x514 )
    sub_100364C0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3429, 0, 0);
  v13 = a6;
  v9 = -32749;
  v10 = a1;
  v11 = a4;
  v12 = a5;
  if ( a2 )
  {
    v7 = *(_BYTE *)(a2 + 2);
    v14 = *(_WORD *)a2;
    v15 = v7;
  }
  else
  {
    v14 = 0;
    v15 = 0;
  }
  if ( a3 )
  {
    memcpy_0(&v16, a3, a7);
    v17 = a7;
  }
  else
  {
    v17 = 0;
  }
  return sub_1003EB70((int)&v9);
}

//----- (1003BD40) --------------------------------------------------------
int __cdecl sub_1003BD40(char *a1)
{
  int v1; // eax@1
  char v2; // cl@1
  __int16 v4; // [sp+4h] [bp-52Ch]@1
  char v5; // [sp+9h] [bp-527h]@1
  __int16 v6; // [sp+Ah] [bp-526h]@1
  char v7; // [sp+Ch] [bp-524h]@1
  __int16 v8; // [sp+Eh] [bp-522h]@1
  int v9; // [sp+10h] [bp-520h]@1
  char v10; // [sp+14h] [bp-51Ch]@1

  memset(&v4, 0, 0x528u);
  v4 = -32722;
  v6 = 57;
  v5 = 1;
  v1 = sub_10069700();
  v2 = *a1;
  v9 = v1;
  v7 = 0;
  v8 = 1;
  v10 = v2;
  return sub_10069800(32, (int)&v4, 5000, 0);
}

//----- (1003BDD0) --------------------------------------------------------
char __cdecl sub_1003BDD0(char a1)
{
  return sub_1003BBE0(0, 0, 0, a1, 0, 11, 0);
}

//----- (1003BDF0) --------------------------------------------------------
char __cdecl sub_1003BDF0(char a1, char a2, char a3, int a4)
{
  return sub_1003BBE0(5, a4, 0, a1, a2, a3, 0);
}

//----- (1003BE20) --------------------------------------------------------
char __cdecl sub_1003BE20(_BYTE *a1)
{
  char result; // al@2

  if ( (unsigned __int8)sub_1003BBD0() == 1 )
  {
    *a1 = *(_BYTE *)dword_1067D838;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1067D838: using guessed type int dword_1067D838;

//----- (1003BE50) --------------------------------------------------------
char __cdecl sub_1003BE50(char *a1)
{
  char result; // al@2

  if ( (unsigned __int8)sub_1003BBD0() == 1 )
  {
    strncpy(a1, (const char *)(dword_1067D838 + 160012), 0x64u);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1067D838: using guessed type int dword_1067D838;

//----- (1003BE80) --------------------------------------------------------
char sub_1003BE80()
{
  char result; // al@2

  if ( (unsigned __int8)sub_1003BBD0() == 1 )
    result = *(_BYTE *)(dword_1067D838 + 2);
  else
    result = 67;
  return result;
}
// 1067D838: using guessed type int dword_1067D838;

//----- (1003BEA0) --------------------------------------------------------
char __cdecl sub_1003BEA0(char a1, char a2, int a3)
{
  return sub_1003BBE0(2, a3, 0, a1, 0, a2, 0);
}

//----- (1003BED0) --------------------------------------------------------
char __cdecl sub_1003BED0(char a1, char a2, char a3, int a4, const void *a5, unsigned int a6)
{
  return sub_1003BBE0(4, a4, a5, a1, a2, a3, a6);
}

//----- (1003BF00) --------------------------------------------------------
char __thiscall sub_1003BF00(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_1067D840 = sub_10036FE0(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_1067D848, 0, 0x1540u);
  memset(&unk_1067ED88, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_1067D848;
  do
  {
    sub_100524A0(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_1067ED88 );
  v3 = 0;
  v4 = &unk_1067ED88;
  do
  {
    result = sub_10052520(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)&unk_10680738 );
  return result;
}
// 1067D840: using guessed type int dword_1067D840;

//----- (1003BF90) --------------------------------------------------------
char __cdecl sub_1003BF90(char a1)
{
  char v1; // bl@1
  unsigned __int8 v2; // al@3
  char v4; // [sp+4h] [bp-20h]@1
  char v5; // [sp+8h] [bp-1Ch]@3
  char v6[19]; // [sp+Dh] [bp-17h]@5

  v1 = 0;
  v4 = 0;
  do
  {
    if ( v1 )
      break;
    sub_10052480(v4, (int)&v5);
    v2 = 0;
    do
    {
      if ( v1 )
        break;
      if ( v6[4 * v2] == a1 )
        v1 = 1;
      ++v2;
    }
    while ( v2 <= 1u );
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  return v1;
}
// 1003BF90: using guessed type char var_17[19];

//----- (1003C000) --------------------------------------------------------
char __cdecl sub_1003C000(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_1067D840 != 1379255385;
  v7 = 0;
  v8 = dword_1067D840 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10069980(86, 10);
      memset((char *)&unk_1067D848 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_100524A0(a1, (int)&unk_1067D848 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_1067DB20[v6] == a2 || byte_1067DB21[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_10069950(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1067D840: using guessed type int dword_1067D840;

//----- (1003C0C0) --------------------------------------------------------
char __cdecl sub_1003C0C0(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_1067D840 != 1379255385;
  v7 = 0;
  v8 = dword_1067D840 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10069980(86, 10);
      memset((char *)&unk_1067D848 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_100524A0(a1, (int)&unk_1067D848 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 8 * (340 * (unsigned __int8)a1 + v5);
      if ( byte_1067DB40[v6] == a2 || byte_1067DB41[v6] == a2 )
        break;
      if ( ++v5 >= 5u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_10069950(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1067D840: using guessed type int dword_1067D840;

//----- (1003C180) --------------------------------------------------------
char __cdecl sub_1003C180(char a1, char a2)
{
  unsigned __int8 v2; // bl@1
  unsigned __int8 v4; // [sp+8h] [bp-8h]@1
  char v5; // [sp+Ch] [bp-4h]@2

  v2 = 0;
  v4 = 0;
  while ( 1 )
  {
    sub_10051EE0(a1, v4, (int)&v5);
    if ( v5 == a2 )
      break;
    v4 = ++v2;
    if ( v2 >= 2u )
      return 0;
  }
  return 1;
}

//----- (1003C1D0) --------------------------------------------------------
char __cdecl sub_1003C1D0(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1003C000(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (1003C200) --------------------------------------------------------
char __cdecl sub_1003C200(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1003C0C0(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (1003C230) --------------------------------------------------------
char __cdecl sub_1003C230(char a1)
{
  char result; // al@1
  unsigned __int8 v2; // bl@1
  char v3; // [sp+8h] [bp-4h]@1

  result = 0;
  v2 = 0;
  v3 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1003C180(v3, a1);
    v3 = ++v2;
  }
  while ( v2 < 3u );
  return result;
}

//----- (1003C270) --------------------------------------------------------
char __cdecl sub_1003C270(char a1, _BYTE *a2)
{
  int v2; // esi@1

  *a2 = 19;
  v2 = 0;
  while ( a1 != 3 && a1 != byte_100C2185[2 * v2] || !sub_1003C230(byte_100C2184[2 * v2]) )
  {
    if ( (unsigned int)++v2 >= 0xF )
      return 0;
  }
  *a2 = byte_100C2184[2 * v2];
  return 1;
}

//----- (1003C2C0) --------------------------------------------------------
char __cdecl sub_1003C2C0(char a1, void *a2)
{
  char v2; // al@1

  v2 = sub_100546E0(a1);
  return sub_1003E2C0(6, (unsigned __int16)word_100C26F0[8 * (unsigned __int8)v2], a2);
}
// 100C26F0: using guessed type __int16 word_100C26F0[];

//----- (1003C2F0) --------------------------------------------------------
char __cdecl sub_1003C2F0(unsigned __int8 a1, void *a2)
{
  return sub_1003E2C0(6, (unsigned __int16)word_100C26F2[8 * a1], a2);
}
// 100C26F2: using guessed type __int16 word_100C26F2[];

//----- (1003C310) --------------------------------------------------------
bool __cdecl sub_1003C310(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_1006A0A0(dword_100C26F8[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 100C26F8: using guessed type int dword_100C26F8[];

//----- (1003C350) --------------------------------------------------------
char __cdecl sub_1003C350(char a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@2
  unsigned __int8 v6; // [sp+0h] [bp-4h]@1

  v6 = sub_100546E0(a1);
  if ( a2 )
    result = sub_1003C310(v6, a5);
  else
    result = sub_1003C2F0(v6, a5);
  return result;
}

//----- (1003C390) --------------------------------------------------------
int __cdecl sub_1003C390(char a1)
{
  return dword_100C2EB4[2 * sub_1003B860(&a1, 2u, (int)&unk_100C2EB0, 8, 63, 63)];
}
// 100C2EB4: using guessed type int dword_100C2EB4[];

//----- (1003C3C0) --------------------------------------------------------
char __cdecl sub_1003C3C0(char a1)
{
  return byte_100C2EA1[2 * sub_1003B860(&a1, 1u, (int)&unk_100C2EA0, 2, 6, 5)];
}

//----- (1003C3F0) --------------------------------------------------------
void __cdecl sub_1003C3F0(int a1)
{
  void *v1; // ecx@0
  int v2; // esi@1
  unsigned __int16 v3; // di@1
  void *v4; // ecx@1
  char v5; // bl@1
  void *v6; // ecx@1
  void *v7; // ecx@6
  void *v8; // ecx@34
  char v9; // al@79
  char v10; // al@80
  char v11; // al@91
  int v12; // eax@97
  int v13; // [sp-Ch] [bp-30h]@82
  int v14; // [sp-Ch] [bp-30h]@105
  char v15; // [sp-8h] [bp-2Ch]@87
  char v16; // [sp-4h] [bp-28h]@87
  char v17; // [sp+13h] [bp-11h]@1
  char v18; // [sp+14h] [bp-10h]@1
  int v19; // [sp+18h] [bp-Ch]@1
  int v20; // [sp+1Ch] [bp-8h]@1
  int v21; // [sp+20h] [bp-4h]@1
  char v22; // [sp+28h] [bp+4h]@1

  v19 = 0;
  v21 = 0;
  sub_10036F70(v1);
  v2 = a1;
  v3 = *(_WORD *)(a1 + 10);
  v18 = *(_BYTE *)(a1 + 16);
  v5 = 0;
  v17 = sub_10036FE0(v4);
  LOBYTE(v20) = 0;
  v22 = sub_10037080(v6);
  if ( v3 == -1 || !*(_BYTE *)(v2 + 16) && sub_100559F0() )
    return;
  if ( v3 >= 0xFF00u )
    sub_100364C0("..\\lib\\adl\\cdp_key_intf.c", 701, 1, 0);
  sub_1006A100(9129, &v19, 2, &v21);
  if ( v22 )
  {
    if ( (signed int)v3 > 0x2000 )
    {
      if ( (signed int)v3 > 32794 )
      {
        if ( v3 != 32838 )
          goto LABEL_34;
      }
      else if ( (signed int)v3 < 32783 && ((signed int)v3 < 16399 || (signed int)v3 > 16410 && v3 != 16454) )
      {
        goto LABEL_34;
      }
      LOBYTE(v20) = 1;
LABEL_33:
      v5 = sub_10054760(v2, 20, v20);
    }
    else if ( v3 == 0x2000 )
    {
LABEL_18:
      if ( v18 == 1 || v18 == 4 )
      {
        if ( v19 & 0xC )
        {
          sub_10054740((v19 & 4) == 4, v2, 20, 1);
          v5 = 1;
        }
        else if ( (_WORD)v19 == 16 && sub_100370A0() )
        {
          sub_10069800(11, v2, 20, 1);
          sub_10069800(14, v2, 20, 1);
          v5 = 1;
        }
      }
    }
    else
    {
      switch ( v3 )
      {
        case 0x40u:
        case 0x41u:
          sub_100548F0(v2);
          break;
        case 0x24u:
          sub_10054CB0();
          break;
        case 0x3Fu:
          sub_10055020(v2);
          break;
        case 0x23u:
          sub_10055080(*(_BYTE *)(v2 + 16) == 2);
          break;
        case 0x36u:
        case 0x45u:
          sub_10054D80(v2);
          break;
        case 0x26u:
        case 0x4Du:
          sub_10055910();
          break;
        case 0x37u:
          sub_10055870(v2);
          break;
        case 0x27u:
          sub_100558C0();
          break;
        case 0x20u:
        case 0x21u:
        case 0x28u:
        case 0x38u:
        case 0x39u:
        case 0x49u:
        case 0x52u:
          goto LABEL_18;
        case 0xFu:
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
        case 0x14u:
        case 0x15u:
        case 0x16u:
        case 0x17u:
        case 0x18u:
        case 0x19u:
        case 0x1Au:
          goto LABEL_33;
        default:
          break;
      }
    }
  }
LABEL_34:
  if ( sub_10037130(v7) != 2 && (v19 & 0xC || (_WORD)v19 == 16) )
  {
    if ( v3 != 28
      && v3 != 29
      && v3 != 30
      && v3 != 31
      && v3 != 32
      && v3 != 33
      && v3 != 56
      && v3 != 57
      && v3 != 40
      && v3 != 44
      && !(_BYTE)v20 )
    {
      goto LABEL_60;
    }
    if ( !v5 )
    {
      if ( (_WORD)v19 == 16 )
      {
        if ( !sub_100370A0() || v3 == 28 || v3 == 29 || v3 == 30 || v3 == 31 || v3 == 44 )
          v19 = 2;
      }
      else
      {
        v19 &= 0xFFF3u;
      }
      sub_1006A250(9129, (int)&v19, 2);
    }
  }
  if ( (_BYTE)v20 )
    return;
LABEL_60:
  if ( v5 || v3 == 32 && (v18 == 1 || v18 == 4) && !sub_10036C40(v8) )
    return;
  if ( v17 == 2 )
  {
    sub_10069800(3, v2, 20, 1);
    return;
  }
  if ( v17 == 8 )
  {
    if ( sub_10069790(21) == 5 )
      sub_10069800(16, v2, 20, 1);
    else
      sub_10069800(15, v2, 20, 1);
    return;
  }
  if ( !v22 )
  {
    sub_10069800(13, v2, 20, 1);
    return;
  }
  if ( (signed int)v3 <= 16395 )
  {
    if ( (signed int)v3 < 16387 )
    {
      switch ( v3 )
      {
        case 2u:
        case 0x25u:
        case 0x2Au:
        case 0x2Bu:
        case 0x3Au:
        case 0x42u:
        case 0x43u:
        case 0x52u:
          sub_10054740(1, v2, 20, 1);
          return;
        case 0x1Bu:
        case 0x22u:
        case 0x29u:
        case 0x3Bu:
        case 0x3Du:
        case 0x3Eu:
          sub_10054740(0, v2, 20, 1);
          return;
        case 0x64u:
        case 0x65u:
          sub_10055650(v2);
          return;
        case 0x5Au:
          v9 = sub_1003C3C0(v18);
          sub_100548C0(*(_BYTE *)(v2 + 8), v9);
          return;
        case 0x66u:
          v10 = sub_1003C3C0(v18);
          sub_10054890(*(_BYTE *)(v2 + 8), v10);
          return;
        case 0x53u:
          sub_100547E0(v8);
          return;
        case 0x2Du:
        case 0x2Eu:
        case 0x2Fu:
        case 0x30u:
        case 0x31u:
        case 0x32u:
        case 0x33u:
        case 0x34u:
        case 0x35u:
        case 0x3Cu:
          v13 = v2;
          if ( !sub_100371F0(9) )
            goto LABEL_101;
          sub_10069800(6, v2, 20, 1);
          return;
        case 3u:
        case 4u:
        case 5u:
        case 6u:
        case 7u:
        case 8u:
        case 9u:
        case 0xAu:
        case 0xBu:
        case 0x4Au:
        case 0x4Bu:
        case 0x55u:
        case 0x56u:
        case 0x57u:
        case 0x5Du:
          goto LABEL_87;
        case 0xEu:
          goto LABEL_92;
        case 0xCu:
          goto LABEL_93;
        case 0x44u:
        case 0x59u:
          goto LABEL_94;
        default:
          goto LABEL_98;
      }
      goto LABEL_98;
    }
LABEL_87:
    v16 = sub_1003C3C0(v18);
    v15 = 1;
LABEL_97:
    v12 = sub_1003C390(v3);
    sub_10054860(v12, v15, v16);
    return;
  }
  if ( (signed int)v3 > 32779 )
  {
    switch ( v3 )
    {
      case 0x800Du:
      case 0x804Au:
      case 0x804Bu:
      case 0x8055u:
      case 0x8056u:
      case 0x8057u:
      case 0x805Du:
      case 0x805Fu:
        goto LABEL_91;
      case 0x800Eu:
LABEL_92:
        *(_BYTE *)(v2 + 8) = -1;
        sub_10055110(v2);
        return;
      case 0x800Cu:
LABEL_93:
        *(_BYTE *)(v2 + 8) = 1;
LABEL_94:
        sub_10055110(v2);
        return;
      case 0x804Cu:
      case 0x8058u:
        v11 = sub_1003C3C0(v18);
        goto LABEL_96;
      default:
        break;
    }
  }
  else
  {
    if ( (signed int)v3 >= 32771 )
    {
LABEL_91:
      v11 = sub_1003C3C0(v18);
LABEL_96:
      v16 = v11;
      v15 = 0;
      goto LABEL_97;
    }
    switch ( v3 )
    {
      case 0x404Au:
      case 0x404Bu:
      case 0x4055u:
      case 0x4056u:
      case 0x4057u:
      case 0x405Du:
        goto LABEL_87;
      case 0x400Du:
      case 0x405Fu:
        sub_10054DE0(v2);
        v16 = sub_1003C3C0(v18);
        v15 = 1;
        goto LABEL_97;
      case 0x404Cu:
      case 0x4058u:
        sub_100553F0();
        v16 = sub_1003C3C0(v18);
        v15 = 1;
        goto LABEL_97;
      case 0x400Eu:
        goto LABEL_92;
      case 0x400Cu:
        goto LABEL_93;
      default:
        break;
    }
  }
LABEL_98:
  if ( sub_10037130(v8) & 3 || !sub_100371F0(8) )
  {
    if ( (signed int)v3 <= 0x2000 )
    {
      if ( v3 == 0x2000 )
      {
LABEL_111:
        if ( sub_100370A0() )
        {
          sub_10069800(11, v2, 20, 1);
          sub_10069800(14, v2, 20, 1);
        }
        else
        {
          sub_10054720(v2, 20, 1);
        }
        return;
      }
      switch ( v3 )
      {
        case 0x1Cu:
        case 0x1Du:
        case 0x1Eu:
        case 0x1Fu:
          v14 = v2;
          if ( sub_100370A0() )
            goto LABEL_115;
          sub_10069800(1, v2, 20, 1);
          return;
        case 0x1Au:
          sub_10054780(v2, 20);
          return;
        case 0x5Cu:
          v19 = 2;
          sub_1006A250(9129, (int)&v19, 2);
          sub_10069800(14, v2, 20, 1);
          return;
        case 0x60u:
          sub_10054700(v2, 20);
          return;
        case 0x62u:
          sub_10054700(v2, 20);
          return;
        case 0x20u:
        case 0x21u:
        case 0x28u:
        case 0x38u:
        case 0x39u:
        case 0x49u:
        case 0x54u:
          goto LABEL_111;
        default:
          break;
      }
    }
    v14 = v2;
LABEL_115:
    sub_10069800(14, v14, 20, 1);
  }
  else
  {
    v13 = v2;
LABEL_101:
    sub_10069800(9, v13, 20, 1);
  }
}

//----- (1003CC80) --------------------------------------------------------
int __cdecl sub_1003CC80(__int16 a1, char a2)
{
  __int16 v3; // [sp+0h] [bp-10h]@1
  __int16 v4; // [sp+4h] [bp-Ch]@1
  char v5; // [sp+6h] [bp-Ah]@1

  v3 = -32764;
  v4 = a1;
  v5 = a2;
  return sub_10069800(7, (int)&v3, 1000, 1);
}

//----- (1003CCC0) --------------------------------------------------------
void __cdecl sub_1003CCC0(__int16 a1, char a2)
{
  __int16 v2; // [sp+0h] [bp-D0h]@1
  char v3; // [sp+2h] [bp-CEh]@1
  int v4; // [sp+4h] [bp-CCh]@1
  char v5; // [sp+8h] [bp-C8h]@1
  __int16 v6; // [sp+Ah] [bp-C6h]@1
  __int16 v7; // [sp+Ch] [bp-C4h]@1
  __int16 v8; // [sp+Eh] [bp-C2h]@1
  char v9; // [sp+10h] [bp-C0h]@1

  v4 = 0;
  v8 = 0;
  v7 = 0;
  v9 = 0;
  v3 = -1;
  v2 = -32696;
  v6 = a1;
  v5 = a2;
  sub_1003C3F0((int)&v2);
}

//----- (1003CD30) --------------------------------------------------------
char __cdecl sub_1003CD30(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_100364C0("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (1003CD70) --------------------------------------------------------
signed int __cdecl sub_1003CD70(char a1)
{
  signed int result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 512;
    }
    else
    {
      sub_100364C0("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 699, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = 256;
  }
  return result;
}

//----- (1003CDB0) --------------------------------------------------------
char sub_1003CDB0()
{
  int v1; // [sp+0h] [bp-4h]@1

  v1 = 0;
  LOWORD(v1) = -32761;
  return sub_1003EB70((int)&v1);
}

//----- (1003CDD0) --------------------------------------------------------
void sub_1003CDD0()
{
  dword_1068073C = -15;
}
// 1068073C: using guessed type int dword_1068073C;

//----- (1003CDE0) --------------------------------------------------------
signed int sub_1003CDE0()
{
  return sub_1006C8D0((int)&off_100C3350);
}
// 100C3350: using guessed type char *off_100C3350;

//----- (1003CDF0) --------------------------------------------------------
char __cdecl sub_1003CDF0(_BYTE *a1)
{
  char result; // al@2

  if ( (unsigned __int8)sub_1003CDE0() == 1 )
  {
    *a1 = *(_BYTE *)dword_1068073C;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1068073C: using guessed type int dword_1068073C;

//----- (1003CE20) --------------------------------------------------------
char __cdecl sub_1003CE20(int a1)
{
  char *v1; // ecx@2
  _BYTE *v2; // edx@2
  char v3; // al@3
  char result; // al@4

  if ( (unsigned __int8)sub_1003CDE0() == 1 )
  {
    *(_DWORD *)(a1 + 140) = *(_DWORD *)(dword_1068073C + 168);
    v1 = (char *)(dword_1068073C + 7);
    v2 = (_BYTE *)(a1 + 4);
    do
    {
      v3 = *v1;
      *v2++ = *v1++;
    }
    while ( v3 );
    *(_DWORD *)a1 = *(_DWORD *)(dword_1068073C + 144);
    *(_DWORD *)(a1 + 132) = *(_DWORD *)(dword_1068073C + 148);
    *(_WORD *)(a1 + 136) = *(_WORD *)(dword_1068073C + 136);
    *(_BYTE *)(a1 + 138) = *(_BYTE *)dword_1068073C;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1068073C: using guessed type int dword_1068073C;

//----- (1003CEB0) --------------------------------------------------------
char *__cdecl sub_1003CEB0(int a1)
{
  char *result; // eax@2

  if ( (unsigned int)(a1 + 61) > 0x3C )
    result = 0;
  else
    result = off_100C3D08[-a1];
  return result;
}
// 100C3D08: using guessed type char *off_100C3D08[62];

//----- (1003CED0) --------------------------------------------------------
int __cdecl sub_1003CED0(float a1)
{
  double v1; // st7@1
  signed int v2; // ecx@1
  int result; // eax@13

  v1 = a1;
  v2 = 6;
  if ( a1 > 0.0 )
    v2 = 0;
  if ( v1 > 8.0 )
    v2 = 1;
  if ( v1 > 10.0 )
    v2 = 2;
  if ( v1 > 12.5 )
    v2 = 3;
  if ( v1 > 14.0 )
    v2 = 4;
  if ( v1 > 16.0 )
    v2 = 6;
  result = 7;
  if ( v1 <= 20.0 )
    result = v2;
  return result;
}

//----- (1003CF60) --------------------------------------------------------
int __cdecl sub_1003CF60(int a1, _WORD *a2, char *a3, int a4, int a5, int a6, int a7)
{
  int v7; // esi@1
  char *v8; // ebp@1
  int v9; // edi@1
  int v10; // eax@3
  int v11; // ebx@3
  bool v12; // al@5
  bool v13; // al@9
  _WORD *v14; // edx@11
  int result; // eax@13
  char *v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v7 = a1;
  sub_100029B0(a1, *(_DWORD *)(a1 + 56));
  v8 = a3;
  v9 = 0;
  if ( sub_10037480(a3, &v17, &v16) )
  {
    do
    {
      if ( sub_10037400(v7, a5, v9) )
      {
        v10 = *(_DWORD *)(v7 + 56);
        LOWORD(a1) = *(_WORD *)a6 + *(_WORD *)v17 + *(_WORD *)(v10 + 36);
        HIWORD(a1) = *(_WORD *)(a6 + 2) + *(_WORD *)(v17 + 2) + *(_WORD *)(v10 + 38);
        v11 = a7;
        v12 = v9 == a7 && sub_10037430(v7, a2, v10);
        *(_BYTE *)(v7 + 3) = v12;
        v13 = v9 == v11 && *(_DWORD *)(v7 + 56) == *(_DWORD *)(*(_DWORD *)(v7 + 48) + 4);
        v14 = a2;
        *(_BYTE *)(v7 + 9) = v13;
        ((void (__cdecl *)(int, char *, int *, _DWORD, _WORD *))dword_10789180[2 * (*(_DWORD *)v8 & 0xFF)])(
          v7,
          v8,
          &a1,
          *(_DWORD *)(a4 + 4 * v9),
          v14);
      }
      v8 = v16;
      ++v9;
    }
    while ( sub_10037480(v16, &v17, &v16) );
  }
  result = *a2 - 32802;
  if ( *a2 == 32802 )
  {
    *(_BYTE *)(v7 + 1) = 1;
  }
  else
  {
    result = *a2 - 32888;
    if ( *a2 == 32888 )
    {
      *(_BYTE *)(v7 + 1) = 1;
      result = j_gdi_pvg_flush();
      *(_BYTE *)(v7 + 3) = 0;
      return result;
    }
  }
  *(_BYTE *)(v7 + 3) = 0;
  return result;
}
// 10069C00: using guessed type int j_gdi_pvg_flush(void);
// 10789180: using guessed type int dword_10789180[];

//----- (1003D0A0) --------------------------------------------------------
int __cdecl sub_1003D0A0(int a1, _WORD *a2, char *a3, int a4, int a5, int a6)
{
  __int16 v7; // [sp+0h] [bp-4h]@1
  __int16 v8; // [sp+2h] [bp-2h]@1

  v7 = 0;
  v8 = 0;
  return sub_1003CF60(a1, a2, a3, a4, a5, (int)&v7, a6);
}

//----- (1003D0E0) --------------------------------------------------------
void __usercall sub_1003D0E0(int a1@<eax>, int a2@<edi>, int a3@<esi>, float a4)
{
  double v4; // st7@1
  double v5; // st6@1
  double v6; // st5@2
  double v7; // st6@6
  float v8; // ST18_4@6
  double v9; // st5@6
  double v10; // st7@6
  float v11; // [sp+8h] [bp-14h]@4
  float v12; // [sp+Ch] [bp-10h]@4
  float v13; // [sp+10h] [bp-Ch]@1
  float v14; // [sp+14h] [bp-8h]@4
  float v15; // [sp+18h] [bp-4h]@1
  float v16; // [sp+20h] [bp+4h]@6
  float v17; // [sp+20h] [bp+4h]@6
  float v18; // [sp+20h] [bp+4h]@6

  v13 = sub_1006AC90(*(_DWORD *)(a3 + 8), a1, *(float *)(a3 + 12));
  v4 = 4.0;
  v15 = *(float *)(a3 + 12) + 4.0;
  v5 = v13;
  if ( 0.0 == *(float *)(a3 + 32) )
    v6 = v13;
  else
    v6 = *(float *)(a3 + 32);
  v14 = v6 + 4.0;
  v11 = *(float *)a3 - *(float *)(a3 + 24) * v5;
  v12 = *(float *)(a3 + 4) - *(float *)(a3 + 28) * *(float *)(a3 + 12);
  if ( LOBYTE(a4) )
  {
    v11 = sub_10022A90(v11, 1.0) + 0.5;
    v12 = sub_10022C70(v12, 1.0);
    v4 = 4.0;
    v5 = v13;
  }
  v16 = (v4 + v5) * *(float *)(a3 + 24) + v11 - 2.0;
  v7 = v14;
  v8 = v16 - *(float *)(a3 + 24) * v14;
  v17 = *(float *)(a3 + 12) * 0.5 + v12;
  v18 = v17 - 0.5 * v15;
  *(float *)(a2 + 304) = v15 + v18;
  *(float *)(a2 + 292) = v8;
  *(float *)(a2 + 300) = v7 + v8;
  v9 = v18;
  *(float *)(a2 + 296) = *(float *)&v9;
  v10 = v12;
  *(float *)(a2 + 36) = v11;
  *(float *)(a2 + 40) = *(float *)&v10;
}

//----- (1003D230) --------------------------------------------------------
void __cdecl sub_1003D230(int a1, int a2, int a3)
{
  sub_1003D0E0(a2, a1, a3, COERCE_FLOAT(1));
}

//----- (1003D250) --------------------------------------------------------
int __usercall sub_1003D250@<eax>(float a1@<eax>, int a2@<ecx>, int a3@<ebx>, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  float v6; // ST10_4@1

  v4 = a4;
  v5 = a2;
  sub_1003D0E0(a3, a4, a2, a1);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(*(_DWORD *)(v5 + 16));
  j_gdi_pvg_begin(72);
  sub_10069EF0(*(float *)(v4 + 292), *(float *)(v4 + 296));
  sub_10069EF0(*(float *)(v4 + 300), *(float *)(v4 + 296));
  sub_10069EF0(*(float *)(v4 + 300), *(float *)(v4 + 304));
  sub_10069EF0(*(float *)(v4 + 292), *(float *)(v4 + 304));
  j_gdi_pvg_end(LODWORD(v6));
  j_gdi_pvg_color_u32(*(_DWORD *)(v5 + 20));
  sub_1006AAF0(*(_DWORD *)(v5 + 8), a3, *(float *)(v4 + 36), *(float *)(v4 + 40), *(float *)(v5 + 12));
  return j_gdi_pvg_disable(35);
}
// 100699C0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10069A50: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10069B20: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10069B40: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10069BC0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10069BE0: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003D330) --------------------------------------------------------
int __cdecl sub_1003D330(int a1, int a2, int a3)
{
  float v3; // eax@1

  v3 = *(float *)&a1;
  LOBYTE(v3) = 1;
  return sub_1003D250(v3, a3, a2, a1);
}

//----- (1003D350) --------------------------------------------------------
int __cdecl sub_1003D350(int a1, int a2, int a3)
{
  int v3; // eax@5
  char v5; // [sp+8h] [bp-24h]@1
  int v6; // [sp+18h] [bp-14h]@5
  int v7; // [sp+1Ch] [bp-10h]@5

  qmemcpy(&v5, (const void *)a3, 0x24u);
  if ( *(_BYTE *)(a1 + 3) && *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 && (byte_10756F5E || byte_10789160) )
  {
    v3 = *(_DWORD *)(a3 + 16);
    v6 = *(_DWORD *)(a3 + 20);
    v7 = v3;
  }
  return sub_1003D330(a1, a2, (int)&v5);
}
// 10756F5E: using guessed type char byte_10756F5E;
// 10789160: using guessed type char byte_10789160;

//----- (1003D3C0) --------------------------------------------------------
char __cdecl sub_1003D3C0(char a1)
{
  void *v1; // ecx@0
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      sub_1006A0C0(6470, (int)&a1, 1);
      result = a1 && sub_10055A60(2u);
    }
    else if ( a1 == 2 )
    {
      result = sub_1003C200(14);
    }
    else
    {
      sub_100364C0("..\\lib\\adl\\iop_dl_wx_intf_a.c", 475, 1, 0);
      result = 0;
    }
  }
  else
  {
    result = (sub_10036FC0(v1) & 0x800) == 2048;
  }
  return result;
}

//----- (1003D440) --------------------------------------------------------
BOOL sub_1003D440()
{
  return sub_1003D3C0(0) || sub_1003D3C0(1) || sub_1003D3C0(2);
}

//----- (1003D480) --------------------------------------------------------
char __cdecl sub_1003D480(unsigned __int8 a1)
{
  unsigned __int8 v1; // bl@1
  char result; // al@10
  int v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@4

  v1 = 0;
  LOBYTE(v3) = 0;
  if ( (unsigned __int8)sub_1003D440() )
  {
    if ( sub_1006A0A0(dword_100C49F8[a1], (int)&v3, 1) || !sub_1003D3C0(v3) )
    {
      LOBYTE(v3) = 0;
      LOBYTE(v4) = 0;
      while ( !sub_1003D3C0(v4) )
      {
        LOBYTE(v4) = ++v1;
        if ( v1 > 3u )
          goto LABEL_9;
      }
      LOBYTE(v3) = v1;
LABEL_9:
      sub_1006A190(dword_100C49F8[a1], (int)&v3, 1);
    }
    result = v3;
  }
  else
  {
    result = v3;
  }
  return result;
}
// 100C49F8: using guessed type int dword_100C49F8[];

//----- (1003D520) --------------------------------------------------------
void sub_1003D520()
{
  dword_10680740 = -15;
}
// 10680740: using guessed type int dword_10680740;

//----- (1003D530) --------------------------------------------------------
signed int sub_1003D530()
{
  return sub_1006C8D0((int)&off_100C5288);
}
// 100C5288: using guessed type char *off_100C5288;

//----- (1003D540) --------------------------------------------------------
char __cdecl sub_1003D540(unsigned __int8 a1, _DWORD *a2)
{
  char result; // al@3

  if ( a1 >= 4u )
  {
    sub_100364C0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 795, 0, 0);
    return 0;
  }
  if ( (unsigned __int8)sub_1003D530() != 1 )
    return 0;
  if ( *(_DWORD *)(dword_10680740 + 4 * a1 + 696) + 4000 <= (unsigned int)sub_10069700() )
  {
    result = 0;
  }
  else
  {
    *a2 = *(_DWORD *)(dword_10680740 + 4 * a1 + 228);
    result = 1;
  }
  return result;
}
// 10680740: using guessed type int dword_10680740;

//----- (1003D5B0) --------------------------------------------------------
BOOL __fastcall sub_1003D5B0(int a1)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = a1;
  return sub_1003BB60(6, 1, 27, 0, (int)&v2, 4) && v2 & 1;
}

//----- (1003D5E0) --------------------------------------------------------
bool __thiscall sub_1003D5E0(void *this)
{
  int v1; // ecx@1
  void *v3; // [sp-2h] [bp-4h]@1

  v3 = this;
  BYTE2(v3) = 0;
  sub_1006A100(6791, (char *)&v3 + 3, 1, (char *)&v3 + 2);
  return BYTE3(v3) && (unsigned __int8)sub_1003D5B0(v1);
}

//----- (1003D620) --------------------------------------------------------
int __cdecl sub_1003D620(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_100C6264[a1];
  return result;
}
// 100C6264: using guessed type __int16 word_100C6264[];

//----- (1003D640) --------------------------------------------------------
signed int sub_1003D640()
{
  signed int result; // eax@1

  result = -15;
  dword_106AD1D8 = -15;
  dword_106AD1E4 = -15;
  dword_106AD1C0 = -15;
  dword_106AD1E8 = -15;
  dword_106AD1D4 = -15;
  dword_106AD1C4 = -15;
  dword_106AD1BC = -15;
  dword_106AD1D0 = -15;
  dword_106AD1E0 = -15;
  dword_106AD1DC = -15;
  dword_106AD1CC = -15;
  dword_106AD1C8 = -15;
  return result;
}
// 106AD1BC: using guessed type int dword_106AD1BC;
// 106AD1C0: using guessed type int dword_106AD1C0;
// 106AD1C4: using guessed type int dword_106AD1C4;
// 106AD1C8: using guessed type int dword_106AD1C8;
// 106AD1CC: using guessed type int dword_106AD1CC;
// 106AD1D0: using guessed type int dword_106AD1D0;
// 106AD1D4: using guessed type int dword_106AD1D4;
// 106AD1D8: using guessed type int dword_106AD1D8;
// 106AD1DC: using guessed type int dword_106AD1DC;
// 106AD1E0: using guessed type int dword_106AD1E0;
// 106AD1E4: using guessed type int dword_106AD1E4;
// 106AD1E8: using guessed type int dword_106AD1E8;

//----- (1003D690) --------------------------------------------------------
signed int __usercall sub_1003D690@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_1006C8D0((int)&off_100C6284);
      break;
    case 0:
      result = sub_1006C8D0((int)&off_100C6298);
      break;
    case 1:
      result = sub_1006C8D0((int)&off_100C62AC);
      break;
    case 2:
      result = sub_1006C8D0((int)&off_100C62D4);
      break;
    case 3:
      result = sub_1006C8D0((int)&off_100C62C0);
      break;
    case 5:
      result = sub_1006C8D0((int)&off_100C62E8);
      break;
    default:
      result = sub_1006C8D0(a2);
      break;
  }
  return result;
}
// 100C6284: using guessed type char *off_100C6284;
// 100C6298: using guessed type char *off_100C6298;
// 100C62AC: using guessed type char *off_100C62AC;
// 100C62C0: using guessed type char *off_100C62C0;
// 100C62D4: using guessed type char *off_100C62D4;
// 100C62E8: using guessed type char *off_100C62E8;

//----- (1003D730) --------------------------------------------------------
int __usercall sub_1003D730@<eax>(char a1@<al>)
{
  return sub_100697B0(dword_100C5DB4[a1]);
}
// 100C5DB4: using guessed type int dword_100C5DB4[];

//----- (1003D750) --------------------------------------------------------
int __usercall sub_1003D750@<eax>(char a1@<al>)
{
  return sub_100697D0(dword_100C5DB4[a1], 10);
}
// 100C5DB4: using guessed type int dword_100C5DB4[];

//----- (1003D770) --------------------------------------------------------
signed __int16 __usercall sub_1003D770@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  signed __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_1003D690(a1, a1) )
        {
          sub_100364C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_106AD1D8 + 2 * a2 + 241212);
        v3 = (unsigned __int16)result < 0x256u;
        goto LABEL_32;
      }
      sub_100364C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_100364C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      if ( (unsigned __int8)sub_1003D690(a1, a1) )
      {
        result = *(_WORD *)(dword_106AD1E4 + 2 * a2 + 284664);
        v3 = (unsigned __int16)result < 0x211u;
        goto LABEL_32;
      }
      if ( sub_10036E50(15000) )
        goto LABEL_6;
      sub_100364C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
      return 0;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_100364C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_1003D690(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_106AD1C0 + 2 * a2 + 447808);
      v3 = (unsigned __int16)result < 0x979u;
      goto LABEL_32;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_100364C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_1003D690(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_106AD1E8 + 2 * a2 + 356016);
      v3 = (unsigned __int16)result < 0x23Du;
      goto LABEL_32;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_100364C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_1003D690(a1, a1) )
      {
        sub_100364C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_106AD1D4 + 2 * a2 + 23096);
      v3 = (unsigned __int16)result < 0x52u;
      goto LABEL_32;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_1003D690(a1, a1) )
        {
          result = *(_WORD *)(dword_106AD1C4 + 2 * a2 + 1804);
          v3 = (unsigned __int16)result < 4u;
LABEL_32:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_100364C0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 106AD1C0: using guessed type int dword_106AD1C0;
// 106AD1C4: using guessed type int dword_106AD1C4;
// 106AD1D4: using guessed type int dword_106AD1D4;
// 106AD1D8: using guessed type int dword_106AD1D8;
// 106AD1E4: using guessed type int dword_106AD1E4;
// 106AD1E8: using guessed type int dword_106AD1E8;

//----- (1003D9B0) --------------------------------------------------------
char __cdecl sub_1003D9B0(char a1, unsigned __int16 a2, _BYTE *a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v6; // eax@9

  v3 = sub_1003D770(a1, a2);
  if ( v3 != -1 && !sub_1003D750(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_1003D690(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_106AD1D8);
        sub_1003D730(a1);
        return 1;
      case 0:
        if ( (unsigned __int8)sub_1003D690(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_106AD1E4);
        sub_1003D730(a1);
        return 1;
      case 1:
        if ( (unsigned __int8)sub_1003D690(a1, v4) != 1 )
          goto LABEL_17;
        v6 = dword_106AD1C0;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_1003D690(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_106AD1E8);
        sub_1003D730(a1);
        return 1;
      case 3:
        if ( (unsigned __int8)sub_1003D690(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_106AD1D4);
        sub_1003D730(a1);
        return 1;
      case 5:
        if ( (unsigned __int8)sub_1003D690(a1, v4) != 1 )
          goto LABEL_17;
        v6 = dword_106AD1C4;
LABEL_16:
        *a3 = *(_BYTE *)((unsigned __int16)v3 + v6);
        sub_1003D730(a1);
        return 1;
      default:
LABEL_17:
        sub_1003D730(a1);
        break;
    }
  }
  return 0;
}
// 106AD1C0: using guessed type int dword_106AD1C0;
// 106AD1C4: using guessed type int dword_106AD1C4;
// 106AD1D4: using guessed type int dword_106AD1D4;
// 106AD1D8: using guessed type int dword_106AD1D8;
// 106AD1E4: using guessed type int dword_106AD1E4;
// 106AD1E8: using guessed type int dword_106AD1E8;

//----- (1003DB10) --------------------------------------------------------
char __cdecl sub_1003DB10(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  signed __int16 v4; // si@1
  char result; // al@2

  v4 = sub_1003D770(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_1003D690(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_106AD1D8 + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_1003D690(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_106AD1E4 + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        result = sub_1003D690(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_106AD1C0 + 321708), 0x34u);
        break;
      case 2:
        if ( (unsigned __int8)sub_1003D690(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_106AD1E8 + 326220), 0x34u);
        result = 1;
        break;
      case 3:
        if ( (unsigned __int8)sub_1003D690(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_106AD1D4 + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        result = sub_1003D690(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_106AD1C4 + 1596), 0x34u);
        break;
      default:
LABEL_16:
        result = 0;
        break;
    }
  }
  return result;
}
// 106AD1C0: using guessed type int dword_106AD1C0;
// 106AD1C4: using guessed type int dword_106AD1C4;
// 106AD1D4: using guessed type int dword_106AD1D4;
// 106AD1D8: using guessed type int dword_106AD1D8;
// 106AD1E4: using guessed type int dword_106AD1E4;
// 106AD1E8: using guessed type int dword_106AD1E8;

//----- (1003DC90) --------------------------------------------------------
char __cdecl sub_1003DC90(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_1003D770(a1, a2);
  if ( v3 != -1 && !sub_1003D750(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_1003D690(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_106AD1D8 + 24 * ((unsigned __int16)v3 + 25);
        goto LABEL_16;
      case 0:
        if ( (unsigned __int8)sub_1003D690(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_106AD1E4 + 24 * (unsigned __int16)v3 + 532;
        goto LABEL_16;
      case 1:
        if ( (unsigned __int8)sub_1003D690(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_106AD1C0 + 24 * (unsigned __int16)v3 + 2428;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_1003D690(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_106AD1E8 + 24 * ((unsigned __int16)v3 + 24);
        goto LABEL_16;
      case 3:
        if ( (unsigned __int8)sub_1003D690(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_106AD1D4 + 24 * (unsigned __int16)v3 + 84;
        goto LABEL_16;
      case 5:
        if ( (unsigned __int8)sub_1003D690(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_106AD1C4 + 24 * (unsigned __int16)v3 + 4;
LABEL_16:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_1003D730(a1);
        return 1;
      default:
LABEL_17:
        sub_1003D730(a1);
        break;
    }
  }
  return 0;
}
// 106AD1C0: using guessed type int dword_106AD1C0;
// 106AD1C4: using guessed type int dword_106AD1C4;
// 106AD1D4: using guessed type int dword_106AD1D4;
// 106AD1D8: using guessed type int dword_106AD1D8;
// 106AD1E4: using guessed type int dword_106AD1E4;
// 106AD1E8: using guessed type int dword_106AD1E8;

//----- (1003DDF0) --------------------------------------------------------
char __cdecl sub_1003DDF0(int a1, int a2, void *a3, char a4, __int16 a5, char a6)
{
  int v6; // ecx@0
  signed __int16 v7; // ax@1
  int v8; // edi@2
  __int16 v9; // si@11
  __int16 v11; // [sp+8h] [bp-560h]@13
  __int16 v12; // [sp+3Ch] [bp-52Ch]@10
  char v13; // [sp+40h] [bp-528h]@16
  char v14; // [sp+41h] [bp-527h]@10
  __int16 v15; // [sp+42h] [bp-526h]@10
  char v16; // [sp+44h] [bp-524h]@10
  __int16 v17; // [sp+46h] [bp-522h]@15
  int v18; // [sp+48h] [bp-520h]@16
  char v19; // [sp+4Ch] [bp-51Ch]@15

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_8;
    case 0:
      v8 = 29;
      goto LABEL_8;
    case 1:
      v8 = 30;
      goto LABEL_8;
    case 2:
      v8 = 31;
      goto LABEL_8;
    case 3:
      v8 = 32;
      goto LABEL_8;
    case 5:
      v8 = 33;
LABEL_8:
      LOBYTE(v7) = sub_1003D690(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_1003D770(a1, a2);
      if ( v7 == -1 )
        return v7;
      v14 = a6;
      LOBYTE(v7) = a4;
      v12 = -32768;
      v15 = a2;
      v16 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_1003DB10(a1, a2, &v11) != 1 )
          goto LABEL_16;
        v9 = v11;
      }
      memcpy_0(&v19, a3, (unsigned __int16)v9);
      v17 = v9;
LABEL_16:
      v18 = sub_10069700();
      v13 = 0;
      LOBYTE(v7) = sub_1003EA50(v8, (int)&v12);
      return v7;
    default:
      return v7;
  }
}

//----- (1003DF30) --------------------------------------------------------
char __cdecl sub_1003DF30(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  unsigned __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_1003D770(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_1003EA50(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (1003E010) --------------------------------------------------------
char __cdecl sub_1003E010(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  signed __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@9
  int v15; // eax@11
  int v16; // eax@13
  int v17; // eax@15
  int v18; // eax@17
  int v19; // eax@25
  char v20; // [sp+7h] [bp-9h]@19
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_10069700();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_1003D770(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_1003D690(a1, v7) )
            goto LABEL_30;
          v9 = 3 * (unsigned __int16)v8 + 75;
          v10 = dword_106AD1D8 + 14952;
          v11 = 52 * (unsigned __int16)v8 + dword_106AD1D8 + 210116;
          v12 = dword_106AD1D8 + 8 * v9;
          v13 = 195164;
          goto LABEL_18;
        case 0:
          if ( !(unsigned __int8)sub_1003D690(a1, v7) )
            goto LABEL_30;
          v14 = 3 * (unsigned __int16)v8;
          v10 = dword_106AD1E4 + 13228;
          v11 = 52 * (unsigned __int16)v8 + dword_106AD1E4 + 257156;
          v12 = dword_106AD1E4 + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_18;
        case 1:
          if ( !(unsigned __int8)sub_1003D690(a1, v7) )
            goto LABEL_30;
          v15 = 3 * (unsigned __int16)v8;
          v10 = dword_106AD1C0 + 60628;
          v11 = 52 * (unsigned __int16)v8 + dword_106AD1C0 + 321708;
          v12 = dword_106AD1C0 + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_18;
        case 2:
          if ( !(unsigned __int8)sub_1003D690(a1, v7) )
            goto LABEL_30;
          v16 = 3 * (unsigned __int16)v8 + 72;
          v10 = dword_106AD1E8 + 14328;
          v11 = 52 * (unsigned __int16)v8 + dword_106AD1E8 + 326220;
          v12 = dword_106AD1E8 + 8 * v16;
          v13 = 311892;
          goto LABEL_18;
        case 3:
          if ( !(unsigned __int8)sub_1003D690(a1, v7) )
            goto LABEL_30;
          v17 = 3 * (unsigned __int16)v8;
          v10 = dword_106AD1D4 + 2052;
          v11 = 52 * (unsigned __int16)v8 + dword_106AD1D4 + 18832;
          v12 = dword_106AD1D4 + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_18;
        case 5:
          if ( !(unsigned __int8)sub_1003D690(a1, v7) )
            goto LABEL_30;
          v18 = 3 * (unsigned __int16)v8;
          v10 = dword_106AD1C4 + 100;
          v11 = 52 * (unsigned __int16)v8 + dword_106AD1C4 + 1596;
          v12 = dword_106AD1C4 + 8 * v18 + 4;
          v13 = 1496;
LABEL_18:
          if ( sub_1003D750(a1) )
            goto LABEL_30;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_33;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_33:
              v20 = 0;
            else
              memcpy_0(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_1003D730(a1);
          result = v20;
          break;
        default:
LABEL_30:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 106AD1BC: using guessed type int dword_106AD1BC;
// 106AD1C0: using guessed type int dword_106AD1C0;
// 106AD1C4: using guessed type int dword_106AD1C4;
// 106AD1D0: using guessed type int dword_106AD1D0;
// 106AD1D4: using guessed type int dword_106AD1D4;
// 106AD1D8: using guessed type int dword_106AD1D8;
// 106AD1E0: using guessed type int dword_106AD1E0;
// 106AD1E4: using guessed type int dword_106AD1E4;
// 106AD1E8: using guessed type int dword_106AD1E8;

//----- (1003E290) --------------------------------------------------------
char __cdecl sub_1003E290(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_1003E010(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (1003E2C0) --------------------------------------------------------
char __cdecl sub_1003E2C0(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_1003E010(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (1003E2F0) --------------------------------------------------------
char __cdecl sub_1003E2F0(char a1, int a2, void *a3, int a4)
{
  return sub_1003E010(a1, a2, 0, 0, a3, a4);
}

//----- (1003E320) --------------------------------------------------------
char __cdecl sub_1003E320(_WORD *a1, int a2, int a3, int a4, int a5)
{
  char result; // al@1
  char v6; // cl@2
  char v7; // dl@2
  __int16 v8; // ax@2
  char v9; // cl@2
  char v10; // dl@2
  __int16 v11; // ax@2
  char v12; // cl@2
  char v13; // dl@2
  __int16 v14; // ax@2
  __int16 v15; // cx@2
  char v16; // dl@2
  __int16 v17; // [sp+10h] [bp-14h]@2
  char v18; // [sp+12h] [bp-12h]@2
  char v19; // [sp+13h] [bp-11h]@2
  __int16 v20; // [sp+14h] [bp-10h]@2
  char v21; // [sp+16h] [bp-Eh]@2
  char v22; // [sp+17h] [bp-Dh]@2
  __int16 v23; // [sp+18h] [bp-Ch]@2
  char v24; // [sp+1Ah] [bp-Ah]@2
  char v25; // [sp+1Bh] [bp-9h]@2
  __int16 v26; // [sp+1Ch] [bp-8h]@2
  unsigned __int8 v27; // [sp+1Eh] [bp-6h]@2
  char v28; // [sp+1Fh] [bp-5h]@2
  char v29; // [sp+20h] [bp-4h]@2

  *a1 = 0x7FFF;
  result = -1;
  *(_DWORD *)a2 = -1;
  *(_DWORD *)a3 = -1;
  *(_DWORD *)a4 = -1;
  *(_DWORD *)a5 = -32769;
  if ( !byte_10789F94 )
  {
    (*(void (__cdecl **)(signed int, signed int, __int16 *))dword_107896F0)(129, 17, &v17);
    v6 = v18;
    *a1 = v17;
    v7 = v19;
    v8 = v20;
    *(_BYTE *)a2 = v6;
    v9 = v21;
    *(_BYTE *)(a2 + 1) = v7;
    v10 = v22;
    *(_WORD *)(a2 + 2) = v8;
    v11 = v23;
    *(_BYTE *)a3 = v9;
    v12 = v24;
    *(_BYTE *)(a3 + 1) = v10;
    v13 = v25;
    *(_WORD *)(a3 + 2) = v11;
    v14 = v26;
    *(_BYTE *)a4 = v12;
    v15 = v27;
    *(_BYTE *)(a4 + 1) = v13;
    v16 = v28;
    *(_WORD *)(a4 + 2) = v14;
    result = v29;
    *(_WORD *)a5 = v15;
    *(_BYTE *)(a5 + 2) = v16;
    *(_BYTE *)(a5 + 3) = result;
  }
  return result;
}
// 107896F0: using guessed type int dword_107896F0;
// 10789F94: using guessed type char byte_10789F94;

//----- (1003E3F0) --------------------------------------------------------
int __cdecl sub_1003E3F0(_BYTE *a1)
{
  int result; // eax@1

  result = (int)a1;
  *a1 = 0;
  if ( !byte_10789F94 )
    result = (*(int (__cdecl **)(signed int, signed int, _BYTE *))dword_107896F0)(146, 1, a1);
  return result;
}
// 107896F0: using guessed type int dword_107896F0;
// 10789F94: using guessed type char byte_10789F94;

//----- (1003E420) --------------------------------------------------------
char __cdecl sub_1003E420(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  char v3; // [sp+8h] [bp-14h]@2
  unsigned __int8 v4; // [sp+9h] [bp-13h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_10789F94 )
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_107896F0)(dword_10789A64, 18, &v3);
    result = v4 & 0xF;
    *a2 = v4 >> 4;
    *a1 = result;
  }
  return result;
}
// 107896F0: using guessed type int dword_107896F0;
// 10789A64: using guessed type int dword_10789A64;
// 10789F94: using guessed type char byte_10789F94;

//----- (1003E470) --------------------------------------------------------
char __cdecl sub_1003E470(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  unsigned __int8 v3; // [sp+8h] [bp-14h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_10789F94 )
  {
    (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_107896F0)(dword_10789A64, 18, &v3);
    result = v3 & 0xF;
    *a2 = v3 >> 4;
    *a1 = result;
  }
  return result;
}
// 107896F0: using guessed type int dword_107896F0;
// 10789A64: using guessed type int dword_10789A64;
// 10789F94: using guessed type char byte_10789F94;

//----- (1003E4C0) --------------------------------------------------------
int sub_1003E4C0()
{
  int result; // eax@1
  unsigned int v1; // ecx@1
  int v2; // edi@4
  int *v3; // esi@5
  int v4; // ebx@5
  int v5; // edx@6
  int v6; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@4
  unsigned int v8; // [sp+Ch] [bp-4h]@4

  memset(dword_10789740, 0, 0x708u);
  result = (*(int (__cdecl **)(signed int, int *))dword_107896E0)(512, &v6);
  v1 = 0;
  do
  {
    word_10789744[v1 / 2] = 0;
    dword_10789748[v1 / 4] = 0;
    dword_10789740[v1 / 4] = 0;
    v1 += 12;
  }
  while ( v1 < 0x708 );
  if ( (_BYTE)result )
  {
    dword_1078974C = v6;
    result = v8;
    v2 = (unsigned __int16)v7 + 512;
    dword_10789750 = v7;
    dword_10789754 = v8;
    if ( v8 >= 2 )
    {
      v3 = &dword_10789758;
      v4 = v8 - 1;
      do
      {
        (*(void (__cdecl **)(int, int *))dword_107896E0)(v2, &v6);
        v5 = v7;
        result = v8;
        *v3 = v6;
        v3[1] = v5;
        v3[2] = result;
        v2 += (unsigned __int16)dword_10789750;
        v3 += 3;
        --v4;
      }
      while ( v4 );
    }
  }
  return result;
}
// 107896E0: using guessed type int dword_107896E0;
// 10789740: using guessed type int dword_10789740[];
// 10789744: using guessed type __int16 word_10789744[];
// 10789748: using guessed type int dword_10789748[];
// 1078974C: using guessed type int dword_1078974C;
// 10789750: using guessed type int dword_10789750;
// 10789754: using guessed type int dword_10789754;
// 10789758: using guessed type int dword_10789758;

//----- (1003E590) --------------------------------------------------------
__int16 sub_1003E590()
{
  __int16 result; // ax@1
  unsigned int v1; // ebx@1
  unsigned int v2; // esi@1
  int v3; // edi@1
  int v4; // ebp@2
  __int16 v5; // [sp+Ch] [bp-4h]@3

  result = word_1078975C;
  v1 = dword_10789760;
  v2 = 1;
  v3 = dword_10789758;
  if ( (unsigned int)dword_10789760 >= 1 )
  {
    v4 = (unsigned __int16)word_1078975C;
    do
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_107896F0)(v3, 2, &v5);
      result = v5;
      word_10789E60[v2++] = v5;
      v3 += v4;
    }
    while ( v2 <= v1 );
  }
  return result;
}
// 107896F0: using guessed type int dword_107896F0;
// 10789758: using guessed type int dword_10789758;
// 1078975C: using guessed type __int16 word_1078975C;
// 10789760: using guessed type int dword_10789760;
// 10789E60: using guessed type __int16 word_10789E60[];

//----- (1003E5F0) --------------------------------------------------------
int __usercall sub_1003E5F0@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4)
{
  signed int v4; // edx@1
  _BYTE *v5; // ecx@2
  unsigned int v6; // ebx@2
  unsigned __int16 v7; // ax@7

  v4 = 0;
  if ( a3 > 0 )
  {
    v5 = a2;
    v6 = a3;
    do
    {
      if ( v4 & 3 )
      {
        if ( (v4 & 3) == 1 )
        {
          result = v6 >> 4;
        }
        else
        {
          --v5;
          result = (v4 & 3) - 2;
          if ( (v4 & 3) == 2 )
          {
            HIBYTE(v7) = v5[1];
            LOBYTE(v7) = *v5;
            v6 = v7;
            result = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(result) = v6;
          }
        }
      }
      else
      {
        HIWORD(result) = 0;
        BYTE1(result) = *v5--;
        LOBYTE(result) = *v5;
        v6 = (unsigned __int16)result;
        LOWORD(result) = (unsigned __int16)result >> 10;
      }
      LOBYTE(result) = (result & 0x3F) + 32;
      *(_BYTE *)(v4++ + a4) = result;
    }
    while ( v4 < a3 );
  }
  return result;
}

//----- (1003E670) --------------------------------------------------------
signed int __cdecl sub_1003E670(int a1)
{
  signed int result; // eax@1
  char v2; // [sp+8h] [bp-10h]@3
  char v3; // [sp+13h] [bp-5h]@3

  result = 538976288;
  *(_DWORD *)a1 = 538976288;
  *(_DWORD *)(a1 + 4) = 538976288;
  *(_DWORD *)(a1 + 8) = 538976288;
  *(_DWORD *)(a1 + 12) = 538976288;
  if ( byte_10789F94 )
  {
    LOBYTE(dword_106AD1EC) = 0;
    *(_BYTE *)(a1 + 16) = 0;
  }
  else if ( (_BYTE)dword_106AD1EC )
  {
    *(_DWORD *)a1 = dword_106AD1EC;
    *(_DWORD *)(a1 + 4) = dword_106AD1F0;
    *(_DWORD *)(a1 + 8) = dword_106AD1F4;
    result = dword_106AD1F8;
    *(_DWORD *)(a1 + 12) = dword_106AD1F8;
    *(_BYTE *)(a1 + 16) = 0;
  }
  else
  {
    (*(void (__cdecl **)(signed int, signed int, char *))dword_107896F0)(147, 12, &v2);
    sub_1003E5F0((int)&v3, &v3, 16, a1);
    dword_106AD1EC = *(_DWORD *)a1;
    dword_106AD1F0 = *(_DWORD *)(a1 + 4);
    result = *(_DWORD *)(a1 + 8);
    dword_106AD1F4 = *(_DWORD *)(a1 + 8);
    dword_106AD1F8 = *(_DWORD *)(a1 + 12);
    byte_106AD1FC = *(_BYTE *)(a1 + 16);
    *(_BYTE *)(a1 + 16) = 0;
  }
  return result;
}
// 106AD1EC: using guessed type int dword_106AD1EC;
// 106AD1F0: using guessed type int dword_106AD1F0;
// 106AD1F4: using guessed type int dword_106AD1F4;
// 106AD1F8: using guessed type int dword_106AD1F8;
// 106AD1FC: using guessed type char byte_106AD1FC;
// 107896F0: using guessed type int dword_107896F0;
// 10789F94: using guessed type char byte_10789F94;

//----- (1003E760) --------------------------------------------------------
char sub_1003E760()
{
  char v0; // al@1
  unsigned __int8 v1; // bl@2
  unsigned int v2; // ecx@3
  char *v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // ecx@8
  _BYTE *v7; // eax@8
  _BYTE *v8; // edx@8
  int v9; // ecx@10
  _BYTE *v10; // eax@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // eax@12
  _BYTE *v13; // edx@12
  signed int v14; // eax@14
  char result; // al@24
  char v16; // [sp+Fh] [bp-25h]@20
  char v17; // [sp+10h] [bp-24h]@1
  char v18; // [sp+1Bh] [bp-19h]@2
  char v19; // [sp+1Ch] [bp-18h]@2

  byte_10789F94 = 1;
  v0 = (*(int (__cdecl **)(signed int, signed int, char *))dword_107896F0)(147, 12, &v17);
  byte_10789F94 = 1;
  dword_106AD1EC = 0;
  dword_106AD1F0 = 0;
  dword_106AD1F4 = 0;
  dword_106AD1F8 = 0;
  byte_106AD1FC = 0;
  if ( !v0 )
    return (unsigned int)memset(dword_10789740, 0, 0x708u);
  sub_1003E5F0((int)&v19, &v18, 16, (int)&v19);
  v1 = 0;
  while ( 1 )
  {
    v2 = 10;
    v3 = &a006D0170[11 * v1];
    v4 = &v19;
    do
    {
      if ( *(_DWORD *)v4 != *(_DWORD *)v3 )
        goto LABEL_7;
      v2 -= 4;
      v3 += 4;
      v4 += 4;
    }
    while ( v2 >= 4 );
    if ( !v2 )
    {
LABEL_16:
      v14 = 0;
      goto LABEL_17;
    }
LABEL_7:
    v5 = (unsigned __int8)*v4 - (unsigned __int8)*v3;
    if ( (unsigned __int8)*v4 == (unsigned __int8)*v3 )
    {
      v6 = v2 - 1;
      v7 = v3 + 1;
      v8 = v4 + 1;
      if ( !v6 )
        goto LABEL_16;
      v5 = *v8 - *v7;
      if ( *v8 == *v7 )
      {
        v9 = v6 - 1;
        v10 = v7 + 1;
        v11 = v8 + 1;
        if ( !v9 )
          goto LABEL_16;
        v5 = *v11 - *v10;
        if ( *v11 == *v10 )
        {
          v12 = v10 + 1;
          v13 = v11 + 1;
          if ( v9 == 1 )
            goto LABEL_16;
          v5 = *v13 - *v12;
          if ( *v13 == *v12 )
            goto LABEL_16;
        }
      }
    }
    v14 = 1;
    if ( v5 <= 0 )
      v14 = -1;
LABEL_17:
    if ( !v14 )
      break;
    if ( ++v1 >= 3u )
      return (unsigned int)memset(dword_10789740, 0, 0x708u);
  }
  byte_10789F94 = 0;
  sub_1003E3F0(&v16);
  if ( v16 != 101 )
  {
    byte_10789F94 = 2;
    return (unsigned int)memset(dword_10789740, 0, 0x708u);
  }
  if ( byte_10789F94 )
    return (unsigned int)memset(dword_10789740, 0, 0x708u);
  sub_1003E470(&unk_10789E48, &byte_10789F8D);
  byte_10789F8C = byte_10789F8D - 1;
  if ( byte_10789F94 )
    return (unsigned int)memset(dword_10789740, 0, 0x708u);
  result = sub_1003E420(&unk_10789E49, &unk_10789E4A);
  byte_10789728 = 0;
  if ( byte_10789F94 )
    return (unsigned int)memset(dword_10789740, 0, 0x708u);
  return result;
}
// 106AD1EC: using guessed type int dword_106AD1EC;
// 106AD1F0: using guessed type int dword_106AD1F0;
// 106AD1F4: using guessed type int dword_106AD1F4;
// 106AD1F8: using guessed type int dword_106AD1F8;
// 106AD1FC: using guessed type char byte_106AD1FC;
// 107896F0: using guessed type int dword_107896F0;
// 10789728: using guessed type char byte_10789728;
// 10789740: using guessed type int dword_10789740[];
// 10789F8C: using guessed type char byte_10789F8C;
// 10789F8D: using guessed type char byte_10789F8D;
// 10789F94: using guessed type char byte_10789F94;

//----- (1003E920) --------------------------------------------------------
int (__cdecl *(*sub_1003E920())[2])(int, int)
{
  int (__cdecl *(*result)[2])(int, int); // eax@1
  unsigned int v1; // edi@2
  char *v2; // ecx@3
  unsigned int v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // eax@8
  _BYTE *v7; // ecx@8
  _BYTE *v8; // edx@8
  int v9; // eax@10
  _BYTE *v10; // ecx@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // ecx@12
  _BYTE *v13; // edx@12
  char v14; // [sp+0h] [bp-24h]@1
  char v15; // [sp+Bh] [bp-19h]@2
  char v16; // [sp+Ch] [bp-18h]@2

  dword_107896E0 = (int)off_100F3560;
  result = (int (__cdecl *(*)[2])(int, int))(*(int (__cdecl **)(signed int, signed int, char *))dword_107896F0)(
                                              147,
                                              12,
                                              &v14);
  if ( (_BYTE)result )
  {
    sub_1003E5F0((int)&v16, &v15, 16, (int)&v16);
    v1 = 0;
    do
    {
      v2 = (&off_100C63EC)[8 * v1];
      v3 = strlen((&off_100C63EC)[8 * v1]);
      v4 = &v16;
      if ( v3 < 4 )
      {
LABEL_6:
        if ( !v3 )
          goto LABEL_16;
      }
      else
      {
        while ( *(_DWORD *)v4 == *(_DWORD *)v2 )
        {
          v3 -= 4;
          v2 += 4;
          v4 += 4;
          if ( v3 < 4 )
            goto LABEL_6;
        }
      }
      v5 = (unsigned __int8)*v4 - (unsigned __int8)*v2;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v2 )
      {
        v6 = v3 - 1;
        v7 = v2 + 1;
        v8 = v4 + 1;
        if ( !v6
          || (v5 = *v8 - *v7, *v8 == *v7)
          && ((v9 = v6 - 1, v10 = v7 + 1, v11 = v8 + 1, !v9)
           || (v5 = *v11 - *v10, *v11 == *v10)
           && ((v12 = v10 + 1, v13 = v11 + 1, v9 == 1) || (v5 = *v13 - *v12, *v13 == *v12))) )
        {
LABEL_16:
          result = 0;
          goto LABEL_17;
        }
      }
      result = (int (__cdecl *(*)[2])(int, int))1;
      if ( v5 <= 0 )
        result = (int (__cdecl *(*)[2])(int, int))-1;
LABEL_17:
      if ( !result )
      {
        result = (&off_100C63F0)[v1];
        dword_107896E0 = (int)(&off_100C63F0)[v1];
        return result;
      }
      ++v1;
    }
    while ( v1 < 3 );
  }
  return result;
}
// 100C63EC: using guessed type char *off_100C63EC;
// 100C63F0: using guessed type int (__cdecl *(*off_100C63F0)[2])(int, int);
// 100F3560: using guessed type int (__cdecl *off_100F3560[2])(int, int);
// 107896E0: using guessed type int dword_107896E0;
// 107896F0: using guessed type int dword_107896F0;

//----- (1003EA50) --------------------------------------------------------
char __cdecl sub_1003EA50(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_1003B860((_DWORD *)a2, 2u, (int)&unk_100C64A0, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_100C64A4[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_10069830(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_10069690();
        sub_10036790(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_100364C0("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 100C64A4: using guessed type int dword_100C64A4[];

//----- (1003EB70) --------------------------------------------------------
char __cdecl sub_1003EB70(int a1)
{
  return sub_1003EA50(28, a1);
}

//----- (1003EB80) --------------------------------------------------------
char __cdecl sub_1003EB80(int a1)
{
  return sub_1003EA50(32, a1);
}

//----- (1003EB90) --------------------------------------------------------
char __cdecl sub_1003EB90(int a1)
{
  return sub_1003EA50(31, a1);
}

//----- (1003EBA0) --------------------------------------------------------
_DWORD *sub_1003EBA0()
{
  sub_10003D30();
  return sub_10055FC0();
}

//----- (1003EBB0) --------------------------------------------------------
#error "1003EBBF: call analysis failed (funcsize=10)"

//----- (1003EBD0) --------------------------------------------------------
BOOL __cdecl sub_1003EBD0(unsigned int a1)
{
  int v1; // edi@1
  __int16 i; // si@1
  char v4; // [sp+Bh] [bp-1h]@1

  v1 = sub_10069700();
  for ( i = sub_1006B970(6, 0, 1, (int)&v4); i == 12; i = sub_1006B970(6, 0, 1, (int)&v4) )
  {
    if ( sub_10069700() - v1 >= a1 )
      break;
    sub_10069880(100);
  }
  return i == 12;
}

//----- (1003EC40) --------------------------------------------------------
char __thiscall sub_1003EC40(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1006BA40(81, (_BYTE *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1003EC60) --------------------------------------------------------
void __cdecl sub_1003EC60(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  sub_1006BA40(120, a1);
  sub_1006BA40(124, a2);
  sub_1006BA40(121, a3);
}

//----- (1003EC90) --------------------------------------------------------
int __cdecl sub_1003EC90(int a1)
{
  return sub_1006A0A0(3025, a1, 84);
}

//----- (1003ECB0) --------------------------------------------------------
signed int sub_1003ECB0()
{
  bool v0; // zf@1
  signed int result; // eax@1
  char v2; // [sp+3h] [bp-5h]@1
  int v3; // [sp+4h] [bp-4h]@1

  v0 = sub_1006B9E0(6, &v3, &v2) == 0;
  result = -4;
  if ( v0 )
    result = v3;
  return result;
}

//----- (1003ECE0) --------------------------------------------------------
void __cdecl sub_1003ECE0(_BYTE *a1)
{
  sub_1006BA40(129, a1);
}

//----- (1003ED00) --------------------------------------------------------
char __cdecl sub_1003ED00(int a1, size_t a2, void *a3)
{
  char result; // al@2

  if ( sub_1006B970(6, a1, a2, (int)a3) )
  {
    memset(a3, 0, a2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1003ED40) --------------------------------------------------------
int __cdecl sub_1003ED40(int a1)
{
  return sub_1006A190(3025, a1, 84);
}

//----- (1003ED60) --------------------------------------------------------
char __fastcall sub_1003ED60(int *a1)
{
  char v1; // bl@1
  unsigned int v2; // eax@7
  int *v3; // edx@7
  int v4; // esi@11
  int v5; // eax@12
  _BYTE *v6; // edx@12
  int v7; // eax@14
  _BYTE *v8; // edx@14
  _BYTE *v9; // edx@16
  signed int v10; // eax@18
  char result; // al@25
  char v12; // [sp+4h] [bp-68h]@1
  int v13; // [sp+8h] [bp-64h]@2
  int v14; // [sp+Ch] [bp-60h]@29
  int v15; // [sp+10h] [bp-5Ch]@29
  char v16; // [sp+12h] [bp-5Ah]@3
  char v17; // [sp+13h] [bp-59h]@4
  int v18; // [sp+14h] [bp-58h]@5
  char v19; // [sp+18h] [bp-54h]@6
  int v20; // [sp+1Ch] [bp-50h]@2
  int v21; // [sp+20h] [bp-4Ch]@29
  int v22; // [sp+24h] [bp-48h]@29
  char v23; // [sp+26h] [bp-46h]@3
  char v24; // [sp+27h] [bp-45h]@4
  int v25; // [sp+28h] [bp-44h]@5
  char v26; // [sp+2Ch] [bp-40h]@6
  int v27; // [sp+2Dh] [bp-3Fh]@7
  int v28; // [sp+31h] [bp-3Bh]@29
  int v29; // [sp+35h] [bp-37h]@29
  int v30; // [sp+3Ch] [bp-30h]@2
  int v31; // [sp+40h] [bp-2Ch]@2
  int v32; // [sp+44h] [bp-28h]@2
  int v33; // [sp+48h] [bp-24h]@2
  int v34; // [sp+4Ch] [bp-20h]@2
  int v35; // [sp+50h] [bp-1Ch]@2
  int v36; // [sp+54h] [bp-18h]@2
  char v37; // [sp+58h] [bp-14h]@2
  int v38; // [sp+5Ch] [bp-10h]@2
  int v39; // [sp+60h] [bp-Ch]@29
  int v40; // [sp+64h] [bp-8h]@29

  v1 = 1;
  v12 = 1;
  if ( byte_10789F94 )
  {
    v1 = 3;
    goto LABEL_24;
  }
  sub_1003ED00(147, 0xCu, &v38);
  sub_1003ED00(129, 0x11u, &v13);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  sub_1006A100(2000, &v20, 29, &v30);
  LOWORD(a1) = v20;
  if ( (_WORD)v20 != (_WORD)v13
    || v23 != v16
    || v24 != v17
    || (LOWORD(a1) = v25, v25 != v18)
    || (LOBYTE(a1) = v26, v26 != v19) )
  {
LABEL_22:
    v1 = 2;
LABEL_24:
    v12 = v1;
    goto LABEL_25;
  }
  v2 = 12;
  a1 = &v38;
  v3 = &v27;
  do
  {
    if ( *v3 != *a1 )
      goto LABEL_11;
    v2 -= 4;
    ++a1;
    ++v3;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_20:
    v10 = 0;
    goto LABEL_21;
  }
LABEL_11:
  v4 = *(_BYTE *)v3 - *(_BYTE *)a1;
  if ( *(_BYTE *)v3 == *(_BYTE *)a1 )
  {
    v5 = v2 - 1;
    a1 = (int *)((char *)a1 + 1);
    v6 = (char *)v3 + 1;
    if ( !v5 )
      goto LABEL_20;
    v4 = *v6 - *(_BYTE *)a1;
    if ( *v6 == *(_BYTE *)a1 )
    {
      v7 = v5 - 1;
      a1 = (int *)((char *)a1 + 1);
      v8 = v6 + 1;
      if ( !v7 )
        goto LABEL_20;
      v4 = *v8 - *(_BYTE *)a1;
      if ( *v8 == *(_BYTE *)a1 )
      {
        a1 = (int *)((char *)a1 + 1);
        v9 = v8 + 1;
        if ( v7 == 1 )
          goto LABEL_20;
        v4 = *v9 - *(_BYTE *)a1;
        if ( *v9 == *(_BYTE *)a1 )
          goto LABEL_20;
      }
    }
  }
  v10 = 1;
  if ( v4 <= 0 )
    v10 = -1;
LABEL_21:
  if ( v10 )
    goto LABEL_22;
LABEL_25:
  result = sub_10037100(a1);
  if ( !result || result == 3 )
    result = sub_100370C0(v12);
  if ( v1 == 2 )
  {
    v22 = v15;
    v20 = v13;
    v21 = v14;
    v27 = v38;
    v25 = v18;
    v26 = v19;
    v28 = v39;
    v29 = v40;
    result = sub_1006A190(2000, (int)&v20, 29);
  }
  return result;
}
// 10789F94: using guessed type char byte_10789F94;

//----- (1003EF80) --------------------------------------------------------
char sub_1003EF80()
{
  int *v0; // ecx@1

  sub_1003EBD0(0x9C40u);
  sub_10035D60(&off_100C7228);
  return sub_1003ED60(v0);
}
// 100C7228: using guessed type int (__cdecl *off_100C7228)(int, size_t, void *);

//----- (1003EFA0) --------------------------------------------------------
void sub_1003EFA0()
{
  dword_10789724 = -15;
}
// 10789724: using guessed type int dword_10789724;

//----- (1003EFB0) --------------------------------------------------------
signed int sub_1003EFB0()
{
  return sub_1006C8D0((int)&off_100C725C);
}
// 100C725C: using guessed type char *off_100C725C;

//----- (1003EFC0) --------------------------------------------------------
signed int sub_1003EFC0()
{
  char v0; // bl@1
  signed int result; // eax@3

  v0 = 1;
  if ( (unsigned __int8)sub_1003EFB0() )
    v0 = *(_BYTE *)(dword_10789724 + 1456);
  result = (unsigned __int8)v0;
  if ( (unsigned __int8)v0 >= 8u )
    result = 1;
  return result;
}
// 10789724: using guessed type int dword_10789724;

//----- (1003EFF0) --------------------------------------------------------
char sub_1003EFF0()
{
  char v0; // bl@1

  v0 = 0;
  if ( (unsigned __int8)sub_1003EFB0() )
  {
    sub_100697D0(101, 10000);
    if ( !*(_BYTE *)(dword_10789724 + 1444)
      || !*(_BYTE *)(dword_10789724 + 1451)
      || (v0 = 1, *(_WORD *)(dword_10789724 + 1456) <= 1u)
      || *(float *)(dword_10789724 + 1480) <= 15.433242 )
    {
      v0 = 0;
    }
    sub_100697B0(101);
  }
  return v0;
}
// 10789724: using guessed type int dword_10789724;

//----- (1003F060) --------------------------------------------------------
bool __cdecl sub_1003F060(float *a1)
{
  bool v1; // bl@1
  double v2; // st7@3

  *a1 = 9.9999996e24;
  v1 = 0;
  if ( (unsigned __int8)sub_1003EFB0() )
  {
    sub_100697D0(101, 10000);
    if ( *(_BYTE *)(dword_10789724 + 1444) )
      v2 = (double)(unsigned int)(sub_10069700() - *(_DWORD *)(dword_10789724 + 1292))
         / 1000.0
         * *(float *)(dword_10789724 + 1488)
         + *(float *)(dword_10789724 + 1484);
    else
      v2 = *(float *)(dword_10789724 + 1484);
    *a1 = v2;
    *a1 = sub_10022BB0(*a1);
    v1 = *(_WORD *)(dword_10789724 + 1456) > 1u;
    sub_100697B0(101);
  }
  return v1;
}
// 10789724: using guessed type int dword_10789724;

//----- (1003F110) --------------------------------------------------------
void sub_1003F110()
{
  dword_10789720 = -15;
}
// 10789720: using guessed type int dword_10789720;

//----- (1003F120) --------------------------------------------------------
int sub_1003F120()
{
  int result; // eax@1

  result = 0;
  dword_106AD200 = -15;
  dword_1078971C = 0;
  dword_10789710 = 0;
  dword_10789714 = 0;
  dword_10789718 = 0;
  return result;
}
// 106AD200: using guessed type int dword_106AD200;
// 10789710: using guessed type int dword_10789710;
// 10789714: using guessed type int dword_10789714;
// 10789718: using guessed type int dword_10789718;
// 1078971C: using guessed type int dword_1078971C;

//----- (1003F150) --------------------------------------------------------
char sub_1003F150()
{
  char v0; // bl@1
  signed int v1; // esi@2
  char result; // al@4

  v0 = sub_1006C8D0((int)&off_100C72B4);
  if ( v0 )
  {
    dword_1078971C = dword_106AD200;
    v1 = *(_BYTE *)(dword_106AD200 + 667) != 0 ? 1100 : 2000;
    if ( v1 + *(_DWORD *)(dword_1078971C + 36) < (unsigned int)sub_10069700() )
      v0 = 0;
    dword_10789718 = dword_106AD200 + 56116;
    result = v0;
    dword_10789710 = dword_106AD200 + 1516;
    dword_10789714 = dword_106AD200 + 20484;
  }
  else
  {
    dword_1078971C = 0;
    dword_10789710 = 0;
    dword_10789714 = 0;
    dword_10789718 = 0;
    result = 0;
  }
  return result;
}
// 100C72B4: using guessed type char *off_100C72B4;
// 106AD200: using guessed type int dword_106AD200;
// 10789710: using guessed type int dword_10789710;
// 10789714: using guessed type int dword_10789714;
// 10789718: using guessed type int dword_10789718;
// 1078971C: using guessed type int dword_1078971C;

//----- (1003F1F0) --------------------------------------------------------
int __cdecl sub_1003F1F0(int a1, int a2)
{
  byte_10789FA4[0] = 0;
  return nullsub_1(a1, a2);
}

//----- (1003F210) --------------------------------------------------------
signed int sub_1003F210()
{
  return 1000;
}

//----- (1003F230) --------------------------------------------------------
int sub_1003F230()
{
  return sub_100452A0((int)off_100C77F0);
}
// 100C77F0: using guessed type int (*off_100C77F0[4])();

//----- (1003F240) --------------------------------------------------------
signed int __cdecl sub_1003F240(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (1003F290) --------------------------------------------------------
int __cdecl sub_1003F290(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (1003F380) --------------------------------------------------------
unsigned int __cdecl sub_1003F380(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (1003F3D0) --------------------------------------------------------
unsigned int __cdecl sub_1003F3D0(_BYTE *a1, __int16 a2, __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  int v8; // eax@9
  char v9; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((signed __int16)a1 >= a2 ? (v8 = (signed __int16)a1 < a3,
                                    LOBYTE(v8) = (signed __int16)a1 <= a3,
                                    result = (v8 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v9 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v9;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (1003F470) --------------------------------------------------------
unsigned int __cdecl sub_1003F470(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (1003F530) --------------------------------------------------------
unsigned int __cdecl sub_1003F530(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_10036690(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (1003F590) --------------------------------------------------------
int __cdecl sub_1003F590(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (1003F5E0) --------------------------------------------------------
int __cdecl sub_1003F5E0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (1003F680) --------------------------------------------------------
int __cdecl sub_1003F680(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (1003F730) --------------------------------------------------------
int __cdecl sub_1003F730(int *a1, int a2)
{
  int result; // eax@1

  result = a2 + (*(int (**)(void))dword_10789708)();
  *a1 = result;
  return result;
}
// 10789708: using guessed type int dword_10789708;

//----- (1003F750) --------------------------------------------------------
char __cdecl sub_1003F750(unsigned __int16 a1, int a2, char a3)
{
  int v3; // ecx@0
  char result; // al@1
  int v5; // [sp-2h] [bp-4h]@1

  v5 = v3;
  result = 31;
  BYTE3(v5) = 31;
  switch ( a1 )
  {
    case 0x1Au:
      if ( a3 )
      {
        sub_1006BA40(44, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_100368E0((void *)a1);
      }
      break;
    case 0u:
    case 0x26u:
    case 0x2Bu:
      if ( a3 )
      {
        sub_1006BA40(77, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10036910((void *)a1);
      }
      break;
    case 0x30u:
    case 0x31u:
      result = 18;
      break;
    case 8u:
    case 9u:
      result = 32;
      break;
    case 0xEu:
    case 0xFu:
    case 0x10u:
      if ( a3 )
      {
        sub_1006BA40(17, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = 33;
      }
      break;
    case 4u:
    case 5u:
      result = sub_10036B00();
      break;
    case 0x11u:
    case 0x12u:
    case 0x13u:
      if ( a3 )
      {
        sub_1006BA40(14, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10036BF0(a1);
      }
      break;
    case 0x14u:
    case 0x15u:
      result = 39;
      break;
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
      if ( a3 )
      {
        sub_1006BA40(45, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10036DD0((void *)a1);
      }
      break;
    case 0x1Eu:
    case 0x1Fu:
      if ( a3 )
      {
        sub_1006BA40(15, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10036A50(a1);
      }
      break;
    case 0x20u:
    case 0x21u:
      if ( a3 )
      {
        sub_1006BA40(16, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_100369B0(a1);
      }
      break;
    case 0x22u:
    case 0x23u:
      sub_1006BA40(67, (_BYTE *)&v5 + 3);
      result = BYTE3(v5);
      break;
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
      result = 0;
      break;
    case 6u:
    case 7u:
      result = 34;
      break;
    case 0x24u:
    case 0x25u:
      result = 41;
      break;
    case 0x29u:
      result = 23;
      break;
    case 1u:
    case 2u:
    case 3u:
    case 0x2Du:
    case 0x2Eu:
      result = 5;
      break;
    case 0x2Fu:
      result = 51;
      break;
    case 0x32u:
      if ( a3 )
      {
        sub_1006BA40(136, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10036E00(a1);
      }
      break;
    default:
      return result;
  }
  return result;
}

//----- (1003F950) --------------------------------------------------------
char __cdecl sub_1003F950(char a1)
{
  char result; // al@3

  if ( a1 == 1 )
  {
    result = 2;
  }
  else if ( a1 == 3 )
  {
    result = 3;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1003F970) --------------------------------------------------------
char __cdecl sub_1003F970(unsigned int a1, float *a2)
{
  __int16 v2; // si@1
  int v3; // edx@1
  char v4; // al@1
  char v5; // cl@1
  char result; // al@3
  float *v7; // edi@37
  int v8; // esi@37
  char v9; // al@51

  v2 = a1;
  v3 = a1 & 0x3F;
  v4 = (a1 >> 12) & 1;
  v5 = 31;
  LOBYTE(a1) = 31;
  switch ( v3 )
  {
    case 0:
    case 1:
      if ( v4 )
      {
        sub_1006BA40(44, &a1);
        result = a1;
      }
      else
      {
        result = sub_100368E0((void *)31);
      }
      break;
    case 2:
    case 27:
      if ( v4 )
      {
        sub_1006BA40(77, &a1);
        result = a1;
      }
      else
      {
        result = sub_10036910((void *)31);
      }
      break;
    case 3:
      result = sub_10036910((void *)31) != 30 ? 29 : 12;
      break;
    case 4:
      v5 = sub_10036910((void *)31);
      if ( v5 == 21 )
      {
        if ( !a2 || *a2 >= 1000.0 )
          goto LABEL_60;
        result = 29;
      }
      else
      {
        if ( !a2 || *a2 >= 185.2 )
          goto LABEL_60;
        result = 12;
      }
      break;
    case 5:
      result = 18;
      break;
    case 10:
      result = 32;
      break;
    case 11:
      result = sub_10036B90((void *)31);
      break;
    case 12:
      if ( v4 )
      {
        sub_1006BA40(17, &a1);
        result = a1;
      }
      else
      {
        result = 33;
      }
      break;
    case 13:
    case 14:
      result = sub_10036B00();
      break;
    case 15:
      if ( v4 )
      {
        sub_1006BA40(49, &a1);
        result = a1;
      }
      else
      {
        result = sub_10036BC0((void *)31);
      }
      break;
    case 16:
    case 17:
      if ( v4 )
      {
        sub_1006BA40(14, &a1);
        result = a1;
      }
      else
      {
        result = sub_10036BF0(31);
      }
      break;
    case 18:
      result = 49;
      break;
    case 19:
      result = 39;
      break;
    case 20:
      if ( v4 )
      {
        sub_1006BA40(45, &a1);
        result = a1;
      }
      else
      {
        result = sub_10036DD0((void *)31);
      }
      break;
    case 21:
      if ( v4 )
      {
        sub_1006BA40(15, &a1);
        result = a1;
      }
      else
      {
        result = sub_10036A50(31);
      }
      break;
    case 36:
      v7 = a2;
      v8 = v2 & 0x1000;
      switch ( (unsigned __int8)sub_1003F970(v8 | 0x15, a2) )
      {
        case 0xDu:
          result = (unsigned __int8)sub_1003F970(v8 | 2, v7) != 21 ? 45 : 57;
          break;
        case 0x18u:
          result = (unsigned __int8)sub_1003F970(v8 | 2, v7) != 21 ? 54 : 59;
          break;
        case 0x10u:
          result = (unsigned __int8)sub_1003F970(v8 | 2, v7) != 21 ? 53 : 58;
          break;
        case 0x13u:
          result = (unsigned __int8)sub_1003F970(v8 | 2, v7) != 21 ? 55 : 60;
          break;
        default:
          result = 4 * ((unsigned __int8)sub_1003F970(v8 | 2, v7) == 21) + 52;
          break;
      }
      break;
    case 22:
      if ( v4 )
      {
        sub_1006BA40(16, &a1);
        result = a1;
      }
      else
      {
        result = sub_100369B0(31);
      }
      break;
    case 23:
      result = 50;
      break;
    case 24:
      result = 0;
      break;
    case 25:
      result = 34;
      break;
    case 26:
      result = 1;
      break;
    case 38:
    case 39:
    case 42:
    case 43:
      result = 5;
      break;
    case 40:
    case 41:
      v9 = sub_100813E0();
      result = sub_1003F950(v9);
      break;
    case 29:
      result = 41;
      break;
    case 30:
      result = 42;
      break;
    case 31:
      result = 43;
      break;
    case 32:
      result = sub_10036E00(31);
      break;
    case 33:
      result = 46;
      break;
    case 34:
      result = 47;
      break;
    case 35:
      result = 48;
      break;
    case 37:
      v5 = (sub_10036E00(31) != 19) + 61;
      goto LABEL_60;
    default:
LABEL_60:
      result = v5;
      break;
  }
  return result;
}

//----- (1003FD90) --------------------------------------------------------
double __cdecl sub_1003FD90(int a1, unsigned __int16 a2, char a3, char *a4)
{
  unsigned __int16 v4; // si@1
  char v5; // al@1
  double v6; // st7@3
  double result; // st7@16
  int v8; // eax@22
  int v9; // eax@23
  int v10; // eax@29
  int v11; // eax@30
  int v12; // eax@39
  int v13; // eax@40
  int v14; // eax@46
  int v15; // eax@47
  float v16; // [sp+4h] [bp-4h]@1

  v16 = 1.0;
  v4 = a2;
  v5 = sub_1003F750(a2, 0, a3);
  *a4 = v5;
  switch ( v4 )
  {
    case 0u:
    case 0x1Au:
    case 0x26u:
    case 0x2Bu:
    case 0x30u:
    case 0x31u:
      switch ( v5 )
      {
        case 0x12:
          v6 = 39.370079;
          goto LABEL_64;
        case 0xC:
          v6 = 3.2808399;
          goto LABEL_64;
        case 0x1E:
          v6 = 0.00053995679;
          goto LABEL_64;
        case 0x15:
          goto LABEL_63;
        default:
          goto LABEL_67;
      }
      goto LABEL_67;
    case 8u:
    case 9u:
      v6 = 100.0;
      goto LABEL_64;
    case 0xEu:
    case 0xFu:
    case 0x10u:
      if ( v5 == 40 )
        v6 = 0.0000099999997;
      else
        v6 = 0.0001450377;
      goto LABEL_64;
    case 4u:
    case 5u:
      v6 = 0.00029530001;
      goto LABEL_64;
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
      if ( v5 == 28 )
        v6 = 60.0;
      else
        v6 = 196.85039;
      goto LABEL_64;
    case 0x11u:
    case 0x12u:
      if ( v5 != 10 || *(float *)&a1 == 9.8999998e24 )
        goto LABEL_67;
      sub_10056050((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 0x13u:
      if ( v5 != 10 )
        goto LABEL_65;
      v6 = 1.8;
      goto LABEL_64;
    case 0x1Eu:
    case 0x1Fu:
      switch ( v5 )
      {
        case 0xD:
          v6 = 0.26417205;
          goto LABEL_64;
        case 0x10:
          v6 = 0.21997361;
          goto LABEL_64;
        case 0x13:
          v8 = (unsigned __int8)sub_10036A20((void *)v4);
          if ( (_BYTE)v8 )
          {
            v9 = v8 - 1;
            if ( v9 )
            {
              if ( v9 == 1 )
                v6 = 0.77890778;
              else
                v6 = 0.84999973;
            }
            else
            {
              v6 = 0.80407244;
            }
          }
          else
          {
            v6 = 0.71895844;
          }
          goto LABEL_64;
        case 0x18:
          v10 = (unsigned __int8)sub_10036A20((void *)v4);
          if ( (_BYTE)v10 )
          {
            v11 = v10 - 1;
            if ( v11 )
            {
              if ( v11 == 1 )
                v6 = 1.7171981;
              else
                v6 = 1.8756201;
            }
            else
            {
              v6 = 1.7726756;
            }
          }
          else
          {
            v6 = 1.5850322;
          }
          goto LABEL_64;
        default:
          goto LABEL_67;
      }
      goto LABEL_67;
    case 0x20u:
    case 0x21u:
      switch ( v5 )
      {
        case 0xE:
          v6 = 951.01935;
          break;
        case 0x11:
          v6 = 791.90497;
          break;
        case 0x14:
          v12 = (unsigned __int8)sub_10036A20((void *)v4);
          if ( (_BYTE)v12 )
          {
            v13 = v12 - 1;
            if ( v13 )
            {
              if ( v13 == 1 )
                v6 = 2804.0679;
              else
                v6 = 3059.999;
            }
            else
            {
              v6 = 2894.6609;
            }
          }
          else
          {
            v6 = 2588.2505;
          }
          break;
        case 0x19:
          v14 = (unsigned __int8)sub_10036A20((void *)v4);
          if ( (_BYTE)v14 )
          {
            v15 = v14 - 1;
            if ( v15 )
            {
              if ( v15 == 1 )
                v6 = 6181.9131;
              else
                v6 = 6752.2324;
            }
            else
            {
              v6 = 6381.6323;
            }
          }
          else
          {
            v6 = 5706.1162;
          }
          break;
        default:
          v6 = 3600.0;
          break;
      }
      goto LABEL_64;
    case 0x22u:
    case 0x23u:
      if ( v5 == 45 )
        v6 = 0.0020439588;
      else
        v6 = 0.0023521457;
      goto LABEL_64;
    case 0x28u:
      v6 = 0.73756248;
      goto LABEL_64;
    case 0x29u:
      v6 = 1.9438444;
      goto LABEL_64;
    case 0x2Du:
    case 0x2Eu:
      v6 = 57.29578;
      goto LABEL_64;
    case 0x2Fu:
      v6 = 61.023743;
      goto LABEL_64;
    case 0x32u:
      if ( v5 == 19 )
LABEL_63:
        v6 = 0.001;
      else
        v6 = 0.0022046;
LABEL_64:
      v16 = v6;
LABEL_65:
      if ( *(float *)&a1 == 9.8999998e24 )
        goto LABEL_67;
      *(float *)&a1 = *(float *)&a1 * v16;
      result = *(float *)&a1;
      break;
    default:
LABEL_67:
      result = *(float *)&a1;
      break;
  }
  return result;
}

//----- (10040160) --------------------------------------------------------
double __cdecl sub_10040160(int a1, unsigned int a2)
{
  __int16 v2; // si@1
  char v3; // al@1
  void *v4; // ecx@1
  double result; // st7@3
  int v6; // eax@26
  int v7; // eax@27
  int v8; // eax@33
  int v9; // eax@34
  double v10; // st7@42
  float v11; // ST0C_4@44
  int v12; // eax@48
  int v13; // eax@49
  int v14; // eax@55
  int v15; // eax@56
  float v16; // [sp+Ch] [bp-4h]@1

  v2 = a2;
  v16 = 1.0;
  v3 = sub_1003F970(a2, (float *)&a1);
  v4 = (void *)(v2 & 0x3F);
  switch ( v4 )
  {
    case 0u:
    case 1u:
    case 2u:
    case 3u:
    case 4u:
    case 0x1Bu:
      switch ( v3 )
      {
        case 0xC:
          *(float *)&a1 = (float)3.2808399 * *(float *)&a1;
          return *(float *)&a1;
        case 0x1E:
          *(float *)&a1 = (float)0.00053995679 * *(float *)&a1;
          return *(float *)&a1;
        case 0x12:
          *(float *)&a1 = (float)39.370079 * *(float *)&a1;
          return *(float *)&a1;
        case 0x15:
          goto LABEL_67;
        default:
          goto LABEL_69;
      }
      goto LABEL_69;
    case 0xAu:
      *(float *)&a1 = (float)100.0 * *(float *)&a1;
      return *(float *)&a1;
    case 0xBu:
      if ( v3 != 15 )
        goto LABEL_8;
      *(float *)&a1 = (float)0.0099999998 * *(float *)&a1;
      return *(float *)&a1;
    case 0xDu:
    case 0xEu:
LABEL_8:
      *(float *)&a1 = (float)0.00029530001 * *(float *)&a1;
      return *(float *)&a1;
    case 0xCu:
      if ( v3 == 40 )
      {
        *(float *)&a1 = (float)0.0000099999997 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.0001450377 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0xFu:
      if ( v3 == 22 )
      {
        *(float *)&a1 = (float)3.5999999 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)1.9438444 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x14u:
      if ( v3 == 28 )
      {
        *(float *)&a1 = (float)60.0 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)196.85039 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x10u:
      if ( v3 != 10 )
        goto LABEL_69;
      sub_10056050((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 0x11u:
      if ( v3 != 10 )
        goto LABEL_68;
      *(float *)&a1 = (float)1.8 * *(float *)&a1;
      return *(float *)&a1;
    case 0x15u:
      switch ( v3 )
      {
        case 0xD:
          *(float *)&a1 = (float)0.26417205 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x10:
          *(float *)&a1 = (float)0.21997361 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x13:
          v6 = (unsigned __int8)sub_10036A20(v4);
          if ( (_BYTE)v6 )
          {
            v7 = v6 - 1;
            if ( v7 )
            {
              if ( v7 == 1 )
              {
                *(float *)&a1 = (float)0.77890778 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.84999973 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.80407244 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.71895844 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x18:
          v8 = (unsigned __int8)sub_10036A20(v4);
          if ( (_BYTE)v8 )
          {
            v9 = v8 - 1;
            if ( v9 )
            {
              if ( v9 == 1 )
              {
                *(float *)&a1 = (float)1.7171981 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)1.8756201 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)1.7726756 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)1.5850322 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          goto LABEL_69;
      }
      return result;
    case 0x24u:
      if ( (unsigned __int8)v3 < 0x38u || (unsigned __int8)v3 > 0x3Cu )
        v10 = 0.00053995679;
      else
        v10 = 0.001;
      v11 = v10;
      *(float *)&a1 = v11 * *(float *)&a1;
      *(float *)&a1 = sub_10040790(a1, v2 & 0x1000 | 0x15u);
      return *(float *)&a1;
    case 0x16u:
      switch ( v3 )
      {
        case 0xE:
          *(float *)&a1 = (float)951.01935 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x11:
          *(float *)&a1 = (float)791.90497 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x14:
          v12 = (unsigned __int8)sub_10036A20(v4);
          if ( (_BYTE)v12 )
          {
            v13 = v12 - 1;
            if ( v13 )
            {
              if ( v13 == 1 )
              {
                *(float *)&a1 = (float)2804.0679 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)3059.999 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)2894.6609 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)2588.2505 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x19:
          v14 = (unsigned __int8)sub_10036A20(v4);
          if ( (_BYTE)v14 )
          {
            v15 = v14 - 1;
            if ( v15 )
            {
              if ( v15 == 1 )
              {
                *(float *)&a1 = (float)6181.9131 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)6752.2324 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)6381.6323 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)5706.1162 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          *(float *)&a1 = (float)3600.0 * *(float *)&a1;
          result = *(float *)&a1;
          break;
      }
      return result;
    case 0x20u:
      if ( v3 == 19 )
        goto LABEL_67;
      *(float *)&a1 = (float)0.0022046 * *(float *)&a1;
      return *(float *)&a1;
    case 0x25u:
      if ( v3 == 61 )
      {
LABEL_67:
        v16 = 0.001;
LABEL_68:
        *(float *)&a1 = v16 * *(float *)&a1;
LABEL_69:
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.0022046 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    default:
      goto LABEL_69;
  }
}

//----- (10040790) --------------------------------------------------------
double __cdecl sub_10040790(int a1, unsigned int a2)
{
  __int16 v2; // di@1
  unsigned int v3; // esi@1
  void *v4; // ecx@1
  char v5; // bl@1
  double result; // st7@5
  int v7; // eax@28
  int v8; // eax@29
  int v9; // eax@35
  int v10; // eax@36
  double v11; // st7@44
  float v12; // ST1C_4@46
  int v13; // eax@50
  int v14; // eax@51
  int v15; // eax@57
  int v16; // eax@58
  float v17; // [sp+14h] [bp-4h]@1

  v17 = 1.0;
  v2 = a2;
  v3 = a2 & 0x3F;
  v5 = sub_1003F970(a2, 0);
  if ( v3 == 4 )
    sub_100364C0("..\\lib\\adl\\cdp_cnvt.c", 1174, 1, 0);
  switch ( v3 )
  {
    case 0u:
    case 1u:
    case 2u:
    case 3u:
    case 0x1Bu:
      switch ( v5 )
      {
        case 0xC:
          *(float *)&a1 = (float)0.3048 * *(float *)&a1;
          return *(float *)&a1;
        case 0x1E:
          *(float *)&a1 = (float)1852.0 * *(float *)&a1;
          return *(float *)&a1;
        case 0x12:
          *(float *)&a1 = (float)0.0254 * *(float *)&a1;
          return *(float *)&a1;
        case 0x15:
          goto LABEL_69;
        default:
          goto LABEL_71;
      }
      goto LABEL_71;
    case 0xAu:
      *(float *)&a1 = (float)0.0099999998 * *(float *)&a1;
      return *(float *)&a1;
    case 0xBu:
      if ( v5 != 15 )
        goto LABEL_10;
      *(float *)&a1 = (float)100.0 * *(float *)&a1;
      return *(float *)&a1;
    case 0xDu:
    case 0xEu:
LABEL_10:
      *(float *)&a1 = (float)3386.3867 * *(float *)&a1;
      return *(float *)&a1;
    case 0xCu:
      if ( v5 == 40 )
      {
        *(float *)&a1 = (float)100000.0 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)6894.7593 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0xFu:
      if ( v5 == 22 )
      {
        *(float *)&a1 = (float)0.27777779 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.51444447 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x14u:
      if ( v5 == 11 )
      {
        *(float *)&a1 = (float)0.00508 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.016666668 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x10u:
      if ( v5 != 10 )
        goto LABEL_71;
      sub_10056070((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 0x11u:
      if ( v5 != 10 )
        goto LABEL_70;
      *(float *)&a1 = (float)0.55555558 * *(float *)&a1;
      return *(float *)&a1;
    case 0x15u:
      switch ( v5 )
      {
        case 0xD:
          *(float *)&a1 = (float)3.7854118 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x10:
          *(float *)&a1 = (float)4.546 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x13:
          v7 = (unsigned __int8)sub_10036A20(v4);
          if ( (_BYTE)v7 )
          {
            v8 = v7 - 1;
            if ( v8 )
            {
              if ( v8 == 1 )
              {
                *(float *)&a1 = (float)1.283849 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)1.176471 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)1.243669 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)1.390901 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x18:
          v9 = (unsigned __int8)sub_10036A20(v4);
          if ( (_BYTE)v9 )
          {
            v10 = v9 - 1;
            if ( v10 )
            {
              if ( v10 == 1 )
              {
                *(float *)&a1 = (float)0.582344 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.53315699 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.56411898 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.63090199 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          goto LABEL_71;
      }
      return result;
    case 0x24u:
      if ( (unsigned __int8)v5 < 0x38u || (unsigned __int8)v5 > 0x3Cu )
        v11 = 1852.0;
      else
        v11 = 1000.0;
      v12 = v11;
      *(float *)&a1 = v12 * *(float *)&a1;
      *(float *)&a1 = sub_10040160(a1, v2 & 0x1000 | 0x15u);
      return *(float *)&a1;
    case 0x16u:
      switch ( v5 )
      {
        case 0xE:
          *(float *)&a1 = (float)0.0010515032 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x11:
          *(float *)&a1 = (float)0.0012627778 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x14:
          v13 = (unsigned __int8)sub_10036A20(v4);
          if ( (_BYTE)v13 )
          {
            v14 = v13 - 1;
            if ( v14 )
            {
              if ( v14 == 1 )
              {
                *(float *)&a1 = (float)0.00035662472 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.00032679751 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.00034546363 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.00038636138 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x19:
          v15 = (unsigned __int8)sub_10036A20(v4);
          if ( (_BYTE)v15 )
          {
            v16 = v15 - 1;
            if ( v16 )
            {
              if ( v16 == 1 )
              {
                *(float *)&a1 = (float)0.00016176222 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.00014809916 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.00015669972 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.00017525055 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          *(float *)&a1 = (float)0.00027777778 * *(float *)&a1;
          result = *(float *)&a1;
          break;
      }
      return result;
    case 0x20u:
      if ( v5 == 19 )
        goto LABEL_69;
      *(float *)&a1 = (float)453.59241 * *(float *)&a1;
      return *(float *)&a1;
    case 0x25u:
      if ( v5 == 61 )
      {
LABEL_69:
        v17 = 1000.0;
LABEL_70:
        *(float *)&a1 = v17 * *(float *)&a1;
LABEL_71:
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)453.59241 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    default:
      goto LABEL_71;
  }
}

//----- (10040E80) --------------------------------------------------------
int __cdecl sub_10040E80(float a1, float a2, float a3, float a4, float a5, int a6, int a7)
{
  int v7; // esi@1
  double v8; // ST1C_8@5
  float v9; // ST18_4@5
  float v10; // ST04_4@5
  double v11; // st7@5
  double v12; // ST1C_8@7
  float v13; // ST18_4@7
  float v14; // ST04_4@7
  float v15; // ST04_4@8
  float v16; // ST04_4@8
  float v18; // [sp+4h] [bp-1Ch]@5
  int v19; // [sp+10h] [bp-10h]@1
  float v20; // [sp+14h] [bp-Ch]@1
  float v21; // [sp+34h] [bp+14h]@5
  float v22; // [sp+34h] [bp+14h]@7
  int v23; // [sp+38h] [bp+18h]@5
  int v24; // [sp+38h] [bp+18h]@7

  v7 = a6;
  v20 = 1.0;
  v19 = a6;
  BYTE2(v19) = (signed int)((double)(unsigned __int8)((unsigned int)a6 >> 16) * 0.8999999761581421);
  BYTE1(v19) = (signed int)((double)BYTE1(v19) * 0.8999999761581421);
  LOBYTE(v19) = (signed int)(0.8999999761581421 * (double)(unsigned __int8)a6);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  if ( !LOBYTE(a5) )
  {
    v20 = -1.0;
    goto LABEL_7;
  }
  if ( LOBYTE(a5) != 2 )
  {
    if ( LOBYTE(a5) == 3 )
    {
      v20 = -1.0;
      goto LABEL_5;
    }
LABEL_7:
    j_gdi_pvg_begin(71);
    j_gdi_pvg_color_u32(a6);
    sub_10069EF0(a1, a2);
    j_gdi_pvg_color_u32(v19);
    v22 = a2 - v20 * a4;
    v12 = a3 * 0.5;
    *(float *)&v24 = v12 + a1;
    sub_10069EF0(*(float *)&v24, v22);
    j_gdi_pvg_color_u32(v7);
    sub_10069EF0(a1, v22);
    j_gdi_pvg_color_u32(v19);
    v13 = a1 - v12;
    sub_10069EF0(v13, v22);
    j_gdi_pvg_end(LODWORD(v14));
    j_gdi_pvg_enable(38);
    sub_10069C80(1.0);
    j_gdi_pvg_color_u32(a7);
    j_gdi_pvg_begin(66);
    sub_10069EF0(a1, a2);
    sub_10069EF0(*(float *)&v24, v22);
    v18 = v22;
    v11 = v13;
    goto LABEL_8;
  }
LABEL_5:
  j_gdi_pvg_begin(71);
  j_gdi_pvg_color_u32(a6);
  sub_10069EF0(a1, a2);
  j_gdi_pvg_color_u32(v19);
  v8 = a4 * 0.5;
  *(float *)&v23 = a2 - v8;
  v21 = v20 * a3 + a1;
  sub_10069EF0(v21, *(float *)&v23);
  j_gdi_pvg_color_u32(v7);
  sub_10069EF0(v21, a2);
  j_gdi_pvg_color_u32(v19);
  v9 = a2 + v8;
  sub_10069EF0(v21, v9);
  j_gdi_pvg_end(LODWORD(v10));
  j_gdi_pvg_enable(38);
  sub_10069C80(1.0);
  j_gdi_pvg_color_u32(a7);
  j_gdi_pvg_begin(66);
  sub_10069EF0(a1, a2);
  sub_10069EF0(v21, *(float *)&v23);
  v18 = v9;
  v11 = v21;
LABEL_8:
  v15 = v11;
  sub_10069EF0(v15, v18);
  j_gdi_pvg_end(LODWORD(v16));
  j_gdi_pvg_disable(38);
  return j_gdi_pvg_disable(35);
}
// 100699C0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10069A50: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10069B20: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10069B40: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10069BC0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10069BE0: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (100411D0) --------------------------------------------------------
__int16 __usercall sub_100411D0@<ax>(int a1@<edi>, char a2)
{
  __int16 v2; // ax@1
  __int16 result; // ax@3

  v2 = sub_1003B860(&a2, 2u, (int)&unk_100DF920, 16, 18, -1);
  if ( v2 == -1 )
  {
LABEL_11:
    result = -1;
  }
  else
  {
    switch ( a1 )
    {
      case 1:
        result = word_100DF922[8 * v2];
        break;
      case 2:
        result = word_100DF926[8 * v2];
        break;
      case 4:
        result = word_100DF924[8 * v2];
        break;
      case 64:
        result = word_100DF928[8 * v2];
        break;
      case 128:
        result = word_100DF92A[8 * v2];
        break;
      case 16:
        result = word_100DF92C[8 * v2];
        break;
      case 32:
        result = word_100DF92E[8 * v2];
        break;
      default:
        sub_10036790(byte_106AD208, 0x64u, "Unrecognized LRU (%u) passed into alert processing.", a1);
        sub_100364C0("..\\lib\\adl\\sys_updt_alrt_data.c", 1037, 0, byte_106AD208);
        goto LABEL_11;
    }
  }
  return result;
}
// 100DF922: using guessed type __int16 word_100DF922[];
// 100DF924: using guessed type __int16 word_100DF924[];
// 100DF926: using guessed type __int16 word_100DF926[];
// 100DF928: using guessed type __int16 word_100DF928[];
// 100DF92A: using guessed type __int16 word_100DF92A[];
// 100DF92C: using guessed type __int16 word_100DF92C[];
// 100DF92E: using guessed type __int16 word_100DF92E[];

//----- (10041370) --------------------------------------------------------
signed __int16 __usercall sub_10041370@<ax>(void *a1@<ecx>, signed __int16 a2@<bx>, const char *a3@<esi>)
{
  signed __int16 v3; // di@1
  void *v4; // ecx@4
  int v5; // eax@19
  char v7; // [sp+4h] [bp-38h]@2

  v3 = a2;
  if ( a3 )
    memset(&v7, 0, 0x33u);
  if ( a2 == 300 )
  {
    switch ( sub_10037130(a1) )
    {
      case 1:
        v3 = 380;
        if ( !a3 )
          return v3;
        sub_100367C0(&v7, "PFD1", 51);
        break;
      case 4:
        v3 = 381;
        if ( !a3 )
          return v3;
        sub_100367C0(&v7, "MFD1", 51);
        break;
      case 2:
        v3 = 382;
        if ( !a3 )
          return v3;
        sub_100367C0(&v7, "PFD2", 51);
        break;
      case 64:
        v3 = 383;
        if ( !a3 )
          return v3;
        sub_100367C0(&v7, "GTC1", 51);
        break;
      case 128:
        v3 = 384;
        if ( !a3 )
          return v3;
        sub_100367C0(&v7, "GTC2", 51);
        break;
      case 16:
        v3 = 385;
        if ( !a3 )
          return v3;
        sub_100367C0(&v7, "GTC3", 51);
        break;
      case 32:
        v3 = 386;
        if ( !a3 )
          return v3;
        sub_100367C0(&v7, "GTC4", 51);
        break;
      default:
        v3 = -1;
        v5 = sub_10037130(v4);
        sub_10036790(byte_106AD208, 0x64u, "Unrecognized LRU (%u) passed into DB error alert processing.", v5);
        sub_100364C0("..\\lib\\adl\\sys_updt_alrt_data.c", 1286, 0, byte_106AD208);
        break;
    }
  }
  if ( a3 )
    sub_100367C0(a3, &v7, 51);
  return v3;
}

//----- (100415C0) --------------------------------------------------------
char __cdecl sub_100415C0(signed __int16 a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  char result; // al@2
  char v4; // [sp+Ah] [bp-6h]@1
  char v5; // [sp+Bh] [bp-5h]@1
  int v6; // [sp+Ch] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = (unsigned __int16)sub_10041370(v1, a1, 0);
  v2 = sub_1003B860(&v6, 2u, (int)&unk_100DEAAA, 8, 415, -1);
  if ( v2 < 0 )
  {
    sub_100364C0("..\\lib\\adl\\sys_updt_alrt_data.c", 152, 0, 0);
    result = 0;
  }
  else
  {
    sub_1006A3A0(*(&dword_100DEAAC + 2 * v2), &v4, 1, &v5);
    result = v4;
  }
  return result;
}

//----- (10041650) --------------------------------------------------------
char __cdecl sub_10041650(char a1, int a2)
{
  __int16 v2; // ax@1

  v2 = sub_100411D0(a2, a1);
  return sub_100415C0(v2);
}

//----- (10041670) --------------------------------------------------------
int __cdecl sub_10041670(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F590(a1, 0, 0xDu, 0xDu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100416A0) --------------------------------------------------------
int __cdecl sub_100416A0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F590(a1, 0, 8u, 8u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100416D0) --------------------------------------------------------
int __cdecl sub_100416D0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F590(a1, 0, 9u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10041700) --------------------------------------------------------
int __cdecl sub_10041700(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F590(a1, 0, 5u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10041730) --------------------------------------------------------
int __cdecl sub_10041730(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F590(a1, 0, 8u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10041760) --------------------------------------------------------
int __cdecl sub_10041760(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F590(a1, 0, 0x14u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10041790) --------------------------------------------------------
int __cdecl sub_10041790(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F590(a1, 0, 6u, 6u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100417C0) --------------------------------------------------------
int __cdecl sub_100417C0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F590(a1, 0, 7u, 7u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100417F0) --------------------------------------------------------
int __cdecl sub_100417F0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F590(a1, 0, 0xFu, 0xFu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10041820) --------------------------------------------------------
int __cdecl sub_10041820(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F590(a1, 0, 0xEu, 0xEu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10041850) --------------------------------------------------------
int __cdecl sub_10041850(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F590(a1, 0, 0xBu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10041880) --------------------------------------------------------
int __cdecl sub_10041880(unsigned __int8 *a1)
{
  return sub_1003F590(a1, 0, 3u, 3u, 0);
}

//----- (100418A0) --------------------------------------------------------
signed int __cdecl sub_100418A0(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1003F590(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100418D0) --------------------------------------------------------
int __cdecl sub_100418D0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F590(a1, 0, 0x13u, 0x13u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10041900) --------------------------------------------------------
int __cdecl sub_10041900(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F590(a1, 0, 2u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10041930) --------------------------------------------------------
int __cdecl sub_10041930(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F590(a1, 0, 3u, 3u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10041960) --------------------------------------------------------
unsigned int __cdecl sub_10041960(char *a1)
{
  return sub_1003F380(a1, -100, 100, 0, 0);
}

//----- (10041980) --------------------------------------------------------
int __cdecl sub_10041980(_BYTE *a1)
{
  return sub_1003F680(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (100419A0) --------------------------------------------------------
int __cdecl sub_100419A0(unsigned __int8 *a1)
{
  return sub_1003F590(a1, 0, 1u, 1u, 0);
}

//----- (100419C0) --------------------------------------------------------
int __cdecl sub_100419C0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F590(a1, 0, 3u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100419F0) --------------------------------------------------------
unsigned int __cdecl sub_100419F0(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_1003F240((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_1003F590((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_1003F240((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F380((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F590((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F590((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F380((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10041D20) --------------------------------------------------------
unsigned int __cdecl sub_10041D20(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_1003F240((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F380((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F380((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F380((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F380((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F380((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F380((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F380((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F380((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F380((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F380((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F380((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F380((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F380((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10042160) --------------------------------------------------------
unsigned int __cdecl sub_10042160(_BYTE *a1)
{
  return sub_1003F470(a1, -1, 5, -1, 0);
}

//----- (10042180) --------------------------------------------------------
int __cdecl sub_10042180(unsigned __int8 *a1)
{
  return sub_1003F590(a1, 0, 5u, 0, 0);
}

//----- (100421A0) --------------------------------------------------------
int __cdecl sub_100421A0(unsigned __int8 *a1)
{
  return sub_1003F590(a1, 0, 4u, 2u, 0);
}

//----- (100421C0) --------------------------------------------------------
int __cdecl sub_100421C0(_BYTE *a1)
{
  return sub_1003F680(a1, 0, 2u, 0, 0);
}

//----- (100421E0) --------------------------------------------------------
int __cdecl sub_100421E0(int a1)
{
  return sub_1003F290(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (10042230) --------------------------------------------------------
int __cdecl sub_10042230(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_100421E0((int)(a1 + 4));
  if ( !result )
    result = sub_100421A0(a1);
  return result;
}

//----- (10042250) --------------------------------------------------------
int __cdecl sub_10042250(int a1)
{
  int result; // eax@1

  result = sub_10042180((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_10042180((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_10042180((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_10052590((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_1003F240((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_1003F240((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_1003F240((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_1003F240((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (100422E0) --------------------------------------------------------
unsigned int __cdecl sub_100422E0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10042160((_BYTE *)a1);
  if ( !result )
    result = sub_10042160((_BYTE *)(a1 + 4));
  return result;
}

//----- (10042300) --------------------------------------------------------
signed int __cdecl sub_10042300(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_1003F240((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_1003F240((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (10042350) --------------------------------------------------------
unsigned int __cdecl sub_10042350(int a1)
{
  unsigned int result; // eax@1

  result = sub_10042160((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10042160((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_10042160((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_10042160((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_1003F240((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (100423B0) --------------------------------------------------------
int __cdecl sub_100423B0(_BYTE *a1)
{
  return sub_1003F680(a1, 0, 0x20u, 2u, 0);
}

//----- (100423D0) --------------------------------------------------------
unsigned int __cdecl sub_100423D0(_BYTE *a1)
{
  return sub_1003F470(a1, -1, 4, -1, 0);
}

//----- (100423F0) --------------------------------------------------------
int __cdecl sub_100423F0(unsigned __int8 *a1)
{
  return sub_1003F590(a1, 0, 9u, 0, 0);
}

//----- (10042410) --------------------------------------------------------
int __cdecl sub_10042410(_BYTE *a1)
{
  return sub_1003F680(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (10042430) --------------------------------------------------------
signed int __cdecl sub_10042430(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1003F680(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10042460) --------------------------------------------------------
int __cdecl sub_10042460(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F5E0(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100424A0) --------------------------------------------------------
signed int __cdecl sub_100424A0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1003F5E0(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100424D0) --------------------------------------------------------
int __cdecl sub_100424D0(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_10042430((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_10042460((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10042460((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100560B0((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10042460((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10042560) --------------------------------------------------------
int __cdecl sub_10042560(unsigned __int8 *a1)
{
  return sub_1003F590(a1, 0, 2u, 0, 0);
}

//----- (10042580) --------------------------------------------------------
int __cdecl sub_10042580(int a1)
{
  int result; // eax@1

  result = sub_1003F590((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_1003F590((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (100425B0) --------------------------------------------------------
int __cdecl sub_100425B0(unsigned __int8 *a1)
{
  return sub_1003F590(a1, 0, 3u, 1u, 0);
}

//----- (100425D0) --------------------------------------------------------
unsigned int __cdecl sub_100425D0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1003F470((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_1003F470((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (10042600) --------------------------------------------------------
int __cdecl sub_10042600(int a1)
{
  int result; // eax@1

  result = sub_1003F290(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_1003F290(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_1003F290(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_1003F290(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_1003F290(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (100426F0) --------------------------------------------------------
int __cdecl sub_100426F0(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_1003F240((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_1003F590((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_100425D0(a1 + 36);
        if ( !result )
        {
          result = sub_1003F290(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_10042600(a1 + 8);
            if ( !result )
            {
              result = sub_100425D0(a1 + 28);
              if ( !result )
              {
                result = sub_1003F5E0((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_10042560((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_10042580(a1 + 57);
                    if ( !result )
                    {
                      result = sub_1003F240((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_100425B0((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (10042800) --------------------------------------------------------
int __cdecl sub_10042800(int a1)
{
  int v1; // edi@1
  signed int v2; // esi@1
  int result; // eax@2

  v1 = a1;
  v2 = 0;
  do
  {
    result = sub_10047650(v1);
    if ( result )
      break;
    ++v2;
    v1 += 232;
  }
  while ( v2 < 14 );
  return result;
}

//----- (10042830) --------------------------------------------------------
int __cdecl sub_10042830(unsigned __int8 *a1)
{
  return sub_1003F590(a1, 0, 3u, 0, 0);
}

//----- (10042850) --------------------------------------------------------
signed int __cdecl sub_10042850(int a1, int a2)
{
  signed int v2; // ebx@1
  signed int result; // eax@9

  v2 = 0;
  if ( sub_100418A0((unsigned __int8 *)(a1 + 15), a2) == 1 )
    v2 = 1;
  if ( sub_100418A0((unsigned __int8 *)(a1 + 34), a2) == 1 )
    v2 = 1;
  if ( sub_100418A0((unsigned __int8 *)(a1 + 38), a2) == 1 )
    v2 = 1;
  if ( sub_100418A0((unsigned __int8 *)(a1 + 36), a2) == 1 )
    v2 = 1;
  result = sub_1003F240((_BYTE *)(a1 + 33), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100416A0((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041670((unsigned __int8 *)(a1 + 48), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041730((unsigned __int8 *)(a1 + 46), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041670((unsigned __int8 *)(a1 + 47), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041760((unsigned __int8 *)(a1 + 45), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100416D0((unsigned __int8 *)(a1 + 44), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041670((unsigned __int8 *)(a1 + 28), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100419C0((unsigned __int8 *)(a1 + 51), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041850((unsigned __int8 *)(a1 + 31), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_100526A0((_BYTE *)(a1 + 20), a2) == 1 )
    v2 = 1;
  result = sub_10041700((unsigned __int8 *)(a1 + 50), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041670((unsigned __int8 *)(a1 + 24), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041790((unsigned __int8 *)(a1 + 5), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041670((unsigned __int8 *)(a1 + 25), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100417C0((unsigned __int8 *)(a1 + 6), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041670((unsigned __int8 *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100417F0((unsigned __int8 *)(a1 + 3), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F290(a1 + 40, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041670((unsigned __int8 *)(a1 + 26), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100416A0((unsigned __int8 *)(a1 + 9), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041670((unsigned __int8 *)(a1 + 8), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041820((unsigned __int8 *)(a1 + 7), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041850((unsigned __int8 *)(a1 + 1), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041930((unsigned __int8 *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041930((unsigned __int8 *)(a1 + 10), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 37), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100418D0((unsigned __int8 *)(a1 + 11), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041670((unsigned __int8 *)(a1 + 12), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F240((_BYTE *)(a1 + 32), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041700((unsigned __int8 *)(a1 + 49), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F290(a1 + 16, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10041930((unsigned __int8 *)(a1 + 35), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10042D60) --------------------------------------------------------
int __cdecl sub_10042D60(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F680(a1, 0, 0x3FFFFu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10042D90) --------------------------------------------------------
signed int __cdecl sub_10042D90(_BYTE *a1, int a2)
{
  signed int v2; // ebx@1
  signed int result; // eax@1

  v2 = 0;
  result = sub_1003F240(a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003F290((int)(a1 + 4), -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10042E00) --------------------------------------------------------
int __cdecl sub_10042E00(unsigned __int8 *a1)
{
  return sub_1003F590(a1, 0, 0x64u, 0x64u, 0);
}

//----- (10042E60) --------------------------------------------------------
int __cdecl sub_10042E60(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_1003F240((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_10042E00((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (10042E70) --------------------------------------------------------
signed int __cdecl sub_10042E70(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1003F680(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10042EA0) --------------------------------------------------------
unsigned int __cdecl sub_10042EA0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1003F3D0((_BYTE *)a1, 0, 10000, 0, 0);
  if ( !result )
  {
    result = sub_1003F3D0((_BYTE *)(a1 + 2), 0, 10000, 0, 0);
    if ( !result )
      result = sub_1003F3D0((_BYTE *)(a1 + 4), 0, 0x7FFF, 0, 0);
  }
  return result;
}

//----- (10042EF0) --------------------------------------------------------
int __cdecl sub_10042EF0(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_1003F590((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_1003F590((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (10042F80) --------------------------------------------------------
int __cdecl sub_10042F80(int a1)
{
  int result; // eax@1

  result = sub_100474F0((_BYTE *)(a1 + 3272));
  if ( !result )
  {
    result = sub_100474F0((_BYTE *)(a1 + 3274));
    if ( !result )
    {
      result = sub_10042830((unsigned __int8 *)(a1 + 14));
      if ( !result )
      {
        result = sub_10042F70(a1 + 24);
        if ( !result )
        {
          result = sub_10042830((unsigned __int8 *)(a1 + 15));
          if ( !result )
          {
            result = sub_10056090((unsigned __int8 *)(a1 + 12));
            if ( !result )
              result = sub_10042830((unsigned __int8 *)(a1 + 13));
          }
        }
      }
    }
  }
  return result;
}
// 10042F70: using guessed type _DWORD __cdecl sub_10042F70(_DWORD);

//----- (10043000) --------------------------------------------------------
unsigned int __cdecl sub_10043000(int a1)
{
  unsigned int result; // eax@1

  result = sub_10041960((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_10041960((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_10041960((char *)a1);
      if ( !result )
        result = sub_10041960((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (10043040) --------------------------------------------------------
unsigned int __cdecl sub_10043040(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_10043000(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_10042560((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_100419A0((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (10043090) --------------------------------------------------------
int __cdecl sub_10043090(int a1)
{
  int result; // eax@1

  result = sub_10041980((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_1003F5E0((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (100430C0) --------------------------------------------------------
int __cdecl sub_100430C0(int a1)
{
  int result; // eax@1

  result = sub_100421C0((_BYTE *)a1);
  if ( !result )
    result = sub_10042410((_BYTE *)(a1 + 4));
  return result;
}

//----- (100430F0) --------------------------------------------------------
unsigned int __cdecl sub_100430F0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10042160((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10042160((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_100423D0((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (10043120) --------------------------------------------------------
unsigned int __cdecl sub_10043120(int a1)
{
  unsigned int result; // eax@1

  result = sub_10042160((_BYTE *)a1);
  if ( !result )
    result = sub_100423F0((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (10043140) --------------------------------------------------------
unsigned int __cdecl sub_10043140(int a1)
{
  unsigned int result; // eax@1

  result = sub_10042160((_BYTE *)a1);
  if ( !result )
  {
    result = sub_1003F590((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_100423D0((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (10043180) --------------------------------------------------------
void __cdecl __noreturn sub_10043180(int a1)
{
  exit(a1 + 4);
}

//----- (100432F0) --------------------------------------------------------
signed int __cdecl sub_100432F0(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_100418A0((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_100424A0((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_100418A0((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (10043340) --------------------------------------------------------
int __cdecl sub_10043340(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_10042D60((_BYTE *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10042D90((_BYTE *)(a1 + 4), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (100433A0) --------------------------------------------------------
int __usercall sub_100433A0@<eax>(unsigned __int8 *a1@<eax>, int a2@<edi>)
{
  unsigned __int8 *v2; // esi@1
  signed int v3; // ebx@1
  int result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  result = sub_10041900(a1, v5);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( *v2 == 1 )
    result = sub_10043340((int)(v2 + 4), a2);
  else
    result = sub_10042850((int)(v2 + 4), a2);
  if ( result != 1 && !result )
    result = v3;
  return result;
}

//----- (100433F0) --------------------------------------------------------
signed int __usercall sub_100433F0@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_100432F0(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_1003F590((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_1003F240((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_10041D20(v2 + 5, a2);
    else
      result = sub_100419F0(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_10042E70((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (100434C0) --------------------------------------------------------
int __cdecl sub_100434C0(unsigned __int8 *a1)
{
  return sub_100433A0(a1, 0);
}

//----- (100434D0) --------------------------------------------------------
signed int __cdecl sub_100434D0(int a1)
{
  return sub_100433F0(a1, 0);
}

//----- (100434E0) --------------------------------------------------------
char __cdecl sub_100434E0(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_100364C0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_1003E2F0(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_1003E2F0(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_100434D0((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_106AD278, (char *)&v6 + 1, 0x20u);
      byte_106AD270 = 1;
      byte_106AD271 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_106AD298, (char *)&v6 + 1, 0x20u);
    byte_106AD271 = 1;
    byte_106AD272 = 1;
    return result;
  }
  return 0;
}
// 106AD270: using guessed type char byte_106AD270;
// 106AD271: using guessed type char byte_106AD271;
// 106AD272: using guessed type char byte_106AD272;

//----- (10043610) --------------------------------------------------------
char __cdecl sub_10043610(char a1, int a2)
{
  char v2; // bl@1
  int v4; // eax@5

  v2 = 0;
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      sub_100364C0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 497, 0, 0);
      return v2;
    }
    v4 = 6110;
  }
  else
  {
    v4 = 6099;
  }
  v2 = 1;
  if ( !sub_1006A0A0(v4, a2, 12) )
    return v2;
  return 0;
}

//----- (10043670) --------------------------------------------------------
char __cdecl sub_10043670(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_100524D0(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_100364C0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (100436F0) --------------------------------------------------------
bool __cdecl sub_100436F0(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_106AD270 == 0;
    qmemcpy(a1, &unk_106AD278, 0x40u);
    result = !v1 && byte_106AD272;
  }
  else
  {
    sub_100364C0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 106AD270: using guessed type char byte_106AD270;
// 106AD272: using guessed type char byte_106AD272;

//----- (10043740) --------------------------------------------------------
char __cdecl sub_10043740(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_100364C0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_1003C1D0(15);
    v3 = 555;
  }
  else
  {
    result = sub_1003C1D0(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_106AD271 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_1003DDF0(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 1006BBD0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 106AD271: using guessed type char byte_106AD271;

//----- (10043820) --------------------------------------------------------
bool __cdecl sub_10043820(char a1, int a2)
{
  bool result; // al@1
  int v3; // eax@3

  result = 0;
  if ( a1 )
  {
    if ( a1 != 1 )
      return result;
    v3 = 6110;
  }
  else
  {
    v3 = 6099;
  }
  return sub_1006A1B0(v3, a2, 12) == 0;
}

//----- (10043860) --------------------------------------------------------
__int16 __usercall sub_10043860@<ax>(unsigned __int8 a1@<al>)
{
  return word_100C9AD0[a1];
}
// 100C9AD0: using guessed type __int16 word_100C9AD0[];

//----- (10043870) --------------------------------------------------------
char __cdecl sub_10043870(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_10043860(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_1003DDF0(1, v3, &v5, 1, HIWORD(v5) + 4, 1);
  return sub_1003DF30(1, v3, 0xFFFFFFF);
}

//----- (10043900) --------------------------------------------------------
char __cdecl sub_10043900(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_100364C0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_106AD271 != 0 ? 25 : 11;
      sub_10043870(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_10043870(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 106AD271: using guessed type char byte_106AD271;

//----- (100439C0) --------------------------------------------------------
bool __cdecl sub_100439C0(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_10043670(a1, (int)a5);
    return 1;
  }
  if ( byte_106AD271 )
  {
    if ( sub_100434E0(a1, &v6, 1) )
    {
LABEL_14:
      byte_106AD273 = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_106AD273 >= 5u )
    {
      byte_106AD270 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_100434E0(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_106AD273 >= 5u )
    {
      byte_106AD272 = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_10043670(a1, (int)&v6);
    sub_10043740(a1, (int)&v6);
  }
  sub_10043900(a1, 11);
  return sub_100436F0(a5);
}
// 1006BBD0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 106AD270: using guessed type char byte_106AD270;
// 106AD271: using guessed type char byte_106AD271;
// 106AD272: using guessed type char byte_106AD272;
// 106AD273: using guessed type char byte_106AD273;

//----- (10043AC0) --------------------------------------------------------
int __usercall sub_10043AC0@<eax>(const char *a1@<eax>, int a2@<ecx>)
{
  int v2; // ebp@1
  int v3; // esi@1
  const char *v4; // edi@2
  int result; // eax@5
  const char *v6; // [sp+8h] [bp-4h]@2

  v2 = *(_WORD *)(a2 + 4);
  v3 = 0;
  if ( v2 <= 0 )
  {
    result = 0;
  }
  else
  {
    v6 = *(const char **)a2;
    v4 = *(const char **)a2;
    while ( strcmp(v4, a1) )
    {
      ++v3;
      v4 += 56;
      if ( v3 >= v2 )
        return 0;
    }
    result = (int)&v6[56 * v3];
  }
  return result;
}

//----- (10043B40) --------------------------------------------------------
int __usercall sub_10043B40@<eax>(int a1@<ebx>, float a2, float a3, int a4, int a5, int a6, float a7, char a8)
{
  int result; // eax@1
  int v9; // edi@1
  float v10; // ST20_4@2
  float v11; // ST24_4@2
  float v12; // ST10_4@2
  float v13; // ST24_4@2
  float v14; // ST24_4@2
  float v15; // ST10_4@2
  float v16; // ST24_4@2
  float v17; // ST20_4@2
  float v18; // ST24_4@2
  float v19; // ST10_4@2
  float v20; // ST24_4@2
  float v21; // ST24_4@2
  float v22; // ST10_4@2
  float v23; // ST24_4@2

  result = sub_10043AC0((const char *)a6, a4);
  v9 = result;
  if ( result )
  {
    j_gdi_pvg_push_attrib(0x2000);
    j_gdi_pvg_enable(34);
    j_gdi_pvg_bind_texture(34, *(_DWORD *)(a4 + 8));
    sub_10069AB0(1.0, 1.0, 1.0, a7);
    j_gdi_pvg_begin(72);
    v10 = (double)(a8 != 0);
    sub_10069DB0(v10, *(float *)(v9 + 52));
    v11 = *(float *)(a5 + 4) + a3;
    v12 = v11;
    v13 = *(float *)a5 + a2;
    sub_10069EF0(v13, v12);
    sub_10069DB0(v10, *(float *)(v9 + 52));
    v14 = *(float *)(a5 + 28) + a3;
    v15 = v14;
    v16 = *(float *)(a5 + 24) + a2;
    sub_10069EF0(v16, v15);
    v17 = (double)(a8 == 0);
    sub_10069DB0(v17, *(float *)(v9 + 52));
    v18 = *(float *)(a5 + 20) + a3;
    v19 = v18;
    v20 = *(float *)(a5 + 16) + a2;
    sub_10069EF0(v20, v19);
    sub_10069DB0(v17, *(float *)(v9 + 52));
    v21 = *(float *)(a5 + 12) + a3;
    v22 = v21;
    v23 = *(float *)(a5 + 8) + a2;
    sub_10069EF0(v23, v22);
    j_gdi_pvg_end(a1);
    result = j_gdi_pvg_pop_attrib();
  }
  return result;
}
// 10043B40: could not find valid save-restore pair for ebx
// 100699C0: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100699E0: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 10069BC0: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10069BE0: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 10069D10: using guessed type int j_gdi_pvg_pop_attrib(void);
// 10069D30: using guessed type int __cdecl j_gdi_pvg_push_attrib(_DWORD);

//----- (10043CE0) --------------------------------------------------------
bool __cdecl sub_10043CE0(unsigned int a1, unsigned __int16 a2)
{
  unsigned int v2; // eax@2
  bool result; // al@5

  result = 0;
  if ( a2 < 0x96u )
  {
    v2 = 12 * a2;
    if ( a1 < dword_10789748[v2 / 4] && word_10789744[v2 / 2] && dword_10789740[v2 / 4] )
      result = 1;
  }
  return result;
}
// 10789740: using guessed type int dword_10789740[];
// 10789744: using guessed type __int16 word_10789744[];
// 10789748: using guessed type int dword_10789748[];

//----- (10043D20) --------------------------------------------------------
int __cdecl sub_10043D20(unsigned __int16 a1)
{
  unsigned __int16 v1; // dx@1
  int result; // eax@2

  if ( sub_10043CE0(0, a1) )
    result = dword_10789748[3 * v1];
  else
    result = 0;
  return result;
}
// 10789748: using guessed type int dword_10789748[];

//----- (10043D50) --------------------------------------------------------
char __cdecl sub_10043D50(void *a1)
{
  return sub_100562B0(31, a1);
}

//----- (10043D60) --------------------------------------------------------
BOOL sub_10043D60()
{
  return sub_1003BF90(9) || sub_1003BF90(10);
}

//----- (10043D90) --------------------------------------------------------
int __usercall sub_10043D90@<eax>(char a1@<al>, int a2@<ecx>)
{
  int v2; // esi@3
  int result; // eax@3

  if ( a1 && a1 != 2 )
  {
    v2 = a2 - sub_100812B0(a1);
    result = v2 + sub_100812B0(0);
  }
  else
  {
    result = a2;
  }
  return result;
}

//----- (10043DC0) --------------------------------------------------------
char __thiscall sub_10043DC0(void *this)
{
  char v1; // al@1
  char result; // al@2
  char v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@2

  v1 = sub_10045170(this);
  v3 = sub_10056420(v1, 1);
  if ( (unsigned __int8)sub_10043D60() )
  {
    result = sub_10056230(28, v3, &v4);
    if ( result != 1 || !(v4 & 0x800) )
      result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10043E20) --------------------------------------------------------
char __thiscall sub_10043E20(void *this)
{
  char v1; // al@1
  char v3; // [sp+0h] [bp-Ch]@1
  int v4; // [sp+4h] [bp-8h]@2
  int v5; // [sp+8h] [bp-4h]@5

  v1 = sub_10045170(this);
  v3 = sub_10056420(v1, 1);
  if ( (unsigned __int8)sub_10043D60() )
  {
    if ( sub_10056230(28, v3, &v4) != 1 || v4 & 0x2000 )
      return 0;
  }
  else if ( sub_100562D0(&v5) != 1 || !(v5 & 0x10000) )
  {
    return 0;
  }
  return 1;
}

//----- (10043E90) --------------------------------------------------------
char __cdecl sub_10043E90(char a1, char a2, int *a3)
{
  char v3; // bl@1
  void *v4; // ecx@1
  void *v5; // ecx@2
  char result; // al@4
  int v7; // esi@9
  void *v8; // ecx@12
  int v9; // esi@14
  char v10; // [sp+8h] [bp-14h]@1
  char v11; // [sp+9h] [bp-13h]@1
  char v12; // [sp+Ah] [bp-12h]@1
  char v13; // [sp+Bh] [bp-11h]@1
  int v14; // [sp+Ch] [bp-10h]@1
  int v15; // [sp+10h] [bp-Ch]@1
  int v16; // [sp+14h] [bp-8h]@1
  int v17; // [sp+18h] [bp-4h]@1

  v3 = sub_10056230(16, a2, &v14);
  v12 = sub_10056230(17, a2, &v16);
  v10 = sub_100813E0();
  v11 = sub_10056230(51, a2, &v15);
  v13 = sub_10056230(52, a2, &v17);
  switch ( a1 )
  {
    case 0:
    case 2:
    case 3:
      if ( sub_10043E20(v4) )
      {
        if ( !v3 )
          return 0;
        v7 = v14;
        if ( v10 == 1 )
          v7 -= sub_100812B0(0);
        *a3 = sub_10043D90(a1, v7);
        result = 1;
      }
      else if ( v3 )
      {
        *a3 = sub_10043D90(a1, v14);
        result = 1;
      }
      else
      {
        if ( !v11 || !sub_10043DC0(v5) )
          return 0;
        *a3 = sub_10043D90(a1, v15);
        result = 1;
      }
      return result;
    case 1:
      if ( sub_10043E20(v4) )
      {
        if ( !v3 )
          return 0;
        v9 = v14;
        if ( v10 == 1 )
          goto LABEL_15;
        *a3 = sub_100812B0(0) + v9;
        result = 1;
      }
      else
      {
        if ( v12 )
        {
          v9 = v16;
LABEL_15:
          *a3 = v9;
          return 1;
        }
        if ( !v13 || !sub_10043DC0(v8) )
          return 0;
        *a3 = v17;
        result = 1;
      }
      return result;
    default:
      sub_100364C0("..\\lib\\acl\\iop\\iop_ahrs_data_intf.c", 1859, 1, 0);
      return 0;
  }
}

//----- (10044040) --------------------------------------------------------
char __cdecl sub_10044040(char a1, int *a2, char a3)
{
  char result; // al@3
  char v4; // bl@4
  int v5; // [sp+4h] [bp-4h]@1

  v5 = 0;
  if ( a3 != 2 && sub_1003BF90(a3 + 9) )
  {
    result = sub_10043E90(a1, a3, a2);
  }
  else
  {
    v4 = sub_10056230(16, a3, &v5);
    if ( v4 )
      *a2 = sub_10043D90(a1, v5);
    result = v4;
  }
  return result;
}

//----- (100440B0) --------------------------------------------------------
char __cdecl sub_100440B0(char a1, int *a2)
{
  void *v2; // ecx@0
  char v3; // al@1
  char v4; // al@1

  v3 = sub_10045170(v2);
  v4 = sub_10056420(v3, 1);
  return sub_10044040(a1, a2, v4);
}

//----- (100440E0) --------------------------------------------------------
char __cdecl sub_100440E0(_DWORD *a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  char result; // al@2
  int v4; // [sp+0h] [bp-8h]@1
  char v5[4]; // [sp+4h] [bp-4h]@2

  v4 = 0;
  v2 = sub_10044670(v1);
  if ( v2 == 1 )
  {
    v5[0] = sub_10056420(0, 1);
    result = sub_10056230(16, v5[0], &v4);
  }
  else if ( v2 == 2 )
  {
    v5[0] = sub_10056420(1, 1);
    result = sub_10056230(16, v5[0], &v4);
  }
  else
  {
    result = sub_100440B0(0, &v4);
  }
  if ( result == 1 )
    *a1 = v4;
  return result;
}

//----- (10044160) --------------------------------------------------------
bool __cdecl sub_10044160(float *a1)
{
  void *v1; // ecx@0
  float *v2; // edi@1
  unsigned int v3; // ebp@1
  char v4; // bl@1
  _DWORD *v5; // esi@1
  char v6; // al@3
  bool result; // al@6
  int v8; // [sp+10h] [bp-8h]@1
  float v9; // [sp+14h] [bp-4h]@3
  char v10; // [sp+1Ch] [bp+4h]@1

  v2 = a1;
  *a1 = 0.0;
  v3 = 0;
  v4 = 0;
  v8 = sub_10036FC0(v1);
  v10 = 0;
  v5 = &unk_100CA110;
  do
  {
    if ( v8 & *v5 )
    {
      v6 = sub_10056420(v10, 0);
      if ( sub_10056230(3, v6, &v9) )
      {
        ++v3;
        *v2 = *v2 + v9;
      }
    }
    ++v4;
    ++v5;
    v10 = v4;
  }
  while ( (unsigned __int8)v4 < 2u );
  result = v3 != 0;
  if ( v3 )
    *v2 = *v2 / (double)v3;
  return result;
}

//----- (10044200) --------------------------------------------------------
int sub_10044200()
{
  int result; // eax@1

  sub_1006A140(6361, (int)&flt_106AD2BC, 4);
  result = sub_1006A140(6362, (int)&flt_106AD2C0, 4);
  dword_106AD2C4 = 1379255385;
  return result;
}
// 106AD2BC: using guessed type float flt_106AD2BC;
// 106AD2C0: using guessed type float flt_106AD2C0;
// 106AD2C4: using guessed type int dword_106AD2C4;

//----- (10044230) --------------------------------------------------------
char __usercall sub_10044230@<al>(int a1@<eax>, float *a2@<esi>, float a3, float a4)
{
  char v4; // cl@1
  char result; // al@5
  void *v6; // [sp+0h] [bp-8h]@0

  v4 = sub_100562B0(a1, v6);
  if ( v4 && ((COERCE_UNSIGNED_INT(*a2) & 0x7F800000) == 2139095040 || a3 < (double)*a2 || a4 > (double)*a2) )
  {
    result = 0;
    *a2 = 0.0;
  }
  else
  {
    result = v4;
  }
  return result;
}

//----- (10044290) --------------------------------------------------------
char __cdecl sub_10044290(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_100562B0(7, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 39950.746
     || *(float *)a1 < -39950.746) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (100442F0) --------------------------------------------------------
char __cdecl sub_100442F0(float *a1)
{
  char v1; // bl@1
  double v2; // st7@2
  double v3; // st7@6
  char result; // al@9
  float v5; // [sp+Ch] [bp-Ch]@1
  float v6; // [sp+10h] [bp-8h]@5
  float v7; // [sp+14h] [bp-4h]@2

  v1 = sub_100562B0(53, &v5);
  if ( v1 )
  {
    v2 = v5;
    v7 = v5;
    if ( (LODWORD(v5) & 0x7F800000) == 2139095040 || v2 > 526.79114 || v2 < -526.79114 )
      return 0;
    if ( sub_100562B0(59, &v6) )
    {
      v3 = v6;
      v7 = v6;
      if ( (LODWORD(v6) & 0x7F800000) != 2139095040 && v3 <= 526.79114 && v3 >= -526.79114 )
      {
        sub_1002B700(flt_106AD2BC, 0.0);
        result = v1;
        v5 = flt_106AD2C0 * v6 + v5;
        *a1 = v5;
        return result;
      }
    }
    *a1 = v5;
  }
  return v1;
}
// 106AD2BC: using guessed type float flt_106AD2BC;
// 106AD2C0: using guessed type float flt_106AD2C0;

//----- (100443F0) --------------------------------------------------------
char __cdecl sub_100443F0(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_100562B0(55, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040 || *(float *)a1 > 4.0960002 || *(float *)a1 < 0.0) )
  {
    *(float *)a1 = 0.0;
    result = 0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10044450) --------------------------------------------------------
char __cdecl sub_10044450(void *a1)
{
  char v1; // bl@1
  int v2; // eax@7
  char result; // al@9
  float v4; // [sp+14h] [bp-10h]@1
  float v5; // [sp+18h] [bp-Ch]@1
  float v6; // [sp+1Ch] [bp-8h]@1
  float v7; // [sp+20h] [bp-4h]@2

  v5 = 0.0;
  v4 = 0.0;
  v6 = 0.0;
  v1 = sub_100562B0(57, a1);
  if ( v1 )
  {
    v7 = *(float *)a1;
    if ( (LODWORD(v7) & 0x7F800000) == 2139095040 || *(float *)a1 > 166.46144 || *(float *)a1 < -166.46144 )
    {
      v1 = 0;
      *(float *)a1 = 0.0;
    }
  }
  sub_1006A140(6950, (int)&v4, 4);
  if ( 0.0 != v4 && sub_100562B0(66, &v5) && (LOBYTE(v2) = 58, sub_10044230(v2, &v6, 166.46144, -166.46144)) )
  {
    result = 1;
    *(float *)a1 = v4 * v5 + v6;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10044530) --------------------------------------------------------
char __cdecl sub_10044530(float *a1)
{
  float *v1; // esi@1
  char v2; // bl@1

  v1 = a1;
  *a1 = 0.0;
  v2 = sub_10044290(&a1);
  if ( v2 )
    *v1 = sub_10036890() + *(float *)&a1;
  return v2;
}
// 10036890: using guessed type double sub_10036890(void);

//----- (10044570) --------------------------------------------------------
bool sub_10044570()
{
  return sub_100697D0(99, 10000) == 0;
}

//----- (10044590) --------------------------------------------------------
signed int sub_10044590()
{
  signed int result; // eax@3

  if ( (unsigned __int8)byte_106AD2C8 > 2u )
    sub_100364C0("..\\lib\\adl\\iop_ap_intf.c", 958, 0, 0);
  result = (unsigned __int8)byte_106AD2C8;
  if ( (unsigned __int8)byte_106AD2C8 >= 2u )
    result = 2;
  byte_106AD2C8 = result;
  return result;
}
// 106AD2C8: using guessed type char byte_106AD2C8;

//----- (100445D0) --------------------------------------------------------
char __thiscall sub_100445D0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1006A140(3190, (int)&v2 + 3, 1);
  return BYTE3(v2);
}

//----- (100445F0) --------------------------------------------------------
char __cdecl sub_100445F0(char a1)
{
  char result; // al@2
  char v2; // [sp+2h] [bp-2h]@1
  char v3; // [sp+3h] [bp-1h]@1

  v3 = 1;
  v2 = 1;
  if ( a1 )
  {
    sub_1006A100(9420, &v2, 1, &v3);
    result = v2;
  }
  else
  {
    sub_1006A100(9419, &v2, 1, &v3);
    result = v2;
  }
  return result;
}

//----- (10044640) --------------------------------------------------------
int sub_10044640()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  v1 = 0;
  sub_1006A3A0(2017, &v1, 4, &v2);
  return v1;
}

//----- (10044670) --------------------------------------------------------
char __thiscall sub_10044670(void *this)
{
  char result; // al@3
  unsigned int v2; // [sp-2h] [bp-4h]@1

  v2 = (unsigned int)this;
  if ( sub_1003E2C0(1, 43, (char *)&v2 + 3) && !sub_10041880((unsigned __int8 *)&v2 + 3) )
    result = BYTE3(v2);
  else
    result = 0;
  return result;
}

//----- (100446B0) --------------------------------------------------------
BOOL __cdecl sub_100446B0(void *a1)
{
  float v2; // [sp+0h] [bp-10h]@1
  float v3; // [sp+4h] [bp-Ch]@1
  float v4; // [sp+8h] [bp-8h]@1
  float v5; // [sp+Ch] [bp-4h]@1

  v4 = *(float *)(dword_10789FA0 + 30396);
  v5 = *(float *)(dword_10789FA0 + 30400);
  v2 = *(float *)(dword_10789FA0 + 30404);
  v3 = *(float *)(dword_10789FA0 + 30408);
  return sub_1006A3A0(9864, a1, 16, &v2) == 0;
}
// 10789FA0: using guessed type int dword_10789FA0;

//----- (10044700) --------------------------------------------------------
char __thiscall sub_10044700(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 2;
  sub_1006A3A0(9860, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10044730) --------------------------------------------------------
BOOL __cdecl sub_10044730(void *a1)
{
  float v2; // [sp+0h] [bp-Ch]@1
  int v3; // [sp+4h] [bp-8h]@1

  v2 = 0.0;
  v3 = 0;
  v2 = *(float *)(dword_10789FA0 + 30400);
  return sub_1006A3A0(2157, a1, 8, &v2) == 0;
}
// 10789FA0: using guessed type int dword_10789FA0;

//----- (10044790) --------------------------------------------------------
char sub_10044790()
{
  char v1; // [sp+2h] [bp-2h]@1
  char v2; // [sp+3h] [bp-1h]@1

  v1 = 0;
  v2 = 0;
  sub_1006A100(6888, &v1, 1, &v2);
  return v1;
}

//----- (100447C0) --------------------------------------------------------
int __cdecl sub_100447C0(int a1)
{
  char v1; // cl@3
  char v2; // al@6
  int result; // eax@12

  result = 0;
  if ( !*(_BYTE *)a1 )
  {
    if ( *(_BYTE *)(a1 + 34) )
    {
      v1 = *(_BYTE *)(a1 + 7);
      if ( v1 == 3 || v1 == 4 || v1 == 13 )
      {
        v2 = *(_BYTE *)(a1 + 8);
        if ( !v2 || v2 == 1 || v2 == 7 || v2 == 8 || v2 == 9 || v2 == 10 )
          result = 1;
      }
    }
  }
  return result;
}

//----- (10044810) --------------------------------------------------------
int __cdecl sub_10044810(int a1)
{
  return sub_1006A190(2017, (int)&a1, 4);
}

//----- (10044830) --------------------------------------------------------
int __cdecl sub_10044830(float a1, int a2, char a3)
{
  double v3; // st7@2
  double v4; // st7@4
  float v5; // ST28_4@6
  double v6; // st7@6
  float v7; // ST24_4@8
  unsigned int v8; // eax@10
  int *v9; // ecx@10
  char *v10; // edx@10
  int v11; // esi@14
  int v12; // eax@15
  _BYTE *v13; // ecx@15
  _BYTE *v14; // edx@15
  int v15; // eax@17
  _BYTE *v16; // ecx@17
  _BYTE *v17; // edx@17
  _BYTE *v18; // ecx@19
  _BYTE *v19; // edx@19
  int result; // eax@21
  float v21; // [sp+0h] [bp-2Ch]@2
  float v22; // [sp+4h] [bp-28h]@4
  float v23; // [sp+8h] [bp-24h]@1
  float v24; // [sp+Ch] [bp-20h]@1
  float v25; // [sp+10h] [bp-1Ch]@1
  float v26; // [sp+14h] [bp-18h]@1
  float v27; // [sp+18h] [bp-14h]@1
  int v28; // [sp+1Ch] [bp-10h]@1
  char v29; // [sp+20h] [bp-Ch]@1

  v27 = a1;
  v28 = a2;
  sub_10044730(&v29);
  v23 = 0.0;
  v24 = 0.0;
  v25 = 0.0;
  v26 = 0.0;
  sub_100446B0(&v23);
  if ( (_BYTE)v28 )
  {
    v21 = v23;
    v3 = v24;
  }
  else
  {
    v21 = v25;
    v3 = v26;
  }
  v22 = v3;
  v4 = v27;
  if ( v22 >= (double)v27 )
    v4 = v22;
  v5 = v4;
  v6 = v5;
  if ( v21 <= (double)v5 )
    v6 = v21;
  v7 = v6;
  v27 = v7;
  if ( a3 )
  {
    sub_1003DDF0(1, 1414, &v27, 0, 8, 1);
    sub_1003DF30(1, 0x586u, 0xFFFFFFF);
  }
  v8 = 8;
  v9 = (int *)&v27;
  v10 = &v29;
  do
  {
    if ( *(_DWORD *)v10 != *v9 )
      goto LABEL_14;
    v8 -= 4;
    ++v9;
    v10 += 4;
  }
  while ( v8 >= 4 );
  if ( !v8 )
  {
LABEL_23:
    result = 0;
    goto LABEL_24;
  }
LABEL_14:
  v11 = (unsigned __int8)*v10 - *(_BYTE *)v9;
  if ( (unsigned __int8)*v10 == *(_BYTE *)v9 )
  {
    v12 = v8 - 1;
    v13 = (char *)v9 + 1;
    v14 = v10 + 1;
    if ( !v12 )
      goto LABEL_23;
    v11 = *v14 - *v13;
    if ( *v14 == *v13 )
    {
      v15 = v12 - 1;
      v16 = v13 + 1;
      v17 = v14 + 1;
      if ( !v15 )
        goto LABEL_23;
      v11 = *v17 - *v16;
      if ( *v17 == *v16 )
      {
        v18 = v16 + 1;
        v19 = v17 + 1;
        if ( v15 == 1 )
          goto LABEL_23;
        v11 = *v19 - *v18;
        if ( *v19 == *v18 )
          goto LABEL_23;
      }
    }
  }
  result = 1;
  if ( v11 <= 0 )
    result = -1;
LABEL_24:
  if ( result )
    result = sub_1006A190(2157, (int)&v27, 8);
  return result;
}

//----- (100449C0) --------------------------------------------------------
char __cdecl sub_100449C0(char a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  void *v3; // ecx@1
  char v5; // [sp+4h] [bp-Ch]@2

  v2 = sub_10045170(v1);
  if ( sub_100445D0(v3) )
    goto LABEL_2;
  if ( a1 )
  {
    if ( v2 )
    {
      sub_1006A140(2015, (int)&v5, 12);
      return v5;
    }
    sub_1006A140(2101, (int)&v5, 12);
  }
  else
  {
    if ( !v2 )
    {
LABEL_2:
      sub_1006A140(2015, (int)&v5, 12);
      return v5;
    }
    sub_1006A140(2101, (int)&v5, 12);
  }
  return v5;
}

//----- (10044A40) --------------------------------------------------------
double __cdecl sub_10044A40(char a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  void *v3; // ecx@1
  char v5; // [sp+4h] [bp-Ch]@2
  float v6; // [sp+8h] [bp-8h]@2

  v2 = sub_10045170(v1);
  if ( sub_100445D0(v3) )
    goto LABEL_2;
  if ( a1 )
  {
    if ( v2 )
    {
      sub_1006A140(2015, (int)&v5, 12);
      return v6;
    }
    sub_1006A140(2101, (int)&v5, 12);
  }
  else
  {
    if ( !v2 )
    {
LABEL_2:
      sub_1006A140(2015, (int)&v5, 12);
      return v6;
    }
    sub_1006A140(2101, (int)&v5, 12);
  }
  return v6;
}

//----- (10044AC0) --------------------------------------------------------
int __cdecl sub_10044AC0(unsigned __int8 a1)
{
  void *v1; // ecx@0

  return dword_100CBE60[(unsigned __int8)sub_10045170(v1) + 2 * a1];
}
// 100CBE60: using guessed type int dword_100CBE60[];

//----- (10044AE0) --------------------------------------------------------
double __cdecl sub_10044AE0(float a1)
{
  double result; // st7@1
  double v2; // st6@3
  float v3; // [sp+4h] [bp+4h]@4

  result = a1;
  if ( (LODWORD(a1) & 0x7F800000) == 2139095040 )
  {
    result = (float)0.0;
  }
  else
  {
    v2 = -304.79999;
    if ( result <= -304.79999 || (v2 = 45720.0, result >= 45720.0) )
    {
      v3 = v2;
      result = v3;
    }
  }
  return result;
}

//----- (10044B40) --------------------------------------------------------
double __cdecl sub_10044B40(float a1)
{
  double result; // st7@1

  result = a1;
  if ( (LODWORD(a1) & 0x7F800000) == 2139095040 )
  {
    result = (float)101320.69;
  }
  else if ( result <= 74500.0 )
  {
    result = (float)74500.0;
  }
  if ( result >= 110100.0 )
    result = (float)110100.0;
  return result;
}

//----- (10044BB0) --------------------------------------------------------
bool __usercall sub_10044BB0@<al>(int a1@<eax>)
{
  signed int v1; // eax@17
  bool result; // al@19

  result = 0;
  if ( *(_BYTE *)(a1 + 2) < 3u
    && *(_BYTE *)(a1 + 10) < 3u
    && *(_BYTE *)a1 < 8u
    && *(_BYTE *)(a1 + 1) < 0xBu
    && *(_BYTE *)(a1 + 3) < 0xFu
    && *(_BYTE *)(a1 + 4) < 0xDu
    && *(_BYTE *)(a1 + 5) < 6u
    && *(_BYTE *)(a1 + 24) < 0xDu
    && *(_BYTE *)(a1 + 6) < 7u
    && *(_BYTE *)(a1 + 25) < 0xDu
    && *(_BYTE *)(a1 + 7) < 0xEu
    && *(_BYTE *)(a1 + 8) < 0xDu
    && *(_BYTE *)(a1 + 9) < 8u
    && *(_BYTE *)(a1 + 26) < 0xDu
    && *(_BYTE *)(a1 + 11) < 0x13u
    && *(_BYTE *)(a1 + 12) < 0xDu )
  {
    v1 = *(_DWORD *)(a1 + 20);
    if ( v1 >= 0 && v1 <= 357913941 )
      result = 1;
  }
  return result;
}

//----- (10044C20) --------------------------------------------------------
char __cdecl sub_10044C20(char *a1)
{
  char *v1; // edi@1
  char v2; // bl@1
  signed int v3; // ebp@1
  char *v4; // esi@1
  char v5; // al@2
  bool v6; // al@4
  char result; // al@13
  char v8; // dh@15
  bool v9; // al@16
  bool v10; // bl@20
  void *v11; // ecx@22
  char v12; // al@23
  int v13; // eax@23
  __int16 v14; // [sp+10h] [bp-88h]@1
  int v15; // [sp+14h] [bp-84h]@1
  char *v16; // [sp+18h] [bp-80h]@1
  char v17; // [sp+1Ch] [bp-7Ch]@27
  char v18; // [sp+20h] [bp-78h]@16
  char v19; // [sp+3Eh] [bp-5Ah]@29
  char v20; // [sp+58h] [bp-40h]@1
  char v21; // [sp+5Ch] [bp-3Ch]@19
  char v22; // [sp+7Ah] [bp-1Eh]@31

  v16 = a1;
  v15 = 3342386;
  v1 = 0;
  v2 = sub_10044590();
  v14 = 0;
  v3 = 1;
  v4 = &v20;
  do
  {
    v5 = sub_1003E2C0(1, *((_WORD *)&v15 + v3), v4);
    *((_BYTE *)&v14 + v3) = v5;
    v6 = v5 && !sub_100434C0((unsigned __int8 *)v4);
    *((_BYTE *)&v14 + v3) = v6;
    if ( v6 && *v4 == v2 )
      v1 = v4;
    --v3;
    v4 -= 60;
  }
  while ( v3 >= 0 );
  if ( !v1 )
    return 0;
  if ( v2 )
  {
    if ( v2 != 1 )
      return 0;
    goto LABEL_34;
  }
  v8 = HIBYTE(v14);
  if ( !(_BYTE)v14 || (v9 = sub_10044BB0((int)&v18), LOBYTE(v14) = 1, !v9) )
    LOBYTE(v14) = 0;
  v10 = v8 && sub_10044BB0((int)&v21);
  if ( sub_10044790() )
  {
    v12 = sub_10045170(v11);
    LOBYTE(v15) = v12;
    v13 = (unsigned __int8)sub_100445F0(v12) - 1;
    if ( v13 )
    {
      if ( v13 != 1 )
        return 0;
      goto LABEL_32;
    }
    if ( !(_BYTE)v14 )
      return 0;
LABEL_27:
    result = 1;
    qmemcpy(v16, &v17, 0x3Cu);
    return result;
  }
  if ( (_BYTE)v14 && (v19 || !v10 || !v22) )
    goto LABEL_27;
LABEL_32:
  if ( !v10 )
    return 0;
  v1 = &v20;
LABEL_34:
  result = 1;
  qmemcpy(v16, v1, 0x3Cu);
  return result;
}

//----- (10044DA0) --------------------------------------------------------
double sub_10044DA0()
{
  double result; // st7@1
  float v1; // [sp+4h] [bp-8h]@1
  float v2; // [sp+8h] [bp-4h]@1

  v2 = 9.8999998e24;
  sub_1006A100(9154, &v1, 4, &v2);
  result = v1;
  if ( v1 != 9.8999998e24 )
  {
    v1 = sub_10044AE0(v1);
    result = v1;
  }
  return result;
}

//----- (10044E00) --------------------------------------------------------
double __thiscall sub_10044E00(void *this)
{
  char v1; // bl@1
  void *v2; // ecx@1
  double result; // st7@2
  char v4; // [sp+4h] [bp-Ch]@2
  float v5; // [sp+Ch] [bp-4h]@2

  v1 = sub_10045170(this);
  if ( sub_100445D0(v2) )
  {
    sub_1006A140(2015, (int)&v4, 12);
    result = v5;
  }
  else if ( v1 )
  {
    sub_1006A140(2101, (int)&v4, 12);
    result = v5;
  }
  else
  {
    sub_1006A140(2015, (int)&v4, 12);
    result = v5;
  }
  return result;
}

//----- (10044E70) --------------------------------------------------------
char sub_10044E70()
{
  return sub_100449C0(0);
}

//----- (10044E80) --------------------------------------------------------
void sub_10044E80()
{
  sub_10044A40(0);
}

//----- (10044E90) --------------------------------------------------------
char __fastcall sub_10044E90(int a1)
{
  int v1; // eax@1
  char result; // al@1
  int v3; // [sp-2h] [bp-4h]@1

  v3 = a1;
  HIWORD(v3) = 0;
  v1 = sub_10044AC0(0);
  sub_1006A100(v1, (char *)&v3 + 2, 1, (char *)&v3 + 3);
  result = BYTE2(v3);
  if ( BYTE2(v3) >= 3u )
    result = 0;
  return result;
}

//----- (10044ED0) --------------------------------------------------------
int __cdecl sub_10044ED0(float a1)
{
  float v2; // [sp+4h] [bp-4h]@1

  v2 = sub_10044AE0(a1);
  return sub_1006A190(9154, (int)&v2, 4);
}

//----- (10044F00) --------------------------------------------------------
void __cdecl sub_10044F00(char a1, float a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@1
  char v4; // bl@1
  int v5; // [sp-8h] [bp-20h]@2
  char *v6; // [sp-4h] [bp-1Ch]@2
  char v7; // [sp+Bh] [bp-Dh]@2
  char v8; // [sp+Ch] [bp-Ch]@2
  float v9; // [sp+10h] [bp-8h]@7
  float v10; // [sp+14h] [bp-4h]@7

  v4 = sub_100445D0(v2);
  if ( v4 )
  {
    v6 = &v8;
    v7 = 0;
    v5 = 2015;
  }
  else
  {
    v7 = sub_10045170(v3);
    if ( v7 )
    {
      v6 = &v8;
      v5 = 2101;
    }
    else
    {
      v6 = &v8;
      v5 = 2015;
    }
  }
  sub_1006A140(v5, (int)v6, 12);
  v8 = a1;
  if ( a1 )
  {
    v9 = sub_10044B40(a2);
    v10 = v9;
  }
  else
  {
    v9 = 101325.0;
  }
  if ( (v4 || !v7) && (sub_1006A190(2015, (int)&v8, 12), v4) || v7 == 1 )
    sub_1006A190(2101, (int)&v8, 12);
}

//----- (10044FD0) --------------------------------------------------------
int __cdecl sub_10044FD0(int a1)
{
  int v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@2
  int result; // eax@3

  v2 = (unsigned __int8)sub_10044E90(v1);
  if ( (_BYTE)v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      result = v3 - 1;
      if ( !result )
        result = sub_1006A190(2065, (int)&a1, 4);
    }
    else
    {
      result = sub_1006A190(2064, (int)&a1, 4);
    }
  }
  else
  {
    result = sub_1006A190(2016, (int)&a1, 4);
  }
  return result;
}

//----- (10045030) --------------------------------------------------------
double __fastcall sub_10045030(float a1)
{
  float v2; // [sp+8h] [bp-4h]@1

  v2 = a1;
  if ( !sub_10044530(&v2) )
    v2 = 0.0;
  v2 = v2 * 3.280839920043945;
  v2 = sub_100229B0(v2, 100.0) * 0.3048000037670135;
  v2 = sub_10044AE0(v2);
  sub_1006A190(9154, (int)&v2, 4);
  return v2;
}

//----- (100450B0) --------------------------------------------------------
int __thiscall sub_100450B0(void *this)
{
  int v1; // eax@1
  int v2; // eax@2
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v1 = (unsigned __int8)sub_10044E90((int)this);
  if ( (_BYTE)v1 )
  {
    v2 = v1 - 1;
    if ( !v2 )
    {
      sub_1006A3A0(2064, &v4, 4, &v5);
      return v4;
    }
    if ( v2 == 1 )
    {
      sub_1006A3A0(2065, &v4, 4, &v5);
      return v4;
    }
  }
  else
  {
    sub_1006A3A0(2016, &v4, 4, &v5);
  }
  return v4;
}

//----- (10045140) --------------------------------------------------------
char __cdecl sub_10045140(char a1)
{
  char result; // al@1

  result = sub_100564E0();
  if ( result == 2 )
    result = byte_100CC424[8 * sub_1003B860(&a1, 4u, (int)&unk_100CC420, 8, 7, 7)];
  return result;
}

//----- (10045170) --------------------------------------------------------
char __thiscall sub_10045170(void *this)
{
  char v1; // al@1

  v1 = sub_10037130(this);
  return sub_10045140(v1);
}

//----- (100451D0) --------------------------------------------------------
int __cdecl sub_100451D0(int a1, float a2)
{
  int result; // eax@1

  result = (signed int)(sub_10022BB0(a2) * 683565248.0);
  *(_DWORD *)a1 = result;
  return result;
}

//----- (10045200) --------------------------------------------------------
char __cdecl sub_10045200(__int16 a1, void *a2)
{
  size_t v2; // eax@2
  char result; // al@6
  __int16 v4; // [sp+0h] [bp-Ch]@1
  char v5; // [sp+4h] [bp-8h]@5

  v4 = a1;
  switch ( a1 )
  {
    case 0x8003:
    case 0x8004:
      v2 = 8;
      goto LABEL_5;
    case 0x8006:
      v2 = 4;
      goto LABEL_5;
    case 0x8001:
    case 0x8007:
      v2 = 1;
LABEL_5:
      memcpy(&v5, a2, v2);
      goto LABEL_6;
    case 0x8005:
    case 0x8008:
    case 0x8009:
LABEL_6:
      result = sub_10069800(40, (int)&v4, 200, 1);
      break;
    default:
      result = sub_100364C0("..\\lib\\adl\\nav_intf_send.c", 162, 0, 0);
      break;
  }
  return result;
}

//----- (100452A0) --------------------------------------------------------
int __cdecl sub_100452A0(int a1)
{
  int result; // eax@1

  result = a1;
  dword_106AD2EC = *(_DWORD *)a1;
  dword_106AD2F0 = *(_DWORD *)(a1 + 4);
  dword_106AD2F4 = *(_DWORD *)(a1 + 8);
  dword_106AD2F8 = *(_DWORD *)(a1 + 12);
  dword_10789708 = (int)&dword_106AD2EC;
  return result;
}
// 106AD2EC: using guessed type int dword_106AD2EC;
// 106AD2F0: using guessed type int dword_106AD2F0;
// 106AD2F4: using guessed type int dword_106AD2F4;
// 106AD2F8: using guessed type int dword_106AD2F8;
// 10789708: using guessed type int dword_10789708;

//----- (100452E0) --------------------------------------------------------
signed int __cdecl sub_100452E0(unsigned int a1)
{
  int v1; // eax@1

  v1 = sub_100453A0(a1);
  return sub_10046930(v1);
}

//----- (10045320) --------------------------------------------------------
signed int __cdecl sub_10045320(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_100453A0(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_10046E10(v4, a4, 0) == a4 )
      result = sub_10046DB0(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10045380) --------------------------------------------------------
signed int __cdecl sub_10045380(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_100453A0(a1);
  return sub_10046E10(v3, a2, a3);
}

//----- (100453A0) --------------------------------------------------------
unsigned int __cdecl sub_100453A0(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (100453C0) --------------------------------------------------------
int __cdecl sub_100453C0(int a1)
{
  return a1 | 1;
}

//----- (100453D0) --------------------------------------------------------
bool __cdecl sub_100453D0(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (100454A0) --------------------------------------------------------
int __cdecl sub_100454A0(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (100454C0) --------------------------------------------------------
int __cdecl sub_100454C0(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_100454A0(a1 + 20);
  return result;
}

//----- (10045500) --------------------------------------------------------
bool __cdecl sub_10045500(int a1)
{
  unsigned int v1; // esi@2
  unsigned int v2; // ecx@5
  bool result; // al@11

  result = a1
        && (v1 = *(_DWORD *)(a1 + 116), v1 < 0xFFFFFFC2)
        && v1
        && *(_DWORD *)a1 != -1
        && ((v2 = *(_DWORD *)(a1 + 120), *(_DWORD *)a1 + 22 <= v2)
         && *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 20) + 22 <= v2
         || !v2
         || *(_DWORD *)(a1 + 4) != v1)
        && *(_DWORD *)(a1 + 8) == 101010256
        && *(_WORD *)(a1 + 14) == *(_WORD *)(a1 + 12);
  return result;
}

//----- (10045560) --------------------------------------------------------
signed int __cdecl sub_10045560(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_1006B340(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_1006B340(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (10045620) --------------------------------------------------------
signed int __cdecl sub_10045620(int a1, int a2, int a3)
{
  int v3; // esi@3
  signed int result; // eax@9

  if ( sub_1006B340(*(_DWORD *)(a1 + 116), (void *)a3, 30, *(_DWORD *)(a2 + 42), 0) != 30 )
    goto LABEL_13;
  if ( *(_BYTE *)(a2 + 8) & 8 )
  {
    v3 = *(_DWORD *)(a2 + 42) + *(_DWORD *)(a2 + 20) + sub_100454C0(0, a3);
    sub_1006B340(*(_DWORD *)(a1 + 116), (void *)(a3 + 14), 12, v3, 0);
    if ( *(_DWORD *)(a3 + 14) != *(_DWORD *)(a2 + 16) )
      sub_1006B340(*(_DWORD *)(a1 + 116), (void *)(a3 + 14), 12, v3 + 4, 0);
  }
  if ( *(_DWORD *)a3 != 67324752
    || *(_DWORD *)(a3 + 18) != *(_DWORD *)(a2 + 20)
    || *(_DWORD *)(a3 + 14) != *(_DWORD *)(a2 + 16)
    || *(_WORD *)(a3 + 26) != *(_WORD *)(a2 + 28) )
  {
LABEL_13:
    result = -15;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100456D0) --------------------------------------------------------
int __cdecl sub_100456D0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (100456F0) --------------------------------------------------------
signed int __cdecl sub_100456F0(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebp@1
  _BYTE *v4; // edi@2
  _BYTE *v5; // ebx@2
  int v6; // esi@3
  signed int result; // eax@5
  int v8; // [sp+1Ch] [bp+Ch]@3

  v3 = a3;
  if ( a3 )
  {
    v4 = a2;
    v5 = a1;
    while ( 1 )
    {
      v6 = *v5;
      --v3;
      v8 = tolower(*v4++);
      ++v5;
      if ( tolower(v6) != v8 )
        break;
      if ( !v3 )
        goto LABEL_5;
    }
    result = 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (10045750) --------------------------------------------------------
int __usercall sub_10045750@<eax>(int a1@<esi>, int a2, char a3)
{
  int v3; // ebp@1
  int v4; // edi@2
  int v5; // ebx@2
  int v6; // ebp@5
  int v7; // eax@5
  int v8; // ST04_4@5
  int v10; // [sp+Ch] [bp-4h]@4
  int v11; // [sp+18h] [bp+8h]@4

  v3 = a2;
  if ( a3 )
  {
    v4 = a2;
    v3 = *(_DWORD *)(a1 + 116);
    v5 = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 116);
    v5 = *(_DWORD *)(a1 + 120);
  }
  v11 = *(_DWORD *)(a1 + 24);
  sub_1006B430(v3);
  v10 = sub_1006B280(v4, v5, v3, v11, *(_DWORD *)(a1 + 20));
  if ( !v10 )
  {
    *(_DWORD *)(a1 + 24) = v5;
    *(_DWORD *)(a1 + 4) = v4;
    *(_DWORD *)(a1 + 120) = v11;
    v6 = sub_1006B460(v3, v11, 0);
    v7 = *(_DWORD *)(a1 + 24);
    v8 = v5 + *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 36) = v7;
    v10 = sub_1006B460(v4, v8, 0) | v6;
  }
  *(_DWORD *)(a1 + 120) = sub_1006B430(*(_DWORD *)(a1 + 116));
  return v10;
}

//----- (10045860) --------------------------------------------------------
int __usercall sub_10045860@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_1005A140(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_1006B430(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_1006B460(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 1006B480: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10045910) --------------------------------------------------------
signed int __usercall sub_10045910@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_1006B490(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_1005A590((void *)(v2 + 555), v7);
  }
  else
  {
    sub_10045560(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_1006B340(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_1006B340(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_1005A460(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_1006B490(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_1006B490(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (10045AE0) --------------------------------------------------------
char __usercall sub_10045AE0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_1005A0F0(a2, a3, a1 + 212);
}

//----- (10045AF0) --------------------------------------------------------
int __usercall sub_10045AF0@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_10045860(result + 148, result);
  return result;
}

//----- (10045B10) --------------------------------------------------------
char __usercall sub_10045B10@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (10045B30) --------------------------------------------------------
int __usercall sub_10045B30@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  int result; // eax@1

  v2 = sub_10022E60(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_10022E60(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (10045B70) --------------------------------------------------------
int __cdecl sub_10045B70(unsigned int a1)
{
  int i; // ebx@1
  int v2; // edi@1
  signed int v3; // eax@1
  signed int v4; // ebp@1
  int result; // eax@2
  int v6; // esi@7
  int v7; // ebx@9
  int v8; // eax@10
  unsigned int v9; // ecx@11
  int *v10; // edx@11
  char *v11; // esi@11
  int v12; // edi@15
  int v13; // ecx@16
  _BYTE *v14; // edx@16
  _BYTE *v15; // esi@16
  int v16; // ecx@18
  _BYTE *v17; // edx@18
  _BYTE *v18; // esi@18
  _BYTE *v19; // edx@20
  _BYTE *v20; // esi@20
  signed int v21; // ecx@22
  signed int v22; // [sp+Ch] [bp-9Ch]@1
  int v23; // [sp+10h] [bp-98h]@7
  signed int v24; // [sp+14h] [bp-94h]@1
  int v25; // [sp+18h] [bp-90h]@1
  int v26; // [sp+20h] [bp-88h]@1
  char v27[128]; // [sp+24h] [bp-84h]@9

  i = 65557;
  v2 = 0;
  v22 = 65557;
  v25 = 0;
  v26 = 101010256;
  v3 = sub_1006B430(a1);
  v4 = v3;
  v24 = v3;
  if ( v3 >= 0 )
  {
    if ( (unsigned int)v3 >= 0x10015 )
      goto LABEL_7;
    v22 = v3;
    if ( v3 > 0 )
    {
      for ( i = v3; ; i = v22 )
      {
LABEL_7:
        v6 = v2 + 128;
        v23 = v2 + 128;
        if ( v2 + 128 > i )
        {
          v6 = i;
          v23 = i;
        }
        v7 = v6 - v2;
        if ( sub_1006B340(a1, v27, v6 - v2, v4 - v6, 0) != v6 - v2 )
          break;
        v8 = v7 - 4;
        if ( v7 - 4 >= 0 )
        {
          while ( 1 )
          {
            v9 = 4;
            v10 = &v26;
            v11 = &v27[v8];
            do
            {
              if ( *(_DWORD *)v11 != *v10 )
                goto LABEL_15;
              v9 -= 4;
              ++v10;
              v11 += 4;
            }
            while ( v9 >= 4 );
            if ( !v9 )
            {
LABEL_24:
              v21 = 0;
              goto LABEL_25;
            }
LABEL_15:
            v12 = (unsigned __int8)*v11 - *(_BYTE *)v10;
            if ( (unsigned __int8)*v11 == *(_BYTE *)v10 )
            {
              v13 = v9 - 1;
              v14 = (char *)v10 + 1;
              v15 = v11 + 1;
              if ( !v13 )
                goto LABEL_24;
              v12 = *v15 - *v14;
              if ( *v15 == *v14 )
              {
                v16 = v13 - 1;
                v17 = v14 + 1;
                v18 = v15 + 1;
                if ( !v16 )
                  goto LABEL_24;
                v12 = *v18 - *v17;
                if ( *v18 == *v17 )
                {
                  v19 = v17 + 1;
                  v20 = v18 + 1;
                  if ( v16 == 1 )
                    goto LABEL_24;
                  v12 = *v20 - *v19;
                  if ( *v20 == *v19 )
                    goto LABEL_24;
                }
              }
            }
            v21 = 1;
            if ( v12 <= 0 )
              v21 = -1;
LABEL_25:
            if ( !v21 )
              return v24 + v8 - v23;
            if ( --v8 < 0 )
            {
              v4 = v24;
              v2 = v25;
              v6 = v23;
              break;
            }
          }
        }
        v2 = v2 + v7 - 3;
        v25 = v2;
        if ( v6 >= v22 )
          break;
      }
    }
    result = -1;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 10045B70: using guessed type char var_84[128];

//----- (10045D20) --------------------------------------------------------
int __fastcall sub_10045D20(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (10045D40) --------------------------------------------------------
int __usercall sub_10045D40@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_DWORD *)(a2 + 732) = result;
  ++*(_DWORD *)(result + 124);
  return result;
}

//----- (10045D50) --------------------------------------------------------
int __usercall sub_10045D50@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_1006B760(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_1006B460(v4, v3, 0);
}
// 1006B480: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10045D90) --------------------------------------------------------
signed int __usercall sub_10045D90@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_10045D20(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_10022E80(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_10045AE0(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_1005C4F0(a2 + 28, 4);
      else
        v22 = sub_1005C4F0(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy_0(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_10045AE0(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 1006B480: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10045FA0) --------------------------------------------------------
int __cdecl sub_10045FA0(void *a1)
{
  unsigned int v1; // ecx@2
  unsigned int v2; // eax@4
  int v3; // edi@4
  int v4; // edi@7
  int result; // eax@8

  if ( a1 && (v1 = *((_DWORD *)a1 + 29), v1 < 0xFFFFFFC2) && v1 )
  {
    v2 = *((_DWORD *)a1 + 1);
    v3 = 0;
    if ( v1 != v2 && v2 < 0xFFFFFFC2 )
    {
      if ( v2 )
      {
        v4 = sub_10045750((int)a1, v2, 0);
        v3 = sub_10045D50((int)a1) | v4;
      }
    }
    sub_1006B1D0(*((_DWORD *)a1 + 29));
    memset(a1, 0, 0x80u);
    result = v3;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10046000) --------------------------------------------------------
int __cdecl sub_10046000(int a1, int a2, void *a3, int a4)
{
  unsigned int v4; // eax@3
  signed int v5; // edi@5
  unsigned int v6; // eax@6
  int v8; // eax@11
  int v9; // eax@17

  memset(a3, 0, 0x80u);
  *((_DWORD *)a3 + 8) = -1;
  *((_DWORD *)a3 + 9) = -1;
  *((_BYTE *)a3 + 48) = 0;
  if ( a4 )
    sub_100365D0((int)a3 + 48, (_BYTE *)a4, 64);
  *((_BYTE *)a3 + 112) = 3;
  v4 = j_FIL_vfs_open(a1, a2, 0);
  *((_DWORD *)a3 + 29) = v4;
  if ( v4 >= 0xFFFFFFC2 || !v4 )
  {
    v5 = v4;
    if ( !v4 )
      return v5;
LABEL_6:
    v6 = *((_DWORD *)a3 + 29);
    if ( v6 < 0xFFFFFFC2 )
    {
      if ( v6 )
        sub_1006B1D0(*((_DWORD *)a3 + 29));
    }
    memset(a3, 0, 0x80u);
    return v5;
  }
  *((_DWORD *)a3 + 1) = v4;
  v8 = sub_1006B430(v4);
  *((_DWORD *)a3 + 30) = v8;
  if ( v8 < 0 )
  {
LABEL_12:
    v5 = -15;
    goto LABEL_6;
  }
  if ( v8 || !(a2 & 2) )
  {
    v9 = sub_10045B70(*((_DWORD *)a3 + 29));
    *(_DWORD *)a3 = v9;
    if ( v9 == -1 || (unsigned int)(v9 + 22) > *((_DWORD *)a3 + 30) )
      goto LABEL_12;
    sub_1006B340(*((_DWORD *)a3 + 1), (char *)a3 + 8, 22, v9, 0);
    if ( !sub_10045500((int)a3) )
    {
      v5 = -15;
      goto LABEL_6;
    }
  }
  else
  {
    *((_DWORD *)a3 + 2) = 101010256;
  }
  return 0;
}
// 1006B2E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10046100) --------------------------------------------------------
signed int __cdecl sub_10046100(int a1, unsigned __int64 a2)
{
  unsigned int v2; // eax@3
  signed int v3; // esi@3
  unsigned int v4; // ebp@4
  int v5; // edx@8
  void *v6; // eax@9
  unsigned __int16 v7; // si@10
  unsigned __int16 v8; // cx@10
  void *v9; // ecx@17
  unsigned __int16 v10; // ax@19
  signed int result; // eax@24
  int v12; // ecx@25
  int v13; // [sp+8h] [bp-4h]@4

  if ( sub_10045500(a1) && a2 < *(_WORD *)(a1 + 16) )
  {
    v2 = *(_DWORD *)(a1 + 32);
    v3 = -15;
    if ( (unsigned int)a2 < v2 )
    {
      v4 = *(_DWORD *)(a1 + 24);
      v13 = 0;
LABEL_5:
      while ( v4 < *(_DWORD *)(a1 + 120) )
      {
        v3 = sub_1006B340(*(_DWORD *)(a1 + 4), (void *)(HIDWORD(a2) + 4), 46, v4, 0);
        if ( v3 != 46 || *(_DWORD *)(HIDWORD(a2) + 4) != 33639248 )
        {
          v12 = *(_DWORD *)(a1 + 24);
          *(_DWORD *)(a1 + 32) = 0;
          *(_DWORD *)(a1 + 36) = v12;
          v3 = -15;
          break;
        }
        v5 = a1;
        *(_DWORD *)(a1 + 32) = v13;
        *(_DWORD *)(a1 + 36) = v4;
        if ( v13 == (_DWORD)a2 )
        {
          v6 = *(void **)(HIDWORD(a2) + 52);
          v3 = 0;
          *(_DWORD *)HIDWORD(a2) = v4;
          *(_WORD *)(HIDWORD(a2) + 58) = -1;
          if ( v6 )
          {
            v7 = *(_WORD *)(HIDWORD(a2) + 56);
            v8 = *(_WORD *)(HIDWORD(a2) + 32);
            if ( v7 <= v8 )
            {
              sub_100365D0((int)v6, byte_10084570, v7);
              v5 = a1;
              v3 = -15;
            }
            else if ( sub_1006B340(*(_DWORD *)(a1 + 4), v6, v8, v4 + 46, 0) == *(_WORD *)(HIDWORD(a2) + 32) )
            {
              v5 = a1;
              *(_WORD *)(HIDWORD(a2) + 58) = *(_WORD *)(HIDWORD(a2) + 32);
              v3 = 0;
              *(_BYTE *)(*(_WORD *)(HIDWORD(a2) + 32) + *(_DWORD *)(HIDWORD(a2) + 52)) = 0;
            }
            else
            {
              v5 = a1;
              v3 = -15;
              *(_BYTE *)(*(_WORD *)(HIDWORD(a2) + 32) + *(_DWORD *)(HIDWORD(a2) + 52)) = 0;
            }
          }
          else
          {
            *(_WORD *)(HIDWORD(a2) + 58) = -1;
          }
          v9 = *(void **)(HIDWORD(a2) + 60);
          *(_WORD *)(HIDWORD(a2) + 66) = -1;
          if ( v9 )
          {
            if ( !v3 )
            {
              v10 = *(_WORD *)(HIDWORD(a2) + 34);
              if ( *(_WORD *)(HIDWORD(a2) + 64) < v10
                || sub_1006B340(*(_DWORD *)(v5 + 4), v9, v10, *(_WORD *)(HIDWORD(a2) + 32) + v4 + 46, 0) != *(_WORD *)(HIDWORD(a2) + 34) )
              {
                v3 = -15;
              }
              else
              {
                v3 = 0;
                *(_WORD *)(HIDWORD(a2) + 66) = *(_WORD *)(HIDWORD(a2) + 34);
              }
            }
          }
        }
        v4 += sub_100454A0(HIDWORD(a2) + 4);
        if ( ++v13 > (unsigned int)a2 )
          return v3;
      }
    }
    else
    {
      v4 = *(_DWORD *)(a1 + 36);
      v13 = *(_DWORD *)(a1 + 32);
      if ( v2 <= (unsigned int)a2 )
        goto LABEL_5;
    }
    result = v3;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10046300) --------------------------------------------------------
signed int __cdecl sub_10046300(int a1, int a2)
{
  return sub_10045620(*(_DWORD *)(a1 + 732), a1 + 20, a2);
}

//----- (10046320) --------------------------------------------------------
int __cdecl sub_10046320(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_10045AF0(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_10039160(&v23);
    sub_10039060((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_100454C0(v1, (int)&v24);
  v13 = sub_1006B430(v31);
  if ( v3 == v31 )
  {
    result = sub_1006B280(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_1006B760(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_1006B280(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_1006B760(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_100454A0(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_10045D50(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_1006B430(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 1006B480: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10046590) --------------------------------------------------------
int __cdecl sub_10046590(void *a1, int a2, char a3)
{
  _BYTE *v3; // eax@1
  char *v4; // edi@3
  int result; // eax@4

  memset(a1, 0, 0x2E0u);
  *((_DWORD *)a1 + 17) = *(_DWORD *)(a2 + 4);
  *((_WORD *)a1 + 36) = *(_WORD *)(a2 + 8);
  *((_DWORD *)a1 + 19) = *(_DWORD *)(a2 + 16);
  *((_WORD *)a1 + 40) = *(_WORD *)(a2 + 20);
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *((_DWORD *)a1 + 24) = *(_DWORD *)(a2 + 24);
  *((_DWORD *)a1 + 25) = *(_DWORD *)(a2 + 28);
  *((_DWORD *)a1 + 26) = 0;
  *((_DWORD *)a1 + 27) = 0;
  sub_100456D0((int)a1 + 116);
  v3 = *(_BYTE **)(a2 + 12);
  if ( v3 )
    sub_100365D0((int)a1 + 148, v3, 64);
  v4 = (char *)a1 + 116;
  if ( a3 )
    result = sub_1005C7B0(
               (int)v4,
               *(_BYTE *)(a2 + 44),
               8,
               -*(_DWORD *)(a2 + 40),
               *(_DWORD *)(a2 + 48),
               0,
               *(_DWORD *)(a2 + 32),
               *(_DWORD *)(a2 + 36));
  else
    result = sub_1005E110((int)v4, -*(_DWORD *)(a2 + 40), *(_DWORD *)(a2 + 32), *(_DWORD *)(a2 + 36));
  return result;
}

//----- (10046660) --------------------------------------------------------
signed int __cdecl sub_10046660(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_1006B760(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_10045D90(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10046700) --------------------------------------------------------
int __usercall sub_10046700@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_10045B10(a1);
  *v3 ^= v2;
  return sub_10045B30(v1, *v3);
}

//----- (10046720) --------------------------------------------------------
int __usercall sub_10046720@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_10046700(a2);
  return result;
}

//----- (10046750) --------------------------------------------------------
signed int __usercall sub_10046750@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_10045B30(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_1006B340(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (100467C0) --------------------------------------------------------
int __cdecl sub_100467C0(int a1, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // ebx@4
  int v5; // esi@6
  int result; // eax@11
  signed int v7; // [sp+8h] [bp-F4h]@6
  char v8; // [sp+Ch] [bp-F0h]@4
  char *v9; // [sp+40h] [bp-BCh]@4
  __int16 v10; // [sp+44h] [bp-B8h]@4
  unsigned __int16 v11; // [sp+46h] [bp-B6h]@8
  char v12; // [sp+50h] [bp-ACh]@4

  v3 = a2;
  if ( sub_10045500(a1) && a2 && *a2 )
  {
    memset(&v8, 0, 0x44u);
    v9 = &v12;
    v10 = 168;
    v4 = strlen(a2);
    strchr(a2, 92);
    if ( *a2 == 47 )
    {
      v3 = a2 + 1;
      --v4;
    }
    v5 = a3;
    v7 = -24;
    if ( a3 < (unsigned int)*(_WORD *)(a1 + 16) )
    {
      while ( sub_10046100(a1, __PAIR__(&v8, v5)) || v4 != v11 || sub_100456F0(v3, &v12, v4) )
      {
        if ( ++v5 >= (unsigned int)*(_WORD *)(a1 + 16) )
          return -24;
      }
      v7 = v5;
    }
    result = v7;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10046930) --------------------------------------------------------
signed int __cdecl sub_10046930(int a1)
{
  signed int result; // eax@5

  if ( a1 && *(_DWORD *)(a1 + 732) )
  {
    --*(_DWORD *)(*(_DWORD *)(a1 + 732) + 124);
    if ( *(_BYTE *)(a1 + 8) )
      exit_0(a1);
    sub_1005D5E0(a1 + 116);
    result = 0;
    *(_DWORD *)a1 = -858993460;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10046990) --------------------------------------------------------
char __usercall sub_10046990@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_1005A0A0(a1, a2, a3 + 212);
  else
    result = sub_10046720(a2, a3 + 148);
  return result;
}

//----- (100469C0) --------------------------------------------------------
signed int __usercall sub_100469C0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_10045910(v3, v1);
  else
    result = sub_10046750(v3, v1);
  return result;
}

//----- (100469F0) --------------------------------------------------------
BOOL __usercall sub_100469F0@<eax>(int a1@<ebx>, int a2)
{
  int v2; // ebp@1
  unsigned int v3; // esi@1
  int v4; // edi@1
  char v6; // [sp+10h] [bp+4h]@2

  v2 = a2;
  v3 = 0;
  v4 = a2 + 148;
  do
  {
    v6 = *(_BYTE *)(a1 + v3 + 76);
    sub_10046700(v4);
    ++v3;
  }
  while ( v3 < 0xC );
  return *(_BYTE *)(v2 + 39) == v6;
}

//----- (10046A30) --------------------------------------------------------
signed int __cdecl sub_10046A30(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_100456D0(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_1005E200(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_100469C0(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10046A80) --------------------------------------------------------
signed int __cdecl sub_10046A80(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_1006B340(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_10046990(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_1006B340(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_1005A140(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_10045D20(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_1005F5C0(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_10022E80(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy_0(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_10022E80(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (10046C70) --------------------------------------------------------
bool __usercall sub_10046C70@<al>(int a1@<eax>)
{
  int v1; // ecx@4
  int v2; // edx@4
  int v3; // eax@4
  signed int v4; // ecx@6
  int v5; // eax@2

  if ( *(_WORD *)(a1 + 30) != 99 )
    return sub_100469F0(a1 + 148, a1);
  v5 = a1 + 148;
  v1 = v5 + 543;
  v2 = v5 + 571;
  v3 = *(_BYTE *)(v5 + 571) - *(_BYTE *)(v5 + 543);
  if ( v3 || (v3 = *(_BYTE *)(v2 + 1) - *(_BYTE *)(v1 + 1), *(_BYTE *)(v2 + 1) != *(_BYTE *)(v1 + 1)) )
  {
    v4 = 1;
    if ( v3 <= 0 )
      return 0;
  }
  else
  {
    v4 = 0;
  }
  return v4 == 0;
}

//----- (10046CA0) --------------------------------------------------------
int __cdecl sub_10046CA0(int a1, int a2, char a3, void *a4, int a5)
{
  int result; // eax@6
  unsigned __int64 v6; // ST04_8@7
  char v7; // [sp+8h] [bp-54h]@8
  int v8; // [sp+28h] [bp-34h]@4
  int v9; // [sp+34h] [bp-28h]@4

  if ( !sub_10045500(a1) || !a4 || a3 & 2 )
    return -15;
  qmemcpy(&v8, (const void *)a5, 0x34u);
  if ( !v9 )
    v9 = a1 + 48;
  result = sub_10046590(a4, (int)&v8, 0);
  if ( !result )
  {
    HIDWORD(v6) = (char *)a4 + 16;
    LODWORD(v6) = a2;
    if ( sub_10046100(a1, v6) )
      return -15;
    sub_10045D40(a1, (int)a4);
    if ( sub_10046300((int)a4, (int)&v7) )
    {
      sub_100452E0((unsigned int)a4);
      return -15;
    }
    *((_DWORD *)a4 + 21) = *(_DWORD *)((char *)a4 + 62) + sub_100454C0((int)a4, (int)&v7);
    *((_DWORD *)a4 + 3) = a2;
    sub_10046A30((unsigned int)a4);
    if ( !(*((_BYTE *)a4 + 28) & 1) || sub_10046C70((int)a4) )
    {
      result = sub_100453C0((int)a4);
    }
    else
    {
      sub_10046930((int)a4);
      result = -34;
    }
  }
  return result;
}

//----- (10046DB0) --------------------------------------------------------
signed int __cdecl sub_10046DB0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_10046A80(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_100453D0(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10046E10) --------------------------------------------------------
signed int __cdecl sub_10046E10(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_10046A30(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_100456D0(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_10046A30(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_10046DB0(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (10046FA0) --------------------------------------------------------
int __cdecl sub_10046FA0(int a1, char *a2, int a3, void *a4, int a5)
{
  int result; // eax@10
  bool v6; // zf@11
  int v7; // ST0C_4@16
  int v8; // eax@16
  int v9; // [sp+Ch] [bp-34h]@5
  int v10; // [sp+18h] [bp-28h]@5
  char v11; // [sp+38h] [bp-8h]@11

  if ( sub_10045500(a1) && a2 && a4 && a5 )
  {
    qmemcpy(&v9, (const void *)a5, 0x34u);
    if ( !v10 )
      v10 = a1 + 48;
    *((_DWORD *)a4 + 1) = a3;
    if ( a3 & 8 )
    {
      if ( *(_WORD *)(a1 + 16) >= 0xFFFFu || *(_WORD *)(a1 + 18) >= 0xFFFFu )
      {
        result = -22;
      }
      else
      {
        result = sub_10046590(a4, (int)&v9, 1);
        if ( !result )
        {
          *((_DWORD *)a4 + 1) = a3;
          *((_BYTE *)a4 + 8) = 1;
          *((_DWORD *)a4 + 183) = a1;
          *((_DWORD *)a4 + 3) = *(_WORD *)(a1 + 16);
          *((_DWORD *)a4 + 22) = -1;
          *((_WORD *)a4 + 12) = 20;
          *((_WORD *)a4 + 13) = 20;
          *((_DWORD *)a4 + 5) = 33639248;
          *((_WORD *)a4 + 14) = 0;
          *((_WORD *)a4 + 16) = 0;
          *((_WORD *)a4 + 17) = 0;
          *((_DWORD *)a4 + 9) = 0;
          *((_DWORD *)a4 + 10) = 0;
          *((_DWORD *)a4 + 11) = 0;
          v6 = v11 == 0;
          *((_WORD *)a4 + 24) = strlen(a2);
          *((_WORD *)a4 + 25) = 0;
          *((_WORD *)a4 + 26) = 0;
          *((_WORD *)a4 + 27) = 0;
          *((_WORD *)a4 + 28) = 0;
          *(_DWORD *)((char *)a4 + 58) = 0;
          if ( v6 )
            *((_WORD *)a4 + 15) = 0;
          else
            *((_WORD *)a4 + 15) = 8;
          if ( *(_BYTE *)a4 & 4 )
          {
            *(_WORD *)((char *)a4 + 689) = *((_WORD *)a4 + 15);
            *((_WORD *)a4 + 15) = 99;
            *((_WORD *)a4 + 14) = 1;
          }
          *(_DWORD *)((char *)a4 + 62) = *(_DWORD *)(a1 + 120);
          *((_DWORD *)a4 + 21) = *(_DWORD *)((char *)a4 + 62) + sub_100454C0((int)a4, 0);
          sub_10045D40(a1, (int)a4);
          v7 = *(_DWORD *)((char *)a4 + 62);
          v8 = sub_100454C0((int)a4, 0);
          sub_1006B490(*(_DWORD *)(a1 + 116), *((_DWORD *)a4 + 24), v8, v7);
          if ( *((_BYTE *)a4 + 28) & 1 )
            sub_100469C0((int)a4);
          result = sub_100453C0((int)a4);
        }
      }
    }
    else
    {
      *((_BYTE *)a4 + 8) = 0;
      result = sub_100467C0(a1, a2, 0);
      if ( result >= 0 )
        result = sub_10046CA0(a1, result, a3, a4, (int)&v9);
    }
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10047190) --------------------------------------------------------
unsigned int __usercall sub_10047190@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  int v2; // ebp@1
  char v3; // dl@1
  int v4; // ecx@5
  int v5; // esi@5
  float *v6; // edx@6
  _BYTE *v7; // edx@11
  char *v8; // ecx@11
  char v9; // al@12
  int v10; // eax@14
  int v11; // edi@16
  char *v12; // eax@16
  long double v13; // ST28_8@19
  long double v14; // st6@19
  int v15; // edi@19
  char *v16; // eax@21
  _BYTE *v17; // esi@21
  char v18; // cl@22
  unsigned int result; // eax@23
  _BYTE *v20; // edi@23
  char v21; // cl@24
  const void *v22; // ebx@25
  char *v23; // eax@28
  char v24; // cl@29
  char v25; // cl@31
  char *v26; // eax@34
  _BYTE *v27; // edx@34
  char v28; // cl@35
  _BYTE *v29; // edi@36
  char v30; // cl@37
  __int32 v31; // [sp+18h] [bp-8h]@17

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 32);
  v3 = 0;
  if ( *(_BYTE *)v2 <= 1u )
    v3 = 1;
  if ( 9.8999998e24 == *(float *)a1 )
    goto LABEL_10;
  if ( !v3 )
  {
    v4 = *(_BYTE *)v2 - 1;
    v5 = 0;
    if ( v4 > 0 )
    {
      v6 = (float *)(v2 + 44);
      while ( *(v6 - 5) > (double)*(float *)a1 || *v6 <= (double)*(float *)a1 )
      {
        ++v5;
        v6 += 5;
        if ( v5 >= v4 )
          goto LABEL_10;
      }
      v10 = v5 + 1;
      if ( *(float *)v1 >= 0.0 )
        v10 = v5;
      v11 = 20 * v10;
      sprintf(*(char **)(v1 + 36), (const char *)(20 * v10 + v2 + 28), *(float *)v1);
      v12 = strrchr((const char *)(v11 + *(_DWORD *)(v1 + 32) + 28), 46);
      if ( v12 )
        v31 = j__atol(v12 + 1);
      else
        v31 = 0;
      v13 = pow(10.0, (double)v31);
      v14 = atof((const char *)*(_DWORD *)(v1 + 36)) * v13;
      v15 = *(_DWORD *)(v1 + 32);
      if ( (signed int)v14 != (signed int)(v13 * *(float *)(v15 + 20 * v5 + 24)) )
        ++v5;
      sprintf(*(char **)(v1 + 36), (const char *)(v15 + 20 * v5 + 28), *(float *)v1);
      v16 = (char *)(*(_DWORD *)(v1 + 32) + 11);
      v17 = (_BYTE *)(*(_DWORD *)(v1 + 32) + 11);
      do
        v18 = *v16++;
      while ( v18 );
      result = v16 - v17;
      v20 = (_BYTE *)(*(_DWORD *)(v1 + 36) - 1);
      do
        v21 = (v20++)[1];
      while ( v21 );
      goto LABEL_25;
    }
LABEL_10:
    if ( *(_DWORD *)(a1 + 40) )
    {
      memset(*(void **)(a1 + 36), 95, *(_DWORD *)(a1 + 40));
      *(_BYTE *)(*(_DWORD *)(v1 + 40) + *(_DWORD *)(v1 + 36)) = 0;
    }
    else
    {
      v7 = *(_BYTE **)(a1 + 36);
      v8 = (char *)(v2 + 1);
      do
      {
        v9 = *v8;
        *v7++ = *v8++;
      }
      while ( v9 );
    }
    v26 = (char *)(*(_DWORD *)(v1 + 32) + 11);
    v27 = (_BYTE *)(*(_DWORD *)(v1 + 32) + 11);
    do
      v28 = *v26++;
    while ( v28 );
    result = v26 - v27;
    v29 = (_BYTE *)(*(_DWORD *)(v1 + 36) - 1);
    do
      v30 = (v29++)[1];
    while ( v30 );
    qmemcpy(v29, v27, result);
    return result;
  }
  sprintf(*(char **)(a1 + 36), (const char *)(v2 + 28), *(float *)a1);
  v23 = (char *)(*(_DWORD *)(v1 + 32) + 11);
  v17 = (_BYTE *)(*(_DWORD *)(v1 + 32) + 11);
  do
    v24 = *v23++;
  while ( v24 );
  result = v23 - v17;
  v20 = (_BYTE *)(*(_DWORD *)(v1 + 36) - 1);
  do
    v25 = (v20++)[1];
  while ( v25 );
LABEL_25:
  qmemcpy(v20, v17, result);
  v22 = *(const void **)(v1 + 36);
  if ( !memcmp(v22, &unk_100E10D0, 3u) )
    *(_WORD *)v22 = 48;
  return result;
}

//----- (100473D0) --------------------------------------------------------
char __cdecl sub_100473D0(int a1, int a2, int a3, int a4, __int16 *a5)
{
  int v5; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  signed int v8; // ecx@1
  signed int v9; // edx@1
  __int16 v10; // ax@1
  float v12; // [sp+4h] [bp-24h]@1
  float v13; // [sp+8h] [bp-20h]@1
  int v14; // [sp+Ch] [bp-1Ch]@1
  float v15; // [sp+10h] [bp-18h]@1
  int v16; // [sp+14h] [bp-14h]@1
  int v17; // [sp+18h] [bp-10h]@1
  float v18; // [sp+1Ch] [bp-Ch]@1
  float v19; // [sp+20h] [bp-8h]@1
  float v20; // [sp+24h] [bp-4h]@1

  v5 = *(_DWORD *)(a4 + 8);
  v6 = *(_DWORD *)(a4 + 4);
  v15 = *(float *)(a4 + 12);
  v7 = *(_DWORD *)(a4 + 20);
  v18 = *(float *)(a4 + 24);
  v16 = v5;
  v19 = *(float *)(a4 + 28);
  v17 = v6;
  v8 = *(_WORD *)a3;
  v20 = *(float *)(a4 + 16);
  v14 = v7;
  v9 = *(_WORD *)(a3 + 2);
  v12 = (double)v8;
  v10 = *a5;
  v13 = (double)v9;
  if ( v10 == -32648 || v10 == -32734 || v10 == -32704 )
    sub_10047190(a4);
  if ( (unsigned __int16)*a5 != 32802 )
  {
    if ( (unsigned __int16)*a5 == 32832 )
    {
      sub_1003D230(a1, *(_DWORD *)(a4 + 36), (int)&v12);
      return 2;
    }
    if ( (unsigned __int16)*a5 != 32888 )
      return 1;
  }
  sub_1003D350(a1, *(_DWORD *)(a4 + 36), (int)&v12);
  return 2;
}

//----- (100474B0) --------------------------------------------------------
unsigned int __cdecl sub_100474B0(_BYTE *a1)
{
  return sub_1003F3D0(a1, 0, 10000, 5000, 0);
}

//----- (100474D0) --------------------------------------------------------
int __cdecl sub_100474D0(_BYTE *a1)
{
  return sub_1003F5E0(a1, 0, 0x2710u, 8000, 0);
}

//----- (100474F0) --------------------------------------------------------
int __cdecl sub_100474F0(_BYTE *a1)
{
  return sub_1003F5E0(a1, 0, 0x2710u, 5000, 0);
}

//----- (10047510) --------------------------------------------------------
unsigned int __cdecl sub_10047510(int a1)
{
  unsigned int result; // eax@1

  result = sub_100474F0((_BYTE *)a1);
  if ( !result )
  {
    result = sub_100474B0((_BYTE *)(a1 + 8));
    if ( !result )
    {
      result = sub_100474B0((_BYTE *)(a1 + 12));
      if ( !result )
      {
        result = sub_100474B0((_BYTE *)(a1 + 6));
        if ( !result )
        {
          result = sub_100474B0((_BYTE *)(a1 + 10));
          if ( !result )
          {
            result = sub_100474D0((_BYTE *)(a1 + 2));
            if ( !result )
              result = sub_100474D0((_BYTE *)(a1 + 4));
          }
        }
      }
    }
  }
  return result;
}

//----- (10047580) --------------------------------------------------------
int __cdecl sub_10047580(unsigned __int8 *a1)
{
  return sub_1003F590(a1, 0, 5u, 5u, 0);
}

//----- (100475A0) --------------------------------------------------------
int __cdecl sub_100475A0(unsigned __int8 *a1)
{
  return sub_1003F590(a1, 0, 6u, 0, 0);
}

//----- (100475C0) --------------------------------------------------------
int __cdecl sub_100475C0(unsigned __int8 *a1)
{
  return sub_1003F590(a1, 0, 0xEu, 1u, 0);
}

//----- (100475E0) --------------------------------------------------------
int __cdecl sub_100475E0(unsigned __int8 *a1)
{
  return sub_1003F590(a1, 0, 1u, 0, 0);
}

//----- (10047610) --------------------------------------------------------
int __cdecl sub_10047610(int a1)
{
  int result; // eax@1

  result = sub_10047580((unsigned __int8 *)a1);
  if ( !result )
  {
    result = sub_10047600(a1 + 12);
    if ( !result )
    {
      result = sub_100475E0((unsigned __int8 *)(a1 + 1));
      if ( !result )
        result = sub_100475C0((unsigned __int8 *)(a1 + 2));
    }
  }
  return result;
}
// 10047600: using guessed type _DWORD __cdecl sub_10047600(_DWORD);

//----- (10047650) --------------------------------------------------------
int __cdecl sub_10047650(int a1)
{
  int result; // eax@1

  result = sub_100526D0((void *)(a1 + 28));
  if ( !result )
    result = sub_10047610(a1);
  return result;
}

//----- (10047670) --------------------------------------------------------
char *__cdecl sub_10047670(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = byte_10084570;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (100476C0) --------------------------------------------------------
int sub_100476C0()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_10069690();
  result = 0;
  while ( 1 )
  {
    v3 = dword_106BAA5C[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_106BAA5C[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 106BAA5C: using guessed type int dword_106BAA5C[];

//----- (10047700) --------------------------------------------------------
int __cdecl sub_10047700(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10047770) --------------------------------------------------------
signed int __cdecl sub_10047770(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10047810) --------------------------------------------------------
int __usercall sub_10047810@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_10047770(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10047840) --------------------------------------------------------
signed int __usercall sub_10047840@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_10047770((_BYTE *)a3, (int)(&off_100E15F8)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_100E15FC[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_10070073(a3, (int)"%ld", (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_10070073(a3, (int)"%lu", (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_10070073(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 100E15F8: using guessed type char *off_100E15F8;

//----- (10047A10) --------------------------------------------------------
char *__usercall sub_10047A10@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, word_10088C68, 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (10047A70) --------------------------------------------------------
int __usercall sub_10047A70@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_10047770((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10047B00) --------------------------------------------------------
int __usercall sub_10047B00@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_10047810(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (10047B50) --------------------------------------------------------
char **__usercall sub_10047B50@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_10047670(v6);
      if ( !sub_10047770((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (10047BB0) --------------------------------------------------------
const char *__usercall sub_10047BB0@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (10047BD0) --------------------------------------------------------
int __usercall sub_10047BD0@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_106BAA48[sub_100476C0()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 106BAA48: using guessed type int dword_106BAA48[];

//----- (10047C10) --------------------------------------------------------
int __usercall sub_10047C10@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_10047840(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (10047CA0) --------------------------------------------------------
int __usercall sub_10047CA0@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (10047DF0) --------------------------------------------------------
int __usercall sub_10047DF0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_10049B40(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_100486D0(v3, v6, 0);
        v7 = -*v3;
        sub_10049B40(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_10049B40(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_100E12B0);
      sub_1005F5E0(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_100E12B0);
      sub_10049B40(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (10047E90) --------------------------------------------------------
int __usercall sub_10047E90@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (10047ED0) --------------------------------------------------------
char *__cdecl sub_10047ED0(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_10047A10(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_10047A10(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_10047A10(result, v5, (int)&v20);
      v10 = byte_10084570;
    }
    LOBYTE(v9) = 0;
    sub_10047A10(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_10047A10(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_10047A10(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_10047A10(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_10049AD0(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 10047ED0: using guessed type int var_61C[6];

//----- (10048080) --------------------------------------------------------
int __usercall sub_10048080@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_10047670((char **)a1);
  result = sub_10049B60(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_100E12B0);
  return result;
}

//----- (100480B0) --------------------------------------------------------
int __usercall sub_100480B0@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_100E12B0);
  v2 = (unsigned int)sub_10047670((char **)a1);
  return sub_10049B40(10, v2);
}

//----- (100480E0) --------------------------------------------------------
void __cdecl sub_100480E0(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_10047670(v5);
            v7 = sub_10047670((char **)v3);
            if ( !sub_10047700(v7, (int)v6) )
            {
              v8 = sub_10047670((char **)v3);
              sub_10049C00(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_10047670((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_10047670((char **)v3);
        sub_10049C00(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_10047BB0(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_1004A620("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_10047670((char **)v3);
            sub_10049C40(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_10047700(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_10047BB0(v18);
                  v25 = sub_1004A620("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_10047670((char **)v3);
                  sub_10049C40(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_10047670((char **)v3);
                  sub_10049C40(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_10047670((char **)v3);
              sub_10049C40(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_10047670((char **)v3);
              sub_10049C40(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_10047670((char **)v3);
              sub_10049C40(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_100480E0(*(_DWORD *)(v3 + 8) + v11 + 8, v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_10047670((char **)v3);
            sub_10049C40(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_10047670((char **)v3);
            sub_10049C40(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_10047670((char **)v3);
          sub_10049C40(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_10047670((char **)v3);
        sub_10049C40(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_10047670(a2);
      sub_10049C00(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (10048550) --------------------------------------------------------
int sub_10048550()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_106BAA48[sub_100476C0()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_100480E0(i, 0, &v2);
  }
  return v2;
}
// 106BAA48: using guessed type int dword_106BAA48[];

//----- (100485A0) --------------------------------------------------------
void *sub_100485A0()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_106BAA48[0] = 0;
  dword_106BAA4C = 0;
  dword_106BAA50 = 0;
  dword_106BAA54 = 0;
  dword_106BAA58 = 0;
  result = &unk_106BAA70;
  dword_106BAA5C[0] = -1;
  dword_106BAA60 = -1;
  dword_106BAA64 = -1;
  dword_106BAA68 = -1;
  dword_106BAA6C = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_10047E90((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 106BAA48: using guessed type int dword_106BAA48[];
// 106BAA4C: using guessed type int dword_106BAA4C;
// 106BAA50: using guessed type int dword_106BAA50;
// 106BAA54: using guessed type int dword_106BAA54;
// 106BAA58: using guessed type int dword_106BAA58;
// 106BAA5C: using guessed type int dword_106BAA5C[];
// 106BAA60: using guessed type int dword_106BAA60;
// 106BAA64: using guessed type int dword_106BAA64;
// 106BAA68: using guessed type int dword_106BAA68;
// 106BAA6C: using guessed type int dword_106BAA6C;

//----- (10048600) --------------------------------------------------------
char *sub_10048600()
{
  return (char *)&unk_106BAA70 + 56 * sub_100476C0();
}

//----- (10048620) --------------------------------------------------------
char sub_10048620()
{
  return sub_10048600()[33];
}

//----- (10048630) --------------------------------------------------------
char __cdecl sub_10048630(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_10048600();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_100496C0(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (10048670) --------------------------------------------------------
int *__usercall sub_10048670@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_10048600() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_10047770((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (100486C0) --------------------------------------------------------
char **sub_100486C0()
{
  return &off_100E1660;
}
// 100E1660: using guessed type char *off_100E1660;

//----- (100486D0) --------------------------------------------------------
int __cdecl sub_100486D0(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_1004E890();
  v3 = sub_10048600();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_10048550();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_10048080(a2);
    if ( a3 )
    {
      v7 = sub_10047DF0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_10047DF0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_100480B0(a2);
        return v7;
      }
    }
    sub_100480B0(a2);
    result = v7;
  }
  return result;
}

//----- (10048780) --------------------------------------------------------
int __cdecl sub_10048780(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_10047A10(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_10047A10(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_10047A10(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_10049AD0(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_10047A10(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_10047A10(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_10047A10(v14, "group-begin", (int)&v29);
          sub_10049AD0(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_10047670(v15);
          sub_10048780(v16[2], v16[3], v16[4], v17, a4);
          sub_10047670(v16);
          v18 = sub_10047ED0((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_10047A10(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_10047A10(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_10047A10(v20, "group-end", (int)&v29);
          result = sub_10049AD0(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_10047A10(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_10047A10(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_10047A10(v21, a4, (int)&v28);
          v23 = byte_10084570;
        }
        LOBYTE(v22) = 0;
        v24 = sub_10047A10(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_10047A10(v24, *(const char **)v5, (int)&v30);
        result = sub_10049AD0(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 10048780: using guessed type int var_414[4];

//----- (10048990) --------------------------------------------------------
char *__usercall sub_10048990@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_10047A10(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_10047A10(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_10049AD0(2, (int)v11, 2);
  if ( a6 )
  {
    sub_10048780(a3, (int)a4, a5, a2, 0);
    result = sub_10047ED0(a3, a4, a5, 0);
  }
  return result;
}
// 10048990: using guessed type int var_20C[2];

//----- (10048A50) --------------------------------------------------------
char *__cdecl sub_10048A50(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_106BAA48[sub_100476C0()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_10047670((char **)v2);
    sub_10048990("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_10048600() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_10048990(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 106BAA48: using guessed type int dword_106BAA48[];

//----- (10048AF0) --------------------------------------------------------
int *__cdecl sub_10048AF0(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_106BAA48[sub_100476C0()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_10047670(v2);
      if ( !sub_10047770(a1, (int)v4) )
      {
        v5 = sub_10047670(v3);
        sub_10048990("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_10048600();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_10047770(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_10048990(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 106BAA48: using guessed type int dword_106BAA48[];

//----- (10048BB0) --------------------------------------------------------
int __usercall sub_10048BB0@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_10047BD0(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_100486D0((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_10047BD0(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_100486D0((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_10048080(v5);
        sub_10047DF0(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_100480B0(v8);
          v10 = sub_10047BD0(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (10048D10) --------------------------------------------------------
signed int __usercall sub_10048D10@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_106BAA48[sub_100476C0()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_100486D0((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 106BAA48: using guessed type int dword_106BAA48[];

//----- (10048D80) --------------------------------------------------------
int __cdecl sub_10048D80(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_10048600();
  switch ( a1 )
  {
    case 9:
      sub_10049B40(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_10047770((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_10047770(v6, (int)"-q") )
            {
              sub_10048AF0(v6);
              v9 = sub_10048550();
              sub_10049B40(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_10048A50(0);
              v8 = sub_10048550();
              sub_10049B40(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_10048A50(1);
            v7 = sub_10048550();
            sub_10049B40(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_10049BC0(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_10049B40(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_10048A50(0);
        v4 = sub_10048550();
        sub_10049B40(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_10049B40(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_106BAA48[sub_100476C0()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_10048D80 )
              v12(2, (int)&unk_100E12B0);
          }
        }
      }
      sub_1004E890();
      v3[34] = 0;
      return 0;
    case 3:
      sub_10049B40(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_106BAA48[sub_100476C0()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_10049BC0(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_10048BB0((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_10049BC0(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_10048D10((int)v3);
    case 14:
      exit_1(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_10049BC0(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_10048D80 )
          v15(3, (int)&unk_100E12B0);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 10048D80: using guessed type int __cdecl sub_10048D80(int, int);
// 106BAA48: using guessed type int dword_106BAA48[];

//----- (10049060) --------------------------------------------------------
char **sub_10049060()
{
  return off_100E1454;
}
// 100E1454: using guessed type char *off_100E1454[3];

//----- (10049070) --------------------------------------------------------
int __usercall sub_10049070@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_10047B00(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_10047C10(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_10049060();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (10049160) --------------------------------------------------------
int __cdecl sub_10049160(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_10048600();
  *a1 = 0;
  v4 = sub_1004A620("Processing command '%s'", v2);
  sub_10049BC0(3, (int)&unk_100E1DF0, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_10047CA0(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_10048BB0((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_10048D10((int)v3);
    v11 = 0;
    v6 = sub_100476C0();
    v7 = sub_10047B50((int (**)(void))dword_106BAA48[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_10047A70((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_10047A70((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_100486D0(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_100486D0(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_10049070(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_10048670(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_10049070(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_10049060();
        result = sub_10049070(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 106BAA48: using guessed type int dword_106BAA48[];
// 10049160: using guessed type char var_2D4[720];

//----- (100493A0) --------------------------------------------------------
int sub_100493A0()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_10049160(&v4);
  if ( !sub_10048600()[32] )
    sub_10049B40(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_1004A620("%s %i, %s", "Command status:", v0, &v4);
    sub_10049BC0(3, (int)&unk_100E1DF0, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_1004A620("%s %i", "Command status:", v0);
    sub_10049BC0(3, (int)&unk_100E1DF0, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (10049480) --------------------------------------------------------
int __cdecl sub_10049480(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_106BAA48[sub_100476C0()] = a1;
  sub_10048600()[32] = a3;
  sub_1004E890();
  sub_1005F7F0(a2);
  v3 = sub_100486C0();
  sub_100495B0(v3);
  return sub_100493A0();
}
// 106BAA48: using guessed type int dword_106BAA48[];

//----- (100494D0) --------------------------------------------------------
int __cdecl sub_100494D0(int a1)
{
  return a1 + 9;
}

//----- (100494E0) --------------------------------------------------------
int __cdecl sub_100494E0(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_10069690();
  memset(a1, 0, 0xDCu);
  sub_10036790((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_100494D0(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_1005F980((int)a1, (int)v3);
}

//----- (10049560) --------------------------------------------------------
int __cdecl sub_10049560(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_1005FB90(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (10049590) --------------------------------------------------------
signed int __cdecl sub_10049590(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_1006CA30(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_10069700();
    }
    else if ( v6 != -57 || (unsigned int)(sub_10069700() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_1005F980(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (100495B0) --------------------------------------------------------
char __cdecl sub_100495B0(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_10048600() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_1005F630("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_100493A0() )
          v7 = 0;
      }
      v5 = sub_1005F630("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_100493A0() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (100496C0) --------------------------------------------------------
char __cdecl sub_100496C0(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (100496F0) --------------------------------------------------------
bool __cdecl sub_100496F0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (10049720) --------------------------------------------------------
bool __cdecl sub_10049720(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (10049750) --------------------------------------------------------
bool __cdecl sub_10049750(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (10049780) --------------------------------------------------------
bool __cdecl sub_10049780(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (100497B0) --------------------------------------------------------
bool __cdecl sub_100497B0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (100497E0) --------------------------------------------------------
bool __cdecl sub_100497E0(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (10049820) --------------------------------------------------------
bool __cdecl sub_10049820(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (10049860) --------------------------------------------------------
bool __cdecl sub_10049860(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (10049890) --------------------------------------------------------
bool __cdecl sub_10049890(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (100498C0) --------------------------------------------------------
char __cdecl sub_100498C0(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (100498F0) --------------------------------------------------------
bool __cdecl sub_100498F0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (10049920) --------------------------------------------------------
bool __cdecl sub_10049920(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (10049950) --------------------------------------------------------
bool __cdecl sub_10049950(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (10049980) --------------------------------------------------------
bool __cdecl sub_10049980(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (100499B0) --------------------------------------------------------
bool __cdecl sub_100499B0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_100E1DF0, 9u);
}

//----- (100499E0) --------------------------------------------------------
bool __cdecl sub_100499E0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (10049A10) --------------------------------------------------------
bool __cdecl sub_10049A10(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (10049A40) --------------------------------------------------------
bool __cdecl sub_10049A40(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (10049A70) --------------------------------------------------------
bool __cdecl sub_10049A70(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (10049AA0) --------------------------------------------------------
bool __cdecl sub_10049AA0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (10049AD0) --------------------------------------------------------
int __cdecl sub_10049AD0(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_10048600() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (10049B40) --------------------------------------------------------
int __cdecl sub_10049B40(int a1, char a2)
{
  return sub_10049AD0(a1, (int)&a2, 1);
}

//----- (10049B60) --------------------------------------------------------
int __cdecl sub_10049B60(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_10049AD0(a1, (int)&v4, 2);
}

//----- (10049B90) --------------------------------------------------------
int __cdecl sub_10049B90(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_10049AD0(a1, (int)&v5, 3);
}

//----- (10049BC0) --------------------------------------------------------
int __cdecl sub_10049BC0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_10049AD0(a1, (int)&v6, 4);
}

//----- (10049C00) --------------------------------------------------------
int __cdecl sub_10049C00(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_10049AD0(a1, (int)&v7, 5);
}

//----- (10049C40) --------------------------------------------------------
int __cdecl sub_10049C40(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_10049AD0(a1, (int)&v8, 6);
}

//----- (10049C90) --------------------------------------------------------
char __cdecl sub_10049C90(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_10048600();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (10049CC0) --------------------------------------------------------
char __cdecl sub_10049CC0(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (10049CD0) --------------------------------------------------------
char __cdecl sub_10049CD0(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  __int16 *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = &word_10092290, v3) )
          v11 = (__int16 *)byte_10084570;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_1005FCB0(v16) )
        sub_1005FC90((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_1005FCC0((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 1005FCB0: using guessed type _DWORD __cdecl sub_1005FCB0(_DWORD);
// 10092290: using guessed type __int16 word_10092290;
// 10049CD0: using guessed type char var_104[255];

//----- (10049E50) --------------------------------------------------------
signed int __cdecl sub_10049E50(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (10049E90) --------------------------------------------------------
signed int __cdecl sub_10049E90(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (10049F30) --------------------------------------------------------
char __cdecl sub_10049F30(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (10049F90) --------------------------------------------------------
char __cdecl sub_10049F90(int a1, void (__cdecl *a2)(int))
{
  char result; // al@6

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( a2 )
      a2(a1);
    sub_1005FC70(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return result;
}

//----- (1004A000) --------------------------------------------------------
char *__cdecl sub_1004A000(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_106BAB88, v1, v2);
  *(&byte_106BAB88 + v2) = 0;
  return &byte_106BAB88;
}

//----- (1004A0A0) --------------------------------------------------------
int __cdecl sub_1004A0A0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1004A110) --------------------------------------------------------
bool __cdecl sub_1004A110(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_10070073(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_10070073(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (1004A1A0) --------------------------------------------------------
char __cdecl sub_1004A1A0(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (1004A250) --------------------------------------------------------
char __cdecl sub_1004A250(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (1004A260) --------------------------------------------------------
char __cdecl sub_1004A260(int a1, void (__cdecl *a2)(int))
{
  char v2; // bl@1

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 324) > 0 || *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    v2 = 1;
    if ( a2 )
      a2(a1);
  }
  if ( *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    sub_1005FC70(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    v2 = 1;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return v2;
}

//----- (1004A2E0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004A2E0(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_1005FD40((int)a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}

//----- (1004A330) --------------------------------------------------------
signed int __cdecl sub_1004A330(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@1

  sub_1004A260(a1, a2);
  result = 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1004A380) --------------------------------------------------------
char *__cdecl sub_1004A380(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  __int16 *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_1005F630("CFG_ActDir", (int)byte_10084570);
      v10 = sub_1005F630("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_1005F630("CFG_ExpDir", (int)byte_10084570);
      v10 = sub_1005F630("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_1005F630("CFG_ActDir", (int)byte_10084570);
      break;
    case 4:
      v10 = sub_1005F630("CFG_ExpDir", (int)byte_10084570);
      break;
    default:
      v10 = byte_10084570;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = &word_10092290, v14) )
    v15 = (__int16 *)byte_10084570;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 10092290: using guessed type __int16 word_10092290;
// 1004A380: using guessed type char var_104[256];

//----- (1004A500) --------------------------------------------------------
int sub_1004A500()
{
  return dword_106BF878[sub_100476C0()];
}
// 106BF878: using guessed type int dword_106BF878[];

//----- (1004A510) --------------------------------------------------------
const char *__cdecl sub_1004A510(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_100E2018[a1];
  return result;
}
// 100E2018: using guessed type char *off_100E2018[7];

//----- (1004A530) --------------------------------------------------------
int __cdecl sub_1004A530(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_10049C00(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (1004A5E0) --------------------------------------------------------
int __cdecl sub_1004A5E0(int a1)
{
  int result; // eax@1

  result = sub_100476C0();
  dword_106C1984[result] = a1;
  return result;
}
// 106C1984: using guessed type int dword_106C1984[];

//----- (1004A600) --------------------------------------------------------
int __cdecl sub_1004A600(int a1)
{
  int result; // eax@1

  result = sub_100476C0();
  dword_106BF878[result] = a1;
  return result;
}
// 106BF878: using guessed type int dword_106BF878[];

//----- (1004A620) --------------------------------------------------------
char *sub_1004A620(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_100476C0() << 8;
  _vsnprintf(&byte_106BAC88[v1], 0x100u, a1, va);
  result = &byte_106BAC88[v1];
  byte_106BAD86[v1] = 42;
  byte_106BAD87[v1] = 0;
  return result;
}

//----- (1004A660) --------------------------------------------------------
char *__usercall sub_1004A660@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_100E202C[a1 & 1];
  else
    result = off_100E2024[a2];
  return result;
}
// 100E2024: using guessed type char *off_100E2024[4];
// 100E202C: using guessed type char *off_100E202C[2];

//----- (1004A680) --------------------------------------------------------
char __usercall sub_1004A680@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  const char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_100476C0();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_1004A500() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_106C2F78[v6];
      v12 = dword_106C2F8C[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_106BF88C[v6];
      v12 = dword_106C1970[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 106BF88C: using guessed type int dword_106BF88C[];
// 106C1970: using guessed type int dword_106C1970[];
// 106C2F78: using guessed type int dword_106C2F78[];
// 106C2F8C: using guessed type int dword_106C2F8C[];

//----- (1004A860) --------------------------------------------------------
int sub_1004A860()
{
  nullsub_1("..\\lib\\utf\\utf_verify.c", "2370");
  return 0;
}

//----- (1004A880) --------------------------------------------------------
int sub_1004A880()
{
  return nullsub_1("..\\lib\\utf\\utf_verify.c", "2396");
}

//----- (1004A8A0) --------------------------------------------------------
int __cdecl sub_1004A8A0(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_100476C0();
  dword_106C1970[result] = a1;
  if ( a2 >= 0 )
  {
    dword_106BF88C[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_1004A620(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_10049BC0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_106BF88C[result] = 8;
  }
  return result;
}
// 106BF88C: using guessed type int dword_106BF88C[];
// 106C1970: using guessed type int dword_106C1970[];

//----- (1004A900) --------------------------------------------------------
int __cdecl sub_1004A900(int a1)
{
  return sub_1004A8A0(0, a1);
}

//----- (1004A910) --------------------------------------------------------
int __cdecl sub_1004A910(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_100476C0();
  dword_106C2F8C[result] = a1;
  if ( a2 >= 0 )
  {
    dword_106C2F78[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_1004A620(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_10049BC0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_106C2F78[result] = 8;
  }
  return result;
}
// 106C2F78: using guessed type int dword_106C2F78[];
// 106C2F8C: using guessed type int dword_106C2F8C[];

//----- (1004A970) --------------------------------------------------------
int __cdecl sub_1004A970(int a1)
{
  return sub_1004A910(0, a1);
}

//----- (1004A980) --------------------------------------------------------
bool __cdecl sub_1004A980(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_10048620() )
    v8 = v8 == 0;
  v9 = (&off_100E1FFC)[4 * a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_100E1FEC[v8 != 0];
  v19 = off_100E1FF4[a1];
  v18 = v10;
  v21 = sub_1004A660(0, a6);
  v22 = sub_1004A660(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_1005FF20();
  sub_10049AD0(7, (int)&v14, v11);
  sub_1005FF30(v12);
  return v8;
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;

//----- (1004AAC0) --------------------------------------------------------
bool __cdecl sub_1004AAC0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  unsigned __int8 v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  bool v16; // [sp+1Bh] [bp-5Dh]@2
  char v17; // [sp+1Fh] [bp-59h]@25
  unsigned int v18; // [sp+20h] [bp-58h]@1
  char *v19; // [sp+3Ch] [bp-3Ch]@28
  int v20; // [sp+40h] [bp-38h]@28
  int v21; // [sp+44h] [bp-34h]@28
  int v22; // [sp+48h] [bp-30h]@28
  char *v23; // [sp+4Ch] [bp-2Ch]@28
  char *v24; // [sp+50h] [bp-28h]@28
  const char *v25; // [sp+54h] [bp-24h]@28
  const char *v26; // [sp+58h] [bp-20h]@28
  const char *v27; // [sp+5Ch] [bp-1Ch]@28
  char *v28; // [sp+60h] [bp-18h]@28
  int v29; // [sp+64h] [bp-14h]@29
  char v30; // [sp+68h] [bp-10h]@25

  v8 = sub_100476C0();
  v18 = 9;
  switch ( a2 )
  {
    case 0:
      v16 = a6 == a7;
      break;
    case 1:
      v16 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 4:
      v16 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_38;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v16 = 1;
      if ( a6 > v10 )
LABEL_38:
        v16 = 0;
      v18 = 10;
      break;
    default:
LABEL_22:
      v16 = 0;
      break;
  }
  if ( sub_10048620() )
    v16 = v16 == 0;
  sub_1004A680((int)&v30, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_106BBC78[v11], 0x400u, &v30, a6);
  byte_106BC076[v11] = 42;
  byte_106BC077[v11] = 0;
  v17 = sub_1004A680((int)&v30, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_106BC078[v11], 0x400u, &v30, a7);
  byte_106BC476[v11] = 42;
  byte_106BC477[v11] = 0;
  if ( v18 <= 9 )
  {
    v12 = &byte_106BC478[v11];
    byte_106BC478[v11] = 0;
  }
  else
  {
    v17 = sub_1004A680((int)&v30, "%c", 3, 0xCu, 0.0);
    v12 = &byte_106BC478[v11];
    _snprintf(&byte_106BC478[v11], 0x400u, &v30, 0);
    byte_106BC876[v11] = 42;
    byte_106BC877[v11] = 0;
  }
  v19 = (&off_100E1FFC)[4 * a2];
  v21 = a4;
  v22 = a5;
  v20 = a3;
  v25 = "char";
  v26 = &byte_106BBC78[v11];
  v27 = &byte_106BC078[v11];
  v13 = off_100E1FF4[a1];
  v23 = off_100E1FEC[v16 != 0];
  v24 = v13;
  v28 = v12;
  if ( a8 )
  {
    v29 = a8;
    v18 = 11;
  }
  v14 = sub_1005FF20();
  sub_10049AD0(7, (int)&v19, v18);
  if ( v17 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 && !strcmp(v26, v27) )
  {
    nullsub_1(a3, a4);
    sub_10049BC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005FF30(v14);
  return v16;
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;

//----- (1004AE70) --------------------------------------------------------
bool __cdecl sub_1004AE70(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  bool v20; // [sp+27h] [bp-61h]@10
  char v21; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v22; // [sp+2Ch] [bp-5Ch]@8
  char *v23; // [sp+4Ch] [bp-3Ch]@37
  int v24; // [sp+50h] [bp-38h]@37
  int v25; // [sp+54h] [bp-34h]@37
  int v26; // [sp+58h] [bp-30h]@37
  char *v27; // [sp+5Ch] [bp-2Ch]@37
  char *v28; // [sp+60h] [bp-28h]@37
  const char *v29; // [sp+64h] [bp-24h]@37
  const char *v30; // [sp+68h] [bp-20h]@37
  const char *v31; // [sp+6Ch] [bp-1Ch]@37
  char *v32; // [sp+70h] [bp-18h]@37
  int v33; // [sp+74h] [bp-14h]@38
  char v34; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_100476C0();
  v22 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 1:
      v20 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v20 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_47;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_47:
        v20 = 0;
        v22 = 10;
      }
      else
      {
        v20 = 1;
        v22 = 10;
      }
      break;
    default:
LABEL_18:
      v20 = 0;
      break;
  }
  if ( sub_10048620() )
    v20 = v20 == 0;
  sub_1004A680((int)&v34, (char *)&unk_100E22E0, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_106BBC78[v12], 0x400u, &v34);
  byte_106BC076[v12] = 42;
  byte_106BC077[v12] = 0;
  v21 = sub_1004A680((int)&v34, (char *)&unk_100E22E0, 3, 0xCu, a7);
  _snprintf(&byte_106BC078[v12], 0x400u, &v34, a7);
  byte_106BC476[v12] = 42;
  byte_106BC477[v12] = 0;
  if ( v22 <= 9 )
  {
    v13 = &byte_106BC478[v12];
    byte_106BC478[v12] = 0;
  }
  else
  {
    v13 = &byte_106BC478[v12];
    v21 = sub_1004A680((int)&v34, (char *)&unk_100E22E0, 3, 0xCu, v10);
    _snprintf(&byte_106BC478[v12], 0x400u, &v34, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_106BC876[v12] = 42;
    byte_106BC877[v12] = 0;
  }
  v23 = (&off_100E1FFC)[4 * a2];
  v26 = a5;
  v25 = a4;
  v24 = a3;
  v29 = "double";
  v30 = &byte_106BBC78[v12];
  v32 = v13;
  v17 = off_100E1FF4[a1];
  v27 = off_100E1FEC[v20 != 0];
  v28 = v17;
  v31 = &byte_106BC078[v12];
  if ( a9 )
  {
    v33 = a9;
    v22 = 11;
  }
  v18 = sub_1005FF20();
  sub_10049AD0(7, (int)&v23, v22);
  if ( v21 && a6 != a7 && fabs(a6 - a7) > v10 && !strcmp(v30, v31) )
  {
    nullsub_1(a3, a4);
    sub_10049BC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005FF30(v18);
  return v20;
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;

//----- (1004B2C0) --------------------------------------------------------
bool __cdecl sub_1004B2C0(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  bool v25; // [sp+1Bh] [bp-59h]@10
  char v26; // [sp+1Fh] [bp-55h]@35
  unsigned int v27; // [sp+20h] [bp-54h]@8
  float v28; // [sp+24h] [bp-50h]@8
  char *v29; // [sp+38h] [bp-3Ch]@38
  int v30; // [sp+3Ch] [bp-38h]@38
  int v31; // [sp+40h] [bp-34h]@38
  int v32; // [sp+44h] [bp-30h]@38
  char *v33; // [sp+48h] [bp-2Ch]@38
  char *v34; // [sp+4Ch] [bp-28h]@38
  const char *v35; // [sp+50h] [bp-24h]@38
  const char *v36; // [sp+54h] [bp-20h]@38
  const char *v37; // [sp+58h] [bp-1Ch]@38
  char *v38; // [sp+5Ch] [bp-18h]@38
  int v39; // [sp+60h] [bp-14h]@39
  char v40; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v28 = v13;
  v14 = v28;
  v15 = a6;
  v16 = sub_100476C0();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_48;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_48:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_32:
      v25 = 0;
      break;
  }
  if ( sub_10048620() )
    v25 = v25 == 0;
  sub_1004A680((int)&v40, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_106BBC78[v20], 0x400u, &v40);
  byte_106BC076[v20] = 42;
  byte_106BC077[v20] = 0;
  v26 = sub_1004A680((int)&v40, "%f", 3, 0xCu, a7);
  _snprintf(&byte_106BC078[v20], 0x400u, &v40, a7);
  byte_106BC476[v20] = 42;
  byte_106BC477[v20] = 0;
  if ( v27 <= 9 )
  {
    v21 = &byte_106BC478[v20];
    byte_106BC478[v20] = 0;
  }
  else
  {
    v21 = &byte_106BC478[v20];
    v26 = sub_1004A680((int)&v40, "%f", 3, 0xCu, v28);
    _snprintf(&byte_106BC478[v20], 0x400u, &v40, v28);
    byte_106BC876[v20] = 42;
    byte_106BC877[v20] = 0;
  }
  v29 = (&off_100E1FFC)[4 * a2];
  v32 = a5;
  v31 = a4;
  v30 = a3;
  v35 = "float";
  v36 = &byte_106BBC78[v20];
  v37 = &byte_106BC078[v20];
  v38 = v21;
  v22 = off_100E1FEC[v25 != 0];
  v34 = off_100E1FF4[a1];
  v33 = v22;
  if ( a9 )
  {
    v39 = a9;
    v27 = 11;
  }
  v23 = sub_1005FF20();
  sub_10049AD0(7, (int)&v29, v27);
  if ( v26 && a7 != a6 && v28 < fabs(a6 - a7) && !strcmp(v36, v37) )
  {
    nullsub_1(a3, a4);
    sub_10049BC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005FF30(v23);
  return v25;
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;

//----- (1004B780) --------------------------------------------------------
bool __cdecl sub_1004B780(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  void *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_100476C0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10048620() )
    v17 = v17 == 0;
  sub_1004A680((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106BBC78[v12], 0x400u, &v31, a6);
  byte_106BC076[v12] = 42;
  byte_106BC077[v12] = 0;
  v18 = sub_1004A680((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_106BC078[v12], 0x400u, &v31, a7);
  byte_106BC476[v12] = 42;
  byte_106BC477[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106BC478[v12];
    byte_106BC478[v12] = 0;
  }
  else
  {
    v18 = sub_1004A680((int)&v31, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_106BC478[v12];
    _snprintf(&byte_106BC478[v12], 0x400u, &v31, a8);
    byte_106BC876[v12] = 42;
    byte_106BC877[v12] = 0;
  }
  v20 = (&off_100E1FFC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = &unk_100E2314;
  v27 = &byte_106BBC78[v12];
  v28 = &byte_106BC078[v12];
  v29 = v13;
  v14 = off_100E1FEC[v17 != 0];
  v25 = off_100E1FF4[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005FF20();
  sub_10049AD0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049BC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005FF30(v15);
  return v17;
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;

//----- (1004BB40) --------------------------------------------------------
bool __cdecl sub_1004BB40(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100476C0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_37;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v17 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10048620() )
    v17 = v17 == 0;
  sub_1004A680((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106BBC78[v12], 0x400u, &v31, a6);
  byte_106BC076[v12] = 42;
  byte_106BC077[v12] = 0;
  v18 = sub_1004A680((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_106BC078[v12], 0x400u, &v31, a7);
  byte_106BC476[v12] = 42;
  byte_106BC477[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106BC478[v12];
    byte_106BC478[v12] = 0;
  }
  else
  {
    v13 = &byte_106BC478[v12];
    v18 = sub_1004A680((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_106BC478[v12], 0x400u, &v31, a8);
    byte_106BC876[v12] = 42;
    byte_106BC877[v12] = 0;
  }
  v20 = (&off_100E1FFC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_106BBC78[v12];
  v21 = a3;
  v26 = "sint16";
  v28 = &byte_106BC078[v12];
  v29 = v13;
  v14 = off_100E1FF4[a1];
  v24 = off_100E1FEC[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005FF20();
  sub_10049AD0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049BC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005FF30(v15);
  return v17;
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;

//----- (1004BF40) --------------------------------------------------------
bool __cdecl sub_1004BF40(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_100476C0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10048620() )
    v17 = v17 == 0;
  sub_1004A680((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106BBC78[v12], 0x400u, &v31, a6);
  byte_106BC076[v12] = 42;
  byte_106BC077[v12] = 0;
  v18 = sub_1004A680((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_106BC078[v12], 0x400u, &v31, a7);
  byte_106BC476[v12] = 42;
  byte_106BC477[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106BC478[v12];
    byte_106BC478[v12] = 0;
  }
  else
  {
    v18 = sub_1004A680((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_106BC478[v12];
    _snprintf(&byte_106BC478[v12], 0x400u, &v31, a8);
    byte_106BC876[v12] = 42;
    byte_106BC877[v12] = 0;
  }
  v20 = (&off_100E1FFC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "sint32";
  v27 = &byte_106BBC78[v12];
  v28 = &byte_106BC078[v12];
  v29 = v13;
  v14 = off_100E1FEC[v17 != 0];
  v25 = off_100E1FF4[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005FF20();
  sub_10049AD0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049BC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005FF30(v15);
  return v17;
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;

//----- (1004C300) --------------------------------------------------------
bool __cdecl sub_1004C300(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  bool v18; // [sp+1Bh] [bp-5Dh]@3
  char v19; // [sp+1Fh] [bp-59h]@37
  unsigned int v20; // [sp+20h] [bp-58h]@1
  int v21; // [sp+30h] [bp-48h]@1
  char *v22; // [sp+3Ch] [bp-3Ch]@40
  int v23; // [sp+40h] [bp-38h]@40
  int v24; // [sp+44h] [bp-34h]@40
  int v25; // [sp+48h] [bp-30h]@40
  char *v26; // [sp+4Ch] [bp-2Ch]@40
  char *v27; // [sp+50h] [bp-28h]@40
  const char *v28; // [sp+54h] [bp-24h]@40
  const char *v29; // [sp+58h] [bp-20h]@40
  const char *v30; // [sp+5Ch] [bp-1Ch]@40
  char *v31; // [sp+60h] [bp-18h]@40
  int v32; // [sp+64h] [bp-14h]@41
  char v33; // [sp+68h] [bp-10h]@37

  v21 = sub_100476C0();
  v20 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 1:
      v18 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v18 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v18 = 0;
      }
      else
      {
        v18 = 1;
      }
LABEL_35:
      if ( sub_10048620() )
        v18 = v18 == 0;
      sub_1004A680((int)&v33, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v21;
      _snprintf(&byte_106BBC78[3072 * v21], 0x400u, &v33, a6);
      byte_106BC076[v13] = 42;
      byte_106BC077[v13] = 0;
      v19 = sub_1004A680((int)&v33, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_106BC078[3072 * v21], 0x400u, &v33, a7);
      byte_106BC476[v13] = 42;
      byte_106BC477[v13] = 0;
      if ( v20 <= 9 )
      {
        v14 = &byte_106BC478[v13];
        byte_106BC478[v13] = 0;
      }
      else
      {
        v19 = sub_1004A680((int)&v33, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_106BC478[v13];
        _snprintf(&byte_106BC478[v13], 0x400u, &v33, a8);
        byte_106BC876[v13] = 42;
        byte_106BC877[v13] = 0;
      }
      v22 = (&off_100E1FFC)[4 * a2];
      v24 = a4;
      v25 = a5;
      v23 = a3;
      v28 = "sint64";
      v29 = &byte_106BBC78[3072 * v21];
      v30 = &byte_106BC078[3072 * v21];
      v15 = off_100E1FF4[a1];
      v26 = off_100E1FEC[v18 != 0];
      v27 = v15;
      v31 = v14;
      if ( a9 )
      {
        v32 = a9;
        v20 = 11;
      }
      v16 = sub_1005FF20();
      sub_10049AD0(7, (int)&v22, v20);
      if ( v19 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v29, v30) )
      {
        nullsub_1(a3, a4);
        sub_10049BC0(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_1005FF30(v16);
      return v18;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v18 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_50;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_50:
        v18 = 0;
        v20 = 10;
      }
      else
      {
        v18 = 1;
        v20 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;

//----- (1004C840) --------------------------------------------------------
bool __cdecl sub_1004C840(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100476C0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_37;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v17 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10048620() )
    v17 = v17 == 0;
  sub_1004A680((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106BBC78[v12], 0x400u, &v31, a6);
  byte_106BC076[v12] = 42;
  byte_106BC077[v12] = 0;
  v18 = sub_1004A680((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_106BC078[v12], 0x400u, &v31, a7);
  byte_106BC476[v12] = 42;
  byte_106BC477[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106BC478[v12];
    byte_106BC478[v12] = 0;
  }
  else
  {
    v13 = &byte_106BC478[v12];
    v18 = sub_1004A680((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_106BC478[v12], 0x400u, &v31, a8);
    byte_106BC876[v12] = 42;
    byte_106BC877[v12] = 0;
  }
  v20 = (&off_100E1FFC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_106BBC78[v12];
  v21 = a3;
  v26 = "sint8";
  v28 = &byte_106BC078[v12];
  v29 = v13;
  v14 = off_100E1FF4[a1];
  v24 = off_100E1FEC[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005FF20();
  sub_10049AD0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049BC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005FF30(v15);
  return v17;
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;

//----- (1004CC20) --------------------------------------------------------
bool __cdecl sub_1004CC20(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_100476C0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10048620() )
    v17 = v17 == 0;
  sub_1004A680((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106BBC78[v12], 0x400u, &v31, a6);
  byte_106BC076[v12] = 42;
  byte_106BC077[v12] = 0;
  v18 = sub_1004A680((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_106BC078[v12], 0x400u, &v31, a7);
  byte_106BC476[v12] = 42;
  byte_106BC477[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106BC478[v12];
    byte_106BC478[v12] = 0;
  }
  else
  {
    v18 = sub_1004A680((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_106BC478[v12];
    _snprintf(&byte_106BC478[v12], 0x400u, &v31, a8);
    byte_106BC876[v12] = 42;
    byte_106BC877[v12] = 0;
  }
  v20 = (&off_100E1FFC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "long int";
  v27 = &byte_106BBC78[v12];
  v28 = &byte_106BC078[v12];
  v29 = v13;
  v14 = off_100E1FEC[v17 != 0];
  v25 = off_100E1FF4[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005FF20();
  sub_10049AD0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049BC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005FF30(v15);
  return v17;
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;

//----- (1004CFE0) --------------------------------------------------------
bool __cdecl sub_1004CFE0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100476C0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10048620() )
    v17 = v17 == 0;
  sub_1004A680((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106BBC78[v12], 0x400u, &v31, a6);
  byte_106BC076[v12] = 42;
  byte_106BC077[v12] = 0;
  v18 = sub_1004A680((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_106BC078[v12], 0x400u, &v31, a7);
  byte_106BC476[v12] = 42;
  byte_106BC477[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106BC478[v12];
    byte_106BC478[v12] = 0;
  }
  else
  {
    v18 = sub_1004A680((int)&v31, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_106BC478[v12];
    _snprintf(&byte_106BC478[v12], 0x400u, &v31, a8);
    byte_106BC876[v12] = 42;
    byte_106BC877[v12] = 0;
  }
  v20 = (&off_100E1FFC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned int";
  v29 = v13;
  v14 = off_100E1FEC[v17 != 0];
  v25 = off_100E1FF4[a1];
  v24 = v14;
  v27 = &byte_106BBC78[v12];
  v28 = &byte_106BC078[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005FF20();
  sub_10049AD0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049BC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005FF30(v15);
  return v17;
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;

//----- (1004D380) --------------------------------------------------------
bool __cdecl sub_1004D380(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100476C0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_37;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10048620() )
    v17 = v17 == 0;
  sub_1004A680((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106BBC78[v12], 0x400u, &v31, a6);
  byte_106BC076[v12] = 42;
  byte_106BC077[v12] = 0;
  v18 = sub_1004A680((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_106BC078[v12], 0x400u, &v31, a7);
  byte_106BC476[v12] = 42;
  byte_106BC477[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106BC478[v12];
    byte_106BC478[v12] = 0;
  }
  else
  {
    v13 = &byte_106BC478[v12];
    v18 = sub_1004A680((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_106BC478[v12], 0x400u, &v31, a8);
    byte_106BC876[v12] = 42;
    byte_106BC877[v12] = 0;
  }
  v20 = (&off_100E1FFC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_106BBC78[v12];
  v21 = a3;
  v26 = "uint16";
  v28 = &byte_106BC078[v12];
  v29 = v13;
  v14 = off_100E1FF4[a1];
  v24 = off_100E1FEC[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005FF20();
  sub_10049AD0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049BC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005FF30(v15);
  return v17;
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;

//----- (1004D780) --------------------------------------------------------
bool __cdecl sub_1004D780(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100476C0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10048620() )
    v17 = v17 == 0;
  sub_1004A680((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106BBC78[v12], 0x400u, &v31, a6);
  byte_106BC076[v12] = 42;
  byte_106BC077[v12] = 0;
  v18 = sub_1004A680((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_106BC078[v12], 0x400u, &v31, a7);
  byte_106BC476[v12] = 42;
  byte_106BC477[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106BC478[v12];
    byte_106BC478[v12] = 0;
  }
  else
  {
    v18 = sub_1004A680((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_106BC478[v12];
    _snprintf(&byte_106BC478[v12], 0x400u, &v31, a8);
    byte_106BC876[v12] = 42;
    byte_106BC877[v12] = 0;
  }
  v20 = (&off_100E1FFC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "uint32";
  v29 = v13;
  v14 = off_100E1FEC[v17 != 0];
  v25 = off_100E1FF4[a1];
  v24 = v14;
  v27 = &byte_106BBC78[v12];
  v28 = &byte_106BC078[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005FF20();
  sub_10049AD0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049BC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005FF30(v15);
  return v17;
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;

//----- (1004DB20) --------------------------------------------------------
bool __cdecl sub_1004DB20(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  bool v19; // [sp+18h] [bp-64h]@3
  char v20; // [sp+27h] [bp-55h]@36
  unsigned int v21; // [sp+28h] [bp-54h]@1
  int v22; // [sp+2Ch] [bp-50h]@1
  char *v23; // [sp+2Ch] [bp-50h]@36
  char *v24; // [sp+40h] [bp-3Ch]@39
  int v25; // [sp+44h] [bp-38h]@39
  int v26; // [sp+48h] [bp-34h]@39
  int v27; // [sp+4Ch] [bp-30h]@39
  char *v28; // [sp+50h] [bp-2Ch]@39
  char *v29; // [sp+54h] [bp-28h]@39
  const char *v30; // [sp+58h] [bp-24h]@39
  const char *v31; // [sp+5Ch] [bp-20h]@39
  const char *v32; // [sp+60h] [bp-1Ch]@39
  char *v33; // [sp+64h] [bp-18h]@39
  int v34; // [sp+68h] [bp-14h]@40
  char v35; // [sp+6Ch] [bp-10h]@36

  v22 = sub_100476C0();
  v21 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 1:
      v19 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v19 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
LABEL_34:
      if ( sub_10048620() )
        v19 = v19 == 0;
      sub_1004A680((int)&v35, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v22;
      v14 = &byte_106BBC78[3072 * v22];
      _snprintf(&byte_106BBC78[3072 * v22], 0x400u, &v35, a6);
      byte_106BC076[v13] = 42;
      byte_106BC077[v13] = 0;
      v20 = sub_1004A680((int)&v35, "%I64u", 6, 0xCu, (double)a7);
      v23 = &byte_106BC078[3072 * v22];
      _snprintf(&byte_106BC078[v13], 0x400u, &v35, a7);
      byte_106BC476[v13] = 42;
      byte_106BC477[v13] = 0;
      if ( v21 <= 9 )
      {
        v15 = &byte_106BC478[v13];
        byte_106BC478[v13] = 0;
      }
      else
      {
        v20 = sub_1004A680((int)&v35, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_106BC478[v13];
        _snprintf(&byte_106BC478[v13], 0x400u, &v35, a8);
        byte_106BC876[v13] = 42;
        byte_106BC877[v13] = 0;
      }
      v24 = (&off_100E1FFC)[4 * a2];
      v27 = a5;
      v26 = a4;
      v33 = v15;
      v25 = a3;
      v30 = "uint64";
      v31 = v14;
      v16 = off_100E1FF4[a1];
      v28 = off_100E1FEC[v19 != 0];
      v29 = v16;
      v32 = v23;
      if ( a9 )
      {
        v34 = a9;
        v21 = 11;
      }
      v17 = sub_1005FF20();
      sub_10049AD0(7, (int)&v24, v21);
      if ( v20 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v31, v32) )
      {
        nullsub_1(a3, a4);
        sub_10049BC0(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_1005FF30(v17);
      return v19;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_49;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_49:
        v19 = 0;
        v21 = 10;
      }
      else
      {
        v19 = 1;
        v21 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;

//----- (1004E100) --------------------------------------------------------
bool __cdecl sub_1004E100(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100476C0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_37;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10048620() )
    v17 = v17 == 0;
  sub_1004A680((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106BBC78[v12], 0x400u, &v31, a6);
  byte_106BC076[v12] = 42;
  byte_106BC077[v12] = 0;
  v18 = sub_1004A680((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_106BC078[v12], 0x400u, &v31, a7);
  byte_106BC476[v12] = 42;
  byte_106BC477[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106BC478[v12];
    byte_106BC478[v12] = 0;
  }
  else
  {
    v13 = &byte_106BC478[v12];
    v18 = sub_1004A680((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_106BC478[v12], 0x400u, &v31, a8);
    byte_106BC876[v12] = 42;
    byte_106BC877[v12] = 0;
  }
  v20 = (&off_100E1FFC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_106BBC78[v12];
  v21 = a3;
  v26 = "uint8";
  v28 = &byte_106BC078[v12];
  v29 = v13;
  v14 = off_100E1FF4[a1];
  v24 = off_100E1FEC[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005FF20();
  sub_10049AD0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049BC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005FF30(v15);
  return v17;
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;

//----- (1004E4F0) --------------------------------------------------------
bool __cdecl sub_1004E4F0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100476C0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10048620() )
    v17 = v17 == 0;
  sub_1004A680((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_106BBC78[v12], 0x400u, &v31, a6);
  byte_106BC076[v12] = 42;
  byte_106BC077[v12] = 0;
  v18 = sub_1004A680((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_106BC078[v12], 0x400u, &v31, a7);
  byte_106BC476[v12] = 42;
  byte_106BC477[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_106BC478[v12];
    byte_106BC478[v12] = 0;
  }
  else
  {
    v18 = sub_1004A680((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_106BC478[v12];
    _snprintf(&byte_106BC478[v12], 0x400u, &v31, a8);
    byte_106BC876[v12] = 42;
    byte_106BC877[v12] = 0;
  }
  v20 = (&off_100E1FFC)[4 * a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned long int";
  v29 = v13;
  v14 = off_100E1FEC[v17 != 0];
  v25 = off_100E1FF4[a1];
  v24 = v14;
  v27 = &byte_106BBC78[v12];
  v28 = &byte_106BC078[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005FF20();
  sub_10049AD0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049BC0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005FF30(v15);
  return v17;
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;

//----- (1004E890) --------------------------------------------------------
int sub_1004E890()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_100476C0();
  sub_1004A5E0(1);
  sub_1004A970(-1);
  result = sub_1004A900(-1);
  dword_106BF878[v0] = 0;
  return result;
}
// 106BF878: using guessed type int dword_106BF878[];

//----- (1004E8C0) --------------------------------------------------------
BOOL __usercall sub_1004E8C0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_100476C0();
  sub_1005FF60((int)&v13);
  sub_1005FF60((int)&v14);
  sub_1005FF60((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_10060BB0((int (__cdecl *)(unsigned int))sub_1004A860, v7, (int)&v13) )
  {
    if ( sub_10060BB0((int (__cdecl *)(unsigned int))sub_1004A860, a2, (int)&v14) )
    {
      v9 = sub_10060A20(
             dword_106C1984[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_1004A860,
             (void (__cdecl *)(_DWORD))sub_1004A880,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_10060E50((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_10060030((void (__cdecl *)(_DWORD))sub_1004A880, (int)&v12);
  sub_10060030((void (__cdecl *)(_DWORD))sub_1004A880, (int)&v13);
  sub_10060030((void (__cdecl *)(_DWORD))sub_1004A880, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 106C1984: using guessed type int dword_106C1984[];

//----- (1004EA30) --------------------------------------------------------
bool __usercall sub_1004EA30@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_100476C0();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_10048620() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_1004CFE0(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_10048620() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_106BBC78[3072 * v24], 0x400u, "%s", v9);
  byte_106BC076[v15] = 42;
  byte_106BC077[v15] = 0;
  _snprintf(&byte_106BC078[3072 * v24], 0x400u, "%s", v22);
  v16 = (&off_100E1FFC)[4 * a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_106BC476[v15] = 42;
  v17 = off_100E1FEC[v14 != 0];
  v18 = off_100E1FF4[a3];
  byte_106BC477[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_106BBC78[3072 * v24];
  v34 = &byte_106BC078[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_1005FF20();
  sub_10049AD0(7, (int)&v26, v19);
  sub_1005FF30(v20);
  return v14;
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;

//----- (1004ECA0) --------------------------------------------------------
char __cdecl sub_1004ECA0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  unsigned int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_100476C0();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_106C1984[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_106C2FA0[v10];
  sub_1004A380(a3, 1, a6, 0x230u, &byte_106C2FA0[v10]);
  v27 = &byte_106BF8A0[v10];
  sub_1004A380(a3, 2, a7, 0x230u, &byte_106BF8A0[v10]);
  v24 = &byte_106C0E80[v10];
  sub_1004A380(a3, 3, a6, 0x230u, &byte_106C0E80[v10]);
  v26 = &byte_106C1998[v10];
  sub_1004A380(a3, 4, a7, 0x230u, &byte_106C1998[v10]);
  _snprintf(&byte_106C2488[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_106C2488[v10];
  byte_106C26B7[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_1004A380(a3, 0, v25, 560 - (v11 - &byte_106C2488[v10 + 1]), &byte_106C2488[v10] + v11 - &byte_106C2488[v10 + 1]);
  v13 = &byte_106C2488[v10];
  byte_106C26B7[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_106C2484[v10] + v13 - &byte_106C2488[v10 + 1]) = 0;
  sub_1004A380(a3, 1, (int)&byte_106C2488[v10], 0x230u, &byte_106BB188[v10]);
  sub_1004A380(a3, 1, (int)&byte_106C2488[v10], 0x230u, &byte_106C0390[v10]);
  v15 = sub_1004E8C0(v22, v27, v21, a2 == 1, (int)&byte_106BB188[v10], (const char **)&v22);
  if ( sub_10048620() )
    v15 = v15 == 0;
  v30 = (&off_100E1FFC)[4 * a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_100E1FF4[a1];
  v34 = off_100E1FEC[v15 != 0];
  v17 = dword_106C1984[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_1005FF20();
  sub_10049AD0(7, (int)&v30, v18);
  sub_1005FF30(v19);
  return v15;
}
// 100E1FEC: using guessed type char *off_100E1FEC[5];
// 100E1FF4: using guessed type char *off_100E1FF4[3];
// 100E1FFC: using guessed type char *off_100E1FFC;
// 106C1984: using guessed type int dword_106C1984[];

//----- (1004EFA0) --------------------------------------------------------
bool __cdecl sub_1004EFA0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_1004B780(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (1004F050) --------------------------------------------------------
bool __cdecl sub_1004F050(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_1004EA30(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (1004F090) --------------------------------------------------------
const char *__cdecl sub_1004F090(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (1004F0D0) --------------------------------------------------------
char __cdecl sub_1004F0D0(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  char *v7; // eax@11
  int v8; // ecx@12
  int v9; // ST44_4@13
  bool v10; // zf@18
  signed int v11; // edx@24
  const char *v12; // eax@32
  _BYTE *v13; // eax@39
  int v14; // eax@44
  bool v15; // sf@44
  char v16; // cl@45
  char *v17; // eax@50
  int v18; // edx@52
  int v19; // edi@53
  unsigned int v20; // eax@53
  const char *v21; // ecx@53
  _DWORD *v22; // edx@53
  int v23; // esi@57
  int v24; // eax@58
  _BYTE *v25; // ecx@58
  _BYTE *v26; // edx@58
  int v27; // eax@60
  _BYTE *v28; // ecx@60
  _BYTE *v29; // edx@60
  _BYTE *v30; // ecx@62
  _BYTE *v31; // edx@62
  signed int v32; // eax@64
  signed int v33; // edi@73
  int v34; // esi@74
  int v35; // ecx@76
  int v36; // edx@82
  int v37; // eax@83
  int *v38; // eax@106
  char *v39; // ebx@106
  char *v40; // edi@109
  char *v41; // esi@112
  const char *v42; // eax@114
  int v43; // ST30_4@123
  const char *v44; // eax@142
  const char *v45; // eax@148
  char *v47; // [sp-14h] [bp-340h]@69
  char v48; // [sp+12h] [bp-31Ah]@24
  char v49; // [sp+13h] [bp-319h]@21
  signed int v50; // [sp+18h] [bp-314h]@52
  char *v51; // [sp+18h] [bp-314h]@94
  char *v52; // [sp+1Ch] [bp-310h]@97
  char *v53; // [sp+20h] [bp-30Ch]@103
  char *v54; // [sp+24h] [bp-308h]@45
  char v55[508]; // [sp+28h] [bp-304h]@11
  char v56; // [sp+224h] [bp-108h]@44
  char v57; // [sp+227h] [bp-105h]@11
  char v58; // [sp+228h] [bp-104h]@123
  char v59; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v4 = sub_100476C0();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_106C3A98 + 580 * v4;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v5) = sub_1004A330((int)v6, 0);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1004A2E0((int)v6, "Resetting test status\r\n");
      return v5;
    case 1:
      LOBYTE(v5) = sub_10049E50((int)v6);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1004A2E0((int)v6, "Clearing test status\r\n");
      return v5;
    case 11:
      LOBYTE(v5) = sub_1004A330((int)v6, 0);
      return v5;
    case 4:
      sub_10049CD0((int)v6, *a2);
      if ( v6[577] && !v6[578] )
      {
        v7 = sub_1004A000((char *)a2[1]);
        _snprintf(v55, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v7);
        v57 = 0;
        sub_1004A2E0((int)v6, v55);
      }
      LOBYTE(v5) = 0;
      v8 = (int)&v6[16 * *(_DWORD *)v6 + 4];
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      return v5;
    case 5:
      v9 = *a2;
      LOBYTE(v5) = sub_10049CC0((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 6:
      LOBYTE(v5) = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8] = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4] = 0;
      v10 = v6[577] == 0;
      *((_DWORD *)v6 + 143) = 0;
      if ( !v10 && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1004A2E0((int)v6, v55);
      }
      return v5;
    case 7:
      v49 = sub_100496C0((int)a2, a3);
      if ( !v49 && !v6[577] )
        goto LABEL_83;
      if ( v6[578] )
        goto LABEL_81;
      v11 = 0;
      v48 = 0;
      if ( a3 > 7 )
        v11 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v11 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v11 += strlen((const char *)a2[3]);
      if ( v11 > 100 )
        v48 = 1;
      v12 = sub_1004F090((int)v6, (unsigned __int8)v49);
      _snprintf(v55, 0x200u, "%s ", v12);
      v57 = 0;
      sub_1004A2E0((int)v6, v55);
      if ( a3 > 7 )
      {
        _snprintf(v55, 0x200u, " ACT: %-17s", a2[7]);
        v57 = 0;
        sub_1004A2E0((int)v6, v55);
        if ( v48 )
          sub_1004A2E0((int)v6, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v55, 0x200u, " EXP: %-17s", a2[8]);
        v57 = 0;
        sub_1004A2E0((int)v6, v55);
        if ( v48 )
          sub_1004A2E0((int)v6, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v13 = (_BYTE *)a2[9];
        if ( v13 )
        {
          if ( *v13 )
          {
            if ( memcmp((const void *)a2[9], &word_100A7F38, 2u) )
            {
              _snprintf(v55, 0x200u, " TOL: %-17s", a2[9]);
              v57 = 0;
              sub_1004A2E0((int)v6, v55);
              if ( v48 )
                sub_1004A2E0((int)v6, "\r\n     ");
            }
          }
        }
      }
      v14 = _snprintf(v55, 0x1FCu, " %s", a2[3]);
      v15 = v14 < 0;
      v56 = 0;
      if ( v14 > 0 )
      {
        do
        {
          v16 = (char)(&v54)[v14 + 3];
          if ( v16 != 10 && v16 != 13 )
            break;
          LOBYTE((&v54)[4 * --v14 + 13]) = 0;
        }
        while ( v14 > 0 );
        v15 = v14 < 0;
      }
      if ( !v15 )
      {
        v17 = &v55[v14];
        *(_WORD *)v17 = *(_WORD *)"\r\n";
        v17[2] = asc_10092000[2];
      }
      sub_1004A2E0((int)v6, v55);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v18 = 10;
      v50 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v19 = v3[v18];
        v20 = 6;
        v21 = "Info: ";
        v22 = (_DWORD *)v3[v18];
        do
        {
          if ( *v22 != *(_DWORD *)v21 )
            goto LABEL_57;
          v20 -= 4;
          v21 += 4;
          ++v22;
        }
        while ( v20 >= 4 );
        if ( !v20 )
          goto LABEL_67;
LABEL_57:
        v23 = *(_BYTE *)v22 - *v21;
        if ( *(_BYTE *)v22 == *v21 )
        {
          v24 = v20 - 1;
          v25 = v21 + 1;
          v26 = (char *)v22 + 1;
          if ( !v24
            || (v23 = *v26 - *v25, *v26 == *v25)
            && ((v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, !v27)
             || (v23 = *v29 - *v28, *v29 == *v28)
             && ((v30 = v28 + 1, v31 = v29 + 1, v27 == 1) || (v23 = *v31 - *v30, *v31 == *v30))) )
          {
            v3 = a2;
LABEL_67:
            v32 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v32 = 1;
        if ( v23 <= 0 )
          v32 = -1;
LABEL_68:
        if ( v32 )
        {
          _snprintf(v55, 0x200u, "      Post Analysis: %s\r\n", v19);
          v47 = v55;
        }
        else
        {
          _snprintf(v55, 0x200u, "      Compare Info: %s\r\n", v19 + 6);
          v47 = v55;
        }
        v57 = 0;
        sub_1004A2E0((int)v6, v47);
        v18 = v50++ + 1;
      }
      while ( v50 < (signed int)a3 );
LABEL_72:
      if ( v6[309] )
      {
        v33 = 0;
        if ( *((_DWORD *)v6 + 143) > 0 )
        {
          v34 = (int)(v6 + 336);
          do
          {
            if ( v33 >= 20 )
              break;
            v35 = *(_DWORD *)(v34 - 4);
            if ( *(_DWORD *)(v34 + 4) )
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v33, v35, *(_DWORD *)v34, *(_DWORD *)(v34 + 4));
            else
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s\r\n", v33, v35, *(_DWORD *)v34);
            v57 = 0;
            sub_1004A2E0((int)v6, v55);
            ++v33;
            v34 += 12;
          }
          while ( v33 < *((_DWORD *)v6 + 143) );
        }
        _snprintf(v55, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v57 = 0;
        sub_1004A2E0((int)v6, v55);
      }
LABEL_81:
      if ( v49 )
      {
        v36 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v36 + 4];
        v5 = (int)&v6[v36 + 4];
      }
      else
      {
LABEL_83:
        v37 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v37 + 8];
        v5 = (int)&v6[v37 + 8];
      }
      return v5;
    case 9:
      LOBYTE(v5) = sub_10049F30((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 3:
      LOBYTE(v5) = sub_100499E0((const void **)a2, a3);
      if ( !(_BYTE)v5 && !v6[578] )
      {
        if ( v6[577]
          || sub_10049AA0((const void **)a2, a3)
          || (LOBYTE(v5) = sub_100498F0((const void **)a2, a3), (_BYTE)v5) )
        {
          if ( a3 <= 8 )
            v51 = byte_10084570;
          else
            v51 = (char *)a2[8];
          if ( a3 <= 7 )
            v52 = byte_10084570;
          else
            v52 = (char *)a2[7];
          if ( a3 <= 6 )
            v54 = byte_10084570;
          else
            v54 = (char *)a2[6];
          if ( a3 <= 5 )
            v53 = byte_10084570;
          else
            v53 = (char *)a2[5];
          if ( a3 <= 4 )
          {
            v38 = a2;
            v39 = byte_10084570;
          }
          else
          {
            v38 = a2;
            v39 = (char *)a2[4];
          }
          if ( a3 <= 3 )
            v40 = byte_10084570;
          else
            v40 = (char *)v38[3];
          if ( a3 )
            v41 = (char *)*v38;
          else
            v41 = byte_10084570;
          v10 = sub_100499B0((const void **)a2, a3) == 0;
          v42 = byte_10084570;
          if ( v10 )
            v42 = "   ";
          _snprintf(v55, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v42, v41, v40, v39, v53, v54, v52, v51);
          v57 = 0;
          LOBYTE(v5) = (unsigned int)sub_1004A2E0((int)v6, v55);
        }
      }
      return v5;
    case 2:
      if ( v6[578] )
        return v5;
      if ( sub_100496F0((const void **)a2, a3) )
      {
        dword_106C3A90 = 2;
        sub_1004A2E0((int)v6, "\r\n");
        sub_1004A2E0((int)v6, "   Command Format:\r\n");
        sub_1004A2E0(
          (int)v6,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_1004A2E0(
          (int)v6,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_1004A2E0(
          (int)v6,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_1004A2E0(
          (int)v6,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_1004A2E0((int)v6, "                                         strings depending upon the command\r\n");
        sub_1004A2E0((int)v6, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_1004A2E0(
          (int)v6,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_1004A2E0(
          (int)v6,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_1004A2E0((int)v6, "\r\n");
        sub_1004A2E0((int)v6, "   Notes:\r\n");
        sub_1004A2E0((int)v6, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_1004A2E0((int)v6, "\r\n");
        sub_1004A2E0(
          (int)v6,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_1004A2E0(
          (int)v6,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_1004A2E0(
          (int)v6,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_1004A2E0((int)v6, "       the suite name and the test case or test suite command.\r\n");
        sub_1004A2E0((int)v6, "\r\n");
        sub_1004A2E0(
          (int)v6,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_1004A2E0(
          (int)v6,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_1004A2E0((int)v6, "       without a test suite name.\r\n");
        sub_1004A2E0((int)v6, "\r\n");
        sub_1004A2E0((int)v6, "   Examples:\r\n");
        sub_1004A2E0(
          (int)v6,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_1004A2E0((int)v6, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_1004A2E0(
          (int)v6,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_1004A2E0(
          (int)v6,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_1004A2E0(
          (int)v6,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_1004A2E0(
          (int)v6,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_1004A2E0(
          (int)v6,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_1004A2E0(
          (int)v6,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_1004A2E0((int)v6, "\r\n");
        sub_1004A2E0((int)v6, "   Command                                 Description\r\n");
        LOBYTE(v5) = (unsigned int)sub_1004A2E0(
                                     (int)v6,
                                     "   --------------------------------        --------------------------------\r\n");
        return v5;
      }
      if ( sub_10049780((const void **)a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_1004A2E0((int)v6, "\r\n");
        return v5;
      }
      if ( sub_10049750((const void **)a2, a3) )
      {
        _snprintf(&v58, 0x100u, "%s %s", a2[3], a2[4]);
        v43 = a2[5];
        v59 = 0;
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_106C3A90,
          byte_10084570,
          &v58,
          6 - dword_106C3A90,
          word_10088C68,
          v43);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1004A2E0((int)v6, v55);
        return v5;
      }
      if ( sub_100497B0((const void **)a2, a3) )
      {
        LOBYTE(v5) = sub_100497E0((int)a2, a3);
        if ( (_BYTE)v5 )
        {
          dword_106C3A90 += 2;
          return v5;
        }
        if ( sub_10049820((int)a2, a3) )
        {
          LOBYTE(v5) = 2;
          if ( dword_106C3A90 < 2 )
            dword_106C3A90 = 0;
          else
            dword_106C3A90 -= 2;
          return v5;
        }
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_106C3A90,
          byte_10084570,
          a2[2],
          6 - dword_106C3A90,
          word_10088C68,
          a2[2]);
LABEL_134:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1004A2E0((int)v6, v55);
        return v5;
      }
      if ( sub_10049720((const void **)a2, a3) )
      {
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_106C3A90,
          byte_10084570,
          a2[3],
          6 - dword_106C3A90,
          word_10088C68,
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_10049890((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1004A2E0((int)v6, v55);
      }
      else if ( sub_10049860((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1004A2E0((int)v6, v55);
      }
      else
      {
        LOBYTE(v5) = (unsigned int)sub_1004A2E0((int)v6, "Unknown test help event\r\n");
      }
      return v5;
    case 8:
      if ( v6[577] && !v6[578] )
      {
        v44 = sub_1004F090((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        _snprintf(v55, 0x200u, "\r\n   Test Case Results: %s\r\n", v44);
        v57 = 0;
        sub_1004A2E0((int)v6, v55);
        _snprintf(v55, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8]);
        v57 = 0;
        sub_1004A2E0((int)v6, v55);
        _snprintf(v55, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        v57 = 0;
        sub_1004A2E0((int)v6, v55);
      }
      v5 = (int)&v6[16 * *(_DWORD *)v6];
      if ( *(_DWORD *)(v5 + 4) )
        ++*(_DWORD *)(v5 + 12);
      else
        ++*(_DWORD *)(v5 + 16);
      return v5;
    case 10:
      if ( v6[577] && !v6[578] )
      {
        v45 = sub_1004F090((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        _snprintf(v55, 0x200u, "\r\nTest Suite Results: %s\r\n", v45);
        v57 = 0;
        sub_1004A2E0((int)v6, v55);
        _snprintf(v55, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v6[16 * (*(_DWORD *)v6 + 1)]);
        v57 = 0;
        sub_1004A2E0((int)v6, v55);
        _snprintf(v55, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        v57 = 0;
        sub_1004A2E0((int)v6, v55);
      }
      LOBYTE(v5) = sub_10049F90((int)v6, 0);
      return v5;
    case 12:
      LOBYTE(v5) = sub_1004A260((int)v6, 0);
      return v5;
    case 13:
      if ( a3 >= 2 )
      {
        v5 = *((_DWORD *)v6 + 143);
        if ( v5 < 20 )
        {
          *(_DWORD *)&v6[12 * v5 + 332] = *a2;
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143) + 28)] = a2[1];
          v5 = 3 * *((_DWORD *)v6 + 143);
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143))++ + 340] = a2[2];
        }
      }
      return v5;
    case 14:
      --*((_DWORD *)v6 + 143);
      return v5;
    default:
      if ( !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1004A2E0((int)v6, "Unknown test event\r\n");
      return v5;
  }
}
// 100A7F38: using guessed type __int16 word_100A7F38;
// 106C3A90: using guessed type int dword_106C3A90;
// 1004F0D0: using guessed type char var_304[508];

//----- (1004FE80) --------------------------------------------------------
signed int __cdecl sub_1004FE80(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_106C3A98 + 580 * sub_100476C0();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_10049E90(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (1004FF00) --------------------------------------------------------
char **__cdecl sub_1004FF00(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_106C3A98 + 580 * sub_100476C0();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_1004A0A0((int)v1, a1, (int)".txt");
  return &off_100E26D0;
}
// 100E26D0: using guessed type char *off_100E26D0;

//----- (1004FF40) --------------------------------------------------------
int (**sub_1004FF40())()
{
  return off_100E33BC;
}
// 100E33BC: using guessed type int (*off_100E33BC[2])();

//----- (1004FF50) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004FF50(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_100476C0();
  return sub_1004A2E0((int)&unk_106C45F0 + 1812 * v1, a1);
}

//----- (1004FF70) --------------------------------------------------------
const char *sub_1004FF70()
{
  return "See version control for test execution date";
}

//----- (1004FF80) --------------------------------------------------------
__int64 sub_1004FF80()
{
  return 0i64;
}

//----- (1004FF90) --------------------------------------------------------
const char *sub_1004FF90()
{
  return "Not Available";
}

//----- (1004FFA0) --------------------------------------------------------
int __usercall sub_1004FFA0@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (1004FFF0) --------------------------------------------------------
signed int __cdecl sub_1004FFF0(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100476C0();
  return sub_10049E90(a1, a2, (int)&unk_106C45F0 + 1812 * v2);
}

//----- (10050140) --------------------------------------------------------
int __usercall sub_10050140@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  int v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_10068840((int)&a2[151 * (*a2 + 1)], (int)sub_1004FF50, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_1004FF80();
  v4 = sub_1005F630("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_10068C90((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_1005F630("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_10068C90((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_10068C90((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_10068C10((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_10068AA0((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_1005F630("CFG_OutputTestRevision", (int)"False");
  if ( !sub_10047770(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_10068CE0((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_10068CE0((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_10068C10((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_10068C10((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_10068CE0((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_1004A000(v3);
  sub_10068CE0((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_10068B90((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_1005F5F0(i, &v15, &v16); ++i )
  {
    sub_10068C10((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_10068CE0((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_10068CE0((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_10068B90((int)&a2[151 * (*a2 + 1)]);
  }
  sub_10068B90((int)&a2[151 * (*a2 + 1)]);
  sub_10068C10((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_10068AA0((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = (int)&a2[4 * *a2 + 1];
  *(_DWORD *)v14 = 0;
  *(_DWORD *)(v14 + 4) = 0;
  *(_DWORD *)(v14 + 8) = 0;
  *(_DWORD *)(v14 + 12) = 0;
  return result;
}
// 10050140: using guessed type char var_103[253];

//----- (100504C0) --------------------------------------------------------
char __cdecl sub_100504C0(int a1, const void **a2, unsigned int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  char *v5; // ebp@1
  const char *v6; // ebx@3
  int v7; // esi@4
  int v8; // ST14_4@5
  int v9; // eax@12
  const char *v10; // eax@13
  const char *v11; // eax@15
  int v12; // ST14_4@17
  int v13; // ecx@29
  const void *v14; // ST24_4@43
  int v15; // ST04_4@44
  _BYTE *v16; // eax@87
  _BYTE *v17; // eax@94
  _BYTE *v18; // eax@100
  int v19; // ST20_4@104
  unsigned int v20; // esi@105
  _DWORD *v21; // edx@106
  unsigned int v22; // eax@106
  const char *v23; // ecx@106
  int v24; // esi@110
  int v25; // eax@111
  _BYTE *v26; // ecx@111
  _BYTE *v27; // edx@111
  int v28; // eax@113
  _BYTE *v29; // ecx@113
  _BYTE *v30; // edx@113
  _BYTE *v31; // ecx@115
  _BYTE *v32; // edx@115
  bool v33; // zf@117
  bool v34; // sf@117
  signed int v35; // eax@117
  const char *v36; // eax@129
  const char *v37; // eax@131
  const char *v39; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v40; // [sp-Ch] [bp-120h]@73
  char v41; // [sp+9h] [bp-10Bh]@46
  char v42; // [sp+Ah] [bp-10Ah]@46
  char v43; // [sp+Bh] [bp-109h]@46
  const char *v44; // [sp+Ch] [bp-108h]@91
  signed int v45; // [sp+Ch] [bp-108h]@105
  char v46[255]; // [sp+10h] [bp-104h]@5
  char v47; // [sp+10Fh] [bp-5h]@44

  v3 = sub_100476C0();
  LOBYTE(v4) = a1;
  v5 = (char *)&unk_106C45F0 + 1812 * v3;
  switch ( a1 )
  {
    case 3:
      if ( sub_10049A40(a2, a3) )
      {
        v6 = (const char *)a2[3];
        do
        {
          v4 = sub_1004FFA0(", \t", (int)v6);
          v7 = v4;
          if ( v4 )
          {
            strncpy(v46, v6, v4);
            v8 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
            v46[v7] = 0;
            sub_10068C10(v8, (int)"Req");
            sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"id", (unsigned __int8 *)v46);
            LOBYTE(v4) = (unsigned int)sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
            v6 += v7;
          }
          else
          {
            ++v6;
          }
        }
        while ( *v6 );
      }
      else if ( sub_10049A10(a2, a3) )
      {
        if ( sub_1004A1A0((int)v5, 3, 1, 0) )
          sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        v9 = *((_DWORD *)v5 + 146);
        if ( v9 > 0 )
        {
          *((_DWORD *)v5 + 146) = v9 - 1;
          sub_10068C10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
          v10 = "true";
          if ( *((_DWORD *)v5 + 144) <= 0 )
            v10 = "false";
          sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v10);
          v11 = "true";
          if ( *((_DWORD *)v5 + 145) <= 0 )
            v11 = "false";
          sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v11);
          sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          v12 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          *((_DWORD *)v5 + 144) = 0;
          *((_DWORD *)v5 + 145) = 0;
          sub_10068B90(v12);
          sub_10068C10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        }
        LOBYTE(v4) = (unsigned int)sub_10068AA0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10049950(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_10068CE0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 146);
      }
      else if ( sub_10049A70(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_10068CE0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_100499E0(a2, a3) )
      {
        if ( sub_1004A1A0((int)v5, 3, 1, 0) )
          sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1004A110((int)a2, a3, (int)v5);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_10068C10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      }
      else if ( sub_10049980(a2, a3) )
      {
        sub_10068C10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Results");
        v13 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_10068AA0(v13, (int)"success", (unsigned __int8 *)&word_100A7F38);
          sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_10068AA0(v13, (int)"success", (unsigned __int8 *)&unk_100AE0F0);
        }
        if ( v5[309] )
        {
          sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1004A1A0((int)v5, 3, 0, 0);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = (unsigned int)sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      else
      {
        LOBYTE(v4) = sub_10049920(a2, a3);
        if ( (_BYTE)v4 )
        {
          if ( !sub_1004A250((int)v5) )
            sub_10068C10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
          sub_10068CE0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v4) = sub_1004A1A0((int)v5, 3, 0, 1);
          if ( (_BYTE)v4 )
            LOBYTE(v4) = (unsigned int)sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      return v4;
    case 4:
      LOBYTE(v4) = sub_10049CD0((int)v5, (int)*a2);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_10050140((char *)a2[1], v5, (int)*a2);
      return v4;
    case 5:
      v14 = *a2;
      LOBYTE(v4) = sub_10049CC0((int)v5);
      if ( !(_BYTE)v4 )
      {
        sub_10068C10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        _snprintf(v46, 0x100u, "Test Group: %s", *a2);
        v15 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        v47 = 0;
        sub_10068CE0(v15, (int)"Method", (unsigned __int8 *)v46);
        LOBYTE(v4) = (unsigned int)sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      return v4;
    case 6:
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      LOBYTE(v4) = sub_10068C10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
      return v4;
    case 7:
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v42 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v43 = 1;
LABEL_55:
        v41 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v5 + 146) )
      {
        sub_10068CE0(
          (int)&v5[604 * (*(_DWORD *)v5 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_10068CE0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v5 + 146);
      }
      if ( !sub_1004A250((int)v5) )
        sub_10068C10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      if ( sub_100498C0((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_10068C10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction");
          sub_10068B40((int)&v5[604 * (*(_DWORD *)v5 + 1)], (unsigned __int8 *)a2[3]);
          sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
        ++*((_DWORD *)v5 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_10068CE0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 144);
      }
      sub_10068C10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Compare");
      if ( sub_100496C0((int)a2, a3) )
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 4];
        sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 8];
        sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v41 )
      {
        sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v43 )
        {
          sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v40 = (unsigned __int8 *)"true";
        v39 = "strict";
      }
      else
      {
        v40 = (unsigned __int8 *)a2[6];
        v39 = "datatype";
      }
      sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)v39, v40);
LABEL_77:
      if ( v5[309] )
      {
        sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_10068C10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Actual");
        if ( v42 )
          sub_10068AF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v42 )
        {
          sub_10068C10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Expected");
          sub_10068AF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          if ( a3 > 9 )
          {
            v16 = a2[9];
            if ( v16 )
            {
              if ( *v16 )
              {
                sub_10068C10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Tolerance");
                sub_10068AF0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v41 )
          {
            v44 = "!";
            if ( memcmp(*a2, &unk_100E0AD0, 3u) )
              v44 = byte_10084570;
            if ( a3 > 9 && (v17 = a2[9]) != 0 && *v17 && memcmp(a2[9], &word_100A7F38, 2u) )
              _snprintf(v46, 0x100u, "%s%s+/-%s", v44, a2[8], a2[9]);
            else
              _snprintf(v46, 0x100u, "%s%s", v44, a2[8]);
          }
          else if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 )
          {
            _snprintf(v46, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v46, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v19 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          v47 = 0;
          sub_10068C10(v19, (int)"Expected");
          sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)v46);
          sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      v20 = 10;
      v45 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_1004A1A0((int)v5, 8, 1, 0) )
        sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      sub_10068C10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
      v36 = "true";
      if ( *((_DWORD *)v5 + 144) <= 0 )
        v36 = "false";
      sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v36);
      v37 = "true";
      if ( *((_DWORD *)v5 + 145) <= 0 )
        v37 = "false";
      sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v37);
      sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      LOBYTE(v4) = (unsigned int)sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      return v4;
    case 9:
      LOBYTE(v4) = sub_10049F30((int)v5);
      return v4;
    case 10:
      LOBYTE(v4) = sub_10049F90((int)v5, (void (__cdecl *)(int))sub_10050020);
      return v4;
    case 0:
    case 11:
      sub_1004A330((int)v5, (void (__cdecl *)(int))sub_10050020);
      goto LABEL_139;
    case 1:
      sub_10049E50((int)v5);
      goto LABEL_139;
    case 12:
      sub_1004A260((int)v5, (void (__cdecl *)(int))sub_10050020);
LABEL_139:
      LOBYTE(v4) = 0;
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      return v4;
    default:
      return v4;
  }
  do
  {
    v21 = a2[v20];
    v22 = 6;
    v23 = "Info: ";
    do
    {
      if ( *v21 != *(_DWORD *)v23 )
        goto LABEL_110;
      v22 -= 4;
      v23 += 4;
      ++v21;
    }
    while ( v22 >= 4 );
    if ( !v22 )
      goto LABEL_120;
LABEL_110:
    v24 = *(_BYTE *)v21 - *v23;
    if ( *(_BYTE *)v21 == *v23 )
    {
      v25 = v22 - 1;
      v26 = v23 + 1;
      v27 = (char *)v21 + 1;
      if ( !v25
        || (v24 = *v27 - *v26, *v27 == *v26)
        && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
         || (v24 = *v30 - *v29, *v30 == *v29)
         && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
      {
        v20 = v45;
LABEL_120:
        v35 = 0;
        goto LABEL_121;
      }
    }
    v33 = v24 == 0;
    v34 = v24 < 0;
    v20 = v45;
    v35 = 1;
    if ( v34 || v33 )
      v35 = -1;
LABEL_121:
    if ( v35 )
    {
      sub_10068C10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"PostAnalysis");
      sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"note", (unsigned __int8 *)a2[v20]);
      sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    else
    {
      sub_10068C10((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"CompareInfo");
      sub_10068AA0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v20] + 6);
      sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    v45 = ++v20;
  }
  while ( v20 < a3 );
LABEL_125:
  sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  LOBYTE(v4) = sub_1004A1A0((int)v5, 7, 0, 1);
  if ( (_BYTE)v4 )
    LOBYTE(v4) = (unsigned int)sub_10068B90((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  return v4;
}
// 10050020: using guessed type int sub_10050020();
// 100A7F38: using guessed type __int16 word_100A7F38;
// 100504C0: using guessed type char var_104[255];

//----- (100512E0) --------------------------------------------------------
char **__cdecl sub_100512E0(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_106C45F0 + 1812 * sub_100476C0();
  *((_DWORD *)v1 + 146) = 0;
  sub_1004A0A0((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_10068840(v2, (int)sub_1004FF50, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_100E3468;
}
// 100E3468: using guessed type char *off_100E3468;

//----- (10051350) --------------------------------------------------------
char __thiscall sub_10051350(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_106C6958 = sub_10036FE0(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_106C6960, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_106C6960;
  do
  {
    result = sub_100524A0(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 106C6958: using guessed type int dword_106C6958;

//----- (100513C0) --------------------------------------------------------
char __usercall sub_100513C0@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_1003E290(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_1003E290(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (10051400) --------------------------------------------------------
void *__usercall sub_10051400@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_106C6958 == 1379255385 )
    goto LABEL_4;
  v4 = sub_10069980(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_106C6960 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_100524A0(a1, (int)&unk_106C6960 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy_0(
               a4,
               (char *)&unk_106C6960 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2,
               (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_106C6958 != 1379255385 )
    result = (void *)sub_10069950(v4, 86);
  return result;
}
// 106C6958: using guessed type int dword_106C6958;

//----- (100514A0) --------------------------------------------------------
char __cdecl sub_100514A0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_100513C0(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (100514E0) --------------------------------------------------------
bool __cdecl sub_100514E0(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_10051400(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (10051540) --------------------------------------------------------
char __cdecl sub_10051540(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_100513C0(a2, 1, a3, a1);
  return result;
}

//----- (10051580) --------------------------------------------------------
char __cdecl sub_10051580(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_10051400(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (100515B0) --------------------------------------------------------
char __cdecl sub_100515B0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_100513C0(a2 + 10, 1, a3, a1);
  return result;
}

//----- (100515F0) --------------------------------------------------------
char __cdecl sub_100515F0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_10051400(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10051630) --------------------------------------------------------
char __cdecl sub_10051630(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_100513C0(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (10051670) --------------------------------------------------------
bool __cdecl sub_10051670(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_10051400(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (100516C0) --------------------------------------------------------
char __cdecl sub_100516C0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_100513C0(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (10051700) --------------------------------------------------------
bool __cdecl sub_10051700(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_10051400(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (10051740) --------------------------------------------------------
char __cdecl sub_10051740(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_100513C0(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (10051780) --------------------------------------------------------
bool __cdecl sub_10051780(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_10051400(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (100517C0) --------------------------------------------------------
char __cdecl sub_100517C0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_100513C0(1229, 1, a2, a1);
  return result;
}

//----- (100517F0) --------------------------------------------------------
char __cdecl sub_100517F0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10051400(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (10051820) --------------------------------------------------------
char __cdecl sub_10051820(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_100513C0(1212, 16, a2, a1);
  return result;
}

//----- (10051850) --------------------------------------------------------
char __cdecl sub_10051850(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10051400(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10051880) --------------------------------------------------------
char __cdecl sub_10051880(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_100513C0(2400, 65, a2, a1);
  return result;
}

//----- (100518B0) --------------------------------------------------------
char __cdecl sub_100518B0(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10051400(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100518E0) --------------------------------------------------------
char __cdecl sub_100518E0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_100513C0(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (10051920) --------------------------------------------------------
char __cdecl sub_10051920(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_100364C0("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_10051400(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (10051970) --------------------------------------------------------
char __cdecl sub_10051970(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_100513C0(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (100519B0) --------------------------------------------------------
char __cdecl sub_100519B0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_10051400(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (100519E0) --------------------------------------------------------
char __cdecl sub_100519E0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_100513C0(22, 1, a2, a1);
  return result;
}

//----- (10051A10) --------------------------------------------------------
char __cdecl sub_10051A10(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_100513C0(832, 4, a2, a1);
  return result;
}

//----- (10051A40) --------------------------------------------------------
char __cdecl sub_10051A40(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10051400(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (10051A70) --------------------------------------------------------
char __cdecl sub_10051A70(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1003CD30(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_10051920(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_100518E0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_100519B0(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10051970(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_100514E0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_100514A0(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_10051700(v6, *(_BYTE *)a4, a5);
        else
          result = sub_100516C0(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_10051780(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10051740(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_10051580(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10051540(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_100515F0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_100515B0(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_100519E0(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_10051850(v6, a5);
        else
          result = sub_10051820(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_10051670(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10051630(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_100518B0(v6, a5);
        else
          result = sub_10051880(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_100517F0(v6, a5);
        else
          result = sub_100517C0(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10051A40(v6, a5);
        else
          result = sub_10051A10(v6, a5);
        break;
      default:
        sub_100364C0("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 1006BBD0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10051E10) --------------------------------------------------------
bool __cdecl sub_10051E10(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_106C7EA0 != 1379255385 )
    {
      sub_10052480(a1, (int)&byte_106C7EA8[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_106C7EAD[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_106C7EAC[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 106C7EA0: using guessed type int dword_106C7EA0;

//----- (10051E80) --------------------------------------------------------
bool __cdecl sub_10051E80(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_106C7EA0 != 1379255385 )
      sub_10052480(a1, (int)&byte_106C7EA8[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_106C7EBC[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 106C7EA0: using guessed type int dword_106C7EA0;
// 106C7EBC: using guessed type int dword_106C7EBC[];

//----- (10051EE0) --------------------------------------------------------
bool __cdecl sub_10051EE0(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_106C7EA0 != 1379255385 )
    {
      sub_10052480(a1, (int)&byte_106C7EA8[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_106C7EB4[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 106C7EA0: using guessed type int dword_106C7EA0;
// 106C7EB4: using guessed type int dword_106C7EB4[];

//----- (10051F50) --------------------------------------------------------
char __cdecl sub_10051F50(char a1, _BYTE *a2)
{
  if ( dword_106C7EA0 != 1379255385 )
    sub_10052480(a1, (int)&byte_106C7EA8[24 * (unsigned __int8)a1]);
  *a2 = byte_106C7EA8[24 * (unsigned __int8)a1];
  return 1;
}
// 106C7EA0: using guessed type int dword_106C7EA0;

//----- (10051F90) --------------------------------------------------------
char __thiscall sub_10051F90(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_106C7EA0 = sub_10036FE0(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_106C7EA8, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_106C7EA8;
  do
  {
    result = sub_10052480(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 106C7EA0: using guessed type int dword_106C7EA0;

//----- (10052000) --------------------------------------------------------
char __cdecl sub_10052000(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10038310(a1);
  v3 = sub_1006C430(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10052030) --------------------------------------------------------
char __cdecl sub_10052030(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10038310(a1);
  v3 = sub_1006C4A0(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10052060) --------------------------------------------------------
char __cdecl sub_10052060(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_10038400(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_10051EE0(v7, *a4, (int)a5);
      }
      else
      {
        sub_100364C0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_10051E10(v7, *a4, (int)a5);
      }
      else
      {
        sub_100364C0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_10051E80(v7, *a4, (int)a5);
      }
      else
      {
        sub_100364C0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_10051F50(v7, a5);
      }
      else
      {
        sub_100364C0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_10052030(v7, (int)a5);
      }
      else
      {
        sub_100364C0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_10052000(v7, (int)a5);
      }
      else
      {
        sub_100364C0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_100364C0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10052230) --------------------------------------------------------
char __cdecl sub_10052230(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x319u )
  {
    sub_100364C0("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 115, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_10116928[8 * a1];
  *a4 = word_1011692A[a2 + 4 * a1];
  return 1;
}
// 1011692A: using guessed type __int16 word_1011692A[];

//----- (10052290) --------------------------------------------------------
char __cdecl sub_10052290(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x145u )
  {
    sub_100364C0("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 320, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_101181F0[16 * a1];
  *a4 = word_101181F8[a2 + 8 * a1];
  return 1;
}
// 101181F8: using guessed type __int16 word_101181F8[];

//----- (100522F0) --------------------------------------------------------
signed int __cdecl sub_100522F0(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_100E4080;
    v6 = &unk_100E4080;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_100E4098;
    v6 = &unk_100E4098;
    v5 = &a1;
  }
  v3 = sub_1003B860(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (10052350) --------------------------------------------------------
int __cdecl sub_10052350(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1003B860(&a1, 1u, (int)&unk_100E40E0, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100E40E4[2 * v1];
  return result;
}
// 100E40E4: using guessed type int dword_100E40E4[];

//----- (10052390) --------------------------------------------------------
signed int __cdecl sub_10052390(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_100E40F0;
    v7 = &unk_100E40F0;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_100E4108;
    v7 = &unk_100E4108;
    v6 = &a1;
  }
  v4 = sub_1003B860(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (10052400) --------------------------------------------------------
int __cdecl sub_10052400(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1003B860(&a1, 1u, (int)&unk_100E4120, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_100E4124[2 * v1];
  return result;
}
// 100E4124: using guessed type int dword_100E4124[];

//----- (10052440) --------------------------------------------------------
int __cdecl sub_10052440(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1003B860(&a1, 1u, (int)&unk_100E4138, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100E413C[2 * v1];
  return result;
}
// 100E413C: using guessed type int dword_100E413C[];

//----- (10052480) --------------------------------------------------------
char __cdecl sub_10052480(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100522F0(a1, 11);
  return sub_1006A0C0(v2, a2, 24);
}

//----- (100524A0) --------------------------------------------------------
char __cdecl sub_100524A0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10052350(a1);
  return sub_1006A0C0(v2, a2, 2720);
}

//----- (100524D0) --------------------------------------------------------
char __cdecl sub_100524D0(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_10052390(a1, 11, 1);
  sub_1006A0C0(v2, a2, 36);
  v3 = sub_10052390(a1, 11, 0);
  return sub_1006A0C0(v3, a2 + 36, 32);
}

//----- (10052520) --------------------------------------------------------
char __cdecl sub_10052520(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10052400(a1);
  return sub_1006A0C0(v2, a2, 2192);
}

//----- (10052550) --------------------------------------------------------
char __cdecl sub_10052550(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10052440(a1);
  return sub_1006A0C0(v2, a2, 60);
}

//----- (10052570) --------------------------------------------------------
char __cdecl sub_10052570(int a1)
{
  return sub_1006A0C0(6453, a1, 5);
}

//----- (10052590) --------------------------------------------------------
int __cdecl sub_10052590(unsigned __int8 *a1)
{
  return sub_1003F590(a1, 0, 0, 0, 0);
}

//----- (100525B0) --------------------------------------------------------
unsigned int __cdecl sub_100525B0(void *a1)
{
  return sub_1003F530(a1, 0xCu, 0);
}

//----- (100525D0) --------------------------------------------------------
unsigned int __cdecl sub_100525D0(void *a1)
{
  return sub_1003F530(a1, 0x20u, 0);
}

//----- (100525F0) --------------------------------------------------------
unsigned int __cdecl sub_100525F0(void *a1)
{
  return sub_1003F530(a1, 0x1Cu, 0);
}

//----- (10052610) --------------------------------------------------------
unsigned int __cdecl sub_10052610(void *a1)
{
  return sub_1003F530(a1, 0x10u, 0);
}

//----- (10052630) --------------------------------------------------------
unsigned int __cdecl sub_10052630(void *a1)
{
  return sub_1003F530(a1, 8u, 0);
}

//----- (10052650) --------------------------------------------------------
int __cdecl sub_10052650(int a1)
{
  int result; // eax@1

  result = sub_1003F590((unsigned __int8 *)(a1 + 1), 1u, 0x1Fu, 1u, 0);
  if ( !result )
  {
    result = sub_1003F590((unsigned __int8 *)a1, 1u, 0xCu, 1u, 0);
    if ( !result )
      result = sub_1003F5E0((_BYTE *)(a1 + 2), 0x7C6u, 0xFFFFu, 1990, 0);
  }
  return result;
}

//----- (100526A0) --------------------------------------------------------
signed int __cdecl sub_100526A0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1003F470(a1, 2147483648, 0x7FFFFFFF, 0x7FFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100526D0) --------------------------------------------------------
int __cdecl sub_100526D0(void *a1)
{
  int result; // eax@1

  result = sub_100525D0((char *)a1 + 64);
  if ( !result )
  {
    result = sub_100525D0((char *)a1 + 128);
    if ( !result )
    {
      result = sub_10052630((char *)a1 + 120);
      if ( !result )
      {
        result = sub_100525F0((char *)a1 + 36);
        if ( !result )
        {
          result = sub_10052650((int)a1 + 168);
          if ( !result )
          {
            result = sub_10052650((int)a1 + 160);
            if ( !result )
            {
              result = sub_10052650((int)a1 + 164);
              if ( !result )
              {
                result = sub_10052610(a1);
                if ( !result )
                {
                  result = sub_100525B0((char *)a1 + 96);
                  if ( !result )
                  {
                    result = sub_100525B0((char *)a1 + 24);
                    if ( !result )
                      result = sub_10052630((char *)a1 + 16);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (100527A0) --------------------------------------------------------
unsigned int __cdecl sub_100527A0(void *a1)
{
  unsigned int result; // eax@1

  result = sub_100525D0((char *)a1 + 64);
  if ( !result )
  {
    result = sub_100525F0((char *)a1 + 36);
    if ( !result )
    {
      result = sub_10052610(a1);
      if ( !result )
      {
        result = sub_100525B0((char *)a1 + 96);
        if ( !result )
        {
          result = sub_100525B0((char *)a1 + 24);
          if ( !result )
            result = sub_10052630((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (10052800) --------------------------------------------------------
char __cdecl sub_10052800(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  *(_DWORD *)a2 = 0;
  *((_DWORD *)a2 + 1) = 0;
  *((_DWORD *)a2 + 2) = 0;
  *((_DWORD *)a2 + 3) = 0;
  *((_DWORD *)a2 + 4) = 0;
  if ( a1 == 3 )
  {
    result = sub_1003E2C0(0, 176, a2);
  }
  else if ( a1 == 4 )
  {
    result = sub_1003E2C0(0, 183, a2);
  }
  return result;
}

//----- (10052850) --------------------------------------------------------
unsigned __int8 __cdecl sub_10052850(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int8 result; // al@1

  result = a2;
  if ( a2 + 1 >= 1 && a2 <= 0x3Fu )
  {
    result = a1;
    if ( (unsigned __int8)(a1 - 3) <= 1u )
      result = sub_1006A190(dword_100E4148[a1], (int)&a2, 1);
  }
  return result;
}
// 100E4148: using guessed type int dword_100E4148[];

//----- (10052890) --------------------------------------------------------
int __cdecl sub_10052890(char a1, _DWORD *a2)
{
  int result; // eax@1
  char v3; // [sp+4h] [bp-18h]@1
  int v4; // [sp+8h] [bp-14h]@1

  LOBYTE(result) = sub_10052800(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (100528D0) --------------------------------------------------------
char __cdecl sub_100528D0(char a1)
{
  return byte_100E5009[2 * (unsigned __int8)sub_1003B860(&a1, 1u, (int)&unk_100E5008, 2, 4, 3)];
}

//----- (10052900) --------------------------------------------------------
char __cdecl sub_10052900(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_1003E2C0(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_100364C0("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_10056440(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_1003E2C0(1, 538, a2);
  }
  if ( !v4 || sub_10043090((int)v3) )
    return 0;
  return 1;
}

//----- (10052980) --------------------------------------------------------
int __cdecl sub_10052980(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_10052900(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (100529D0) --------------------------------------------------------
void __cdecl sub_100529D0(char a1, char a2)
{
  if ( (unsigned __int8)a2 <= 0x3Fu )
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sub_1006A190(2011, (int)&a2, 1);
      }
      else
      {
        if ( a1 == 2 )
          sub_100564B0(a2);
        sub_100364C0("..\\lib\\acl\\iop\\iop_com_intf.c", 658, 0, 0);
      }
    }
    else
    {
      sub_1006A190(2010, (int)&a2, 1);
    }
  }
}

//----- (10052A40) --------------------------------------------------------
char *__cdecl sub_10052A40(char *a1)
{
  char *v1; // esi@1
  signed int v2; // edi@1
  char *result; // eax@2
  char v4; // [sp+Ch] [bp-5BCh]@1
  char v5; // [sp+1Ch] [bp-5ACh]@1
  char v6[720]; // [sp+24h] [bp-5A4h]@2
  char v7[16]; // [sp+2F4h] [bp-2D4h]@1
  char v8[704]; // [sp+304h] [bp-2C4h]@2

  sub_1006A0A0(6120, (int)&v4, 744);
  sub_1006A0A0(6466, (int)v7, 720);
  strncpy(a1, &v4, 0x10u);
  strncpy(a1 + 16, &v5, 8u);
  v1 = a1 + 40;
  v2 = 0;
  do
  {
    strncpy(v1 - 16, &v6[v2], 0x10u);
    strncpy(v1, &v1[&v4 - a1], 8u);
    strncpy(v1 + 704, &v7[v2], 0x10u);
    result = strncpy(v1 + 720, &v8[v2], 8u);
    v2 += 24;
    v1 += 24;
  }
  while ( v2 < 720 );
  return result;
}
// 10052A40: using guessed type char var_2D4[16];
// 10052A40: using guessed type char var_5A4[720];
// 10052A40: using guessed type char var_2C4[704];

//----- (10052B30) --------------------------------------------------------
int __cdecl sub_10052B30(char a1)
{
  return sub_1003B860(&a1, 1u, (int)"7", 8, 2, 2);
}

//----- (10052B50) --------------------------------------------------------
BOOL __cdecl sub_10052B50(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_1003BB10(a1);
  return sub_1003E2C0(0, 604, a2) && sub_1003DC90(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (10052BB0) --------------------------------------------------------
int __usercall sub_10052BB0@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_10052B30(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_100E5034[2 * v1];
  return result;
}
// 100E5034: using guessed type int dword_100E5034[];

//----- (10052BE0) --------------------------------------------------------
BOOL __cdecl sub_10052BE0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10052BB0(a1);
  return sub_1006A0A0(v2, a2, 16) == 0;
}

//----- (10052C10) --------------------------------------------------------
int __cdecl sub_10052C10(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_10052BE0(a1, (int)a5);
  else
    result = sub_10052B50(a1, a5);
  return result;
}

//----- (10052C40) --------------------------------------------------------
char __cdecl sub_10052C40(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_1003E2F0(1, 1947, a1, (int)&v3);
}

//----- (10052C60) --------------------------------------------------------
BOOL __cdecl sub_10052C60(int a1)
{
  return sub_1006A0A0(6792, a1, 284) == 0;
}

//----- (10052C80) --------------------------------------------------------
char __cdecl sub_10052C80(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_10052C60((int)a5);
  else
    result = sub_10052C40(a5);
  return result;
}

//----- (10052CB0) --------------------------------------------------------
bool __cdecl sub_10052CB0(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_1003B860(&a2, 4u, (int)&dword_100E5EA8, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_1006A0A0((unsigned __int16)word_100E5EAC[a1 + 6 * v3], a3, (unsigned __int16)word_100E5EB0[6 * v3]) == 0;
  }
  else
  {
    sub_100364C0("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 100E5EA8: using guessed type int dword_100E5EA8;
// 100E5EAC: using guessed type __int16 word_100E5EAC[];
// 100E5EB0: using guessed type __int16 word_100E5EB0[];

//----- (10052D40) --------------------------------------------------------
bool __cdecl sub_10052D40(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_10068D80(a1);
  v6 = sub_1003B860(&a3, 1u, (int)&unk_100E5ECC, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_1003B860(&dword_100E5ED0[2 * v6], 4u, (int)&dword_100E5EA8, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_100E5EB0[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_10052CB0(v11, *(int *)((char *)&dword_100E5EA8 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100E5EA8: using guessed type int dword_100E5EA8;
// 100E5EB0: using guessed type __int16 word_100E5EB0[];

//----- (10052DE0) --------------------------------------------------------
bool __cdecl sub_10052DE0(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_1006A0A0((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (10052E20) --------------------------------------------------------
signed int __usercall sub_10052E20@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (10052E40) --------------------------------------------------------
bool __cdecl sub_10052E40(char a1, void *a2)
{
  int v2; // esi@1
  int v3; // edx@1
  int v4; // ecx@1
  bool result; // al@5
  void *v6; // ecx@6
  int v7; // [sp+Ch] [bp-28h]@4
  char v8; // [sp+10h] [bp-24h]@2
  int v9; // [sp+24h] [bp-10h]@3
  __int16 v10; // [sp+28h] [bp-Ch]@8
  int v11; // [sp+2Ch] [bp-8h]@8

  v2 = sub_10052E20(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online(v4, v3)) == v2
    && sub_1003DC90(1, 0x6ACu, (int)&v8)
    && v9 == v2
    && sub_1003E2F0(1, 1708, a2, (int)&v7) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_10052DE0(a1, a2);
  }
  else
  {
    v11 = sub_10037130(v6);
    v10 = 1708;
    sub_1003DDF0(1, 0, &v10, 0, 8, 1);
    sub_1003DF30(1, 0, v2);
    result = 0;
  }
  return result;
}
// 1006BB50: using guessed type int __fastcall j_HWM_pvg_hsdb_get_lrus_online(_DWORD, _DWORD);
// 1006BBD0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10052F30) --------------------------------------------------------
bool __cdecl sub_10052F30(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_10052DE0(a1, a5);
  else
    result = sub_10052E40(a1, a5);
  return result;
}

//----- (10052F60) --------------------------------------------------------
BOOL __cdecl sub_10052F60(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (10052F70) --------------------------------------------------------
BOOL __usercall sub_10052F70@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_10052F60(a1) && *v2 < 3u && a2 == 24;
}

//----- (10052FA0) --------------------------------------------------------
bool __cdecl sub_10052FA0(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_10052F60(a1) )
    {
      v6 = 10 * v5;
      if ( sub_100394C0((unsigned __int8)byte_100E72E8[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_1003E2C0(1, (unsigned __int16)word_100E72E0[v6], &Tm.tm_mon) || sub_10043040((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_10052980(a1, &v15) || v15 != dword_100E7300[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_1003E2C0(1, (unsigned __int16)word_100E72E4[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 100E72E0: using guessed type __int16 word_100E72E0[];
// 100E72E4: using guessed type __int16 word_100E72E4[];
// 100E7300: using guessed type int dword_100E7300[];

//----- (10053150) --------------------------------------------------------
bool __cdecl sub_10053150(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_10052F60(a1) )
    result = sub_1006A0A0((unsigned __int16)word_100E72EA[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 100E72EA: using guessed type __int16 word_100E72EA[];

//----- (10053190) --------------------------------------------------------
bool __cdecl sub_10053190(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_100528D0(a1);
  if ( !(unsigned __int8)sub_10052F70(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_10052FA0(v9, a3, *a4, (int)a5);
  if ( sub_100394C0((unsigned __int8)byte_100E72E8[20 * v6], (bool *)&v8) && v8 && sub_10053150(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 10053190: using guessed type int var_20[7];

//----- (10053280) --------------------------------------------------------
char sub_10053280()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_1003E2C0(1, 1309, &v1) )
    sub_10043180((int)&v1);
  return 0;
}

//----- (10053320) --------------------------------------------------------
BOOL __cdecl sub_10053320(int a1, int a2)
{
  return sub_1006A0A0(6455, a2, 252) == 0;
}

//----- (10053340) --------------------------------------------------------
char __cdecl sub_10053340(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10053320(a1, a5);
  }
  else
  {
    result = sub_10053280();
  }
  return result;
}

//----- (10053380) --------------------------------------------------------
char __cdecl sub_10053380(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_106CA780, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_100364C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_10052520(a1, (int)byte_106CA780);
    v3 = 4 * a2 - 64;
    v4 = byte_106CA781[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_106CA780[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (10053420) --------------------------------------------------------
bool __cdecl sub_10053420(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_106CA780, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_100364C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_10052520(a1, (int)byte_106CA780);
    v3 = (char *)&unk_106CA820 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (100534A0) --------------------------------------------------------
char __cdecl sub_100534A0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_106CA780, 0, 0x890u);
  sub_10052520(a1, (int)byte_106CA780);
  if ( a2 > 0x10u )
  {
    sub_100364C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_106CAAF0[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_106CAAF4[2 * a2];
    result = 1;
  }
  return result;
}
// 106CAAF0: using guessed type int dword_106CAAF0[];
// 106CAAF4: using guessed type int dword_106CAAF4[];

//----- (10053510) --------------------------------------------------------
char __cdecl sub_10053510(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_1003E2C0(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_1003E2C0(0, 572, a2);
    }
    else
    {
      sub_100364C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_1003E2C0(0, 226, a2);
  }
  return result;
}

//----- (10053590) --------------------------------------------------------
char __cdecl sub_10053590(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_106CA780, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_100364C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10053510(a1, byte_106CA780);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_106CA781[v4];
    *(_BYTE *)a3 = byte_106CA780[v4];
  }
  return result;
}

//----- (10053610) --------------------------------------------------------
char __cdecl sub_10053610(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_106CA780, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_100364C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10053510(a1, byte_106CA780);
    v4 = (char *)&unk_106CA820 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (10053690) --------------------------------------------------------
char __cdecl sub_10053690(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_106CA780, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_10053510(a1, byte_106CA780);
    *(_DWORD *)a3 = dword_106CAAF0[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_106CAAF4[2 * a2];
  }
  else
  {
    sub_100364C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 106CAAF0: using guessed type int dword_106CAAF0[];
// 106CAAF4: using guessed type int dword_106CAAF4[];

//----- (10053700) --------------------------------------------------------
char __cdecl sub_10053700(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10068E00(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_100534A0(v6, *a4, a5);
    else
      result = sub_10053690(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_10053380(v6, *a4, a5);
    else
      result = sub_10053590(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_100364C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_10053420(v6, *a4, a5);
    else
      result = sub_10053610(v6, *a4, a5);
  }
  return result;
}

//----- (10053810) --------------------------------------------------------
BOOL sub_10053810()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_10039400(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (10053870) --------------------------------------------------------
char __cdecl sub_10053870(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_1003E2C0(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_10053810() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_100426F0((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (10053960) --------------------------------------------------------
BOOL __cdecl sub_10053960(int a1, int a2)
{
  return sub_1006A0A0(6200, a2, 60) == 0;
}

//----- (10053980) --------------------------------------------------------
char __cdecl sub_10053980(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10053960(a1, (int)a5);
  }
  else
  {
    result = sub_10053870(a1, a5);
  }
  return result;
}

//----- (100539C0) --------------------------------------------------------
char __cdecl sub_100539C0(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_1003E2C0(2, 284, &v6) || sub_10042E60((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (10053A70) --------------------------------------------------------
BOOL __cdecl sub_10053A70(int a1, int a2)
{
  return sub_1006A0A0(6169, a2, 40) == 0;
}

//----- (10053A90) --------------------------------------------------------
char __cdecl sub_10053A90(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10053A70(a1, a5);
  }
  else
  {
    result = sub_100539C0(a1, a5);
  }
  return result;
}

//----- (10053AD0) --------------------------------------------------------
char __cdecl sub_10053AD0(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_1003E2C0(2, 363, a1);
}

//----- (10053AF0) --------------------------------------------------------
char __cdecl sub_10053AF0(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_1006A0A0(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (10053C40) --------------------------------------------------------
bool __thiscall sub_10053C40(void *this)
{
  return (sub_10036FC0(this) & 0x8000) == 0x8000;
}

//----- (10053C60) --------------------------------------------------------
char __cdecl sub_10053C60(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_10053AF0(a5);
      else
        result = sub_10053AD0(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_10053AF0(&unk_106CB010);
      else
        v7 = sub_10053AD0(&unk_106CB010);
      v8 = v7;
      memcpy_0(a5, (char *)&unk_106CB010 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_10053AF0(&unk_106CB010);
      else
        v9 = sub_10053AD0(&unk_106CB010);
      v10 = v9;
      memcpy_0(a5, (char *)&unk_106CDF18 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_10053AF0(&unk_106CB010);
      else
        v11 = sub_10053AD0(&unk_106CB010);
      v12 = v11;
      memcpy_0(a5, (char *)&unk_106CE418 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_10053AF0(&unk_106CB010);
      else
        v13 = sub_10053AD0(&unk_106CB010);
      v14 = v13;
      memcpy_0(a5, &unk_106CE4C0, a6);
      result = v14;
      break;
    default:
      sub_100364C0("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10053E00) --------------------------------------------------------
char __cdecl sub_10053E00(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_100364C0("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10053E40) --------------------------------------------------------
__int16 __usercall sub_10053E40@<ax>(unsigned __int8 a1@<al>)
{
  return word_100EB2E8[a1];
}
// 100EB2E8: using guessed type __int16 word_100EB2E8[];

//----- (10053E50) --------------------------------------------------------
char __cdecl sub_10053E50(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_10053E40(a1);
    if ( sub_1003E2F0(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (10053F20) --------------------------------------------------------
char __cdecl sub_10053F20(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_10053E00(a1);
  if ( a3 != 11 )
  {
    sub_100364C0("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_10053E50(v7, a5);
  }
  else
  {
    sub_100364C0("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10053FA0) --------------------------------------------------------
char __cdecl sub_10053FA0(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_100691C0(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10068FC0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10069040(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_100690C0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_10069140(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (100540B0) --------------------------------------------------------
int __cdecl sub_100540B0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1003B860(&a1, 1u, (int)&unk_100EBB20, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_100364C0("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_100EBB24[2 * v1];
  }
  return result;
}
// 100EBB24: using guessed type int dword_100EBB24[];

//----- (10054100) --------------------------------------------------------
char __cdecl sub_10054100(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_10052550(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_1006A0A0(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_10052570((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (10054270) --------------------------------------------------------
int __usercall sub_10054270@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_10054100(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 10054270: using guessed type int var_2C[10];

//----- (100542B0) --------------------------------------------------------
int __usercall sub_100542B0@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_10054100(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 100542B0: using guessed type int var_14[4];

//----- (100542F0) --------------------------------------------------------
signed int sub_100542F0()
{
  return sub_1006C8D0((int)&off_100EC9F0);
}
// 100EC9F0: using guessed type char *off_100EC9F0;

//----- (10054300) --------------------------------------------------------
char __cdecl sub_10054300(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_100542F0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_10789704 + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_10789704 + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_10789704);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10789704: using guessed type int dword_10789704;

//----- (10054360) --------------------------------------------------------
char __cdecl sub_10054360(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_100542F0() )
  {
    if ( (sub_100546B0(a1)
       || *(_BYTE *)(dword_10789704 + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_10789704 + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_10789704 + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10789704 + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10789704 + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10789704 + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10789704 + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10789704 + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10789704 + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10789704 + 176))
      && *(_BYTE *)(dword_10789704 + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_10789704 + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_10789704 + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_10789704 + 162) )
    {
      qmemcpy(a2, (const void *)(dword_10789704 + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10789704: using guessed type int dword_10789704;

//----- (10054480) --------------------------------------------------------
char __cdecl sub_10054480(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_100542F0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_10789704 + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_10789704 + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_10789704 + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_10789704 + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_10789704);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10789704: using guessed type int dword_10789704;

//----- (10054500) --------------------------------------------------------
char __cdecl sub_10054500(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_100364C0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_100542B0(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_10054480(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_100364C0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_10054270(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_10054300(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_100364C0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_10054100(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_10054360(v6, a5);
        }
      }
      else
      {
        sub_100364C0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_100364C0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (100546B0) --------------------------------------------------------
char __cdecl sub_100546B0(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_1003C1D0(11);
  }
  else
  {
    result = sub_1003C1D0(5);
  }
  return result;
}

//----- (100546E0) --------------------------------------------------------
char __cdecl sub_100546E0(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10054700) --------------------------------------------------------
int __cdecl sub_10054700(int a1, int a2)
{
  return sub_10069800(1, a1, a2, 1);
}

//----- (10054720) --------------------------------------------------------
int __cdecl sub_10054720(int a1, int a2, int a3)
{
  return sub_10069800(1, a1, a2, a3);
}

//----- (10054740) --------------------------------------------------------
int __cdecl sub_10054740(char a1, int a2, int a3, int a4)
{
  return sub_10069800(8 * (a1 == 0) + 2, a2, a3, a4);
}

//----- (10054760) --------------------------------------------------------
char __cdecl sub_10054760(int a1, int a2, char a3)
{
  if ( a3 )
    sub_10069800(11, a1, a2, 1);
  return 0;
}

//----- (10054780) --------------------------------------------------------
int __cdecl sub_10054780(int a1, int a2)
{
  if ( sub_100370A0() )
    sub_10069800(14, a1, a2, 1);
  return sub_10069800(11, a1, a2, 1);
}

//----- (100547C0) --------------------------------------------------------
char __cdecl sub_100547C0(char a1)
{
  return sub_1003DDF0(1, 43, &a1, 0, 1, 1);
}

//----- (100547E0) --------------------------------------------------------
char __thiscall sub_100547E0(void *this)
{
  char v2; // [sp+0h] [bp-4h]@1

  v2 = 1;
  if ( sub_10044670(this) == 1 )
    v2 = 2;
  return sub_100547C0(v2);
}

//----- (10054810) --------------------------------------------------------
__int16 __thiscall sub_10054810(void *this)
{
  return word_100F15A8[(unsigned __int8)sub_10038600(this)];
}
// 100F15A8: using guessed type __int16 word_100F15A8[];

//----- (10054830) --------------------------------------------------------
char __cdecl sub_10054830(void *a1)
{
  void *v1; // ecx@0
  __int16 v2; // si@1

  v2 = sub_10054810(v1);
  sub_1003DDF0(1, (unsigned __int16)v2, a1, 0, 8, 1);
  return sub_1003DF30(1, v2, 0xFFFFFFF);
}

//----- (10054860) --------------------------------------------------------
char __cdecl sub_10054860(int a1, char a2, char a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  if ( a2 == 1 )
    v4 = a1;
  LOBYTE(v5) = a3;
  return sub_10054830(&v4);
}

//----- (10054890) --------------------------------------------------------
char __cdecl sub_10054890(char a1, char a2)
{
  int v3; // [sp+0h] [bp-8h]@1
  int v4; // [sp+4h] [bp-4h]@1

  v4 = 0;
  v3 = 0;
  BYTE1(v4) = a1;
  LOBYTE(v4) = a2;
  return sub_10054830(&v3);
}

//----- (100548C0) --------------------------------------------------------
char __cdecl sub_100548C0(char a1, char a2)
{
  int v3; // [sp+0h] [bp-8h]@1
  int v4; // [sp+4h] [bp-4h]@1

  v4 = 0;
  v3 = 0;
  BYTE3(v4) = a1;
  LOBYTE(v4) = a2;
  return sub_10054830(&v3);
}

//----- (100548F0) --------------------------------------------------------
int __cdecl sub_100548F0(int a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  int v3; // ebx@1
  signed int v4; // ebp@3
  signed int v5; // edi@3
  double v6; // st7@5
  int v7; // esi@9
  int v8; // eax@10
  double v9; // st7@19
  float v10; // ST34_4@25
  double v11; // st7@25
  signed int v12; // ecx@25
  int v13; // edi@25
  char v14; // al@32
  int v15; // edi@37
  float v16; // ST40_4@37
  signed int v17; // esi@37
  char v18; // bl@39
  float v19; // ST40_4@41
  double v20; // st7@41
  signed int v21; // eax@41
  bool v22; // sf@41
  unsigned __int8 v23; // of@41
  signed int v24; // ebp@41
  float v25; // ST40_4@50
  double v26; // st7@50
  signed int v27; // eax@50
  bool v28; // sf@50
  unsigned __int8 v29; // of@50
  float v30; // ST40_4@65
  float v32; // [sp+8h] [bp-D4h]@0
  float v33; // [sp+18h] [bp-C4h]@17
  signed int v34; // [sp+18h] [bp-C4h]@25
  signed int v35; // [sp+1Ch] [bp-C0h]@7
  signed int v36; // [sp+1Ch] [bp-C0h]@37
  char v37; // [sp+23h] [bp-B9h]@1
  char v38; // [sp+2Ah] [bp-B2h]@17
  char v39; // [sp+2Bh] [bp-B1h]@17
  int v40; // [sp+2Ch] [bp-B0h]@5
  float v41; // [sp+30h] [bp-ACh]@5
  int v42; // [sp+34h] [bp-A8h]@5
  float v43; // [sp+38h] [bp-A4h]@17
  float v44; // [sp+3Ch] [bp-A0h]@5
  float v45; // [sp+40h] [bp-9Ch]@17
  float v46; // [sp+44h] [bp-98h]@17
  char v47; // [sp+48h] [bp-94h]@17
  float v48; // [sp+80h] [bp-5Ch]@17

  v2 = sub_100368B0(v1);
  v3 = dword_10789FA0;
  v37 = *(_BYTE *)(dword_10789FA0 + 31462);
  if ( v2 == 1 )
  {
    if ( *(_BYTE *)(dword_10789FA0 + 31483) )
    {
      v4 = 50;
      v5 = 500;
    }
    else
    {
      v4 = 10;
      v5 = 100;
    }
    v41 = 1.0;
    v44 = 1.0;
    v40 = (signed int)sub_10022C70(-304.79999, 1.0);
    v6 = sub_10022C70(45720.0, 1.0);
    v3 = dword_10789FA0;
    v42 = (signed int)v6;
  }
  else
  {
    v4 = 100;
    v5 = 1000;
    v41 = 3.2808399;
    v40 = -1000;
    v42 = 150000;
    v44 = 0.3048;
  }
  v35 = v5;
  if ( *(_WORD *)(a1 + 10) != 65 )
    v35 = v4;
  v7 = *(_BYTE *)(a1 + 8);
  if ( *(_BYTE *)(a1 + 8) )
  {
    v8 = abs(v7) - 1;
    if ( v8 >= 9 )
      v8 = 9;
    if ( v35 == v5 )
      v7 = *(_BYTE *)(v3 + v8 + 31473);
    else
      v7 = *(_BYTE *)(v3 + v8 + 31463);
    if ( *(_BYTE *)(a1 + 8) < 0 )
      v7 = -v7;
  }
  v46 = 0.0;
  v38 = 0;
  sub_1006A100(9121, &v39, 1, &v38);
  sub_1006A100(9120, &v45, 4, &v46);
  v33 = sub_10044DA0();
  sub_10081390(&v47);
  v43 = 0.0;
  if ( v48 == 9.9999996e24 || 9.8999998e24 == v48 )
  {
    v9 = 9.8999998e24;
  }
  else
  {
    v9 = 9.8999998e24;
    v43 = v48;
  }
  if ( v9 == v33 )
  {
    v33 = sub_10045030(v32);
    if ( v7 >= 0 )
      --v7;
    else
      ++v7;
  }
  v10 = v33 * v41;
  v11 = sub_10022C70(v10, 1.0);
  v12 = v35;
  v13 = (signed int)v11;
  v34 = (signed int)v11;
  if ( !v37 )
    v12 = v4;
  if ( v13 % v12 )
  {
    if ( v7 >= 0 )
    {
      if ( v7 <= 0 )
      {
        v14 = *(_BYTE *)(a1 + 8);
        if ( v14 <= 0 )
        {
          if ( v14 >= 0 )
            sub_100364C0("..\\lib\\adl\\cdp_cmsg_cmn_pfd.c", 360, 0, 0);
          else
            v13 = sub_10022A50((signed int)v11, v12);
        }
        else
        {
          v13 = sub_10022970((signed int)v11, v12);
        }
      }
      else
      {
        v13 = sub_10022970((signed int)v11, v12);
        --v7;
      }
    }
    else
    {
      v13 = sub_10022A50((signed int)v11, v12);
      ++v7;
    }
  }
  v15 = v35 * v7 + v13;
  v36 = v15;
  v16 = *(float *)(dword_10789FA0 + 28124) * v41;
  v17 = (signed int)sub_10022C70(v16, 1.0);
  if ( v17 >= v42 )
    v17 = v42;
  v18 = 0;
  if ( v39 != 1 || v45 == 9.8999998e24 )
  {
    v24 = v34;
  }
  else
  {
    v19 = v45 * v41;
    v20 = sub_10022C70(v19, 1.0);
    v21 = (signed int)v20;
    v23 = __OFSUB__((signed int)v20, v15);
    v22 = (signed int)v20 - v15 < 0;
    v24 = v34;
    if ( (signed int)v20 > v15 )
    {
      if ( v21 < v34 )
      {
        v40 = (signed int)v20;
        v18 = 1;
        goto LABEL_49;
      }
      v23 = __OFSUB__(v21, v15);
      v22 = v21 - v15 < 0;
    }
    if ( v22 ^ v23 && v21 > v34 )
    {
      v17 = (signed int)v20;
      v18 = 1;
    }
  }
LABEL_49:
  if ( v43 == 0.0 )
    goto LABEL_61;
  v25 = v43 * v41;
  v26 = sub_10022C70(v25, 1.0);
  v27 = (signed int)v26;
  v29 = __OFSUB__((signed int)v26, v15);
  v28 = (signed int)v26 - v15 < 0;
  if ( (signed int)v26 > v15 )
  {
    if ( v27 < v24 )
    {
      if ( !v18 || v40 <= v27 )
        v40 = (signed int)v26;
      goto LABEL_61;
    }
    v29 = __OFSUB__(v27, v15);
    v28 = v27 - v15 < 0;
  }
  if ( v28 ^ v29 && v27 > v24 && (!v18 || v17 >= v27) )
    v17 = (signed int)v26;
LABEL_61:
  if ( v15 <= v40 )
  {
    v15 = v40;
    v36 = v40;
  }
  if ( v15 >= v17 )
    v36 = v17;
  v30 = (double)v36 * v44;
  return sub_10044ED0(v30);
}
// 10789FA0: using guessed type int dword_10789FA0;

//----- (10054CB0) --------------------------------------------------------
char sub_10054CB0()
{
  char result; // al@1
  double v1; // st7@2
  double v2; // st7@4
  float v3; // [sp+8h] [bp-8h]@1
  float v4; // [sp+Ch] [bp-4h]@2

  result = sub_10044530(&v3);
  if ( result )
  {
    v3 = v3 * 3.280839920043945;
    v3 = sub_10022C70(v3, 10.0);
    v4 = *(float *)(dword_10789FA0 + 28124) * 3.280839920043945;
    v4 = sub_10022C70(v4, 10.0);
    v1 = v4;
    if ( v4 > 150000.0 )
      v1 = 150000.0;
    v4 = v1;
    v2 = v3;
    if ( v4 <= (double)v3 )
      v2 = v4;
    v4 = v2;
    v3 = v4 * 0.3048000037670135;
    result = sub_10044ED0(v3);
  }
  return result;
}
// 10789FA0: using guessed type int dword_10789FA0;

//----- (10054D80) --------------------------------------------------------
char __cdecl sub_10054D80(int a1)
{
  char v1; // cl@1
  int v2; // esi@1
  int v3; // eax@2
  char v4; // cl@6
  char result; // al@7

  v1 = *(_BYTE *)(a1 + 8);
  v2 = *(_BYTE *)(a1 + 8);
  if ( *(_BYTE *)(a1 + 8) )
  {
    v3 = abs(v2) - 1;
    if ( v3 >= 9 )
      v3 = 9;
    v2 = *(_BYTE *)(dword_10789FA0 + v3 + 33300);
    if ( v1 < 0 )
      v2 = -v2;
  }
  sub_10044E90(v1);
  sub_100812D0();
  if ( sub_10044E90(v4) || (result = sub_100812D0(), result == 1) )
    result = sub_10055920(v2);
  return result;
}
// 10789FA0: using guessed type int dword_10789FA0;

//----- (10054DE0) --------------------------------------------------------
char __cdecl sub_10054DE0(int a1)
{
  char v1; // bl@1
  int v2; // edx@1
  int v3; // ecx@1
  char result; // al@4
  void *v5; // ecx@7
  __int16 v6; // cx@14
  double v7; // st7@19
  char v8; // [sp+12h] [bp-66h]@2
  char v9; // [sp+13h] [bp-65h]@4
  int v10; // [sp+14h] [bp-64h]@7
  char v11; // [sp+1Bh] [bp-5Dh]@1
  int v12; // [sp+1Ch] [bp-5Ch]@7
  float v13; // [sp+20h] [bp-58h]@1
  int v14; // [sp+24h] [bp-54h]@4
  float v15; // [sp+28h] [bp-50h]@1
  float v16; // [sp+2Ch] [bp-4Ch]@1
  float v17; // [sp+30h] [bp-48h]@6
  int v18; // [sp+34h] [bp-44h]@6
  char v19; // [sp+38h] [bp-40h]@1

  v1 = sub_10044C20(&v19);
  sub_10044530(&v15);
  v11 = sub_10044290(&v13);
  v16 = sub_10044DA0();
  if ( !v1 || (v8 = 1, !(unsigned __int8)sub_100447C0((int)&v19)) )
    v8 = 0;
  v9 = 1;
  LOBYTE(v14) = 1;
  result = sub_10069300(v3, v2);
  if ( result && v11 )
  {
    sub_10044730(&v17);
    if ( (_BYTE)v18 )
    {
      *(float *)&v10 = v17;
      sub_10069480(v17, v13, (int)&v12);
      *(float *)&v12 = sub_10022C70(*(float *)&v12, 0.51444447);
    }
    else
    {
      *(float *)&v12 = v17;
      sub_10069410(v17, v13, (int)&v10);
      *(float *)&v10 = sub_10022C70(*(float *)&v10, 0.0099999998);
    }
    if ( !v1 || v8 )
      return sub_1006A190(9863, (int)&v9, 1);
    if ( sub_10044700(v5) != 1 && *(_BYTE *)(dword_10789FA0 + 31728) & 0x80 )
    {
      sub_100443F0(&v10);
      *(float *)&v10 = sub_10022C70(*(float *)&v10, 0.0099999998);
      sub_100442F0((float *)&v12);
      *(float *)&v12 = sub_10022C70(*(float *)&v12, 0.51444447);
    }
    v6 = *(_WORD *)(dword_10789FA0 + 31728);
    if ( v6 & 1 || *(_WORD *)(a1 + 10) == 16479 || v15 >= (double)v16 && v6 & 0x10 )
    {
      LOBYTE(v18) = 0;
    }
    else if ( (_BYTE)v18 )
    {
      v7 = *(float *)&v10;
LABEL_20:
      v17 = v7;
      if ( sub_10069260(v18) )
      {
        sub_10044830(v17, v18, v14);
        sub_1006A190(41117, (int)&v14, 1);
      }
      return sub_1006A190(9863, (int)&v9, 1);
    }
    v7 = *(float *)&v12;
    goto LABEL_20;
  }
  return result;
}
// 10789FA0: using guessed type int dword_10789FA0;

//----- (10055020) --------------------------------------------------------
int __cdecl sub_10055020(int a1)
{
  int v1; // esi@1
  int v2; // eax@2
  int v3; // eax@6
  int v4; // eax@6

  v1 = *(_BYTE *)(a1 + 8);
  if ( *(_BYTE *)(a1 + 8) )
  {
    v2 = abs(v1) - 1;
    if ( v2 >= 9 )
      v2 = 9;
    v1 = *(_BYTE *)(dword_10789FA0 + v2 + 33290);
    if ( *(_BYTE *)(a1 + 8) < 0 )
      v1 = -v1;
  }
  v3 = sub_10044640();
  v4 = 11930465 * v1 + sub_10022C20(v3, 11930464);
  return sub_10044810(v4);
}
// 10789FA0: using guessed type int dword_10789FA0;

//----- (10055080) --------------------------------------------------------
int __cdecl sub_10055080(char a1)
{
  int result; // eax@3
  int v2; // [sp+4h] [bp-8h]@1
  float v3; // [sp+8h] [bp-4h]@2

  v2 = 0;
  if ( sub_10037170() && sub_1003F060(&v3) )
  {
    sub_100451D0((int)&v2, v3);
    v2 -= sub_100812B0(0);
    result = sub_10044810(v2);
  }
  else if ( a1 )
  {
    sub_100440E0(&v2);
    result = sub_10044810(v2);
  }
  else
  {
    sub_100440B0(0, &v2);
    result = sub_10044810(v2);
  }
  return result;
}

//----- (10055110) --------------------------------------------------------
char __cdecl sub_10055110(int a1)
{
  __int64 v1; // rax@1
  void *v2; // ecx@1
  bool v3; // bl@6
  int v4; // edi@8
  bool v5; // zf@17
  double v6; // st7@38
  signed int v7; // ecx@38
  float v8; // ST28_4@43
  signed int v9; // eax@45
  int v10; // eax@47
  int v11; // eax@48
  char v12; // al@50
  int v13; // eax@51
  int v14; // eax@52
  __int16 v15; // si@54
  char v16; // ST10_1@54
  int v17; // eax@54
  float v19; // [sp+4h] [bp-6Ch]@37
  char v20; // [sp+1Ah] [bp-56h]@2
  char v21; // [sp+1Bh] [bp-55h]@1
  float v22; // [sp+1Ch] [bp-54h]@37
  int v23; // [sp+20h] [bp-50h]@8
  float v24; // [sp+24h] [bp-4Ch]@37
  float v25; // [sp+28h] [bp-48h]@36
  int v26; // [sp+2Ch] [bp-44h]@36
  char v27; // [sp+30h] [bp-40h]@1
  char v28; // [sp+34h] [bp-3Ch]@21
  char v29; // [sp+3Fh] [bp-31h]@25
  char v30; // [sp+4Fh] [bp-21h]@2

  LOBYTE(v1) = sub_10044C20(&v27);
  v21 = v1;
  if ( !(_BYTE)v1 || (v20 = 1, !v30) )
    v20 = 0;
  v3 = (_BYTE)v1 && (unsigned __int8)sub_100447C0((int)&v27);
  LOBYTE(v2) = *(_BYTE *)(a1 + 8);
  v4 = *(_BYTE *)(a1 + 8);
  v23 = *(_BYTE *)(a1 + 8);
  if ( *(_WORD *)(a1 + 10) == 89 && *(_BYTE *)(a1 + 8) )
  {
    v1 = *(_BYTE *)(a1 + 8);
    LODWORD(v1) = abs(v4) - 1;
    if ( (signed int)v1 >= 9 )
      LODWORD(v1) = 9;
    v4 = *(_BYTE *)(dword_10789FA0 + v1 + 33280);
    v23 = *(_BYTE *)(dword_10789FA0 + v1 + 33280);
    if ( (char)v2 < 0 )
    {
      v4 = -v4;
      v23 = v4;
    }
  }
  if ( *(_BYTE *)(dword_10789FA0 + 31484) == 1 )
  {
    LOBYTE(v1) = sub_10044700(v2) == 0;
    v5 = (_BYTE)v1 == 0;
  }
  else
  {
    LOBYTE(v1) = *(_BYTE *)(dword_10789FA0 + 31484) - 2;
    if ( *(_BYTE *)(dword_10789FA0 + 31484) == 2 || v3 )
      goto LABEL_20;
    v5 = v20 == 0;
  }
  if ( v5 )
  {
    v9 = *(_WORD *)(a1 + 10);
    if ( v9 > 16396 )
    {
      v13 = v9 - 16398;
      if ( v13 )
      {
        v14 = v13 - 16382;
        if ( v14 )
        {
          LODWORD(v1) = v1 - 2;
          if ( (_DWORD)v1 )
            return v1;
        }
      }
    }
    else if ( v9 != 16396 )
    {
      v10 = v9 - 12;
      if ( v10 )
      {
        v11 = v10 - 2;
        if ( v11 )
        {
          LODWORD(v1) = v1 - 54;
          if ( !(_DWORD)v1 )
          {
            v12 = sub_1003C3C0(*(_BYTE *)(a1 + 16));
            LOBYTE(v1) = sub_10054890(v4, v12);
          }
          return v1;
        }
      }
    }
    v15 = *(_WORD *)(a1 + 10);
    v16 = sub_1003C3C0(*(_BYTE *)(a1 + 16));
    v17 = sub_1003C390(v15);
    LOBYTE(v1) = sub_10054860(v17, (unsigned __int16)(v15 & 0x8000) != 0x8000, v16);
    return v1;
  }
LABEL_20:
  if ( !v21
    || (v28 == 6 || v28 == 7 ? (LOBYTE(v2) = 1) : (LOBYTE(v2) = 0),
        v29 == 7 || v29 == 17 || v29 == 18 ? (LOBYTE(v1) = 1) : (LOBYTE(v1) = 0),
        !(_BYTE)v2 && !(_BYTE)v1) )
  {
    if ( !v20 )
    {
      if ( !sub_10069300((int)v2, SHIDWORD(v1)) )
      {
LABEL_41:
        LOBYTE(v1) = sub_10069800(14, a1, 20, 1);
        return v1;
      }
      LOWORD(v1) = *(_WORD *)(a1 + 10);
      if ( (_WORD)v1 != -32754 && (_WORD)v1 != -32756 )
      {
        sub_10044730(&v25);
        if ( (_BYTE)v26 )
        {
          v24 = 0.0099999998;
          v22 = v25;
          v19 = 0.0099999998;
          if ( v4 >= 0 )
          {
            v6 = sub_100229B0(v25, v19);
            v7 = -1;
          }
          else
          {
            v6 = sub_10022A90(v25, v19);
            v7 = 1;
          }
          v25 = v6;
          v8 = v22 - v25;
          if ( COERCE_FLOAT(LODWORD(v8) & 0x7FFFFFFF) > 0.00050000002 )
            v23 = v7 + v4;
        }
        else
        {
          v24 = 0.51444447;
          v25 = sub_10022C70(v25, 0.51444447);
        }
        v25 = (double)v23 * v24 + v25;
        v25 = sub_10022C70(v25, v24);
        sub_10044830(v25, v26, 0);
        goto LABEL_41;
      }
    }
  }
  return v1;
}
// 10789FA0: using guessed type int dword_10789FA0;

//----- (100553F0) --------------------------------------------------------
void sub_100553F0()
{
  char v0; // al@1
  char v1; // bl@1
  int v2; // edx@7
  void *v3; // ecx@12
  void *v4; // ecx@19
  bool v5; // zf@26
  double v6; // st7@27
  char v7; // [sp+12h] [bp-5Ah]@5
  char v8; // [sp+13h] [bp-59h]@2
  char v9; // [sp+14h] [bp-58h]@7
  char v10; // [sp+15h] [bp-57h]@7
  char v11; // [sp+16h] [bp-56h]@7
  char v12; // [sp+17h] [bp-55h]@7
  float v13; // [sp+18h] [bp-54h]@19
  float v14; // [sp+1Ch] [bp-50h]@29
  float v15; // [sp+20h] [bp-4Ch]@7
  int v16; // [sp+24h] [bp-48h]@7
  int v17; // [sp+28h] [bp-44h]@7
  char v18; // [sp+2Ch] [bp-40h]@1
  char v19; // [sp+3Bh] [bp-31h]@9
  char v20; // [sp+4Bh] [bp-21h]@2

  v0 = sub_10044C20(&v18);
  v1 = v0;
  if ( !v0 || (v8 = 1, !v20) )
    v8 = 0;
  if ( !v0 || (v7 = 1, !(unsigned __int8)sub_100447C0((int)&v18)) )
    v7 = 0;
  v15 = 2.0;
  v11 = sub_100443F0(&v15);
  v10 = 0;
  v9 = 0;
  v12 = sub_100396A0((bool *)&v9);
  *(float *)&v16 = 0.0;
  v17 = 0;
  if ( !(*(_BYTE *)(dword_10789FA0 + 31728) & 1)
    && (!v1 || v19 != 7 && v19 != 17 && v19 != 18)
    && sub_10069300(dword_10789FA0, v2) )
  {
    if ( *(_BYTE *)(dword_10789FA0 + 31484) == 1 )
    {
      if ( sub_10044700(v3) )
        return;
    }
    else if ( *(_BYTE *)(dword_10789FA0 + 31484) != 2 && !v7 )
    {
      return;
    }
    if ( !v8
      && sub_10044290(&v13)
      && sub_10044700(v4) != 1
      && (!(*(_WORD *)(dword_10789FA0 + 31728) & 0x100)
       || (!v12 || !v9) && (!v11 || *(float *)(dword_10789FA0 + 31360) < (double)v15)) )
    {
      sub_10044730(&v16);
      v5 = (_BYTE)v17 != 0;
      LOBYTE(v17) = (_BYTE)v17 == 0;
      if ( v5 )
      {
        sub_10069480(*(float *)&v16, v13, (int)&v16);
        v6 = 0.51444447;
      }
      else
      {
        sub_10069410(*(float *)&v16, v13, (int)&v16);
        v6 = 0.0099999998;
      }
      v14 = v6;
      *(float *)&v16 = sub_10022C70(*(float *)&v16, v14);
      if ( !v7 || sub_10069260(v17) )
      {
        sub_10044830(*(float *)&v16, v17, 0);
        v10 = 1;
        sub_1006A190(9863, (int)&v10, 1);
      }
    }
  }
}
// 10789FA0: using guessed type int dword_10789FA0;

//----- (10055650) --------------------------------------------------------
void __cdecl sub_10055650(int a1)
{
  int v1; // edx@1
  int v2; // ecx@1
  bool v3; // bl@3
  char v4; // al@10
  double v5; // st7@10
  float v6; // ST08_4@12
  char v7; // bl@12
  float v8; // [sp+Ch] [bp-48h]@9
  int v9; // [sp+10h] [bp-44h]@9
  char v10; // [sp+14h] [bp-40h]@1

  v3 = sub_10044C20(&v10) && (unsigned __int8)sub_100447C0((int)&v10);
  if ( sub_10069300(v2, v1) && v3 && *(_WORD *)(a1 + 10) == 101 && *(_BYTE *)(dword_10789FA0 + 31728) & 0x80 )
  {
    sub_10044730(&v8);
    if ( (_BYTE)v9 )
    {
      v4 = sub_100443F0(&v8);
      v5 = 0.0099999998;
    }
    else
    {
      v4 = sub_100442F0(&v8);
      v5 = 0.51444447;
    }
    v6 = v5;
    v7 = v4;
    v8 = sub_10022C70(v8, v6);
    if ( v7 )
      sub_10044830(v8, v9, 0);
  }
}
// 10789FA0: using guessed type int dword_10789FA0;

//----- (10055730) --------------------------------------------------------
double __cdecl sub_10055730(float a1, char a2)
{
  void *v2; // ecx@0
  double v3; // st7@2
  double result; // st7@3
  double v5; // st7@6
  float v6; // [sp+Ch] [bp+4h]@2
  float v7; // [sp+Ch] [bp+4h]@2
  float v8; // [sp+Ch] [bp+4h]@2
  float v9; // [sp+Ch] [bp+4h]@3
  float v10; // [sp+Ch] [bp+4h]@3
  float v11; // [sp+Ch] [bp+4h]@5
  float v12; // [sp+Ch] [bp+4h]@6
  float v13; // [sp+Ch] [bp+4h]@6
  float v14; // [sp+Ch] [bp+4h]@6
  float v15; // [sp+Ch] [bp+4h]@7
  float v16; // [sp+Ch] [bp+4h]@7
  float v17; // [sp+Ch] [bp+4h]@9

  if ( sub_10036B90(v2) == 15 )
  {
    v6 = a1 * 0.009999999776482582;
    v7 = v6 + (double)a2;
    v8 = sub_10022C70(v7, 1.0);
    v3 = 745.0;
    if ( v8 <= 745.0 || (v3 = 1101.0, v8 >= 1101.0) )
    {
      v9 = v3;
      v10 = v9 * 100.0;
      result = v10;
    }
    else
    {
      v11 = v8 * 100.0;
      result = v11;
    }
  }
  else
  {
    v12 = a1 * 0.000295300007564947;
    v13 = v12 + (double)a2 * 0.009999999776482582;
    v14 = sub_10022C70(v13, 0.0099999998);
    v5 = 22.0;
    if ( v14 <= 22.0 || (v5 = 32.5, v14 >= 32.5) )
    {
      v15 = v5;
      v16 = v15 * 3386.38671875;
      result = v16;
    }
    else
    {
      v17 = v14 * 3386.38671875;
      result = v17;
    }
  }
  return result;
}

//----- (10055870) --------------------------------------------------------
void __cdecl sub_10055870(int a1)
{
  double v1; // st7@2
  float v2; // ST00_4@4
  float v3; // ST04_4@4
  char v4; // [sp+4h] [bp-4h]@2

  if ( sub_10044E70() )
  {
    v4 = *(_BYTE *)(a1 + 8);
    v1 = sub_10044E80();
  }
  else
  {
    v1 = 101325.0;
    v4 = *(_BYTE *)(a1 + 8);
  }
  v2 = v1;
  v3 = sub_10055730(v2, v4);
  sub_10044F00(1, v3);
}
// 10044E80: using guessed type double sub_10044E80(void);

//----- (100558C0) --------------------------------------------------------
void sub_100558C0()
{
  void *v0; // ecx@1
  float v1; // ST00_4@2
  float v2; // ST04_4@2

  if ( sub_10044E70() == 1 )
  {
    sub_10044F00(0, 101325.0);
  }
  else
  {
    v1 = sub_10044E00(v0);
    v2 = sub_10055730(v1, 0);
    sub_10044F00(1, v2);
  }
}

//----- (10055910) --------------------------------------------------------
char sub_10055910()
{
  return sub_10045200(-32759, 0);
}

//----- (10055920) --------------------------------------------------------
unsigned __int8 __cdecl sub_10055920(int a1)
{
  int v1; // ecx@0
  char v2; // al@1
  void *v3; // ecx@1
  unsigned __int8 result; // al@2
  int v5; // eax@3
  int v6; // eax@3
  void *v7; // ecx@4
  int v8; // eax@5
  signed int v9; // ST14_4@5
  float v10; // [sp+4h] [bp-4h]@5

  v2 = sub_10044E90(v1);
  if ( v2 )
  {
    result = v2 - 1;
    if ( result <= 1u )
    {
      v5 = sub_100450B0(v3);
      v6 = sub_10022C20(v5, 11930464);
      result = sub_10044FD0(11930464 * a1 + v6);
    }
  }
  else
  {
    result = sub_100812D0();
    if ( result == 1 )
    {
      v8 = sub_100450B0(v7);
      v9 = (11930464 * a1 + sub_10022C20(v8, 11930464)) | 1;
      sub_10044FD0(v9);
      v10 = (double)v9 * 0.000000001462918079267163;
      result = sub_10045200(-32762, &v10);
    }
  }
  return result;
}

//----- (100559C0) --------------------------------------------------------
BOOL __cdecl sub_100559C0(void *a1)
{
  return sub_1003E2C0(0, 765, a1) && *(_BYTE *)(dword_10789FA0 + 33316);
}
// 10789FA0: using guessed type int dword_10789FA0;

//----- (100559F0) --------------------------------------------------------
char sub_100559F0()
{
  void *v0; // ecx@1
  unsigned int v1; // esi@2
  char *v2; // edi@2
  char result; // al@5
  char v4; // [sp+8h] [bp-78h]@1

  if ( (unsigned __int8)sub_100559C0(&v4) )
  {
    v1 = 0;
    v2 = &v4;
    while ( *(_DWORD *)v2 != sub_10037130(v0) )
    {
      ++v1;
      v2 += 40;
      if ( v1 >= 3 )
        goto LABEL_5;
    }
    result = 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (10055A60) --------------------------------------------------------
signed int __cdecl sub_10055A60(unsigned __int8 a1)
{
  void *v1; // ecx@0
  bool v2; // dl@2
  unsigned __int8 v3; // cl@2
  signed int v4; // ebp@8
  void *v5; // ecx@8
  unsigned __int8 v6; // bl@9
  signed int result; // eax@14
  int v8; // [sp+8h] [bp-250h]@0
  char v9[68]; // [sp+Ch] [bp-24Ch]@9
  char v10; // [sp+50h] [bp-208h]@2
  char v11[2]; // [sp+A8h] [bp-1B0h]@5
  char v12[426]; // [sp+AAh] [bp-1AEh]@4

  if ( sub_10053C40(v1) )
  {
    v2 = sub_1006A0A0(6444, (int)&v10, 514) == 0;
    v3 = 0;
    while ( !v2 || !v12[12 * v3] || !(a1 & (unsigned __int8)v11[v3]) )
    {
      if ( ++v3 >= 2u )
        goto LABEL_7;
    }
    result = 0x8000;
  }
  else
  {
LABEL_7:
    LOBYTE(v8) = 0;
    while ( 1 )
    {
      v4 = sub_1003CD70(v8);
      if ( (v4 & sub_10036FC0(v5)) == v4 )
        break;
LABEL_13:
      LOBYTE(v8) = v8 + 1;
      if ( (unsigned __int8)v8 >= 2u )
        return 0;
    }
    sub_100518B0(v8, v9);
    v6 = 0;
    while ( !sub_1003C000(v8, byte_100F2DF1[2 * v6]) || !(a1 & (unsigned __int8)v9[12 * v6]) )
    {
      if ( ++v6 >= 2u )
        goto LABEL_13;
    }
    result = v4;
  }
  return result;
}
// 10055A60: using guessed type char var_1AE[426];
// 10055A60: using guessed type char var_1B0[2];
// 10055A60: using guessed type char var_24C[68];

//----- (10055B90) --------------------------------------------------------
char __cdecl sub_10055B90(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // ecx@2
  int v5; // [sp+0h] [bp-Ch]@1
  __int16 v6; // [sp+4h] [bp-8h]@2
  int v7; // [sp+8h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_107896F0)(a1, 12, &v5);
  if ( result )
  {
    v3 = v6;
    *(_DWORD *)a2 = v5;
    v4 = v7 & 0xFFFFFF;
    *(_WORD *)(a2 + 4) = v3;
    *(_DWORD *)(a2 + 8) = v4;
    result = 1;
  }
  return result;
}
// 107896F0: using guessed type int dword_107896F0;

//----- (10055BE0) --------------------------------------------------------
char __cdecl sub_10055BE0(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  __int16 v4; // cx@2
  __int16 v5; // dx@2
  __int16 v6; // cx@2
  int v7; // edx@2
  __int16 v8; // cx@2
  unsigned int v9; // ecx@2
  int v10; // edx@2
  __int16 v11; // [sp+0h] [bp-1Ch]@1
  __int16 v12; // [sp+2h] [bp-1Ah]@2
  __int16 v13; // [sp+4h] [bp-18h]@2
  __int16 v14; // [sp+6h] [bp-16h]@2
  __int16 v15; // [sp+8h] [bp-14h]@2
  int v16; // [sp+Ah] [bp-12h]@2
  __int16 v17; // [sp+Eh] [bp-Eh]@2
  int v18; // [sp+12h] [bp-Ah]@2
  unsigned int v19; // [sp+16h] [bp-6h]@2
  char v20; // [sp+1Ah] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_107896F0)(a1, 27, &v11);
  if ( result )
  {
    v3 = v12;
    *(_WORD *)a2 = v11;
    v4 = v13;
    *(_WORD *)(a2 + 2) = v3;
    v5 = v14;
    *(_WORD *)(a2 + 4) = v4;
    v6 = v15;
    *(_WORD *)(a2 + 6) = v5;
    *(_DWORD *)(a2 + 12) = v16;
    v7 = v18;
    *(_WORD *)(a2 + 8) = v6;
    v8 = v17;
    *(_DWORD *)(a2 + 20) = v7;
    *(_WORD *)(a2 + 16) = v8;
    v9 = v19;
    *(_DWORD *)(a2 + 24) = v19 & 3;
    *(_DWORD *)(a2 + 28) = (v9 >> 2) & 1;
    v10 = (v9 >> 3) & 3;
    *(_DWORD *)(a2 + 36) = (v9 >> 5) & 1;
    LOBYTE(v9) = v20;
    *(_DWORD *)(a2 + 32) = v10;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v9 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v9 >> 6;
    result = 1;
  }
  return result;
}
// 107896F0: using guessed type int dword_107896F0;

//----- (10055C90) --------------------------------------------------------
char __cdecl sub_10055C90(int a1, int a2)
{
  char result; // al@1
  char v3; // ah^2@2
  __int16 v4; // dx@2
  __int16 v5; // dx@2
  int v6; // [sp+0h] [bp-8h]@1
  unsigned int v7; // [sp+4h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_107896F0)(a1, 8, &v6);
  if ( result )
  {
    v3 = BYTE3(v6);
    *(_DWORD *)a2 = v6 & 0xFFFFFF;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = v3;
    v5 = (unsigned __int8)v7 ^ v4;
    *(_DWORD *)(a2 + 8) = v7 >> 8;
    *(_WORD *)(a2 + 4) = v5;
    result = 1;
  }
  return result;
}
// 107896F0: using guessed type int dword_107896F0;

//----- (10055CF0) --------------------------------------------------------
char __cdecl sub_10055CF0(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // esi@2
  unsigned int v5; // ecx@2
  __int16 v6; // [sp+0h] [bp-14h]@1
  __int16 v7; // [sp+2h] [bp-12h]@2
  __int16 v8; // [sp+4h] [bp-10h]@2
  __int16 v9; // [sp+6h] [bp-Eh]@2
  __int16 v10; // [sp+8h] [bp-Ch]@2
  unsigned __int16 v11; // [sp+Ah] [bp-Ah]@2
  int v12; // [sp+Ch] [bp-8h]@2
  char v13; // [sp+12h] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_107896F0)(a1, 19, &v6);
  if ( result )
  {
    v3 = v7;
    *(_WORD *)a2 = v6;
    *(_WORD *)(a2 + 4) = v8;
    *(_WORD *)(a2 + 8) = v10;
    *(_WORD *)(a2 + 2) = v3;
    v4 = v11;
    *(_WORD *)(a2 + 6) = v9;
    LOBYTE(v3) = v13;
    *(_DWORD *)(a2 + 12) = v4 + ((v13 & 7) << 16);
    *(_WORD *)(a2 + 16) = v12 & 0x3FFF;
    v5 = *(int *)((char *)&v12 + 2);
    *(_DWORD *)(a2 + 20) = *(int *)((char *)&v12 + 2) & 0xFFFFFF;
    *(_DWORD *)(a2 + 24) = (v5 >> 24) & 3;
    *(_DWORD *)(a2 + 28) = (v5 >> 26) & 1;
    *(_DWORD *)(a2 + 36) = (v5 >> 29) & 1;
    *(_DWORD *)(a2 + 32) = (v5 >> 27) & 3;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v3 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v3 >> 6;
    result = 1;
  }
  return result;
}
// 107896F0: using guessed type int dword_107896F0;

//----- (10055DC0) --------------------------------------------------------
char __thiscall sub_10055DC0(void *this)
{
  int v1; // eax@1
  char result; // al@3

  v1 = sub_10037130(this) - 2;
  if ( v1 )
  {
    if ( v1 == 2 )
      result = 2;
    else
      result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10055DE0) --------------------------------------------------------
_DWORD *__usercall sub_10055DE0@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4)
{
  _DWORD *result; // eax@1

  sub_100694F0(a2, a1);
  result = (_DWORD *)sub_100398C0(a3, a4);
  if ( (_BYTE)result )
    result = sub_10003EE0(a2);
  return result;
}

//----- (10055EC0) --------------------------------------------------------
char __cdecl sub_10055EC0(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  void *v4; // ecx@2
  int v5; // eax@3
  int v6; // eax@5
  char v7; // al@4
  int v8; // ecx@14
  char v9; // al@17
  char *v10; // eax@22
  char v12; // [sp+4h] [bp-10h]@20
  char v13; // [sp+8h] [bp-Ch]@11
  char v14; // [sp+Ch] [bp-8h]@18
  char v15; // [sp+10h] [bp-4h]@15
  char v16; // [sp+1Ch] [bp+8h]@3

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 52);
  if ( *(_WORD *)v3 != -32696 )
    return v3;
  v4 = (void *)*(_WORD *)(v3 + 10);
  if ( (unsigned __int16)v4 & 0xC000 )
    return v3;
  v5 = *(_DWORD *)(v3 + 4);
  v16 = -1;
  if ( v5 )
  {
    v7 = sub_10038BA0(*(int (__cdecl **)(int))(v5 + 8));
LABEL_7:
    v16 = v7;
    goto LABEL_8;
  }
  v6 = *(_DWORD *)(v2 + 48);
  if ( v6 )
  {
    v7 = sub_10038BA0(*(int (__cdecl **)(int))(v6 + 8));
    goto LABEL_7;
  }
LABEL_8:
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 1 )
    goto LABEL_26;
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 2 )
  {
    v13 = 8;
    goto LABEL_14;
  }
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 4 )
  {
LABEL_26:
    v13 = 7;
    goto LABEL_14;
  }
  v13 = sub_10055DC0(v4);
LABEL_14:
  v8 = *(_DWORD *)(v2 + 52);
  if ( *(_WORD *)(v8 + 10) == 0x2000 )
    v15 = *(_BYTE *)(v8 + 14) - 92;
  else
    v15 = *(_BYTE *)(v8 + 10);
  v9 = *(_BYTE *)(v8 + 8);
  if ( v9 >= 0 )
  {
    v14 = 0;
  }
  else
  {
    v14 = 1;
    v9 = -v9;
  }
  v12 = v9;
  if ( *(_WORD *)(v8 + 12) )
    v12 = v9 * *(_BYTE *)(v8 + 12);
  v10 = sub_10038BD0(v16);
  LOBYTE(v3) = sub_10069510(v13, v16, v15, v12, v14, *(_DWORD *)(v2 + 64), 0, 0, v10);
  return v3;
}

//----- (10055FC0) --------------------------------------------------------
_DWORD *sub_10055FC0()
{
  char v1; // [sp+4h] [bp-104h]@1

  sub_1006A140(6463, (int)&v1, 256);
  sub_10055DE0((int)sub_10055E70, (int)&unk_106CE520, &v1, "PAGE_INIT");
  sub_10055DE0((int)sub_10055E10, (int)&unk_106CE510, &v1, "PAGE_SET_FOCUS");
  return sub_10055DE0((int)sub_10055EC0, (int)&unk_106CE518, &v1, "KEY_PRESS");
}
// 10055E10: using guessed type int sub_10055E10();
// 10055E70: using guessed type int sub_10055E70();

//----- (10056050) --------------------------------------------------------
int __cdecl sub_10056050(int a1, float a2)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    *(float *)a1 = a2 * 1.799999952316284 + 32.0;
  return result;
}

//----- (10056070) --------------------------------------------------------
int __cdecl sub_10056070(int a1, float a2)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    *(float *)a1 = (a2 - 32.0) * 0.5555555820465088;
  return result;
}

//----- (10056090) --------------------------------------------------------
int __cdecl sub_10056090(unsigned __int8 *a1)
{
  return sub_1003F590(a1, 0, 0x7Fu, 0, 0);
}

//----- (100560B0) --------------------------------------------------------
int __cdecl sub_100560B0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1003F590(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100560E0) --------------------------------------------------------
char __cdecl sub_100560E0(unsigned __int8 a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  int v3; // eax@1
  char result; // al@2
  char v5[68]; // [sp+0h] [bp-48h]@1

  v2 = sub_10045170(v1);
  v3 = sub_10056340(v2);
  if ( sub_1006A0A0(v3, (int)v5, 67) )
    result = 0;
  else
    result = v5[a1];
  return result;
}
// 100560E0: using guessed type char var_48[68];

//----- (10056140) --------------------------------------------------------
signed int sub_10056140()
{
  return sub_1006C8D0((int)&off_100F57D0);
}
// 100F57D0: using guessed type char *off_100F57D0;

//----- (10056150) --------------------------------------------------------
char __usercall sub_10056150@<al>(unsigned __int8 a1@<al>, char a2, void *a3)
{
  unsigned __int8 v3; // bl@1
  char result; // al@7

  v3 = a1;
  if ( (unsigned __int8)(a1 - 53) > 0xDu
    || (unsigned __int8)a2 >= 3u
    || !(unsigned __int8)sub_10056140()
    || sub_100697D0(33, 10) )
  {
    sub_100364C0("..\\lib\\adl\\iop_data.c", 366, 0, 0);
    result = 0;
  }
  else if ( (unsigned int)(sub_10069700()
                         - *(_DWORD *)(dword_10789700 + 4 * (v3 - 33 + (unsigned __int8)a2 + 2 * (v3 - 33)))) <= 0x258
         && *(_BYTE *)(v3 + (unsigned __int8)a2 + 2 * v3 + dword_10789700 + 37) )
  {
    memcpy_0(
      a3,
      (const void *)(dword_10789700 + 4 * (v3 - 53 + (unsigned __int8)a2 + 2 * (v3 - 53))),
      *(_WORD *)(dword_10789700 + 2 * v3 + 62));
    sub_100697B0(33);
    result = 1;
  }
  else
  {
    sub_100697B0(33);
    result = 0;
  }
  return result;
}
// 10789700: using guessed type int dword_10789700;

//----- (10056230) --------------------------------------------------------
char __cdecl sub_10056230(int a1, char a2, void *a3)
{
  char result; // al@1
  int v4; // eax@4
  int v5; // esi@6
  int v6; // edi@7

  result = 0;
  if ( (unsigned __int8)a1 < 0x43u && (unsigned __int8)a2 < 3u )
  {
    if ( (unsigned __int8)a1 > 0x34u )
    {
      result = sub_10056150(a1, a2, a3);
    }
    else
    {
      v4 = sub_10069610(a1);
      if ( v4
        && (v5 = v4 + 4 * (unsigned __int8)a2, *(_BYTE *)v5 < 7)
        && (v6 = *(_WORD *)(v5 + 2), (unsigned __int16)v6 < (unsigned __int16)sub_1003D620(*(_BYTE *)v5)) )
      {
        result = sub_1003E2C0(*(_BYTE *)v5, v6, a3);
      }
      else
      {
        result = 0;
      }
    }
  }
  return result;
}
// 10069610: using guessed type _DWORD __cdecl sub_10069610(char);

//----- (100562B0) --------------------------------------------------------
char __cdecl sub_100562B0(int a1, void *a2)
{
  char v2; // al@1

  v2 = sub_100560E0(a1);
  return sub_10056230(a1, v2, a2);
}

//----- (100562D0) --------------------------------------------------------
char __cdecl sub_100562D0(_DWORD *a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  char v3; // al@1
  char result; // al@3
  char v5; // [sp+7h] [bp-5h]@1
  int v6; // [sp+8h] [bp-4h]@2

  v2 = sub_10045170(v1);
  v5 = sub_10056420(v2, 1);
  v3 = sub_1003B860(&v5, 1u, (int)&unk_100F585C, 4, 3, 2);
  v5 = v3;
  if ( v3 != 2 && sub_1003E2C0(6, (unsigned __int16)word_100F585E[2 * (unsigned __int8)v3], &v6) )
  {
    result = 1;
    *a1 = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100F585E: using guessed type __int16 word_100F585E[];

//----- (10056340) --------------------------------------------------------
int __cdecl sub_10056340(char a1)
{
  return 9190 - (a1 != 1);
}

//----- (10056350) --------------------------------------------------------
int __usercall sub_10056350@<eax>(char *a1@<eax>, char a2@<cl>)
{
  return sub_10069620(a2, a1);
}

//----- (10056360) --------------------------------------------------------
char __usercall sub_10056360@<al>(char a1@<bl>, char a2)
{
  int v2; // eax@1
  char result; // al@2
  char *v4; // ecx@3
  unsigned __int8 v5; // [sp+4h] [bp-8Ch]@1
  char v6; // [sp+5h] [bp-8Bh]@2
  char v7[68]; // [sp+48h] [bp-48h]@1

  memset(&v5, 0, 0x43u);
  memset(v7, 0, 0x43u);
  sub_10056350((char *)&v5, a2);
  v2 = sub_10056340(a1);
  if ( sub_1006A0A0(v2, (int)v7, 67) )
  {
    result = a1 == 1;
  }
  else
  {
    result = v7[v5];
    if ( v6 != 67 )
    {
      v4 = &v6;
      do
        ++v4;
      while ( *v4 != 67 );
    }
  }
  return result;
}
// 10056360: using guessed type char var_48[68];

//----- (10056420) --------------------------------------------------------
char __cdecl sub_10056420(char a1, char a2)
{
  return sub_10056360(a1, a2);
}

//----- (10056440) --------------------------------------------------------
bool __cdecl sub_10056440(void *a1)
{
  char v1; // al@1

  v1 = sub_1003E2C0(1, 1946, a1);
  *((_DWORD *)a1 + 1) = (unsigned int)(*((_DWORD *)a1 + 1) * (unsigned __int64)(unsigned int)&unk_10624DD3 >> 32) >> 6;
  return v1 && !sub_10043090((int)a1);
}

//----- (10056480) --------------------------------------------------------
char __cdecl sub_10056480(char a1)
{
  sub_1003DDF0(1, 1672, &a1, 0, 1, 1);
  return sub_1003DF30(1, 0x688u, 0xFFFFFFF);
}

//----- (100564B0) --------------------------------------------------------
char __cdecl sub_100564B0(char a1)
{
  int v1; // eax@1

  v1 = sub_1006A190(10028, (int)&a1, 1);
  if ( !v1 )
    LOBYTE(v1) = sub_10056480(a1);
  return v1;
}

//----- (100564E0) --------------------------------------------------------
char sub_100564E0()
{
  return 2;
}

//----- (100564F0) --------------------------------------------------------
char sub_100564F0()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_1006A140(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 100564F0: using guessed type int var_1C[7];

//----- (10056570) --------------------------------------------------------
signed int __usercall sub_10056570@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_100F84C0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_100F78C0[2 * (unsigned __int8)v68] ^ dword_100F7CC0[2 * BYTE1(v65)] ^ dword_100F80C0[2 * (unsigned __int8)(v66 >> 16)] ^ dword_100F84C0[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_100F84C0[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_100F84C0[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_100F84C0[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_100F84C0[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_100F84C0[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_100F84C0[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_100F84C0[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_100F84C0[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_100F88C0[(unsigned __int8)v57] ^ dword_100F94C0[v58 >> 24] ^ dword_100F8CC0[BYTE1(v59)] ^ dword_100F90C0[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_100F88C0[(unsigned __int8)v59] ^ dword_100F90C0[(unsigned __int8)(v58 >> 16)] ^ dword_100F94C0[v57 >> 24] ^ dword_100F8CC0[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_100F88C0[(unsigned __int8)v60] ^ dword_100F8CC0[BYTE1(v58)] ^ dword_100F90C0[(unsigned __int8)(v57 >> 16)] ^ dword_100F94C0[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_100F88C0[(unsigned __int8)v58] ^ dword_100F8CC0[BYTE1(v57)] ^ dword_100F90C0[(unsigned __int8)(v59 >> 16)] ^ dword_100F94C0[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100F84C0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_100F84C0[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100F84C0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100F84C0[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100F84C0[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100F78C0[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100F7CC0[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100F80C0[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100F84C0[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 100F88C0: using guessed type int dword_100F88C0[];
// 100F8CC0: using guessed type int dword_100F8CC0[];
// 100F90C0: using guessed type int dword_100F90C0[];
// 100F94C0: using guessed type int dword_100F94C0[];

//----- (10057620) --------------------------------------------------------
int __usercall sub_10057620@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_10056570(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (10057680) --------------------------------------------------------
signed int __usercall sub_10057680@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_100F94C0[(unsigned __int8)v9] ^ dword_100F88C0[BYTE1(v9)] ^ dword_100F8CC0[(unsigned __int8)(v9 >> 16)] ^ dword_100F90C0[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_100F94C0[(unsigned __int8)v129] ^ dword_100F88C0[BYTE1(v129)] ^ dword_100F8CC0[(unsigned __int8)(v129 >> 16)] ^ dword_100F90C0[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_100F94C0[(unsigned __int8)v133] ^ dword_100F88C0[BYTE1(v133)] ^ dword_100F8CC0[(unsigned __int8)(v133 >> 16)] ^ dword_100F90C0[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_100F94C0[(unsigned __int8)v137] ^ dword_100F88C0[BYTE1(v137)] ^ dword_100F8CC0[(unsigned __int8)(v137 >> 16)] ^ dword_100F90C0[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_100F94C0[(unsigned __int8)v141] ^ dword_100F88C0[BYTE1(v141)] ^ dword_100F8CC0[(unsigned __int8)(v141 >> 16)] ^ dword_100F90C0[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_100F94C0[(unsigned __int8)v145] ^ dword_100F88C0[BYTE1(v145)] ^ dword_100F8CC0[(unsigned __int8)(v145 >> 16)] ^ dword_100F90C0[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_100F94C0[(unsigned __int8)v149] ^ dword_100F88C0[BYTE1(v149)] ^ dword_100F8CC0[(unsigned __int8)(v149 >> 16)] ^ dword_100F90C0[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_100F94C0[(unsigned __int8)v153] ^ dword_100F88C0[BYTE1(v153)] ^ dword_100F8CC0[(unsigned __int8)(v153 >> 16)] ^ dword_100F90C0[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_100F94C0[(unsigned __int8)v157] ^ dword_100F88C0[BYTE1(v157)] ^ dword_100F8CC0[(unsigned __int8)(v157 >> 16)] ^ dword_100F90C0[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_100F94C0[(unsigned __int8)v161] ^ dword_100F88C0[BYTE1(v161)] ^ dword_100F8CC0[(unsigned __int8)(v161 >> 16)] ^ dword_100F90C0[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_100F94C0[(unsigned __int8)v77] ^ dword_100F88C0[BYTE1(v77)] ^ dword_100F8CC0[(unsigned __int8)(v77 >> 16)] ^ dword_100F90C0[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_100F94C0[(unsigned __int8)v82] ^ dword_100F88C0[BYTE1(v82)] ^ dword_100F8CC0[(unsigned __int8)(v82 >> 16)] ^ dword_100F90C0[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_100F94C0[(unsigned __int8)v89] ^ dword_100F88C0[BYTE1(v89)] ^ dword_100F8CC0[(unsigned __int8)(v89 >> 16)] ^ dword_100F90C0[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_100F94C0[(unsigned __int8)v94] ^ dword_100F88C0[BYTE1(v94)] ^ dword_100F8CC0[(unsigned __int8)(v94 >> 16)] ^ dword_100F90C0[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_100F94C0[(unsigned __int8)v100] ^ dword_100F88C0[BYTE1(v100)] ^ dword_100F8CC0[(unsigned __int8)(v100 >> 16)] ^ dword_100F90C0[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_100F94C0[(unsigned __int8)v100] ^ dword_100F88C0[BYTE1(v100)] ^ dword_100F8CC0[(unsigned __int8)(v100 >> 16)] ^ dword_100F90C0[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_100F94C0[(unsigned __int8)v108] ^ dword_100F88C0[BYTE1(v108)] ^ dword_100F8CC0[(unsigned __int8)(v108 >> 16)] ^ dword_100F90C0[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_100F94C0[(unsigned __int8)v114] ^ dword_100F88C0[BYTE1(v114)] ^ dword_100F8CC0[(unsigned __int8)(v114 >> 16)] ^ dword_100F90C0[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_100F94C0[(unsigned __int8)v120] ^ dword_100F88C0[BYTE1(v120)] ^ dword_100F8CC0[(unsigned __int8)(v120 >> 16)] ^ dword_100F90C0[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_100F94C0[(unsigned __int8)v19] ^ dword_100F88C0[BYTE1(v19)] ^ dword_100F8CC0[(unsigned __int8)(v19 >> 16)] ^ dword_100F90C0[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_100F88C0[(unsigned __int8)v23] ^ dword_100F8CC0[BYTE1(v23)] ^ dword_100F90C0[(unsigned __int8)(v23 >> 16)] ^ dword_100F94C0[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_100F94C0[(unsigned __int8)v26] ^ dword_100F88C0[BYTE1(v26)] ^ dword_100F8CC0[(unsigned __int8)(v26 >> 16)] ^ dword_100F90C0[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_100F88C0[(unsigned __int8)v31] ^ dword_100F8CC0[BYTE1(v31)] ^ dword_100F90C0[(unsigned __int8)(v31 >> 16)] ^ dword_100F94C0[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_100F94C0[(unsigned __int8)v35] ^ dword_100F88C0[BYTE1(v35)] ^ dword_100F8CC0[(unsigned __int8)(v35 >> 16)] ^ dword_100F90C0[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_100F88C0[(unsigned __int8)v41] ^ dword_100F8CC0[BYTE1(v41)] ^ dword_100F90C0[(unsigned __int8)(v41 >> 16)] ^ dword_100F94C0[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_100F94C0[(unsigned __int8)v43] ^ dword_100F88C0[BYTE1(v43)] ^ dword_100F8CC0[(unsigned __int8)(v43 >> 16)] ^ dword_100F90C0[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_100F88C0[(unsigned __int8)v47] ^ dword_100F8CC0[BYTE1(v47)] ^ dword_100F90C0[(unsigned __int8)(v47 >> 16)] ^ dword_100F94C0[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_100F94C0[(unsigned __int8)v52] ^ dword_100F88C0[BYTE1(v52)] ^ dword_100F8CC0[(unsigned __int8)(v52 >> 16)] ^ dword_100F90C0[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_100F88C0[(unsigned __int8)v58] ^ dword_100F8CC0[BYTE1(v58)] ^ dword_100F90C0[(unsigned __int8)(v58 >> 16)] ^ dword_100F94C0[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_100F94C0[(unsigned __int8)v60] ^ dword_100F88C0[BYTE1(v60)] ^ dword_100F8CC0[(unsigned __int8)(v60 >> 16)] ^ dword_100F90C0[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_100F88C0[(unsigned __int8)v66] ^ dword_100F8CC0[BYTE1(v66)] ^ dword_100F90C0[(unsigned __int8)(v66 >> 16)] ^ dword_100F94C0[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_100F94C0[(unsigned __int8)v69] ^ dword_100F88C0[BYTE1(v69)] ^ dword_100F8CC0[(unsigned __int8)(v69 >> 16)] ^ dword_100F90C0[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 100F88C0: using guessed type int dword_100F88C0[];
// 100F8CC0: using guessed type int dword_100F8CC0[];
// 100F90C0: using guessed type int dword_100F90C0[];
// 100F94C0: using guessed type int dword_100F94C0[];

//----- (10058400) --------------------------------------------------------
void *__usercall sub_10058400@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (10058420) --------------------------------------------------------
unsigned int __cdecl sub_10058420(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_10069700();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 10069750: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (10058480) --------------------------------------------------------
int __usercall sub_10058480@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = &unk_10325476;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (100584C0) --------------------------------------------------------
int __usercall sub_100584C0@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (10059BE0) --------------------------------------------------------
unsigned int __usercall sub_10059BE0@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_100F98E8[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_100F98F8[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_100584C0(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_100584C0(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 100F98E8: using guessed type int dword_100F98E8[];
// 100F98F8: using guessed type int dword_100F98F8[];

//----- (10059CE0) --------------------------------------------------------
void *__usercall sub_10059CE0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  int v3; // ebp@1
  size_t v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (int)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*(_DWORD *)(v3 + 4);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy_0((void *)(v5 + v3 + 28), v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_100584C0(v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy_0((void *)(v5 + v3 + 28), v9, v4);
}

//----- (10059D60) --------------------------------------------------------
void *__usercall sub_10059D60@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_10059BE0(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_10058480(v3 + 64);
    result = sub_10059CE0(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_10059CE0(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (10059E00) --------------------------------------------------------
int __usercall sub_10059E00@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_10059D60(a1, 0, 0);
  sub_10059BE0(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_10058480(a1 + 64);
  sub_10059CE0(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_10059CE0(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_10059BE0(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy_0((void *)a2, &v5, a3);
  return result;
}

//----- (10059EC0) --------------------------------------------------------
int __usercall sub_10059EC0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy_0((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_10058480(a2 + 64);
    sub_10059CE0(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_10059CE0(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (10059F20) --------------------------------------------------------
int __usercall sub_10059F20@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  int v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = (int)&a1[v1];
    memcpy_0(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy_0(&v19[v6], a1, 64 - v6);
    sub_100584C0((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *(_DWORD *)(v8 + 4) = v9;
    v12 = v18;
    *(_DWORD *)(v8 + 8) = result;
    v1 += 20;
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(v8 + 16) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 10059F20: using guessed type char var_40[64];

//----- (10059FE0) --------------------------------------------------------
int __usercall sub_10059FE0@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_10059F20((char *)a1);
  return sub_10059F20(v8);
}

//----- (1005A0A0) --------------------------------------------------------
char __cdecl sub_1005A0A0(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10059D60(a3 + 296, a2, a1);
    sub_10057620(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005A0F0) --------------------------------------------------------
char __cdecl sub_1005A0F0(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10057620(a3, (int)a1, a2);
    sub_10059D60(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005A140) --------------------------------------------------------
bool __cdecl sub_1005A140(int a1, int a2)
{
  if ( a2 )
    sub_10059E00(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (1005A170) --------------------------------------------------------
int __usercall sub_1005A170@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_10058400(&v24);
  sub_10059EC0(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_10059D60((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_10059D60((int)&v23, v12, (char *)&v31);
          sub_10059E00((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 1005A170: using guessed type char var_14[16];

//----- (1005A380) --------------------------------------------------------
int __usercall sub_1005A380@<eax>(void *a1@<eax>, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1

  v2 = (int)a1;
  memset(a1, 0, 0x210u);
  *(_DWORD *)(v2 + 524) = a2;
  sub_10059FE0(v2);
  v3 = 20;
  do
  {
    sub_10059F20((char *)v2);
    --v3;
  }
  while ( v3 );
  return sub_10059FE0(v2);
}

//----- (1005A3D0) --------------------------------------------------------
char *__cdecl sub_1005A3D0(int a1, int a2)
{
  void *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = (char *)v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy_0(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_10059FE0(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (1005A460) --------------------------------------------------------
signed int __cdecl sub_1005A460(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_1005A170(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_10057680(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_10058400((void *)(a6 + 296));
      sub_10059EC0(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 1005A460: using guessed type char var_40[8];
// 1005A460: using guessed type __int16 var_38[26];

//----- (1005A590) --------------------------------------------------------
bool __cdecl sub_1005A590(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_1005A380(&v4, (int)sub_10058420);
  if ( v2 )
    sub_1005A3D0(a2, (int)&v4);
  return v2;
}

//----- (1005A610) --------------------------------------------------------
BOOL __usercall sub_1005A610@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_100FA100[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_100FA000[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_100F9F00[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (1005A6B0) --------------------------------------------------------
int __usercall sub_1005A6B0@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (1005A740) --------------------------------------------------------
unsigned int __fastcall sub_1005A740(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (1005A760) --------------------------------------------------------
int __usercall sub_1005A760@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (1005A7F0) --------------------------------------------------------
int __usercall sub_1005A7F0@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_100FA100[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_100FA100[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_100F9908[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_100FA200[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_100FA000[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_100F9F00[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_100F9990[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_100FA278[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 100F9908: using guessed type int dword_100F9908[];
// 100F9990: using guessed type int dword_100F9990[];
// 100FA200: using guessed type int dword_100FA200[];
// 100FA278: using guessed type int dword_100FA278[];

//----- (1005AC70) --------------------------------------------------------
int __usercall sub_1005AC70@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_1005A760(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (1005AD20) --------------------------------------------------------
void *__usercall sub_1005AD20@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy_0(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (1005AD80) --------------------------------------------------------
int __usercall sub_1005AD80@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (1005AF50) --------------------------------------------------------
signed int __usercall sub_1005AF50@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_1005A740(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (1005AFD0) --------------------------------------------------------
_WORD *__fastcall sub_1005AFD0(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (1005B040) --------------------------------------------------------
signed int __usercall sub_1005B040@<eax>(int a1@<esi>)
{
  int v1; // ecx@1
  int v2; // edx@1
  int v3; // eax@1
  int v4; // edx@1
  signed int result; // eax@1

  v1 = *(_DWORD *)(a1 + 5764);
  v2 = *(_DWORD *)(a1 + 5736);
  *(_DWORD *)(a1 + 5744) = 2 * *(_DWORD *)(a1 + 5748);
  *(_WORD *)(v2 + 2 * v1 - 2) = 0;
  memset(*(void **)(a1 + 5736), 0, 2 * *(_DWORD *)(a1 + 5764) - 2);
  v3 = 6 * *(_BYTE *)(a1 + 5784);
  *(_DWORD *)(a1 + 5700) = (unsigned __int16)word_100FA2F2[6 * *(_BYTE *)(a1 + 5784)];
  *(_DWORD *)(a1 + 5704) = (unsigned __int16)word_100FA2F0[v3];
  *(_DWORD *)(a1 + 5708) = (unsigned __int16)word_100FA2F4[v3];
  v4 = (unsigned __int16)word_100FA2F6[v3];
  result = 2;
  *(_DWORD *)(a1 + 5680) = 0;
  *(_DWORD *)(a1 + 5664) = 0;
  *(_DWORD *)(a1 + 5688) = 0;
  *(_DWORD *)(a1 + 5676) = 0;
  *(_DWORD *)(a1 + 5760) = 0;
  *(_DWORD *)(a1 + 5696) = v4;
  *(_DWORD *)(a1 + 5692) = 2;
  *(_DWORD *)(a1 + 5668) = 2;
  return result;
}
// 100FA2F0: using guessed type __int16 word_100FA2F0[];
// 100FA2F2: using guessed type __int16 word_100FA2F2[];
// 100FA2F4: using guessed type __int16 word_100FA2F4[];
// 100FA2F6: using guessed type __int16 word_100FA2F6[];

//----- (1005B100) --------------------------------------------------------
unsigned int __usercall sub_1005B100@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (1005B2B0) --------------------------------------------------------
unsigned int __usercall sub_1005B2B0@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (1005B380) --------------------------------------------------------
int __usercall sub_1005B380@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (1005B430) --------------------------------------------------------
int __usercall sub_1005B430@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (1005B470) --------------------------------------------------------
unsigned int __usercall sub_1005B470@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_1005D4E0(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy_0(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005B4D0) --------------------------------------------------------
signed int __usercall sub_1005B4D0@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (1005B5B0) --------------------------------------------------------
int __usercall sub_1005B5B0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (1005BB50) --------------------------------------------------------
_WORD *__fastcall sub_1005BB50(int a1, int a2)
{
  *(_DWORD *)(a2 + 5628) = a2 + 2936;
  *(_DWORD *)(a2 + 5652) = a2 + 5472;
  *(_DWORD *)(a2 + 5636) = &off_100FA4A4;
  *(_DWORD *)(a2 + 5640) = a2 + 5228;
  *(_DWORD *)(a2 + 5648) = &off_100FA4B8;
  *(_DWORD *)(a2 + 5660) = &unk_100FA4CC;
  *(_WORD *)(a2 + 2924) = 0;
  *(_DWORD *)(a2 + 2932) = 0;
  *(_DWORD *)(a2 + 2928) = 8;
  return sub_1005AFD0(a2 + 5228, a2);
}
// 100FA4A4: using guessed type void *off_100FA4A4;
// 100FA4B8: using guessed type void *off_100FA4B8;

//----- (1005BBB0) --------------------------------------------------------
signed int __cdecl sub_1005BBB0(int a1)
{
  int v1; // esi@2
  int v2; // eax@3
  int v3; // ecx@5
  signed int result; // eax@5

  if ( a1 && (v1 = *(_DWORD *)(a1 + 24)) != 0 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(v1 + 5808) = *(_DWORD *)(v1 + 5800);
    v2 = *(_DWORD *)(v1 + 5780);
    *(_DWORD *)(v1 + 5812) = 0;
    if ( v2 < 0 )
      *(_DWORD *)(v1 + 5780) = -v2;
    *(_DWORD *)(v1 + 5788) = *(_DWORD *)(v1 + 5780) != 0 ? 42 : 113;
    *(_DWORD *)(a1 + 28) = sub_1005D4E0(0, 0, 0);
    *(_DWORD *)(v1 + 5792) = 0;
    sub_1005BB50(v3, v1);
    sub_1005B040(v1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1005BC40) --------------------------------------------------------
int __usercall sub_1005BC40@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_1005A6B0(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_1005A6B0(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_1005A6B0(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (1005BE80) --------------------------------------------------------
int __usercall sub_1005BE80@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_1005AC70(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_1005AC70(a1, a3, a4);
  }
  return result;
}

//----- (1005BF20) --------------------------------------------------------
signed int __usercall sub_1005BF20@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_1005B380(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_1005B380(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_1005B380(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_1005AD80(a1, a2);
  return sub_1005AF50(a1, v16, v5);
}

//----- (1005C100) --------------------------------------------------------
unsigned int __usercall sub_1005C100@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy_0(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_1005B470(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (1005C240) --------------------------------------------------------
int __usercall sub_1005C240@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_100F997C[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_1005B5B0(a1, a1 + 2936, a2 - 1);
  return sub_1005B5B0(v24, v24 + 5228, a3 - 1);
}

//----- (1005C4F0) --------------------------------------------------------
signed int __cdecl sub_1005C4F0(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_1005B430(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_1005B430(v9, *(_WORD *)(a1 + 30));
      sub_1005B430(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_1005D4E0(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_1005AD20(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_100FA2F8 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_1005BC40(v2);
    }
    else
    {
      sub_1005BE80(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_1005AD20(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_1005B430(v2, *(_WORD *)(a1 + 30));
    sub_1005B430(v13, *(_WORD *)(a1 + 28));
    sub_1005AD20(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100FA2F8: using guessed type int (__cdecl *off_100FA2F8)(int, int);

//----- (1005C7B0) --------------------------------------------------------
signed int __cdecl sub_1005C7B0(int a1, unsigned __int8 a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8)
{
  signed int v8; // edx@1
  int v9; // eax@5
  unsigned int v10; // edi@12
  signed int v11; // ebp@12
  signed int v12; // eax@12
  int v13; // ebp@14
  int v14; // esi@14
  int v15; // esi@14
  int v16; // esi@14
  signed int result; // eax@14

  v8 = 1;
  if ( a1 && a7 )
  {
    if ( a2 == -1 )
      a2 = 6;
    v9 = a4;
    if ( a4 < 0 )
    {
      v8 = 0;
      v9 = -a4;
      a4 = -a4;
    }
    if ( (unsigned int)(a5 - 1) > 7 || a3 != 8 || (unsigned int)(v9 - 9) > 6 || a2 > 9u || a6 > 3u )
    {
      result = -2;
    }
    else
    {
      v10 = 1 << (a5 + 6);
      v11 = 1 << v9;
      v12 = 1 << (a5 + 7);
      if ( (signed int)(2 * (v12 + 2 * (v10 + v11) + 2908)) > a8 || a7 & 3 )
      {
        result = -4;
      }
      else
      {
        *(_DWORD *)(a1 + 24) = a7;
        *(_DWORD *)(a7 + 5780) = v8;
        *(_DWORD *)(a7 + 5764) = v12;
        *(_DWORD *)(a7 + 5752) = a4;
        *(_DWORD *)(a7 + 5768) = a5 + 7;
        *(_DWORD *)(a7 + 5772) = v12 - 1;
        *(_DWORD *)(a7 + 5756) = v11 - 1;
        *(_DWORD *)(a7 + 5748) = v11;
        *(_DWORD *)(a7 + 5740) = a7 + 5816;
        v13 = 2 * v11;
        v14 = v13 + a7 + 5816;
        *(_DWORD *)(a7 + 5732) = v14;
        v15 = v13 + v14;
        *(_DWORD *)(a7 + 5776) = (a5 + 9) / 3u;
        *(_DWORD *)(a7 + 5736) = v15;
        v16 = v15 + 2 * (1 << (a5 + 7));
        *(_DWORD *)(a7 + 5804) = 4 * v10;
        *(_DWORD *)(a7 + 5716) = v10 + v16 + 2 * v10;
        *(_DWORD *)(a7 + 5712) = v16 + 2 * (v10 >> 1);
        *(_DWORD *)(a7 + 5724) = v10;
        *(_DWORD *)(a7 + 5800) = v16;
        *(_BYTE *)(a7 + 5784) = a2;
        *(_BYTE *)(a7 + 5796) = a6;
        *(_BYTE *)(a7 + 5720) = 8;
        result = sub_1005BBB0(a1);
      }
    }
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1005C960) --------------------------------------------------------
signed int __usercall sub_1005C960@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_1005B4D0(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_1005B4D0(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_1005BF20(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_100F997C[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100F997B[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100F997A[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100F9979[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (1005CA30) --------------------------------------------------------
_WORD *__usercall sub_1005CA30@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_1005BF20(a2, a2 + 5628);
  sub_1005BF20(v4, v4 + 5640);
  v8 = sub_1005C960(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_1005BE80(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_1005A7F0(v4, (int)&unk_100F9A08, (int)&unk_100F9E88);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_1005C240(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_1005A7F0(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_1005AFD0(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_1005A760(v4);
  return result;
}

//----- (1005CC50) --------------------------------------------------------
signed int __cdecl sub_1005CC50(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_1005C100(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_1005B100(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_1005B2B0(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_1005A610(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_1005A610(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_1005CA30(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_1005AD20(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_1005CA30(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1005AD20(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1005CF60) --------------------------------------------------------
signed int __cdecl sub_1005CF60(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_1005C100(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_1005B100(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_1005B2B0(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_1005A610(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_1005CA30(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_1005AD20(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_1005A610(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_1005CA30(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_1005AD20(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_1005A610(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_1005CA30(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1005AD20(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (1005D370) --------------------------------------------------------
signed int __cdecl sub_1005D370(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_1005C100(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_1005CA30(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_1005AD20(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_1005CA30(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_1005AD20(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_1005CA30(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1005AD20(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1005D4E0) --------------------------------------------------------
int __cdecl sub_1005D4E0(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  int result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = v4 | (v5 << 16);
  }
  else
  {
    result = (int)(a2 + 1);
  }
  return result;
}

//----- (1005D5E0) --------------------------------------------------------
signed int __cdecl sub_1005D5E0(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1005D600) --------------------------------------------------------
signed int __usercall sub_1005D600@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 1005D600: using guessed type int var_78[14];
// 1005D600: using guessed type int var_3C[15];

//----- (1005DAA0) --------------------------------------------------------
int (__cdecl *__usercall sub_1005DAA0@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (1005DAF0) --------------------------------------------------------
int __usercall sub_1005DAF0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (1005DB10) --------------------------------------------------------
signed int __cdecl sub_1005DB10(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_100FA4E0[a1];
  v51 = dword_100FA4E0[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_100FA4E0[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_100FA4E0[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_100FA4E0[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_100FA4E0[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 100FA4E0: using guessed type int dword_100FA4E0[];

//----- (1005DEC0) --------------------------------------------------------
int __usercall sub_1005DEC0@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy_0(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy_0(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (1005E000) --------------------------------------------------------
signed int __usercall sub_1005E000@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_1005D600(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (1005E050) --------------------------------------------------------
signed int __usercall sub_1005E050@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_1005D600(a7, a6, a4, 257, (int)&unk_100FA578, (int)&unk_100FA5F8, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_1005D600(a8, &a6[a4], a5, 0, (int)&unk_100FA678, (int)&unk_100FA6F0, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005E0F0) --------------------------------------------------------
int __usercall sub_1005E0F0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_100FA768;
  *a4 = &unk_100FB768;
  return 0;
}

//----- (1005E110) --------------------------------------------------------
signed int __cdecl sub_1005E110(int a1, int a2, int a3, int a4)
{
  int v4; // ecx@1
  signed int v5; // ebx@1

  v4 = a2;
  v5 = 0;
  if ( a2 < 0 )
  {
    v5 = 1;
    v4 = -a2;
  }
  if ( (1 << v4) + 14152 <= a4 && !(a3 & 3) )
  {
    *(_DWORD *)(a1 + 24) = a3;
    *(_DWORD *)(a3 + 16) = v4;
    *(_DWORD *)(a3 + 12) = v5;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)(a3 + 20) = a3 + 24;
    *(_DWORD *)(a3 + 14128) = a3 + 14152;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14108) = (1 << v4) + *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14104);
    **(_BYTE **)(a3 + 20) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1428) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1424) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14124) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1420) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14112) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14116) = 0;
    if ( *(_DWORD *)(a3 + 12) )
      *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14120) = 0;
    else
      *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14120) = sub_1005D4E0;
    sub_1005DAA0(0, *(_DWORD *)(a3 + 20), a1);
    JUMPOUT(&loc_1005DFC0);
  }
  return -4;
}

//----- (1005E200) --------------------------------------------------------
signed int __cdecl sub_1005E200(int a1)
{
  signed int result; // eax@2
  int v2; // ecx@3
  int v3; // esi@3

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    v3 = *(_DWORD *)(v2 + 20);
    *(_BYTE *)v2 = *(_DWORD *)(v2 + 12) != 0 ? 7 : 0;
    sub_1005DAA0(0, v3, a1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1005E210) --------------------------------------------------------
int __usercall sub_1005E210@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_1005DB10(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100FA4E0[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_100FA4E0[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100FA4E0[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_100FA4E0[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_1005DEC0(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_1005DEC0(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_1005DEC0(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_1005DEC0(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 100FA4E0: using guessed type int dword_100FA4E0[];

//----- (1005E8B0) --------------------------------------------------------
int __usercall sub_1005E8B0@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_1005E0F0(&v67, &v69, &v66, &v68);
          sub_1005DAF0(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_1005DEC0(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy_0(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_100FA528[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_100FA528[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_1005E000(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_1005E050(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_1005DAF0(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_1005E210(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_1005DEC0(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_1005DEC0(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_1005DEC0(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_100FA4E0[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_100FA4E0[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_1005DEC0(v7, v3, v58);
}
// 100FA4E0: using guessed type int dword_100FA4E0[];
// 100FA528: using guessed type int dword_100FA528[];

//----- (1005F290) --------------------------------------------------------
signed int __usercall sub_1005F290@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_1005E8B0(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_1005DAA0((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (1005F5C0) --------------------------------------------------------
signed int __cdecl sub_1005F5C0(int a1, int a2)
{
  return sub_1005F290(a1, a2);
}

//----- (1005F5E0) --------------------------------------------------------
int __cdecl sub_1005F5E0(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (1005F5F0) --------------------------------------------------------
char __cdecl sub_1005F5F0(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_10730278[592 * a1]) || byte_107302C8[v3]) )
  {
    *a2 = &byte_10730278[v3];
    *a3 = &byte_107302C8[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005F630) --------------------------------------------------------
char *__cdecl sub_1005F630(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_10730278;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_107302C8[592 * v2];
}

//----- (1005F6A0) --------------------------------------------------------
char *__usercall sub_1005F6A0@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (1005F6D0) --------------------------------------------------------
void __cdecl sub_1005F6D0(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_1005F630(v2 + 3, (int)byte_10084570);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_1005F6D0(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (1005F790) --------------------------------------------------------
void __cdecl sub_1005F790(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  char *v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  char *v8; // edx@4
  char v9; // cl@5

  if ( dword_10730270 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_10730270;
    v4 = (char *)(&byte_10730278[592 * dword_10730270] - a1);
    do
    {
      v5 = *v2;
      v2[(_DWORD)v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_107302C8[v3];
    v8 = (char *)(&byte_107302C8[v3] - a2);
    do
    {
      v9 = *v6;
      v6[(_DWORD)v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_1005F6D0(v7);
    ++dword_10730270;
  }
}
// 10730270: using guessed type int dword_10730270;

//----- (1005F7F0) --------------------------------------------------------
void *__cdecl sub_1005F7F0(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  char *v4; // edi@4
  char *v5; // esi@4
  char *v6; // eax@4
  const char *v7; // esi@6
  const char *v8; // ebx@6
  char *v9; // edi@6
  char *v10; // eax@6
  char v11; // [sp+4h] [bp-204h]@3

  result = memset(byte_10730278, 0, 0x73A0u);
  dword_10730270 = 0;
  if ( a1 )
  {
    v2 = sub_1005FCC0(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_1005FEA0((int)&v11, 512, v2) )
      {
        do
        {
          sub_1005F6A0(&v11);
          v4 = strstr(&v11, "=");
          v5 = strstr(&v11, "<Var name=\"");
          v6 = strstr(&v11, " value=\"");
          if ( v5 && v6 )
          {
            v7 = v5 + 11;
            v8 = v6 + 8;
            v9 = strchr(v7, 34);
            v10 = strchr(v8, 34);
            if ( v9 )
            {
              if ( v10 )
              {
                *v9 = 0;
                *v10 = 0;
                sub_1005F790((char *)v7, (char *)v8);
              }
            }
          }
          else if ( v4 && !strpbrk(&v11, "<>") )
          {
            *v4 = 0;
            sub_1005F790(&v11, v4 + 1);
          }
        }
        while ( sub_1005FEA0((int)&v11, 512, v3) );
      }
      result = (void *)sub_1005FC70(v3);
    }
    else
    {
      result = (void *)sub_10049C40(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 10730270: using guessed type int dword_10730270;

//----- (1005F980) --------------------------------------------------------
int __cdecl sub_1005F980(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 1006C9A0: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 1006C9B0: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 1006C9C0: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 1006C9D0: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 1006CA80: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (1005FAC0) --------------------------------------------------------
char __usercall sub_1005FAC0@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (1005FB90) --------------------------------------------------------
signed int __cdecl sub_1005FB90(_DWORD *a1, char *a2)
{
  int v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = (int)a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *(_DWORD *)v2;
    v10 = *(_DWORD *)v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_1006C9E0(*(_DWORD *)(v2 + 4), (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_1005FAC0(v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)(v2 + 30), (char)a1);
          v3 = v10;
          *a2 = v8;
          *(_DWORD *)(v2 + 24) += v6;
        }
        else
        {
          v7 = *(_DWORD *)(v2 + 4);
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_1005F980(v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 1006CA90: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (1005FC70) --------------------------------------------------------
BOOL __cdecl sub_1005FC70(unsigned int a1)
{
  j_FIL_vfs_clean_invalidate_cache(a1);
  return sub_1006B1D0(a1) == 0;
}
// 1006B1C0: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);

//----- (1005FC90) --------------------------------------------------------
BOOL __cdecl sub_1005FC90(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 1006B250: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (1005FCC0) --------------------------------------------------------
unsigned int __cdecl sub_1005FCC0(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 1006B2E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1005FD20) --------------------------------------------------------
signed int __cdecl sub_1005FD20(void *a1, int a2, unsigned int a3)
{
  return sub_1006B2F0(a3, a1, a2);
}

//----- (1005FD40) --------------------------------------------------------
int __cdecl sub_1005FD40(int a1, int a2, int a3)
{
  return j_FIL_vfs_write(a3, a1, a2);
}
// 1006B480: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1005FD60) --------------------------------------------------------
char __cdecl sub_1005FD60(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  unsigned int v4; // ebp@7
  int v5; // esi@8
  bool i; // zf@8
  char v8; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_1005FCC0((int)a1, 0);
    if ( v3 )
    {
      v4 = sub_1005FCC0((int)a2, 1);
      if ( v4 )
      {
        v5 = sub_1005FD20(&v8, 512, v3);
        for ( i = v5 == 0; v5 > 0; i = v5 == 0 )
        {
          v5 -= sub_1005FD40((int)&v8, v5, v4);
          if ( !v5 )
            v5 = sub_1005FD20(&v8, 512, v3);
        }
        v2 = i;
        sub_1005FC70(v4);
      }
      sub_1005FC70(v3);
    }
    return v2;
  }
  return 1;
}

//----- (1005FEA0) --------------------------------------------------------
int __cdecl sub_1005FEA0(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_1005FD20(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (1005FF20) --------------------------------------------------------
int sub_1005FF20()
{
  return 0;
}

//----- (1005FF30) --------------------------------------------------------
void __cdecl sub_1005FF30(int a1)
{
  if ( a1 > 0 )
    exit_1(14);
}

//----- (1005FF60) --------------------------------------------------------
int __cdecl sub_1005FF60(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (1005FF80) --------------------------------------------------------
bool __cdecl sub_1005FF80(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (1005FFB0) --------------------------------------------------------
void *__cdecl sub_1005FFB0(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (1005FFF0) --------------------------------------------------------
unsigned int __usercall sub_1005FFF0@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (10060010) --------------------------------------------------------
int __usercall sub_10060010@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (10060030) --------------------------------------------------------
char __cdecl sub_10060030(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_1005FF80(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_1005FF60(a2);
  }
  return result;
}

//----- (10060060) --------------------------------------------------------
signed int __cdecl sub_10060060(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  int v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = (int)a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( *(_DWORD *)(v5 + 4) )
      {
        do
        {
          v10 = sub_1005FFF0(v5, v7, v9);
          v11 = (_BYTE *)sub_1005FFF0(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_1005FFF0(a4, v7, v9);
            sub_10060010(v16, (int)&unk_100FB90C);
          }
          ++v9;
        }
        while ( v9 < *(_DWORD *)(v5 + 4) );
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (10060140) --------------------------------------------------------
void __cdecl sub_10060140(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_1005FFF0((int)v3, v4, v6);
          v8 = sub_1005FFF0(a2, v4, v6);
          v9 = sub_1005FFF0(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (100601F0) --------------------------------------------------------
void *__usercall sub_100601F0@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  int v34; // [sp+14h] [bp-Ch]@1
  int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_1005FFF0(a1, v31, v4);
      v6 = sub_1005FFF0(a2, 0, 0);
      sub_10060010(v5, v6);
      v7 = sub_1005FFF0(a1, v33, v4);
      v8 = sub_1005FFF0(a2, *(_DWORD *)a2 - 1, 0);
      sub_10060010(v7, v8);
      v9 = sub_1005FFF0(a1, v31, v34 - v4 - 1);
      v10 = sub_1005FFF0(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_10060010(v9, v10);
      v11 = sub_1005FFF0(a1, v33, v34 - v4 - 1);
      v12 = sub_1005FFF0(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_10060010(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_1005FFF0(a2, 0, 1);
    v16 = (void *)sub_1005FFF0(a1, v13, a3 + 1);
    memcpy_0(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_1005FFF0(a1, a3 + i, v18);
      v20 = sub_1005FFF0(a2, i, 0);
      sub_10060010(v19, v20);
      v21 = sub_1005FFF0(a1, i + a3, v34 - v18 - 1);
      v22 = sub_1005FFF0(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_10060010(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_1005FFF0(a2, i, 1);
    v25 = (void *)sub_1005FFF0(a1, a3 + i, a3 + 1);
    memcpy_0(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_1005FFF0(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_1005FFF0(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy_0(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (10060470) --------------------------------------------------------
void __cdecl sub_10060470(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_1005FFF0(a1, v2, v4);
          v6 = sub_1005FFF0(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (10060540) --------------------------------------------------------
char __cdecl sub_10060540(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_1005FF80(a1);
  if ( result )
  {
    result = sub_1005FF80(a4);
    if ( result )
    {
      sub_10060030(a3, a4);
      sub_1005FFB0(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy_0(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (100605B0) --------------------------------------------------------
int __usercall sub_100605B0@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_1005FFB0(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_100601F0((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_1005FFF0((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_1005FFF0(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_10060030((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_10060540(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (10060910) --------------------------------------------------------
int __usercall sub_10060910@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_1005FFB0(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_10060140(v8, a3, (int)&v16);
  sub_1005FFB0(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_100605B0(9u, v7, (int)&v16, (int)&unk_100FB8E8, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_1005FFF0((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_1005FFF0(a6, v9, v11);
            sub_10060010(v13, (int)&unk_100FB90C);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_10060030(a5, (int)&v15);
  sub_10060030(a5, (int)&v16);
  return v10;
}

//----- (10060A20) --------------------------------------------------------
int __cdecl sub_10060A20(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_1005FFB0(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_10060470(a3, a8);
  if ( a1 )
    result = sub_10060910(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_10060060((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (10060BB0) --------------------------------------------------------
char __cdecl sub_10060BB0(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  char *v6; // ebp@11
  int v7; // esi@11
  unsigned int v8; // ebx@11
  int v9; // edi@11
  char result; // al@20
  char v11; // [sp+8h] [bp-40h]@14
  unsigned int v12; // [sp+Ch] [bp-3Ch]@5
  __int16 v13; // [sp+10h] [bp-38h]@6
  int v14; // [sp+1Ah] [bp-2Eh]@8
  char v15; // [sp+20h] [bp-28h]@9
  int v16; // [sp+24h] [bp-24h]@11
  unsigned int v17; // [sp+28h] [bp-20h]@11
  unsigned __int16 v18; // [sp+2Eh] [bp-1Ah]@10
  char v19; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_1005FCC0((int)a2, 0);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        if ( sub_1005FD20(&v13, 14, v4) == 14
          && v13 == 19778
          && v14 == 54
          && sub_1005FD20(&v15, 40, v5) == 40
          && v18 == 24 )
        {
          sub_1005FFB0(v17, v16, 24, a1, a3);
          v6 = *(char **)(a3 + 12);
          v7 = v16 * (((unsigned int)v18 + 7) >> 3);
          v8 = 0;
          v9 = -(v16 * (((unsigned int)v18 + 7) >> 3)) & 3;
          v19 = 1;
          if ( v17 )
          {
            while ( sub_1005FD20(v6, v7, v12) == v7 && (!v9 || sub_1005FD20(&v11, v9, v12) == v9) )
            {
              ++v8;
              v6 += v7;
              if ( v8 >= v17 )
                goto LABEL_18;
            }
            v19 = 0;
          }
LABEL_18:
          v3 = v19;
          v5 = v12;
        }
        sub_1005FC70(v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10060D00) --------------------------------------------------------
char __usercall sub_10060D00@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@1
  unsigned int v10; // ebx@1
  int v12; // [sp+10h] [bp-40h]@4
  int v13; // [sp+14h] [bp-3Ch]@4
  __int16 v14; // [sp+18h] [bp-38h]@1
  int v15; // [sp+1Ah] [bp-36h]@1
  __int16 v16; // [sp+1Eh] [bp-32h]@1
  __int16 v17; // [sp+20h] [bp-30h]@1
  int v18; // [sp+22h] [bp-2Eh]@1
  int v19; // [sp+28h] [bp-28h]@1
  int v20; // [sp+2Ch] [bp-24h]@1
  unsigned int v21; // [sp+30h] [bp-20h]@1
  __int16 v22; // [sp+34h] [bp-1Ch]@1
  __int16 v23; // [sp+36h] [bp-1Ah]@1
  int v24; // [sp+38h] [bp-18h]@1
  int v25; // [sp+3Ch] [bp-14h]@1
  int v26; // [sp+40h] [bp-10h]@1
  int v27; // [sp+44h] [bp-Ch]@1
  int v28; // [sp+48h] [bp-8h]@1
  int v29; // [sp+4Ch] [bp-4h]@1
  char v30; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v25 = v8;
  v15 = v8 + 54;
  v16 = 0;
  v17 = 0;
  v29 = 0;
  v28 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v14 = 19778;
  v18 = 54;
  v19 = 40;
  v23 = a2;
  v21 = v5;
  v20 = a1;
  v22 = 1;
  v9 = sub_1005FCC0(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_1005FD40((int)&v14, 14, v9) == 14 && sub_1005FD40((int)&v19, 40, v10) == 40 )
    {
      v30 = 1;
      v12 = a4;
      v13 = 0;
      if ( v5 )
      {
        while ( sub_1005FD40(v12, v6, v10) == v6 && (!v7 || sub_1005FD40((int)&unk_100FBAA0, v7, v10) == v7) )
        {
          v12 += v6;
          if ( ++v13 >= v5 )
          {
            sub_1005FC70(v10);
            return 1;
          }
        }
        v30 = 0;
      }
    }
    sub_1005FC70(v10);
  }
  return v30;
}

//----- (10060E50) --------------------------------------------------------
char __cdecl sub_10060E50(int a1, int a2)
{
  char result; // al@2

  if ( sub_1005FF80(a1) )
    result = sub_10060D00(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (10060E90) --------------------------------------------------------
signed int __cdecl sub_10060E90(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_10737619 = 1;
    byte_10737618 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_10737618 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_10737619 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 10737618: using guessed type char byte_10737618;
// 10737619: using guessed type char byte_10737619;

//----- (10060EF0) --------------------------------------------------------
bool __cdecl sub_10060EF0(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_10049B90(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_10113698, (int)"failing_subroutine( depth-1 )");
    sub_10060EF0(a1 - 1);
    exit_1(14);
  }
  return sub_1004F050(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (10060F60) --------------------------------------------------------
int sub_10060F60()
{
  const char *v0; // eax@1

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_10737618 )
  {
    sub_1004F050(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_10049B90(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_10060EF0(1);
    exit_1(14);
  }
  return sub_10049BC0(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 10737618: using guessed type char byte_10737618;

//----- (10061280) --------------------------------------------------------
char sub_10061280()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10737618 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100FC70C + v2) )
      {
        sub_1004A380((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100FC714[v2], 0x100u, &v11);
        sub_1004A380((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100FC70C + v2), 0x100u, &v12);
        sub_1005FD60(&v12, &v11);
      }
      if ( byte_100FC708[v2] )
      {
        sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = off_100FC710[v2 / 4];
        v4 = *(char **)&off_100FC714[v2];
        v5 = sub_1004A620(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100FC714[v2],
               off_100FC710[v2 / 4]);
        v6 = sub_1004ECA0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1004A980(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"731",
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = off_100FC710[v2 / 4];
        v8 = *(char **)&off_100FC714[v2];
        v9 = sub_1004A620(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100FC714[v2],
               off_100FC710[v2 / 4]);
        v10 = sub_1004ECA0(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1004A980(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"741",
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x90 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"704",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100FC70C: using guessed type void *off_100FC70C;
// 100FC710: using guessed type char *off_100FC710[2];
// 10737618: using guessed type char byte_10737618;

//----- (100614A0) --------------------------------------------------------
char sub_100614A0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10737618 )
  {
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_1004A980(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"777",
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1004A980(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_1004A980(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1004A980(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"782",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"784", 2, 2);
    v4 = sub_1004A980(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1004A980(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"788", 2, 2);
    v5 = sub_1004A980(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1004A980(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"790",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10737618: using guessed type char byte_10737618;

//----- (100616A0) --------------------------------------------------------
char sub_100616A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_100FC79C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_100FC799[v2 * 4];
        v4 = byte_100FC798[v2 * 4];
        v5 = sub_1004A620(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + dword_100FC79C[v2])],
               (&off_100FC7A0)[v2 * 4]);
        v6 = sub_1004AAC0(
               0,
               *(&dword_100FC6EC + dword_100FC79C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1004A620(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_100FC79C[v2]],
               (&off_100FC7A0)[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100FC79C: using guessed type int dword_100FC79C[];
// 100FC7A0: using guessed type char *off_100FC7A0;
// 10737618: using guessed type char byte_10737618;

//----- (10061820) --------------------------------------------------------
char sub_10061820()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_100FCA20[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100FCA18[v2 / 8];
        v4 = dbl_100FCA10[v2 / 8];
        v5 = dbl_100FCA08[v2 / 8];
        v6 = sub_1004A620(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               (&off_100FCA24)[v2]);
        v7 = sub_1004AE70(
               0,
               *(&dword_100FC6EC + dword_100FCA20[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_100FCA20[v2 / 4]],
               (&off_100FCA24)[v2]);
        LOBYTE(v0) = sub_1004A980(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100FCA08: using guessed type double dbl_100FCA08[];
// 100FCA10: using guessed type double dbl_100FCA10[];
// 100FCA18: using guessed type double dbl_100FCA18[];
// 100FCA20: using guessed type int dword_100FCA20[];
// 100FCA24: using guessed type char *off_100FCA24;
// 10737618: using guessed type char byte_10737618;

//----- (100619A0) --------------------------------------------------------
char sub_100619A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_100FD634[v2];
      if ( v0 != 6 )
      {
        v3 = flt_100FD630[v2];
        v4 = flt_100FD62C[v2];
        v5 = flt_100FD628[v2];
        v6 = sub_1004A620(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               *(_DWORD *)&off_100FD638[v2 * 4]);
        v7 = sub_1004B2C0(
               0,
               *(&dword_100FC6EC + dword_100FD634[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_100FD634[v2]],
               *(_DWORD *)&off_100FD638[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100FD628: using guessed type float flt_100FD628[];
// 100FD62C: using guessed type float flt_100FD62C[];
// 100FD630: using guessed type float flt_100FD630[];
// 100FD634: using guessed type int dword_100FD634[];
// 10737618: using guessed type char byte_10737618;

//----- (10061B10) --------------------------------------------------------
char sub_10061B10()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10737618 )
  {
    sub_1004EFA0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_10061B10,
      (int)sub_10061B10,
      (int)"This test is expected to fail");
    sub_1004EFA0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_10061B10,
      0,
      (int)"This test is expected to fail");
    result = sub_1004EFA0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10061B10,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10737618: using guessed type char byte_10737618;

//----- (10061C10) --------------------------------------------------------
char sub_10061C10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_100FDDDC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100FDDD8[v2];
        v4 = dword_100FDDD4[v2];
        v5 = dword_100FDDD0[v2];
        v6 = sub_1004A620(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               (&off_100FDDE0)[v2 * 4]);
        v7 = sub_1004B780(
               0,
               *(&dword_100FC6EC + dword_100FDDDC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_100FDDDC[v2]],
               (&off_100FDDE0)[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100FDDD0: using guessed type int dword_100FDDD0[];
// 100FDDD4: using guessed type int dword_100FDDD4[];
// 100FDDD8: using guessed type int dword_100FDDD8[];
// 100FDDDC: using guessed type int dword_100FDDDC[];
// 100FDDE0: using guessed type char *off_100FDDE0;
// 10737618: using guessed type char byte_10737618;

//----- (10061D70) --------------------------------------------------------
char sub_10061D70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_100FE570[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100FE56C[v2 / 2];
        v4 = word_100FE56A[v2 / 2];
        v5 = word_100FE568[v2 / 2];
        v6 = sub_1004A620(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               (&off_100FE574)[v2]);
        v7 = sub_1004BB40(
               0,
               *(&dword_100FC6EC + dword_100FE570[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_100FE570[v2 / 4]],
               (&off_100FE574)[v2]);
        LOBYTE(v0) = sub_1004A980(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100FE568: using guessed type __int16 word_100FE568[];
// 100FE56A: using guessed type __int16 word_100FE56A[];
// 100FE56C: using guessed type __int16 word_100FE56C[];
// 100FE570: using guessed type int dword_100FE570[];
// 100FE574: using guessed type char *off_100FE574;
// 10737618: using guessed type char byte_10737618;

//----- (10061ED0) --------------------------------------------------------
char sub_10061ED0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_100FEB84[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100FEB80[v2];
        v4 = dword_100FEB7C[v2];
        v5 = dword_100FEB78[v2];
        v6 = sub_1004A620(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               *(_DWORD *)&off_100FEB88[v2 * 4]);
        v7 = sub_1004BF40(
               0,
               *(&dword_100FC6EC + dword_100FEB84[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_100FEB84[v2]],
               *(_DWORD *)&off_100FEB88[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100FEB78: using guessed type int dword_100FEB78[];
// 100FEB7C: using guessed type int dword_100FEB7C[];
// 100FEB80: using guessed type int dword_100FEB80[];
// 100FEB84: using guessed type int dword_100FEB84[];
// 10737618: using guessed type char byte_10737618;

//----- (10062030) --------------------------------------------------------
char sub_10062030()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_100FF328[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100FF324[v2];
        LODWORD(v3) = dword_100FF320[v2];
        HIDWORD(v4) = dword_100FF31C[v2];
        LODWORD(v4) = dword_100FF318[v2];
        HIDWORD(v5) = dword_100FF314[v2];
        LODWORD(v5) = dword_100FF310[v2];
        v6 = sub_1004A620(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               *(_DWORD *)&off_100FF32C[v2 * 4]);
        v7 = sub_1004C300(
               0,
               *(&dword_100FC6EC + dword_100FF328[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_100FF328[v2]],
               *(_DWORD *)&off_100FF32C[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100FF310: using guessed type int dword_100FF310[];
// 100FF314: using guessed type int dword_100FF314[];
// 100FF318: using guessed type int dword_100FF318[];
// 100FF31C: using guessed type int dword_100FF31C[];
// 100FF320: using guessed type int dword_100FF320[];
// 100FF324: using guessed type int dword_100FF324[];
// 100FF328: using guessed type int dword_100FF328[];
// 10737618: using guessed type char byte_10737618;

//----- (100621A0) --------------------------------------------------------
char sub_100621A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_100FFF34[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100FFF32[v2 * 4];
        v4 = byte_100FFF31[v2 * 4];
        v5 = byte_100FFF30[v2 * 4];
        v6 = sub_1004A620(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               (&off_100FFF38)[v2 * 4]);
        v7 = sub_1004C840(
               0,
               *(&dword_100FC6EC + dword_100FFF34[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_100FFF34[v2]],
               (&off_100FFF38)[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100FFF34: using guessed type int dword_100FFF34[];
// 100FFF38: using guessed type char *off_100FFF38;
// 10737618: using guessed type char byte_10737618;

//----- (10062300) --------------------------------------------------------
char sub_10062300()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_101003CC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_101003C8[v2];
        v4 = dword_101003C4[v2];
        v5 = dword_101003C0[v2];
        v6 = sub_1004A620(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               (&off_101003D0)[v2 * 4]);
        v7 = sub_1004CC20(
               0,
               *(&dword_100FC6EC + dword_101003CC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_101003CC[v2]],
               (&off_101003D0)[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101003C0: using guessed type int dword_101003C0[];
// 101003C4: using guessed type int dword_101003C4[];
// 101003C8: using guessed type int dword_101003C8[];
// 101003CC: using guessed type int dword_101003CC[];
// 101003D0: using guessed type char *off_101003D0;
// 10737618: using guessed type char byte_10737618;

//----- (10062460) --------------------------------------------------------
char sub_10062460()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10737618 )
  {
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_1004F050(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           byte_10084570,
           (int)"This test is expected to fail");
    sub_1004A980(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_1004F050(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           byte_10084570,
           "a",
           (int)"This test is expected to fail");
    sub_1004A980(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_1004F050(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           byte_10084570,
           byte_10084570,
           (int)"This test is expected to fail");
    sub_1004A980(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_1004F050(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_1004A980(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10737618: using guessed type char byte_10737618;

//----- (10062680) --------------------------------------------------------
char sub_10062680()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_10100B64[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10100B60[v2];
        v4 = dword_10100B5C[v2];
        v5 = dword_10100B58[v2];
        v6 = sub_1004A620(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               *(_DWORD *)&off_10100B68[v2 * 4]);
        v7 = sub_1004CFE0(
               0,
               *(&dword_100FC6EC + dword_10100B64[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_10100B64[v2]],
               *(_DWORD *)&off_10100B68[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10100B58: using guessed type int dword_10100B58[];
// 10100B5C: using guessed type int dword_10100B5C[];
// 10100B60: using guessed type int dword_10100B60[];
// 10100B64: using guessed type int dword_10100B64[];
// 10737618: using guessed type char byte_10737618;

//----- (100627E0) --------------------------------------------------------
char sub_100627E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_10100ED0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_10100ECC[v2 / 2];
        v4 = word_10100ECA[v2 / 2];
        v5 = word_10100EC8[v2 / 2];
        v6 = sub_1004A620(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               (&off_10100ED4)[v2]);
        v7 = sub_1004D380(
               0,
               *(&dword_100FC6EC + dword_10100ED0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_10100ED0[v2 / 4]],
               (&off_10100ED4)[v2]);
        LOBYTE(v0) = sub_1004A980(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10100EC8: using guessed type __int16 word_10100EC8[];
// 10100ECA: using guessed type __int16 word_10100ECA[];
// 10100ECC: using guessed type __int16 word_10100ECC[];
// 10100ED0: using guessed type int dword_10100ED0[];
// 10100ED4: using guessed type char *off_10100ED4;
// 10737618: using guessed type char byte_10737618;

//----- (10062940) --------------------------------------------------------
char sub_10062940()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_10101194[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10101190[v2];
        v4 = dword_1010118C[v2];
        v5 = dword_10101188[v2];
        v6 = sub_1004A620(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               *(_DWORD *)&off_10101198[v2 * 4]);
        v7 = sub_1004D780(
               0,
               *(&dword_100FC6EC + dword_10101194[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_10101194[v2]],
               *(_DWORD *)&off_10101198[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10101188: using guessed type int dword_10101188[];
// 1010118C: using guessed type int dword_1010118C[];
// 10101190: using guessed type int dword_10101190[];
// 10101194: using guessed type int dword_10101194[];
// 10737618: using guessed type char byte_10737618;

//----- (10062AA0) --------------------------------------------------------
char sub_10062AA0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_10101510[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1010150C[v2];
        LODWORD(v3) = dword_10101508[v2];
        HIDWORD(v4) = dword_10101504[v2];
        LODWORD(v4) = dword_10101500[v2];
        HIDWORD(v5) = dword_101014FC[v2];
        LODWORD(v5) = dword_101014F8[v2];
        v6 = sub_1004A620(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               *(_DWORD *)&off_10101514[v2 * 4]);
        v7 = sub_1004DB20(
               0,
               *(&dword_100FC6EC + dword_10101510[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_10101510[v2]],
               *(_DWORD *)&off_10101514[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101014F8: using guessed type int dword_101014F8[];
// 101014FC: using guessed type int dword_101014FC[];
// 10101500: using guessed type int dword_10101500[];
// 10101504: using guessed type int dword_10101504[];
// 10101508: using guessed type int dword_10101508[];
// 1010150C: using guessed type int dword_1010150C[];
// 10101510: using guessed type int dword_10101510[];
// 10737618: using guessed type char byte_10737618;

//----- (10062C10) --------------------------------------------------------
char sub_10062C10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_10101A7C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_10101A7A[v2 * 4];
        v4 = byte_10101A79[v2 * 4];
        v5 = byte_10101A78[v2 * 4];
        v6 = sub_1004A620(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               (&off_10101A80)[v2 * 4]);
        v7 = sub_1004E100(
               0,
               *(&dword_100FC6EC + dword_10101A7C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_10101A7C[v2]],
               (&off_10101A80)[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10101A7C: using guessed type int dword_10101A7C[];
// 10101A80: using guessed type char *off_10101A80;
// 10737618: using guessed type char byte_10737618;

//----- (10062D70) --------------------------------------------------------
char sub_10062D70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_10101C94[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10101C90[v2];
        v4 = dword_10101C8C[v2];
        v5 = dword_10101C88[v2];
        v6 = sub_1004A620(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               *(_DWORD *)&off_10101C98[v2 * 4]);
        v7 = sub_1004E4F0(
               0,
               *(&dword_100FC6EC + dword_10101C94[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_10101C94[v2]],
               *(_DWORD *)&off_10101C98[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10101C88: using guessed type int dword_10101C88[];
// 10101C8C: using guessed type int dword_10101C8C[];
// 10101C90: using guessed type int dword_10101C90[];
// 10101C94: using guessed type int dword_10101C94[];
// 10737618: using guessed type char byte_10737618;

//----- (10062ED0) --------------------------------------------------------
char sub_10062ED0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10737618 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_10101FFC + v2) )
      {
        sub_1004A380((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_10102004[v2], 0x100u, &v11);
        sub_1004A380((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_10101FFC + v2), 0x100u, &v12);
        sub_1005FD60(&v12, &v11);
      }
      if ( byte_10101FF8[v2] )
      {
        sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = off_10102000[v2 / 4];
        v4 = *(char **)&off_10102004[v2];
        v5 = sub_1004A620(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10102004[v2],
               off_10102000[v2 / 4]);
        v6 = sub_1004ECA0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1004A980(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = off_10102000[v2 / 4];
        v8 = *(char **)&off_10102004[v2];
        v9 = sub_1004A620(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10102004[v2],
               off_10102000[v2 / 4]);
        v10 = sub_1004ECA0(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1004A980(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x90 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10101FFC: using guessed type void *off_10101FFC;
// 10102000: using guessed type char *off_10102000[2];
// 10737618: using guessed type char byte_10737618;

//----- (100630F0) --------------------------------------------------------
char sub_100630F0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_10737618 )
  {
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_1004A980(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1004A980(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_1004A980(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1004A980(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_1004A980(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1004A980(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_1004A980(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1004A980(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10737618: using guessed type char byte_10737618;

//----- (100632F0) --------------------------------------------------------
char sub_100632F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_1010208C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_10102089[v2 * 4];
        v4 = byte_10102088[v2 * 4];
        v5 = sub_1004A620(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + dword_1010208C[v2])],
               (&off_10102090)[v2 * 4]);
        v6 = sub_1004AAC0(
               1,
               *(&dword_100FC6EC + dword_1010208C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1004A620(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_1010208C[v2]],
               (&off_10102090)[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010208C: using guessed type int dword_1010208C[];
// 10102090: using guessed type char *off_10102090;
// 10737618: using guessed type char byte_10737618;

//----- (10063470) --------------------------------------------------------
char sub_10063470()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_10102310[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_10102308[v2 / 8];
        v4 = dbl_10102300[v2 / 8];
        v5 = dbl_101022F8[v2 / 8];
        v6 = sub_1004A620(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               *(_DWORD *)&off_10102314[v2]);
        v7 = sub_1004AE70(
               1,
               *(&dword_100FC6EC + dword_10102310[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_10102310[v2 / 4]],
               *(_DWORD *)&off_10102314[v2]);
        LOBYTE(v0) = sub_1004A980(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101022F8: using guessed type double dbl_101022F8[];
// 10102300: using guessed type double dbl_10102300[];
// 10102308: using guessed type double dbl_10102308[];
// 10102310: using guessed type int dword_10102310[];
// 10737618: using guessed type char byte_10737618;

//----- (100635F0) --------------------------------------------------------
char sub_100635F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_10102F24[v2];
      if ( v0 != 6 )
      {
        v3 = flt_10102F20[v2];
        v4 = flt_10102F1C[v2];
        v5 = flt_10102F18[v2];
        v6 = sub_1004A620(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               *(_DWORD *)&off_10102F28[v2 * 4]);
        v7 = sub_1004B2C0(
               1,
               *(&dword_100FC6EC + dword_10102F24[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_10102F24[v2]],
               *(_DWORD *)&off_10102F28[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10102F18: using guessed type float flt_10102F18[];
// 10102F1C: using guessed type float flt_10102F1C[];
// 10102F20: using guessed type float flt_10102F20[];
// 10102F24: using guessed type int dword_10102F24[];
// 10737618: using guessed type char byte_10737618;

//----- (10063760) --------------------------------------------------------
char sub_10063760()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10737618 )
  {
    sub_1004EFA0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_10063760,
      (int)sub_10063760,
      0);
    sub_1004EFA0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_10063760,
      0,
      0);
    result = sub_1004EFA0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10063760,
               0);
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10737618: using guessed type char byte_10737618;

//----- (10063850) --------------------------------------------------------
char sub_10063850()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_101036BC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_101036B8[v2];
        v4 = dword_101036B4[v2];
        v5 = dword_101036B0[v2];
        v6 = sub_1004A620(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               (&off_101036C0)[v2 * 4]);
        v7 = sub_1004B780(
               1,
               *(&dword_100FC6EC + dword_101036BC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_101036BC[v2]],
               (&off_101036C0)[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101036B0: using guessed type int dword_101036B0[];
// 101036B4: using guessed type int dword_101036B4[];
// 101036B8: using guessed type int dword_101036B8[];
// 101036BC: using guessed type int dword_101036BC[];
// 101036C0: using guessed type char *off_101036C0;
// 10737618: using guessed type char byte_10737618;

//----- (100639B0) --------------------------------------------------------
char sub_100639B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_10103E50[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_10103E4C[v2 / 2];
        v4 = word_10103E4A[v2 / 2];
        v5 = word_10103E48[v2 / 2];
        v6 = sub_1004A620(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               (&off_10103E54)[v2]);
        v7 = sub_1004BB40(
               1,
               *(&dword_100FC6EC + dword_10103E50[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_10103E50[v2 / 4]],
               (&off_10103E54)[v2]);
        LOBYTE(v0) = sub_1004A980(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10103E48: using guessed type __int16 word_10103E48[];
// 10103E4A: using guessed type __int16 word_10103E4A[];
// 10103E4C: using guessed type __int16 word_10103E4C[];
// 10103E50: using guessed type int dword_10103E50[];
// 10103E54: using guessed type char *off_10103E54;
// 10737618: using guessed type char byte_10737618;

//----- (10063B10) --------------------------------------------------------
char sub_10063B10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_10104464[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10104460[v2];
        v4 = dword_1010445C[v2];
        v5 = dword_10104458[v2];
        v6 = sub_1004A620(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               *(_DWORD *)&off_10104468[v2 * 4]);
        v7 = sub_1004BF40(
               1,
               *(&dword_100FC6EC + dword_10104464[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_10104464[v2]],
               *(_DWORD *)&off_10104468[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10104458: using guessed type int dword_10104458[];
// 1010445C: using guessed type int dword_1010445C[];
// 10104460: using guessed type int dword_10104460[];
// 10104464: using guessed type int dword_10104464[];
// 10737618: using guessed type char byte_10737618;

//----- (10063C70) --------------------------------------------------------
char sub_10063C70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_10104C08[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_10104C04[v2];
        LODWORD(v3) = dword_10104C00[v2];
        HIDWORD(v4) = dword_10104BFC[v2];
        LODWORD(v4) = dword_10104BF8[v2];
        HIDWORD(v5) = dword_10104BF4[v2];
        LODWORD(v5) = dword_10104BF0[v2];
        v6 = sub_1004A620(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               *(_DWORD *)&off_10104C0C[v2 * 4]);
        v7 = sub_1004C300(
               1,
               *(&dword_100FC6EC + dword_10104C08[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_10104C08[v2]],
               *(_DWORD *)&off_10104C0C[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10104BF0: using guessed type int dword_10104BF0[];
// 10104BF4: using guessed type int dword_10104BF4[];
// 10104BF8: using guessed type int dword_10104BF8[];
// 10104BFC: using guessed type int dword_10104BFC[];
// 10104C00: using guessed type int dword_10104C00[];
// 10104C04: using guessed type int dword_10104C04[];
// 10104C08: using guessed type int dword_10104C08[];
// 10737618: using guessed type char byte_10737618;

//----- (10063DE0) --------------------------------------------------------
char sub_10063DE0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_10105814[v2];
      if ( v0 != 6 )
      {
        v3 = byte_10105812[v2 * 4];
        v4 = byte_10105811[v2 * 4];
        v5 = byte_10105810[v2 * 4];
        v6 = sub_1004A620(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               (&off_10105818)[v2 * 4]);
        v7 = sub_1004C840(
               1,
               *(&dword_100FC6EC + dword_10105814[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_10105814[v2]],
               (&off_10105818)[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10105814: using guessed type int dword_10105814[];
// 10105818: using guessed type char *off_10105818;
// 10737618: using guessed type char byte_10737618;

//----- (10063F40) --------------------------------------------------------
char sub_10063F40()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_10105CAC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10105CA8[v2];
        v4 = dword_10105CA4[v2];
        v5 = dword_10105CA0[v2];
        v6 = sub_1004A620(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               (&off_10105CB0)[v2 * 4]);
        v7 = sub_1004CC20(
               1,
               *(&dword_100FC6EC + dword_10105CAC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_10105CAC[v2]],
               (&off_10105CB0)[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10105CA0: using guessed type int dword_10105CA0[];
// 10105CA4: using guessed type int dword_10105CA4[];
// 10105CA8: using guessed type int dword_10105CA8[];
// 10105CAC: using guessed type int dword_10105CAC[];
// 10105CB0: using guessed type char *off_10105CB0;
// 10737618: using guessed type char byte_10737618;

//----- (100640A0) --------------------------------------------------------
char sub_100640A0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10737618 )
  {
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_1004F050(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           byte_10084570,
           0);
    sub_1004A980(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_1004F050(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           byte_10084570,
           "a",
           0);
    sub_1004A980(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_1004F050(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           byte_10084570,
           byte_10084570,
           0);
    sub_1004A980(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_1004F050(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_1004A980(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10737618: using guessed type char byte_10737618;

//----- (100642A0) --------------------------------------------------------
char sub_100642A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_10106444[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10106440[v2];
        v4 = dword_1010643C[v2];
        v5 = dword_10106438[v2];
        v6 = sub_1004A620(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               *(_DWORD *)&off_10106448[v2 * 4]);
        v7 = sub_1004CFE0(
               1,
               *(&dword_100FC6EC + dword_10106444[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_10106444[v2]],
               *(_DWORD *)&off_10106448[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10106438: using guessed type int dword_10106438[];
// 1010643C: using guessed type int dword_1010643C[];
// 10106440: using guessed type int dword_10106440[];
// 10106444: using guessed type int dword_10106444[];
// 10737618: using guessed type char byte_10737618;

//----- (10064400) --------------------------------------------------------
char sub_10064400()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_101067B0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_101067AC[v2 / 2];
        v4 = word_101067AA[v2 / 2];
        v5 = word_101067A8[v2 / 2];
        v6 = sub_1004A620(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               (&off_101067B4)[v2]);
        v7 = sub_1004D380(
               1,
               *(&dword_100FC6EC + dword_101067B0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_101067B0[v2 / 4]],
               (&off_101067B4)[v2]);
        LOBYTE(v0) = sub_1004A980(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 101067A8: using guessed type __int16 word_101067A8[];
// 101067AA: using guessed type __int16 word_101067AA[];
// 101067AC: using guessed type __int16 word_101067AC[];
// 101067B0: using guessed type int dword_101067B0[];
// 101067B4: using guessed type char *off_101067B4;
// 10737618: using guessed type char byte_10737618;

//----- (10064560) --------------------------------------------------------
char sub_10064560()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_10106A74[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10106A70[v2];
        v4 = dword_10106A6C[v2];
        v5 = dword_10106A68[v2];
        v6 = sub_1004A620(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               *(_DWORD *)&off_10106A78[v2 * 4]);
        v7 = sub_1004D780(
               1,
               *(&dword_100FC6EC + dword_10106A74[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_10106A74[v2]],
               *(_DWORD *)&off_10106A78[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10106A68: using guessed type int dword_10106A68[];
// 10106A6C: using guessed type int dword_10106A6C[];
// 10106A70: using guessed type int dword_10106A70[];
// 10106A74: using guessed type int dword_10106A74[];
// 10737618: using guessed type char byte_10737618;

//----- (100646C0) --------------------------------------------------------
char sub_100646C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_10106DF0[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_10106DEC[v2];
        LODWORD(v3) = dword_10106DE8[v2];
        HIDWORD(v4) = dword_10106DE4[v2];
        LODWORD(v4) = dword_10106DE0[v2];
        HIDWORD(v5) = dword_10106DDC[v2];
        LODWORD(v5) = dword_10106DD8[v2];
        v6 = sub_1004A620(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               *(_DWORD *)&off_10106DF4[v2 * 4]);
        v7 = sub_1004DB20(
               1,
               *(&dword_100FC6EC + dword_10106DF0[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_10106DF0[v2]],
               *(_DWORD *)&off_10106DF4[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10106DD8: using guessed type int dword_10106DD8[];
// 10106DDC: using guessed type int dword_10106DDC[];
// 10106DE0: using guessed type int dword_10106DE0[];
// 10106DE4: using guessed type int dword_10106DE4[];
// 10106DE8: using guessed type int dword_10106DE8[];
// 10106DEC: using guessed type int dword_10106DEC[];
// 10106DF0: using guessed type int dword_10106DF0[];
// 10737618: using guessed type char byte_10737618;

//----- (10064830) --------------------------------------------------------
char sub_10064830()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_1010735C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1010735A[v2 * 4];
        v4 = byte_10107359[v2 * 4];
        v5 = byte_10107358[v2 * 4];
        v6 = sub_1004A620(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               (&off_10107360)[v2 * 4]);
        v7 = sub_1004E100(
               1,
               *(&dword_100FC6EC + dword_1010735C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_1010735C[v2]],
               (&off_10107360)[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1010735C: using guessed type int dword_1010735C[];
// 10107360: using guessed type char *off_10107360;
// 10737618: using guessed type char byte_10737618;

//----- (10064990) --------------------------------------------------------
char sub_10064990()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10737618 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_10107574[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10107570[v2];
        v4 = dword_1010756C[v2];
        v5 = dword_10107568[v2];
        v6 = sub_1004A620(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * *(&dword_100FC6EC + v0)],
               *(_DWORD *)&off_10107578[v2 * 4]);
        v7 = sub_1004E4F0(
               1,
               *(&dword_100FC6EC + dword_10107574[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A620(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_10107574[v2]],
               *(_DWORD *)&off_10107578[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10107568: using guessed type int dword_10107568[];
// 1010756C: using guessed type int dword_1010756C[];
// 10107570: using guessed type int dword_10107570[];
// 10107574: using guessed type int dword_10107574[];
// 10737618: using guessed type char byte_10737618;

//----- (10064AF0) --------------------------------------------------------
char sub_10064AF0()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_10737619 )
  {
    sub_1004F050(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_1004B780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_1004B780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_1004B780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_1004B780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_1004B780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_1004B780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_1004B780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_1004B780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_1004B780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_1004B780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_10049BC0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_1004B780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_10048620() )
      v1 = 3;
    sub_1004B780(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_10048620();
    sub_1004B780(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_10049BC0(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_1004B780(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10737619: using guessed type char byte_10737619;

//----- (10065090) --------------------------------------------------------
char sub_10065090()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  int v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10737619 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_101078DC + v2) )
      {
        sub_1004A380((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_101078E4[v2], 0x100u, &v13);
        sub_1004A380((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_101078DC + v2), 0x100u, &v14);
        sub_1005FD60(&v14, &v13);
      }
      if ( byte_101078D8[v2] )
      {
        sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = *(int *)((char *)&off_101078E0 + v2);
        v4 = *(char **)&off_101078E4[v2];
        v5 = sub_1004A620(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_101078E4[v2],
               *(void **)((char *)&off_101078E0 + v2));
        v12 = 1;
        v11 = sub_1004ECA0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2114", (int)v5, (int)v4, v3, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = *(int *)((char *)&off_101078E0 + v2);
        v7 = *(char **)&off_101078E4[v2];
        v8 = sub_1004A620(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_101078E4[v2],
               *(void **)((char *)&off_101078E0 + v2));
        v12 = 1;
        v11 = sub_1004ECA0(0, 1, (int)"..\\lib\\utf\\utf_validate.c", (int)"2123", (int)v8, (int)v7, v6, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_1004A980(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 16;
    }
    while ( v2 < 0x50 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101078DC: using guessed type void *off_101078DC;
// 101078E0: using guessed type void *off_101078E0;
// 10737619: using guessed type char byte_10737619;

//----- (100652A0) --------------------------------------------------------
char sub_100652A0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10737619 )
  {
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_1004A980(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1004A980(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_1004A980(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1004A980(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_1004A980(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1004A980(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_1004A980(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1004A980(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10737619: using guessed type char byte_10737619;

//----- (10065490) --------------------------------------------------------
char sub_10065490()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_1010792C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_10107929[v2 * 4];
        v4 = byte_10107928[v2 * 4];
        v5 = sub_1004A620(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * dword_1010792C[v2]],
               (&off_10107930)[v2 * 4]);
        v6 = sub_1004AAC0(0, dword_1010792C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_1004A620(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_1010792C[v2]],
               (&off_10107930)[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 1010792C: using guessed type int dword_1010792C[];
// 10107930: using guessed type char *off_10107930;
// 10737619: using guessed type char byte_10737619;

//----- (10065600) --------------------------------------------------------
char sub_10065600()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_10107BA8[v2 / 2];
      v4 = dbl_10107BA0[v2 / 2];
      v5 = dbl_10107B98[v2 / 2];
      v6 = sub_1004A620(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_10107BB0[v2]],
             *(_DWORD *)&off_10107BB4[v2 * 4]);
      v7 = sub_1004AE70(0, dword_10107BB0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_10107BB0[v2]],
             *(_DWORD *)&off_10107BB4[v2 * 4]);
      result = sub_1004A980(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10107B98: using guessed type double dbl_10107B98[];
// 10107BA0: using guessed type double dbl_10107BA0[];
// 10107BA8: using guessed type double dbl_10107BA8[];
// 10107BB0: using guessed type int dword_10107BB0[];
// 10737619: using guessed type char byte_10737619;

//----- (10065770) --------------------------------------------------------
char sub_10065770()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_101087C0[v2];
      v4 = flt_101087BC[v2];
      v5 = flt_101087B8[v2];
      v6 = sub_1004A620(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_101087C4[v2]],
             *(_DWORD *)&off_101087C8[v2 * 4]);
      v7 = sub_1004B2C0(0, dword_101087C4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_101087C4[v2]],
             *(_DWORD *)&off_101087C8[v2 * 4]);
      result = sub_1004A980(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101087B8: using guessed type float flt_101087B8[];
// 101087BC: using guessed type float flt_101087BC[];
// 101087C0: using guessed type float flt_101087C0[];
// 101087C4: using guessed type int dword_101087C4[];
// 10737619: using guessed type char byte_10737619;

//----- (100658D0) --------------------------------------------------------
char sub_100658D0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10737619 )
  {
    sub_1004EFA0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_100658D0,
      (int)sub_100658D0,
      0);
    sub_1004EFA0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_100658D0,
      0,
      0);
    result = sub_1004EFA0(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_100658D0,
               0);
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10737619: using guessed type char byte_10737619;

//----- (100659C0) --------------------------------------------------------
char sub_100659C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_10108F58[v2];
      v4 = dword_10108F54[v2];
      v5 = dword_10108F50[v2];
      v6 = sub_1004A620(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_10108F5C[v2]],
             (&off_10108F60)[v2 * 4]);
      v7 = sub_1004B780(0, dword_10108F5C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_10108F5C[v2]],
             (&off_10108F60)[v2 * 4]);
      result = sub_1004A980(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10108F50: using guessed type int dword_10108F50[];
// 10108F54: using guessed type int dword_10108F54[];
// 10108F58: using guessed type int dword_10108F58[];
// 10108F5C: using guessed type int dword_10108F5C[];
// 10108F60: using guessed type char *off_10108F60;
// 10737619: using guessed type char byte_10737619;

//----- (10065B20) --------------------------------------------------------
char sub_10065B20()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_101096EC[v2 / 2];
      v4 = word_101096EA[v2 / 2];
      v5 = word_101096E8[v2 / 2];
      v6 = sub_1004A620(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_101096F0[v2 / 4]],
             (&off_101096F4)[v2]);
      v7 = sub_1004BB40(
             0,
             dword_101096F0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_101096F0[v2 / 4]],
             (&off_101096F4)[v2]);
      result = sub_1004A980(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101096E8: using guessed type __int16 word_101096E8[];
// 101096EA: using guessed type __int16 word_101096EA[];
// 101096EC: using guessed type __int16 word_101096EC[];
// 101096F0: using guessed type int dword_101096F0[];
// 101096F4: using guessed type char *off_101096F4;
// 10737619: using guessed type char byte_10737619;

//----- (10065C80) --------------------------------------------------------
char sub_10065C80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_10109D00[v2];
      v4 = dword_10109CFC[v2];
      v5 = dword_10109CF8[v2];
      v6 = sub_1004A620(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_10109D04[v2]],
             *(_DWORD *)&off_10109D08[v2 * 4]);
      v7 = sub_1004BF40(0, dword_10109D04[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_10109D04[v2]],
             *(_DWORD *)&off_10109D08[v2 * 4]);
      result = sub_1004A980(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10109CF8: using guessed type int dword_10109CF8[];
// 10109CFC: using guessed type int dword_10109CFC[];
// 10109D00: using guessed type int dword_10109D00[];
// 10109D04: using guessed type int dword_10109D04[];
// 10737619: using guessed type char byte_10737619;

//----- (10065DE0) --------------------------------------------------------
char sub_10065DE0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_1010A4A4[v2];
      LODWORD(v3) = dword_1010A4A0[v2];
      HIDWORD(v4) = dword_1010A49C[v2];
      LODWORD(v4) = dword_1010A498[v2];
      HIDWORD(v5) = dword_1010A494[v2];
      LODWORD(v5) = dword_1010A490[v2];
      v6 = sub_1004A620(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010A4A8[v2]],
             *(_DWORD *)&off_1010A4AC[v2 * 4]);
      v7 = sub_1004C300(0, dword_1010A4A8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010A4A8[v2]],
             *(_DWORD *)&off_1010A4AC[v2 * 4]);
      result = sub_1004A980(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1010A490: using guessed type int dword_1010A490[];
// 1010A494: using guessed type int dword_1010A494[];
// 1010A498: using guessed type int dword_1010A498[];
// 1010A49C: using guessed type int dword_1010A49C[];
// 1010A4A0: using guessed type int dword_1010A4A0[];
// 1010A4A4: using guessed type int dword_1010A4A4[];
// 1010A4A8: using guessed type int dword_1010A4A8[];
// 10737619: using guessed type char byte_10737619;

//----- (10065F50) --------------------------------------------------------
char sub_10065F50()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_1010B0B2[v2 * 4];
      v4 = byte_1010B0B1[v2 * 4];
      v5 = byte_1010B0B0[v2 * 4];
      v6 = sub_1004A620(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010B0B4[v2]],
             (&off_1010B0B8)[v2 * 4]);
      v7 = sub_1004C840(0, dword_1010B0B4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010B0B4[v2]],
             (&off_1010B0B8)[v2 * 4]);
      result = sub_1004A980(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1010B0B4: using guessed type int dword_1010B0B4[];
// 1010B0B8: using guessed type char *off_1010B0B8;
// 10737619: using guessed type char byte_10737619;

//----- (100660B0) --------------------------------------------------------
char sub_100660B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_1010B548[v2];
      v4 = dword_1010B544[v2];
      v5 = dword_1010B540[v2];
      v6 = sub_1004A620(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010B54C[v2]],
             (&off_1010B550)[v2 * 4]);
      v7 = sub_1004CC20(0, dword_1010B54C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010B54C[v2]],
             (&off_1010B550)[v2 * 4]);
      result = sub_1004A980(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1010B540: using guessed type int dword_1010B540[];
// 1010B544: using guessed type int dword_1010B544[];
// 1010B548: using guessed type int dword_1010B548[];
// 1010B54C: using guessed type int dword_1010B54C[];
// 1010B550: using guessed type char *off_1010B550;
// 10737619: using guessed type char byte_10737619;

//----- (10066210) --------------------------------------------------------
char sub_10066210()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10737619 )
  {
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_1004F050(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           byte_10084570,
           byte_10084570,
           0);
    sub_1004A980(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_1004F050(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1004A980(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_1004F050(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           byte_10084570,
           0);
    sub_1004A980(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_1004F050(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1004A980(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10737619: using guessed type char byte_10737619;

//----- (10066410) --------------------------------------------------------
char sub_10066410()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_1010BCE0[v2];
      v4 = dword_1010BCDC[v2];
      v5 = dword_1010BCD8[v2];
      v6 = sub_1004A620(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010BCE4[v2]],
             *(_DWORD *)&off_1010BCE8[v2 * 4]);
      v7 = sub_1004CFE0(0, dword_1010BCE4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010BCE4[v2]],
             *(_DWORD *)&off_1010BCE8[v2 * 4]);
      result = sub_1004A980(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1010BCD8: using guessed type int dword_1010BCD8[];
// 1010BCDC: using guessed type int dword_1010BCDC[];
// 1010BCE0: using guessed type int dword_1010BCE0[];
// 1010BCE4: using guessed type int dword_1010BCE4[];
// 10737619: using guessed type char byte_10737619;

//----- (10066570) --------------------------------------------------------
char sub_10066570()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_1010C04C[v2 / 2];
      v4 = word_1010C04A[v2 / 2];
      v5 = word_1010C048[v2 / 2];
      v6 = sub_1004A620(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010C050[v2 / 4]],
             (&off_1010C054)[v2]);
      v7 = sub_1004D380(
             0,
             dword_1010C050[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010C050[v2 / 4]],
             (&off_1010C054)[v2]);
      result = sub_1004A980(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1010C048: using guessed type __int16 word_1010C048[];
// 1010C04A: using guessed type __int16 word_1010C04A[];
// 1010C04C: using guessed type __int16 word_1010C04C[];
// 1010C050: using guessed type int dword_1010C050[];
// 1010C054: using guessed type char *off_1010C054;
// 10737619: using guessed type char byte_10737619;

//----- (100666D0) --------------------------------------------------------
char sub_100666D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_1010C310[v2];
      v4 = dword_1010C30C[v2];
      v5 = dword_1010C308[v2];
      v6 = sub_1004A620(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010C314[v2]],
             *(_DWORD *)&off_1010C318[v2 * 4]);
      v7 = sub_1004D780(0, dword_1010C314[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010C314[v2]],
             *(_DWORD *)&off_1010C318[v2 * 4]);
      result = sub_1004A980(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1010C308: using guessed type int dword_1010C308[];
// 1010C30C: using guessed type int dword_1010C30C[];
// 1010C310: using guessed type int dword_1010C310[];
// 1010C314: using guessed type int dword_1010C314[];
// 10737619: using guessed type char byte_10737619;

//----- (10066830) --------------------------------------------------------
char sub_10066830()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_1010C68C[v2];
      LODWORD(v3) = dword_1010C688[v2];
      HIDWORD(v4) = dword_1010C684[v2];
      LODWORD(v4) = dword_1010C680[v2];
      HIDWORD(v5) = dword_1010C67C[v2];
      LODWORD(v5) = dword_1010C678[v2];
      v6 = sub_1004A620(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010C690[v2]],
             *(_DWORD *)&off_1010C694[v2 * 4]);
      v7 = sub_1004DB20(0, dword_1010C690[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010C690[v2]],
             *(_DWORD *)&off_1010C694[v2 * 4]);
      result = sub_1004A980(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1010C678: using guessed type int dword_1010C678[];
// 1010C67C: using guessed type int dword_1010C67C[];
// 1010C680: using guessed type int dword_1010C680[];
// 1010C684: using guessed type int dword_1010C684[];
// 1010C688: using guessed type int dword_1010C688[];
// 1010C68C: using guessed type int dword_1010C68C[];
// 1010C690: using guessed type int dword_1010C690[];
// 10737619: using guessed type char byte_10737619;

//----- (100669A0) --------------------------------------------------------
char sub_100669A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_1010CBFA[v2 * 4];
      v4 = byte_1010CBF9[v2 * 4];
      v5 = byte_1010CBF8[v2 * 4];
      v6 = sub_1004A620(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010CBFC[v2]],
             (&off_1010CC00)[v2 * 4]);
      v7 = sub_1004E100(0, dword_1010CBFC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010CBFC[v2]],
             (&off_1010CC00)[v2 * 4]);
      result = sub_1004A980(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1010CBFC: using guessed type int dword_1010CBFC[];
// 1010CC00: using guessed type char *off_1010CC00;
// 10737619: using guessed type char byte_10737619;

//----- (10066B00) --------------------------------------------------------
char sub_10066B00()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_1010CE10[v2];
      v4 = dword_1010CE0C[v2];
      v5 = dword_1010CE08[v2];
      v6 = sub_1004A620(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010CE14[v2]],
             *(_DWORD *)&off_1010CE18[v2 * 4]);
      v7 = sub_1004E4F0(0, dword_1010CE14[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010CE14[v2]],
             *(_DWORD *)&off_1010CE18[v2 * 4]);
      result = sub_1004A980(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1010CE08: using guessed type int dword_1010CE08[];
// 1010CE0C: using guessed type int dword_1010CE0C[];
// 1010CE10: using guessed type int dword_1010CE10[];
// 1010CE14: using guessed type int dword_1010CE14[];
// 10737619: using guessed type char byte_10737619;

//----- (10066C60) --------------------------------------------------------
char sub_10066C60()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  int v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10737619 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_1010D17C + v2) )
      {
        sub_1004A380((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1010D184[v2], 0x100u, &v13);
        sub_1004A380((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_1010D17C + v2), 0x100u, &v14);
        sub_1005FD60(&v14, &v13);
      }
      if ( byte_1010D178[v2] )
      {
        sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = *(int *)((char *)&off_1010D180 + v2);
        v4 = *(char **)&off_1010D184[v2];
        v5 = sub_1004A620(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1010D184[v2],
               *(void **)((char *)&off_1010D180 + v2));
        v12 = 1;
        v11 = sub_1004ECA0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2745", (int)v5, (int)v4, v3, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = *(int *)((char *)&off_1010D180 + v2);
        v7 = *(char **)&off_1010D184[v2];
        v8 = sub_1004A620(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1010D184[v2],
               *(void **)((char *)&off_1010D180 + v2));
        v12 = 1;
        v11 = sub_1004ECA0(1, 1, (int)"..\\lib\\utf\\utf_validate.c", (int)"2754", (int)v8, (int)v7, v6, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_1004A980(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 16;
    }
    while ( v2 < 0x50 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1010D17C: using guessed type void *off_1010D17C;
// 1010D180: using guessed type void *off_1010D180;
// 10737619: using guessed type char byte_10737619;

//----- (10066E70) --------------------------------------------------------
char sub_10066E70()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10737619 )
  {
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_1004A980(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1004A980(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_1004A980(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1004A980(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_1004A980(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1004A980(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_1004A980(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1004A980(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10737619: using guessed type char byte_10737619;

//----- (10067060) --------------------------------------------------------
char sub_10067060()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      v0 = dword_1010D1CC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_1010D1C9[v2 * 4];
        v4 = byte_1010D1C8[v2 * 4];
        v5 = sub_1004A620(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100FC6D0[4 * dword_1010D1CC[v2]],
               (&off_1010D1D0)[v2 * 4]);
        v6 = sub_1004AAC0(1, dword_1010D1CC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_1004A620(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100FC6D0[4 * dword_1010D1CC[v2]],
               (&off_1010D1D0)[v2 * 4]);
        LOBYTE(v0) = sub_1004A980(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10049BC0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 1010D1CC: using guessed type int dword_1010D1CC[];
// 1010D1D0: using guessed type char *off_1010D1D0;
// 10737619: using guessed type char byte_10737619;

//----- (100671D0) --------------------------------------------------------
char sub_100671D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_1010D448[v2 / 2];
      v4 = dbl_1010D440[v2 / 2];
      v5 = dbl_1010D438[v2 / 2];
      v6 = sub_1004A620(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010D450[v2]],
             *(_DWORD *)&off_1010D454[v2 * 4]);
      v7 = sub_1004AE70(1, dword_1010D450[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010D450[v2]],
             *(_DWORD *)&off_1010D454[v2 * 4]);
      result = sub_1004A980(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1010D438: using guessed type double dbl_1010D438[];
// 1010D440: using guessed type double dbl_1010D440[];
// 1010D448: using guessed type double dbl_1010D448[];
// 1010D450: using guessed type int dword_1010D450[];
// 10737619: using guessed type char byte_10737619;

//----- (10067340) --------------------------------------------------------
char sub_10067340()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_1010E060[v2];
      v4 = flt_1010E05C[v2];
      v5 = flt_1010E058[v2];
      v6 = sub_1004A620(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010E064[v2]],
             *(_DWORD *)&off_1010E068[v2 * 4]);
      v7 = sub_1004B2C0(1, dword_1010E064[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010E064[v2]],
             *(_DWORD *)&off_1010E068[v2 * 4]);
      result = sub_1004A980(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1010E058: using guessed type float flt_1010E058[];
// 1010E05C: using guessed type float flt_1010E05C[];
// 1010E060: using guessed type float flt_1010E060[];
// 1010E064: using guessed type int dword_1010E064[];
// 10737619: using guessed type char byte_10737619;

//----- (100674A0) --------------------------------------------------------
char sub_100674A0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10737619 )
  {
    sub_1004EFA0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_100674A0,
      (int)sub_100674A0,
      0);
    sub_1004EFA0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_100674A0,
      0,
      0);
    result = sub_1004EFA0(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_100674A0,
               0);
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10737619: using guessed type char byte_10737619;

//----- (10067590) --------------------------------------------------------
char sub_10067590()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_1010E7F8[v2];
      v4 = dword_1010E7F4[v2];
      v5 = dword_1010E7F0[v2];
      v6 = sub_1004A620(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010E7FC[v2]],
             (&off_1010E800)[v2 * 4]);
      v7 = sub_1004B780(1, dword_1010E7FC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010E7FC[v2]],
             (&off_1010E800)[v2 * 4]);
      result = sub_1004A980(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1010E7F0: using guessed type int dword_1010E7F0[];
// 1010E7F4: using guessed type int dword_1010E7F4[];
// 1010E7F8: using guessed type int dword_1010E7F8[];
// 1010E7FC: using guessed type int dword_1010E7FC[];
// 1010E800: using guessed type char *off_1010E800;
// 10737619: using guessed type char byte_10737619;

//----- (100676F0) --------------------------------------------------------
char sub_100676F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_1010EF8C[v2 / 2];
      v4 = word_1010EF8A[v2 / 2];
      v5 = word_1010EF88[v2 / 2];
      v6 = sub_1004A620(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010EF90[v2 / 4]],
             (&off_1010EF94)[v2]);
      v7 = sub_1004BB40(
             1,
             dword_1010EF90[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010EF90[v2 / 4]],
             (&off_1010EF94)[v2]);
      result = sub_1004A980(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1010EF88: using guessed type __int16 word_1010EF88[];
// 1010EF8A: using guessed type __int16 word_1010EF8A[];
// 1010EF8C: using guessed type __int16 word_1010EF8C[];
// 1010EF90: using guessed type int dword_1010EF90[];
// 1010EF94: using guessed type char *off_1010EF94;
// 10737619: using guessed type char byte_10737619;

//----- (10067850) --------------------------------------------------------
char sub_10067850()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_1010F5A0[v2];
      v4 = dword_1010F59C[v2];
      v5 = dword_1010F598[v2];
      v6 = sub_1004A620(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010F5A4[v2]],
             *(_DWORD *)&off_1010F5A8[v2 * 4]);
      v7 = sub_1004BF40(1, dword_1010F5A4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010F5A4[v2]],
             *(_DWORD *)&off_1010F5A8[v2 * 4]);
      result = sub_1004A980(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1010F598: using guessed type int dword_1010F598[];
// 1010F59C: using guessed type int dword_1010F59C[];
// 1010F5A0: using guessed type int dword_1010F5A0[];
// 1010F5A4: using guessed type int dword_1010F5A4[];
// 10737619: using guessed type char byte_10737619;

//----- (100679B0) --------------------------------------------------------
char sub_100679B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_1010FD44[v2];
      LODWORD(v3) = dword_1010FD40[v2];
      HIDWORD(v4) = dword_1010FD3C[v2];
      LODWORD(v4) = dword_1010FD38[v2];
      HIDWORD(v5) = dword_1010FD34[v2];
      LODWORD(v5) = dword_1010FD30[v2];
      v6 = sub_1004A620(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010FD48[v2]],
             *(_DWORD *)&off_1010FD4C[v2 * 4]);
      v7 = sub_1004C300(1, dword_1010FD48[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_1010FD48[v2]],
             *(_DWORD *)&off_1010FD4C[v2 * 4]);
      result = sub_1004A980(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1010FD30: using guessed type int dword_1010FD30[];
// 1010FD34: using guessed type int dword_1010FD34[];
// 1010FD38: using guessed type int dword_1010FD38[];
// 1010FD3C: using guessed type int dword_1010FD3C[];
// 1010FD40: using guessed type int dword_1010FD40[];
// 1010FD44: using guessed type int dword_1010FD44[];
// 1010FD48: using guessed type int dword_1010FD48[];
// 10737619: using guessed type char byte_10737619;

//----- (10067B20) --------------------------------------------------------
char sub_10067B20()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_10110952[v2 * 4];
      v4 = byte_10110951[v2 * 4];
      v5 = byte_10110950[v2 * 4];
      v6 = sub_1004A620(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_10110954[v2]],
             (&off_10110958)[v2 * 4]);
      v7 = sub_1004C840(1, dword_10110954[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_10110954[v2]],
             (&off_10110958)[v2 * 4]);
      result = sub_1004A980(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10110954: using guessed type int dword_10110954[];
// 10110958: using guessed type char *off_10110958;
// 10737619: using guessed type char byte_10737619;

//----- (10067C80) --------------------------------------------------------
char sub_10067C80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_10110DE8[v2];
      v4 = dword_10110DE4[v2];
      v5 = dword_10110DE0[v2];
      v6 = sub_1004A620(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_10110DEC[v2]],
             (&off_10110DF0)[v2 * 4]);
      v7 = sub_1004CC20(1, dword_10110DEC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_10110DEC[v2]],
             (&off_10110DF0)[v2 * 4]);
      result = sub_1004A980(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10110DE0: using guessed type int dword_10110DE0[];
// 10110DE4: using guessed type int dword_10110DE4[];
// 10110DE8: using guessed type int dword_10110DE8[];
// 10110DEC: using guessed type int dword_10110DEC[];
// 10110DF0: using guessed type char *off_10110DF0;
// 10737619: using guessed type char byte_10737619;

//----- (10067DE0) --------------------------------------------------------
char sub_10067DE0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049BC0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1004A510(0);
  sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_10049BC0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10737619 )
  {
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_1004F050(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           byte_10084570,
           byte_10084570,
           0);
    sub_1004A980(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_1004F050(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1004A980(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_1004F050(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           byte_10084570,
           0);
    sub_1004A980(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_1004F050(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1004A980(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10737619: using guessed type char byte_10737619;

//----- (10067FE0) --------------------------------------------------------
char sub_10067FE0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_10111580[v2];
      v4 = dword_1011157C[v2];
      v5 = dword_10111578[v2];
      v6 = sub_1004A620(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_10111584[v2]],
             *(_DWORD *)&off_10111588[v2 * 4]);
      v7 = sub_1004CFE0(1, dword_10111584[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_10111584[v2]],
             *(_DWORD *)&off_10111588[v2 * 4]);
      result = sub_1004A980(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10111578: using guessed type int dword_10111578[];
// 1011157C: using guessed type int dword_1011157C[];
// 10111580: using guessed type int dword_10111580[];
// 10111584: using guessed type int dword_10111584[];
// 10737619: using guessed type char byte_10737619;

//----- (10068140) --------------------------------------------------------
char sub_10068140()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_101118EC[v2 / 2];
      v4 = word_101118EA[v2 / 2];
      v5 = word_101118E8[v2 / 2];
      v6 = sub_1004A620(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_101118F0[v2 / 4]],
             (&off_101118F4)[v2]);
      v7 = sub_1004D380(
             1,
             dword_101118F0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_101118F0[v2 / 4]],
             (&off_101118F4)[v2]);
      result = sub_1004A980(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101118E8: using guessed type __int16 word_101118E8[];
// 101118EA: using guessed type __int16 word_101118EA[];
// 101118EC: using guessed type __int16 word_101118EC[];
// 101118F0: using guessed type int dword_101118F0[];
// 101118F4: using guessed type char *off_101118F4;
// 10737619: using guessed type char byte_10737619;

//----- (100682A0) --------------------------------------------------------
char sub_100682A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_10111BB0[v2];
      v4 = dword_10111BAC[v2];
      v5 = dword_10111BA8[v2];
      v6 = sub_1004A620(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_10111BB4[v2]],
             *(_DWORD *)&off_10111BB8[v2 * 4]);
      v7 = sub_1004D780(1, dword_10111BB4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_10111BB4[v2]],
             *(_DWORD *)&off_10111BB8[v2 * 4]);
      result = sub_1004A980(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10111BA8: using guessed type int dword_10111BA8[];
// 10111BAC: using guessed type int dword_10111BAC[];
// 10111BB0: using guessed type int dword_10111BB0[];
// 10111BB4: using guessed type int dword_10111BB4[];
// 10737619: using guessed type char byte_10737619;

//----- (10068400) --------------------------------------------------------
char sub_10068400()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_10111F2C[v2];
      LODWORD(v3) = dword_10111F28[v2];
      HIDWORD(v4) = dword_10111F24[v2];
      LODWORD(v4) = dword_10111F20[v2];
      HIDWORD(v5) = dword_10111F1C[v2];
      LODWORD(v5) = dword_10111F18[v2];
      v6 = sub_1004A620(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_10111F30[v2]],
             *(_DWORD *)&off_10111F34[v2 * 4]);
      v7 = sub_1004DB20(1, dword_10111F30[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_10111F30[v2]],
             *(_DWORD *)&off_10111F34[v2 * 4]);
      result = sub_1004A980(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10111F18: using guessed type int dword_10111F18[];
// 10111F1C: using guessed type int dword_10111F1C[];
// 10111F20: using guessed type int dword_10111F20[];
// 10111F24: using guessed type int dword_10111F24[];
// 10111F28: using guessed type int dword_10111F28[];
// 10111F2C: using guessed type int dword_10111F2C[];
// 10111F30: using guessed type int dword_10111F30[];
// 10737619: using guessed type char byte_10737619;

//----- (10068570) --------------------------------------------------------
char sub_10068570()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_1011249A[v2 * 4];
      v4 = byte_10112499[v2 * 4];
      v5 = byte_10112498[v2 * 4];
      v6 = sub_1004A620(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_1011249C[v2]],
             (&off_101124A0)[v2 * 4]);
      v7 = sub_1004E100(1, dword_1011249C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_1011249C[v2]],
             (&off_101124A0)[v2 * 4]);
      result = sub_1004A980(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1011249C: using guessed type int dword_1011249C[];
// 101124A0: using guessed type char *off_101124A0;
// 10737619: using guessed type char byte_10737619;

//----- (100686D0) --------------------------------------------------------
char sub_100686D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10737619 )
  {
    sub_10049BC0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1004A510(0);
    sub_10049BC0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_10049BC0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1004A600(0);
    v2 = 0;
    do
    {
      sub_1004A530((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_101126B0[v2];
      v4 = dword_101126AC[v2];
      v5 = dword_101126A8[v2];
      v6 = sub_1004A620(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100FC6D0[4 * dword_101126B4[v2]],
             *(_DWORD *)&off_101126B8[v2 * 4]);
      v7 = sub_1004E4F0(1, dword_101126B4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A620(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100FC6D0[4 * dword_101126B4[v2]],
             *(_DWORD *)&off_101126B8[v2 * 4]);
      result = sub_1004A980(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049BC0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101126A8: using guessed type int dword_101126A8[];
// 101126AC: using guessed type int dword_101126AC[];
// 101126B0: using guessed type int dword_101126B0[];
// 101126B4: using guessed type int dword_101126B4[];
// 10737619: using guessed type char byte_10737619;

//----- (10068830) --------------------------------------------------------
char **sub_10068830()
{
  return off_100FDDBC;
}
// 100FDDBC: using guessed type char *off_100FDDBC[3];

//----- (10068840) --------------------------------------------------------
int __cdecl sub_10068840(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (10068860) --------------------------------------------------------
int (__cdecl *__usercall sub_10068860@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (10068870) --------------------------------------------------------
int __usercall sub_10068870@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (10068AA0) --------------------------------------------------------
int (__cdecl *__cdecl sub_10068AA0(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_10068860(a1, (int)word_10088C68);
  sub_10068860(a1, a2);
  sub_10068860(a1, (int)&unk_1011690C);
  v3 = sub_10068870(a3, a1);
  sub_10068860(a1, v3);
  return sub_10068860(a1, (int)&unk_10116908);
}

//----- (10068AF0) --------------------------------------------------------
int (__cdecl *__cdecl sub_10068AF0(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_10068860(a1, (int)word_10088C68);
  sub_10068860(a1, a2);
  sub_10068860(a1, (int)&unk_10116914);
  v3 = sub_10068870(a3, a1);
  sub_10068860(a1, v3);
  return sub_10068860(a1, (int)&unk_10116910);
}

//----- (10068B40) --------------------------------------------------------
int (__cdecl *__cdecl sub_10068B40(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_10068860(a1, (int)&unk_10116918);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_10068870(a2, a1);
    result = sub_10068860(a1, v3);
  }
  return result;
}

//----- (10068B90) --------------------------------------------------------
int (__cdecl *__cdecl sub_10068B90(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_10116920;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_10068860(a1, dword_10116874[(signed int)result]);
      sub_10068860(a1, (int)&unk_1011691C);
      sub_10068860(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_10116918;
    }
    result = sub_10068860(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_10068860(a1, (int)"\r\n");
  }
  return result;
}
// 10116874: using guessed type int dword_10116874[];

//----- (10068C10) --------------------------------------------------------
int __cdecl sub_10068C10(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_10068860(a1, (int)&unk_10116918);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_10068860(a1, (int)off_10116878[*(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84)]);
  sub_10068860(a1, (int)&unk_10116924);
  sub_10068860(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}
// 10116878: using guessed type char *off_10116878[19];

//----- (10068C90) --------------------------------------------------------
int (__cdecl *__cdecl sub_10068C90(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_10068870(a2, a1);
    sub_10068860(a1, v3);
    result = sub_10068860(a1, (int)"\r\n");
  }
  else
  {
    sub_10068860(a1, (int)a2);
    result = sub_10068860(a1, (int)"\r\n");
  }
  return result;
}

//----- (10068CE0) --------------------------------------------------------
int (__cdecl *__cdecl sub_10068CE0(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_10068C10(a1, a2);
  if ( a3 && *a3 )
    sub_10068B40(a1, a3);
  return sub_10068B90(a1);
}

//----- (10068D20) --------------------------------------------------------
int (__cdecl *__cdecl sub_10068D20(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_10068CE0(a1, a2, (unsigned __int8 *)&v4);
}

//----- (10068D80) --------------------------------------------------------
char __cdecl sub_10068D80(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_100364C0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (10068E00) --------------------------------------------------------
char __cdecl sub_10068E00(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_100364C0("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (10068E40) --------------------------------------------------------
int __cdecl sub_10068E40(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_1011B384[2 * sub_1003B860(&a1, 1u, (int)&unk_1011B380, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_1011B3C4[2 * sub_1003B860(&a2, 1u, (int)&unk_1011B3C0, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_1011B3F4[2 * sub_1003B860(&a2, 1u, (int)&unk_1011B3F0, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_1011B39C[2 * sub_1003B860(&a2, 1u, (int)&unk_1011B398, 8, 5, 5)];
  }
  return result;
}
// 1011B384: using guessed type int dword_1011B384[];
// 1011B39C: using guessed type int dword_1011B39C[];
// 1011B3C4: using guessed type int dword_1011B3C4[];
// 1011B3F4: using guessed type int dword_1011B3F4[];

//----- (10068EF0) --------------------------------------------------------
bool __usercall sub_10068EF0@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_10120B27[44 * a1] - (unsigned __int8)byte_10120B22[44 * a1];
}

//----- (10068F20) --------------------------------------------------------
char __usercall sub_10068F20@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_10068EF0(a1, a4, a5) )
  {
    v6 = a3
       + sub_10068E40(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_10120B22[44 * a1] - (unsigned __int8)byte_10120B27[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy_0(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_10068E40(a1, a4);
    memcpy_0(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (10068FC0) --------------------------------------------------------
char __cdecl sub_10068FC0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_100540B0(a1);
  sub_1006A0C0(v5, (int)&v7, 3684);
  return sub_10068F20(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (10069040) --------------------------------------------------------
char __cdecl sub_10069040(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_100540B0(a1);
  sub_1006A0C0(v5, (int)&v7, 3684);
  return sub_10068F20(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (100690C0) --------------------------------------------------------
char __cdecl sub_100690C0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_100540B0(a1);
  sub_1006A0C0(v5, (int)&v7, 3684);
  return sub_10068F20(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (10069140) --------------------------------------------------------
char __cdecl sub_10069140(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_100540B0(a1);
  sub_1006A0C0(v5, (int)&v7, 3684);
  return sub_10068F20(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (100691C0) --------------------------------------------------------
char __cdecl sub_100691C0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_100364C0("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10069260) --------------------------------------------------------
bool __cdecl sub_10069260(char a1)
{
  char v1; // bl@1
  char v2; // cl@1
  char v4; // [sp+5h] [bp-1Bh]@1
  char v5; // [sp+6h] [bp-1Ah]@1
  char v6; // [sp+7h] [bp-19h]@1
  float v7; // [sp+8h] [bp-18h]@1
  char v8; // [sp+Ch] [bp-14h]@1
  char v9; // [sp+10h] [bp-10h]@1
  char v10; // [sp+14h] [bp-Ch]@1
  char v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ch] [bp-4h]@1

  v4 = sub_10044290(&v8);
  v7 = sub_10044DA0();
  v5 = sub_100442F0((float *)&v9);
  v1 = sub_100443F0(&v10);
  v6 = sub_10043D50(&v11);
  v2 = sub_10044450(&v12);
  if ( !a1 )
    v1 = 1;
  return v4 && 9.8999998e24 != v7 && v5 && v1 && v6 && v2;
}

//----- (10069300) --------------------------------------------------------
char __fastcall sub_10069300(int a1, int a2)
{
  int v2; // edi@1
  void *v3; // ecx@2
  int v4; // eax@2
  int v5; // eax@3
  char result; // al@5
  signed int v7; // esi@6
  void *v8; // ecx@6
  signed int v9; // esi@7
  void *v10; // ecx@7
  int v11; // [sp+4h] [bp-8h]@1
  int v12; // [sp+8h] [bp-4h]@2

  v2 = j_HWM_pvg_hsdb_get_lrus_online(a1, a2);
  if ( sub_1003C270(2, &v11) )
  {
    LOBYTE(v12) = sub_1003C180(2, v11) != 0 ? 2 : 0;
    v4 = (unsigned __int8)sub_10038600(v3);
    if ( (_BYTE)v4 )
    {
      v5 = v4 - 1;
      if ( !v5 )
      {
        v7 = sub_10038310(v12);
        return ((v7 & v2) == 0) | (sub_10044670(v8) == 1);
      }
      if ( v5 != 1 )
        return 0;
    }
    v9 = sub_10038310(1);
    result = ((v9 & v2) == 0) | (sub_10044670(v10) == 2);
  }
  else
  {
    result = 1;
  }
  return result;
}
// 1006BB50: using guessed type int __fastcall j_HWM_pvg_hsdb_get_lrus_online(_DWORD, _DWORD);

//----- (100693B0) --------------------------------------------------------
void __cdecl sub_100693B0(float a1, int a2)
{
  double v2; // st7@1

  v2 = a1;
  if ( a1 < 11000.232 )
    *(float *)a2 = pow(v2 * -0.0065 / 288.1499938964844 + 1.0, 5.255880147586614) * 101325.0;
  else
    *(float *)a2 = exp((v2 - 11000.232421875) * -0.0001576885406393558) * 22631.953125;
}

//----- (10069410) --------------------------------------------------------
void __cdecl sub_10069410(float a1, float a2, int a3)
{
  float v3; // ecx@0
  float v4; // [sp+8h] [bp-4h]@1

  v4 = v3;
  sub_100693B0(a2, (int)&v4);
  *(float *)a3 = sqrt((pow(
                         (pow(a1 * a1 * 0.000001727115545691049 + 1.0, 3.500000238418579) - 1.0) * (101325.0 / v4) + 1.0,
                         0.2857142686843872)
                     - 1.0) * 5.000000476837158);
}

//----- (10069480) --------------------------------------------------------
void __cdecl sub_10069480(float a1, float a2, int a3)
{
  float v3; // ecx@0
  float v4; // [sp+8h] [bp-4h]@1

  v4 = v3;
  sub_100693B0(a2, (int)&v4);
  *(float *)a3 = sqrt((pow(
                         (pow(a1 * a1 * 0.199999988079071 + 1.0, 3.500000238418579) - 1.0) * (v4 / 101325.0) + 1.0,
                         0.2857142686843872)
                     - 1.0) * 579000.0625);
}

//----- (100694F0) --------------------------------------------------------
int __cdecl sub_100694F0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (10069510) --------------------------------------------------------
char __cdecl sub_10069510(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9)
{
  char *v9; // eax@1
  char v10; // cl@2
  __int16 v12; // [sp+0h] [bp-52Ch]@1
  char v13; // [sp+4h] [bp-528h]@1
  char v14; // [sp+5h] [bp-527h]@1
  char v15; // [sp+6h] [bp-526h]@1
  char v16; // [sp+7h] [bp-525h]@1
  char v17; // [sp+8h] [bp-524h]@1
  char v18; // [sp+9h] [bp-523h]@1
  __int16 v19; // [sp+Ah] [bp-522h]@1
  int v20; // [sp+Ch] [bp-520h]@1
  char v21[1300]; // [sp+14h] [bp-518h]@2

  memset(&v12, 0, 0x528u);
  v15 = a4;
  v20 = a6;
  v16 = a3;
  v13 = a1;
  v9 = a9;
  v17 = a5;
  v14 = a2;
  v12 = -32708;
  v18 = a7;
  v19 = a8;
  if ( a9 )
  {
    do
    {
      v10 = *v9;
      v9[v21 - a9] = *v9;
      ++v9;
    }
    while ( v10 );
  }
  return sub_1003EB90((int)&v12);
}
// 10069510: using guessed type char var_518[1300];

//----- (100695E0) --------------------------------------------------------
int __cdecl sub_100695E0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1003B860(&a1, 1u, (int)&unk_10120828, 8, 53, 67);
  if ( v1 == 67 )
    result = 0;
  else
    result = (int)*(&off_1012082C + 2 * v1);
  return result;
}
// 1012082C: using guessed type void *off_1012082C;

//----- (10069620) --------------------------------------------------------
int __cdecl sub_10069620(char a1, char *a2)
{
  int result; // eax@1
  char *v3; // edi@2
  char *v4; // esi@3
  int v5; // edi@3

  result = sub_1003B860(&a1, 1u, (int)&unk_101209D0, 68, 4, 4);
  if ( result < 4 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = (char *)&unk_101209D1 + 68 * result;
      qmemcpy(a2, v4, 0x40u);
      v4 += 64;
      v5 = (int)(v3 + 64);
      *(_WORD *)v5 = *(_WORD *)v4;
      *(_BYTE *)(v5 + 2) = v4[2];
    }
  }
  return result;
}

//----- (10069670) --------------------------------------------------------
int __cdecl sub_10069670(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D5B4: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (10069690) --------------------------------------------------------
int sub_10069690()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D5BA: using guessed type int TSK_pvg_get_id(void);

//----- (100696B0) --------------------------------------------------------
int __cdecl sub_100696B0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D5C0: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (100696E0) --------------------------------------------------------
__int16 __cdecl sub_100696E0(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D5C6: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (10069700) --------------------------------------------------------
int sub_10069700()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D5CC: using guessed type int TSK_pvg_get_timer(void);

//----- (10069720) --------------------------------------------------------
int __cdecl sub_10069720(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D5D2: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10069760) --------------------------------------------------------
int __cdecl sub_10069760(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D5DE: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10069790) --------------------------------------------------------
int __cdecl sub_10069790(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_proc_status(a1);
  SYS_exit_krnl();
  return v1;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D5E4: using guessed type int __cdecl TSK_pvg_proc_status(_DWORD);

//----- (100697B0) --------------------------------------------------------
int __cdecl sub_100697B0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D5EA: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (100697D0) --------------------------------------------------------
int __cdecl sub_100697D0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D5F0: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (10069800) --------------------------------------------------------
int __cdecl sub_10069800(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_send_msg(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D5F6: using guessed type int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10069830) --------------------------------------------------------
int __cdecl sub_10069830(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D5FC: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (10069860) --------------------------------------------------------
int __cdecl sub_10069860(int a1)
{
  SYS_enter_krnl();
  TSK_pvg_set_proc_status(a1);
  return SYS_exit_krnl();
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D602: using guessed type int __cdecl TSK_pvg_set_proc_status(_DWORD);

//----- (10069880) --------------------------------------------------------
int __cdecl sub_10069880(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D608: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (100698A0) --------------------------------------------------------
char __cdecl sub_100698A0(int a1, int a2)
{
  unsigned int v2; // esi@1
  char result; // al@4

  v2 = a2 + sub_10069700();
  if ( sub_10069790(a1) == 5 )
    goto LABEL_4;
  while ( sub_10069700() < v2 )
  {
    sub_10069880(20);
    if ( sub_10069790(a1) == 5 )
      goto LABEL_4;
  }
  if ( sub_10069790(a1) == 5 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    sub_100364C0("..\\lib\\acl\\tsk\\tsk_usr.c", 1769, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10069910) --------------------------------------------------------
int __cdecl sub_10069910(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_10069690();
    sub_10069720((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D60E: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (10069950) --------------------------------------------------------
int __cdecl sub_10069950(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_100697B0(a2);
  return result;
}
// 100995F8: using guessed type void *tsk_app_hdr_ptr;

//----- (10069980) --------------------------------------------------------
int __cdecl sub_10069980(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_100697D0(a1, a2);
  return result;
}
// 100995F8: using guessed type void *tsk_app_hdr_ptr;

//----- (100699A0) --------------------------------------------------------
int __cdecl sub_100699A0(int a1, float a2)
{
  return gdi_pvg_alpha_func(a1, LODWORD(a2));
}
// 1006D614: using guessed type int __cdecl gdi_pvg_alpha_func(_DWORD, _DWORD);

//----- (10069A00) --------------------------------------------------------
int __cdecl sub_10069A00(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_bitblt(&v8, a2, a3, a7, a1, a4, a5, a6);
}
// 1006D632: using guessed type int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10069A80) --------------------------------------------------------
int __cdecl sub_10069A80(float a1, float a2, float a3, float a4)
{
  return gdi_pvg_clear_color(LODWORD(a1), LODWORD(a2), LODWORD(a3), LODWORD(a4));
}
// 1006D64A: using guessed type int __cdecl gdi_pvg_clear_color(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10069AB0) --------------------------------------------------------
int __cdecl sub_10069AB0(float a1, float a2, float a3, float a4)
{
  return gdi_pvg_color4f(LODWORD(a1), LODWORD(a2), LODWORD(a3), LODWORD(a4));
}
// 1006D650: using guessed type int __cdecl gdi_pvg_color4f(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10069AE0) --------------------------------------------------------
int __cdecl sub_10069AE0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-14h]@1

  return gdi_pvg_color_pointer(&v6, a1, a2, a3, a4, a5);
}
// 1006D656: using guessed type int __cdecl gdi_pvg_color_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10069B70) --------------------------------------------------------
int __cdecl sub_10069B70(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_draw_pixels(&v8, a5, a4, a7, a6, a3, a1, a2);
}
// 1006D67A: using guessed type int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10069C10) --------------------------------------------------------
int __cdecl sub_10069C10(float a1, float a2, float a3, float a4, float a5, float a6)
{
  float v7; // [sp+0h] [bp-18h]@1

  return gdi_pvg_frustum(&v7, LODWORD(a4), LODWORD(a6), LODWORD(a1), LODWORD(a5), LODWORD(a2), LODWORD(a3));
}
// 1006D69E: using guessed type int __cdecl gdi_pvg_frustum(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10069C70) --------------------------------------------------------
int sub_10069C70()
{
  gdi_pvg_init();
  return sub_10069FD0();
}
// 1006D6B0: using guessed type int gdi_pvg_init(void);

//----- (10069C80) --------------------------------------------------------
int __cdecl sub_10069C80(float a1)
{
  return gdi_pvg_line_width(LODWORD(a1));
}
// 1006D6B6: using guessed type int __cdecl gdi_pvg_line_width(_DWORD);

//----- (10069CD0) --------------------------------------------------------
int __cdecl sub_10069CD0(float a1, float a2, float a3, float a4, float a5, float a6)
{
  float v7; // [sp+0h] [bp-18h]@1

  return gdi_pvg_ortho(&v7, LODWORD(a4), LODWORD(a6), LODWORD(a1), LODWORD(a5), LODWORD(a2), LODWORD(a3));
}
// 1006D6D4: using guessed type int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10069D50) --------------------------------------------------------
int __cdecl sub_10069D50(float a1, float a2, float a3, float a4)
{
  return gdi_pvg_rotatef(LODWORD(a1), LODWORD(a2), LODWORD(a3), LODWORD(a4));
}
// 1006D6F2: using guessed type int __cdecl gdi_pvg_rotatef(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10069D80) --------------------------------------------------------
int __cdecl sub_10069D80(float a1, float a2, float a3)
{
  return gdi_pvg_scalef(LODWORD(a1), LODWORD(a2), LODWORD(a3));
}
// 1006D6F8: using guessed type int __cdecl gdi_pvg_scalef(_DWORD, _DWORD, _DWORD);

//----- (10069DB0) --------------------------------------------------------
int __cdecl sub_10069DB0(float a1, float a2)
{
  return gdi_pvg_tex_coord2f(LODWORD(a1), LODWORD(a2));
}
// 1006D6FE: using guessed type int __cdecl gdi_pvg_tex_coord2f(_DWORD, _DWORD);

//----- (10069DD0) --------------------------------------------------------
int __cdecl sub_10069DD0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-14h]@1

  return gdi_pvg_tex_coord_pointer(&v6, a1, a2, a3, a4, a5);
}
// 1006D704: using guessed type int __cdecl gdi_pvg_tex_coord_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10069E10) --------------------------------------------------------
int __cdecl sub_10069E10(int a1, int a2, float a3)
{
  return gdi_pvg_tex_envf(a1, a2, LODWORD(a3));
}
// 1006D70A: using guessed type int __cdecl gdi_pvg_tex_envf(_DWORD, _DWORD, _DWORD);

//----- (10069E30) --------------------------------------------------------
int __cdecl sub_10069E30(int a1, char a2, char a3, int a4, int a5, int a6, char a7, int a8, int a9, int a10)
{
  char v11; // [sp+0h] [bp-20h]@1
  char v12; // [sp+1h] [bp-1Fh]@1
  char v13; // [sp+2h] [bp-1Eh]@1

  v12 = a2;
  v13 = a3;
  v11 = a7;
  return gdi_pvg_tex_image_2d(&v11, *(_DWORD *)&v11, a8, a4, a10, a1, a9, a6, a5);
}
// 1006D710: using guessed type int __cdecl gdi_pvg_tex_image_2d(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10069EB0) --------------------------------------------------------
int __cdecl sub_10069EB0(float a1, float a2, float a3)
{
  return gdi_pvg_translatef(LODWORD(a1), LODWORD(a2), LODWORD(a3));
}
// 1006D722: using guessed type int __cdecl gdi_pvg_translatef(_DWORD, _DWORD, _DWORD);

//----- (10069EF0) --------------------------------------------------------
int __cdecl sub_10069EF0(float a1, float a2)
{
  return gdi_pvg_vertex2f(LODWORD(a1), LODWORD(a2));
}
// 1006D72E: using guessed type int __cdecl gdi_pvg_vertex2f(_DWORD, _DWORD);

//----- (10069F10) --------------------------------------------------------
int __cdecl sub_10069F10(float a1, float a2, float a3)
{
  return gdi_pvg_vertex3f(LODWORD(a1), LODWORD(a2), LODWORD(a3));
}
// 1006D734: using guessed type int __cdecl gdi_pvg_vertex3f(_DWORD, _DWORD, _DWORD);

//----- (10069F40) --------------------------------------------------------
int __cdecl sub_10069F40(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-14h]@1

  return gdi_pvg_vertex_pointer(&v6, a1, a2, a3, a4, a5);
}
// 1006D73A: using guessed type int __cdecl gdi_pvg_vertex_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10069F90) --------------------------------------------------------
int __cdecl sub_10069F90(int a1, int a2, int a3)
{
  dword_10737640 = a1;
  dword_10737634 = a2;
  dword_10737638 = a3;
  return gdi_pvg_create_window(&dword_1073762C);
}
// 1006D746: using guessed type int __cdecl gdi_pvg_create_window(_DWORD);
// 1073762C: using guessed type int dword_1073762C;
// 10737634: using guessed type int dword_10737634;
// 10737638: using guessed type int dword_10737638;
// 10737640: using guessed type int dword_10737640;

//----- (10069FD0) --------------------------------------------------------
int sub_10069FD0()
{
  int result; // eax@1

  result = 0;
  dword_10737640 = 0;
  dword_10737634 = 0;
  dword_10737638 = 59;
  dword_1073762C = 1;
  dword_10737630 = 0;
  dword_1073763C = 0;
  return result;
}
// 1073762C: using guessed type int dword_1073762C;
// 10737630: using guessed type int dword_10737630;
// 10737634: using guessed type int dword_10737634;
// 10737638: using guessed type int dword_10737638;
// 1073763C: using guessed type int dword_1073763C;
// 10737640: using guessed type int dword_10737640;

//----- (1006A020) --------------------------------------------------------
int __cdecl sub_1006A020(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1073762C = a1;
  return result;
}
// 1073762C: using guessed type int dword_1073762C;

//----- (1006A030) --------------------------------------------------------
int __cdecl sub_1006A030(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10737630 = a1;
  return result;
}
// 10737630: using guessed type int dword_10737630;

//----- (1006A040) --------------------------------------------------------
int __cdecl sub_1006A040(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1073763C = a1;
  return result;
}
// 1073763C: using guessed type int dword_1073763C;

//----- (1006A050) --------------------------------------------------------
int __cdecl sub_1006A050(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = 0;
  result = 42066;
  while ( dword_101258E8[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xA5 )
      return result;
  }
  return dword_101258EC[2 * v1];
}
// 101258E8: using guessed type int dword_101258E8[];
// 101258EC: using guessed type int dword_101258EC[];

//----- (1006A0A0) --------------------------------------------------------
int __cdecl sub_1006A0A0(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 1006D758: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1006A0C0) --------------------------------------------------------
char __cdecl sub_1006A0C0(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_1006A0A0(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_100364C0("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (1006A100) --------------------------------------------------------
int __cdecl sub_1006A100(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_1006A0A0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy_0(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (1006A140) --------------------------------------------------------
int __cdecl sub_1006A140(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_1006A0A0(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (1006A170) --------------------------------------------------------
int __cdecl sub_1006A170(int a1, int a2, int a3)
{
  return sub_1006A140(a1 | 0x40000, a2, a3);
}

//----- (1006A190) --------------------------------------------------------
int __cdecl sub_1006A190(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 1006D75E: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1006A1B0) --------------------------------------------------------
int __cdecl sub_1006A1B0(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@2
  int result; // eax@4
  int v6; // [sp+10h] [bp-4h]@1

  v6 = sub_1006A190(a1, a2, a3);
  v3 = 0;
  if ( (unsigned __int8)sub_1006CAA0() )
  {
    v4 = sub_1006A050(a1);
    if ( v4 != 42066 )
      v3 = sub_1006A190(v4, a2, a3);
  }
  result = v6;
  if ( !v6 )
    result = v3;
  return result;
}
// 1006CAA0: using guessed type int sub_1006CAA0(void);

//----- (1006A210) --------------------------------------------------------
int __cdecl sub_1006A210(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_1006A1B0(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    sub_100364C0("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1742, 1, 0);
    result = v4;
  }
  return result;
}

//----- (1006A250) --------------------------------------------------------
char __cdecl sub_1006A250(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_1006A190(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_100364C0("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1826, 1, 0);
  return v3;
}

//----- (1006A290) --------------------------------------------------------
char __cdecl sub_1006A290(int a1, _DWORD *a2, int a3, int a4, int a5, unsigned int a6)
{
  char v6; // dl@1
  int v7; // ecx@2
  unsigned int v8; // ebp@4
  unsigned int v9; // esi@5
  char v10; // dl@5
  unsigned int v11; // eax@5
  int v12; // eax@13
  bool v13; // zf@18
  int v15; // [sp+0h] [bp-20h]@1
  int v16; // [sp+4h] [bp-1Ch]@2
  int v17; // [sp+8h] [bp-18h]@13
  int v18; // [sp+Ch] [bp-14h]@2
  unsigned int v19; // [sp+10h] [bp-10h]@4
  char v20; // [sp+14h] [bp-Ch]@13
  int v21; // [sp+18h] [bp-8h]@14
  char v22; // [sp+30h] [bp+10h]@4
  char v23; // [sp+30h] [bp+10h]@13

  v6 = 0;
  v15 = 0;
  if ( a4 )
  {
    v7 = a3 + 4;
    v16 = a3 + 4;
    v18 = a4;
    do
    {
      if ( *(_DWORD *)(v7 - 4) == a1 )
      {
        v22 = 1;
        v19 = *(_DWORD *)(v7 + 4) - *(_DWORD *)v7;
        v8 = 0;
        do
        {
          v9 = v8 + *(_DWORD *)v7;
          v10 = 0;
          v11 = 0;
          if ( a6 )
          {
            v7 = a5;
            while ( !v10 )
            {
              if ( *(_DWORD *)v7 == a1 && *(_DWORD *)(v7 + 4) == v9 )
                v10 = 1;
              ++v11;
              v7 += 10;
              if ( v11 >= a6 )
              {
                if ( v10 )
                  break;
                goto LABEL_13;
              }
            }
          }
          else
          {
LABEL_13:
            v12 = j_reg_get_tag_hdr(v7, v10);
            v23 = v20 & (v12 == 1) & v22;
            v17 = 0;
            if ( !sub_1006CAB0(v9, (unsigned int *)&v15, &v17) )
              v15 = v21;
            v22 = (v17 == 0) & v23;
            *a2 += v15;
          }
          v7 = v16;
          ++v8;
        }
        while ( v8 <= v19 );
        v6 = v22;
      }
      v7 += 12;
      v13 = v18-- == 1;
      v16 = v7;
    }
    while ( !v13 );
  }
  return v6;
}
// 1006A090: using guessed type int __fastcall j_reg_get_tag_hdr(_DWORD, _DWORD);

//----- (1006A3A0) --------------------------------------------------------
int __cdecl sub_1006A3A0(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_1006A0A0(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy_0(a2, a4, (unsigned __int16)a3);
    sub_1006A190(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (1006A3F0) --------------------------------------------------------
char __cdecl sub_1006A3F0(_DWORD *a1)
{
  int v1; // eax@1
  unsigned int v2; // esi@1
  char v3; // bl@1
  int *v4; // edi@1

  *a1 = 0;
  v1 = 10;
  v2 = 0;
  v3 = 1;
  v4 = (int *)&unk_10125E10;
  do
  {
    v3 &= sub_1006A290(*v4, a1, (int)&unk_10125E10, v1, (int)&unk_10124DA0, 0x120u);
    v1 = 10;
    ++v2;
    v4 += 3;
  }
  while ( v2 < 0xA );
  return v3;
}

//----- (1006A450) --------------------------------------------------------
int __cdecl sub_1006A450(unsigned int a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 0x8A )
  {
    if ( a1 < 0x8A && (unsigned __int8)sub_1006CD80() )
      result = dword_10755CDC + 24 * a1;
    else
      result = 0;
  }
  return result;
}
// 10755CDC: using guessed type int dword_10755CDC;

//----- (1006A470) --------------------------------------------------------
void __cdecl sub_1006A470(float a1, float a2, float a3, float a4, float a5, float a6, float a7)
{
  float v7; // ST18_4@1
  double v8; // st7@1
  float v9; // ST0C_4@2
  float v10; // ST08_4@2
  float v11; // ST04_4@2
  float v12; // ST00_4@2
  float v13; // [sp+1Ch] [bp-8h]@1
  float v14; // [sp+2Ch] [bp+8h]@2
  float v15; // [sp+2Ch] [bp+8h]@2
  float v16; // [sp+2Ch] [bp+8h]@2
  float v17; // [sp+34h] [bp+10h]@1
  float v18; // [sp+34h] [bp+10h]@1
  float v19; // [sp+34h] [bp+10h]@1
  float v20; // [sp+38h] [bp+14h]@1
  float v21; // [sp+38h] [bp+14h]@1
  float v22; // [sp+38h] [bp+14h]@1
  float v23; // [sp+38h] [bp+14h]@1
  float v24; // [sp+38h] [bp+14h]@2

  v20 = a5 * 0.01745329238474369;
  v13 = a4 - a2;
  v17 = sin(v20);
  v7 = v17;
  v21 = cos(v20);
  v22 = (v13 + a2) * -v21;
  v18 = v13 * (a2 * -v17);
  v19 = sqrt(v22 * v22 - v18 * (v7 * 4.0));
  v23 = (v19 - v22) / (v7 + v7);
  v8 = v23;
  if ( v23 >= 0.001 )
  {
    v24 = v13 * a6 / v8;
    v9 = -v24;
    v14 = a2 * a6 / v8;
    v10 = v14;
    v15 = (a3 - a1) * a6 / v8;
    v11 = v15;
    v16 = a6 * a1 / v8;
    v12 = -v16;
    sub_10069C10(v12, v11, v10, v9, a6, a7);
  }
}

//----- (1006A5B0) --------------------------------------------------------
void sub_1006A5B0()
{
  dword_1073CEC8 = 0;
  dword_10755CDC = -15;
}
// 10755CDC: using guessed type int dword_10755CDC;

//----- (1006A5C0) --------------------------------------------------------
int __cdecl sub_1006A5C0(int a1)
{
  j_gdi_pvg_bind_buffer(53, *(_DWORD *)a1);
  j_gdi_pvg_enable_client_state(11);
  j_gdi_pvg_enable_client_state(12);
  j_gdi_pvg_enable_client_state(13);
  sub_10069F40(3, 18, 24, *(_DWORD *)(a1 + 8), 0);
  sub_10069AE0(4, 15, 24, *(_DWORD *)(a1 + 8), 12);
  return sub_10069DD0(2, 18, 24, *(_DWORD *)(a1 + 8), 16);
}
// 100699D0: using guessed type int __cdecl j_gdi_pvg_bind_buffer(_DWORD, _DWORD);
// 10069BD0: using guessed type int __cdecl j_gdi_pvg_enable_client_state(_DWORD);

//----- (1006A620) --------------------------------------------------------
char __cdecl sub_1006A620(_DWORD *a1, int a2, int a3, _DWORD *a4, unsigned int a5)
{
  _DWORD *v5; // esi@1
  char v6; // bl@2
  int v7; // ebp@4
  bool v8; // zf@4
  unsigned int v9; // ebx@4
  _DWORD *v10; // edi@6

  v5 = a1;
  if ( *a1 )
  {
    v6 = 0;
  }
  else
  {
    j_gdi_pvg_gen_buffers(1, a1);
    v6 = 1;
  }
  j_gdi_pvg_bind_buffer(53, *v5);
  v7 = a2;
  v8 = v6 == 0;
  v9 = a5;
  if ( v8 )
  {
    if ( a2 == v5[1] )
      goto LABEL_11;
    v10 = a4;
  }
  else
  {
    v10 = (_DWORD *)a5;
  }
  a1 = v10;
  j_gdi_pvg_buffer_data(53, &a1, a3, 56);
  if ( a1 != v10 )
    return 0;
  v5[1] = v7;
LABEL_11:
  v5[2] = v9 / 0x18;
  j_gdi_pvg_bind_buffer(53, 0);
  return 1;
}
// 100699D0: using guessed type int __cdecl j_gdi_pvg_bind_buffer(_DWORD, _DWORD);
// 10069A60: using guessed type int __cdecl j_gdi_pvg_buffer_data(_DWORD, _DWORD, _DWORD, _DWORD);
// 10069C50: using guessed type int __cdecl j_gdi_pvg_gen_buffers(_DWORD, _DWORD);

//----- (1006A6B0) --------------------------------------------------------
int sub_1006A6B0()
{
  j_gdi_pvg_bind_buffer(53, 0);
  j_gdi_pvg_disable_client_state(11);
  j_gdi_pvg_disable_client_state(12);
  return j_gdi_pvg_disable_client_state(13);
}
// 100699D0: using guessed type int __cdecl j_gdi_pvg_bind_buffer(_DWORD, _DWORD);
// 10069B50: using guessed type int __cdecl j_gdi_pvg_disable_client_state(_DWORD);

//----- (1006A6E0) --------------------------------------------------------
signed int __fastcall sub_1006A6E0(char *a1)
{
  unsigned __int8 v1; // al@1
  char v2; // dl@1
  char v3; // bl@1
  signed int result; // eax@13

  v1 = *a1;
  v2 = 0;
  v3 = 0;
  if ( !*a1 )
    goto LABEL_17;
  do
  {
    if ( v1 < 0x30u || v1 > 0x39u )
    {
      if ( v1 >= 0x61u && v1 <= 0x7Au || v1 >= 0x41u && v1 <= 0x5Au )
        v2 = 1;
    }
    else
    {
      v3 = 1;
    }
    v1 = (a1++)[1];
  }
  while ( v1 );
  if ( v2 && v3 )
    result = 1;
  else
LABEL_17:
    result = 0;
  return result;
}

//----- (1006A730) --------------------------------------------------------
char __usercall sub_1006A730@<al>(int a1@<eax>, char *a2@<ecx>, unsigned int a3)
{
  unsigned int v3; // ebx@1
  unsigned int v4; // edi@1
  char *v5; // esi@1
  unsigned __int8 v6; // al@3
  bool v7; // zf@3
  unsigned int v8; // eax@5
  signed int v9; // eax@8
  int v10; // edx@8
  char result; // al@11
  unsigned __int8 v12; // [sp+13h] [bp-5h]@2
  int v13; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(a1 + 12) * *(_WORD *)(a1 + 14);
  v4 = 0;
  v5 = a2;
  if ( v3 )
  {
    while ( sub_1006B2F0(a3, &v12, 1) == 1 )
    {
      v6 = (v12 & 0x7F) + 1;
      v7 = v12 >> 7 == 1;
      v12 = (v12 & 0x7F) + 1;
      if ( v7 )
      {
        if ( sub_1006B2F0(a3, &v13, 4) != 4 )
          break;
        v8 = 0;
        if ( v12 )
        {
          do
          {
            *(_DWORD *)v5 = v13;
            ++v8;
            v5 += 4;
            ++v4;
          }
          while ( v8 < v12 );
        }
      }
      else
      {
        v9 = sub_1006B2F0(a3, v5, 4 * v6);
        v10 = 4 * v12;
        if ( v9 != v10 )
          break;
        v5 += v10;
        v4 += v12;
      }
      if ( v4 >= v3 )
        goto LABEL_11;
    }
    result = 0;
  }
  else
  {
LABEL_11:
    result = 1;
  }
  return result;
}

//----- (1006A800) --------------------------------------------------------
int __usercall sub_1006A800@<eax>(unsigned int a1@<eax>)
{
  return sub_1006CD90(a1);
}

//----- (1006A810) --------------------------------------------------------
int __cdecl sub_1006A810(int a1, int a2, char *a3)
{
  int result; // eax@4
  int v4; // [sp+4h] [bp-34h]@5
  int v5; // [sp+8h] [bp-30h]@5
  __int16 v6; // [sp+Ch] [bp-2Ch]@5
  int v7; // [sp+14h] [bp-24h]@5
  __int16 v8; // [sp+18h] [bp-20h]@5
  void *v9; // [sp+1Ch] [bp-1Ch]@5
  int v10; // [sp+20h] [bp-18h]@5
  void *v11; // [sp+24h] [bp-14h]@5
  int v12; // [sp+28h] [bp-10h]@5
  int v13; // [sp+2Ch] [bp-Ch]@5
  char v14; // [sp+30h] [bp-8h]@5
  int v15; // [sp+34h] [bp-4h]@5

  if ( dword_1073CEC8 )
    sub_10045FA0(dword_1073CEC8);
  dword_1073CEC8 = &unk_1073CE48;
  memset(&unk_1073CE48, 0, 0x80u);
  memset(&unk_1073CED0, 0, 0x2E0u);
  if ( sub_10046000(a1, 4, &unk_1073CE48, a2) )
  {
    dword_1073CEC8 = 0;
    result = 0;
  }
  else
  {
    memset(&v4, 0, 0x34u);
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = &unk_107488F8;
    v10 = 1024;
    v11 = &unk_1073D1B0;
    v12 = 46920;
    v13 = 15;
    v14 = -2;
    v15 = 0xFFFF;
    result = sub_10046FA0((int)dword_1073CEC8, a3, 4, &unk_1073CED0, (int)&v4);
  }
  return result;
}

//----- (1006A900) --------------------------------------------------------
int __usercall sub_1006A900@<eax>(_BYTE *a1@<eax>, signed int a2@<ecx>, signed int a3, int a4, int a5, _BYTE *a6)
{
  int v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edx@1
  int result; // eax@1
  _BYTE *v10; // ecx@1
  _BYTE *v11; // edi@1
  _BYTE *v12; // ebx@1
  __int64 v13; // rax@7
  bool v14; // zf@7
  int v15; // [sp+10h] [bp-Ch]@2
  int v16; // [sp+14h] [bp-8h]@1
  int v17; // [sp+18h] [bp-4h]@1
  int v18; // [sp+20h] [bp+4h]@1
  int v19; // [sp+20h] [bp+4h]@6
  _BYTE *v20; // [sp+24h] [bp+8h]@1
  int v21; // [sp+2Ch] [bp+10h]@4

  v6 = a5 * a4;
  v7 = a1;
  v16 = a2 / 2;
  v8 = a2 * a5 * a4;
  v18 = a3 / 2;
  v20 = a6;
  result = v18;
  v10 = &v7[v8];
  v17 = v8;
  v11 = &v7[v6];
  v12 = &v7[v8] + v6;
  if ( v18 > 0 )
  {
    v15 = v18;
    do
    {
      result = v16;
      if ( v16 > 0 )
      {
        v21 = v16;
        do
        {
          result = a5;
          if ( a5 > 0 )
          {
            v19 = a5;
            do
            {
              v13 = *v7 + *v11 + *v10 + *v12;
              *v20 = (signed int)(v13 + (BYTE4(v13) & 3)) >> 2;
              result = (int)(v20 + 1);
              ++v7;
              ++v11;
              ++v10;
              ++v12;
              v14 = v19-- == 1;
              ++v20;
            }
            while ( !v14 );
            v8 = v17;
          }
          v7 += v6;
          v11 += v6;
          v10 += v6;
          v12 += v6;
          --v21;
        }
        while ( v21 );
      }
      v7 += v8;
      v11 += v8;
      v10 += v8;
      v12 += v8;
      --v15;
    }
    while ( v15 );
  }
  return result;
}

//----- (1006A9E0) --------------------------------------------------------
_BYTE *__cdecl sub_1006A9E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  _BYTE *result; // eax@1
  signed int v8; // esi@5
  signed int v9; // edi@6
  int v10; // ebp@8
  int v11; // [sp+0h] [bp-4h]@3

  result = (_BYTE *)(a5 - 58);
  if ( a5 == 58 )
  {
    v11 = 1;
  }
  else
  {
    result = (_BYTE *)(a5 - 59);
    if ( a5 != 59 )
      return result;
    v11 = 4;
  }
  v8 = a3;
  if ( a3 <= 2048 )
  {
    v9 = a4;
    if ( a4 <= 2048 )
    {
      result = (_BYTE *)(a4 / 2);
      if ( (unsigned int)(v11 * a4 / 2 * (a3 / 2)) <= 0x100000 )
      {
        v10 = 0;
        sub_10069E30(a1, 0, 0, a2, a3, a4, 0, a5, a6, a7);
        result = (_BYTE *)a7;
        while ( v8 > 1 || v9 > 1 )
        {
          sub_1006A900(result, v8, v9, 1, v11, &unk_103D96C8);
          v8 /= 2;
          v9 /= 2;
          if ( v8 < 1 )
            v8 = 1;
          if ( v9 < 1 )
            v9 = 1;
          sub_10069E30(a1, ++v10, 0, a2, v8, v9, 0, a5, a6, (int)&unk_103D96C8);
          result = &unk_103D96C8;
        }
      }
    }
  }
  return result;
}

//----- (1006AAF0) --------------------------------------------------------
double __cdecl sub_1006AAF0(int a1, int a2, float a3, float a4, float a5)
{
  char *v5; // ebp@1
  int v6; // edi@1
  void *v7; // esi@1
  bool v8; // bl@3
  int v9; // eax@6
  int v10; // edi@6
  double v11; // st7@7
  char v12; // al@7
  double v13; // st7@8
  double v14; // st5@8
  int v15; // eax@13
  double v16; // st4@13
  double v17; // st3@13
  double v18; // rt2@13
  double v19; // st3@13
  bool v20; // zf@13
  float v22; // [sp+0h] [bp-8h]@7
  unsigned int v23; // [sp+4h] [bp-4h]@1

  v5 = (char *)a2;
  a4 = a4 + a5;
  v23 = strlen((const char *)a2);
  v6 = a1;
  v7 = &unk_103D96C8;
  if ( a1 & 0xC0000000 )
  {
    if ( (a1 & 0xC0000000) == 0x80000000 )
      v8 = (unsigned __int8)sub_1006A6E0((char *)a2) == 0;
    else
      v8 = 0;
  }
  else
  {
    v8 = 1;
  }
  v9 = sub_1006A800(v6 & 0x3FFFFFFF);
  v10 = v9;
  if ( v9 )
  {
    v11 = a4;
    a4 = a4 - *(float *)(v9 + 8200) * a5;
    v22 = v11 + a5 * *(float *)(v9 + 8204);
    sub_1006A0A0(6610, (int)&a1, 1);
    v12 = *v5;
    if ( *v5 )
    {
      v13 = a4;
      v14 = a5;
      do
      {
        if ( (_BYTE)a1 && v8 && v12 == 48 )
          v12 = -122;
        v15 = v10 + 32 * (unsigned __int8)v12;
        ++v5;
        v7 = (char *)v7 + 64;
        a4 = *(float *)(v15 + 16) * v14;
        a3 = *(float *)(v15 + 24) + a3;
        *((float *)v7 - 14) = *(float *)v15;
        *((float *)v7 - 13) = *(float *)(v15 + 8);
        v16 = a3;
        *((float *)v7 - 16) = a3;
        *((float *)v7 - 15) = v13;
        *((float *)v7 - 10) = *(float *)(v15 + 4);
        *((float *)v7 - 9) = *(float *)(v15 + 8);
        a4 = a4 + v16;
        v17 = a4;
        *((float *)v7 - 12) = a4;
        v18 = v17;
        *((float *)v7 - 11) = v13;
        *((float *)v7 - 6) = *(float *)(v15 + 4);
        *((float *)v7 - 5) = *(float *)(v15 + 12);
        *((float *)v7 - 8) = v17;
        *((float *)v7 - 7) = v22;
        *((float *)v7 - 2) = *(float *)v15;
        *((float *)v7 - 1) = *(float *)(v15 + 12);
        *((float *)v7 - 4) = v16;
        *((float *)v7 - 3) = v22;
        v19 = *(float *)(v15 + 28);
        v12 = *v5;
        v20 = *v5 == 0;
        a3 = v18 + v19;
      }
      while ( !v20 );
    }
    j_gdi_pvg_text_out_verts(&unk_103D96C8, v23, *(_DWORD *)(v10 + 8212));
  }
  return a3;
}
// 10069EA0: using guessed type int __cdecl j_gdi_pvg_text_out_verts(_DWORD, _DWORD, _DWORD);

//----- (1006AC90) --------------------------------------------------------
double __cdecl sub_1006AC90(int a1, int a2, float a3)
{
  int v3; // eax@1
  double result; // st7@1
  char *v5; // edx@2
  unsigned __int8 i; // cl@2
  int v7; // ecx@3
  float v8; // ST00_4@3
  float v9; // ST00_4@3
  double v10; // st6@3
  float v11; // [sp+0h] [bp-4h]@2

  v3 = sub_1006A800(a1);
  result = 0.0;
  if ( v3 )
  {
    v5 = (char *)a2;
    v11 = 0.0;
    for ( i = *(_BYTE *)a2; *v5; v11 = v10 )
    {
      v7 = v3 + 32 * i;
      ++v5;
      v8 = *(float *)(v7 + 16) * a3 + v11;
      v9 = v8 + *(float *)(v7 + 24);
      v10 = v9 + *(float *)(v7 + 28);
      i = *v5;
    }
    result = v11;
  }
  return result;
}

//----- (1006ACF0) --------------------------------------------------------
unsigned int __cdecl sub_1006ACF0(char *a1)
{
  int v1; // ebx@1
  int v2; // edi@2
  int v3; // esi@2
  unsigned int result; // eax@3
  int v5; // [sp+10h] [bp-10h]@1
  const char *v6; // [sp+14h] [bp-Ch]@1
  int v7; // [sp+18h] [bp-8h]@1
  const char *v8; // [sp+1Ch] [bp-4h]@1

  v5 = (int)"/mnt/sys_nand0/sys_files.gca";
  v6 = "/mnt/sys_nand0/arfrm_imgs.zip";
  v7 = (int)"GarminSplashDontGiveOut*$&)aslkd932(lkasdf93023";
  v8 = "gARMIN system DONT give out PWD *&(AS;L238%))+,.023";
  v1 = 0;
LABEL_2:
  v2 = *(&v5 + v1);
  v3 = 0;
  while ( 1 )
  {
    result = sub_1006A810(v2, *(&v7 + v3), a1);
    if ( result < 0xFFFFFFC2 )
    {
      if ( result )
        return result;
    }
    if ( (unsigned int)++v3 >= 2 )
    {
      if ( (unsigned int)++v1 < 2 )
        goto LABEL_2;
      return 0;
    }
  }
}

//----- (1006AD60) --------------------------------------------------------
char __cdecl sub_1006AD60(char *a1)
{
  unsigned int v1; // eax@1
  unsigned int v2; // esi@1
  char result; // al@3
  int v4; // esi@16
  char v5; // al@16
  int v6; // edi@16
  unsigned int v7; // ebp@18
  unsigned int v8; // eax@19
  int *v9; // [sp+4h] [bp-90h]@9
  unsigned int v10; // [sp+8h] [bp-8Ch]@1
  char v11; // [sp+Ch] [bp-88h]@18
  unsigned int v12; // [sp+10h] [bp-84h]@18
  int v13; // [sp+14h] [bp-80h]@4
  int v14; // [sp+18h] [bp-7Ch]@5
  int v15; // [sp+1Ch] [bp-78h]@6
  int v16; // [sp+20h] [bp-74h]@16
  int v17; // [sp+24h] [bp-70h]@16
  char v18; // [sp+30h] [bp-64h]@16
  int v19; // [sp+64h] [bp-30h]@7
  int v20; // [sp+68h] [bp-2Ch]@8

  v1 = sub_1006ACF0(a1);
  v2 = v1;
  v10 = v1;
  if ( v1 >= 0xFFFFFFC2 || !v1 )
  {
    sub_100364C0("..\\lib\\adl\\gdi_usr_util.c", 713, 0, 0);
    return 0;
  }
  sub_1006B2F0(v1, &v13, 128);
  if ( v13 != 542327876 || v14 != 124 || (v15 & 0x1001) != 4097 )
    goto LABEL_26;
  if ( v19 & 4 && v20 == 827611204 )
  {
    v9 = (int *)&unk_10121DF0;
    goto LABEL_16;
  }
  if ( !(v19 & 4) )
    goto LABEL_26;
  if ( v20 == 861165636 )
  {
    v9 = (int *)&unk_10121DF4;
    goto LABEL_16;
  }
  if ( !(v19 & 4) || v20 != 894720068 )
  {
LABEL_26:
    sub_1006B1D0(v2);
    return 0;
  }
  v9 = (int *)&unk_10121DF8;
LABEL_16:
  v4 = v17;
  v5 = v18;
  v6 = v16;
  if ( !(v15 & 0x20000) )
    v5 = 1;
  v11 = v5;
  v7 = 0;
  v12 = (unsigned __int8)v5;
  if ( v5 )
  {
    while ( 1 )
    {
      v8 = 8 * (v4 + 3) / 4 * (v6 + 3) / 4 * ((*v9 != 60) + 1);
      if ( v8 > 0x100000 )
        break;
      sub_1006B2F0(v10, &unk_103D96C8, v8);
      sub_10069E30(34, v7++, v11, *v9, v4, v6, 0, *v9, 15, (int)&unk_103D96C8);
      v4 = (unsigned int)(v4 + 1) >> 1;
      v6 = (unsigned int)(v6 + 1) >> 1;
      if ( v7 >= v12 )
        goto LABEL_21;
    }
    sub_1006B1D0(v10);
    result = 0;
  }
  else
  {
LABEL_21:
    sub_1006B1D0(v10);
    result = 1;
  }
  return result;
}

//----- (1006AF40) --------------------------------------------------------
bool __cdecl sub_1006AF40(char *a1, int a2, int a3, int a4, int a5)
{
  unsigned int v5; // eax@1
  bool result; // al@3
  int v7; // ecx@14
  int v8; // ebx@16
  unsigned int v9; // esi@29
  int v10; // edi@29
  char *v11; // ebp@32
  char v12; // [sp+2h] [bp-1Eh]@4
  char v13; // [sp+3h] [bp-1Dh]@4
  unsigned int v14; // [sp+4h] [bp-1Ch]@1
  char v15; // [sp+8h] [bp-18h]@4
  char v16; // [sp+9h] [bp-17h]@5
  char v17; // [sp+Ah] [bp-16h]@7
  unsigned __int16 v18; // [sp+14h] [bp-Ch]@15
  unsigned __int16 v19; // [sp+16h] [bp-Ah]@17
  unsigned __int8 v20; // [sp+18h] [bp-8h]@12

  v5 = sub_1006ACF0(a1);
  v14 = v5;
  if ( v5 >= 0xFFFFFFC2 || !v5 )
    return 0;
  sub_1006B2F0(v5, &v15, 18);
  v12 = 0;
  v13 = 0;
  if ( v15 || v16 )
    v12 = 1;
  if ( v17 == 2 )
  {
    v13 = 0;
  }
  else if ( v17 == 10 )
  {
    v13 = 1;
  }
  else
  {
    v12 = 1;
  }
  if ( v20 != 32 )
    v12 = 1;
  v7 = a4;
  if ( !a4 )
  {
    a4 = v18;
    v7 = v18;
  }
  v8 = a5;
  if ( !a5 )
  {
    a5 = v19;
    v8 = v19;
  }
  if ( a2 < 0 || a3 < 0 || a2 + v7 > v18 || v8 + a3 > v19 )
    v12 = 1;
  if ( v13 && (a2 || a3 || v7 != v18 || v8 != v19) )
    v12 = 1;
  v9 = (unsigned int)v20 >> 3;
  v10 = v7 * v9;
  if ( (signed int)(v8 * v7 * v9) > 0x100000 )
    goto LABEL_41;
  if ( !v12 )
  {
    if ( !v13 )
    {
      sub_1006B760(v14, v9 * (a2 + a3 * v18), 1);
      v11 = (char *)&unk_103D96C8;
      if ( v8 > 0 )
      {
        do
        {
          if ( sub_1006B2F0(v14, v11, v10) != v10 )
            v12 = 1;
          sub_1006B760(v14, v9 * (v18 - a4), 1);
          v11 += v10;
          --v8;
        }
        while ( v8 );
        if ( v12 )
          goto LABEL_39;
        v8 = a5;
      }
      goto LABEL_38;
    }
    if ( sub_1006A730((int)&v15, (char *)&unk_103D96C8, v14) )
    {
LABEL_38:
      sub_1006A9E0(34, 59, a4, v8, 59, 15, (int)&unk_103D96C8);
      goto LABEL_39;
    }
LABEL_41:
    v12 = 1;
  }
LABEL_39:
  sub_1006B1D0(v14);
  sub_10045FA0(dword_1073CEC8);
  result = v12 == 0;
  dword_1073CEC8 = 0;
  return result;
}

//----- (1006B180) --------------------------------------------------------
char __cdecl sub_1006B180(char *a1)
{
  char result; // al@2

  if ( strstr(a1, ".dds") )
    result = sub_1006AD60(a1);
  else
    result = sub_1006AF40(a1, 0, 0, 0, 0);
  return result;
}

//----- (1006B1D0) --------------------------------------------------------
signed int __cdecl sub_1006B1D0(unsigned int a1)
{
  signed int result; // eax@4
  int v2; // eax@8
  int v3; // edx@9

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_16;
  if ( (a1 & 3) == 1 )
    return sub_100452E0(a1);
  if ( a1 && (a1 & 3) == 2 )
  {
    v2 = 0;
    if ( !dword_10755D60 )
      goto LABEL_11;
    while ( 1 )
    {
      v3 = dword_10755D68[v2];
      if ( *(_DWORD *)v3 == a1 )
        break;
      if ( ++v2 >= (unsigned int)dword_10755D60 )
        goto LABEL_11;
    }
    if ( v2 != -1 )
    {
      sub_1006CDF0(
        v2,
        *(_DWORD *)(dword_10755D68[v2] + 12),
        *(_DWORD *)(v3 + 16),
        *(_BYTE *)(v3 + 32),
        *(_WORD *)(v3 + 20),
        *(_DWORD *)(v3 + 4));
      result = sub_1006B1D0(a1 & 0xFFFFFFFC);
    }
    else
    {
LABEL_11:
      result = -6;
    }
  }
  else
  {
LABEL_16:
    result = FIL_vfs_close();
  }
  return result;
}
// 1006D76A: using guessed type int FIL_vfs_close(void);
// 10755D60: using guessed type int dword_10755D60;
// 10755D68: using guessed type int dword_10755D68[];

//----- (1006B210) --------------------------------------------------------
signed int __cdecl sub_1006B210(unsigned int a1)
{
  signed int result; // eax@3

  if ( a1 < 0xFFFFFFC2 && a1 )
    result = sub_1006B1D0(a1);
  else
    result = -6;
  return result;
}

//----- (1006B280) --------------------------------------------------------
int __cdecl sub_1006B280(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 1006D78E: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1006B2F0) --------------------------------------------------------
signed int __cdecl sub_1006B2F0(unsigned int a1, void *a2, int a3)
{
  unsigned int v3; // eax@4
  signed int result; // eax@4
  int v5; // eax@7

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v3 = sub_100453A0(a1);
    return sub_10046DB0(v3, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v5 = sub_1006B760(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_1006D190(a1, a2, a3, v5, (unsigned __int64)v5 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 1006D7A0: using guessed type int FIL_vfs_read(void);

//----- (1006B340) --------------------------------------------------------
signed int __cdecl sub_1006B340(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_10045320(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_1006D190(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 1006D7AC: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1006B3E0) --------------------------------------------------------
signed int __cdecl sub_1006B3E0(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_10045380(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 1006D7BE: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1006B430) --------------------------------------------------------
__int64 __cdecl sub_1006B430(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 1006D7C4: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (1006B460) --------------------------------------------------------
int __cdecl sub_1006B460(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 1006D7D0: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (1006B490) --------------------------------------------------------
int __cdecl sub_1006B490(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 1006D7DC: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1006B4B0) --------------------------------------------------------
unsigned int __cdecl sub_1006B4B0(int a1, int a2)
{
  unsigned int result; // eax@1
  unsigned int v3; // edi@1
  unsigned int v4; // eax@3
  unsigned int v5; // esi@3
  int v6; // ebx@5

  result = j_FIL_vfs_open(a2, 4, 0);
  v3 = result;
  if ( result < 0xFFFFFFC2 && result )
  {
    v4 = j_FIL_vfs_open(a1, 10, 0);
    v5 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
      v6 = j_FIL_vfs_copy(v4, v3);
    else
      v6 = v4;
    sub_1006B210(v3);
    sub_1006B210(v5);
    result = v6;
  }
  return result;
}
// 1006B230: using guessed type int __cdecl j_FIL_vfs_copy(_DWORD, _DWORD);
// 1006B2E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1006B510) --------------------------------------------------------
char __cdecl sub_1006B510(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_1006B1D0(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1006B2E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1006B540) --------------------------------------------------------
int __cdecl sub_1006B540(char *a1, size_t a2, int a3, int a4)
{
  unsigned int v4; // ecx@1
  int v5; // esi@1
  int v6; // eax@5
  unsigned int v7; // kr08_4@5
  char *v8; // eax@5
  char *v9; // esi@5
  char v10; // cl@6
  unsigned int v11; // eax@7
  char *v12; // edi@7
  char v13; // cl@8
  char *v14; // edi@9
  char *v15; // esi@9
  int v16; // ecx@9
  unsigned int v17; // eax@9
  unsigned int v18; // ebp@11
  signed int v19; // edi@11
  unsigned int i; // esi@11
  char v21; // al@21
  char v23; // [sp+Bh] [bp-85h]@7
  char v24[128]; // [sp+Ch] [bp-84h]@5

  v4 = a3 - 1;
  v5 = 0;
  if ( a3 != 1 )
  {
    do
    {
      ++v5;
      v4 /= 0xAu;
    }
    while ( v4 );
  }
  if ( strlen(a1) + 5 > 0x80 || strlen(a1) + v5 + 1 > a2 )
    return -26;
  v6 = sub_100365D0((int)v24, a1, 128);
  sub_10036790(&v24[v6 - a4 - 1], 128 - (v6 - a4 - 1), "%%0%ii", v5);
  v7 = strlen(a1);
  v8 = &a1[v7 - a4];
  v9 = &a1[v7 - a4];
  do
    v10 = *v8++;
  while ( v10 );
  v11 = v8 - v9;
  v12 = &v23;
  do
    v13 = (v12++)[1];
  while ( v13 );
  qmemcpy(v12, v9, 4 * (v11 >> 2));
  v15 = &v9[4 * (v11 >> 2)];
  v14 = &v12[4 * (v11 >> 2)];
  v16 = v11 & 3;
  v17 = (unsigned int)a3 >> 4;
  qmemcpy(v14, v15, v16);
  if ( a3 > (unsigned int)a3 >> 4 )
    v17 = a3;
  v18 = 0;
  v19 = v17;
  for ( i = 0; ; i += v19 )
  {
    if ( i >= a3 )
      i = a3 - 1;
    sub_10036790(a1, a2, v24, i);
    if ( sub_1006B510((int)a1) )
      break;
    if ( !i )
      goto LABEL_21;
    v19 /= 2;
    i = v18;
    if ( v19 == 1 )
    {
      i = v18 + 1;
      goto LABEL_21;
    }
LABEL_19:
    ;
  }
  v18 = i;
  if ( i < a3 - 1 )
    goto LABEL_19;
  i = 0;
LABEL_21:
  v21 = 1;
  while ( i < a3 )
  {
    sub_10036790(a1, a2, v24, i);
    v21 = sub_1006B510((int)a1);
    ++i;
    if ( !v21 )
      return 0;
  }
  if ( !v21 )
    return 0;
  return -11;
}
// 1006B540: using guessed type char var_84[128];

//----- (1006B740) --------------------------------------------------------
int __cdecl sub_1006B740(int a1, int a2, int a3)
{
  return j_FIL_vfs_read_dir_cnt(a1, a2, a3, -1);
}
// 1006B330: using guessed type int __cdecl j_FIL_vfs_read_dir_cnt(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1006B760) --------------------------------------------------------
signed int __cdecl sub_1006B760(unsigned int a1, int a2, int a3)
{
  return sub_1006B3E0(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (1006B780) --------------------------------------------------------
int __cdecl sub_1006B780(int a1, int a2, int a3)
{
  return sub_1006B460(a1, a2, a3);
}

//----- (1006B7A0) --------------------------------------------------------
int __cdecl sub_1006B7A0(const char *a1)
{
  const char *v1; // edi@1
  int i; // esi@1
  int v3; // esi@3
  int result; // eax@3
  unsigned int v5; // eax@5
  unsigned int v6; // esi@5
  int v7; // ebx@7
  char *v8; // ebp@9
  char *v9; // eax@10
  char *v10; // edi@12
  char v11; // cl@13
  char v12; // dl@15
  unsigned int v13; // eax@16
  char *v14; // edi@16
  char v15; // cl@17
  int v16; // eax@19
  int v17; // eax@22
  signed int v18; // [sp+10h] [bp-1A0h]@9
  int v19; // [sp+18h] [bp-198h]@3
  unsigned int v20; // [sp+1Ch] [bp-194h]@5
  char v21; // [sp+20h] [bp-190h]@12
  char v22; // [sp+A0h] [bp-110h]@8

  v1 = a1;
  for ( i = 0; ; i = v19 )
  {
    v3 = i + 1;
    v19 = v3;
    result = j_FIL_vfs_rmdir(v1);
    if ( result != -30 || v3 >= 200000 )
      break;
    v5 = j_FIL_vfs_open(v1, 260, 0);
    v6 = v5;
    v20 = v5;
    if ( v5 < 0xFFFFFFC2 && v5 )
      v7 = sub_1006B740(v5, (int)&v22, 268);
    else
      v7 = v5;
    v8 = &v22;
    v18 = v7 < 0 ? 0 : v7;
    if ( (v7 < 0 ? 0 : v7) > 0 )
    {
      do
      {
        v9 = v8 + 24;
        if ( memcmp(&unk_10084574, v8 + 24, 2u) )
        {
          if ( memcmp("..", v8 + 24, 3u) )
          {
            strcpy(&v21, a1);
            v10 = (char *)&v20 + 3;
            do
              v11 = (v10++)[1];
            while ( v11 );
            *(_WORD *)v10 = 47;
            do
              v12 = *v9++;
            while ( v12 );
            v13 = v9 - (v8 + 24);
            v14 = (char *)&v20 + 3;
            do
              v15 = (v14++)[1];
            while ( v15 );
            qmemcpy(v14, v8 + 24, v13);
            v16 = *((_DWORD *)v8 + 5) & 0x1000 ? sub_1006B7A0(&v21) : j_FIL_vfs_delete(&v21);
            v7 = v16;
            if ( v16 )
              break;
          }
        }
        v17 = *((_WORD *)v8 + 2);
        v8 += v17;
        v18 -= v17;
      }
      while ( v18 > 0 );
      v1 = a1;
      v6 = v20;
    }
    if ( v6 < 0xFFFFFFC2 )
    {
      if ( v6 )
        sub_1006B1D0(v6);
    }
    if ( v7 )
      return v7;
  }
  return result;
}
// 1006B250: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);
// 1006B2E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1006B3D0: using guessed type int __cdecl j_FIL_vfs_rmdir(_DWORD);

//----- (1006B970) --------------------------------------------------------
__int16 __cdecl sub_1006B970(int a1, int a2, int a3, int a4)
{
  __int16 v4; // si@1

  SYS_enter_krnl();
  v4 = HWM_pvg_read_rgn(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D7E2: using guessed type int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1006B9A0) --------------------------------------------------------
const char *__cdecl sub_1006B9A0(int a1)
{
  char v1; // dl@1
  const char *result; // eax@1
  int v3; // ecx@3

  v1 = *(_BYTE *)a1;
  result = "UNKNOWN";
  if ( *(_BYTE *)(a1 + 2) )
    v1 = 5;
  v3 = 0;
  while ( byte_10122618[8 * v3] != v1 )
  {
    if ( (unsigned int)++v3 >= 5 )
      return result;
  }
  return (const char *)off_1012261C[2 * v3];
}

//----- (1006B9E0) --------------------------------------------------------
__int16 __cdecl sub_1006B9E0(int a1, _DWORD *a2, _BYTE *a3)
{
  __int16 result; // ax@1
  char v4; // [sp+8h] [bp-ECh]@1
  unsigned __int8 v5; // [sp+Ah] [bp-EAh]@1
  int v6; // [sp+10h] [bp-E4h]@1

  j_HWM_pvg_rgn_get_info(a1, &v4);
  result = v5;
  *a2 = v6;
  *a3 = 2;
  return result;
}
// 1006B9D0: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (1006BA40) --------------------------------------------------------
void __cdecl sub_1006BA40(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_1006D2E0(a1, a2);
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D7EE: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (1006BA70) --------------------------------------------------------
int __cdecl sub_1006BA70(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_set(a1, a2);
  return SYS_exit_krnl();
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D7F4: using guessed type int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD);

//----- (1006BC30) --------------------------------------------------------
int sub_1006BC30()
{
  int result; // eax@2

  if ( sub_1006C1E0() )
    result = j_HWM_pvg_get_anlg_outp(4);
  else
    result = j_HWM_pvg_get_anlg_outp(0);
  return result;
}
// 1006BAF0: using guessed type int __cdecl j_HWM_pvg_get_anlg_outp(_DWORD);

//----- (1006BC50) --------------------------------------------------------
int __usercall sub_1006BC50@<eax>(int a1@<eax>)
{
  return HWM_pvg_test_dev(a1);
}
// 1006D896: using guessed type int __cdecl HWM_pvg_test_dev(_DWORD);

//----- (1006BC60) --------------------------------------------------------
int __cdecl sub_1006BC60(__int16 a1)
{
  void *v1; // ecx@0
  int result; // eax@2

  if ( sub_10037130(v1) & 0xF0 )
    result = sub_1006D340(1, HIBYTE(a1));
  else
    result = sub_1006D340(0, HIBYTE(a1));
  return result;
}

//----- (1006BC90) --------------------------------------------------------
signed int __cdecl sub_1006BC90(__int16 a1, char a2)
{
  char v2; // bl@1
  const char *v3; // ecx@1
  signed int result; // eax@9
  unsigned int v5; // esi@9
  int v6; // edi@15
  char v7; // [sp+8h] [bp-D0h]@15
  char v8; // [sp+Ch] [bp-CCh]@4

  v2 = 0;
  sub_10069700();
  v3 = "/hwm_test.dat";
  if ( a2 )
    v3 = "/hwm_test_rw.dat";
  if ( HIBYTE(a1) )
  {
    if ( HIBYTE(a1) == 1 )
      sprintf(&v8, "%s%s", "/mnt/card1", v3);
    else
      sprintf(&v8, "%s%s", "/mnt/card2", v3);
  }
  else
  {
    sprintf(&v8, "%s%s", "/mnt/card0", v3);
  }
  if ( a2 )
  {
    v2 = sub_1006D470((int)&v8, 0x8000u, 1u, 2u);
LABEL_18:
    sub_10069700();
    return v2 != 0 ? 0 : -14;
  }
  result = j_FIL_vfs_open(&v8, 4, 0);
  v5 = result;
  if ( (unsigned int)result < 0xFFFFFFC2 )
  {
    if ( result )
    {
      sub_10069700();
      result = sub_1006B760(v5, 0, 2);
      if ( result >= 0 )
      {
        if ( result < 100 )
        {
          sub_100364C0("..\\lib\\adl\\hwm_usr_test.c", 440, 1, 0);
          return -14;
        }
        j_FIL_vfs_clean_invalidate_cache(v5);
        v6 = j_FIL_vfs_crc32(v5, 0, 0, &v7);
        sub_1006B1D0(v5);
        if ( !v6 )
          v2 = 1;
        goto LABEL_18;
      }
    }
  }
  return result;
}
// 1006B1C0: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);
// 1006B240: using guessed type int __cdecl j_FIL_vfs_crc32(_DWORD, _DWORD, _DWORD, _DWORD);
// 1006B2E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1006BE10) --------------------------------------------------------
unsigned int __cdecl sub_1006BE10(__int16 a1)
{
  unsigned int result; // eax@5
  const char *v2; // [sp-Ch] [bp-Ch]@2

  if ( HIBYTE(a1) )
  {
    if ( HIBYTE(a1) != 1 )
      return -33;
    v2 = "/dev/eeprom1";
  }
  else
  {
    v2 = "/dev/eeprom0";
  }
  result = j_FIL_vfs_open(v2, 6, 0);
  if ( result < 0xFFFFFFC2 )
  {
    if ( result )
    {
      sub_1006B1D0(result);
      result = 0;
    }
  }
  return result;
}
// 1006B2E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1006BE60) --------------------------------------------------------
unsigned int __cdecl sub_1006BE60(char a1)
{
  unsigned int result; // eax@2
  unsigned int v2; // edi@6
  unsigned int v3; // edx@9
  int *v4; // eax@9
  int *v5; // ecx@9
  int v6; // esi@13
  int v7; // edx@14
  _BYTE *v8; // eax@14
  _BYTE *v9; // ecx@14
  int v10; // edx@16
  _BYTE *v11; // eax@16
  _BYTE *v12; // ecx@16
  _BYTE *v13; // eax@18
  _BYTE *v14; // ecx@18
  int v15; // edx@19
  signed int v16; // eax@20
  unsigned int v17; // eax@24
  int *v18; // ecx@24
  int *v19; // edx@24
  int v20; // esi@28
  int v21; // eax@29
  _BYTE *v22; // ecx@29
  _BYTE *v23; // edx@29
  int v24; // eax@31
  _BYTE *v25; // ecx@31
  _BYTE *v26; // edx@31
  _BYTE *v27; // ecx@33
  _BYTE *v28; // edx@33
  signed int v29; // eax@35
  int v30; // [sp+0h] [bp-24h]@9
  int v31; // [sp+4h] [bp-20h]@9
  int v32; // [sp+8h] [bp-1Ch]@9
  int v33; // [sp+Ch] [bp-18h]@9
  int v34; // [sp+10h] [bp-14h]@9
  int v35; // [sp+14h] [bp-10h]@9
  int v36; // [sp+18h] [bp-Ch]@9
  int v37; // [sp+1Ch] [bp-8h]@9

  if ( a1 != 4 )
    return -16;
  if ( sub_1006B510((int)"/mnt/sys_nand0/nand_test.txt") )
  {
    result = j_FIL_vfs_delete("/mnt/sys_nand0/nand_test.txt");
    if ( result )
      return result;
    j_FIL_vfs_sync_all();
  }
  result = j_FIL_vfs_open("/mnt/sys_nand0/nand_test.txt", 14, 1911);
  v2 = result;
  if ( result < 0xFFFFFFC2 && result )
  {
    v30 = -1431655766;
    v31 = -1431655766;
    v32 = -1431655766;
    v33 = -1431655766;
    j_FIL_vfs_write(result, &v30, 16);
    j_FIL_vfs_clean_invalidate_cache(v2);
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    sub_1006B340(v2, &v34, 16, 0, 0);
    v3 = 16;
    v4 = &v30;
    v5 = &v34;
    do
    {
      if ( *v5 != *v4 )
        goto LABEL_13;
      v3 -= 4;
      ++v4;
      ++v5;
    }
    while ( v3 >= 4 );
    if ( v3 )
    {
LABEL_13:
      v6 = *(_BYTE *)v5 - *(_BYTE *)v4;
      if ( *(_BYTE *)v5 != *(_BYTE *)v4
        || (v7 = v3 - 1, v8 = (char *)v4 + 1, v9 = (char *)v5 + 1, v7)
        && ((v6 = *v9 - *v8, *v9 != *v8)
         || (v10 = v7 - 1, v11 = v8 + 1, v12 = v9 + 1, v10)
         && ((v6 = *v12 - *v11, *v12 != *v11)
          || (v13 = v11 + 1, v14 = v12 + 1, v10 != 1) && (v15 = *v13, v6 = *v14 - v15, *v14 != v15))) )
      {
        v16 = 1;
        if ( v6 <= 0 )
          v16 = -1;
LABEL_23:
        if ( v16 )
          return -16;
        sub_1006B760(v2, 0, 0);
        v30 = 1431655765;
        v31 = 1431655765;
        v32 = 1431655765;
        v33 = 1431655765;
        j_FIL_vfs_write(v2, &v30, 16);
        j_FIL_vfs_clean_invalidate_cache(v2);
        v34 = 0;
        v35 = 0;
        v36 = 0;
        v37 = 0;
        sub_1006B340(v2, &v34, 16, 0, 0);
        v17 = 16;
        v18 = &v30;
        v19 = &v34;
        do
        {
          if ( *v19 != *v18 )
            goto LABEL_28;
          v17 -= 4;
          ++v18;
          ++v19;
        }
        while ( v17 >= 4 );
        if ( v17 )
        {
LABEL_28:
          v20 = *(_BYTE *)v19 - *(_BYTE *)v18;
          if ( *(_BYTE *)v19 != *(_BYTE *)v18
            || (v21 = v17 - 1, v22 = (char *)v18 + 1, v23 = (char *)v19 + 1, v21)
            && ((v20 = *v23 - *v22, *v23 != *v22)
             || (v24 = v21 - 1, v25 = v22 + 1, v26 = v23 + 1, v24)
             && ((v20 = *v26 - *v25, *v26 != *v25)
              || (v27 = v25 + 1, v28 = v26 + 1, v24 != 1) && (v20 = *v28 - *v27, *v28 != *v27))) )
          {
            v29 = 1;
            if ( v20 <= 0 )
              v29 = -1;
LABEL_38:
            if ( !v29 )
            {
              sub_1006B1D0(v2);
              j_FIL_vfs_delete("/mnt/sys_nand0/nand_test.txt");
              return 0;
            }
            return -16;
          }
        }
        v29 = 0;
        goto LABEL_38;
      }
    }
    v16 = 0;
    goto LABEL_23;
  }
  return result;
}
// 1006B1C0: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);
// 1006B250: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);
// 1006B2E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1006B450: using guessed type int j_FIL_vfs_sync_all(void);
// 1006B480: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1006C0E0) --------------------------------------------------------
signed int __cdecl sub_1006C0E0(__int16 *a1, char a2)
{
  int v2; // esi@2
  signed int result; // eax@2
  unsigned int v4; // esi@3
  signed int v5; // esi@4
  int v6; // esi@5
  unsigned int v7; // esi@6
  int v8; // ST04_4@7
  int v9; // esi@7

  sub_10069700();
  switch ( *(_BYTE *)a1 )
  {
    case 1:
      v2 = sub_1006BC60(*a1);
      sub_10069700();
      result = v2;
      break;
    case 3:
      v4 = sub_1006BE10(*a1);
      sub_10069700();
      result = v4;
      break;
    case 6:
      v5 = sub_1006BC90(*a1, a2);
      sub_10069700();
      result = v5;
      break;
    case 5:
    case 7:
    case 0xB:
      v6 = sub_1006BC50((int)a1);
      sub_10069700();
      result = v6;
      break;
    case 4:
      v7 = sub_1006BE60(*a1);
      sub_10069700();
      result = v7;
      break;
    case 0xC:
      v8 = (unsigned __int16)*a1;
      v9 = sub_1005FF20();
      sub_10069700();
      result = v9;
      break;
    default:
      sub_10069700();
      result = -15;
      break;
  }
  return result;
}

//----- (1006C1E0) --------------------------------------------------------
bool sub_1006C1E0()
{
  unsigned int v0; // eax@1

  v0 = j_HWM_pvg_read_reg(0);
  return v0 >= 0x17 && (v0 <= 0x18 || v0 == 40);
}
// 1006BBD0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1006C200) --------------------------------------------------------
__int16 __cdecl sub_1006C200(unsigned __int16 a1)
{
  int v1; // eax@1
  signed int v2; // eax@3
  unsigned int v3; // ecx@3
  int v4; // eax@6

  v1 = j_HWM_pvg_read_reg(0);
  if ( v1 != 33 && v1 != 49 )
  {
    LOWORD(v4) = a1;
  }
  else
  {
    v2 = 1;
    v3 = 6;
    do
    {
      if ( a1 <= (unsigned __int16)word_10123110[v3] )
        break;
      v3 += 6;
      ++v2;
    }
    while ( v3 < 54 );
    v4 = (dword_10123118[3 * (v2 - 1)] + dword_10123114[3 * (v2 - 1)] * a1) / 0x2000;
    if ( v4 > 0 )
    {
      if ( (unsigned int)v4 >= 0x2710 )
        LOWORD(v4) = 10000;
    }
    else
    {
      LOWORD(v4) = 0;
    }
  }
  return v4;
}
// 1006BBD0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10123110: using guessed type __int16 word_10123110[];
// 10123114: using guessed type int dword_10123114[];
// 10123118: using guessed type int dword_10123118[];

//----- (1006C280) --------------------------------------------------------
char __cdecl sub_1006C280(int a1)
{
  bool v1; // zf@1
  char result; // al@1
  char v3; // [sp+4h] [bp-60h]@1

  memset(&v3, 0, 0x60u);
  v1 = j_HWM_pvg_ethr_get_stats(a1, &v3) == 0;
  result = 1;
  if ( !v1 )
    result = 0;
  return result;
}
// 1006BAE0: using guessed type int __cdecl j_HWM_pvg_ethr_get_stats(_DWORD, _DWORD);

//----- (1006C2C0) --------------------------------------------------------
signed int sub_1006C2C0()
{
  return sub_1006C280(3) != 0 ? 1 : 5;
}

//----- (1006C2E0) --------------------------------------------------------
__int16 sub_1006C2E0()
{
  int v0; // esi@1
  unsigned int v1; // eax@1

  v0 = (signed __int16)j_HWM_pvg_get_frmt_adc(1);
  v1 = (unsigned __int16)((v0 + (signed __int16)j_HWM_pvg_get_frmt_adc(0)) / 2);
  if ( v1 >= 0x2710 )
    LOWORD(v1) = 10000;
  return sub_1006C200(v1);
}
// 1006BB10: using guessed type int __cdecl j_HWM_pvg_get_frmt_adc(_DWORD);

//----- (1006C330) --------------------------------------------------------
int __cdecl sub_1006C330(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10037130(v1);
  a1 = v2;
  v3 = sub_1003B860(&a1, 4u, (int)&unk_10123C18, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_10123C1C[2 * v3];
}
// 10123C1C: using guessed type int dword_10123C1C[];

//----- (1006C370) --------------------------------------------------------
int __cdecl sub_1006C370(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10037130(v1);
  a1 = v2;
  v3 = sub_1003B860(&a1, 4u, (int)&unk_10123C50, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_10123C54[2 * v3];
}
// 10123C54: using guessed type int dword_10123C54[];

//----- (1006C3B0) --------------------------------------------------------
int __cdecl sub_1006C3B0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10037130(v1);
  a1 = v2;
  v3 = sub_1003B860(&a1, 4u, (int)&unk_10123C88, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_10123C8C[2 * v3];
}
// 10123C8C: using guessed type int dword_10123C8C[];

//----- (1006C3F0) --------------------------------------------------------
int __cdecl sub_1006C3F0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10037130(v1);
  a1 = v2;
  v3 = sub_1003B860(&a1, 4u, (int)&unk_10123CC0, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_10123CC4[2 * v3];
}
// 10123CC4: using guessed type int dword_10123CC4[];

//----- (1006C430) --------------------------------------------------------
int __cdecl sub_1006C430(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_1006C370(a4);
    result = sub_1006A0A0(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_1006A0A0(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_1006C330(a4);
      result = sub_1006A0A0(v6, a3, 6);
    }
  }
  return result;
}

//----- (1006C4A0) --------------------------------------------------------
int __cdecl sub_1006C4A0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_1006C3F0(a3);
    result = sub_1006A0A0(v4, a1, 64);
    if ( result == -7 )
    {
      sub_10069880(100);
      v5 = sub_1006C3F0(a3);
      result = sub_1006A0A0(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_1006C3B0(a3);
    result = sub_1006A0A0(v6, a2, 8);
    if ( result == -7 )
    {
      sub_10069880(100);
      v7 = sub_1006C3B0(a3);
      result = sub_1006A0A0(v7, a2, 8);
    }
  }
  return result;
}

//----- (1006C550) --------------------------------------------------------
int __cdecl sub_1006C550(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_100364C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_100364C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 1006D590: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (1006C5B0) --------------------------------------------------------
int __usercall sub_1006C5B0@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  char v3; // ST28_1@2
  unsigned int v4; // eax@5
  char *v5; // edi@9
  char v6; // al@10
  unsigned int v7; // eax@12
  char v8; // ST28_1@12
  signed int v9; // ebx@15
  int v10; // eax@19
  int result; // eax@47
  unsigned int v12; // [sp+Ch] [bp-98h]@1
  int v13; // [sp+14h] [bp-90h]@29
  char v14; // [sp+1Dh] [bp-87h]@30
  char v15; // [sp+1Fh] [bp-85h]@9
  char v16; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v12 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
    v3 = 4;
  }
  else
  {
    strncpy(&v16, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v5 = &v15;
      do
        v6 = (v5++)[1];
      while ( v6 );
      *(_DWORD *)v5 = 7368052;
    }
    v12 = j_FIL_vfs_open(*a1, 6, 1809);
    v7 = j_FIL_vfs_open(&v16, 14, 1809);
    v2 = v7;
    v8 = 6;
    if ( v7 >= 0xFFFFFFC2 || !v7 )
    {
      sub_100364C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v9 = sub_1006B760(v7, 0, 2);
    if ( v9 < 0 )
    {
      sub_100364C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_100364C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v10 = (int)(a1[2] + 12);
    if ( v9 < v10 && sub_1006B780(v2, v10, (unsigned __int64)v10 >> 32) < 0 )
    {
      sub_100364C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v4 = ((int (__cdecl *)(unsigned int, _DWORD, const char *, _DWORD))j_FIL_vfs_mmap)(v2, 0, a1[2] + 12, 0);
    v1 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v4 + 9) || *(_BYTE *)(v4 + 8) != 56 )
        {
          sub_1006C550((int)a1, v4 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v4 + 4) = sub_10069700();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v12 < 0xFFFFFFC2 && v12 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_1006B2F0(v12, &v13, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v13;
          v14 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_1006B490(v12, (int)&v13, 12, 0) != 12 )
          {
            sub_100364C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v16, *a1) )
        sub_100364C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_100364C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_1006B1D0(v2);
LABEL_42:
  if ( v12 < 0xFFFFFFC2 && v12 )
    sub_1006B1D0(v12);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 1006B2D0: using guessed type int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1006B2E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1006B3C0: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (1006C8B0) --------------------------------------------------------
int __usercall sub_1006C8B0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 1006D590: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (1006C8D0) --------------------------------------------------------
signed int __cdecl sub_1006C8D0(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_100364C0("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_10069980(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_10069950(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_1006C8B0(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_1006C5B0((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_10069950(v6, 81);
  return (unsigned __int8)v2;
}

//----- (1006C9E0) --------------------------------------------------------
int __cdecl sub_1006C9E0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D8BA: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (1006CA30) --------------------------------------------------------
int __cdecl sub_1006CA30(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 1006D59C: using guessed type int SYS_exit_krnl(void);
// 1006D5A8: using guessed type int SYS_enter_krnl(void);
// 1006D8C0: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (1006CAB0) --------------------------------------------------------
char __cdecl sub_1006CAB0(unsigned int a1, unsigned int *a2, int *a3)
{
  int *v3; // edi@4
  int *v4; // edi@5
  int *v5; // edi@6
  int *v7; // edi@11
  int *v8; // edi@12
  int *v9; // esi@13
  unsigned int *v10; // [sp-18h] [bp-E94h]@4
  signed int v11; // [sp-14h] [bp-E90h]@4
  int v12; // [sp+14h] [bp-E68h]@1
  int v13; // [sp+18h] [bp-E64h]@6
  int v14; // [sp+1Ch] [bp-E60h]@6
  char v15; // [sp+20h] [bp-E5Ch]@6
  char v16; // [sp+22h] [bp-E5Ah]@6
  char v17; // [sp+23h] [bp-E59h]@6
  char v18; // [sp+25h] [bp-E57h]@6
  char v19; // [sp+27h] [bp-E55h]@6
  char v20; // [sp+28h] [bp-E54h]@6
  char v21; // [sp+29h] [bp-E53h]@6
  int v22; // [sp+2Ch] [bp-E50h]@6
  int v23; // [sp+37h] [bp-E45h]@5
  int v24; // [sp+40h] [bp-E3Ch]@12
  int v25; // [sp+F0h] [bp-D8Ch]@13
  int v26; // [sp+E70h] [bp-Ch]@11
  int v27; // [sp+E74h] [bp-8h]@11

  memset(&v12, 0, 0xE64u);
  *_errno() = 0;
  if ( a1 > 0x183A )
  {
    if ( a1 == 6455 )
    {
      v9 = _errno();
      *v9 = sub_1006A0A0(6455, (int)&v12, 252);
      v25 = 0;
      v11 = 252;
LABEL_14:
      v10 = (unsigned int *)&v12;
      goto LABEL_15;
    }
    if ( a1 != 6649 )
    {
      if ( a1 != 6655 )
        return 0;
      goto LABEL_11;
    }
LABEL_12:
    v8 = _errno();
    *v8 = sub_1006A0A0(a1, (int)&v12, 48);
    v11 = 48;
    v24 = 0;
    v10 = (unsigned int *)&v12;
    goto LABEL_15;
  }
  if ( a1 >= 0x1839 )
    goto LABEL_12;
  switch ( a1 )
  {
    case 0x17D9u:
    case 0x17DAu:
      v3 = _errno();
      v11 = 36;
      *v3 = sub_1006A0A0(a1, (int)&v12, 36);
      v12 = 0;
      v10 = (unsigned int *)&v12;
      goto LABEL_15;
    case 0x1819u:
      v4 = _errno();
      *v4 = sub_1006A0A0(a1, (int)&v12, 40);
      v11 = 40;
      v23 = 0;
      v10 = (unsigned int *)&v12;
      goto LABEL_15;
    case 0x17CDu:
    case 0x17CEu:
      v5 = _errno();
      *v5 = sub_1006A0A0(a1, (int)&v12, 60);
      v12 = 0;
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v22 = 0;
      v18 = 0;
      v21 = 0;
      v19 = 0;
      v20 = 0;
      v11 = 60;
      goto LABEL_14;
    default:
      return 0;
    case 0x1776u:
    case 0x1777u:
    case 0x1778u:
      break;
  }
LABEL_11:
  v7 = _errno();
  *v7 = sub_1006A0A0(a1, (int)&v12, 3684);
  v11 = 3684;
  v26 = 0;
  v27 = 0;
  v10 = (unsigned int *)&v12;
LABEL_15:
  *a2 = sub_10022E80(v10, v11, 0xFFFFFFFF);
  *a3 = *_errno();
  return 1;
}

//----- (1006CD80) --------------------------------------------------------
signed int sub_1006CD80()
{
  return sub_1006C8D0((int)&off_10125F58);
}
// 10125F58: using guessed type char *off_10125F58;

//----- (1006CD90) --------------------------------------------------------
int __cdecl sub_1006CD90(unsigned int a1)
{
  int result; // eax@3

  if ( a1 < 0xC && (unsigned __int8)sub_1006CD80() )
    result = 8216 * a1 + dword_10755CDC + 3312;
  else
    result = 0;
  return result;
}
// 10755CDC: using guessed type int dword_10755CDC;

//----- (1006CDF0) --------------------------------------------------------
unsigned int __cdecl sub_1006CDF0(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_10755D68[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_10755D20[a1];
  dword_10755D20[a1] = a3 + v9;
  dword_10755CE0[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_10755CE0[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 10755D20: using guessed type int dword_10755D20[];
// 10755D68: using guessed type int dword_10755D68[];

//----- (1006CFA0) --------------------------------------------------------
int __usercall sub_1006CFA0@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_10755D68[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_10755D68[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 10755D68: using guessed type int dword_10755D68[];

//----- (1006D050) --------------------------------------------------------
int __cdecl sub_1006D050(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_1006CFA0(a1);
  v3 = &dword_10755D68[a1];
  v4 = sub_1006B340(
         *(_DWORD *)dword_10755D68[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_10755D68[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_10755D20[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 10755D20: using guessed type int dword_10755D20[];
// 10755D68: using guessed type int dword_10755D68[];

//----- (1006D100) --------------------------------------------------------
int __usercall sub_1006D100@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_10755D68[a1];
  v3 = (int *)(dword_10755D20[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_10755D68[a1] + 32)) % *(_WORD *)(dword_10755D68[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_1006D050(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 10755D20: using guessed type int dword_10755D20[];
// 10755D68: using guessed type int dword_10755D68[];

//----- (1006D190) --------------------------------------------------------
unsigned int __cdecl sub_1006D190(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  unsigned int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_10755D60 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_10755D68[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_10755D60 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_100697D0(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_10755D68[v6] + 28);
        v12 = sub_1006D100(v6, (unsigned int)v7 & *(_DWORD *)(dword_10755D68[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy_0(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_10755D68[v6] + 4) != 138 )
        sub_100697B0(*(_DWORD *)(dword_10755D68[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_10755D68[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_100697B0(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 10755D60: using guessed type int dword_10755D60;
// 10755D68: using guessed type int dword_10755D68[];

//----- (1006D2E0) --------------------------------------------------------
void __cdecl sub_1006D2E0(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_10036FA0(v2) && sub_10037080(v3) != 1 )
    *a2 = 0;
}

//----- (1006D340) --------------------------------------------------------
int __cdecl sub_1006D340(int a1, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  int v4; // edi@2
  int v5; // [sp+4h] [bp-2Ch]@1
  int v6; // [sp+8h] [bp-28h]@1
  int v7; // [sp+Ch] [bp-24h]@1
  int v8; // [sp+10h] [bp-20h]@1
  int v9; // [sp+14h] [bp-1Ch]@1
  int v10; // [sp+18h] [bp-18h]@1
  int v11; // [sp+1Ch] [bp-14h]@1
  int v12; // [sp+20h] [bp-10h]@1
  char v13; // [sp+24h] [bp-Ch]@1
  char v14; // [sp+25h] [bp-Bh]@1
  int v15; // [sp+28h] [bp-8h]@1

  v13 = 1;
  v14 = 1;
  v15 = a2;
  v5 = -1;
  v6 = -1;
  v7 = -1;
  v8 = -1;
  v9 = -1;
  v10 = -1;
  v11 = -1;
  v12 = -1;
  result = j_HWM_pvg_arnc_open(&v5);
  v3 = result;
  if ( result >= 0 )
  {
    v4 = j_HWM_pvg_arnc_ioctl(a1, 0, result);
    j_HWM_pvg_arnc_close(v3);
    result = v4;
  }
  return result;
}
// 1006D310: using guessed type int __cdecl j_HWM_pvg_arnc_close(_DWORD);
// 1006D320: using guessed type int __cdecl j_HWM_pvg_arnc_ioctl(_DWORD, _DWORD, _DWORD);
// 1006D330: using guessed type int __cdecl j_HWM_pvg_arnc_open(_DWORD);

//----- (1006D3D0) --------------------------------------------------------
char __usercall sub_1006D3D0@<al>(size_t a1@<eax>, void *a2@<ebx>, size_t a3@<edi>)
{
  size_t v3; // esi@8

  if ( a2 )
  {
    switch ( a1 )
    {
      case 0u:
        LOBYTE(a1) = (unsigned int)memset(a2, 0, a3);
        break;
      case 1u:
        LOBYTE(a1) = (unsigned int)memset(a2, -1, a3);
        break;
      case 3u:
        a1 = 0;
        if ( a3 )
        {
          do
          {
            *((_BYTE *)a2 + a1) = a1;
            ++a1;
          }
          while ( a1 < a3 );
        }
        break;
      case 2u:
        v3 = 0;
        if ( a3 )
        {
          do
          {
            LOBYTE(a1) = rand();
            *((_BYTE *)a2 + v3++) = a1;
          }
          while ( v3 < a3 );
        }
        break;
      default:
        LOBYTE(a1) = sub_100364C0("..\\lib\\adl\\fil_test_dev_rw.c", 281, 0, 0);
        break;
    }
  }
  else
  {
    LOBYTE(a1) = sub_100364C0("..\\lib\\adl\\fil_test_dev_rw.c", 288, 0, 0);
  }
  return a1;
}

//----- (1006D470) --------------------------------------------------------
char __cdecl sub_1006D470(int a1, unsigned int a2, unsigned int a3, size_t a4)
{
  char result; // al@1
  unsigned int v5; // eax@3
  unsigned int v6; // edi@3
  unsigned int v7; // esi@5
  signed int v8; // ebp@5
  int v9; // edi@6
  bool v10; // cf@17
  char v11; // [sp+3h] [bp-Dh]@1
  int v12; // [sp+4h] [bp-Ch]@3
  int v13; // [sp+8h] [bp-8h]@1
  int v14; // [sp+Ch] [bp-4h]@13

  result = 1;
  v11 = 1;
  v13 = 0;
  if ( a3 )
  {
    while ( result )
    {
      v5 = j_FIL_vfs_open(a1, 14, 0);
      v6 = v5;
      v12 = v5;
      if ( v5 >= 0xFFFFFFC2 || !v5 )
        return 0;
      v7 = 0;
      v8 = -1;
      if ( a2 )
      {
        while ( 1 )
        {
          v9 = a2 - v7;
          if ( a2 - v7 > 0x400 )
            v9 = 1024;
          sub_1006D3D0(a4, &unk_10755DA8, v9);
          v8 = sub_10022E80((unsigned int *)&unk_10755DA8, v9, v8);
          if ( sub_1006B490(v12, (int)&unk_10755DA8, v9, v7) != v9 )
            break;
          v7 += 1024;
          if ( v7 >= a2 )
            goto LABEL_12;
        }
        v11 = 0;
LABEL_12:
        v6 = v12;
      }
      j_FIL_vfs_clean_invalidate_cache(v6);
      if ( j_FIL_vfs_crc32(v6, 0, a2, &v14) || v14 != v8 )
        return 0;
      if ( sub_1006B1D0(v6) )
        v11 = 0;
      v10 = v13++ + 1 < a3;
      result = v11;
      if ( !v10 )
        return result;
    }
  }
  return result;
}
// 1006B1C0: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);
// 1006B240: using guessed type int __cdecl j_FIL_vfs_crc32(_DWORD, _DWORD, _DWORD, _DWORD);
// 1006B2E0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10070073) --------------------------------------------------------
int __cdecl sub_10070073(int a1, int a2, char a3)
{
  return vscan_fn(sub_10078B0F, a2, 0, &a3);
}
// 1007000B: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100714DC) --------------------------------------------------------
int __cdecl sub_100714DC(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_1007B261() + 8 && (void **)v2 != sub_1007B261() + 16 || !sub_1007B203((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_101362A8;
      else
        v9 = (_BYTE *)(dword_1078B000[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_1007B0E3((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_1007B0E3((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 1007B1BF: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 1078B000: using guessed type int dword_1078B000[];

//----- (10072071) --------------------------------------------------------
int __cdecl sub_10072071(int a1)
{
  int result; // eax@1

  result = a1;
  dword_107564EC = a1;
  return result;
}
// 107564EC: using guessed type int dword_107564EC;

//----- (100729D3) --------------------------------------------------------
signed int __cdecl sub_100729D3(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_10756504 )
  {
    *a1 = dword_10756504;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 10072177: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10756504: using guessed type int dword_10756504;

//----- (10072A0A) --------------------------------------------------------
signed int __cdecl sub_10072A0A(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_10756504 )
  {
    *a1 = dword_10756510;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 10072177: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10756504: using guessed type int dword_10756504;
// 10756510: using guessed type int dword_10756510;

//----- (1007302B) --------------------------------------------------------
void sub_1007302B()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_1078B000;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_1078B100 );
}
// 1078B000: using guessed type int dword_1078B000[];
// 1078B100: using guessed type int dword_1078B100;

//----- (100734D8) --------------------------------------------------------
int (*sub_100734D8())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_10134350;
  v1 = (int (**)(void))&unk_10134350;
  if ( &unk_10134350 < &unk_10134350 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_10134350 );
  }
  return result;
}

//----- (100734FC) --------------------------------------------------------
void __cdecl sub_100734FC()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_10134358;
  if ( &unk_10134358 < &unk_10134358 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_10134358 );
  }
}

//----- (100750D4) --------------------------------------------------------
#error "100750D9: positive sp value has been found (funcsize=0)"

//----- (100750DF) --------------------------------------------------------
#error "100750E4: positive sp value has been found (funcsize=0)"

//----- (100750EA) --------------------------------------------------------
#error "100750EF: positive sp value has been found (funcsize=0)"

//----- (100750F0) --------------------------------------------------------
#error "100750F5: positive sp value has been found (funcsize=0)"

//----- (100750F6) --------------------------------------------------------
#error "100750FB: positive sp value has been found (funcsize=0)"

//----- (100750FC) --------------------------------------------------------
#error "10075101: positive sp value has been found (funcsize=0)"

//----- (10075102) --------------------------------------------------------
#error "1007511D: positive sp value has been found (funcsize=0)"

//----- (10075123) --------------------------------------------------------
#error "10075138: positive sp value has been found (funcsize=0)"

//----- (1007513E) --------------------------------------------------------
#error "10075159: positive sp value has been found (funcsize=0)"

//----- (1007515A) --------------------------------------------------------
#error "10075169: positive sp value has been found (funcsize=0)"

//----- (1007516A) --------------------------------------------------------
#error "1007517D: positive sp value has been found (funcsize=0)"

//----- (1007517E) --------------------------------------------------------
#error "1007518D: positive sp value has been found (funcsize=0)"

//----- (1007518E) --------------------------------------------------------
#error "100751AD: positive sp value has been found (funcsize=0)"

//----- (100751B3) --------------------------------------------------------
#error "100751CC: positive sp value has been found (funcsize=0)"

//----- (100751D2) --------------------------------------------------------
#error "100751F1: positive sp value has been found (funcsize=0)"

//----- (100751F2) --------------------------------------------------------
#error "10075205: positive sp value has been found (funcsize=0)"

//----- (10075206) --------------------------------------------------------
#error "1007521D: positive sp value has been found (funcsize=0)"

//----- (1007521E) --------------------------------------------------------
#error "10075231: positive sp value has been found (funcsize=0)"

//----- (10075232) --------------------------------------------------------
#error "10075251: positive sp value has been found (funcsize=0)"

//----- (10075257) --------------------------------------------------------
#error "10075270: positive sp value has been found (funcsize=0)"

//----- (10075276) --------------------------------------------------------
#error "10075295: positive sp value has been found (funcsize=0)"

//----- (10075296) --------------------------------------------------------
#error "100752A9: positive sp value has been found (funcsize=0)"

//----- (100752AA) --------------------------------------------------------
#error "100752C1: positive sp value has been found (funcsize=0)"

//----- (100752C2) --------------------------------------------------------
#error "100752D5: positive sp value has been found (funcsize=0)"

//----- (100752D6) --------------------------------------------------------
#error "100752F5: positive sp value has been found (funcsize=0)"

//----- (100752FB) --------------------------------------------------------
#error "10075314: positive sp value has been found (funcsize=0)"

//----- (1007531A) --------------------------------------------------------
#error "10075339: positive sp value has been found (funcsize=0)"

//----- (1007533A) --------------------------------------------------------
#error "1007534D: positive sp value has been found (funcsize=0)"

//----- (1007534E) --------------------------------------------------------
#error "10075365: positive sp value has been found (funcsize=0)"

//----- (10075366) --------------------------------------------------------
#error "10075379: positive sp value has been found (funcsize=0)"

//----- (1007537A) --------------------------------------------------------
#error "10075399: positive sp value has been found (funcsize=0)"

//----- (1007539F) --------------------------------------------------------
#error "100753B8: positive sp value has been found (funcsize=0)"

//----- (100753BE) --------------------------------------------------------
#error "100753DD: positive sp value has been found (funcsize=0)"

//----- (100753DE) --------------------------------------------------------
#error "100753F1: positive sp value has been found (funcsize=0)"

//----- (100753F2) --------------------------------------------------------
#error "10075409: positive sp value has been found (funcsize=0)"

//----- (1007540A) --------------------------------------------------------
#error "1007541D: positive sp value has been found (funcsize=0)"

//----- (1007541E) --------------------------------------------------------
#error "1007543D: positive sp value has been found (funcsize=0)"

//----- (10075443) --------------------------------------------------------
#error "1007545C: positive sp value has been found (funcsize=0)"

//----- (10075462) --------------------------------------------------------
#error "10075481: positive sp value has been found (funcsize=0)"

//----- (10075482) --------------------------------------------------------
#error "10075495: positive sp value has been found (funcsize=0)"

//----- (10075496) --------------------------------------------------------
#error "100754AD: positive sp value has been found (funcsize=0)"

//----- (100754AE) --------------------------------------------------------
#error "100754C1: positive sp value has been found (funcsize=0)"

//----- (100754C2) --------------------------------------------------------
#error "100754E1: positive sp value has been found (funcsize=0)"

//----- (100754E7) --------------------------------------------------------
#error "10075500: positive sp value has been found (funcsize=0)"

//----- (10075506) --------------------------------------------------------
#error "10075525: positive sp value has been found (funcsize=0)"

//----- (10075526) --------------------------------------------------------
#error "10075539: positive sp value has been found (funcsize=0)"

//----- (1007553A) --------------------------------------------------------
#error "10075551: positive sp value has been found (funcsize=0)"

//----- (10075552) --------------------------------------------------------
#error "10075565: positive sp value has been found (funcsize=0)"

//----- (10078B0F) --------------------------------------------------------
int __cdecl sub_10078B0F(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
  {
    v7 = &unk_101362A8;
  }
  else
  {
    v6 = &dword_1078B000[_fileno(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno(a1) == -1 || _fileno(a1) == -2 ? (v9 = &unk_101362A8) : (v8 = &dword_1078B000[_fileno(a1) >> 5],
                                                                         v9 = (_BYTE *)(*v8 + ((_fileno(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_1007E6AC(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_1007E6AC(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_1007E6AC(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_1007E6AC(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_1007E6AC(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_10136284[0]);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_1007E6AC(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_1007E6AC(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_1007E6AC(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_1007E6AC(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 10072177: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100723E8: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10078AD4: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 10078AEA: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 10136284: using guessed type int (*off_10136284[3])();
// 1078B000: using guessed type int dword_1078B000[];
// 10078B0F: using guessed type char var_24[11];

//----- (1007A360) --------------------------------------------------------
int sub_1007A360()
{
  dword_1078B118 = _get_sse2_info();
  return 0;
}
// 1007A300: using guessed type int _get_sse2_info(void);
// 1078B118: using guessed type int dword_1078B118;

//----- (1007A36D) --------------------------------------------------------
void sub_1007A36D()
{
  dword_1078AFE4 = 0;
}
// 1078AFE4: using guessed type int dword_1078AFE4;

//----- (1007A375) --------------------------------------------------------
int __cdecl sub_1007A375(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1007D709((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 10076F61: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007A41B) --------------------------------------------------------
int __cdecl sub_1007A41B(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1007DC4B((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 10076F61: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007A925) --------------------------------------------------------
DWORD __cdecl sub_1007A925(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_1007FE51(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_1078B000[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 10070511: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1078B000: using guessed type int dword_1078B000[];

//----- (1007AAC1) --------------------------------------------------------
_WORD *__cdecl sub_1007AAC1(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  CHAR v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_1078B000[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_1078B000[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_1007A925(a1, 0, 0, 2u);
  if ( sub_1007B203(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 10070511: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 10072177: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10072604: using guessed type int _getptd(void);
// 1078B000: using guessed type int dword_1078B000[];
// 1007AAC1: using guessed type CHAR var_410[688];

//----- (1007B0E3) --------------------------------------------------------
_WORD *__cdecl sub_1007B0E3(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_1078B000[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_1007AAC1(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_1007FF62(a1);
  return v6;
}
// 10072177: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1007FEC2: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 1078B000: using guessed type int dword_1078B000[];

//----- (1007B203) --------------------------------------------------------
int __cdecl sub_1007B203(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_1078B000[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 10072177: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1078B000: using guessed type int dword_1078B000[];

//----- (1007B261) --------------------------------------------------------
void **sub_1007B261()
{
  return &off_10136CC0;
}
// 10136CC0: using guessed type void *off_10136CC0;

//----- (1007B267) --------------------------------------------------------
signed int sub_1007B267()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_1078AFE0;
  if ( !dword_1078AFE0 )
  {
    v0 = 512;
LABEL_5:
    dword_1078AFE0 = v0;
    goto LABEL_6;
  }
  if ( dword_1078AFE0 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_10789FC0 = v1;
  if ( v1 || (dword_1078AFE0 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_10789FC0 = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_10136CC0;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&dword_10136F40 )
        break;
      v1 = dword_10789FC0;
    }
    v5 = 0;
    v6 = &unk_10136CD0;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_1078B000[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_10136D30 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 10072CF4: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 10136CC0: using guessed type void *off_10136CC0;
// 10136F40: using guessed type int dword_10136F40;
// 1078AFE0: using guessed type int dword_1078AFE0;
// 1078B000: using guessed type int dword_1078B000[];

//----- (1007BB32) --------------------------------------------------------
int sub_1007BB32()
{
  return _decode_pointer(dword_10756B28);
}
// 100723E8: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10756B28: using guessed type int dword_10756B28;

//----- (1007BCEF) --------------------------------------------------------
int __cdecl sub_1007BCEF(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10756B34 = a1;
  return result;
}
// 10756B34: using guessed type int dword_10756B34;

//----- (1007BCF9) --------------------------------------------------------
int __cdecl sub_1007BCF9(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10756B40 = a1;
  return result;
}
// 10756B40: using guessed type int dword_10756B40;

//----- (1007BD03) --------------------------------------------------------
int __cdecl sub_1007BD03(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10756B44 = a1;
  return result;
}
// 10756B44: using guessed type int dword_10756B44;

//----- (1007BDE2) --------------------------------------------------------
int __cdecl sub_1007BDE2(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10756B48 = a1;
  return result;
}
// 10756B48: using guessed type int dword_10756B48;

//----- (1007D709) --------------------------------------------------------
signed int __cdecl sub_1007D709(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_10137138 - 1;
    v64 = v3;
    v65 = dword_10137138 / 32;
    v9 = dword_10137138 % 32;
    v10 = (int *)(&v60 + dword_10137138 / 32);
    v66 = 31 - dword_10137138 % 32;
    if ( (1 << (31 - dword_10137138 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_10137134 - dword_10137138 )
    {
      if ( v3 > dword_10137134 )
      {
        if ( v3 < dword_10137130 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_10137144 + v3;
          v50 = dword_1013713C / 32;
          v51 = dword_1013713C % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_1013713C % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_1013713C / 32;
          v44 = dword_1013713C % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_1013713C % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_10137144 + dword_10137130;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_10137134 - v64) / 32;
      v62 = v59;
      v18 = (dword_10137134 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_10137138 - 1;
      v25 = dword_10137138 / 32;
      v65 = dword_10137138 / 32;
      v26 = (int *)(&v60 + dword_10137138 / 32);
      v64 = 31 - dword_10137138 % 32;
      if ( (1 << (31 - dword_10137138 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_10137138 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_1013713C + 1) / 32;
      v37 = (dword_1013713C + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_1013713C));
  if ( dword_10137140 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_10137140 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 10137130: using guessed type int dword_10137130;
// 10137134: using guessed type int dword_10137134;
// 10137138: using guessed type int dword_10137138;
// 1013713C: using guessed type int dword_1013713C;
// 10137140: using guessed type int dword_10137140;
// 10137144: using guessed type int dword_10137144;

//----- (1007DC4B) --------------------------------------------------------
signed int __cdecl sub_1007DC4B(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_10137150 - 1;
    v64 = v3;
    v65 = dword_10137150 / 32;
    v9 = dword_10137150 % 32;
    v10 = (int *)(&v60 + dword_10137150 / 32);
    v66 = 31 - dword_10137150 % 32;
    if ( (1 << (31 - dword_10137150 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_1013714C - dword_10137150 )
    {
      if ( v3 > dword_1013714C )
      {
        if ( v3 < dword_10137148 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_1013715C + v3;
          v50 = dword_10137154 / 32;
          v51 = dword_10137154 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_10137154 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_10137154 / 32;
          v44 = dword_10137154 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_10137154 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_1013715C + dword_10137148;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_1013714C - v64) / 32;
      v62 = v59;
      v18 = (dword_1013714C - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_10137150 - 1;
      v25 = dword_10137150 / 32;
      v65 = dword_10137150 / 32;
      v26 = (int *)(&v60 + dword_10137150 / 32);
      v64 = 31 - dword_10137150 % 32;
      if ( (1 << (31 - dword_10137150 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_10137150 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_10137154 + 1) / 32;
      v37 = (dword_10137154 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_10137154));
  if ( dword_10137158 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_10137158 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 10137148: using guessed type int dword_10137148;
// 1013714C: using guessed type int dword_1013714C;
// 10137150: using guessed type int dword_10137150;
// 10137154: using guessed type int dword_10137154;
// 10137158: using guessed type int dword_10137158;
// 1013715C: using guessed type int dword_1013715C;

//----- (1007E58C) --------------------------------------------------------
int __cdecl sub_1007E58C(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
    {
      v8 = &unk_101362A8;
    }
    else
    {
      v7 = &dword_1078B000[_fileno(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 10072177: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1007B1BF: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 1078B000: using guessed type int dword_1078B000[];

//----- (1007E6AC) --------------------------------------------------------
int __cdecl sub_1007E6AC(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno(a2) == -1 || _fileno(a2) == -2 )
    {
      v3 = &unk_101362A8;
    }
    else
    {
      v2 = &dword_1078B000[_fileno(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno(a2) == -1 || _fileno(a2) == -2 ? (v5 = &unk_101362A8) : (v4 = &dword_1078B000[_fileno(a2) >> 5],
                                                                           v5 = (_BYTE *)(*v4
                                                                                        + ((_fileno(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 10072177: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1007B1BF: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 1078B000: using guessed type int dword_1078B000[];

//----- (1007E8F4) --------------------------------------------------------
int sub_1007E8F4()
{
  return 0;
}

//----- (1007FDD0) --------------------------------------------------------
signed int __cdecl sub_1007FDD0(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_1078B000[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_107561C0 == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 107561C0: using guessed type int dword_107561C0;
// 1078B000: using guessed type int dword_1078B000[];

//----- (1007FE51) --------------------------------------------------------
signed int __cdecl sub_1007FE51(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_1078B000[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 10072177: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1078B000: using guessed type int dword_1078B000[];

//----- (1007FF62) --------------------------------------------------------
void __cdecl sub_1007FF62(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_1078B000[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 1078B000: using guessed type int dword_1078B000[];

//----- (10080263) --------------------------------------------------------
int sub_10080263()
{
  return flsall(1);
}
// 10080189: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (1008026C) --------------------------------------------------------
int __cdecl sub_1008026C(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_10756B64 )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_10756B64 = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_10756B68 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_10756B6C = _encode_pointer(v7);
    if ( sub_100729D3(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_10756B74 = _encode_pointer(v8);
      if ( dword_10756B74 )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_10756B70 = _encode_pointer(v9);
      }
    }
  }
  if ( dword_10756B70 == v23
    || dword_10756B74 == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_10756B70),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_10756B74),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_10756B68 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_10756B68);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_10756B6C != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_10756B6C);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_10072A0A(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_10756B64);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 1007207B: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10072371: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 100723DF: using guessed type int _encoded_null(void);
// 100723E8: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10756B64: using guessed type int dword_10756B64;
// 10756B68: using guessed type int dword_10756B68;
// 10756B6C: using guessed type int dword_10756B6C;
// 10756B70: using guessed type int dword_10756B70;
// 10756B74: using guessed type int dword_10756B74;

//----- (10081081) --------------------------------------------------------
signed int __cdecl sub_10081081(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_1007FE51(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_1078B000[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_1078B000[0] + 68) & 1)
    && (v1 = sub_1007FE51(2), sub_1007FE51(1) == v1)
    || (v2 = (void *)sub_1007FE51(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_1007FDD0(a1);
  *(_BYTE *)(dword_1078B000[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10070511: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1078B000: using guessed type int dword_1078B000[];

//----- (10081220) --------------------------------------------------------
double __cdecl sub_10081220(char a1)
{
  double v1; // st7@5
  double result; // st7@9
  float v3; // [sp+0h] [bp-4h]@1

  v3 = 0.0;
  if ( !sub_1003F150() )
    goto LABEL_13;
  if ( !a1 )
  {
    v1 = *(float *)(dword_1078971C + 124);
    goto LABEL_8;
  }
  if ( a1 == 2 )
  {
    v1 = *(float *)(dword_1078971C + 860);
    goto LABEL_8;
  }
  if ( a1 == 3 )
  {
    v1 = *(float *)(dword_1078971C + 1204);
LABEL_8:
    v3 = v1;
  }
  result = v3;
  if ( (LODWORD(v3) & 0x7F800000) == 2139095040 || result > 3.141592502593994 || result < -3.141592502593994 )
  {
    v3 = 0.0;
LABEL_13:
    result = v3;
  }
  return result;
}
// 1078971C: using guessed type int dword_1078971C;

//----- (100812B0) --------------------------------------------------------
signed int __cdecl sub_100812B0(char a1)
{
  return (signed int)(sub_10081220(a1) * 683565248.0);
}

//----- (100812D0) --------------------------------------------------------
char sub_100812D0()
{
  char result; // al@2

  if ( sub_1003F150() )
    result = *(_BYTE *)(dword_1078971C + 815);
  else
    result = 0;
  return result;
}
// 1078971C: using guessed type int dword_1078971C;

//----- (10081390) --------------------------------------------------------
bool __cdecl sub_10081390(void *a1)
{
  bool result; // al@2

  if ( sub_1003F150() )
  {
    sub_10044570();
    qmemcpy(a1, (const void *)(dword_1078971C + 1356), 0x94u);
    result = sub_100697B0(99) == 0;
  }
  else
  {
    memset(a1, 0, 0x94u);
    result = (char)a1;
    *((float *)a1 + 11) = 9.9999996e24;
    *((float *)a1 + 12) = 9.9999996e24;
    *((_BYTE *)a1 + 1) = 0;
    *((float *)a1 + 14) = 9.9999996e24;
    *((_BYTE *)a1 + 25) = 0;
    *((float *)a1 + 15) = 9.9999996e24;
    *((_BYTE *)a1 + 7) = 1;
    *((float *)a1 + 18) = 9.9999996e24;
    *((_BYTE *)a1 + 10) = 0;
    *((float *)a1 + 17) = 9.9999996e24;
    *((_DWORD *)a1 + 9) = -1;
    *((float *)a1 + 20) = 9.9999996e24;
    *((_BYTE *)a1 + 19) = -1;
    *((float *)a1 + 24) = 9.9999996e24;
    *((_DWORD *)a1 + 10) = -1;
    *((float *)a1 + 26) = 9.9999996e24;
    *((_BYTE *)a1 + 20) = -1;
    *((float *)a1 + 27) = 9.9999996e24;
    *((_BYTE *)a1 + 8) = 0;
    *((float *)a1 + 31) = 9.9999996e24;
    *((_BYTE *)a1 + 9) = 0;
    *((float *)a1 + 32) = 9.9999996e24;
    *((_BYTE *)a1 + 13) = 0;
    *((float *)a1 + 33) = 9.9999996e24;
    *((_BYTE *)a1 + 15) = 0;
    *((float *)a1 + 34) = 9.9999996e24;
    *((_BYTE *)a1 + 14) = 0;
    *((float *)a1 + 16) = 9.9999996e24;
    *((_BYTE *)a1 + 16) = 0;
    *((float *)a1 + 35) = 9.9999996e24;
    *((_BYTE *)a1 + 17) = 0;
    *((float *)a1 + 36) = 9.9999996e24;
    *((_BYTE *)a1 + 24) = 0;
    *((float *)a1 + 19) = 9.9999996e24;
    *((float *)a1 + 21) = 9.9999996e24;
    *((float *)a1 + 22) = 9.9999996e24;
    *((float *)a1 + 23) = 9.9999996e24;
    *((float *)a1 + 25) = 9.9999996e24;
    *((float *)a1 + 28) = 9.9999996e24;
    *((float *)a1 + 29) = 0.0;
    *((float *)a1 + 30) = 9.9999996e24;
  }
  return result;
}
// 1078971C: using guessed type int dword_1078971C;

//----- (100813E0) --------------------------------------------------------
char sub_100813E0()
{
  unsigned __int8 v0; // cl@2
  signed int v1; // eax@4

  if ( !sub_1003F150() )
  {
    LOBYTE(v1) = 0;
    return v1;
  }
  v0 = *(_BYTE *)(dword_1078971C + 1200);
  if ( v0 || (v0 = *(_BYTE *)(dword_1078971C + 814)) != 0 )
  {
    LOBYTE(v1) = v0;
    if ( v0 < 4u )
      return v1;
    v1 = 4;
  }
  else
  {
    v1 = *(_BYTE *)(dword_1078971C + 122) == 0;
  }
  if ( v1 == 4 )
    LOBYTE(v1) = 0;
  return v1;
}
// 1078971C: using guessed type int dword_1078971C;

//----- (10081430) --------------------------------------------------------
double __cdecl sub_10081430(float a1)
{
  float v2; // [sp+4h] [bp+4h]@1

  v2 = pow(a1 / 101325.0, 0.190228059887886);
  return (float)((1.0 - v2) * -44330.765625);
}

//----- (10081460) --------------------------------------------------------
int __cdecl sub_10081460(int a1, signed int a2, int a3, char a4)
{
  int result; // eax@44
  signed __int16 v5; // [sp+0h] [bp-3Ch]@11
  int v6; // [sp+4h] [bp-38h]@27
  int v7; // [sp+4h] [bp-38h]@33
  __int16 v8; // [sp+8h] [bp-34h]@13
  char v9; // [sp+Fh] [bp-2Dh]@2
  char (__cdecl *v10)(int); // [sp+10h] [bp-2Ch]@3
  char *(__cdecl *v11)(int); // [sp+14h] [bp-28h]@6
  __int16 v12; // [sp+18h] [bp-24h]@8
  __int16 v13; // [sp+1Ch] [bp-20h]@13
  signed __int16 v14; // [sp+20h] [bp-1Ch]@13
  signed __int16 v15; // [sp+24h] [bp-18h]@21
  signed int i; // [sp+28h] [bp-14h]@8
  __int16 v17; // [sp+2Ch] [bp-10h]@11
  __int16 v18; // [sp+30h] [bp-Ch]@11
  signed __int16 v19; // [sp+34h] [bp-8h]@24
  __int16 v20; // [sp+38h] [bp-4h]@8

  if ( a2 >= 2 )
  {
    v9 = 0;
    if ( *(_DWORD *)(a1 + 72) )
      v10 = *(char (__cdecl **)(int))(a1 + 72);
    else
      v10 = sub_1001F4F0;
    if ( *(_DWORD *)(a1 + 76) )
      v11 = *(char *(__cdecl **)(int))(a1 + 76);
    else
      v11 = sub_1001F6C0;
    v20 = *(_WORD *)(a1 + 42) + *(_WORD *)a3;
    v12 = *(_WORD *)(a1 + 40) + *(_WORD *)(a3 + 2);
    for ( i = 1; i < a2; ++i )
    {
      *(_WORD *)(a1 + 10) = v20;
      *(_WORD *)(a1 + 8) = v12;
      v20 = *(_WORD *)(a1 + 42) + *(_WORD *)(a3 + 4 * i);
      v12 = *(_WORD *)(a1 + 40) + *(_WORD *)(a3 + 4 * i + 2);
      *(_WORD *)(a1 + 14) = v20;
      *(_WORD *)(a1 + 12) = v12;
      v5 = 1;
      v17 = *(_WORD *)(a1 + 14) - *(_WORD *)(a1 + 10);
      v18 = v17;
      if ( v17 < 0 )
      {
        v5 = -1;
        v18 = -v17;
      }
      v14 = 1;
      v8 = *(_WORD *)(a1 + 12) - *(_WORD *)(a1 + 8);
      v13 = v8;
      if ( v8 < 0 )
      {
        v14 = -1;
        v13 = -v8;
      }
      if ( v8 | v17 )
      {
        if ( *(_WORD *)(a1 + 14) == *(_WORD *)(a1 + 10) )
        {
          v9 = 1;
          *(_WORD *)(a1 + 16) = 0;
          *(_WORD *)(a1 + 18) = 1;
          *(_WORD *)(a1 + 12) = v8;
          v11(a1);
          *(_WORD *)(a1 + 8) += v8;
        }
        else if ( *(_WORD *)(a1 + 12) == *(_WORD *)(a1 + 8) )
        {
          v9 = 0;
          *(_WORD *)(a1 + 16) = 1;
          *(_WORD *)(a1 + 18) = 0;
          *(_WORD *)(a1 + 14) = v17;
          v10(a1);
          *(_WORD *)(a1 + 10) += v17;
        }
        else
        {
          if ( v18 <= 0x3FFF )
            v15 = 2 * v18;
          else
            v15 = 32766;
          if ( v13 <= 0x3FFF )
            v19 = 2 * v13;
          else
            v19 = 32766;
          if ( v18 <= v13 )
          {
            v9 = 1;
            *(_WORD *)(a1 + 16) = 0;
            *(_WORD *)(a1 + 18) = 1;
            v7 = v15 - v13 - (v5 < 0);
            *(_WORD *)(a1 + 12) = 0;
            while ( v13 )
            {
              *(_WORD *)(a1 + 12) += v14;
              if ( v7 >= 0 )
              {
                v11(a1);
                *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
                *(_WORD *)(a1 + 12) = 0;
                *(_WORD *)(a1 + 10) += v5;
                v7 -= v19;
              }
              v7 += v15;
              --v13;
            }
            v11(a1);
            *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
          }
          else
          {
            v9 = 0;
            *(_WORD *)(a1 + 16) = 1;
            *(_WORD *)(a1 + 18) = 0;
            v6 = v19 - v18 - (v14 < 0);
            *(_WORD *)(a1 + 14) = 0;
            while ( v18 )
            {
              *(_WORD *)(a1 + 14) += v5;
              if ( v6 >= 0 )
              {
                v10(a1);
                *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
                *(_WORD *)(a1 + 14) = 0;
                *(_WORD *)(a1 + 8) += v14;
                v6 -= v15;
              }
              v6 += v19;
              --v18;
            }
            v10(a1);
            *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
          }
        }
      }
    }
    if ( a4 & 2 )
    {
      if ( v9 )
      {
        *(_WORD *)(a1 + 12) = 1;
        v11(a1);
      }
      else
      {
        *(_WORD *)(a1 + 14) = 1;
        v10(a1);
      }
    }
    *(_WORD *)(a1 + 46) = *(_WORD *)(a1 + 10) - *(_WORD *)(a1 + 42);
    result = *(_WORD *)(a1 + 40);
    *(_WORD *)(a1 + 44) = *(_WORD *)(a1 + 8) - result;
  }
  return result;
}

//----- (100818F0) --------------------------------------------------------
int __cdecl sub_100818F0(int a1, signed int a2, int a3, int a4, int a5)
{
  int result; // eax@3
  __int16 v6; // ST14_2@11
  __int16 v7; // ST18_2@11
  __int16 v8; // ST5C_2@11
  int v9; // edx@47
  int v10; // eax@50
  int v11; // ecx@50
  int v12; // ecx@51
  __int16 v13; // [sp+4h] [bp-6Ch]@55
  __int16 v14; // [sp+Ah] [bp-66h]@11
  __int16 v15; // [sp+Eh] [bp-62h]@11
  signed __int16 j; // [sp+10h] [bp-60h]@6
  unsigned __int16 l; // [sp+10h] [bp-60h]@18
  signed __int16 ii; // [sp+10h] [bp-60h]@47
  unsigned __int16 v19; // [sp+14h] [bp-5Ch]@22
  unsigned __int16 v20; // [sp+18h] [bp-58h]@24
  char *v21; // [sp+20h] [bp-50h]@1
  __int16 k; // [sp+28h] [bp-48h]@15
  int v23; // [sp+2Ch] [bp-44h]@47
  int v24; // [sp+30h] [bp-40h]@47
  int v25; // [sp+34h] [bp-3Ch]@47
  int v26; // [sp+38h] [bp-38h]@15
  int v27; // [sp+3Ch] [bp-34h]@4
  int v28; // [sp+40h] [bp-30h]@11
  __int16 v29; // [sp+44h] [bp-2Ch]@13
  signed __int16 v30; // [sp+48h] [bp-28h]@11
  int v31; // [sp+4Ch] [bp-24h]@11
  signed __int16 v32; // [sp+54h] [bp-1Ch]@11
  __int16 v33; // [sp+5Ch] [bp-14h]@57
  signed __int16 i; // [sp+60h] [bp-10h]@4
  unsigned __int16 m; // [sp+60h] [bp-10h]@36
  signed __int16 n; // [sp+60h] [bp-10h]@44
  unsigned __int16 jj; // [sp+60h] [bp-10h]@53
  __int16 v38; // [sp+64h] [bp-Ch]@11
  __int16 v39; // [sp+68h] [bp-8h]@4
  unsigned __int16 v40; // [sp+6Ch] [bp-4h]@17
  int v41; // [sp+84h] [bp+14h]@1

  v21 = (char *)(a5 + (-a5 & 3));
  v41 = a4 - (-a5 & 3) - (((_BYTE)a4 - (-(char)a5 & 3)) & 3);
  if ( a2 >= 2 && 2 * a2 <= v41 )
  {
    v39 = *(_WORD *)(a1 + 4);
    *(_WORD *)(a1 + 4) = *(_WORD *)(a1 + 6);
    v27 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 48);
    *(_WORD *)v21 = 0;
    for ( i = 1; (unsigned __int16)i < a2; ++i )
    {
      for ( j = i;
            j
         && *(_WORD *)(a3 + 4 * *(_WORD *)&v21[2 * (unsigned __int16)j - 2] + 2) > (signed int)*(_WORD *)(a3 + 4 * (unsigned __int16)i + 2);
            --j )
      {
        *(_WORD *)&v21[2 * (unsigned __int16)j] = *(_WORD *)&v21[2 * (unsigned __int16)j - 2];
      }
      *(_WORD *)&v21[2 * (unsigned __int16)j] = i;
    }
    v30 = 0;
    v32 = 0;
    v28 = 2 * a2 + (-2 * a2 & 3);
    v31 = (int)&v21[v28];
    v6 = *(_WORD *)(a1 + 26);
    v7 = *(_WORD *)(a1 + 30);
    v15 = *(_WORD *)(a1 + 28);
    v8 = *(_WORD *)(a1 + 42);
    v14 = *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 40);
    v38 = *(_WORD *)(a3 + 4 * *(_WORD *)v21 + 2);
    if ( v38 < v14 )
      v38 = *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 40);
    v29 = *(_WORD *)(a3 + 4 * *(_WORD *)&v21[2 * a2 - 2] + 2);
    if ( v29 > v15 + v14 )
      v29 = v15 + v14;
    v26 = 0;
    for ( k = v38; k < v29; ++k )
    {
      while ( 1 )
      {
        v40 = *(_WORD *)&v21[2 * v26];
        if ( *(_WORD *)(a3 + 4 * v40 + 2) > k )
          break;
        for ( l = 0; (signed int)l < 2; ++l )
        {
          if ( l )
          {
            if ( v40 == a2 - 1 )
              v19 = 0;
            else
              v19 = v40 + 1;
            v20 = v40;
          }
          else
          {
            if ( v40 )
              v19 = v40 - 1;
            else
              v19 = a2 - 1;
            v20 = v19;
          }
          if ( *(_WORD *)(a3 + 4 * v19 + 2) <= k )
          {
            if ( *(_WORD *)(a3 + 4 * v19 + 2) < k )
            {
              for ( m = 0; m < (signed int)(unsigned __int16)v30 && *(_WORD *)(v31 + 12 * m) != v20; ++m )
                ;
              if ( (unsigned __int16)v30 - m > 0 )
                memcpy((void *)(v31 + 12 * m), (const void *)(v31 + 12 * (m + 1)), 12 * ((unsigned __int16)--v30 - m));
            }
          }
          else
          {
            if ( (unsigned __int16)v30 == (unsigned __int16)((v41 - v28) / 0xCu) )
            {
              v32 = -1;
              goto LABEL_63;
            }
            *(_WORD *)(v31 + 12 * (unsigned __int16)v30) = v20;
            *(_DWORD *)(v31 + 12 * (unsigned __int16)v30 + 4) = ((*(_WORD *)(a3 + 4 * v19)
                                                                - (signed int)*(_WORD *)(a3 + 4 * v40)) << 16)
                                                              / (*(_WORD *)(a3 + 4 * v19 + 2)
                                                               - (signed int)*(_WORD *)(a3 + 4 * v40 + 2));
            *(_DWORD *)(v31 + 12 * (unsigned __int16)v30 + 8) = (*(_WORD *)(a3 + 4 * v40) << 16)
                                                              + *(_DWORD *)(v31 + 12 * (unsigned __int16)v30 + 4)
                                                              * (k - *(_WORD *)(a3 + 4 * v40 + 2));
            if ( (unsigned __int16)++v30 > (signed int)(unsigned __int16)v32 )
              v32 = v30;
          }
        }
        ++v26;
      }
      for ( n = 1; (unsigned __int16)n < (signed int)(unsigned __int16)v30; ++n )
      {
        if ( *(_DWORD *)(v31 + 12 * ((unsigned __int16)n - 1) + 8) > *(_DWORD *)(v31 + 12 * (unsigned __int16)n + 8) )
        {
          v9 = v31 + 12 * (unsigned __int16)n;
          v23 = *(_DWORD *)v9;
          v24 = *(_DWORD *)(v9 + 4);
          v25 = *(_DWORD *)(v9 + 8);
          for ( ii = n; ii && *(_DWORD *)(v31 + 12 * ((unsigned __int16)ii - 1) + 8) > v25; --ii )
          {
            v10 = v31 + 12 * ((unsigned __int16)ii - 1);
            v11 = v31 + 12 * (unsigned __int16)ii;
            *(_DWORD *)v11 = *(_DWORD *)v10;
            *(_DWORD *)(v11 + 4) = *(_DWORD *)(v10 + 4);
            *(_DWORD *)(v11 + 8) = *(_DWORD *)(v10 + 8);
          }
          v12 = v31 + 12 * (unsigned __int16)ii;
          *(_DWORD *)v12 = v23;
          *(_DWORD *)(v12 + 4) = v24;
          *(_DWORD *)(v12 + 8) = v25;
        }
      }
      for ( jj = 0; jj < (unsigned __int16)v30 - 1; jj += 2 )
      {
        v13 = *(_DWORD *)(v31 + 12 * jj + 8) >> 16;
        if ( *(_WORD *)(v31 + 12 * jj + 8) )
          ++v13;
        v33 = *(_DWORD *)(v31 + 12 * (jj + 1) + 8) >> 16;
        if ( !*(_WORD *)(v31 + 12 * (jj + 1) + 8) )
          --v33;
        if ( v13 <= v33 )
        {
          *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + v13;
          *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + k;
          *(_WORD *)(a1 + 14) = *(_WORD *)(a1 + 42) + v33;
          sub_1001F440(a1);
        }
        *(_DWORD *)(v31 + 12 * jj + 8) += *(_DWORD *)(v31 + 12 * jj + 4);
        *(_DWORD *)(v31 + 12 * (jj + 1) + 8) += *(_DWORD *)(v31 + 12 * (jj + 1) + 4);
      }
    }
LABEL_63:
    *(_WORD *)(a1 + 4) = v39;
    *(_DWORD *)(a1 + 36) = v27;
    if ( (unsigned __int16)v32 == 0xFFFF )
      result = -1;
    else
      result = v31 + 12 * (unsigned __int16)v32 - a5;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10081FE0) --------------------------------------------------------
double __cdecl sub_10081FE0(int a1)
{
  float v1; // ST00_4@1
  float v2; // ST00_4@1

  v1 = *(float *)a1 * *(float *)a1 + 0.0;
  v2 = *(float *)(a1 + 4) * *(float *)(a1 + 4) + v1;
  return (float)sqrt(v2);
}

//----- (10082020) --------------------------------------------------------
int __cdecl sub_10082020(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(float *)a3 = *(float *)a2 * a1;
  *(float *)(a3 + 4) = a1 * *(float *)(a2 + 4);
  return result;
}

//----- (10082040) --------------------------------------------------------
int __cdecl sub_10082040(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(float *)a3 = *(float *)a1 - *(float *)a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) - *(float *)(a2 + 4);
  return result;
}

//----- (10082060) --------------------------------------------------------
int __cdecl sub_10082060(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)a2 = *(float *)a1;
  *(float *)(a2 + 4) = *(float *)(a1 + 4);
  return result;
}

//----- (10082080) --------------------------------------------------------
void __cdecl sub_10082080(int a1, int a2)
{
  int v2; // edx@1
  float v3; // ST10_4@1
  double v4; // st7@1

  sub_10082060(a1, a2);
  v3 = sub_10081FE0(v2);
  v4 = v3;
  if ( v3 > 0.0 )
  {
    *(float *)a2 = *(float *)a2 / v4;
    *(float *)(a2 + 4) = *(float *)(a2 + 4) / v4;
  }
}

#error "There were 52 decompilation failure(s) on 1823 function(s)"
