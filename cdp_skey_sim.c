/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

char __cdecl sub_10001000(int a1);
bool __cdecl sub_100010B0(int a1, int a2);
// int __usercall sub_100010D0@<eax>(int result@<eax>, int a2@<esi>);
char __cdecl sub_10001180(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
char __cdecl sub_100012C0(int a1, int a2);
int sub_100014A0(void); // weak
int sub_100014B0();
int __cdecl sub_100014E0(int a1, int a2);
int __cdecl sub_10001500(int a1);
_DWORD *sub_10001530();
int __cdecl sub_10001550(int a1, char *a2, int a3, int a4);
char __cdecl sub_100015E0(int a1, int a2, int a3);
char __cdecl sub_10001650(int a1, int a2, int a3);
int sub_100016C0();
_DWORD *__cdecl sub_100016E0(int a1);
// void __usercall sub_10001700(int a1@<esi>);
// char __usercall sub_10001730@<al>(int a1@<esi>);
// void __usercall sub_10001810(int a1@<esi>, int a2);
// void __usercall sub_100018E0(int a1@<esi>, int a2);
// int __usercall sub_10001980@<eax>(int a1@<edi>, int a2);
char __thiscall sub_10001B50(int this);
signed int __cdecl sub_10001B70(int a1, int a2);
char __cdecl sub_10001CC0(int a1, int a2, __int16 a3);
char __cdecl sub_10001CF0(int a1, int a2, __int16 a3);
char __cdecl sub_10001D20(int a1);
// int __usercall sub_10002050@<eax>(int a1@<eax>);
void __noreturn sub_100020E0();
int __cdecl sub_10002320(int a1, int a2);
char __cdecl sub_10002340(int a1, unsigned int a2);
char sub_10002380();
char __thiscall sub_100023A0(int this);
int __cdecl sub_10002510(int a1);
char __cdecl sub_10002660(int a1);
int __cdecl sub_10002680(int a1, int a2);
int __cdecl sub_10002700(int a1, __int16 a2, __int16 a3);
_WORD *__cdecl sub_10002720(int a1);
// int __usercall sub_10002790@<eax>(char a1@<dl>, int a2@<esi>);
// int __usercall sub_10002820@<eax>(int a1@<esi>, char a2);
// char __usercall sub_10002920@<al>(void *a1@<ecx>, int a2@<edi>);
int __thiscall sub_10002A30(void *this);
int __cdecl sub_10002AB0(__int16 a1);
// int __usercall sub_100030A0@<eax>(int a1@<edi>);
int __cdecl sub_10003190(int a1);
char __cdecl sub_10003440(int a1);
char __cdecl sub_100035A0(int a1);
int sub_10003820(void); // weak
char __cdecl sub_10003830(char a1);
char sub_10003850();
int __cdecl sub_10003860(int a1);
char sub_100038A0();
_DWORD __cdecl sub_100038B0(_DWORD); // weak
char __cdecl sub_100038C0(int a1);
char __cdecl sub_10003930(int a1);
int sub_100039A0(void); // weak
int __cdecl nullsub_1(_DWORD, _DWORD);
_DWORD sub_100039C0(); // weak
int __cdecl sub_10003A30(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_10003A80(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int sub_10003AD0();
int __cdecl j_gdi_pvg_load_identity(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_active(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_current(_DWORD); // weak
int __cdecl j_gdi_pvg_matrix_mode(_DWORD); // weak
int __cdecl sub_10003B20(float, float, float, float, float, float); // idb
int j_gdi_pvg_update_display_wdw(void); // weak
int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD); // weak
char *__cdecl sub_10003B80(int a1, char *a2, int a3, char *a4, int a5);
char sub_10003CB0();
char __cdecl sub_10003CC0(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_10003DC0(char *a1, int a2, char a3, char *a4);
int __cdecl sub_10003E30(int a1, int a2, int a3);
int __cdecl j_gdi_pvg_destroy_window(_DWORD); // weak
int sub_10003E70();
int __cdecl sub_10003EC0(int a1);
int __cdecl sub_10003ED0(int a1);
int sub_10003EF0();
int __cdecl sub_10003F10(int a1, int a2);
__int16 __cdecl sub_10003F40(int a1);
int sub_10003F60();
int __cdecl sub_10003F80(int a1, int a2, int a3, int a4);
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_10003FC0(int a1, int a2, int a3, int a4);
int __cdecl sub_10003FF0(int a1);
int __cdecl sub_10004010(int a1);
int __cdecl sub_10004030(int a1, int a2);
int __cdecl sub_10004060(int a1, int a2);
int __cdecl sub_10004090(int a1, int a2, int a3, int a4);
int __cdecl sub_100040C0(int a1, int a2);
int __cdecl sub_100040F0(int a1);
int __cdecl sub_10004110(int a1);
char __cdecl sub_10004130(int a1, int a2);
int __cdecl sub_100041A0(_BYTE *a1);
int __cdecl sub_100041E0(int a1, int a2);
int __cdecl sub_10004210(int a1, int a2);
int __cdecl sub_10004230(int a1);
int __cdecl sub_10004270(int a1, int a2, int a3);
char __cdecl sub_10004290(int a1, int a2, int a3);
int __cdecl sub_100042D0(int, void *, int, void *); // idb
int __cdecl sub_10004310(int a1, int a2, int a3);
int __cdecl sub_10004340(int a1, int a2, int a3);
int __cdecl sub_10004360(int a1, int a2, int a3);
int __cdecl sub_100043C0(int a1, int a2, int a3);
int __cdecl sub_10004400(int, void *, int, void *); // idb
int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD); // weak
signed int __cdecl sub_10004460(unsigned int a1);
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl sub_100044C0(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_10004530(unsigned int a1, void *a2, int a3);
signed int __cdecl sub_10004570(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
signed int __cdecl sub_10004600(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_10004650(int a1);
int __cdecl sub_10004670(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_100046A0(int a1, int a2, int a3, char a4);
char __cdecl sub_100046C0(int a1);
signed int __cdecl sub_100046F0(unsigned int a1, int a2, int a3);
int __cdecl sub_10004710(int a1, int a2, int a3);
void __cdecl sub_10004730(int a1, _BYTE *a2);
int __cdecl sub_10004760(int a1, int a2);
int sub_10004780(void); // weak
int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD); // weak
int j_HWM_pvg_hsdb_get_lrus_online(void); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
int sub_100047D0(void); // weak
unsigned int __cdecl sub_100047E0(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_10004990@<eax>(int a1@<esi>);
int __cdecl sub_10004A40(int a1, unsigned __int64 a2);
// int __usercall sub_10004AF0@<eax>(int a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_10004B80(int a1, void *a2, int a3, int a4, int a5);
void __cdecl sub_10004CD0(__int16 a1, _BYTE *a2);
// char __usercall sub_10004D00@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3);
int sub_10004D50();
int sub_10004DF0();
_DWORD *__cdecl sub_10004E50(_DWORD *a1);
int __cdecl sub_10004E60(int *a1, int a2);
_DWORD *__cdecl sub_10004E90(_DWORD *a1, int a2);
char __cdecl sub_10004EA0(int a1, _WORD *a2, int a3);
bool __cdecl sub_10004ED0(char *a1, int *a2, _DWORD *a3);
char __cdecl sub_10004F20(int a1, char *a2, int a3);
int __cdecl sub_10004FD0(int a1);
int sub_10005050();
bool __thiscall sub_10005060(void *this);
int sub_10005130();
char __cdecl sub_10005160(int a1);
int __cdecl sub_10005180(int, char *); // idb
char __thiscall sub_100051E0(void *this);
char __thiscall sub_10005200(void *this);
char __thiscall sub_10005220(void *this);
char __thiscall sub_10005240(void *this);
char __thiscall sub_10005260(void *this);
bool sub_10005280();
char __thiscall sub_10005300(void *this);
char sub_10005320();
char __cdecl sub_10005340(char a1);
char __cdecl sub_10005380(char a1);
signed int __cdecl sub_100053F0(char a1);
char __cdecl sub_10005470(char a1);
char __cdecl sub_100054E0(char a1);
char __cdecl sub_10005590(int a1);
char __thiscall sub_10005690(void *this);
int __cdecl sub_100056A0(int *a1);
// char __usercall sub_100056D0@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_10005770(const char *a1);
char __cdecl sub_100057B0(void *a1);
signed int __cdecl sub_10005800(unsigned int a1, int a2);
char **sub_10005BA0();
int __cdecl j_nullsub_1(_DWORD); // weak
int __cdecl sub_10005BC0(int a1);
int __cdecl sub_10005BD0(int a1);
int sub_10005BE0(void); // weak
int __cdecl sub_10005C10(int a1, _BYTE *a2, int a3);
int __cdecl sub_10005C60(void *, size_t); // idb
int __cdecl sub_10005C90(char *, size_t, char *, va_list); // idb
int sub_10005CD0(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_10005D00(const char *a1, _BYTE *a2, int a3);
int __thiscall sub_10005D40(void *this);
int __cdecl sub_10005D60(unsigned __int16 a1);
char *__cdecl sub_10005D80(unsigned __int16 a1);
char __cdecl sub_10005DC0(char a1);
__int16 __cdecl sub_10005DF0(int a1, int a2, int a3);
char __thiscall sub_10005E70(void *this);
char __cdecl sub_10005F00(int a1, char a2);
char __cdecl sub_10005FC0(char a1, char a2);
char __cdecl sub_10006010(char a1);
char __cdecl sub_10006040(char a1);
int __cdecl sub_10006080(char a1);
int __cdecl sub_100060E0(char *, char *); // idb
// void *__usercall sub_10006120@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>);
signed int sub_10006170();
_DWORD *sub_10007F70();
int sub_10007F80();
void sub_10007FA0();
int sub_10007FB0();
int __cdecl sub_10007FE0(char a1);
signed int sub_10008000();
// signed int __usercall sub_10008050@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_100080F0@<eax>(char a1@<al>);
// int __usercall sub_10008110@<eax>(char a1@<al>);
// signed __int16 __usercall sub_10008130@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_10008370(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_100084F0(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10008650(int a1, int a2, void *a3, char a4, __int16 a5, char a6);
char __cdecl sub_10008790(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10008870(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_10008AF0(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_10008B20(char a1, int a2, void *a3);
char __cdecl sub_10008B50(char a1, int a2, void *a3, int a4);
int __cdecl sub_10008B80(int a1, int a2);
signed int sub_10008BA0();
int sub_10008BC0();
char __cdecl sub_10008BD0(char *a1);
signed int __cdecl sub_10008C40(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_10008CA0(unsigned int a1, int a2, int a3);
int __cdecl sub_10008CC0(unsigned __int8 *a1, int a2);
int __cdecl sub_10008CF0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
signed int __fastcall sub_10008E80(unsigned __int8 a1);
char __cdecl sub_10008E90(unsigned __int8 a1);
__int16 __cdecl sub_10008EB0(unsigned __int8 a1);
char *__cdecl sub_10008ED0(char **a1);
int sub_10008F20();
int __cdecl sub_10008F60(_BYTE *a1, int a2);
signed int __cdecl sub_10008FD0(_BYTE *a1, int a2);
// int __usercall sub_10009070@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_100090A0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_10009270@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// int __usercall sub_100092D0@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_10009360@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_100093B0@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_10009410@<eax>(int a1@<eax>);
// int __usercall sub_10009430@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_10009470@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_10009500@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_10009650@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_100096F0@<eax>(int result@<eax>);
char *__cdecl sub_10009730(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_100098E0@<eax>(int a1@<eax>);
// int __usercall sub_10009910@<eax>(int a1@<esi>);
void __cdecl sub_10009940(int (**a1)(void), char **a2, _DWORD *a3);
int sub_10009DB0();
void *sub_10009E00();
char *sub_10009E60();
char sub_10009E80();
char __cdecl sub_10009E90(int a1, int a2, unsigned int a3);
// int *__usercall sub_10009ED0@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_10009F20();
int __cdecl sub_10009F30(_DWORD *a1, int a2, int a3);
int __cdecl sub_10009FE0(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_1000A1F0@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_1000A2B0(char a1);
int *__cdecl sub_1000A350(_BYTE *a1);
// int __usercall sub_1000A410@<eax>(int a1@<eax>);
// signed int __usercall sub_1000A570@<eax>(int a1@<esi>);
int __cdecl sub_1000A5E0(int, int); // weak
char **sub_1000A8C0();
// int __usercall sub_1000A8D0@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_1000A9C0(char *a1);
int sub_1000AC00();
int __cdecl sub_1000ACE0(int a1, int a2, char a3);
int __cdecl sub_1000AD30(int a1);
int __cdecl sub_1000AD40(void *); // idb
int __cdecl sub_1000ADC0(int a1, int a2);
signed int __cdecl sub_1000ADF0(int a1, int a2, int a3);
char __cdecl sub_1000AE10(_DWORD *a1);
char __cdecl sub_1000AF20(int a1, unsigned int a2);
bool __cdecl sub_1000AF50(const void **a1, int a2);
bool __cdecl sub_1000AF80(const void **a1, int a2);
bool __cdecl sub_1000AFB0(const void **a1, int a2);
bool __cdecl sub_1000AFE0(const void **a1, int a2);
bool __cdecl sub_1000B010(const void **a1, int a2);
bool __cdecl sub_1000B040(int a1, int a2);
bool __cdecl sub_1000B080(int a1, int a2);
bool __cdecl sub_1000B0C0(const void **a1, int a2);
bool __cdecl sub_1000B0F0(const void **a1, int a2);
char __cdecl sub_1000B120(int a1, unsigned int a2);
bool __cdecl sub_1000B150(const void **a1, int a2);
bool __cdecl sub_1000B180(const void **a1, int a2);
bool __cdecl sub_1000B1B0(const void **a1, int a2);
bool __cdecl sub_1000B1E0(const void **a1, int a2);
bool __cdecl sub_1000B210(const void **a1, int a2);
bool __cdecl sub_1000B240(const void **a1, int a2);
bool __cdecl sub_1000B270(const void **a1, int a2);
bool __cdecl sub_1000B2A0(const void **a1, int a2);
bool __cdecl sub_1000B2D0(const void **a1, int a2);
bool __cdecl sub_1000B300(const void **a1, int a2);
int __cdecl sub_1000B330(int a1, int a2, int a3);
// void __cdecl __noreturn exit(int);
int __cdecl sub_1000B3A0(int a1, char a2);
int __cdecl sub_1000B3C0(int a1, int a2, int a3);
int __cdecl sub_1000B3F0(int a1, int a2, int a3, int a4);
int __cdecl sub_1000B420(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1000B460(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1000B4A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_1000B4F0(int a1);
char __cdecl sub_1000B520(int a1);
char __cdecl sub_1000B530(int a1, int a2);
signed int __cdecl sub_1000B6B0(int a1);
signed int __cdecl sub_1000B6F0(int a1, int a2, int a3);
char __cdecl sub_1000B790(int a1);
char __cdecl sub_1000B7F0(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1000B860(char *a1);
int __cdecl sub_1000B900(int a1, int a2, int a3);
bool __cdecl sub_1000B970(int a1, unsigned int a2, int a3);
char __cdecl sub_1000BA00(int a1, int a2, char a3, char a4);
char __cdecl sub_1000BAB0(int a1);
char __cdecl sub_1000BAC0(int a1, void (__cdecl *a2)(int));
int (__cdecl *__cdecl sub_1000BB40(int a1, const char *a2))(const char *);
signed int __cdecl sub_1000BB90(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1000BBE0(int a1, int a2, int a3, size_t a4, char *a5);
int sub_1000BD60();
const char *__cdecl sub_1000BD70(unsigned int a1);
int __cdecl sub_1000BD90(int a1, int a2, int a3, int a4);
int __cdecl sub_1000BE40(int a1);
int __cdecl sub_1000BE60(int a1);
char *sub_1000BE80(char *a1, ...);
// char *__usercall sub_1000BEC0@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_1000BEE0@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_1000C0C0();
int sub_1000C0E0();
int __cdecl sub_1000C100(int a1, int a2);
int __cdecl sub_1000C160(int a1);
int __cdecl sub_1000C170(int a1, int a2);
int __cdecl sub_1000C1D0(int a1);
bool __cdecl sub_1000C1E0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1000C320(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1000C6D0(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_1000CB20(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_1000CFE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1000D3A0(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_1000D7A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1000DB60(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_1000E0A0(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_1000E480(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1000E840(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1000EBE0(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_1000EFE0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1000F380(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_1000F960(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_1000FD50(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_100100F0();
// BOOL __usercall sub_10010120@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_10010290@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_10010500(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_10010800(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_100108B0(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
const char *__cdecl sub_100108F0(int a1, int a2);
char __cdecl sub_10010930(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_100116E0(int a1, int a2);
char **__cdecl sub_10011760(int a1);
int (**sub_100117A0())();
int (__cdecl *__cdecl sub_100117B0(const char *a1))(const char *);
const char *sub_100117D0();
__int64 sub_100117E0();
const char *sub_100117F0();
// int __usercall sub_10011800@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_10011850(int a1, int a2);
int sub_10011880(); // weak
// int __usercall sub_100119A0@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_10011D20(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_10012B40(int a1);
int sub_10012BB0();
char __thiscall sub_10012BE0(void *this);
// char __usercall sub_10012C50@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_10012C90@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_10012D30(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10012D70(char a1, char a2, void *a3);
char __cdecl sub_10012DD0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10012E10(char a1, char a2, void *a3);
char __cdecl sub_10012E40(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10012E80(char a1, char a2, void *a3);
char __cdecl sub_10012EC0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10012F00(char a1, char a2, void *a3);
char __cdecl sub_10012F50(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10012F90(char a1, char a2, void *a3);
char __cdecl sub_10012FD0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10013010(char a1, char a2, void *a3);
char __cdecl sub_10013050(char a1, void *a2);
char __cdecl sub_10013080(char a1, void *a2);
char __cdecl sub_100130B0(char a1, void *a2);
char __cdecl sub_100130E0(char a1, void *a2);
char __cdecl sub_10013110(char a1, void *a2);
char __cdecl sub_10013140(char a1, void *a2);
char __cdecl sub_10013170(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_100131B0(char a1, char a2, void *a3);
char __cdecl sub_10013200(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10013240(char a1, char a2, void *a3);
char __cdecl sub_10013270(char a1, void *a2);
char __cdecl sub_100132A0(char a1, void *a2);
char __cdecl sub_100132D0(char a1, void *a2);
char __cdecl sub_10013300(int a1, char a2, char a3, int a4, void *a5);
bool __cdecl sub_100136A0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10013710(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10013770(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_100137E0(char a1, _BYTE *a2);
char __thiscall sub_10013820(void *this);
char __cdecl sub_10013890(char a1, int a2);
char __cdecl sub_100138C0(char a1, int a2);
char __cdecl sub_100138F0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
int __cdecl sub_10013AC0(int a1);
char __cdecl sub_10013B00(char a1, void *a2);
unsigned __int8 __cdecl sub_10013B50(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_10013B90(char a1, _DWORD *a2);
char __cdecl sub_10013BD0(char a1);
char __cdecl sub_10013C00(char a1, void *a2);
int __cdecl sub_10013C80(char a1, _DWORD *a2);
void __cdecl sub_10013CD0(char a1, char a2);
char sub_10013D40();
signed int __cdecl sub_10013DC0(char a1, char a2);
int __cdecl sub_10013E20(char a1);
signed int __cdecl sub_10013E60(char a1, char a2, char a3);
int __cdecl sub_10013ED0(char a1);
int __cdecl sub_10013F10(char a1);
char __cdecl sub_10013F50(char a1, int a2);
char __cdecl sub_10013F70(char a1, int a2);
char __cdecl sub_10013FA0(char a1, int a2);
char __cdecl sub_10013FF0(char a1, int a2);
char __cdecl sub_10014020(char a1, int a2);
char __cdecl sub_10014040(int a1);
char __cdecl sub_10014060(char a1);
char sub_10014090();
BOOL __cdecl sub_10014130(int a1, int a2);
char __cdecl sub_10014150(int a1, char a2, int a3, int a4, int a5);
unsigned int __cdecl sub_10014190(char *a1);
int __cdecl sub_100141B0(unsigned __int8 *a1);
int __cdecl sub_100141D0(_BYTE *a1);
int __cdecl sub_100141F0(unsigned __int8 *a1);
unsigned int __cdecl sub_10014210(int a1, int a2);
unsigned int __cdecl sub_10014540(int a1, int a2);
unsigned int __cdecl sub_10014980(_BYTE *a1);
int __cdecl sub_100149A0(unsigned __int8 *a1);
int __cdecl sub_100149C0(unsigned __int8 *a1);
int __cdecl sub_100149E0(_BYTE *a1);
int __cdecl sub_10014A00(int a1);
// void __cdecl __noreturn exit_0(int);
int __cdecl sub_10014A50(unsigned __int8 *a1);
int __cdecl sub_10014A70(int a1);
unsigned int __cdecl sub_10014B00(int a1);
signed int __cdecl sub_10014B20(int a1);
unsigned int __cdecl sub_10014B70(int a1);
int __cdecl sub_10014BD0(_BYTE *a1);
unsigned int __cdecl sub_10014BF0(_BYTE *a1);
int __cdecl sub_10014C10(unsigned __int8 *a1);
int __cdecl sub_10014C30(_BYTE *a1);
signed int __cdecl sub_10014C50(_BYTE *a1, int a2);
int __cdecl sub_10014C80(_BYTE *a1, int a2);
int __cdecl sub_10014CC0(int a1, int a2);
int __cdecl sub_10014D50(int a1);
int __cdecl sub_10014D80(unsigned __int8 *a1);
unsigned int __cdecl sub_10014DA0(int a1);
int __cdecl sub_10014DD0(int a1);
int __cdecl sub_10014EC0(int a1);
signed int __cdecl sub_10014FD0(unsigned __int8 *a1, int a2);
signed int __cdecl sub_10015000(_BYTE *a1, int a2);
int __cdecl sub_10015030(unsigned __int8 *a1);
int __cdecl sub_10015090(int a1);
signed int __cdecl sub_100150A0(_BYTE *a1, int a2);
int __cdecl sub_100150D0(int a1, int a2);
unsigned int __cdecl sub_10015150(int a1);
unsigned int __cdecl sub_10015190(int a1);
int __cdecl sub_100151E0(int a1);
int __cdecl sub_10015210(int a1);
unsigned int __cdecl sub_10015240(int a1);
unsigned int __cdecl sub_10015270(int a1);
unsigned int __cdecl sub_10015290(int a1);
void __cdecl __noreturn sub_100152D0(int a1);
signed int __cdecl sub_10015440(int a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// signed int __usercall sub_100154A0@<eax>(int a1@<eax>, int a2@<edi>);
signed int __cdecl sub_10015570(int a1);
char __thiscall sub_10015580(void *this);
// _DWORD *__usercall sub_100155A0@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4);
int sub_100155D0(); // weak
int sub_10015630(); // weak
char __cdecl sub_10015680(int a1, int a2);
_DWORD *sub_10015780();
char __cdecl sub_10015810(int a1, int a2);
char __cdecl sub_10015930(int a1);
int __cdecl sub_10015940(int a1, unsigned int a2);
__int16 __cdecl sub_10015A30(int a1, unsigned int a2);
__int16 __cdecl sub_10015A80(unsigned int *a1, _WORD *a2, _WORD *a3);
unsigned int __cdecl sub_10015B00(unsigned int a1);
bool __cdecl sub_10015B20(int a1);
int __cdecl sub_10015BF0(int a1);
int __cdecl sub_10015C10(int a1, int a2);
signed int __cdecl sub_10015C50(int a1, void *a2, unsigned __int16 a3, __int16 a4);
int __cdecl sub_10015D10(int a1);
// int __usercall sub_10015D50@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_10015E00@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_10015FD0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_10015FE0@<eax>(int result@<eax>);
// char __usercall sub_10016000@<al>(int a1@<eax>);
// int __usercall sub_10016020@<eax>(int a1@<esi>, unsigned __int8 a2);
int __fastcall sub_10016060(int a1, int a2);
// int __usercall sub_10016080@<eax>(int a1@<esi>);
// signed int __usercall sub_100160C0@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_100162D0(int a1);
signed int __cdecl sub_10016540(unsigned int a1, int a2, int a3);
// int __usercall sub_100165E0@<eax>(int a1@<eax>);
// int __usercall sub_10016600@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_10016630@<eax>(int a1@<eax>, int a2@<ebx>);
// void __cdecl __noreturn exit_1(int);
// char __usercall sub_10016720@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_10016750@<eax>(int a1@<eax>);
signed int __cdecl sub_10016780(unsigned int a1);
signed int __cdecl sub_100167D0(int a1, int a2);
signed int __cdecl sub_100169C0(unsigned int a1, int a2, int a3);
signed int __cdecl sub_10016A20(unsigned int a1, int a2, int a3);
signed int __cdecl sub_10016BB0(_BYTE *a1, char a2, int a3);
int __cdecl sub_10016C00(int, float, float, int, int); // idb
unsigned int __cdecl sub_10016CF0(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_10016D40(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
unsigned int __cdecl sub_10016E00(void *a1, size_t a2, int a3);
int __cdecl sub_10016E60(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_10016EB0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_10016F50(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
int __cdecl sub_10017000(unsigned __int8 *a1);
unsigned int __cdecl sub_10017020(void *a1);
unsigned int __cdecl sub_10017040(void *a1);
unsigned int __cdecl sub_10017060(void *a1);
unsigned int __cdecl sub_10017080(void *a1);
unsigned int __cdecl sub_100170A0(void *a1);
unsigned int __cdecl sub_100170C0(void *a1);
int __cdecl sub_10017120(int a1);
char __cdecl sub_10017130(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_10017170(const char *a1, int a2);
// char *__usercall sub_100171E0@<eax>(char *result@<eax>);
void __cdecl sub_10017210(char *a1);
void __cdecl sub_100172D0(char *a1, char *a2);
void *__cdecl sub_10017330(int a1);
int __cdecl sub_100174C0(int a1, int a2);
// char __usercall sub_10017600@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_100176D0(_DWORD *a1, char *a2);
BOOL __cdecl sub_100177B0(unsigned int a1);
BOOL __cdecl sub_100177D0(int a1);
_DWORD __cdecl sub_100177F0(_DWORD); // weak
unsigned int __cdecl sub_10017800(int a1, char a2);
signed int __cdecl sub_10017860(void *a1, int a2, unsigned int a3);
int __cdecl sub_10017880(int a1, int a2, int a3);
char __cdecl sub_100178A0(const char *a1, const char *a2);
int __cdecl sub_100179E0(int a1, int a2, unsigned int a3);
int sub_10017A60();
void __cdecl sub_10017A70(int a1);
int __cdecl sub_10017AA0(int a1);
bool __cdecl sub_10017AC0(int a1);
void *__cdecl sub_10017AF0(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_10017B30@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_10017B50@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_10017B70(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_10017BA0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_10017C80(int a1, int a2, int a3);
// void *__usercall sub_10017D30@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_10017FB0(int a1, int a2);
char __cdecl sub_10018080(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_100180F0@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_10018450@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_10018560(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_100186F0(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_10018840@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_10018990(int a1, int a2);
signed int __cdecl sub_100189D0(int a1, int a2);
bool __cdecl sub_10018A30(signed int a1);
int sub_10018AA0();
char sub_10018DC0();
char sub_10018FE0();
char sub_100191E0();
char sub_10019360();
char sub_100194E0();
char sub_10019650();
char sub_10019750();
char sub_100198B0();
char sub_10019A10();
char sub_10019B70();
char sub_10019CE0();
char sub_10019E40();
char sub_10019FA0();
char sub_1001A1C0();
char sub_1001A320();
char sub_1001A480();
char sub_1001A5E0();
char sub_1001A750();
char sub_1001A8B0();
char sub_1001AA10();
char sub_1001AC30();
char sub_1001AE30();
char sub_1001AFB0();
char sub_1001B130();
char sub_1001B2A0();
char sub_1001B390();
char sub_1001B4F0();
char sub_1001B650();
char sub_1001B7B0();
char sub_1001B920();
char sub_1001BA80();
char sub_1001BBE0();
char sub_1001BDE0();
char sub_1001BF40();
char sub_1001C0A0();
char sub_1001C200();
char sub_1001C370();
char sub_1001C4D0();
char sub_1001C630();
char sub_1001CBD0();
char sub_1001CDE0();
char sub_1001CFD0();
char sub_1001D140();
char sub_1001D2B0();
char sub_1001D410();
char sub_1001D500();
char sub_1001D660();
char sub_1001D7C0();
char sub_1001D920();
char sub_1001DA90();
char sub_1001DBF0();
char sub_1001DD50();
char sub_1001DF50();
char sub_1001E0B0();
char sub_1001E210();
char sub_1001E370();
char sub_1001E4E0();
char sub_1001E640();
char sub_1001E7A0();
char sub_1001E9B0();
char sub_1001EBA0();
char sub_1001ED10();
char sub_1001EE80();
char sub_1001EFE0();
char sub_1001F0D0();
char sub_1001F230();
char sub_1001F390();
char sub_1001F4F0();
char sub_1001F660();
char sub_1001F7C0();
char sub_1001F920();
char sub_1001FB20();
char sub_1001FC80();
char sub_1001FDE0();
char sub_1001FF40();
char sub_100200B0();
char sub_10020210();
char **sub_10020370();
int __cdecl sub_10020380(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_100203A0@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_100203B0@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_100205E0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10020630(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10020680(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_100206D0(int a1))(int);
int __cdecl sub_10020750(int a1, int a2);
int (__cdecl *__cdecl sub_100207D0(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_10020820(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10020860(int a1, int a2, int a3))(int);
char __cdecl sub_100208C0(char a1);
int __cdecl sub_10020900(char a1);
bool __cdecl sub_10020950(void *a1);
char __cdecl sub_10020990(char a1);
char __cdecl sub_100209C0(char a1);
BOOL __cdecl sub_100209F0(unsigned __int8 a1);
// BOOL __usercall sub_10020A00@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_10020A30(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_10020BE0(unsigned __int8 a1, int a2);
bool __cdecl sub_10020C20(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
bool __cdecl sub_10020D10(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_10020DA0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
char __cdecl sub_10020E40(char a1);
char __cdecl sub_10020EC0(char a1, int a2);
// int __usercall sub_10021030@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_10021070@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_100210B0();
char __cdecl sub_100210C0(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_10021120(char a1, void *a2);
char __cdecl sub_10021240(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_100212C0(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
int __cdecl sub_10021470(int a1, int a2);
char __cdecl sub_10021490(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9);
signed int __cdecl sub_10021560(int (__cdecl *a1)(int));
char *__cdecl sub_10021590(unsigned __int8 a1);
// signed int __usercall sub_100215C0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10022670@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_100226D0@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_10023450@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_10023470(int a1, unsigned int a2);
// int __usercall sub_100234D0@<eax>(int result@<eax>);
// int __usercall sub_10023510@<eax>(int result@<eax>);
// unsigned int __usercall sub_10024C30@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_10024D30@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_10024DB0@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_10024E50@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_10024F10@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_10024F70@<eax>(char *a1@<edi>);
// int __usercall sub_10025030@<eax>(int a1@<ebx>);
char __cdecl sub_100250F0(char *a1, size_t a2, int a3);
char __cdecl sub_10025140(char *a1, unsigned int a2, int a3);
bool __cdecl sub_10025190(int a1, int a2);
// int __usercall sub_100251C0@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_100253D0@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_10025420(int a1, int a2);
signed int __cdecl sub_100254B0(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_100255E0(void *a1, int a2);
// BOOL __usercall sub_10025660@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10025700@<eax>(int result@<eax>);
unsigned int __fastcall sub_10025790(unsigned int a1, int a2);
// int __usercall sub_100257B0@<eax>(int result@<eax>);
// int __usercall sub_10025840@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_10025CC0@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_10025D70@<eax>(int a1@<edi>);
// int __usercall sub_10025DD0@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_10025FA0@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_10026020(int a1, int a2);
// unsigned int __usercall sub_10026090@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_10026240@<eax>(int a1@<esi>, int a2);
// int __usercall sub_10026310@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_100263C0@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_10026400@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_10026460@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10026540@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10026AE0@<eax>(int a1@<eax>);
// int __usercall sub_10026D20@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_10026DC0@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_10026FA0@<eax>(int a1@<edi>);
// int __usercall sub_100270E0@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_10027390(int a1, int a2);
// signed int __usercall sub_10027650@<eax>(int a1@<eax>);
// _WORD *__usercall sub_10027720@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_10027940(int a1, int a2);
signed int __cdecl sub_10027C50(int a1, int a2);
signed int __cdecl sub_10028060(int a1, int a2);
int __cdecl sub_100281D0(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_100282D0(int a1);
// signed int __usercall sub_100282F0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_10028790@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_100287E0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_10028800(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_10028BB0@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_10028CF0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_10028D40@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_10028DE0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_10028E00(int a1);
// int __usercall sub_10028E10@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_100294B0@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_10029E90@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_1002A1C0(int a1, int a2);
int __cdecl sub_1002A1E0(char *a1, char a2);
bool __cdecl sub_1002A250(int a1, void *a2);
char __cdecl sub_1002A310(int a1, bool *a2);
int __cdecl sub_1002A3D0(char a1);
int __cdecl sub_1002A3F0(int, void *); // idb
// int __usercall sub_1002A450@<eax>(char a1@<al>);
BOOL __cdecl sub_1002A480(char a1, int a2);
int __cdecl sub_1002A4B0(int, char, int, int, void *); // idb
char __cdecl sub_1002A4E0(void *a1);
BOOL __cdecl sub_1002A500(int a1);
char __cdecl sub_1002A520(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_1002A550(char a1, void *a2);
// signed int __usercall sub_1002A590@<eax>(char a1@<al>);
bool __cdecl sub_1002A5B0(char a1, void *a2);
bool __cdecl sub_1002A6A0(char a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_1002A6D0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_1002A770(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1002A7F0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1002A860(char a1, void *a2);
char __cdecl sub_1002A8E0(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1002A960(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1002A9E0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1002AA50(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
char __cdecl sub_1002AB60(char a1, void *a2);
bool __cdecl sub_1002AB80(unsigned __int8 a1, char *a2);
char __cdecl sub_1002ABC0(int a1, char a2, int a3, int a4, void *a5);
BOOL sub_1002AC00();
char __cdecl sub_1002AC60(int a1, char *a2);
BOOL __cdecl sub_1002AD50(int a1, int a2);
char __cdecl sub_1002AD70(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_1002ADB0(int a1, int a2);
BOOL __cdecl sub_1002AE60(int a1, int a2);
char __cdecl sub_1002AE80(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_1002AEC0(void *a1);
char __cdecl sub_1002AEE0(void *a1);
char __cdecl sub_1002B030(int a1, char a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_1002B1D0(char a1);
// __int16 __usercall sub_1002B210@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_1002B220(unsigned __int8 a1, char *a2);
char __cdecl sub_1002B2F0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_1002B370(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_1002B480(char a1);
char __cdecl sub_1002B4D0(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_1002B600(char a1, int a2);
bool __cdecl sub_1002B680(void *a1);
char __cdecl sub_1002B6D0(char a1, int a2);
// __int16 __usercall sub_1002B7B0@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_1002B7C0(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_1002B850(unsigned __int8 a1, char a2);
bool __cdecl sub_1002B910(__int16 a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_1002BA10(char a1);
char __cdecl sub_1002BA50(char a1);
int __cdecl sub_1002BA70(char a1, char a2);
// bool __usercall sub_1002BB20@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_1002BB50@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_1002BBF0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1002BC70(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1002BCF0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1002BD70(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1002BDF0(char a1);
// int __cdecl FNT_get_fnt_hdr(_DWORD); weak
// int TXT_get_static_string(void); weak
int __cdecl sub_1002BE90(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
unsigned int __cdecl sub_1002BFA0(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
int __cdecl sub_1002C080(int a1);
int __cdecl sub_1002C3D0(int a1);
unsigned int __cdecl sub_1002C5B0(int a1);
int __cdecl sub_1002CAE0(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
_WORD *__cdecl sub_1002CB40(int a1);
int __cdecl sub_1002CBA0(int a1, int a2, char a3);
int __cdecl sub_1002CC90(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
int __cdecl sub_1002CD80(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
int __cdecl sub_1002CFE0(int a1, _BYTE *a2, int a3);
char __cdecl sub_1002D020(char a1, char a2);
int __cdecl sub_1002D040(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7);
bool __cdecl sub_1002D880(_BYTE *a1);
bool __cdecl sub_1002D920(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5);
int __cdecl sub_1002DA30(int a1, _BYTE *a2, int a3);
int __cdecl sub_1002DB20(int a1, __int16 a2, __int16 a3, char a4);
void sub_1002E070();
int __cdecl sub_1002E080(int a1);
int __cdecl sub_1002E250(int a1, signed int a2, signed int a3);
char __cdecl sub_1002E720(int a1);
char *__cdecl sub_1002E890(int a1);
int __cdecl sub_1002E9E0(int a1, int a2);
unsigned int __cdecl sub_1002EB00(int a1, int a2);
int __cdecl sub_1002ECA0(int a1, int a2, int a3);
int __cdecl sub_1002ED20(int a1, int a2, int a3);
char __cdecl sub_1002EDA0(int a1, signed int a2, int a3, int a4);
int __cdecl sub_1002EEB0(int a1, signed int a2, signed int a3);
int __cdecl sub_1002EFA0(int a1, signed int a2, int a3, int a4);
int __cdecl sub_1002F0A0(int a1, int a2);
char *__cdecl sub_1002F1D0(int a1, signed int a2, int a3, int *a4);
char *__cdecl sub_1002F310(int a1, signed int a2, int a3, int *a4);
int __cdecl sub_1002F560(int a1, signed int a2, int a3);
int __cdecl sub_1002F6A0(int a1, signed int a2, int a3);
int __cdecl sub_1002F7E0(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_1002F800(unsigned int *a1, signed int a2, unsigned int a3);
// int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int gdi_pvg_init(void); weak
// int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_create_window(_DWORD); weak
// int SYS_exit_krnl(void); weak
// int SYS_enter_krnl(void); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_set_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_close(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_cnt(_DWORD, _DWORD, _DWORD, _DWORD); weak
__int32 __cdecl j__atol(const char *);
// char *__cdecl strstr(const char *, const char *);
// char *__cdecl strncpy(char *, const char *, size_t);
// char *__cdecl strrchr(const char *, int);
// void *__cdecl memset(void *, int, size_t);
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
// char *__cdecl strchr(const char *, int);
// int sprintf(char *, const char *, ...);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isprint(int);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_10031221(int a1, int a2, char a3);
// char *__cdecl strncat(char *, const char *, size_t);
// int _snprintf(char *, size_t, const char *, ...);
// double __cdecl floor(double);
// char *__cdecl strpbrk(const char *, const char *);
// int __cdecl strncmp(const char *, const char *, size_t);
signed int __cdecl sub_10032ECD(_DWORD *a1);
signed int __cdecl sub_10032F04(_DWORD *a1);
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_10033B4A();
int (*sub_10033FF7())(void);
void __cdecl sub_1003401B(); // idb
int __cdecl sub_10035AAE(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_10035BD8(int, FILE *); // idb
// int __cdecl isleadbyte(int);
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_1003774A(FILE *, int, struct localeinfo_struct *, int); // idb
int __cdecl sub_1003A82C(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_1003A8D2(int, int, struct localeinfo_struct *); // idb
void sub_1003AD42();
int sub_1003B2D2();
int __cdecl sub_1003B48F(int a1);
int __cdecl sub_1003B499(int a1);
int __cdecl sub_1003B4A3(int a1);
int __cdecl sub_1003B582(int a1);
// int _get_sse2_info(void); weak
int sub_1003C747();
DWORD __cdecl sub_1003CA29(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_1003CBC5(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_1003D1E7(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_1003D307(signed int a1);
void **sub_1003D365();
signed int sub_1003D36B();
// int __cdecl _fileno(FILE *);
int __cdecl sub_1003DEBC(FILE *); // idb
int __cdecl sub_1003DFDC(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
int sub_1003E224();
signed int __cdecl sub_1003EA09(int a1, int a2);
signed int __cdecl sub_1003EF4B(int a1, int a2);
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_10040844(int a1, int a2, int a3);
signed int __cdecl sub_10040D17(signed int a1);
signed int __cdecl sub_10040D98(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_10040EA9(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_100411AA();
// int __cdecl _read(int, void *, unsigned int);
signed int __cdecl sub_10041CC1(signed int a1);
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_10041EA0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_10041EF0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
int __cdecl sub_10041F60(int a1, int a2);
// int __usercall sub_10041FC0@<eax>(const char **a1@<esi>);
// int __usercall sub_100422C0@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_100422E0(int a1);
int __cdecl sub_100423B0(int a1);
int __cdecl sub_100423F0(int a1);
int __cdecl sub_10042430(int a1);
int __cdecl sub_10042470(int a1);
int __cdecl sub_100424B0(int a1, int a2, int a3, int a4);
int __cdecl sub_10042520(int a1, int a2, int a3);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_10044348; // weak
_UNKNOWN unk_10044350; // weak
_UNKNOWN unk_10044370; // weak
__int16 word_100455E8[] = { 16399 }; // weak
__int16 word_100455EA[] = { 32783 }; // weak
_UNKNOWN unk_1004563C; // weak
_UNKNOWN unk_10045648; // weak
_UNKNOWN unk_10045660; // weak
_UNKNOWN unk_1004569C; // weak
_UNKNOWN unk_100456D8; // weak
_UNKNOWN unk_100456DC; // weak
_UNKNOWN unk_100457C0; // weak
void *off_1004692C = &unk_100C2830; // weak
int (__cdecl *off_100473E4)(int) = &sub_10003440; // weak
char aSkey[5] = "SKEY"; // weak
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
_UNKNOWN unk_10049AD1; // weak
int dword_1004B7B0[] = { 6103 }; // weak
int dword_1004B7B4[] = { 8000 }; // weak
_UNKNOWN unk_1004C99C; // weak
_UNKNOWN unk_1004CF35; // weak
_UNKNOWN unk_1004CF6E; // weak
_UNKNOWN unk_1004E02C; // weak
_UNKNOWN unk_1004E0D8; // weak
void *off_1004E0DC = &unk_1004E04C; // weak
_UNKNOWN unk_1004E8E0; // weak
__int16 word_1004E8E4[] = { 2 }; // weak
char *off_1004F298[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_1004F108 }; // weak
_UNKNOWN unk_1004F2AC; // weak
char byte_100509C0[] = { '\0' }; // weak
_UNKNOWN unk_10051130; // weak
int dword_1005790C[] = { 88 }; // weak
__int16 word_10057DBC[] = { 836 }; // weak
char *off_10057DDC = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_10057DF0 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_10057E04 = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_10057E18 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_10057E2C = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_10057E40 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
int (*off_10058420[4])() = { &sub_10008BB0, &sub_10008BA0, &sub_10008B90, &sub_10008BA0 }; // weak
__int16 word_1006DE28[] = { 43 }; // weak
char byte_1006DE2C[] = { '\x06' }; // weak
_UNKNOWN unk_1006E438; // weak
char *off_1006E5DC[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_1006E5F0 }; // weak
char *off_1006E780 = "true"; // weak
char byte_1006E784[] = { '\x01' }; // weak
char *off_1006E7E8 = "failure listener"; // weak
_UNKNOWN unk_1006EF90; // weak
char *off_1006F19C[7] = { "FAIL", "PASS", "normal", "robust", "EQ", "NE", "LE" }; // weak
char *off_1006F1A4[5] = { "normal", "robust", "EQ", "NE", "LE" }; // weak
char *off_1006F1AC[3] = { "EQ", "NE", "LE" }; // weak
char *off_1006F1C8[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1006F1D4[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_1006F1DC[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_1006F490; // weak
_UNKNOWN unk_1006F4D4; // weak
char *off_1006F898 = "printf_listener"; // weak
__int16 word_100704CC = 2573; // weak
int (*off_10070588[2])() = { &sub_10020370, &sub_10005BA0 }; // weak
char *off_10070638 = "gate_listener"; // weak
int dword_10072A78[] = { 1600085855 }; // weak
_UNKNOWN unk_10073938; // weak
char byte_10073939[] = { '\0' }; // weak
_UNKNOWN unk_10074708; // weak
_UNKNOWN unk_10074720; // weak
_UNKNOWN unk_10074768; // weak
int dword_1007476C[] = { 6767 }; // weak
_UNKNOWN unk_10074778; // weak
_UNKNOWN unk_10074790; // weak
_UNKNOWN unk_100747A8; // weak
int dword_100747AC[] = { 6769 }; // weak
_UNKNOWN unk_100747C0; // weak
int dword_100747C4[] = { 6093 }; // weak
_UNKNOWN unk_100787C8; // weak
int dword_100787CC[] = { 1312 }; // weak
char aMessageQueueTi[] = "message queue timed out sending from: %d to %d"; // idb
_UNKNOWN unk_1007BC28; // weak
_UNKNOWN unk_1007BC4C; // weak
_UNKNOWN unk_1007BDF0; // weak
char off_1007CA20[] = { '', '', '\x06', '\x10' }; // idb
int dword_1007CA3C = 1; // idb
char byte_1007CA58[] = { '\x01' }; // weak
char *off_1007CA5C[3] = { "1", "2", "fail_normal_1" }; // weak
char *off_1007CA60[2] = { "2", "fail_normal_1" }; // weak
char off_1007CA64[8] = { '\b', '', '\a', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_1007CAE8[] = { '\0' }; // weak
char byte_1007CAE9[] = { '\0' }; // weak
int dword_1007CAEC[] = { 0 }; // weak
char *off_1007CAF0 = "0, 0, 0"; // weak
double dbl_1007CD58[] = {  0.0 }; // weak
double dbl_1007CD60[] = {  0.0 }; // weak
double dbl_1007CD68[] = {  0.0 }; // weak
int dword_1007CD70[] = { 0 }; // weak
char off_1007CD74[32] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_1007D978[] = {  0.0 }; // weak
float flt_1007D97C[] = {  0.0 }; // weak
float flt_1007D980[] = {  0.0 }; // weak
int dword_1007D984[] = { 0 }; // weak
char off_1007D988[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char *off_1007E10C[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_10092D68
}; // weak
int dword_1007E120[] = { 0 }; // weak
int dword_1007E124[] = { 0 }; // weak
int dword_1007E128[] = { 0 }; // weak
int dword_1007E12C[] = { 0 }; // weak
char *off_1007E130 = "0, 0, 0"; // weak
__int16 word_1007E8B8[] = { 0 }; // weak
__int16 word_1007E8BA[] = { 0 }; // weak
__int16 word_1007E8BC[] = { 0 }; // weak
int dword_1007E8C0[] = { 0 }; // weak
char *off_1007E8C4 = "0, 0, 0"; // weak
int dword_1007EEC8[] = { 0 }; // weak
int dword_1007EECC[] = { 0 }; // weak
int dword_1007EED0[] = { 0 }; // weak
int dword_1007EED4[] = { 0 }; // weak
char off_1007EED8[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1007F660[] = { 0 }; // weak
int dword_1007F664[] = { 0 }; // weak
int dword_1007F668[] = { 0 }; // weak
int dword_1007F66C[] = { 0 }; // weak
int dword_1007F670[] = { 0 }; // weak
int dword_1007F674[] = { 0 }; // weak
int dword_1007F678[] = { 0 }; // weak
char off_1007F67C[32] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10080280[] = { '\0' }; // weak
char byte_10080281[] = { '\0' }; // weak
char byte_10080282[] = { '\0' }; // weak
int dword_10080284[] = { 0 }; // weak
char *off_10080288 = "0, 0, 0"; // weak
int dword_10080710[] = { 0 }; // weak
int dword_10080714[] = { 0 }; // weak
int dword_10080718[] = { 0 }; // weak
int dword_1008071C[] = { 0 }; // weak
char *off_10080720 = "0, 0, 0"; // weak
int dword_10080EA8[] = { 0 }; // weak
int dword_10080EAC[] = { 0 }; // weak
int dword_10080EB0[] = { 0 }; // weak
int dword_10080EB4[] = { 0 }; // weak
char off_10080EB8[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_10081218[] = { 0 }; // weak
__int16 word_1008121A[] = { 0 }; // weak
__int16 word_1008121C[] = { 0 }; // weak
int dword_10081220[] = { 0 }; // weak
char *off_10081224 = "0, 0, 0"; // weak
int dword_100814D8[] = { 0 }; // weak
int dword_100814DC[] = { 0 }; // weak
int dword_100814E0[] = { 0 }; // weak
int dword_100814E4[] = { 0 }; // weak
char off_100814E8[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10081848[] = { 0 }; // weak
int dword_1008184C[] = { 0 }; // weak
int dword_10081850[] = { 0 }; // weak
int dword_10081854[] = { 0 }; // weak
int dword_10081858[] = { 0 }; // weak
int dword_1008185C[] = { 0 }; // weak
int dword_10081860[] = { 0 }; // weak
char *off_10081864 = "0, 0, 0"; // weak
char byte_10081DC8[] = { '\0' }; // weak
char byte_10081DC9[] = { '\0' }; // weak
char byte_10081DCA[] = { '\0' }; // weak
int dword_10081DCC[] = { 0 }; // weak
char *off_10081DD0 = "0, 0, 0"; // weak
int dword_10081FD8[] = { 0 }; // weak
int dword_10081FDC[] = { 0 }; // weak
int dword_10081FE0[] = { 0 }; // weak
int dword_10081FE4[] = { 0 }; // weak
char off_10081FE8[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10082348[] = { '\x01' }; // weak
char *off_1008234C[3] = { "1", "2", "fail_robust_1" }; // weak
char *off_10082350[2] = { "2", "fail_robust_1" }; // weak
char off_10082354[8] = { '', '', '\a', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100823D8[] = { '\0' }; // weak
char byte_100823D9[] = { '\0' }; // weak
int dword_100823DC[] = { 0 }; // weak
char *off_100823E0 = "0, 0, 0"; // weak
double dbl_10082648[] = {  0.0 }; // weak
double dbl_10082650[] = {  0.0 }; // weak
double dbl_10082658[] = {  0.0 }; // weak
int dword_10082660[] = { 0 }; // weak
char *off_10082664 = "0, 0, 0"; // weak
float flt_10083268[] = {  0.0 }; // weak
float flt_1008326C[] = {  0.0 }; // weak
float flt_10083270[] = {  0.0 }; // weak
int dword_10083274[] = { 0 }; // weak
char off_10083278[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10083A00[] = { 0 }; // weak
int dword_10083A04[] = { 0 }; // weak
int dword_10083A08[] = { 0 }; // weak
int dword_10083A0C[] = { 0 }; // weak
char *off_10083A10 = "0, 0, 0"; // weak
__int16 word_10084198[] = { 0 }; // weak
__int16 word_1008419A[] = { 0 }; // weak
__int16 word_1008419C[] = { 0 }; // weak
int dword_100841A0[] = { 0 }; // weak
char *off_100841A4 = "0, 0, 0"; // weak
int dword_100847A8[] = { 0 }; // weak
int dword_100847AC[] = { 0 }; // weak
int dword_100847B0[] = { 0 }; // weak
int dword_100847B4[] = { 0 }; // weak
char off_100847B8[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10084F40[] = { 0 }; // weak
int dword_10084F44[] = { 0 }; // weak
int dword_10084F48[] = { 0 }; // weak
int dword_10084F4C[] = { 0 }; // weak
int dword_10084F50[] = { 0 }; // weak
int dword_10084F54[] = { 0 }; // weak
int dword_10084F58[] = { 0 }; // weak
char off_10084F5C[32] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10085B60[] = { '\0' }; // weak
char byte_10085B61[] = { '\0' }; // weak
char byte_10085B62[] = { '\0' }; // weak
int dword_10085B64[] = { 0 }; // weak
char *off_10085B68 = "0, 0, 0"; // weak
int dword_10085FF0[] = { 0 }; // weak
int dword_10085FF4[] = { 0 }; // weak
int dword_10085FF8[] = { 0 }; // weak
int dword_10085FFC[] = { 0 }; // weak
char *off_10086000 = "0, 0, 0"; // weak
int dword_10086788[] = { 0 }; // weak
int dword_1008678C[] = { 0 }; // weak
int dword_10086790[] = { 0 }; // weak
int dword_10086794[] = { 0 }; // weak
char off_10086798[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_10086AF8[] = { 0 }; // weak
__int16 word_10086AFA[] = { 0 }; // weak
__int16 word_10086AFC[] = { 0 }; // weak
int dword_10086B00[] = { 0 }; // weak
char *off_10086B04 = "0, 0, 0"; // weak
int dword_10086DB8[] = { 0 }; // weak
int dword_10086DBC[] = { 0 }; // weak
int dword_10086DC0[] = { 0 }; // weak
int dword_10086DC4[] = { 0 }; // weak
char off_10086DC8[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10087128[] = { 0 }; // weak
int dword_1008712C[] = { 0 }; // weak
int dword_10087130[] = { 0 }; // weak
int dword_10087134[] = { 0 }; // weak
int dword_10087138[] = { 0 }; // weak
int dword_1008713C[] = { 0 }; // weak
int dword_10087140[] = { 0 }; // weak
char *off_10087144 = "0, 0, 0"; // weak
char byte_100876A8[] = { '\0' }; // weak
char byte_100876A9[] = { '\0' }; // weak
char byte_100876AA[] = { '\0' }; // weak
int dword_100876AC[] = { 0 }; // weak
char *off_100876B0 = "0, 0, 0"; // weak
int dword_100878B8[] = { 0 }; // weak
int dword_100878BC[] = { 0 }; // weak
int dword_100878C0[] = { 0 }; // weak
int dword_100878C4[] = { 0 }; // weak
char off_100878C8[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10087C28[] = { '\x01' }; // weak
char *off_10087C2C[3] = { "1", "1", "pass_normal_1" }; // weak
char *off_10087C30[2] = { "1", "pass_normal_1" }; // weak
char off_10087C34[8] = { '', '', '\a', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_10087C78[] = { '\0' }; // weak
char byte_10087C79[] = { '\0' }; // weak
int dword_10087C7C[] = { 0 }; // weak
char *off_10087C80 = "0, 0, 0"; // weak
double dbl_10087EE8[] = {  0.0 }; // weak
double dbl_10087EF0[] = {  0.0 }; // weak
double dbl_10087EF8[] = {  0.0 }; // weak
int dword_10087F00[] = { 0 }; // weak
char *off_10087F04 = "0, 0, 0"; // weak
float flt_10088B08[] = {  0.0 }; // weak
float flt_10088B0C[] = {  0.0 }; // weak
float flt_10088B10[] = {  0.0 }; // weak
int dword_10088B14[] = { 0 }; // weak
char off_10088B18[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100892A0[] = { 0 }; // weak
int dword_100892A4[] = { 0 }; // weak
int dword_100892A8[] = { 0 }; // weak
int dword_100892AC[] = { 0 }; // weak
char *off_100892B0 = "0, 0, 0"; // weak
__int16 word_10089A38[] = { 0 }; // weak
__int16 word_10089A3A[] = { 0 }; // weak
__int16 word_10089A3C[] = { 0 }; // weak
int dword_10089A40[] = { 0 }; // weak
char *off_10089A44 = "0, 0, 0"; // weak
int dword_1008A048[] = { 0 }; // weak
int dword_1008A04C[] = { 0 }; // weak
int dword_1008A050[] = { 0 }; // weak
int dword_1008A054[] = { 0 }; // weak
char off_1008A058[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1008A7E0[] = { 0 }; // weak
int dword_1008A7E4[] = { 0 }; // weak
int dword_1008A7E8[] = { 0 }; // weak
int dword_1008A7EC[] = { 0 }; // weak
int dword_1008A7F0[] = { 0 }; // weak
int dword_1008A7F4[] = { 0 }; // weak
int dword_1008A7F8[] = { 0 }; // weak
char off_1008A7FC[32] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1008B400[] = { '\0' }; // weak
char byte_1008B401[] = { '\0' }; // weak
char byte_1008B402[] = { '\0' }; // weak
int dword_1008B404[] = { 0 }; // weak
char *off_1008B408 = "0, 0, 0"; // weak
int dword_1008B890[] = { 0 }; // weak
int dword_1008B894[] = { 0 }; // weak
int dword_1008B898[] = { 0 }; // weak
int dword_1008B89C[] = { 0 }; // weak
char *off_1008B8A0 = "0, 0, 0"; // weak
int dword_1008C028[] = { 0 }; // weak
int dword_1008C02C[] = { 0 }; // weak
int dword_1008C030[] = { 0 }; // weak
int dword_1008C034[] = { 0 }; // weak
char off_1008C038[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_1008C398[] = { 0 }; // weak
__int16 word_1008C39A[] = { 0 }; // weak
__int16 word_1008C39C[] = { 0 }; // weak
int dword_1008C3A0[] = { 0 }; // weak
char *off_1008C3A4 = "0, 0, 0"; // weak
int dword_1008C658[] = { 0 }; // weak
int dword_1008C65C[] = { 0 }; // weak
int dword_1008C660[] = { 0 }; // weak
int dword_1008C664[] = { 0 }; // weak
char off_1008C668[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1008C9C8[] = { 0 }; // weak
int dword_1008C9CC[] = { 0 }; // weak
int dword_1008C9D0[] = { 0 }; // weak
int dword_1008C9D4[] = { 0 }; // weak
int dword_1008C9D8[] = { 0 }; // weak
int dword_1008C9DC[] = { 0 }; // weak
int dword_1008C9E0[] = { 0 }; // weak
char *off_1008C9E4 = "0, 0, 0"; // weak
char byte_1008CF48[] = { '\0' }; // weak
char byte_1008CF49[] = { '\0' }; // weak
char byte_1008CF4A[] = { '\0' }; // weak
int dword_1008CF4C[] = { 0 }; // weak
char *off_1008CF50 = "0, 0, 0"; // weak
int dword_1008D158[] = { 0 }; // weak
int dword_1008D15C[] = { 0 }; // weak
int dword_1008D160[] = { 0 }; // weak
int dword_1008D164[] = { 0 }; // weak
char off_1008D168[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1008D4C8[] = { '\x01' }; // weak
char *off_1008D4CC[3] = { "1", "1", "pass_robust_1" }; // weak
char *off_1008D4D0[2] = { "1", "pass_robust_1" }; // weak
char off_1008D4D4[8] = { '', '', '\a', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_1008D518[] = { '\0' }; // weak
char byte_1008D519[] = { '\0' }; // weak
int dword_1008D51C[] = { 0 }; // weak
char *off_1008D520 = "0, 0, 0"; // weak
double dbl_1008D788[] = {  0.0 }; // weak
double dbl_1008D790[] = {  0.0 }; // weak
double dbl_1008D798[] = {  0.0 }; // weak
int dword_1008D7A0[] = { 0 }; // weak
char *off_1008D7A4 = "0, 0, 0"; // weak
float flt_1008E3A8[] = {  0.0 }; // weak
float flt_1008E3AC[] = {  0.0 }; // weak
float flt_1008E3B0[] = {  0.0 }; // weak
int dword_1008E3B4[] = { 0 }; // weak
char off_1008E3B8[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1008EB40[] = { 0 }; // weak
int dword_1008EB44[] = { 0 }; // weak
int dword_1008EB48[] = { 0 }; // weak
int dword_1008EB4C[] = { 0 }; // weak
char *off_1008EB50 = "0, 0, 0"; // weak
__int16 word_1008F2D8[] = { 0 }; // weak
__int16 word_1008F2DA[] = { 0 }; // weak
__int16 word_1008F2DC[] = { 0 }; // weak
int dword_1008F2E0[] = { 0 }; // weak
char *off_1008F2E4 = "0, 0, 0"; // weak
int dword_1008F8E8[] = { 0 }; // weak
int dword_1008F8EC[] = { 0 }; // weak
int dword_1008F8F0[] = { 0 }; // weak
int dword_1008F8F4[] = { 0 }; // weak
char off_1008F8F8[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10090080[] = { 0 }; // weak
int dword_10090084[] = { 0 }; // weak
int dword_10090088[] = { 0 }; // weak
int dword_1009008C[] = { 0 }; // weak
int dword_10090090[] = { 0 }; // weak
int dword_10090094[] = { 0 }; // weak
int dword_10090098[] = { 0 }; // weak
char off_1009009C[32] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10090CA0[] = { '\0' }; // weak
char byte_10090CA1[] = { '\0' }; // weak
char byte_10090CA2[] = { '\0' }; // weak
int dword_10090CA4[] = { 0 }; // weak
char *off_10090CA8 = "0, 0, 0"; // weak
int dword_10091130[] = { 0 }; // weak
int dword_10091134[] = { 0 }; // weak
int dword_10091138[] = { 0 }; // weak
int dword_1009113C[] = { 0 }; // weak
char *off_10091140 = "0, 0, 0"; // weak
int dword_100918C8[] = { 0 }; // weak
int dword_100918CC[] = { 0 }; // weak
int dword_100918D0[] = { 0 }; // weak
int dword_100918D4[] = { 0 }; // weak
char off_100918D8[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_10091C38[] = { 0 }; // weak
__int16 word_10091C3A[] = { 0 }; // weak
__int16 word_10091C3C[] = { 0 }; // weak
int dword_10091C40[] = { 0 }; // weak
char *off_10091C44 = "0, 0, 0"; // weak
int dword_10091EF8[] = { 0 }; // weak
int dword_10091EFC[] = { 0 }; // weak
int dword_10091F00[] = { 0 }; // weak
int dword_10091F04[] = { 0 }; // weak
char off_10091F08[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10092268[] = { 0 }; // weak
int dword_1009226C[] = { 0 }; // weak
int dword_10092270[] = { 0 }; // weak
int dword_10092274[] = { 0 }; // weak
int dword_10092278[] = { 0 }; // weak
int dword_1009227C[] = { 0 }; // weak
int dword_10092280[] = { 0 }; // weak
char *off_10092284 = "0, 0, 0"; // weak
char byte_100927E8[] = { '\0' }; // weak
char byte_100927E9[] = { '\0' }; // weak
char byte_100927EA[] = { '\0' }; // weak
int dword_100927EC[] = { 0 }; // weak
char *off_100927F0 = "0, 0, 0"; // weak
int dword_100929F8[] = { 0 }; // weak
int dword_100929FC[] = { 0 }; // weak
int dword_10092A00[] = { 0 }; // weak
int dword_10092A04[] = { 0 }; // weak
char off_10092A08[20] =
{
  'p',
  '',
  '\a',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_100939E8; // weak
int dword_10096BC4[] = { 0 }; // weak
_UNKNOWN off_10096BC8; // weak
_UNKNOWN unk_10096C58; // weak
_UNKNOWN unk_10096C5C; // weak
_UNKNOWN unk_10096C60; // weak
_UNKNOWN unk_10096C64; // weak
_UNKNOWN unk_10096C68; // weak
_UNKNOWN unk_10096C6C; // weak
_UNKNOWN unk_10096C70; // weak
_UNKNOWN unk_10096C74; // weak
_UNKNOWN unk_10099608; // weak
int dword_1009960C[] = { 0 }; // weak
__int16 word_1009B580[] = { 1565 }; // weak
__int16 word_1009B584[] = { 534 }; // weak
char byte_1009B588[] = { '\x04' }; // weak
__int16 word_1009B58A[] = { 6512 }; // weak
int dword_1009B5A0[] = { 118000 }; // weak
int dword_1009C510 = 64; // weak
__int16 word_1009C514[] = { 6782 }; // weak
__int16 word_1009C518[] = { 128 }; // weak
_UNKNOWN unk_1009C534; // weak
_DWORD dword_1009C538[10] = { 64, 24, 62, 18, 65, 27525120, 27394467, 27721729, 27591078, 0 }; // idb
char *off_1009E3D8 = "/shr_mem/iop_gtx_intf.shr"; // weak
_WORD dword_1009FDD0[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_100A01D0[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_100A05D0[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_100A09D0[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_100A0DD0[] = { 99 }; // weak
int dword_100A11D0[] = { 25344 }; // weak
int dword_100A15D0[] = { 6488064 }; // weak
int dword_100A19D0[] = { 1660944384 }; // weak
int dword_100A1DF8[] = { 128 }; // weak
int dword_100A1E08[] = { 0 }; // weak
int dword_100A1E18[] = { 0 }; // weak
char byte_100A1E89[] = { '\0' }; // weak
char byte_100A1E8A[] = { '\0' }; // weak
char byte_100A1E8B[] = { '\0' }; // weak
char byte_100A1E8C[] = { '\x10' }; // weak
int dword_100A1EA0[] = { 0 }; // weak
_UNKNOWN unk_100A1F18; // weak
_UNKNOWN unk_100A2398; // weak
char byte_100A2410[] = { '\0' }; // weak
char byte_100A2510[] = { '\0' }; // weak
char byte_100A2610[] = { '\0' }; // weak
int dword_100A2710[] = { 0 }; // weak
int dword_100A2788[] = { 0 }; // weak
int (__cdecl *off_100A2808)(int, int) = &sub_10028060; // weak
int dword_100A29F0[] = { 0 }; // weak
int dword_100A2A38[] = { 16 }; // weak
_UNKNOWN unk_100A2A88; // weak
_UNKNOWN unk_100A2B08; // weak
_UNKNOWN unk_100A2B88; // weak
_UNKNOWN unk_100A2C00; // weak
_UNKNOWN unk_100A2C78; // weak
_UNKNOWN unk_100A3C78; // weak
int (__cdecl *off_100A4A28[3])(char) = { &sub_10005470, &sub_10005380, &sub_10005340 }; // weak
_UNKNOWN unk_100A4F88; // weak
int dword_100A4F8C[] = { 6829 }; // weak
__int16 word_100A5FC2[] = { 233 }; // weak
int dword_100A5FC8[] = { 6201 }; // weak
__int16 word_100A8B78[] = { 114 }; // weak
_UNKNOWN unk_100A93B0; // weak
int dword_100A93B4[] = { 6006 }; // weak
__int16 word_100A94D8[] = { 551 }; // weak
_UNKNOWN unk_100ABAE0; // weak
int dword_100ABAE4[] = { 0 }; // weak
_UNKNOWN unk_100ABAF8; // weak
int dword_100ABAFC[] = { 0 }; // weak
_UNKNOWN unk_100ABB20; // weak
int dword_100ABB24[] = { 0 }; // weak
_UNKNOWN unk_100ABB50; // weak
int dword_100ABB54[] = { 0 }; // weak
char byte_100B0262[] = { '\x04' }; // weak
char byte_100B0267[] = { '\a' }; // weak
char byte_100B3B64[] = { '\0' }; // weak
char byte_100B3B70[16] =
{
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\xFF',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B3B80 = 0; // idb
int dword_100B4480[] = { 0 }; // weak
_UNKNOWN unk_100BE1E8; // weak
int dword_100BE1EC[] = { 3535 }; // weak
_UNKNOWN unk_100BE220; // weak
int dword_100BE224[] = { 6813 }; // weak
_UNKNOWN unk_100BE258; // weak
int dword_100BE25C[] = { 9036 }; // weak
_UNKNOWN unk_100BE290; // weak
int dword_100BE294[] = { 6763 }; // weak
_UNKNOWN unk_100BEAC0; // weak
_UNKNOWN unk_100BEAC8; // weak
int (*off_100C025C[3])() = { &_fptrap, &_fptrap, &_fptrap }; // weak
_UNKNOWN unk_100C0278; // weak
void *off_100C0D78 = &unk_101A4A80; // weak
_UNKNOWN unk_100C0D88; // weak
_UNKNOWN unk_100C0DE8; // weak
wchar_t *off_100C0FF8 = L"         (((((                  H"; // weak
int dword_100C120C = 1024; // weak
int dword_100C1210 = 4294966273; // weak
int dword_100C1214 = 53; // weak
int dword_100C1218 = 11; // weak
int dword_100C121C = 64; // weak
int dword_100C1220 = 1023; // weak
int dword_100C1224 = 128; // weak
int dword_100C1228 = 4294967169; // weak
int dword_100C122C = 24; // weak
int dword_100C1230 = 8; // weak
int dword_100C1234 = 32; // weak
int dword_100C1238 = 127; // weak
_UNKNOWN unk_100C1740; // weak
char byte_100C1744 = '\0'; // weak
int dword_100C1748 = 0; // weak
_UNKNOWN unk_100C1750; // weak
char byte_100C1820 = '\0'; // weak
char byte_100C1828 = '\0'; // idb
int dword_100C2828; // weak
_UNKNOWN unk_100C2830; // weak
char byte_100C90B0; // weak
char byte_100C90B1; // weak
int dword_100C90B4; // weak
int dword_100C90B8; // weak
int dword_100C90BC; // weak
int dword_100C90C0; // weak
int dword_100C90C4; // weak
int dword_100C90C8; // weak
_DWORD dword_100DB8B8[16]; // idb
int dword_100DB8F8[]; // weak
int dword_100DB938; // weak
int dword_100DB940[]; // weak
__int16 word_100DB980[]; // weak
char byte_100DB9A8[]; // weak
int dword_100DBAA8[]; // weak
int dword_100DBABC; // weak
int dword_100DBAC0; // weak
int dword_100DBAE8; // weak
_UNKNOWN unk_100DBAF0; // weak
char byte_100DBDC8[]; // weak
char byte_100DBDC9[]; // weak
_UNKNOWN unk_100DD030; // weak
_UNKNOWN unk_100DE9E0; // weak
_UNKNOWN unk_100DE9E8; // weak
_UNKNOWN unk_100DE9E9; // weak
_UNKNOWN unk_100DE9FF; // weak
_UNKNOWN unk_100DEA00; // weak
_UNKNOWN unk_100DEA01; // weak
_UNKNOWN unk_100DEA02; // weak
_UNKNOWN unk_100DEA04; // weak
_UNKNOWN unk_100DEA08; // weak
_UNKNOWN unk_100DEA0C; // weak
_UNKNOWN unk_100DEA2C; // weak
_UNKNOWN unk_100DEA4C; // weak
_UNKNOWN unk_100DEA6C; // weak
_UNKNOWN unk_100DEA8C; // weak
_UNKNOWN unk_100DEAAC; // weak
_UNKNOWN unk_100DEACC; // weak
_UNKNOWN unk_100DEAEC; // weak
_UNKNOWN unk_100DEB0C; // weak
_UNKNOWN unk_100DEB2C; // weak
_UNKNOWN unk_100DEB4C; // weak
_UNKNOWN unk_100DEB6C; // weak
_UNKNOWN unk_100DEB8C; // weak
_UNKNOWN unk_100DEBAC; // weak
_UNKNOWN unk_100DEBCC; // weak
_UNKNOWN unk_100DEBEC; // weak
_UNKNOWN unk_100DEC0C; // weak
_UNKNOWN unk_100DEC2C; // weak
_UNKNOWN unk_100DEC4C; // weak
_UNKNOWN unk_100DEC6C; // weak
_UNKNOWN unk_100DEC8C; // weak
_UNKNOWN unk_100DECAC; // weak
_UNKNOWN unk_100DECCC; // weak
_UNKNOWN unk_100DECEC; // weak
_UNKNOWN unk_100DED0C; // weak
_UNKNOWN unk_100DED2C; // weak
_UNKNOWN unk_100DED4C; // weak
_UNKNOWN unk_100DED6C; // weak
_UNKNOWN unk_100DED8C; // weak
_UNKNOWN unk_100DED90; // weak
_UNKNOWN unk_100DED94; // weak
_UNKNOWN unk_100DED98; // weak
_UNKNOWN unk_100DED9C; // weak
_UNKNOWN unk_100DEDA0; // weak
_UNKNOWN unk_100DEDA4; // weak
_UNKNOWN unk_100DEDC4; // weak
_UNKNOWN unk_100DEDE4; // weak
_UNKNOWN unk_100DEE04; // weak
_UNKNOWN unk_100DEE24; // weak
_UNKNOWN unk_100DEE44; // weak
_UNKNOWN unk_100DEE64; // weak
_UNKNOWN unk_100DEE84; // weak
_UNKNOWN unk_100DEEA4; // weak
_UNKNOWN unk_100DEEA5; // weak
_UNKNOWN unk_100DEEA6; // weak
_UNKNOWN unk_100DEEF8; // weak
_UNKNOWN unk_100DEF18; // weak
_UNKNOWN unk_100DEF38; // weak
_UNKNOWN unk_100DEF3C; // weak
_UNKNOWN unk_100DEF40; // weak
_UNKNOWN unk_100DEF44; // weak
_UNKNOWN unk_100DEF64; // weak
_UNKNOWN unk_100DEF84; // weak
_UNKNOWN unk_100DEFA4; // weak
_UNKNOWN unk_100DEFC4; // weak
_UNKNOWN unk_100DEFE4; // weak
_UNKNOWN unk_100DF004; // weak
_UNKNOWN unk_100DF024; // weak
_UNKNOWN unk_100DF044; // weak
_UNKNOWN unk_100DF064; // weak
_UNKNOWN unk_100DF0AC; // weak
_UNKNOWN unk_100DF0F4; // weak
_UNKNOWN unk_100DF13C; // weak
_UNKNOWN unk_100DF184; // weak
_UNKNOWN unk_100DF1CC; // weak
_UNKNOWN unk_100DF214; // weak
_UNKNOWN unk_100DF25C; // weak
_UNKNOWN unk_100DF2A4; // weak
_UNKNOWN unk_100DF2EC; // weak
_UNKNOWN unk_100DF334; // weak
_UNKNOWN unk_100DF37C; // weak
_UNKNOWN unk_100DF3C4; // weak
_UNKNOWN unk_100DF40C; // weak
_UNKNOWN unk_100DF454; // weak
_UNKNOWN unk_100DF49C; // weak
_UNKNOWN unk_100DF4E4; // weak
_UNKNOWN unk_100DF52C; // weak
_UNKNOWN unk_100DF574; // weak
_UNKNOWN unk_100DF5BC; // weak
_UNKNOWN unk_100DF604; // weak
_UNKNOWN unk_100DF64C; // weak
_UNKNOWN unk_100DF694; // weak
_UNKNOWN unk_100DF6DC; // weak
_UNKNOWN unk_100DF724; // weak
_UNKNOWN unk_100DF76C; // weak
_UNKNOWN unk_100DF7B4; // weak
_UNKNOWN unk_100DF7FC; // weak
_UNKNOWN unk_100DF844; // weak
_UNKNOWN unk_100DF88C; // weak
_UNKNOWN unk_100DF8D4; // weak
_UNKNOWN unk_100DF8EC; // weak
_UNKNOWN unk_100DF90C; // weak
_UNKNOWN unk_100DF92C; // weak
_UNKNOWN unk_100DF930; // weak
_UNKNOWN unk_100DF9D4; // weak
_UNKNOWN unk_100DFA78; // weak
_UNKNOWN unk_100DFB1C; // weak
_UNKNOWN unk_100DFBC0; // weak
_UNKNOWN unk_100DFC64; // weak
_UNKNOWN unk_100DFD08; // weak
_UNKNOWN unk_100DFDAC; // weak
_UNKNOWN unk_100DFE50; // weak
_UNKNOWN unk_100DFEF4; // weak
_UNKNOWN unk_100DFF98; // weak
_UNKNOWN unk_100E003C; // weak
_UNKNOWN unk_100E00E0; // weak
_UNKNOWN unk_100E0184; // weak
_UNKNOWN unk_100E0228; // weak
_UNKNOWN unk_100E02CC; // weak
_UNKNOWN unk_100E0370; // weak
_UNKNOWN unk_100E0414; // weak
_UNKNOWN unk_100E04B8; // weak
_UNKNOWN unk_100E055C; // weak
_UNKNOWN unk_100E0600; // weak
_UNKNOWN unk_100E06A4; // weak
_UNKNOWN unk_100E0748; // weak
_UNKNOWN unk_100E07EC; // weak
_UNKNOWN unk_100E0890; // weak
_UNKNOWN unk_100E0934; // weak
_UNKNOWN unk_100E09D8; // weak
_UNKNOWN unk_100E0A7C; // weak
_UNKNOWN unk_100E0B20; // weak
_UNKNOWN unk_100E0BC4; // weak
_UNKNOWN unk_100E0C68; // weak
_UNKNOWN unk_100E0D0C; // weak
_UNKNOWN unk_100E0DB0; // weak
_UNKNOWN unk_100E0E54; // weak
_UNKNOWN unk_100E0EF8; // weak
_UNKNOWN unk_100E0F9C; // weak
_UNKNOWN unk_100E1040; // weak
_UNKNOWN unk_100E10E4; // weak
_UNKNOWN unk_100E1188; // weak
_UNKNOWN unk_100E122C; // weak
_UNKNOWN unk_100E12D0; // weak
_UNKNOWN unk_100E1374; // weak
_UNKNOWN unk_100E1418; // weak
_UNKNOWN unk_100E14BC; // weak
_UNKNOWN unk_100E1560; // weak
_UNKNOWN unk_100E1604; // weak
_UNKNOWN unk_100E16A8; // weak
_UNKNOWN unk_100E174C; // weak
_UNKNOWN unk_100E17F0; // weak
_UNKNOWN unk_100E1894; // weak
_UNKNOWN unk_100E1938; // weak
_UNKNOWN unk_100E19DC; // weak
_UNKNOWN unk_100E1A80; // weak
_UNKNOWN unk_100E1B24; // weak
_UNKNOWN unk_100E1BC8; // weak
_UNKNOWN unk_100E1C6C; // weak
_UNKNOWN unk_100E1D10; // weak
_UNKNOWN unk_100E1DB4; // weak
_UNKNOWN unk_100E1E58; // weak
_UNKNOWN unk_100E1EFC; // weak
_UNKNOWN unk_100E1FA0; // weak
_UNKNOWN unk_100E2044; // weak
_UNKNOWN unk_100E20E8; // weak
_UNKNOWN unk_100E218C; // weak
_UNKNOWN unk_100E2230; // weak
_UNKNOWN unk_100E22D4; // weak
_UNKNOWN unk_100E2378; // weak
_UNKNOWN unk_100E241C; // weak
_UNKNOWN unk_100E24C0; // weak
_UNKNOWN unk_100E2564; // weak
_UNKNOWN unk_100E2608; // weak
_UNKNOWN unk_100E26AC; // weak
_UNKNOWN unk_100E2750; // weak
_UNKNOWN unk_100E27F4; // weak
_UNKNOWN unk_100E2898; // weak
_UNKNOWN unk_100E293C; // weak
_UNKNOWN unk_100E29E0; // weak
_UNKNOWN unk_100E2A84; // weak
_UNKNOWN unk_100E2B28; // weak
_UNKNOWN unk_100E2BCC; // weak
_UNKNOWN unk_100E2C70; // weak
_UNKNOWN unk_100E2D14; // weak
_UNKNOWN unk_100E2DB8; // weak
_UNKNOWN unk_100E2E5C; // weak
_UNKNOWN unk_100E2F00; // weak
_UNKNOWN unk_100E2FA4; // weak
_UNKNOWN unk_100E3048; // weak
_UNKNOWN unk_100E30EC; // weak
_UNKNOWN unk_100E3190; // weak
_UNKNOWN unk_100E3234; // weak
_UNKNOWN unk_100E32D8; // weak
_UNKNOWN unk_100E337C; // weak
_UNKNOWN unk_100E3420; // weak
_UNKNOWN unk_100E34C4; // weak
_UNKNOWN unk_100E3568; // weak
_UNKNOWN unk_100E360C; // weak
_UNKNOWN unk_100E36B0; // weak
_UNKNOWN unk_100E3754; // weak
_UNKNOWN unk_100E37F8; // weak
_UNKNOWN unk_100E389C; // weak
_UNKNOWN unk_100E3940; // weak
_UNKNOWN unk_100E3960; // weak
_UNKNOWN unk_100E3980; // weak
_UNKNOWN unk_100E39A0; // weak
_UNKNOWN unk_100E39C0; // weak
_UNKNOWN unk_100E39E8; // weak
_UNKNOWN unk_100E3A04; // weak
_UNKNOWN unk_100E3A20; // weak
_UNKNOWN unk_100E3A3C; // weak
_UNKNOWN unk_100E3A58; // weak
_UNKNOWN unk_100E3A74; // weak
_UNKNOWN unk_100E3A90; // weak
_UNKNOWN unk_100E3AAC; // weak
_UNKNOWN unk_100E3AC8; // weak
_UNKNOWN unk_100E3AE4; // weak
_UNKNOWN unk_100E3B00; // weak
_UNKNOWN unk_100E3B1C; // weak
_UNKNOWN unk_100E3B38; // weak
_UNKNOWN unk_100E3B54; // weak
_UNKNOWN unk_100E3B70; // weak
_UNKNOWN unk_100E3B8C; // weak
_UNKNOWN unk_100E3BA8; // weak
_UNKNOWN unk_100E3BC4; // weak
_UNKNOWN unk_100E3BE0; // weak
_UNKNOWN unk_100E3BFC; // weak
_UNKNOWN unk_100E3C18; // weak
_UNKNOWN unk_100E3C34; // weak
_UNKNOWN unk_100E3C50; // weak
_UNKNOWN unk_100E3C6C; // weak
_UNKNOWN unk_100E3C88; // weak
_UNKNOWN unk_100E3CA4; // weak
_UNKNOWN unk_100E3CC0; // weak
_UNKNOWN unk_100E3CDC; // weak
_UNKNOWN unk_100E3CF8; // weak
_UNKNOWN unk_100E3D14; // weak
_UNKNOWN unk_100E3D30; // weak
_UNKNOWN unk_100E3D4C; // weak
_UNKNOWN unk_100E3D68; // weak
_UNKNOWN unk_100E3D84; // weak
_UNKNOWN unk_100E3DA0; // weak
_UNKNOWN unk_100E3DBC; // weak
_UNKNOWN unk_100E3DD8; // weak
_UNKNOWN unk_100E3DF4; // weak
_UNKNOWN unk_100E3E10; // weak
_UNKNOWN unk_100E3E2C; // weak
_UNKNOWN unk_100E3E48; // weak
_UNKNOWN unk_100E3E64; // weak
_UNKNOWN unk_100E3E80; // weak
_UNKNOWN unk_100E3E9C; // weak
_UNKNOWN unk_100E3EB8; // weak
_UNKNOWN unk_100E3ED4; // weak
_UNKNOWN unk_100E3EF0; // weak
_UNKNOWN unk_100E3F0C; // weak
_UNKNOWN unk_100E3F28; // weak
_UNKNOWN unk_100E3F44; // weak
_UNKNOWN unk_100E3F60; // weak
_UNKNOWN unk_100E3F7C; // weak
_UNKNOWN unk_100E3F98; // weak
_UNKNOWN unk_100E3FB4; // weak
_UNKNOWN unk_100E3FD0; // weak
_UNKNOWN unk_100E3FEC; // weak
_UNKNOWN unk_100E4008; // weak
_UNKNOWN unk_100E4024; // weak
_UNKNOWN unk_100E4040; // weak
_UNKNOWN unk_100E405C; // weak
_UNKNOWN unk_100E4078; // weak
_UNKNOWN unk_100E4094; // weak
_UNKNOWN unk_100E40B0; // weak
_UNKNOWN unk_100E40CC; // weak
_UNKNOWN unk_100E40E8; // weak
_UNKNOWN unk_100E4104; // weak
_UNKNOWN unk_100E4120; // weak
_UNKNOWN unk_100E413C; // weak
_UNKNOWN unk_100E4158; // weak
_UNKNOWN unk_100E4174; // weak
_UNKNOWN unk_100E4190; // weak
_UNKNOWN unk_100E41AC; // weak
_UNKNOWN unk_100E41C8; // weak
_UNKNOWN unk_100E41E4; // weak
_UNKNOWN unk_100E4200; // weak
_UNKNOWN unk_100E421C; // weak
_UNKNOWN unk_100E4238; // weak
_UNKNOWN unk_100E4254; // weak
_UNKNOWN unk_100E4270; // weak
_UNKNOWN unk_100E428C; // weak
_UNKNOWN unk_100E42A8; // weak
_UNKNOWN unk_100E42C4; // weak
_UNKNOWN unk_100E42E0; // weak
_UNKNOWN unk_100E42FC; // weak
_UNKNOWN unk_100E4318; // weak
_UNKNOWN unk_100E4334; // weak
_UNKNOWN unk_100E4350; // weak
_UNKNOWN unk_100E436C; // weak
_UNKNOWN unk_100E4388; // weak
_UNKNOWN unk_100E43A4; // weak
_UNKNOWN unk_100E43C0; // weak
_UNKNOWN unk_100E43DC; // weak
_UNKNOWN unk_100E43F8; // weak
_UNKNOWN unk_100E4414; // weak
_UNKNOWN unk_100E4430; // weak
_UNKNOWN unk_100E444C; // weak
_UNKNOWN unk_100E4468; // weak
_UNKNOWN unk_100E4484; // weak
_UNKNOWN unk_100E44A0; // weak
_UNKNOWN unk_100E44BC; // weak
_UNKNOWN unk_100E44D8; // weak
_UNKNOWN unk_100E44DC; // weak
_UNKNOWN unk_100E44E0; // weak
_UNKNOWN unk_100E44E4; // weak
_UNKNOWN unk_100E44E8; // weak
_UNKNOWN unk_100E44EC; // weak
_UNKNOWN unk_100E44F0; // weak
_UNKNOWN unk_100E44F4; // weak
_UNKNOWN unk_100E44F8; // weak
_UNKNOWN unk_100E44FC; // weak
_UNKNOWN unk_100E4500; // weak
_UNKNOWN unk_100E4504; // weak
_UNKNOWN unk_100E4508; // weak
_UNKNOWN unk_100E450C; // weak
_UNKNOWN unk_100E4510; // weak
_UNKNOWN unk_100E4514; // weak
_UNKNOWN unk_100E4518; // weak
_UNKNOWN unk_100E451C; // weak
_UNKNOWN unk_100E4520; // weak
_UNKNOWN unk_100E4604; // weak
_UNKNOWN unk_100E57C4; // weak
_UNKNOWN unk_100E57C8; // weak
_UNKNOWN unk_100E57F0; // weak
_UNKNOWN unk_100E5818; // weak
_UNKNOWN unk_100E5858; // weak
_UNKNOWN unk_100E58D8; // weak
_UNKNOWN unk_100E58DC; // weak
_UNKNOWN unk_100E58E0; // weak
_UNKNOWN unk_100E58E2; // weak
_UNKNOWN unk_100E58E4; // weak
_UNKNOWN unk_100E58E5; // weak
_UNKNOWN unk_100E58E6; // weak
_UNKNOWN unk_100E58E8; // weak
_UNKNOWN unk_100E594C; // weak
_UNKNOWN unk_100E5954; // weak
_UNKNOWN unk_100E595C; // weak
_UNKNOWN unk_100E5964; // weak
_UNKNOWN unk_100E596C; // weak
_UNKNOWN unk_100E5974; // weak
_UNKNOWN unk_100E597C; // weak
_UNKNOWN unk_100E5984; // weak
_UNKNOWN unk_100E598C; // weak
_UNKNOWN unk_100E5994; // weak
_UNKNOWN unk_100E599C; // weak
_UNKNOWN unk_100E59A4; // weak
_UNKNOWN unk_100E59AC; // weak
_UNKNOWN unk_100E59B4; // weak
_UNKNOWN unk_100E59BC; // weak
_UNKNOWN unk_100E59C4; // weak
_UNKNOWN unk_100E59CC; // weak
_UNKNOWN unk_100E59D4; // weak
_UNKNOWN unk_100E59DC; // weak
_UNKNOWN unk_100E59E4; // weak
_UNKNOWN unk_100E59EC; // weak
_UNKNOWN unk_100E59F4; // weak
_UNKNOWN unk_100E59FC; // weak
_UNKNOWN unk_100E5A04; // weak
_UNKNOWN unk_100E5A0C; // weak
_UNKNOWN unk_100E5A14; // weak
_UNKNOWN unk_100E5A1C; // weak
_UNKNOWN unk_100E5A24; // weak
_UNKNOWN unk_100E5A2C; // weak
_UNKNOWN unk_100E5A34; // weak
_UNKNOWN unk_100E5A3C; // weak
_UNKNOWN unk_100E5A44; // weak
_UNKNOWN unk_100E5A4C; // weak
_UNKNOWN unk_100E5A54; // weak
_UNKNOWN unk_100E5A5C; // weak
_UNKNOWN unk_100E5A64; // weak
_UNKNOWN unk_100E5A6C; // weak
_UNKNOWN unk_100E5A74; // weak
_UNKNOWN unk_100E5A7C; // weak
_UNKNOWN unk_100E5A84; // weak
_UNKNOWN unk_100E5C6C; // weak
_UNKNOWN unk_100E5C7C; // weak
_UNKNOWN unk_100E5C8C; // weak
_UNKNOWN unk_100E5C9C; // weak
_UNKNOWN unk_100E5C9D; // weak
_UNKNOWN unk_100E5C9E; // weak
_UNKNOWN unk_100E5CA0; // weak
_UNKNOWN unk_100E5CA4; // weak
_UNKNOWN unk_100E5D4C; // weak
_UNKNOWN unk_100E5D50; // weak
_UNKNOWN unk_100E5D54; // weak
_UNKNOWN unk_100E5DA4; // weak
_UNKNOWN unk_100E5DA8; // weak
_UNKNOWN unk_100E5DAC; // weak
_UNKNOWN unk_100E5E9C; // weak
_UNKNOWN unk_100E5F8C; // weak
_UNKNOWN unk_100E5F90; // weak
_UNKNOWN unk_100E5F98; // weak
_UNKNOWN unk_100E5FA0; // weak
_UNKNOWN unk_100E5FA8; // weak
_UNKNOWN unk_100E5FB0; // weak
_UNKNOWN unk_100E5FB8; // weak
_UNKNOWN unk_100E5FC0; // weak
_UNKNOWN unk_100E5FC8; // weak
_UNKNOWN unk_100E5FD0; // weak
_UNKNOWN unk_100E5FD8; // weak
_UNKNOWN unk_100E5FE0; // weak
_UNKNOWN unk_100E5FE8; // weak
_UNKNOWN unk_100E5FEC; // weak
_UNKNOWN unk_100E5FF0; // weak
_UNKNOWN unk_100E5FF4; // weak
_UNKNOWN unk_100E6048; // weak
_UNKNOWN unk_100E609C; // weak
_UNKNOWN unk_100E60A4; // weak
_UNKNOWN unk_100E60A8; // weak
_UNKNOWN unk_100E60AC; // weak
_UNKNOWN unk_100E60B0; // weak
_UNKNOWN unk_100E60B4; // weak
_UNKNOWN unk_100E62BC; // weak
_UNKNOWN unk_100E641C; // weak
_UNKNOWN unk_100E6434; // weak
_UNKNOWN unk_100E644C; // weak
_UNKNOWN unk_100E6456; // weak
_UNKNOWN unk_100E6458; // weak
_UNKNOWN unk_100E6468; // weak
_UNKNOWN unk_100E646C; // weak
_UNKNOWN unk_100E6470; // weak
_UNKNOWN unk_100E6474; // weak
_UNKNOWN unk_100E6475; // weak
_UNKNOWN unk_100E6478; // weak
_UNKNOWN unk_100E64C8; // weak
_UNKNOWN unk_100E64CC; // weak
_UNKNOWN unk_100E64CD; // weak
_UNKNOWN unk_100E64CE; // weak
_UNKNOWN unk_100E64CF; // weak
_UNKNOWN unk_100E64E3; // weak
_UNKNOWN unk_100E64E4; // weak
_UNKNOWN unk_100E64E5; // weak
_UNKNOWN unk_100E64E6; // weak
_UNKNOWN unk_100E64E8; // weak
_UNKNOWN unk_100E6588; // weak
_UNKNOWN unk_100E65D8; // weak
_UNKNOWN unk_100E65DC; // weak
_UNKNOWN unk_100E65E0; // weak
_UNKNOWN unk_100E65E4; // weak
_UNKNOWN unk_100E65E8; // weak
_UNKNOWN unk_100E65EC; // weak
_UNKNOWN unk_100E65F0; // weak
_UNKNOWN unk_100E65F4; // weak
_UNKNOWN unk_100E65F8; // weak
_UNKNOWN unk_100E65FC; // weak
_UNKNOWN unk_100E6600; // weak
_UNKNOWN unk_100E6604; // weak
_UNKNOWN unk_100E6608; // weak
_UNKNOWN unk_100E6748; // weak
_UNKNOWN unk_100E6754; // weak
_UNKNOWN unk_100E679C; // weak
_UNKNOWN unk_100E679D; // weak
_UNKNOWN unk_100E67C8; // weak
_UNKNOWN unk_100E67F8; // weak
_UNKNOWN unk_100E6820; // weak
_UNKNOWN unk_100E6824; // weak
_UNKNOWN unk_100E6828; // weak
_UNKNOWN unk_100E682C; // weak
_UNKNOWN unk_100E685C; // weak
_UNKNOWN unk_100E685D; // weak
_UNKNOWN unk_100E685E; // weak
_UNKNOWN unk_100E6860; // weak
_UNKNOWN unk_100E6864; // weak
_UNKNOWN unk_100E6868; // weak
_UNKNOWN unk_100E686C; // weak
_UNKNOWN unk_100E6870; // weak
_UNKNOWN unk_100E6874; // weak
_UNKNOWN unk_100E6878; // weak
_UNKNOWN unk_100E687C; // weak
_UNKNOWN unk_100E6880; // weak
_UNKNOWN unk_100E6884; // weak
_UNKNOWN unk_100E6BE4; // weak
_UNKNOWN unk_100E6BE8; // weak
_UNKNOWN unk_100E6BF2; // weak
_UNKNOWN unk_100E6BFC; // weak
int dword_100E83B8; // weak
int dword_100E83BC; // weak
int dword_100E83C0; // weak
int dword_100E83C4; // weak
int dword_100E83C8; // weak
int dword_100E83CC; // weak
int dword_100E83D0; // weak
int dword_100E83D4; // weak
int dword_100E83D8; // weak
int dword_100E83DC; // weak
int dword_100E83E0; // weak
int dword_100E83E4; // weak
int dword_100E83E8; // weak
int dword_100F5B38[]; // weak
int dword_100F5B3C; // weak
int dword_100F5B40; // weak
int dword_100F5B44; // weak
int dword_100F5B48; // weak
int dword_100F5B4C[]; // weak
int dword_100F5B50; // weak
int dword_100F5B54; // weak
int dword_100F5B58; // weak
int dword_100F5B5C; // weak
_UNKNOWN unk_100F5B60; // weak
char byte_100F5C78; // idb
char byte_100F5D78[254]; // idb
char byte_100F5E76[]; // weak
char byte_100F5E77[]; // weak
char byte_100F6278[2800]; // idb
char byte_100F6D68[1022]; // idb
char byte_100F7166[]; // weak
char byte_100F7167[]; // weak
char byte_100F7168[1022]; // idb
char byte_100F7566[]; // weak
char byte_100F7567[]; // weak
char byte_100F7568[1022]; // idb
char byte_100F7966[]; // weak
char byte_100F7967[]; // weak
int dword_100FA968[]; // weak
int dword_100FA97C[]; // weak
char byte_100FA990[2800]; // idb
char byte_100FB480[2800]; // idb
char byte_100FBF70[2800]; // idb
int dword_100FCA60[]; // weak
int dword_100FCA74[]; // weak
char byte_100FCA88[2796]; // idb
char byte_100FD574[]; // weak
char byte_100FD578[559]; // idb
char byte_100FD7A7[]; // weak
int dword_100FE068[]; // weak
int dword_100FE07C[]; // weak
char byte_100FE090[2800]; // idb
int dword_100FEB80; // weak
_UNKNOWN unk_100FEB88; // weak
_UNKNOWN unk_100FF6E0; // weak
_UNKNOWN unk_10101A44; // weak
_UNKNOWN unk_10101A48; // weak
int dword_10101A4C; // weak
int dword_10101A50; // weak
_UNKNOWN unk_10101A58; // weak
int dword_10102F98; // weak
char byte_10102FA0[]; // weak
char byte_10102FA4[]; // weak
char byte_10102FA5[]; // weak
int dword_10102FAC[]; // weak
int dword_10102FB4[]; // weak
int dword_10102FE8; // weak
int dword_10102FEC; // weak
int dword_10102FF0; // weak
int dword_10102FF4; // weak
_UNKNOWN unk_10162D3C; // weak
_UNKNOWN unk_10162D44; // weak
_UNKNOWN unk_10162D4C; // weak
int dword_10162D58; // weak
char byte_10162D60[]; // weak
char byte_10162DB0[]; // weak
char byte_1016A100; // weak
char byte_1016A101; // weak
char byte_1016C9A8[]; // weak
char byte_1016C9A9[]; // weak
_UNKNOWN unk_1016CA48; // weak
int dword_1016CD18[]; // weak
int dword_1016CD1C[]; // weak
_UNKNOWN unk_1016D238; // weak
_UNKNOWN unk_10170140; // weak
_UNKNOWN unk_10170640; // weak
_UNKNOWN unk_101706E8; // weak
char byte_10170708; // weak
char byte_10170709; // weak
char byte_1017070A; // weak
char byte_1017070B; // weak
_UNKNOWN unk_10170710; // weak
_UNKNOWN unk_10170730; // weak
char byte_10171840; // weak
char byte_10171841; // weak
int dword_1017185C; // weak
int dword_10171B88; // weak
int dword_10171B94; // weak
int dword_10171CF0; // weak
int dword_101721B8; // weak
int dword_101721C4; // weak
int dword_101721D0; // weak
int dword_101721D4; // weak
int dword_101721D8; // weak
int dword_101721F4; // weak
int dword_101721F8; // weak
int dword_101721FC; // weak
int dword_10172200; // weak
int dword_10172204; // weak
char byte_101722C8; // weak
char byte_101722C9; // weak
int dword_101722E0; // weak
_UNKNOWN unk_101722E4; // weak
char byte_101A4300; // weak
char byte_101A4301; // weak
char byte_101A4302; // weak
char byte_101A4304; // weak
char byte_101A430B; // weak
__int16 word_101A430E; // weak
__int16 word_101A4310; // weak
__int16 word_101A4314; // weak
int dword_101A4318; // weak
int dword_101A431C; // weak
int dword_101A4334; // weak
int dword_101A4340; // weak
int dword_101A4348; // weak
char byte_101A4488; // weak
int dword_101A44DC; // weak
char byte_101A44E0; // weak
int dword_101A4500[]; // weak
_BYTE dword_101A4504[1120]; // idb
int dword_101A4968; // weak
_UNKNOWN unk_101A496C; // weak
int dword_101A4980[]; // weak
int dword_101A4A4C; // weak
int dword_101A4A50; // weak
int dword_101A4A60; // weak
int dword_101A4A64; // weak
int dword_101A4A68; // weak
int dword_101A4A6C; // weak
int dword_101A4A70; // weak
int dword_101A4A74; // weak
char byte_101A4A78[]; // weak
void *dword_101A4A7C; // idb
int dword_101A5A80; // weak
int dword_101A5A9C; // weak
int dword_101A5AA8; // weak
UINT uNumber; // idb
int dword_101A5AC0[]; // weak
int dword_101A5BC0; // weak


//----- (10001000) --------------------------------------------------------
char __cdecl sub_10001000(int a1)
{
  int *v1; // ecx@1
  __int16 v2; // bx@1
  __int16 v3; // di@1
  char result; // al@1
  bool v5; // zf@1
  __int16 v6; // bp@1
  int v7; // ecx@3
  __int16 v8; // si@4
  __int16 v9; // dx@5
  char v10; // [sp+13h] [bp-1h]@1
  int v11; // [sp+18h] [bp+4h]@1

  v1 = (int *)a1;
  v2 = *(_WORD *)(a1 + 30);
  v3 = *(_WORD *)(a1 + 28);
  result = 0;
  v5 = a1 == dword_101A4968;
  v10 = 0;
  v6 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 34) - 1;
  v11 = (unsigned __int16)(*(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 32) - 1);
  if ( v5 )
  {
    result = 1;
    v10 = 1;
  }
  v7 = *v1;
  if ( v7 )
  {
    while ( 1 )
    {
      v8 = *(_WORD *)(v7 + 28);
      if ( v3 >= v8 )
      {
        v9 = *(_WORD *)(v7 + 30);
        if ( v2 >= v9 && v6 <= *(_WORD *)(v7 + 34) + v9 - 1 && (signed __int16)v11 <= *(_WORD *)(v7 + 32) + v8 - 1 )
          break;
      }
      v7 = *(_DWORD *)v7;
      if ( !v7 )
        return v10;
    }
    result = 1;
  }
  return result;
}
// 101A4968: using guessed type int dword_101A4968;

//----- (100010B0) --------------------------------------------------------
bool __cdecl sub_100010B0(int a1, int a2)
{
  char v2; // al@1

  v2 = *(_BYTE *)(a2 + 24);
  return v2 == 1 || v2 == 3;
}

//----- (100010D0) --------------------------------------------------------
int __usercall sub_100010D0@<eax>(int result@<eax>, int a2@<esi>)
{
  signed int v2; // ST1C_4@2
  float v3; // ST10_4@2
  float v4; // ST08_4@2

  if ( *(_BYTE *)(result + 11) )
  {
    j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
    j_gdi_pvg_matrix_mode(51);
    ((void (*)(void))j_gdi_pvg_load_identity)();
    v2 = *(_WORD *)(a2 + 32);
    v3 = (double)*(_WORD *)(a2 + 34);
    v4 = (double)v2;
    sub_10003B20(0.0, v4, 0.0, v3, 0.0, 1.0);
    j_gdi_pvg_matrix_mode(52);
    j_gdi_pvg_load_identity(v2);
    if ( (*(_BYTE *)(a2 + 24) & 3) == 2 )
      result = j_gdi_pvg_viewport(0, 0, *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
    else
      result = j_gdi_pvg_viewport(*(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
  }
  return result;
}
// 10003AE0: using guessed type int __cdecl j_gdi_pvg_load_identity(_DWORD);
// 10003B00: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 10003B10: using guessed type int __cdecl j_gdi_pvg_matrix_mode(_DWORD);
// 10003B70: using guessed type int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001180) --------------------------------------------------------
char __cdecl sub_10001180(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int v6; // eax@2

  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 24) = a6;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) = a5;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) = a4;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 28) = a2;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 30) = a3;
  switch ( a6 & 3 )
  {
    case 0:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = sub_10002700(a1, a4, a5);
      LOBYTE(v6) = -1;
      if ( *(_DWORD *)(a1 + 24) == -1 || *(_BYTE *)(a1 + 11) != 1 )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = -1;
      }
      else
      {
        sub_10003E70();
        sub_10003EC0(1);
        v6 = sub_10003E30(a4, a5, 57);
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      }
      break;
    case 1:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = &unk_100C2830;
      v6 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      break;
    case 2:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      sub_10003E70();
      sub_10003EC0(1);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = sub_10003E30(a4, a5, 59);
      LOBYTE(v6) = sub_100010D0(a1, *(_DWORD *)(a1 + 56));
      break;
    case 3:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      v6 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(v6 + 52) = *(_DWORD *)(a1 + 24);
      break;
    default:
      LOBYTE(v6) = sub_10003DC0(".\\cdp_cnvs_utl.c", 250, 1, 0);
      break;
  }
  return v6;
}

//----- (100012C0) --------------------------------------------------------
char __cdecl sub_100012C0(int a1, int a2)
{
  __int64 v2; // rax@4
  char result; // al@4
  int v4; // eax@5
  int v5; // eax@6
  int v6; // edx@6
  int v7; // eax@7
  int v8; // esi@9

  if ( !a2 )
    sub_10003DC0(".\\cdp_cnvs_utl.c", 388, 1, 0);
  switch ( *(_BYTE *)(a2 + 24) & 3 )
  {
    case 0:
      *(_WORD *)(a1 + 270) = *(_WORD *)(a2 + 32);
      *(_WORD *)(a1 + 268) = *(_WORD *)(a2 + 34);
      *(_BYTE *)(a1 + 272) = 8;
      v2 = *(_WORD *)(a2 + 32) + 255;
      *(_WORD *)(a1 + 274) = (unsigned __int16)((BYTE4(v2) + (signed int)v2) >> 8) << 8;
      *(_DWORD *)(a1 + 264) = *(_DWORD *)(a2 + 48);
      *(_BYTE *)(a1 + 273) = 0;
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(a1 + 268);
      *(_WORD *)(a1 + 434) = 0;
      *(_WORD *)(a1 + 432) = 0;
      result = 1;
      break;
    case 1:
      v4 = *(_DWORD *)(a1 + 56);
      if ( *(_DWORD *)(v4 + 8) != *(_DWORD *)(a1 + 44) )
      {
        *(_DWORD *)(v4 + 52) = *(_DWORD *)(a1 + 24);
        sub_100010D0(a1, *(_DWORD *)(a1 + 56));
        v5 = *(_DWORD *)(a1 + 56);
        v6 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 44) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(v5 + 52) = v6;
      }
      *(_DWORD *)(a1 + 264) = &unk_100C2830;
      v7 = a1 + 264;
      *(_DWORD *)(v7 + 4) = *(&off_1004692C + 1);
      *(_DWORD *)(v7 + 8) = *(&off_1004692C + 2);
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(a1 + 268);
      sub_1002BE90(a1 + 392, *(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
      *(_WORD *)(a1 + 434) = *(_WORD *)(a2 + 28);
      *(_WORD *)(a1 + 432) = *(_WORD *)(a2 + 30);
      result = 1;
      break;
    case 2:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      result = 1;
      break;
    case 3:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      v8 = *(_DWORD *)(a1 + 56);
      if ( *(_DWORD *)(v8 + 8) == *(_DWORD *)(a1 + 44) )
        goto LABEL_12;
      sub_100010D0(a1, v8);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 8);
      result = 1;
      break;
    default:
      sub_10003DC0(".\\cdp_cnvs_utl.c", 473, 1, 0);
LABEL_12:
      result = 1;
      break;
  }
  return result;
}
// 10003B00: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 1004692C: using guessed type void *off_1004692C;

//----- (100014B0) --------------------------------------------------------
int sub_100014B0()
{
  _BYTE *v0; // eax@1
  int result; // eax@3

  v0 = dword_101A4504;
  do
  {
    *((_DWORD *)v0 - 1) = 0;
    *v0 = 0;
    v0 += 8;
  }
  while ( (signed int)v0 < (signed int)&unk_101A496C );
  result = 0;
  dword_101A4500[0] = 0;
  *(_DWORD *)dword_101A4504 = 0;
  return result;
}
// 101A4500: using guessed type int dword_101A4500[];

//----- (100014E0) --------------------------------------------------------
int __cdecl sub_100014E0(int a1, int a2)
{
  int result; // eax@1

  for ( result = *(_DWORD *)(a1 + 48); result; result = *(_DWORD *)(result + 4) )
  {
    if ( *(_DWORD *)(result + 8) == a2 )
      break;
  }
  return result;
}

//----- (10001500) --------------------------------------------------------
int __cdecl sub_10001500(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 3) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_BYTE *)(a1 + 5) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 10) = 0;
  *(_BYTE *)(a1 + 7) = 1;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

//----- (10001530) --------------------------------------------------------
_DWORD *sub_10001530()
{
  _DWORD *result; // eax@1

  byte_101A44E0 = 0;
  result = sub_10004E50(&unk_100C1740);
  byte_101722C8 = 0;
  return result;
}
// 101722C8: using guessed type char byte_101722C8;
// 101A44E0: using guessed type char byte_101A44E0;

//----- (10001550) --------------------------------------------------------
int __cdecl sub_10001550(int a1, char *a2, int a3, int a4)
{
  if ( !a2 )
    sub_10003DC0(".\\cdp_main.c", 890, 1, 0);
  if ( a3 > 0 )
    *((_DWORD *)a2 + 3) = sub_10002680(a1, a3);
  *((_DWORD *)a2 + 14) = sub_10002680(a1, 4 * a4 + 4);
  a2[68] = a4;
  a2[231] = 0;
  if ( a4 > 0 )
  {
    *((_DWORD *)a2 + 15) = sub_10002680(a1, 4 * a4);
    *((_DWORD *)a2 + 16) = sub_10002680(a1, a4);
  }
  return *((_DWORD *)a2 + 3);
}

//----- (100015E0) --------------------------------------------------------
char __cdecl sub_100015E0(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 1;
  v9 = 1000;
  v4 = sub_100040C0(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_10003DC0(".\\cdp_main.c", 1068, 0, 0);
  return v4;
}

//----- (10001650) --------------------------------------------------------
char __cdecl sub_10001650(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 2;
  v9 = 1000;
  v4 = sub_100040C0(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_10003DC0(".\\cdp_main.c", 1136, 0, 0);
  return v4;
}

//----- (100016C0) --------------------------------------------------------
int sub_100016C0()
{
  int result; // eax@1

  result = sub_10003F60();
  dword_100C1748 = result;
  byte_100C1744 = 0;
  return result;
}
// 100C1744: using guessed type char byte_100C1744;
// 100C1748: using guessed type int dword_100C1748;

//----- (100016E0) --------------------------------------------------------
_DWORD *__cdecl sub_100016E0(int a1)
{
  return sub_10004E90(&unk_100C1740, a1);
}

//----- (10001700) --------------------------------------------------------
void __usercall sub_10001700(int a1@<esi>)
{
  if ( *(_BYTE *)(a1 + 11) )
  {
    sub_10003AD0();
    sub_10003E70();
    *(_DWORD *)(a1 + 28) = sub_10003E30(*(_WORD *)(a1 + 16), *(_WORD *)(a1 + 14), 57);
  }
}

//----- (10001730) --------------------------------------------------------
char __usercall sub_10001730@<al>(int a1@<esi>)
{
  _WORD *v1; // eax@1
  int v2; // edi@1
  void *v3; // ecx@1
  int v4; // eax@1
  int v5; // eax@9
  char result; // al@13
  char v7; // [sp+8h] [bp-8h]@1
  int v8; // [sp+Ch] [bp-4h]@1

  v1 = *(_WORD **)(a1 + 52);
  v8 = 2;
  byte_101722C9 = *v1 == -32749;
  byte_101A44E0 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  v2 = *(_DWORD *)(a1 + 56);
  sub_100042D0(9129, &v7, 2, &v8);
  v4 = *(_DWORD *)(a1 + 64);
  if ( (v4 == 1 || v4 == 9) && sub_10005690(v3) != 2 && v7 & 0x1C )
  {
    byte_101722C9 = 0;
    byte_101A44E0 = 0;
  }
  if ( *(_DWORD *)(a1 + 64) == 1 && sub_10005320() )
  {
    byte_101722C9 = 0;
    byte_101A44E0 = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 238) = 1;
  }
  v5 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 56) = v5;
  if ( v5 && *(_BYTE *)(v5 + 230) != -1 && !*(_BYTE *)(v5 + 238) )
  {
    sub_10004F20(a1, (char *)v5, (int)&unk_1004E02C);
    *(_BYTE *)(a1 + 1) = 1;
  }
  *(_DWORD *)(a1 + 56) = v2;
  result = sub_100038C0(a1);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 101722C9: using guessed type char byte_101722C9;
// 101A44E0: using guessed type char byte_101A44E0;

//----- (10001810) --------------------------------------------------------
void __usercall sub_10001810(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  __int64 v3; // rax@8

  v2 = *(_DWORD *)(a1 + 52);
  if ( v2 != -1 )
  {
    if ( *(_BYTE *)(a1 + 24) & 3 )
    {
      if ( (*(_BYTE *)(a1 + 24) & 3) == 2 )
        sub_10003A30(v2, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), 0, 0, *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 34));
    }
    else if ( *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 26) && !sub_10001000(a1) )
    {
      j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 52));
      v3 = *(_WORD *)(a1 + 32) + 255;
      sub_10003A80(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(a1 + 34), 57, 15, *(_DWORD *)(a1 + 48));
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 24));
      sub_10003A30(
        *(_DWORD *)(a1 + 52),
        *(_WORD *)(a1 + 28),
        *(_WORD *)(a1 + 30),
        0,
        0,
        *(_WORD *)(a1 + 32),
        *(_WORD *)(a1 + 34));
    }
  }
}
// 10003B00: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);

//----- (100018E0) --------------------------------------------------------
void __usercall sub_100018E0(int a1@<esi>, int a2)
{
  __int16 v2; // ST1C_2@5
  __int16 v3; // ST14_2@5
  __int16 v4; // ST10_2@5
  int v5; // [sp+0h] [bp-Ch]@5
  __int16 v6; // [sp+4h] [bp-8h]@5
  __int16 v7; // [sp+6h] [bp-6h]@5
  char v8; // [sp+8h] [bp-4h]@5
  char v9; // [sp+9h] [bp-3h]@5
  __int16 v10; // [sp+Ah] [bp-2h]@5

  if ( !(*(_BYTE *)(a1 + 24) & 3) && *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 26) && !sub_10001000(a1) )
  {
    v2 = *(_WORD *)(a1 + 34);
    v7 = *(_WORD *)(a1 + 32);
    v3 = *(_WORD *)(a1 + 30);
    v4 = *(_WORD *)(a1 + 28);
    v10 = (unsigned __int16)((v7 + 255) / 256) << 8;
    v5 = *(_DWORD *)(a1 + 48);
    v6 = v2;
    v8 = 8;
    v9 = 0;
    sub_1002BFA0(a2 + 392, (int)&v5, 0, 0, v4, v3, v7, v2);
  }
}

//----- (10001980) --------------------------------------------------------
int __usercall sub_10001980@<eax>(int a1@<edi>, int a2)
{
  int v2; // esi@1
  __int64 v3; // rax@8
  int result; // eax@11

  v2 = *(_DWORD *)(a1 + 48);
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)(v2 + 4) )
  {
    if ( !*(_DWORD *)(v2 + 4) )
      break;
    if ( sub_100010B0(a1, v2) )
      break;
  }
  if ( *(_DWORD *)(a1 + 24) != -1 )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 24));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
    if ( v2 )
    {
      if ( (*(_BYTE *)(v2 + 24) & 3) == 1 )
      {
        j_gdi_pvg_make_window_current(*(_DWORD *)(v2 + 52));
        v3 = *(_WORD *)(a1 + 16) + 255;
        sub_10003A80(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(v2 + 34), 57, 15, *(_DWORD *)(v2 + 48));
        j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
        sub_10003A30(
          *(_DWORD *)(v2 + 52),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 32),
          *(_WORD *)(v2 + 34));
      }
      nullsub_1(a1, 1);
      do
      {
        sub_10001810(v2, a1);
        v2 = *(_DWORD *)v2;
      }
      while ( v2 );
    }
    result = nullsub_1(a1, 0);
    goto LABEL_21;
  }
  if ( *(_BYTE *)(a1 + 11) )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 28));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 28));
  }
  if ( v2 && *(_BYTE *)(v2 + 26) )
    nullsub_1(a1, 1);
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)v2 )
    sub_100018E0(v2, a1);
  result = nullsub_1(a1, 0);
  if ( *(_BYTE *)(a1 + 11) )
  {
    result = sub_10003A80(
               0,
               0,
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 10),
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 4),
               57,
               15,
               **(_DWORD **)(a1 + 444));
LABEL_21:
    if ( *(_BYTE *)(a1 + 11) )
      result = j_gdi_pvg_update_display_wdw();
  }
  *(_BYTE *)(a1 + 392) = 0;
  return result;
}
// 10003AF0: using guessed type int __cdecl j_gdi_pvg_make_window_active(_DWORD);
// 10003B00: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 10003B60: using guessed type int j_gdi_pvg_update_display_wdw(void);

//----- (10001B50) --------------------------------------------------------
char __thiscall sub_10001B50(int this)
{
  char result; // al@1

  result = 0;
  if ( !*(_BYTE *)(*(_DWORD *)(this + 56) + 26) && **(_WORD **)(this + 52) == -32696 )
  {
    result = 1;
    *(_BYTE *)(this + 6) = 2;
  }
  return result;
}

//----- (10001B70) --------------------------------------------------------
signed int __cdecl sub_10001B70(int a1, int a2)
{
  const void *v2; // edx@1
  int v3; // ebx@1
  char v4; // al@4
  char v6; // al@13
  char v7; // al@14
  int v8; // [sp-Ch] [bp-FCh]@15
  __int16 *v9; // [sp-8h] [bp-F8h]@15
  int v10; // [sp+Ch] [bp-E4h]@1
  __int16 v11; // [sp+18h] [bp-D8h]@7
  int v12; // [sp+1Ch] [bp-D4h]@12

  v2 = (const void *)a2;
  v3 = *(_DWORD *)(a2 + 4);
  v10 = 0;
  if ( !v3 )
  {
    if ( *(_WORD *)a2 > 0x8001u && *(_WORD *)a2 < 0x800Du )
    {
      v3 = *(_DWORD *)(a1 + 48);
      v4 = 1;
      goto LABEL_7;
    }
    v3 = 0;
  }
  v4 = 0;
LABEL_7:
  qmemcpy(&v11, (const void *)a2, 0xCCu);
  if ( !v4 )
  {
    sub_100015E0(a1, (int)&v11, 204);
    return 1;
  }
  if ( v3 )
  {
    while ( 1 )
    {
      qmemcpy(&v11, v2, 0xCCu);
      v12 = v3;
      if ( v11 != -32760 )
        break;
      v6 = *(_BYTE *)(v3 + 243);
      if ( v6 )
      {
        v7 = v6 - 1;
        *(_BYTE *)(v3 + 243) = v7;
        if ( !v7 )
        {
          v11 = -32648;
          v9 = &v11;
          *(_BYTE *)(v3 + 243) = *(_BYTE *)(v3 + 244);
          v8 = a1;
LABEL_17:
          sub_100015E0(v8, (int)v9, 204);
          ++v10;
          goto LABEL_18;
        }
      }
LABEL_18:
      if ( sub_100010B0(a1, v3) )
        return v10;
      v3 = *(_DWORD *)(v3 + 4);
      if ( !v3 )
        return v10;
      v2 = (const void *)a2;
    }
    v9 = &v11;
    v8 = a1;
    goto LABEL_17;
  }
  return v10;
}

//----- (10001CC0) --------------------------------------------------------
char __cdecl sub_10001CC0(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_100015E0(a1, (int)&v4, 8);
}

//----- (10001CF0) --------------------------------------------------------
char __cdecl sub_10001CF0(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_10001650(a1, (int)&v4, 8);
}

//----- (10001D20) --------------------------------------------------------
char __cdecl sub_10001D20(int a1)
{
  int v1; // eax@1
  int v2; // ecx@2
  __int16 v3; // dx@2
  unsigned int v4; // ebx@3
  _DWORD *v5; // eax@3
  char v6; // dl@3
  __int16 v7; // ax@10
  unsigned __int16 v8; // cx@14
  int v9; // eax@31
  int v10; // eax@31
  int v11; // eax@41
  __int16 v12; // ax@48
  char v13; // al@52
  _WORD *v14; // edx@55
  int v15; // ebp@58
  int v17; // [sp+0h] [bp-10h]@0

  v1 = *(_DWORD *)(a1 + 52);
  if ( *(_WORD *)v1 < 0x8000u )
  {
    v2 = *(_DWORD *)(v1 + 4);
    v3 = *(_WORD *)(v1 + 8);
    *(_WORD *)v1 = -32670;
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 12) = v2;
    *(_WORD *)(*(_DWORD *)(a1 + 52) + 8) = v3;
  }
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
  sub_10004E60((int *)&unk_100C1740, a1);
  v5 = *(_DWORD **)(a1 + 32);
  v6 = 0;
  if ( v5 )
  {
    while ( *(_DWORD **)(*(_DWORD *)(a1 + 52) + 4) != v5 )
    {
      v5 = (_DWORD *)*v5;
      if ( !v5 )
        goto LABEL_8;
    }
    v6 = 1;
  }
LABEL_8:
  if ( v4 )
  {
    if ( !v6 )
    {
      v7 = **(_WORD **)(a1 + 52);
      if ( v7 != -32703 )
      {
        if ( v7 == -32744 )
          return v7;
        v4 = 0;
        *(_DWORD *)(a1 + 56) = 0;
      }
    }
  }
  LOBYTE(v7) = sub_100038A0();
  if ( !(_BYTE)v7 )
  {
    v8 = **(_WORD **)(a1 + 52);
    switch ( **(_WORD **)(a1 + 52) )
    {
      case 0x8013:
      case 0x8014:
        sub_10001730(a1);
        goto LABEL_40;
      case 0x8018:
        if ( *(_DWORD *)(a1 + 24) != -1 && (!(*(_BYTE *)(v4 + 24) & 3) || (*(_BYTE *)(v4 + 24) & 3) == 2) )
          j_gdi_pvg_destroy_window(*(_DWORD *)(v4 + 52));
        if ( v4 != *(_DWORD *)(a1 + 32) && *(_DWORD *)(v4 + 4) )
        {
          *(_DWORD *)(a1 + 48) = *(_DWORD *)(v4 + 4);
          **(_DWORD **)(v4 + 4) = 0;
        }
        else
        {
          sub_10001500(a1);
        }
        goto LABEL_40;
      case 0x8022:
      case 0x8078:
        if ( *(_BYTE *)(a1 + 4) || v4 && sub_10001000(v4) )
          v4 = 0;
        if ( *(_DWORD *)(a1 + 64) == 1 && sub_10005320() != byte_100C1744 )
        {
          **(_WORD **)(a1 + 52) = -32734;
          byte_100C1744 = sub_10005320();
        }
        goto LABEL_40;
      case 0x8041:
        v9 = sub_10002680(a1, 332);
        v4 = v9;
        qmemcpy((void *)v9, &unk_10044370, 0x14Cu);
        *(_DWORD *)(v9 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
        v10 = *(_DWORD *)(a1 + 48);
        if ( v10 )
        {
          *(_DWORD *)(v4 + 4) = v10;
          **(_DWORD **)(a1 + 48) = v4;
          *(_BYTE *)(v4 + 243) = *(_BYTE *)(*(_DWORD *)(v4 + 4) + 243);
        }
        if ( !*(_DWORD *)(a1 + 32) )
          *(_DWORD *)(a1 + 32) = v4;
        --*(_BYTE *)(a1 + 4);
        *(_DWORD *)(a1 + 48) = v4;
        goto LABEL_40;
      default:
        if ( !v4 )
        {
          if ( v8 <= 0x800Eu || v8 >= 0xFFFFu )
            goto LABEL_67;
          v4 = *(_DWORD *)(a1 + 48);
LABEL_40:
          if ( !v4 )
            goto LABEL_67;
        }
        v11 = *(_DWORD *)(a1 + 52);
        *(_DWORD *)(a1 + 56) = v4;
        *(_BYTE *)(a1 + 6) = 1;
        *(_DWORD *)(v11 + 4) = v4;
        if ( **(_WORD **)(a1 + 52) == -32665 )
          *(_BYTE *)(*(_DWORD *)(a1 + 56) + 237) = 0;
        nullsub_1(a1, v17);
        if ( *(_BYTE *)(a1 + 6) == 1 && !sub_10001B50(a1) )
          (*(void (__cdecl **)(int))(v4 + 8))(a1);
        if ( !v4 || v4 > *(_DWORD *)(a1 + 48) && (v12 = **(_WORD **)(a1 + 52), v12 != -32703) && v12 != -32744 )
        {
LABEL_67:
          v4 = 0;
          *(_DWORD *)(a1 + 56) = 0;
        }
        LOBYTE(v7) = nullsub_1(a1, v17);
        if ( v4 )
        {
          v13 = *(_BYTE *)(a1 + 6);
          if ( v13 == 1 || v13 == 3 )
            sub_10003860(a1);
          v14 = *(_WORD **)(a1 + 52);
          if ( *v14 == 32792 )
          {
            LOBYTE(v7) = sub_10002340(0, v4);
            if ( !*(_DWORD *)(a1 + 32) )
              *(_DWORD *)(a1 + 56) = 0;
            *(_BYTE *)(a1 + 1) = 1;
          }
          else if ( *v14 == 32871 )
          {
            LOBYTE(v7) = sub_10001CC0(a1, *(_DWORD *)(a1 + 56), -32734);
          }
          else
          {
            v7 = *v14 + 32648;
            if ( *v14 == 32888 )
            {
              v15 = *(_DWORD *)(a1 + 56);
              if ( v15 )
                *(_BYTE *)(v15 + 26) = 1;
            }
          }
        }
        break;
    }
  }
  return v7;
}
// 10003E60: using guessed type int __cdecl j_gdi_pvg_destroy_window(_DWORD);
// 100C1744: using guessed type char byte_100C1744;

//----- (10002050) --------------------------------------------------------
int __usercall sub_10002050@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  int result; // eax@1
  __int16 v3; // ax@2
  bool v4; // al@4
  char v5; // [sp+4h] [bp-4h]@1

  v1 = a1;
  for ( result = sub_10003F10(*(_DWORD *)(a1 + 52), (int)&v5);
        result != 1;
        result = sub_10003F10(*(_DWORD *)(v1 + 52), (int)&v5) )
  {
    v3 = **(_WORD **)(v1 + 52);
    v4 = v3 == -32696 || v3 == -32734;
    *(_BYTE *)(v1 + 10) = v4;
    sub_10001D20(v1);
    if ( *(_BYTE *)(v1 + 6) != 1 && *(_BYTE *)(v1 + 10) && (*(_BYTE *)(v1 + 392) || *(_BYTE *)(v1 + 1)) )
    {
      sub_10001980(v1, (int)&off_1004692C);
      *(_BYTE *)(v1 + 10) = 0;
    }
  }
  return result;
}
// 1004692C: using guessed type void *off_1004692C;

//----- (100020E0) --------------------------------------------------------
void __noreturn sub_100020E0()
{
  void *v0; // ecx@8
  unsigned int v1; // esi@16
  int v2; // eax@19
  int v3; // [sp+10h] [bp-ECh]@1
  char v4; // [sp+14h] [bp-E8h]@9
  char v5; // [sp+18h] [bp-E4h]@5

  dword_101A44DC = (int)&dword_101722E0;
  sub_100041A0(&v3);
  if ( !(v3 & 0x10) )
    sub_10003DC0(".\\cdp_main.c", 403, 1, 0);
  v3 |= 0x10u;
  if ( !sub_10004130(1, 20000) )
    sub_10003DC0(".\\cdp_main.c", 428, 1, 0);
  sub_10005BE0();
  sub_100057B0(&v5);
  while ( 1 )
  {
    byte_101A4488 = 0;
    if ( v3 & 0x10 || v3 & 0x8000 )
    {
      sub_10001500((int)&byte_101A4300);
      byte_101A4302 = sub_10005200(v0);
      byte_101A4304 = 0;
      dword_101A4334 = (int)&unk_100C1750;
      word_101A430E = 26;
      word_101A4310 = 1024;
      dword_101A4340 = 11;
      word_101A4314 = 250;
      dword_101A4318 = -1;
      dword_101A431C = -1;
      byte_101A430B = 1;
      dword_101A4348 = 0;
      byte_101A4300 = 0;
      while ( sub_10003F10(dword_101A4334, (int)&v4) != 1 )
        ;
      sub_100014A0();
      sub_10002660((int)&byte_101A4300);
      sub_100038B0(&byte_101A4300);
      sub_10005BD0((int)&unk_10044348);
      sub_10005BC0((int)&unk_10044350);
      sub_10001700((int)&byte_101A4300);
      sub_10003930((int)&byte_101A4300);
    }
    if ( v3 & 2 )
      sub_10002050((int)&byte_101A4300);
    if ( v3 & 1 )
    {
      v3 |= 0x20000000u;
      if ( (unsigned int)(sub_10003F60() - dword_100C1748) >= 0x3E8 )
      {
        dword_100C1748 += 1000;
        j_nullsub_1(&byte_101A4300);
        sub_100056A0((int *)&v5);
      }
    }
    v1 = 0x40000000;
    do
    {
      if ( v1 != 0x8000 && v1 & v3 )
      {
        v2 = sub_10004FD0(v1);
        sub_10001B70((int)&byte_101A4300, v2);
        sub_10002050((int)&byte_101A4300);
      }
      v1 >>= 1;
    }
    while ( v1 >= 0x200 );
    if ( byte_101A4488 || byte_101A4301 )
      sub_10001980((int)&byte_101A4300, (int)&off_1004692C);
    sub_100041A0(&v3);
  }
}
// 100014A0: using guessed type int sub_100014A0(void);
// 100038B0: using guessed type _DWORD __cdecl sub_100038B0(_DWORD);
// 10005BB0: using guessed type int __cdecl j_nullsub_1(_DWORD);
// 10005BE0: using guessed type int sub_10005BE0(void);
// 1004692C: using guessed type void *off_1004692C;
// 100C1748: using guessed type int dword_100C1748;
// 101722E0: using guessed type int dword_101722E0;
// 101A4300: using guessed type char byte_101A4300;
// 101A4301: using guessed type char byte_101A4301;
// 101A4302: using guessed type char byte_101A4302;
// 101A4304: using guessed type char byte_101A4304;
// 101A430B: using guessed type char byte_101A430B;
// 101A430E: using guessed type __int16 word_101A430E;
// 101A4310: using guessed type __int16 word_101A4310;
// 101A4314: using guessed type __int16 word_101A4314;
// 101A4318: using guessed type int dword_101A4318;
// 101A431C: using guessed type int dword_101A431C;
// 101A4334: using guessed type int dword_101A4334;
// 101A4340: using guessed type int dword_101A4340;
// 101A4348: using guessed type int dword_101A4348;
// 101A4488: using guessed type char byte_101A4488;
// 101A44DC: using guessed type int dword_101A44DC;

//----- (10002320) --------------------------------------------------------
int __cdecl sub_10002320(int a1, int a2)
{
  return a2 * ((a1 + 255) / 256) << 8;
}

//----- (10002340) --------------------------------------------------------
char __cdecl sub_10002340(int a1, unsigned int a2)
{
  char result; // al@4

  if ( !a2 || a2 < (unsigned int)&unk_101722E4 || a2 >= dword_101722E0 )
    result = sub_10003DC0(".\\cdp_mem.c", 222, 1, 0);
  dword_101722E0 = a2;
  return result;
}
// 101722E0: using guessed type int dword_101722E0;

//----- (10002380) --------------------------------------------------------
char sub_10002380()
{
  char result; // al@1

  byte_100C1820 = 0;
  result = sub_100046C0((int)"/mnt/card0/enable_heap_mntr.txt");
  if ( result )
    byte_100C1820 = 1;
  return result;
}
// 100C1820: using guessed type char byte_100C1820;

//----- (100023A0) --------------------------------------------------------
char __thiscall sub_100023A0(int this)
{
  unsigned int v1; // eax@1
  unsigned int v2; // esi@2
  int v3; // ecx@5
  int v4; // eax@5
  char *v5; // edi@6
  char v7[4]; // [sp+4h] [bp-ACh]@1
  int v8; // [sp+8h] [bp-A8h]@1
  int v9; // [sp+Ch] [bp-A4h]@1
  int v10; // [sp+10h] [bp-A0h]@1
  int v11; // [sp+14h] [bp-9Ch]@1
  char v12; // [sp+18h] [bp-98h]@1
  char v13; // [sp+2Ch] [bp-84h]@1

  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  sub_10003F80((int)&v12, 1, *(_DWORD *)(this + 64), 20);
  sub_10005CD0(&v13, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v12);
  LOBYTE(v1) = sub_100046C0((int)&v13);
  if ( (_BYTE)v1 )
  {
    v1 = j_FIL_vfs_open(&v13, 4, 0);
    v2 = v1;
    if ( v1 < 0xFFFFFFC2
      && v1
      && (sub_10004530(v1, &byte_100C1828, 4096),
          sub_10004460(v2),
          (v1 = (unsigned int)strstr(&byte_100C1828, "usage:")) != 0) )
    {
      v3 = v1 - (_DWORD)&byte_100C1828;
      v4 = v1 - (_DWORD)&byte_100C1828 + 7;
      if ( v4 < v3 + 27 )
      {
        v5 = &v7[-v4];
        do
        {
          if ( !(((unsigned __int8)byte_100509C0[2 * (unsigned __int8)*(&byte_100C1828 + v4)] >> 4) & 1) )
            break;
          v5[v4] = *(&byte_100C1828 + v4);
          ++v4;
        }
        while ( v4 < v3 + 27 );
      }
      v1 = j__atol(v7);
      dword_100C2828 = v1;
    }
    else
    {
      dword_100C2828 = 0;
    }
  }
  else
  {
    dword_100C2828 = 0;
  }
  return v1;
}
// 10004520: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100C2828: using guessed type int dword_100C2828;

//----- (10002510) --------------------------------------------------------
int __cdecl sub_10002510(int a1)
{
  unsigned int v1; // ecx@0
  int result; // eax@1
  unsigned int v3; // edi@1
  int v4; // eax@3
  unsigned int v5; // esi@3
  int v6; // edi@7
  char v7; // [sp+4h] [bp-160h]@3
  char v8; // [sp+18h] [bp-14Ch]@4
  char v9; // [sp+E0h] [bp-84h]@3

  result = a1;
  v3 = v1;
  if ( a1 && dword_100C2828 < v1 )
  {
    v4 = *(_DWORD *)(a1 + 64);
    dword_100C2828 = v1;
    sub_10003F80((int)&v7, 1, v4, 20);
    sub_10005CD0(&v9, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v7);
    v5 = j_FIL_vfs_open(&v9, 10, 0);
    sub_10005C10((int)&byte_100C1828, "HEAP STATISTICS:\r\n", 4096);
    if ( v3 > 0x32000 )
    {
      sub_10005C10((int)&v8, "\r\n!!!HEAP LIMIT EXCEEDED!!!\r\n", 200);
      sub_10005D00(&byte_100C1828, &v8, 4096);
    }
    sub_10005CD0(&v8, 0xC8u, "%s maximum heap usage: %d bytes out of %d bytes\r\n", &v7, v3, 204800);
    result = sub_10005D00(&byte_100C1828, &v8, 4096);
    if ( v5 < 0xFFFFFFC2 )
    {
      if ( v5 )
      {
        v6 = sub_10005C60(&byte_100C1828, 0x1000u);
        j_FIL_vfs_write(v5, &byte_100C1828, v6);
        sub_10004670(v5, v6, 0);
        result = sub_10004460(v5);
      }
    }
  }
  return result;
}
// 10004520: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10004690: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 100C2828: using guessed type int dword_100C2828;

//----- (10002660) --------------------------------------------------------
char __cdecl sub_10002660(int a1)
{
  char result; // al@2

  dword_101722E0 = (int)&unk_101722E4;
  if ( byte_100C1820 )
    result = sub_100023A0(a1);
  return result;
}
// 100C1820: using guessed type char byte_100C1820;
// 101722E0: using guessed type int dword_101722E0;

//----- (10002680) --------------------------------------------------------
int __cdecl sub_10002680(int a1, int a2)
{
  unsigned int v2; // esi@1
  int v3; // ecx@2
  int result; // eax@4

  v2 = (unsigned int)(a2 + 3) >> 2;
  if ( byte_100C1820 )
  {
    v3 = 4 * v2 - *(_DWORD *)(a1 + 476);
    sub_10002510(a1);
  }
  if ( !a2 || (result = dword_101722E0, dword_101722E0 + 4 * v2 > *(_DWORD *)(a1 + 476) + 204804) )
  {
    sub_10003DC0(".\\cdp_mem.c", 371, 1, 0);
    result = dword_101722E0;
  }
  dword_101722E0 = result + 4 * v2;
  return result;
}
// 100C1820: using guessed type char byte_100C1820;
// 101722E0: using guessed type int dword_101722E0;

//----- (10002700) --------------------------------------------------------
int __cdecl sub_10002700(int a1, __int16 a2, __int16 a3)
{
  int v3; // eax@1

  v3 = sub_10002320(a2, a3);
  return sub_10002680(a1, v3);
}

//----- (10002720) --------------------------------------------------------
_WORD *__cdecl sub_10002720(int a1)
{
  void *v1; // eax@1

  v1 = (void *)sub_10002680(a1, 332);
  *(_DWORD *)(a1 + 56) = v1;
  qmemcpy(v1, &unk_10044370, 0x14Cu);
  sub_10001550(a1, *(char **)(a1 + 56), 0, 0);
  **(_WORD **)(a1 + 52) = -32671;
  sub_1002CBA0(a1 + 392, (int)&off_1004692C, 0);
  *(_WORD *)(a1 + 428) = 0;
  *(_WORD *)(a1 + 430) = 0;
  return sub_1002CB40(a1 + 392);
}
// 1004692C: using guessed type void *off_1004692C;

//----- (10002790) --------------------------------------------------------
int __usercall sub_10002790@<eax>(char a1@<dl>, int a2@<esi>)
{
  int v2; // ebx@1
  int v3; // ebp@1
  __int16 v4; // di@1
  int result; // eax@1

  v2 = *(_DWORD *)(a2 + 452);
  v3 = *(_DWORD *)(a2 + 440);
  v4 = *(_WORD *)(a2 + 398);
  *(_WORD *)(a2 + 398) = 1;
  *(_DWORD *)(a2 + 452) = &unk_100457C0;
  *(_WORD *)(a2 + 440) = word_100DB980[12];
  *(_WORD *)(a2 + 442) = -1;
  result = sub_1002CC90(a2 + 392, 85 * a1 + 3, 2, 83, 24);
  *(_WORD *)(a2 + 398) = v4;
  *(_WORD *)(a2 + 440) = v3;
  *(_DWORD *)(a2 + 452) = v2;
  *(_WORD *)(a2 + 442) = HIWORD(v3);
  return result;
}
// 100DB980: using guessed type __int16 word_100DB980[];

//----- (10002820) --------------------------------------------------------
int __usercall sub_10002820@<eax>(int a1@<esi>, char a2)
{
  int v2; // ecx@1
  __int16 v3; // bp@1
  __int16 v4; // di@1
  int v5; // ST40_4@1
  int v6; // ST3C_4@1
  int result; // eax@1

  v2 = *(_DWORD *)(a1 + 440);
  v3 = *(_WORD *)(a1 + 398);
  v4 = 85 * a2;
  v5 = *(_DWORD *)(a1 + 452);
  *(_WORD *)(a1 + 426) = 3;
  *(_WORD *)(a1 + 424) = 3;
  *(_WORD *)(a1 + 428) = word_100DB980[6];
  v6 = v2;
  *(_WORD *)(a1 + 430) = word_100DB980[6];
  sub_1002CD80(a1 + 392, v4 + 3, 2, 84, 23, 0);
  *(_WORD *)(a1 + 428) = word_100DB980[1];
  *(_WORD *)(a1 + 430) = word_100DB980[1];
  *(_WORD *)(a1 + 426) = 1;
  *(_WORD *)(a1 + 424) = 1;
  sub_1002CD80(a1 + 392, v4 + 4, 3, 82, 21, 0);
  result = HIWORD(v6);
  *(_WORD *)(a1 + 398) = v3;
  *(_WORD *)(a1 + 440) = v6;
  *(_WORD *)(a1 + 442) = HIWORD(v6);
  *(_DWORD *)(a1 + 452) = v5;
  return result;
}
// 100DB980: using guessed type __int16 word_100DB980[];

//----- (10002920) --------------------------------------------------------
char __usercall sub_10002920@<al>(void *a1@<ecx>, int a2@<edi>)
{
  int v2; // ebx@1
  void *v3; // ecx@1
  char result; // al@3
  __int16 v5; // ax@5
  int v6; // ecx@5
  int v7; // edx@9
  int v8; // eax@9
  int v9; // esi@9
  int v10; // ecx@10
  bool v11; // zf@10
  char v12; // al@14

  v2 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 12);
  if ( sub_10005240(a1) != 8 && sub_10005240(v3) != 2 || (result = sub_10005260(v3)) != 0 )
  {
    if ( **(_WORD **)(a2 + 52) == -32657 )
    {
      v5 = sub_10003F40(14);
      if ( v5 == 1 || (LOBYTE(v6) = 11, !v5) )
        LOBYTE(v6) = 12;
      if ( (_BYTE)v6 )
      {
        v7 = 0;
        v8 = v2 + 18;
        v9 = (unsigned __int8)v6;
        do
        {
          v10 = *(_DWORD *)(a2 + 52);
          v11 = *(_WORD *)(v7 + v10 + 12) == -1;
          v6 = v7 + v10 + 12;
          if ( v11 )
          {
            *(_DWORD *)v8 = 6;
            *(_DWORD *)(v8 + 4) = 16776962;
            v6 = 16711935;
          }
          else
          {
            *(_DWORD *)v8 = *(_DWORD *)v6;
            *(_DWORD *)(v8 + 4) = *(_DWORD *)(v6 + 4);
            LOWORD(v6) = *(_WORD *)(v6 + 8);
          }
          *(_WORD *)(v8 + 8) = v6;
          v7 += 10;
          v8 += 10;
          --v9;
        }
        while ( v9 );
      }
      v12 = *(_BYTE *)(v2 + 12);
      if ( (v12 == 3
         || v12 == 4
         || v12 == 5
         || v12 == 6
         || v12 == 7
         || v12 == 8
         || v12 == 12
         || v12 == 15
         || v12 == 9
         || v12 == 10
         || v12 == 11)
        && (!*(_BYTE *)(v2 + 20) || sub_10005220((void *)v6)) )
      {
        *(_BYTE *)(v2 + 144) = 0;
      }
    }
    result = sub_10001CF0(a2, *(_DWORD *)(a2 + 56), -32648);
    *(_BYTE *)(a2 + 6) = 2;
  }
  return result;
}

//----- (10002A30) --------------------------------------------------------
int __thiscall sub_10002A30(void *this)
{
  char v1; // al@1
  void *v2; // ecx@1
  int v3; // eax@2
  void *v4; // ecx@5
  bool v5; // zf@6
  __int16 v7; // [sp+0h] [bp-88h]@1
  int v8; // [sp+4h] [bp-84h]@1

  v1 = sub_10005240(this);
  v8 = 0;
  v7 = -32657;
  if ( v1 == 2 )
  {
    v3 = 3;
  }
  else if ( v1 == 8 )
  {
    v3 = 16 - (sub_10003FF0(21) != 5);
  }
  else if ( sub_10005D40(v2) & 3 || (v5 = sub_10005300(v4) == 1, v3 = 9, v5) )
  {
    v3 = 14;
  }
  return sub_10004090(v3, (int)&v7, 60000, 1);
}

//----- (10002AB0) --------------------------------------------------------
int __cdecl sub_10002AB0(__int16 a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  __int16 v3; // ax@1
  __int16 v4; // dx@4
  __int16 v5; // ax@4
  int v6; // edi@4
  void *v7; // ecx@4
  void *v8; // ecx@6
  void *v9; // ecx@8
  char v10; // bl@11
  __int16 v11; // bp@12
  char v12; // bl@13
  int v13; // ebp@14
  int v14; // eax@24
  char *v15; // eax@37
  char v16; // cl@42
  __int16 v17; // dx@52
  int result; // eax@59
  __int16 v19; // [sp+0h] [bp-4Ch]@0
  int v20; // [sp+4h] [bp-48h]@0
  char v21; // [sp+13h] [bp-39h]@2
  int v22; // [sp+14h] [bp-38h]@15
  int v23; // [sp+18h] [bp-34h]@1
  _BYTE *v24; // [sp+1Ch] [bp-30h]@1
  unsigned int v25; // [sp+20h] [bp-2Ch]@4
  int v26; // [sp+24h] [bp-28h]@1
  int v27; // [sp+28h] [bp-24h]@11
  int v28; // [sp+2Ch] [bp-20h]@11
  char v29; // [sp+30h] [bp-1Ch]@13
  __int16 v30; // [sp+34h] [bp-18h]@4
  __int16 v31; // [sp+38h] [bp-14h]@4
  char v32; // [sp+3Ch] [bp-10h]@38

  v2 = v1;
  v26 = v1;
  v24 = (_BYTE *)sub_10005050();
  v23 = *(_DWORD *)(*(_DWORD *)(v2 + 56) + 12);
  v3 = sub_10003F40(14);
  if ( v3 == 1 || (v21 = 1, !v3) )
    v21 = 0;
  v4 = *(_WORD *)(v2 + 396);
  v5 = *(_WORD *)(v2 + 398);
  v6 = v2 + 392;
  *(_WORD *)(v6 + 4) = 2;
  *(_WORD *)(v6 + 6) = 3;
  *(_WORD *)(v6 + 34) = 1;
  *(_WORD *)(v6 + 32) = 1;
  v30 = v4;
  v31 = v5;
  v25 = *(_BYTE *)(v2 + 2) != 2 ? 4096 : 2048;
  if ( sub_10005240((void *)v25) != 8 && sub_10005240(v7) != 2 && (sub_10005D40(v7) & 3 || sub_10005300(v8) == 1)
    || sub_10005240(v7) == 2
    || sub_10005240(v9) == 8 )
  {
    v25 = 4096;
  }
  v28 = *(_DWORD *)(v2 + 428);
  v27 = *(_DWORD *)(v2 + 440);
  *(_WORD *)(v2 + 428) = word_100DB980[(unsigned __int8)sub_10005DC0(15)];
  *(_WORD *)(v2 + 430) = word_100DB980[(unsigned __int8)sub_10005DC0(15)];
  *(_WORD *)(v2 + 438) = 2;
  *(_WORD *)(v2 + 436) = 0;
  sub_1002DB20(v2 + 392, 1026, 0, 2);
  *(_WORD *)(v2 + 428) = word_100DB980[12];
  *(_WORD *)(v2 + 430) = word_100DB980[1];
  *(_WORD *)(v2 + 440) = word_100DB980[12];
  *(_WORD *)(v2 + 442) = word_100DB980[12];
  sub_1002CD80(v2 + 392, 2, 1, 1024, 26, 3);
  *(_WORD *)(v2 + 428) = word_100DB980[(unsigned __int8)sub_10005DC0(13)];
  *(_WORD *)(v2 + 430) = word_100DB980[1];
  v10 = 0;
  do
  {
    sub_1002CD80(v6, 85 * v10 + 2, 1, 85, 26, 2);
    v11 = 85 * v10 + 86;
    *(_WORD *)(v6 + 46) = v11;
    *(_WORD *)(v6 + 44) = 1;
    sub_1002DB20(v6, v11, 27, 2);
    ++v10;
  }
  while ( v10 < 12 );
  v12 = 0;
  v29 = 0;
  do
  {
    v13 = v23;
    if ( v12 == a1
      || (v22 = v23 + 10 * v12, *(_BYTE *)(v23 + 10 * v12 + 23) < 0xFFu) && *(_BYTE *)(v23 + 2 * (5 * v12 + 10)) == 1 )
    {
      v22 = v23 + 10 * v12;
      if ( !*(_BYTE *)(v23 + 10 * v12 + 22) )
      {
        *(_WORD *)(v6 + 36) = word_100DB980[0];
        *(_WORD *)(v6 + 38) = word_100DB980[15];
        sub_1002CD80(v6, 85 * v12 + 2, 0, 85, 27, 2);
        *(_WORD *)(v6 + 36) = word_100DB980[1];
        *(_WORD *)(v6 + 38) = word_100DB980[14];
        *(_WORD *)(v6 + 48) = word_100DB980[14];
        *(_WORD *)(v6 + 50) = word_100DB980[14];
        sub_1002CD80(v6, 85 * v12 + 3, 1, 83, 25, 3);
        v13 = v23;
      }
    }
    if ( v21 && v12 == 11 && *(_BYTE *)v13 != 19 )
    {
      *(_WORD *)(v6 + 36) = word_100DB980[1];
      *(_WORD *)(v6 + 38) = word_100DB980[14];
      if ( *(_BYTE *)(v13 + 4) && *(_BYTE *)(v13 + 13) )
      {
        *(_WORD *)(v6 + 48) = word_100DB980[*(_BYTE *)(v13 + 1)];
        v14 = *(_BYTE *)(v13 + 1);
      }
      else
      {
        *(_WORD *)(v6 + 48) = word_100DB980[*(_BYTE *)v13];
        v14 = *(_BYTE *)v13;
      }
      *(_WORD *)(v6 + 50) = word_100DB980[v14];
      sub_1002CD80(v6, 938, 1, 83, 25, 3);
    }
    if ( *(_BYTE *)(v13 + 14)
      && *(_BYTE *)(v13 + 15) == v12
      && !*(_BYTE *)(v22 + 22)
      && (*(_BYTE *)(v13 + 4) || !*(_DWORD *)(v13 + 8)
                              || (unsigned int)(sub_10003F60() - *(_DWORD *)(v13 + 8)) >= 0x1388) )
    {
      sub_10002820(v26, v29);
      v13 = v23;
    }
    if ( *(_WORD *)(v22 + 18) == 1252 )
    {
      sub_10005C10((int)&v32, v24, 9);
    }
    else if ( *(_WORD *)(v22 + 18) == 1256 )
    {
      sub_10005C10((int)&v32, v24, 9);
      sub_10005D00(&v32, &unk_100456D8, 9);
    }
    else
    {
      if ( *(_WORD *)(v22 + 18) != 1257 )
      {
        v15 = sub_10005D80(*(_WORD *)(v22 + 18));
        goto LABEL_42;
      }
      sub_10005C10((int)&v32, v24, 9);
      sub_10005D00(&v32, &unk_100456DC, 9);
    }
    v15 = &v32;
LABEL_42:
    v16 = *(_BYTE *)(v22 + 22);
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        *(_WORD *)(v6 + 36) = word_100DB980[12];
        *(_WORD *)(v6 + 38) = word_100DB980[0];
        *(_WORD *)(v6 + 46) = 85 * v12 + 44;
        *(_WORD *)(v6 + 44) = 20;
        sub_1002D040(v6, dword_101A4980[5 * ((v25 >> 10) & 0xF)], v15, 0, 1, v19, v20);
        sub_10002790(v12, v26);
      }
    }
    else
    {
      if ( v21 && v12 == 11 && *(_BYTE *)v13 != 19 )
      {
        if ( *(_BYTE *)(v13 + 4) && *(_BYTE *)(v13 + 13) )
        {
          *(_WORD *)(v6 + 36) = word_100DB980[*(_BYTE *)(v13 + 1)];
          *(_WORD *)(v6 + 38) = word_100DB980[*(_BYTE *)v13];
        }
        else
        {
          *(_WORD *)(v6 + 36) = word_100DB980[*(_BYTE *)v13];
          *(_WORD *)(v6 + 38) = word_100DB980[*(_BYTE *)(v13 + 1)];
        }
      }
      else
      {
        if ( v12 == a1 || *(_BYTE *)(v13 + 2 * (5 * v12 + 10)) == 1 )
        {
          *(_WORD *)(v6 + 36) = word_100DB980[14];
          v17 = word_100DB980[12];
        }
        else
        {
          *(_WORD *)(v6 + 36) = word_100DB980[12];
          v17 = word_100DB980[15];
        }
        *(_WORD *)(v6 + 38) = v17;
      }
      *(_WORD *)(v6 + 46) = 85 * v12 + 45;
      *(_WORD *)(v6 + 44) = 20;
      sub_1002D040(v6, dword_101A4980[5 * ((v25 >> 10) & 0xF)], v15, 0, 1, v19, v20);
    }
    v29 = ++v12;
  }
  while ( v12 < 12 );
  *(_WORD *)(v6 + 4) = v30;
  *(_WORD *)(v6 + 6) = v31;
  *(_WORD *)(v6 + 36) = v28;
  result = HIWORD(v27);
  *(_WORD *)(v6 + 38) = HIWORD(v28);
  *(_WORD *)(v6 + 48) = v27;
  *(_WORD *)(v6 + 50) = HIWORD(v27);
  return result;
}
// 100DB980: using guessed type __int16 word_100DB980[];
// 101A4980: using guessed type int dword_101A4980[];

//----- (100030A0) --------------------------------------------------------
int __usercall sub_100030A0@<eax>(int a1@<edi>)
{
  int v1; // esi@1
  int v2; // eax@1
  signed int v3; // ecx@1
  bool v4; // al@5
  void *v5; // ecx@7
  int result; // eax@7
  int v7; // [sp+8h] [bp-4h]@3

  v1 = sub_10001550(a1, *(char **)(a1 + 56), 148, 0);
  sub_10001180(a1, 0, 0, 1024, 27, 1);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  *(_BYTE *)(v1 + 14) = 0;
  *(_BYTE *)(v1 + 15) = 0;
  *(_BYTE *)(v1 + 16) = sub_10005280();
  v2 = v1 + 18;
  v3 = 12;
  do
  {
    *(_DWORD *)v2 = 6;
    *(_DWORD *)(v2 + 4) = 16776962;
    *(_WORD *)(v2 + 8) = 255;
    v2 += 10;
    --v3;
  }
  while ( v3 );
  *(_DWORD *)(v1 + 8) = 0;
  *(_WORD *)(v1 + 138) = 12;
  *(_BYTE *)(v1 + 144) = 0;
  sub_10004730(39, &v7);
  *(_BYTE *)(v1 + 3) = (v7 & 0x10) == 16;
  v4 = (v7 & 0x60) == 32 || !(v7 & 0x60);
  *(_BYTE *)(v1 + 2) = v4;
  *(_BYTE *)(v1 + 13) = 1;
  sub_10001CF0(a1, *(_DWORD *)(a1 + 56), -32734);
  result = sub_10002A30(v5);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10003190) --------------------------------------------------------
int __cdecl sub_10003190(int a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  int v3; // esi@1
  unsigned int v4; // ebp@1
  __int16 v5; // di@1
  void *v6; // ecx@2
  char v7; // al@2
  void *v8; // ecx@2
  void *v9; // ecx@8
  void *v10; // ecx@11
  char *v11; // ebx@18
  int v12; // edi@25
  int v13; // eax@26
  _DWORD *v14; // eax@29
  _DWORD *v15; // eax@34
  int result; // eax@37
  int v17; // [sp-8h] [bp-2Ch]@13
  char v18; // [sp+10h] [bp-14h]@1
  __int16 v19; // [sp+12h] [bp-12h]@1
  char v20; // [sp+14h] [bp-10h]@1
  __int16 v21; // [sp+16h] [bp-Eh]@1
  char v22; // [sp+18h] [bp-Ch]@1
  int v23; // [sp+1Ah] [bp-Ah]@1
  int v24; // [sp+1Eh] [bp-6h]@1

  v2 = sub_10005240(v1);
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v4 = 0;
  v5 = sub_10003F40(14);
  v22 = 0;
  LOWORD(v23) = 0;
  BYTE2(v23) = 0;
  LOWORD(v24) = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  if ( *(_BYTE *)(v3 + 16) != sub_10005280() )
  {
    *(_BYTE *)(v3 + 16) = sub_10005280();
    *(_DWORD *)(v3 + 8) = 0;
    v7 = sub_10005690(v6);
    if ( sub_10005FC0(v7, 4) )
      *(_DWORD *)(v3 + 8) = sub_10003F60();
    sub_10002A30(v8);
  }
  if ( *(_BYTE *)(v3 + 144)
    && v2 != 2
    && v2 != 8
    && ((unsigned int)(sub_10003F60() - *(_DWORD *)(v3 + 140)) > 0xAFC8
     || *(_BYTE *)(v3 + 12) == 14 && (unsigned int)(sub_10003F60() - *(_DWORD *)(v3 + 140)) > 0x3A98) )
  {
    if ( sub_10005D40(v9) & 3 || sub_10005300(v10) == 1 )
      v17 = 14;
    else
      v17 = 9;
    sub_10004060(v17, 0x40000000);
    *(_BYTE *)(v3 + 144) = 0;
  }
  if ( v5 != 1 && v5 )
  {
    v11 = (char *)&unk_10045660;
    if ( *(_BYTE *)(v3 + 3) )
      v11 = (char *)&unk_1004569C;
    *(_BYTE *)(v3 + 13) = 1;
    if ( sub_10005DF0(5, 0, 5) )
    {
      if ( *(_BYTE *)(v3 + 2) )
      {
        do
        {
LABEL_25:
          v12 = (int)&v11[12 * v4];
          if ( sub_10005DF0((unsigned __int8)v11[12 * v4], 0, 5) )
          {
            v13 = *(_DWORD *)(v12 + 4);
            *(_DWORD *)(v3 + 128) = *(_DWORD *)v13;
            *(_DWORD *)(v3 + 132) = *(_DWORD *)(v13 + 4);
            *(_WORD *)(v3 + 136) = *(_WORD *)(v13 + 8);
            *(_BYTE *)v3 = *(_BYTE *)(v12 + 8);
            *(_BYTE *)(v3 + 1) = *(_BYTE *)(v12 + 9);
            v4 = 6;
          }
          ++v4;
        }
        while ( v4 < 5 );
LABEL_33:
        if ( byte_101722C8 )
        {
          v15 = &unk_10045648;
          if ( !*(_BYTE *)(v3 + 3) )
            v15 = &unk_1004563C;
          *(_DWORD *)(v3 + 128) = *v15;
          *(_DWORD *)(v3 + 132) = v15[1];
          *(_WORD *)(v3 + 136) = *((_WORD *)v15 + 4);
          *(_BYTE *)v3 = 12;
          *(_BYTE *)(v3 + 1) = 15;
          *(_BYTE *)(v3 + 13) = 0;
          *(_BYTE *)(v3 + 132) = 1;
        }
        goto LABEL_37;
      }
      if ( sub_10005DF0(3, 0, 5) )
      {
        if ( !*(_BYTE *)(v3 + 2) )
          v4 = 2;
        goto LABEL_25;
      }
    }
    v14 = &unk_10045648;
    if ( !*(_BYTE *)(v3 + 3) )
      v14 = &unk_1004563C;
    *(_DWORD *)(v3 + 128) = *v14;
    *(_DWORD *)(v3 + 132) = v14[1];
    *(_WORD *)(v3 + 136) = *((_WORD *)v14 + 4);
    *(_BYTE *)v3 = 19;
    *(_BYTE *)(v3 + 1) = 19;
    if ( sub_10005DF0(3, 1, 5) )
    {
      *(_BYTE *)v3 = 15;
      *(_BYTE *)(v3 + 1) = 1;
      *(_BYTE *)(v3 + 13) = 0;
    }
    goto LABEL_33;
  }
LABEL_37:
  sub_10002AB0(*(_WORD *)(v3 + 138));
  result = sub_100042D0(41111, &v22, 8, &v18);
  if ( !result )
  {
    if ( v22 == 1 )
      result = sub_10002AB0(v23);
    if ( BYTE2(v23) == 1 )
      result = sub_10002AB0(v24);
  }
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 101722C8: using guessed type char byte_101722C8;

//----- (10003440) --------------------------------------------------------
char __cdecl sub_10003440(int a1)
{
  int v1; // esi@1
  int v2; // eax@1
  void *v3; // ecx@1
  void *v4; // ecx@5
  char v5; // al@9

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(_DWORD *)(a1 + 52);
  v3 = (void *)*(_WORD *)v2;
  switch ( v3 )
  {
    case 0x8016u:
      *(_BYTE *)(v1 + 4) = 0;
      break;
    case 0x8015u:
      *(_BYTE *)(v1 + 4) = 1;
      break;
    case 0x8041u:
      LOBYTE(v2) = sub_100030A0(a1);
      break;
    case 0x8048u:
      if ( sub_10005240(v3) != 8 && sub_10005240(v4) != 2 || (LOBYTE(v2) = sub_10005260(v4), (_BYTE)v2) )
        LOBYTE(v2) = sub_100035A0(a1);
      break;
    case 0x806Fu:
      v5 = *(_BYTE *)(v2 + 134);
      *(_BYTE *)(v1 + 12) = v5;
      if ( v5 && (*(_BYTE *)(*(_DWORD *)(a1 + 52) + 8) || v5 != 16) )
      {
        if ( !*(_BYTE *)(v1 + 144) )
        {
          *(_BYTE *)(v1 + 144) = 1;
          *(_DWORD *)(v1 + 140) = sub_10003F60();
        }
      }
      else
      {
        *(_BYTE *)(v1 + 144) = 0;
      }
      LOBYTE(v3) = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 132);
      *(_BYTE *)(v1 + 14) = (_BYTE)v3;
      *(_BYTE *)(v1 + 15) = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 133);
      goto LABEL_16;
    case 0x8022u:
LABEL_16:
      LOBYTE(v2) = sub_10002920(v3, a1);
      break;
    case 0x8078u:
      LOBYTE(v2) = sub_10003190(a1);
      break;
    default:
      return v2;
  }
  return v2;
}

//----- (100035A0) --------------------------------------------------------
char __cdecl sub_100035A0(int a1)
{
  int v1; // eax@1
  int v2; // ebp@1
  int v3; // esi@1
  __int16 v4; // ax@1
  int v5; // ecx@4
  signed int v6; // eax@4
  __int16 v7; // ax@13
  int v8; // eax@17
  int v9; // eax@24
  __int16 v10; // ax@32
  char v12; // [sp+13h] [bp-D1h]@2
  __int16 v13; // [sp+14h] [bp-D0h]@1
  int v14; // [sp+18h] [bp-CCh]@1
  char v15; // [sp+1Ch] [bp-C8h]@1
  char v16; // [sp+1Dh] [bp-C7h]@1
  char v17; // [sp+1Eh] [bp-C6h]@1
  char v18; // [sp+1Fh] [bp-C5h]@1

  v13 = -32617;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v1 = sub_100014E0(a1, (int)sub_10003440);
  v2 = v1;
  v3 = *(_DWORD *)(v1 + 12);
  v4 = sub_10003F40(14);
  if ( v4 == 1 || (v12 = 1, !v4) )
    v12 = 0;
  v5 = *(_DWORD *)(a1 + 52);
  v6 = *(_WORD *)(v5 + 10);
  if ( v6 > 0x2000 )
  {
    if ( v6 == 16454 )
    {
      if ( !*(_BYTE *)(v3 + 14) )
        goto LABEL_17;
      v7 = word_100455E8[2 * *(_BYTE *)(v3 + 15)];
    }
    else
    {
      if ( v6 != 32838 || !*(_BYTE *)(v3 + 14) )
        goto LABEL_17;
      v7 = word_100455EA[2 * *(_BYTE *)(v3 + 15)];
    }
    *(_WORD *)(v5 + 10) = v7;
    goto LABEL_17;
  }
  if ( v6 == 0x2000 )
  {
LABEL_7:
    if ( *(_BYTE *)(v3 + 144) && sub_10005320() )
      *(_DWORD *)(v3 + 140) = sub_10003F60();
  }
  else
  {
    switch ( v6 )
    {
      case 33:
      case 56:
      case 57:
      case 73:
        goto LABEL_7;
      default:
        break;
    }
  }
LABEL_17:
  LOWORD(v8) = *(_WORD *)(*(_DWORD *)(a1 + 52) + 10);
  if ( (unsigned __int16)v8 >= 0x400Fu && (unsigned __int16)v8 <= 0x401Au )
  {
    *(_WORD *)(v3 + 138) = 12;
    LOWORD(v8) = *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) - 16399;
    if ( !*(_BYTE *)(v3 + 10 * (unsigned __int16)v8 + 22) )
    {
      *(_WORD *)(v3 + 138) = v8;
      LOBYTE(v8) = sub_10001CF0(a1, v2, -32648);
    }
    *(_BYTE *)(a1 + 6) = 2;
    return v8;
  }
  if ( (unsigned __int16)v8 < 0x800Fu || (unsigned __int16)v8 > 0x801Au )
  {
    if ( !v12 || (_WORD)v8 != 26 || *(_BYTE *)(v3 + 132) )
      return v8;
    v10 = *(_WORD *)(v3 + 128);
    if ( v10 == 6997 || v10 == 1264 )
    {
      v17 = 1;
      v18 = 1;
    }
    else if ( !sub_10005DF0(2, 0, 5) && !sub_10005DF0(4, 0, 5) )
    {
      if ( sub_10005DF0(3, 0, 5) )
        v15 = 1;
      goto LABEL_40;
    }
    v16 = 1;
LABEL_40:
    LOBYTE(v8) = sub_10004090(1, (int)&v13, 60000, 1);
    return v8;
  }
  *(_WORD *)(v3 + 138) = 12;
  v9 = (unsigned __int16)(*(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + 32753);
  if ( !*(_BYTE *)(v3 + 10 * v9 + 22) && (*(_BYTE *)(v3 + 10 * v9 + 21) != 1 || *(_BYTE *)(v3 + 2 * (5 * v9 + 10))) )
    sub_10001CF0(a1, v2, -32648);
  *(_BYTE *)(a1 + 6) = 2;
  v8 = sub_10003F60();
  *(_DWORD *)(v3 + 140) = v8;
  return v8;
}
// 100455E8: using guessed type __int16 word_100455E8[];
// 100455EA: using guessed type __int16 word_100455EA[];

//----- (10003830) --------------------------------------------------------
char __cdecl sub_10003830(char a1)
{
  return sub_1002D020(a1, -122);
}

//----- (10003850) --------------------------------------------------------
char sub_10003850()
{
  sub_1002E070();
  return sub_10003830(0);
}

//----- (10003860) --------------------------------------------------------
int __cdecl sub_10003860(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = *(_DWORD *)(a1 + 52);
  result = *(_WORD *)v1 - 32829;
  if ( *(_WORD *)v1 == 32829 )
  {
    byte_101722C8 = *(_BYTE *)(v1 + 8);
  }
  else
  {
    result = *(_WORD *)v1 - 32885;
    if ( *(_WORD *)v1 == 32885 )
    {
      a1 = *(_BYTE *)(v1 + 8);
      sub_10004340(3190, (int)&a1, 1);
      result = sub_10006080(a1);
    }
  }
  return result;
}
// 101722C8: using guessed type char byte_101722C8;

//----- (100038A0) --------------------------------------------------------
char sub_100038A0()
{
  return 0;
}

//----- (100038C0) --------------------------------------------------------
char __cdecl sub_100038C0(int a1)
{
  int v1; // eax@1
  bool v2; // zf@1
  __int16 v4; // [sp+4h] [bp-D0h]@1
  int v5; // [sp+8h] [bp-CCh]@1

  v1 = sub_100014E0(a1, (int)sub_10003440);
  v2 = **(_WORD **)(a1 + 52) == -32749;
  v5 = v1;
  v4 = !v2 - 32747;
  return sub_10001650(a1, (int)&v4, 204);
}

//----- (10003930) --------------------------------------------------------
char __cdecl sub_10003930(int a1)
{
  __int16 v2; // [sp+4h] [bp-D0h]@1
  int v3; // [sp+8h] [bp-CCh]@1
  char (__cdecl *v4)(int); // [sp+Ch] [bp-C8h]@1

  ++*(_BYTE *)(a1 + 4);
  v2 = -32703;
  v3 = 0;
  v4 = sub_10003440;
  sub_10001650(a1, (int)&v2, 204);
  **(_WORD **)(a1 + 52) = -32671;
  return sub_10003440(a1);
}

//----- (100039C0) --------------------------------------------------------
#error "100039D9: call analysis failed (funcsize=25)"

//----- (10003A30) --------------------------------------------------------
int __cdecl sub_10003A30(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_bitblt(&v8, a2, a3, a7, a1, a4, a5, a6);
}
// 1002F922: using guessed type int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10003A80) --------------------------------------------------------
int __cdecl sub_10003A80(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_draw_pixels(&v8, a5, a4, a7, a6, a3, a1, a2);
}
// 1002F928: using guessed type int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10003AD0) --------------------------------------------------------
int sub_10003AD0()
{
  gdi_pvg_init();
  return sub_10003E70();
}
// 1002F92E: using guessed type int gdi_pvg_init(void);

//----- (10003B20) --------------------------------------------------------
int __cdecl sub_10003B20(float a1, float a2, float a3, float a4, float a5, float a6)
{
  float v7; // [sp+0h] [bp-18h]@1

  return gdi_pvg_ortho(&v7, LODWORD(a4), LODWORD(a6), LODWORD(a1), LODWORD(a5), LODWORD(a2), LODWORD(a3));
}
// 1002F94C: using guessed type int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10003B80) --------------------------------------------------------
char *__cdecl sub_10003B80(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_10003EF0();
  *(_DWORD *)(a5 + 596) = sub_10003F60();
  sub_10003F80((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_10005C10(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_10008BD0((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (10003CB0) --------------------------------------------------------
char sub_10003CB0()
{
  char result; // al@1

  result = 0;
  byte_100C90B0 = 0;
  byte_100C90B1 = 0;
  return result;
}
// 100C90B0: using guessed type char byte_100C90B0;
// 100C90B1: using guessed type char byte_100C90B1;

//----- (10003CC0) --------------------------------------------------------
char __cdecl sub_10003CC0(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_10003B80(-5, a1, a2, a4, a5);
  else
    sub_10003B80(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_10005D00((const char *)(a5 + 485), " DBGA", 100);
  sub_10003F80((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_100C90B0 )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_100C90B1 )
LABEL_15:
      result = sub_10003FC0(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 100047B0: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 100C90B0: using guessed type char byte_100C90B0;
// 100C90B1: using guessed type char byte_100C90B1;

//----- (10003DC0) --------------------------------------------------------
char __cdecl sub_10003DC0(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_10003CC0(a1, a2, a3, a4, (int)&v5);
}

//----- (10003E30) --------------------------------------------------------
int __cdecl sub_10003E30(int a1, int a2, int a3)
{
  dword_100C90C8 = a1;
  dword_100C90BC = a2;
  dword_100C90C0 = a3;
  return gdi_pvg_create_window(&dword_100C90B4);
}
// 1002F95E: using guessed type int __cdecl gdi_pvg_create_window(_DWORD);
// 100C90B4: using guessed type int dword_100C90B4;
// 100C90BC: using guessed type int dword_100C90BC;
// 100C90C0: using guessed type int dword_100C90C0;
// 100C90C8: using guessed type int dword_100C90C8;

//----- (10003E70) --------------------------------------------------------
int sub_10003E70()
{
  int result; // eax@1

  result = 0;
  dword_100C90C8 = 0;
  dword_100C90BC = 0;
  dword_100C90C0 = 59;
  dword_100C90B4 = 1;
  dword_100C90B8 = 0;
  dword_100C90C4 = 0;
  return result;
}
// 100C90B4: using guessed type int dword_100C90B4;
// 100C90B8: using guessed type int dword_100C90B8;
// 100C90BC: using guessed type int dword_100C90BC;
// 100C90C0: using guessed type int dword_100C90C0;
// 100C90C4: using guessed type int dword_100C90C4;
// 100C90C8: using guessed type int dword_100C90C8;

//----- (10003EC0) --------------------------------------------------------
int __cdecl sub_10003EC0(int a1)
{
  int result; // eax@1

  result = a1;
  dword_100C90B4 = a1;
  return result;
}
// 100C90B4: using guessed type int dword_100C90B4;

//----- (10003ED0) --------------------------------------------------------
int __cdecl sub_10003ED0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002F976: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (10003EF0) --------------------------------------------------------
int sub_10003EF0()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002F97C: using guessed type int TSK_pvg_get_id(void);

//----- (10003F10) --------------------------------------------------------
int __cdecl sub_10003F10(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002F982: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (10003F40) --------------------------------------------------------
__int16 __cdecl sub_10003F40(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002F988: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (10003F60) --------------------------------------------------------
int sub_10003F60()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002F98E: using guessed type int TSK_pvg_get_timer(void);

//----- (10003F80) --------------------------------------------------------
int __cdecl sub_10003F80(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002F994: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10003FC0) --------------------------------------------------------
int __cdecl sub_10003FC0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002F9A0: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10003FF0) --------------------------------------------------------
int __cdecl sub_10003FF0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_proc_status(a1);
  SYS_exit_krnl();
  return v1;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002F9A6: using guessed type int __cdecl TSK_pvg_proc_status(_DWORD);

//----- (10004010) --------------------------------------------------------
int __cdecl sub_10004010(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002F9AC: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (10004030) --------------------------------------------------------
int __cdecl sub_10004030(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002F9B2: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (10004060) --------------------------------------------------------
int __cdecl sub_10004060(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_evnt(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002F9B8: using guessed type int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD);

//----- (10004090) --------------------------------------------------------
int __cdecl sub_10004090(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_send_msg(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002F9BE: using guessed type int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100040C0) --------------------------------------------------------
int __cdecl sub_100040C0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002F9C4: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (100040F0) --------------------------------------------------------
int __cdecl sub_100040F0(int a1)
{
  SYS_enter_krnl();
  TSK_pvg_set_proc_status(a1);
  return SYS_exit_krnl();
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002F9CA: using guessed type int __cdecl TSK_pvg_set_proc_status(_DWORD);

//----- (10004110) --------------------------------------------------------
int __cdecl sub_10004110(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002F9D0: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (10004130) --------------------------------------------------------
char __cdecl sub_10004130(int a1, int a2)
{
  unsigned int v2; // esi@1
  char result; // al@4

  v2 = a2 + sub_10003F60();
  if ( sub_10003FF0(a1) == 5 )
    goto LABEL_4;
  while ( sub_10003F60() < v2 )
  {
    sub_10004110(20);
    if ( sub_10003FF0(a1) == 5 )
      goto LABEL_4;
  }
  if ( sub_10003FF0(a1) == 5 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    sub_10003DC0("..\\lib\\acl\\tsk\\tsk_usr.c", 1769, 0, 0);
    result = 0;
  }
  return result;
}

//----- (100041A0) --------------------------------------------------------
int __cdecl sub_100041A0(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_10003EF0();
    sub_10003F80((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002F9D6: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (100041E0) --------------------------------------------------------
int __cdecl sub_100041E0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_10004010(a2);
  return result;
}
// 10048ACC: using guessed type void *tsk_app_hdr_ptr;

//----- (10004210) --------------------------------------------------------
int __cdecl sub_10004210(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_10004030(a1, a2);
  return result;
}
// 10048ACC: using guessed type void *tsk_app_hdr_ptr;

//----- (10004230) --------------------------------------------------------
int __cdecl sub_10004230(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = 0;
  result = 42066;
  while ( dword_1004B7B0[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xA5 )
      return result;
  }
  return dword_1004B7B4[2 * v1];
}
// 1004B7B0: using guessed type int dword_1004B7B0[];
// 1004B7B4: using guessed type int dword_1004B7B4[];

//----- (10004270) --------------------------------------------------------
int __cdecl sub_10004270(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 1002F9DC: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004290) --------------------------------------------------------
char __cdecl sub_10004290(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_10004270(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10003DC0("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (100042D0) --------------------------------------------------------
int __cdecl sub_100042D0(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_10004270(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (10004310) --------------------------------------------------------
int __cdecl sub_10004310(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_10004270(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (10004340) --------------------------------------------------------
int __cdecl sub_10004340(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 1002F9E2: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004360) --------------------------------------------------------
int __cdecl sub_10004360(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@2
  int result; // eax@4
  int v6; // [sp+10h] [bp-4h]@1

  v6 = sub_10004340(a1, a2, a3);
  v3 = 0;
  if ( (unsigned __int8)sub_100047D0() )
  {
    v4 = sub_10004230(a1);
    if ( v4 != 42066 )
      v3 = sub_10004340(v4, a2, a3);
  }
  result = v6;
  if ( !v6 )
    result = v3;
  return result;
}
// 100047D0: using guessed type int sub_100047D0(void);

//----- (100043C0) --------------------------------------------------------
int __cdecl sub_100043C0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_10004360(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    sub_10003DC0("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1742, 1, 0);
    result = v4;
  }
  return result;
}

//----- (10004400) --------------------------------------------------------
int __cdecl sub_10004400(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_10004270(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    sub_10004340(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (10004460) --------------------------------------------------------
signed int __cdecl sub_10004460(unsigned int a1)
{
  signed int result; // eax@7
  int v2; // eax@8
  int v3; // edx@9
  unsigned int v4; // [sp+4h] [bp+4h]@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return FIL_vfs_close();
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_10015B00(a1);
    if ( v4 && *(_DWORD *)(v4 + 732) )
    {
      --*(_DWORD *)(*(_DWORD *)(v4 + 732) + 124);
      if ( *(_BYTE *)(v4 + 8) )
        exit_1(v4);
      sub_100282D0(v4 + 116);
      result = 0;
      *(_DWORD *)v4 = -858993460;
    }
    else
    {
      result = -6;
    }
    return result;
  }
  if ( !a1 || (a1 & 3) != 2 )
    return FIL_vfs_close();
  v2 = 0;
  if ( !dword_100DB938 )
    goto LABEL_11;
  while ( 1 )
  {
    v3 = dword_100DB940[v2];
    if ( *(_DWORD *)v3 == a1 )
      break;
    if ( ++v2 >= (unsigned int)dword_100DB938 )
      goto LABEL_11;
  }
  if ( v2 != -1 )
  {
    sub_100047E0(
      v2,
      *(_DWORD *)(dword_100DB940[v2] + 12),
      *(_DWORD *)(v3 + 16),
      *(_BYTE *)(v3 + 32),
      *(_WORD *)(v3 + 20),
      *(_DWORD *)(v3 + 4));
    result = sub_10004460(a1 & 0xFFFFFFFC);
  }
  else
  {
LABEL_11:
    result = -6;
  }
  return result;
}
// 1002F9EE: using guessed type int FIL_vfs_close(void);
// 100DB938: using guessed type int dword_100DB938;
// 100DB940: using guessed type int dword_100DB940[];

//----- (100044C0) --------------------------------------------------------
int __cdecl sub_100044C0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 1002FA00: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004530) --------------------------------------------------------
signed int __cdecl sub_10004530(unsigned int a1, void *a2, int a3)
{
  int v3; // eax@7
  unsigned int v4; // eax@4
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_10015B00(a1);
    return sub_100169C0(v4, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v3 = sub_100046F0(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_10004B80(a1, a2, a3, v3, (unsigned __int64)v3 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 1002FA12: using guessed type int FIL_vfs_read(void);

//----- (10004570) --------------------------------------------------------
signed int __cdecl sub_10004570(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_10008C40(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_10004B80(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 1002FA18: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004600) --------------------------------------------------------
signed int __cdecl sub_10004600(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_10008CA0(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 1002FA24: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004650) --------------------------------------------------------
__int64 __cdecl sub_10004650(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 1002FA2A: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (10004670) --------------------------------------------------------
int __cdecl sub_10004670(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 1002FA30: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (100046A0) --------------------------------------------------------
int __cdecl sub_100046A0(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 1002FA3C: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100046C0) --------------------------------------------------------
char __cdecl sub_100046C0(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_10004460(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10004520: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (100046F0) --------------------------------------------------------
signed int __cdecl sub_100046F0(unsigned int a1, int a2, int a3)
{
  return sub_10004600(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (10004710) --------------------------------------------------------
int __cdecl sub_10004710(int a1, int a2, int a3)
{
  return sub_10004670(a1, a2, a3);
}

//----- (10004730) --------------------------------------------------------
void __cdecl sub_10004730(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_10004CD0(a1, a2);
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002FA42: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (10004760) --------------------------------------------------------
int __cdecl sub_10004760(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_set(a1, a2);
  return SYS_exit_krnl();
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002FA48: using guessed type int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD);

//----- (100047E0) --------------------------------------------------------
unsigned int __cdecl sub_100047E0(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_100DB940[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_100DB8F8[a1];
  dword_100DB8F8[a1] = a3 + v9;
  dword_100DB8B8[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_100DB8B8[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 100DB8F8: using guessed type int dword_100DB8F8[];
// 100DB940: using guessed type int dword_100DB940[];

//----- (10004990) --------------------------------------------------------
int __usercall sub_10004990@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_100DB940[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_100DB940[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 100DB940: using guessed type int dword_100DB940[];

//----- (10004A40) --------------------------------------------------------
int __cdecl sub_10004A40(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_10004990(a1);
  v3 = &dword_100DB940[a1];
  v4 = sub_10004570(
         *(_DWORD *)dword_100DB940[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_100DB940[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_100DB8F8[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 100DB8F8: using guessed type int dword_100DB8F8[];
// 100DB940: using guessed type int dword_100DB940[];

//----- (10004AF0) --------------------------------------------------------
int __usercall sub_10004AF0@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_100DB940[a1];
  v3 = (int *)(dword_100DB8F8[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_100DB940[a1] + 32)) % *(_WORD *)(dword_100DB940[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_10004A40(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 100DB8F8: using guessed type int dword_100DB8F8[];
// 100DB940: using guessed type int dword_100DB940[];

//----- (10004B80) --------------------------------------------------------
unsigned int __cdecl sub_10004B80(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  unsigned int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_100DB938 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_100DB940[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_100DB938 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_10004030(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_100DB940[v6] + 28);
        v12 = sub_10004AF0(v6, (unsigned int)v7 & *(_DWORD *)(dword_100DB940[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_100DB940[v6] + 4) != 138 )
        sub_10004010(*(_DWORD *)(dword_100DB940[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_100DB940[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_10004010(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 100DB938: using guessed type int dword_100DB938;
// 100DB940: using guessed type int dword_100DB940[];

//----- (10004CD0) --------------------------------------------------------
void __cdecl sub_10004CD0(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_10005200(v2) && sub_10005300(v3) != 1 )
    *a2 = 0;
}

//----- (10004D00) --------------------------------------------------------
char __usercall sub_10004D00@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3)
{
  signed int v3; // ebx@1
  char result; // al@1
  char v5; // al@2
  char v6; // [sp+Bh] [bp-5h]@1
  char v7; // [sp+Ch] [bp-4h]@2
  char v8; // [sp+Dh] [bp-3h]@1

  v3 = a1;
  result = 0;
  v6 = 0;
  v8 = 0;
  if ( a1 <= (signed int)a3 )
  {
    do
    {
      v7 = v3;
      v5 = sub_1002CFE0(a2, &v7, 0);
      if ( v5 > v6 )
        v6 = v5;
      ++v3;
    }
    while ( v3 <= a3 );
    result = v6;
  }
  return result;
}

//----- (10004D50) --------------------------------------------------------
int sub_10004D50()
{
  void *v0; // ebx@1
  unsigned __int8 v1; // al@2
  int *v2; // esi@2
  unsigned __int8 v3; // al@2
  int v4; // eax@2
  char v5; // al@2
  int v6; // edi@2
  char v7; // al@2
  int v8; // edi@2
  unsigned __int8 v9; // al@2
  int result; // eax@2

  v0 = &unk_1004C99C;
  do
  {
    v1 = *(_BYTE *)v0;
    v2 = &dword_101A4980[5 * ((*((_DWORD *)v0 - 1) >> 10) & 0xF)];
    *((_BYTE *)v2 + 12) = *(_BYTE *)v0;
    *v2 = FNT_get_fnt_hdr(v1);
    v3 = *((_BYTE *)v0 + 1);
    *((_BYTE *)v2 + 13) = v3;
    v4 = FNT_get_fnt_hdr(v3);
    v2[1] = v4;
    v5 = sub_1002CFE0(v4, ".", 0);
    v6 = v2[1];
    *((_BYTE *)v2 + 15) = v5;
    v7 = sub_10004D00(0x20u, v6, 0x5Fu);
    v8 = v2[1];
    *((_BYTE *)v2 + 16) = v7;
    *((_BYTE *)v2 + 17) = sub_10004D00(0x30u, v8, 0x39u);
    v9 = *((_BYTE *)v0 + 2);
    *((_BYTE *)v2 + 14) = v9;
    result = FNT_get_fnt_hdr(v9);
    v0 = (char *)v0 + 8;
    v2[2] = result;
  }
  while ( (signed int)v0 < (signed int)"EFGHJKLMPQRS" );
  return result;
}
// 1002BE84: using guessed type int __cdecl FNT_get_fnt_hdr(_DWORD);
// 101A4980: using guessed type int dword_101A4980[];

//----- (10004DF0) --------------------------------------------------------
int sub_10004DF0()
{
  int v0; // ebx@1
  void *v1; // esi@1
  int result; // eax@2

  memset(byte_100DB9A8, 127, 0x100u);
  v0 = 0;
  v1 = &unk_1004CF35;
  do
  {
    LOBYTE(result) = j_HWM_pvg_get_color(*((char *)v1 - 1), *(_BYTE *)v1, *((_BYTE *)v1 + 1));
    word_100DB980[v0] = (unsigned __int8)result;
    result = (unsigned __int8)result;
    byte_100DB9A8[(unsigned __int8)result] = v0;
    v1 = (char *)v1 + 3;
    ++v0;
  }
  while ( (signed int)v1 < (signed int)&unk_1004CF6E );
  return result;
}
// 10004790: using guessed type int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD);
// 100DB980: using guessed type __int16 word_100DB980[];

//----- (10004E50) --------------------------------------------------------
_DWORD *__cdecl sub_10004E50(_DWORD *a1)
{
  _DWORD *result; // eax@1

  result = a1;
  *a1 = 0;
  return result;
}

//----- (10004E60) --------------------------------------------------------
int __cdecl sub_10004E60(int *a1, int a2)
{
  int result; // eax@1
  int i; // esi@1

  result = (int)a1;
  for ( i = *a1; i; i = *(_DWORD *)(i + 4) )
    result = (*(int (__cdecl **)(int, int))i)(i, a2);
  return result;
}

//----- (10004E90) --------------------------------------------------------
_DWORD *__cdecl sub_10004E90(_DWORD *a1, int a2)
{
  _DWORD *result; // eax@1

  result = a1;
  *(_DWORD *)(a2 + 4) = *a1;
  *a1 = a2;
  return result;
}

//----- (10004EA0) --------------------------------------------------------
char __cdecl sub_10004EA0(int a1, _WORD *a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( *a2 == -32665 || !*(_BYTE *)(a1 + 5) && a3 && *(_DWORD *)(a1 + 48) == a3 )
    result = 1;
  return result;
}

//----- (10004ED0) --------------------------------------------------------
bool __cdecl sub_10004ED0(char *a1, int *a2, _DWORD *a3)
{
  int v3; // ecx@1
  bool v4; // zf@1
  int v5; // eax@2

  v3 = *(_DWORD *)a1 & 0xFF;
  v4 = v3 == 141;
  if ( v3 != 141 )
  {
    v5 = (int)&a1[dword_101A4504[8 * v3]];
    if ( a2 )
      *a2 = v5;
    if ( a3 )
      *a3 = v5 + 4;
    v4 = v3 == 141;
  }
  return !v4;
}

//----- (10004F20) --------------------------------------------------------
char __cdecl sub_10004F20(int a1, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // ebp@3
  signed int v5; // ebx@3
  char result; // al@3
  _WORD *v7; // ST2C_4@6

  v3 = a2;
  if ( !a2 )
    sub_10003DC0("..\\lib\\adl\\cdp_fld_utl.c", 323, 1, a2);
  v4 = *(_DWORD *)(a1 + 56);
  v5 = (unsigned __int8)v3[230];
  result = 1;
  if ( (*(_BYTE *)(v4 + 26) || v4 != *(_DWORD *)(a1 + 48)) && v5 < (unsigned __int8)v3[68] )
  {
    v7 = (_WORD *)a3;
    *(_DWORD *)(a1 + 56) = v3;
    *(_BYTE *)(a1 + 3) = sub_10004EA0(a1, v7, (int)v3);
    sub_10004ED0(*(char **)(*((_DWORD *)v3 + 14) + 4 * v5), (int *)&a2, 0);
    sub_100012C0(a1, (int)v3);
    result = ((int (__cdecl *)(int, _DWORD, char *, _DWORD, int))dword_101A4500[2
                                                                              * (**(_DWORD **)(*((_DWORD *)v3 + 14)
                                                                                             + 4 * v5) & 0xFF)])(
               a1,
               *(_DWORD *)(*((_DWORD *)v3 + 14) + 4 * v5),
               a2,
               *(_DWORD *)(*((_DWORD *)v3 + 15) + 4 * v5),
               a3);
    *(_DWORD *)(a1 + 56) = v4;
    *(_BYTE *)(a1 + 3) = 0;
  }
  return result;
}
// 101A4500: using guessed type int dword_101A4500[];

//----- (10004FD0) --------------------------------------------------------
int __cdecl sub_10004FD0(int a1)
{
  int v1; // eax@1
  int v2; // esi@1
  char v4; // [sp+4h] [bp-68h]@3

  v1 = sub_10008CF0(&a1, 4u, (int)&unk_1004E0D8, 8, 20, -1);
  v2 = v1;
  if ( v1 < 0 || (unsigned int)v1 >= 0x14 )
  {
    sprintf(&v4, "UNKNOWN EVENT %lu\n", a1);
    sub_10003DC0(".\\cdp_evnt_map.c", 328, 1, &v4);
  }
  return (int)*(&off_1004E0DC + 2 * v2);
}
// 1004E0DC: using guessed type void *off_1004E0DC;

//----- (10005050) --------------------------------------------------------
int sub_10005050()
{
  return dword_101A4A74 + 30388;
}
// 101A4A74: using guessed type int dword_101A4A74;

//----- (10005060) --------------------------------------------------------
bool __thiscall sub_10005060(void *this)
{
  int v1; // eax@2
  bool result; // al@2
  unsigned __int16 v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@1

  LOBYTE(v4) = sub_10005690(this);
  v5 = 2;
  sub_100042D0(9129, &v3, 2, &v5);
  if ( sub_10005FC0(v4, 4) )
  {
    v1 = sub_10008CF0(&v4, 1u, (int)&unk_1004E8E0, 8, 2, 2);
    result = (v3 & (unsigned __int16)word_1004E8E4[4 * v1]) != 0;
  }
  else
  {
    result = sub_10005FC0(v4, 2) || sub_10006040(6) || sub_10006040(8) || sub_10005FC0(v4, 12) || sub_10005FC0(v4, 16);
  }
  return result;
}
// 1004E8E4: using guessed type __int16 word_1004E8E4[];

//----- (10005130) --------------------------------------------------------
int sub_10005130()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v1 = 0;
  sub_10004400(3012, &v2, 4, &v1);
  return v2;
}

//----- (10005160) --------------------------------------------------------
char __cdecl sub_10005160(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002FA66: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);

//----- (10005180) --------------------------------------------------------
int __cdecl sub_10005180(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_10003DC0("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_10003DC0("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002FA6C: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (100051E0) --------------------------------------------------------
char __thiscall sub_100051E0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10005180(18, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10005200) --------------------------------------------------------
char __thiscall sub_10005200(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10005180(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10005220) --------------------------------------------------------
char __thiscall sub_10005220(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10005180(32, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10005240) --------------------------------------------------------
char __thiscall sub_10005240(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10005180(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10005260) --------------------------------------------------------
char __thiscall sub_10005260(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10005180(43, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10005280) --------------------------------------------------------
bool sub_10005280()
{
  void *v0; // ecx@1
  char v1; // bl@1
  void *v2; // ecx@3
  bool result; // al@4
  char v4; // [sp+Ch] [bp-4h]@1

  v4 = j_HWM_pvg_hsdb_get_lrus_online();
  v1 = sub_10005690(v0);
  if ( sub_10005FC0(v1, 2) || sub_10005FC0(v1, 18) )
    goto LABEL_12;
  if ( sub_10005FC0(v1, 4) )
    return sub_10005060(v2);
  if ( sub_10005FC0(v1, 6) && (!v1 || !(v4 & 4)) )
LABEL_12:
    result = 1;
  else
    result = 0;
  return result;
}
// 100047A0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);

//----- (10005300) --------------------------------------------------------
char __thiscall sub_10005300(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10005180(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10005320) --------------------------------------------------------
char sub_10005320()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 0;
  sub_10005180(48, &v1);
  return v1;
}

//----- (10005340) --------------------------------------------------------
char __cdecl sub_10005340(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10005380) --------------------------------------------------------
char __cdecl sub_10005380(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_10003DC0("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (100053F0) --------------------------------------------------------
signed int __cdecl sub_100053F0(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_10003DC0("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10005470) --------------------------------------------------------
char __cdecl sub_10005470(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_10003DC0("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (100054E0) --------------------------------------------------------
char __cdecl sub_100054E0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_10003DC0("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10005590) --------------------------------------------------------
char __cdecl sub_10005590(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_10003DC0("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10005690) --------------------------------------------------------
char __thiscall sub_10005690(void *this)
{
  int v1; // eax@1

  v1 = sub_10005D40(this);
  return sub_10005590(v1);
}

//----- (100056A0) --------------------------------------------------------
int __cdecl sub_100056A0(int *a1)
{
  int result; // eax@1

  result = sub_1000ADC0((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_10003F60();
    result = sub_1000AC00();
  }
  return result;
}

//----- (100056D0) --------------------------------------------------------
char __usercall sub_100056D0@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_10004030(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_1000BE80("%i %i\r\n", 13, v2);
    sub_1000B420(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"356", (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    v5 = sub_10004010(*(_DWORD *)(a1 + 4));
    v6 = sub_1000BE80("%i %i\r\n", 14, v5);
    sub_1000B420(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_1004F2AC, (int)v6);
    result = 1;
  }
  else
  {
    sub_10003DC0(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}

//----- (10005770) --------------------------------------------------------
int __cdecl sub_10005770(const char *a1)
{
  int result; // eax@1

  result = sub_10008F20();
  if ( a1 )
    result = sub_1000ADF0(dword_100DBAA8[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 100DBAA8: using guessed type int dword_100DBAA8[];

//----- (100057B0) --------------------------------------------------------
char __cdecl sub_100057B0(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_1000AD40((char *)a1 + 4);
  v1 = sub_100117A0();
  sub_1000ACE0((int)v1, 0, 0);
  dword_100DBAA8[sub_10008F20()] = (int)a1;
  v2 = sub_10011760((int)sub_10005770);
  return sub_1000AE10(v2);
}
// 100DBAA8: using guessed type int dword_100DBAA8[];

//----- (10005800) --------------------------------------------------------
signed int __cdecl sub_10005800(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_10003F60();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_10004110(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_10003F60() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_100041A0(&v23);
          }
          while ( sub_10003F60() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_10003F40(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_10003F80((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_1000BE80("The %s task is loaded.", &v24);
            sub_1000B420(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_1000BE80("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_1000B420(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_1000BE80("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_1000B420(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_1000BE80(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_1000B420(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_10003ED0(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_1000BE80("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_1000B420(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_1000BE80("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_1000B420(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_1000B420(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_10003FC0(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_10011760((int)sub_10005770);
        sub_1000B4F0((int)v15);
        v16 = sub_10012B40((int)sub_10005770);
        sub_1000B4F0((int)v16);
        v17 = sub_10012B40((int)sub_10005770);
        sub_1000AE10(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_10011760((int)sub_10005770);
        sub_1000B4F0((int)v18);
        v19 = sub_10012B40((int)sub_10005770);
        sub_1000B4F0((int)v19);
        v20 = sub_10011760((int)sub_10005770);
        sub_1000AE10(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_100056D0(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (10005BA0) --------------------------------------------------------
char **sub_10005BA0()
{
  return off_1004F298;
}
// 1004F298: using guessed type char *off_1004F298[3];

//----- (10005BC0) --------------------------------------------------------
int __cdecl sub_10005BC0(int a1)
{
  int result; // eax@1

  result = a1;
  dword_100DBABC = a1;
  return result;
}
// 100DBABC: using guessed type int dword_100DBABC;

//----- (10005BD0) --------------------------------------------------------
int __cdecl sub_10005BD0(int a1)
{
  int result; // eax@1

  result = a1;
  dword_100DBAC0 = a1;
  return result;
}
// 100DBAC0: using guessed type int dword_100DBAC0;

//----- (10005BE0) --------------------------------------------------------
#error "10005BE5: call analysis failed (funcsize=28)"

//----- (10005C10) --------------------------------------------------------
int __cdecl sub_10005C10(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (10005C60) --------------------------------------------------------
int __cdecl sub_10005C60(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (10005C90) --------------------------------------------------------
int __cdecl sub_10005C90(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10005CD0) --------------------------------------------------------
int sub_10005CD0(char *a1, size_t a2, char *a3, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, a3);
  result = sub_10005C90(a1, a2, a3, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (10005D00) --------------------------------------------------------
int __cdecl sub_10005D00(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_10005C10((int)&a1[v3], a2, a3 - v3);
}

//----- (10005D40) --------------------------------------------------------
int __thiscall sub_10005D40(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10005180(46, (char *)&v2);
  return (int)v2;
}

//----- (10005D60) --------------------------------------------------------
int __cdecl sub_10005D60(unsigned __int16 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 > 0x1C8Au && a1 < 0x1C8Bu )
    result = (unsigned __int16)(a1 - 7307);
  return result;
}

//----- (10005D80) --------------------------------------------------------
char *__cdecl sub_10005D80(unsigned __int16 a1)
{
  bool v1; // cf@1
  bool v2; // zf@1
  char *result; // eax@1

  v1 = a1 < 0x1C8Au;
  v2 = a1 == 7306;
  result = (char *)&unk_10051130;
  if ( a1 < 0x1C8Au )
  {
    if ( a1 != -1 )
      return (char *)TXT_get_static_string();
    v1 = 0;
    v2 = 0;
  }
  if ( !v1 && !v2 && a1 < 0x1C8Bu )
    result = &byte_101A4A78[(unsigned __int16)sub_10005D60(a1)];
  return result;
}
// 1002BE8A: using guessed type int TXT_get_static_string(void);

//----- (10005DC0) --------------------------------------------------------
char __cdecl sub_10005DC0(char a1)
{
  char v1; // bl@1
  char result; // al@4

  v1 = a1;
  sub_10004730(69, &a1);
  if ( a1 && (v1 == 15 || v1 == 13) )
    result = 17;
  else
    result = v1;
  return result;
}

//----- (10005DF0) --------------------------------------------------------
__int16 __cdecl sub_10005DF0(int a1, int a2, int a3)
{
  __int16 v3; // si@1

  SYS_enter_krnl();
  v3 = SYS_pvg_alrt_cnt(a1, a2, a3, 0);
  SYS_exit_krnl();
  return v3;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 1002FA72: using guessed type int __cdecl SYS_pvg_alrt_cnt(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10005E70) --------------------------------------------------------
char __thiscall sub_10005E70(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_100DBAE8 = sub_10005240(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_100DBAF0, 0, 0x1540u);
  memset(&unk_100DD030, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_100DBAF0;
  do
  {
    sub_10013F70(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_100DD030 );
  v3 = 0;
  v4 = &unk_100DD030;
  do
  {
    result = sub_10013FF0(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)&unk_100DE9E0 );
  return result;
}
// 100DBAE8: using guessed type int dword_100DBAE8;

//----- (10005F00) --------------------------------------------------------
char __cdecl sub_10005F00(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_100DBAE8 != 1379255385;
  v7 = 0;
  v8 = dword_100DBAE8 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10004210(86, 10);
      memset((char *)&unk_100DBAF0 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10013F70(a1, (int)&unk_100DBAF0 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_100DBDC8[v6] == a2 || byte_100DBDC9[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_100041E0(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100DBAE8: using guessed type int dword_100DBAE8;

//----- (10005FC0) --------------------------------------------------------
char __cdecl sub_10005FC0(char a1, char a2)
{
  unsigned __int8 v2; // bl@1
  unsigned __int8 v4; // [sp+8h] [bp-8h]@1
  char v5; // [sp+Ch] [bp-4h]@2

  v2 = 0;
  v4 = 0;
  while ( 1 )
  {
    sub_10013770(a1, v4, (int)&v5);
    if ( v5 == a2 )
      break;
    v4 = ++v2;
    if ( v2 >= 2u )
      return 0;
  }
  return 1;
}

//----- (10006010) --------------------------------------------------------
char __cdecl sub_10006010(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10005F00(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (10006040) --------------------------------------------------------
char __cdecl sub_10006040(char a1)
{
  char result; // al@1
  unsigned __int8 v2; // bl@1
  char v3; // [sp+8h] [bp-4h]@1

  result = 0;
  v2 = 0;
  v3 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10005FC0(v3, a1);
    v3 = ++v2;
  }
  while ( v2 < 3u );
  return result;
}

//----- (10006080) --------------------------------------------------------
int __cdecl sub_10006080(char a1)
{
  int result; // eax@2
  char v2; // [sp+0h] [bp-Ch]@2

  if ( a1 )
  {
    sub_10004310(2015, (int)&v2, 12);
    result = sub_10004340(2101, (int)&v2, 12);
  }
  return result;
}

//----- (100060E0) --------------------------------------------------------
int __cdecl sub_100060E0(char *a1, char *a2)
{
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  char v4; // al@2
  int result; // eax@4

  v2 = strstr(a1, a2);
  v3 = strlen(a2);
  result = 0;
  if ( v2 )
  {
    v4 = v2[v3];
    if ( !v4 || v4 == 44 )
      result = 1;
  }
  return result;
}

//----- (10006120) --------------------------------------------------------
void *__usercall sub_10006120@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@0
  int v5; // [sp+4h] [bp-8h]@0
  int v6; // [sp+8h] [bp-4h]@0

  result = (void *)sub_10004270(v4, v5, v6);
  if ( a2 == 6011 )
  {
    if ( result || *(_BYTE *)a3 > 0x3Fu )
    {
      *(_BYTE *)a3 = 63;
      result = (void *)sub_100043C0(6011, (int)a3, a1);
    }
  }
  else if ( result )
  {
    result = memset(a3, 204, a1);
  }
  return result;
}

//----- (10006170) --------------------------------------------------------
signed int sub_10006170()
{
  int v0; // edi@5
  void *v1; // esi@5
  signed int v2; // ebp@5
  signed int result; // eax@7
  char v4; // [sp+13h] [bp-1h]@1

  dword_101A4A74 = 0;
  v4 = 0;
  sub_10004730(94, &v4);
  if ( v4 == 3 )
  {
    v4 = 1;
    sub_10004340(3201, (int)&v4, 1);
    sub_10004760(94, (int)&v4);
  }
  else if ( v4 == 2 )
  {
    v4 = 0;
    sub_10004340(3201, (int)&v4, 1);
    sub_10004760(94, (int)&v4);
  }
  sub_10006120(1u, 6011, &unk_100DE9E8);
  sub_10006120(0x16u, 6194, &unk_100DE9E9);
  sub_10006120(1u, 6012, &unk_100DE9FF);
  sub_10006120(1u, 6013, &unk_100DEA00);
  sub_10006120(1u, 6014, &unk_100DEA01);
  sub_10006120(1u, 6015, &unk_100DEA02);
  sub_10006120(4u, 6078, &unk_100DEA04);
  sub_10006120(4u, 6104, &unk_100DEA08);
  sub_10006120(0x20u, 6016, &unk_100DEA0C);
  sub_10006120(0x20u, 6017, &unk_100DEA2C);
  sub_10006120(0x20u, 6018, &unk_100DEA4C);
  sub_10006120(0x20u, 6019, &unk_100DEA6C);
  sub_10006120(0x20u, 6020, &unk_100DEA8C);
  sub_10006120(0x20u, 6021, &unk_100DEAAC);
  sub_10006120(0x20u, 6022, &unk_100DEACC);
  sub_10006120(0x20u, 6023, &unk_100DEAEC);
  sub_10006120(0x20u, 6024, &unk_100DEB0C);
  sub_10006120(0x20u, 6025, &unk_100DEB2C);
  sub_10006120(0x20u, 6026, &unk_100DEB4C);
  sub_10006120(0x20u, 6027, &unk_100DEB6C);
  sub_10006120(0x20u, 6028, &unk_100DEB8C);
  sub_10006120(0x20u, 6029, &unk_100DEBAC);
  sub_10006120(0x20u, 6030, &unk_100DEBCC);
  sub_10006120(0x20u, 6031, &unk_100DEBEC);
  sub_10006120(0x20u, 6032, &unk_100DEC0C);
  sub_10006120(0x20u, 6033, &unk_100DEC2C);
  sub_10006120(0x20u, 6034, &unk_100DEC4C);
  sub_10006120(0x20u, 6035, &unk_100DEC6C);
  sub_10006120(0x20u, 6036, &unk_100DEC8C);
  sub_10006120(0x20u, 6037, &unk_100DECAC);
  sub_10006120(0x20u, 6038, &unk_100DECCC);
  sub_10006120(0x20u, 6039, &unk_100DECEC);
  sub_10006120(0x20u, 6040, &unk_100DED0C);
  sub_10006120(0x20u, 6041, &unk_100DED2C);
  sub_10006120(0x20u, 6042, &unk_100DED4C);
  sub_10006120(0x20u, 6043, &unk_100DED6C);
  sub_10006120(4u, 6044, &unk_100DED8C);
  sub_10006120(4u, 6045, &unk_100DED90);
  sub_10006120(4u, 6046, &unk_100DED94);
  sub_10006120(4u, 6357, &unk_100DED98);
  sub_10006120(4u, 6358, &unk_100DED9C);
  sub_10006120(4u, 6359, &unk_100DEDA0);
  sub_10006120(0x20u, 6047, &unk_100DEDA4);
  sub_10006120(0x20u, 6048, &unk_100DEDC4);
  sub_10006120(0x20u, 6049, &unk_100DEDE4);
  sub_10006120(0x20u, 6050, &unk_100DEE04);
  sub_10006120(0x20u, 6051, &unk_100DEE24);
  sub_10006120(0x20u, 6052, &unk_100DEE44);
  sub_10006120(0x20u, 6053, &unk_100DEE64);
  sub_10006120(0x20u, 6054, &unk_100DEE84);
  sub_10006120(1u, 6511, &unk_100DEEA4);
  sub_10006120(1u, 6522, &unk_100DEEA5);
  sub_10006120(1u, 6057, &unk_100DEEA6);
  sub_10006120(0x20u, 6075, &unk_100DEEF8);
  sub_10006120(0x20u, 6076, &unk_100DEF18);
  sub_10006120(1u, 6077, &unk_100DEF38);
  sub_10006120(4u, 6079, &unk_100DEF3C);
  sub_10006120(4u, 6080, &unk_100DEF40);
  sub_10006120(0x20u, 6082, &unk_100DEF44);
  sub_10006120(0x20u, 6083, &unk_100DEF64);
  sub_10006120(0x20u, 6084, &unk_100DEF84);
  sub_10006120(0x20u, 6085, &unk_100DEFA4);
  sub_10006120(0x20u, 6086, &unk_100DEFC4);
  sub_10006120(0x20u, 6087, &unk_100DEFE4);
  sub_10006120(0x20u, 6088, &unk_100DF004);
  sub_10006120(0x20u, 6089, &unk_100DF024);
  sub_10006120(0x20u, 6123, &unk_100DF044);
  sub_10006120(0x48u, 6906, &unk_100DF064);
  sub_10006120(0x48u, 6907, &unk_100DF0AC);
  sub_10006120(0x48u, 6908, &unk_100DF0F4);
  sub_10006120(0x48u, 6909, &unk_100DF13C);
  sub_10006120(0x48u, 6910, &unk_100DF184);
  sub_10006120(0x48u, 6911, &unk_100DF1CC);
  sub_10006120(0x48u, 6912, &unk_100DF214);
  sub_10006120(0x48u, 6913, &unk_100DF25C);
  sub_10006120(0x48u, 6914, &unk_100DF2A4);
  sub_10006120(0x48u, 6915, &unk_100DF2EC);
  sub_10006120(0x48u, 6916, &unk_100DF334);
  sub_10006120(0x48u, 6917, &unk_100DF37C);
  sub_10006120(0x48u, 6918, &unk_100DF3C4);
  sub_10006120(0x48u, 6919, &unk_100DF40C);
  sub_10006120(0x48u, 6920, &unk_100DF454);
  sub_10006120(0x48u, 6921, &unk_100DF49C);
  sub_10006120(0x48u, 6922, &unk_100DF4E4);
  sub_10006120(0x48u, 6923, &unk_100DF52C);
  sub_10006120(0x48u, 6924, &unk_100DF574);
  sub_10006120(0x48u, 6925, &unk_100DF5BC);
  sub_10006120(0x48u, 6926, &unk_100DF604);
  sub_10006120(0x48u, 6927, &unk_100DF64C);
  sub_10006120(0x48u, 6928, &unk_100DF694);
  sub_10006120(0x48u, 6929, &unk_100DF6DC);
  sub_10006120(0x48u, 6930, &unk_100DF724);
  sub_10006120(0x48u, 6931, &unk_100DF76C);
  sub_10006120(0x48u, 6932, &unk_100DF7B4);
  sub_10006120(0x48u, 6933, &unk_100DF7FC);
  sub_10006120(0x48u, 6934, &unk_100DF844);
  sub_10006120(0x48u, 6935, &unk_100DF88C);
  sub_10006120(0x18u, 6163, &unk_100DF8D4);
  sub_10006120(0x20u, 6164, &unk_100DF8EC);
  sub_10006120(0x20u, 6165, &unk_100DF90C);
  sub_10006120(2u, 6166, &unk_100DF92C);
  sub_10006120(0xA4u, 40100, &unk_100DF930);
  sub_10006120(0xA4u, 40101, &unk_100DF9D4);
  sub_10006120(0xA4u, 40102, &unk_100DFA78);
  sub_10006120(0xA4u, 40103, &unk_100DFB1C);
  sub_10006120(0xA4u, 40104, &unk_100DFBC0);
  sub_10006120(0xA4u, 40105, &unk_100DFC64);
  sub_10006120(0xA4u, 40106, &unk_100DFD08);
  sub_10006120(0xA4u, 40107, &unk_100DFDAC);
  sub_10006120(0xA4u, 40108, &unk_100DFE50);
  sub_10006120(0xA4u, 40109, &unk_100DFEF4);
  sub_10006120(0xA4u, 40110, &unk_100DFF98);
  sub_10006120(0xA4u, 40111, &unk_100E003C);
  sub_10006120(0xA4u, 40112, &unk_100E00E0);
  sub_10006120(0xA4u, 40113, &unk_100E0184);
  sub_10006120(0xA4u, 40114, &unk_100E0228);
  sub_10006120(0xA4u, 40115, &unk_100E02CC);
  sub_10006120(0xA4u, 40116, &unk_100E0370);
  sub_10006120(0xA4u, 40117, &unk_100E0414);
  sub_10006120(0xA4u, 40118, &unk_100E04B8);
  sub_10006120(0xA4u, 40119, &unk_100E055C);
  sub_10006120(0xA4u, 40120, &unk_100E0600);
  sub_10006120(0xA4u, 40121, &unk_100E06A4);
  sub_10006120(0xA4u, 40122, &unk_100E0748);
  sub_10006120(0xA4u, 40123, &unk_100E07EC);
  sub_10006120(0xA4u, 40124, &unk_100E0890);
  sub_10006120(0xA4u, 40125, &unk_100E0934);
  sub_10006120(0xA4u, 40126, &unk_100E09D8);
  sub_10006120(0xA4u, 40127, &unk_100E0A7C);
  sub_10006120(0xA4u, 40128, &unk_100E0B20);
  sub_10006120(0xA4u, 40129, &unk_100E0BC4);
  sub_10006120(0xA4u, 40130, &unk_100E0C68);
  sub_10006120(0xA4u, 40131, &unk_100E0D0C);
  sub_10006120(0xA4u, 40132, &unk_100E0DB0);
  sub_10006120(0xA4u, 40133, &unk_100E0E54);
  sub_10006120(0xA4u, 40134, &unk_100E0EF8);
  sub_10006120(0xA4u, 40135, &unk_100E0F9C);
  sub_10006120(0xA4u, 40136, &unk_100E1040);
  sub_10006120(0xA4u, 40137, &unk_100E10E4);
  sub_10006120(0xA4u, 40138, &unk_100E1188);
  sub_10006120(0xA4u, 40139, &unk_100E122C);
  sub_10006120(0xA4u, 40140, &unk_100E12D0);
  sub_10006120(0xA4u, 40141, &unk_100E1374);
  sub_10006120(0xA4u, 40142, &unk_100E1418);
  sub_10006120(0xA4u, 40143, &unk_100E14BC);
  sub_10006120(0xA4u, 40144, &unk_100E1560);
  sub_10006120(0xA4u, 40145, &unk_100E1604);
  sub_10006120(0xA4u, 40146, &unk_100E16A8);
  sub_10006120(0xA4u, 40147, &unk_100E174C);
  sub_10006120(0xA4u, 40148, &unk_100E17F0);
  sub_10006120(0xA4u, 40149, &unk_100E1894);
  sub_10006120(0xA4u, 40150, &unk_100E1938);
  sub_10006120(0xA4u, 40151, &unk_100E19DC);
  sub_10006120(0xA4u, 40152, &unk_100E1A80);
  sub_10006120(0xA4u, 40153, &unk_100E1B24);
  sub_10006120(0xA4u, 40154, &unk_100E1BC8);
  sub_10006120(0xA4u, 40155, &unk_100E1C6C);
  sub_10006120(0xA4u, 40156, &unk_100E1D10);
  sub_10006120(0xA4u, 40157, &unk_100E1DB4);
  sub_10006120(0xA4u, 40158, &unk_100E1E58);
  sub_10006120(0xA4u, 40159, &unk_100E1EFC);
  sub_10006120(0xA4u, 40160, &unk_100E1FA0);
  sub_10006120(0xA4u, 40161, &unk_100E2044);
  sub_10006120(0xA4u, 40162, &unk_100E20E8);
  sub_10006120(0xA4u, 40163, &unk_100E218C);
  sub_10006120(0xA4u, 40164, &unk_100E2230);
  sub_10006120(0xA4u, 40165, &unk_100E22D4);
  sub_10006120(0xA4u, 40166, &unk_100E2378);
  sub_10006120(0xA4u, 40167, &unk_100E241C);
  sub_10006120(0xA4u, 40168, &unk_100E24C0);
  sub_10006120(0xA4u, 40169, &unk_100E2564);
  sub_10006120(0xA4u, 40170, &unk_100E2608);
  sub_10006120(0xA4u, 40171, &unk_100E26AC);
  sub_10006120(0xA4u, 40172, &unk_100E2750);
  sub_10006120(0xA4u, 40173, &unk_100E27F4);
  sub_10006120(0xA4u, 40174, &unk_100E2898);
  sub_10006120(0xA4u, 40175, &unk_100E293C);
  sub_10006120(0xA4u, 40176, &unk_100E29E0);
  sub_10006120(0xA4u, 40177, &unk_100E2A84);
  sub_10006120(0xA4u, 40178, &unk_100E2B28);
  sub_10006120(0xA4u, 40179, &unk_100E2BCC);
  sub_10006120(0xA4u, 40180, &unk_100E2C70);
  sub_10006120(0xA4u, 40181, &unk_100E2D14);
  sub_10006120(0xA4u, 40182, &unk_100E2DB8);
  sub_10006120(0xA4u, 40183, &unk_100E2E5C);
  sub_10006120(0xA4u, 40184, &unk_100E2F00);
  sub_10006120(0xA4u, 40185, &unk_100E2FA4);
  sub_10006120(0xA4u, 40186, &unk_100E3048);
  sub_10006120(0xA4u, 40187, &unk_100E30EC);
  sub_10006120(0xA4u, 40188, &unk_100E3190);
  sub_10006120(0xA4u, 40189, &unk_100E3234);
  sub_10006120(0xA4u, 40190, &unk_100E32D8);
  sub_10006120(0xA4u, 40191, &unk_100E337C);
  sub_10006120(0xA4u, 40192, &unk_100E3420);
  sub_10006120(0xA4u, 40193, &unk_100E34C4);
  sub_10006120(0xA4u, 40194, &unk_100E3568);
  sub_10006120(0xA4u, 40195, &unk_100E360C);
  sub_10006120(0xA4u, 40196, &unk_100E36B0);
  sub_10006120(0xA4u, 40197, &unk_100E3754);
  sub_10006120(0xA4u, 40198, &unk_100E37F8);
  sub_10006120(0xA4u, 40199, &unk_100E389C);
  sub_10006120(0x20u, 6190, &unk_100E3940);
  sub_10006120(0x20u, 6191, &unk_100E3960);
  sub_10006120(0x20u, 6192, &unk_100E3980);
  sub_10006120(0x20u, 6199, &unk_100E39A0);
  sub_10006120(0x28u, 6207, &unk_100E39C0);
  sub_10006120(4u, 6231, &unk_100E44D8);
  sub_10006120(4u, 6232, &unk_100E44DC);
  sub_10006120(4u, 6233, &unk_100E44E0);
  sub_10006120(4u, 6234, &unk_100E44E4);
  sub_10006120(0x1Cu, 40000, &unk_100E39E8);
  sub_10006120(0x1Cu, 40001, &unk_100E3A04);
  sub_10006120(0x1Cu, 40002, &unk_100E3A20);
  sub_10006120(0x1Cu, 40003, &unk_100E3A3C);
  sub_10006120(0x1Cu, 40004, &unk_100E3A58);
  sub_10006120(0x1Cu, 40005, &unk_100E3A74);
  sub_10006120(0x1Cu, 40006, &unk_100E3A90);
  sub_10006120(0x1Cu, 40007, &unk_100E3AAC);
  sub_10006120(0x1Cu, 40008, &unk_100E3AC8);
  sub_10006120(0x1Cu, 40009, &unk_100E3AE4);
  sub_10006120(0x1Cu, 40010, &unk_100E3B00);
  sub_10006120(0x1Cu, 40011, &unk_100E3B1C);
  sub_10006120(0x1Cu, 40012, &unk_100E3B38);
  sub_10006120(0x1Cu, 40013, &unk_100E3B54);
  sub_10006120(0x1Cu, 40014, &unk_100E3B70);
  sub_10006120(0x1Cu, 40015, &unk_100E3B8C);
  sub_10006120(0x1Cu, 40016, &unk_100E3BA8);
  sub_10006120(0x1Cu, 40017, &unk_100E3BC4);
  sub_10006120(0x1Cu, 40018, &unk_100E3BE0);
  sub_10006120(0x1Cu, 40019, &unk_100E3BFC);
  sub_10006120(0x1Cu, 40020, &unk_100E3C18);
  sub_10006120(0x1Cu, 40021, &unk_100E3C34);
  sub_10006120(0x1Cu, 40022, &unk_100E3C50);
  sub_10006120(0x1Cu, 40023, &unk_100E3C6C);
  sub_10006120(0x1Cu, 40024, &unk_100E3C88);
  sub_10006120(0x1Cu, 40025, &unk_100E3CA4);
  sub_10006120(0x1Cu, 40026, &unk_100E3CC0);
  sub_10006120(0x1Cu, 40027, &unk_100E3CDC);
  sub_10006120(0x1Cu, 40028, &unk_100E3CF8);
  sub_10006120(0x1Cu, 40029, &unk_100E3D14);
  sub_10006120(0x1Cu, 40030, &unk_100E3D30);
  sub_10006120(0x1Cu, 40031, &unk_100E3D4C);
  sub_10006120(0x1Cu, 40032, &unk_100E3D68);
  sub_10006120(0x1Cu, 40033, &unk_100E3D84);
  sub_10006120(0x1Cu, 40034, &unk_100E3DA0);
  sub_10006120(0x1Cu, 40035, &unk_100E3DBC);
  sub_10006120(0x1Cu, 40036, &unk_100E3DD8);
  sub_10006120(0x1Cu, 40037, &unk_100E3DF4);
  sub_10006120(0x1Cu, 40038, &unk_100E3E10);
  sub_10006120(0x1Cu, 40039, &unk_100E3E2C);
  sub_10006120(0x1Cu, 40040, &unk_100E3E48);
  sub_10006120(0x1Cu, 40041, &unk_100E3E64);
  sub_10006120(0x1Cu, 40042, &unk_100E3E80);
  sub_10006120(0x1Cu, 40043, &unk_100E3E9C);
  sub_10006120(0x1Cu, 40044, &unk_100E3EB8);
  sub_10006120(0x1Cu, 40045, &unk_100E3ED4);
  sub_10006120(0x1Cu, 40046, &unk_100E3EF0);
  sub_10006120(0x1Cu, 40047, &unk_100E3F0C);
  sub_10006120(0x1Cu, 40048, &unk_100E3F28);
  sub_10006120(0x1Cu, 40049, &unk_100E3F44);
  sub_10006120(0x1Cu, 40050, &unk_100E3F60);
  sub_10006120(0x1Cu, 40051, &unk_100E3F7C);
  sub_10006120(0x1Cu, 40052, &unk_100E3F98);
  sub_10006120(0x1Cu, 40053, &unk_100E3FB4);
  sub_10006120(0x1Cu, 40054, &unk_100E3FD0);
  sub_10006120(0x1Cu, 40055, &unk_100E3FEC);
  sub_10006120(0x1Cu, 40056, &unk_100E4008);
  sub_10006120(0x1Cu, 40057, &unk_100E4024);
  sub_10006120(0x1Cu, 40058, &unk_100E4040);
  sub_10006120(0x1Cu, 40059, &unk_100E405C);
  sub_10006120(0x1Cu, 40060, &unk_100E4078);
  sub_10006120(0x1Cu, 40061, &unk_100E4094);
  sub_10006120(0x1Cu, 40062, &unk_100E40B0);
  sub_10006120(0x1Cu, 40063, &unk_100E40CC);
  sub_10006120(0x1Cu, 40064, &unk_100E40E8);
  sub_10006120(0x1Cu, 40065, &unk_100E4104);
  sub_10006120(0x1Cu, 40066, &unk_100E4120);
  sub_10006120(0x1Cu, 40067, &unk_100E413C);
  sub_10006120(0x1Cu, 40068, &unk_100E4158);
  sub_10006120(0x1Cu, 40069, &unk_100E4174);
  sub_10006120(0x1Cu, 40070, &unk_100E4190);
  sub_10006120(0x1Cu, 40071, &unk_100E41AC);
  sub_10006120(0x1Cu, 40072, &unk_100E41C8);
  sub_10006120(0x1Cu, 40073, &unk_100E41E4);
  sub_10006120(0x1Cu, 40074, &unk_100E4200);
  sub_10006120(0x1Cu, 40075, &unk_100E421C);
  sub_10006120(0x1Cu, 40076, &unk_100E4238);
  sub_10006120(0x1Cu, 40077, &unk_100E4254);
  sub_10006120(0x1Cu, 40078, &unk_100E4270);
  sub_10006120(0x1Cu, 40079, &unk_100E428C);
  sub_10006120(0x1Cu, 40080, &unk_100E42A8);
  sub_10006120(0x1Cu, 40081, &unk_100E42C4);
  sub_10006120(0x1Cu, 40082, &unk_100E42E0);
  sub_10006120(0x1Cu, 40083, &unk_100E42FC);
  sub_10006120(0x1Cu, 40084, &unk_100E4318);
  sub_10006120(0x1Cu, 40085, &unk_100E4334);
  sub_10006120(0x1Cu, 40086, &unk_100E4350);
  sub_10006120(0x1Cu, 40087, &unk_100E436C);
  sub_10006120(0x1Cu, 40088, &unk_100E4388);
  sub_10006120(0x1Cu, 40089, &unk_100E43A4);
  sub_10006120(0x1Cu, 40090, &unk_100E43C0);
  sub_10006120(0x1Cu, 40091, &unk_100E43DC);
  sub_10006120(0x1Cu, 40092, &unk_100E43F8);
  sub_10006120(0x1Cu, 40093, &unk_100E4414);
  sub_10006120(0x1Cu, 40094, &unk_100E4430);
  sub_10006120(0x1Cu, 40095, &unk_100E444C);
  sub_10006120(0x1Cu, 40096, &unk_100E4468);
  sub_10006120(0x1Cu, 40097, &unk_100E4484);
  sub_10006120(0x1Cu, 40098, &unk_100E44A0);
  sub_10006120(0x1Cu, 40099, &unk_100E44BC);
  sub_10006120(4u, 6238, &unk_100E44E8);
  sub_10006120(4u, 6239, &unk_100E44EC);
  sub_10006120(4u, 6240, &unk_100E44F0);
  sub_10006120(4u, 6242, &unk_100E44F4);
  sub_10006120(4u, 6244, &unk_100E44F8);
  sub_10006120(4u, 6245, &unk_100E44FC);
  sub_10006120(4u, 6246, &unk_100E4500);
  sub_10006120(4u, 6251, &unk_100E4504);
  sub_10006120(4u, 6252, &unk_100E4508);
  sub_10006120(4u, 6253, &unk_100E450C);
  sub_10006120(4u, 6254, &unk_100E4510);
  sub_10006120(1u, 6255, &unk_100E4514);
  sub_10006120(4u, 6256, &unk_100E4518);
  sub_10006120(4u, 6257, &unk_100E451C);
  sub_10006120(0xE2u, 6286, &unk_100E4520);
  v0 = 18000;
  v1 = &unk_100E4604;
  v2 = 16;
  do
  {
    sub_10006120(0x11Cu, v0, v1);
    v1 = (char *)v1 + 284;
    ++v0;
    --v2;
  }
  while ( v2 );
  sub_10006120(4u, 6262, &unk_100E57C4);
  sub_10006120(0x28u, 6263, &unk_100E57C8);
  sub_10006120(0x28u, 6264, &unk_100E57F0);
  sub_10006120(0x40u, 6268, &unk_100E5818);
  sub_10006120(4u, 6272, &unk_100E58D8);
  sub_10006120(4u, 6273, &unk_100E58DC);
  sub_10006120(1u, 6274, &unk_100E58E0);
  sub_10006120(2u, 6275, &unk_100E58E2);
  sub_10006120(1u, 6276, &unk_100E58E4);
  sub_10006120(1u, 6277, &unk_100E58E5);
  sub_10006120(1u, 6278, &unk_100E58E6);
  sub_10006120(0x40u, 6279, &unk_100E58E8);
  sub_10006120(0x28u, 6753, &unk_100E679D);
  sub_10006120(0x30u, 6754, &unk_100E67C8);
  sub_10006120(0x28u, 6958, &unk_100E67F8);
  sub_10006120(0x80u, 6802, &unk_100E5858);
  sub_10006120(1u, 6760, &unk_100E6820);
  sub_10006120(0x10u, 6312, &unk_100E5C6C);
  sub_10006120(0x10u, 6313, &unk_100E5C7C);
  sub_10006120(0x10u, 6314, &unk_100E5C8C);
  sub_10006120(1u, 6307, &unk_100E5C9C);
  sub_10006120(1u, 6308, &unk_100E5C9D);
  sub_10006120(1u, 6309, &unk_100E5C9E);
  sub_10006120(4u, 6285, &unk_100E5CA0);
  sub_10006120(0xA8u, 6318, &unk_100E5CA4);
  sub_10006120(4u, 6319, &unk_100E5D4C);
  sub_10006120(1u, 6350, &unk_100E5D50);
  sub_10006120(0x50u, 6351, &unk_100E5D54);
  sub_10006120(4u, 6352, &unk_100E5DA4);
  sub_10006120(4u, 6353, &unk_100E5DA8);
  sub_10006120(0x54u, 6448, &unk_100E5FF4);
  sub_10006120(0x54u, 6449, &unk_100E6048);
  sub_10006120(8u, 6287, &unk_100E594C);
  sub_10006120(8u, 6288, &unk_100E5954);
  sub_10006120(8u, 6289, &unk_100E595C);
  sub_10006120(8u, 6290, &unk_100E5964);
  sub_10006120(8u, 6291, &unk_100E596C);
  sub_10006120(8u, 6292, &unk_100E5974);
  sub_10006120(8u, 6293, &unk_100E597C);
  sub_10006120(8u, 6294, &unk_100E5984);
  sub_10006120(8u, 6295, &unk_100E598C);
  sub_10006120(8u, 6296, &unk_100E5994);
  sub_10006120(8u, 6297, &unk_100E599C);
  sub_10006120(8u, 6298, &unk_100E59A4);
  sub_10006120(8u, 6299, &unk_100E59AC);
  sub_10006120(8u, 6300, &unk_100E59B4);
  sub_10006120(8u, 6301, &unk_100E59BC);
  sub_10006120(8u, 6302, &unk_100E59C4);
  sub_10006120(8u, 6303, &unk_100E59CC);
  sub_10006120(8u, 6304, &unk_100E59D4);
  sub_10006120(8u, 6305, &unk_100E59DC);
  sub_10006120(8u, 6306, &unk_100E59E4);
  sub_10006120(8u, 6409, &unk_100E59EC);
  sub_10006120(8u, 6410, &unk_100E59F4);
  sub_10006120(8u, 6411, &unk_100E59FC);
  sub_10006120(8u, 6412, &unk_100E5A04);
  sub_10006120(8u, 6413, &unk_100E5A0C);
  sub_10006120(8u, 6414, &unk_100E5A14);
  sub_10006120(8u, 6415, &unk_100E5A1C);
  sub_10006120(8u, 6416, &unk_100E5A24);
  sub_10006120(8u, 6417, &unk_100E5A2C);
  sub_10006120(8u, 6418, &unk_100E5A34);
  sub_10006120(8u, 6419, &unk_100E5A3C);
  sub_10006120(8u, 6420, &unk_100E5A44);
  sub_10006120(8u, 6421, &unk_100E5A4C);
  sub_10006120(8u, 6422, &unk_100E5A54);
  sub_10006120(8u, 6423, &unk_100E5A5C);
  sub_10006120(8u, 6424, &unk_100E5A64);
  sub_10006120(8u, 6425, &unk_100E5A6C);
  sub_10006120(8u, 6426, &unk_100E5A74);
  sub_10006120(8u, 6427, &unk_100E5A7C);
  sub_10006120(8u, 6428, &unk_100E5A84);
  sub_10006120(4u, 6429, &unk_100E5F8C);
  sub_10006120(8u, 6430, &unk_100E5F90);
  sub_10006120(8u, 6431, &unk_100E5F98);
  sub_10006120(8u, 6432, &unk_100E5FA0);
  sub_10006120(8u, 6433, &unk_100E5FA8);
  sub_10006120(8u, 6434, &unk_100E5FB0);
  sub_10006120(8u, 6435, &unk_100E5FB8);
  sub_10006120(8u, 6436, &unk_100E5FC0);
  sub_10006120(8u, 6437, &unk_100E5FC8);
  sub_10006120(8u, 6438, &unk_100E5FD0);
  sub_10006120(8u, 6439, &unk_100E5FD8);
  sub_10006120(8u, 6440, &unk_100E5FE0);
  sub_10006120(0xAu, 6519, &unk_100E644C);
  sub_10006120(4u, 6442, &unk_100E5FE8);
  sub_10006120(4u, 6443, &unk_100E5FEC);
  sub_10006120(0xF0u, 6367, &unk_100E5DAC);
  sub_10006120(0xF0u, 6368, &unk_100E5E9C);
  sub_10006120(1u, 6446, &unk_100E5FF0);
  sub_10006120(6u, 6452, &unk_100E609C);
  sub_10006120(4u, 6457, &unk_100E60A4);
  sub_10006120(4u, 6458, &unk_100E60A8);
  sub_10006120(4u, 6459, &unk_100E60AC);
  sub_10006120(4u, 6460, &unk_100E60B0);
  sub_10006120(0x208u, 6515, &unk_100E60B4);
  sub_10006120(0x160u, 6516, &unk_100E62BC);
  sub_10006120(0x18u, 6517, &unk_100E641C);
  sub_10006120(0x18u, 6518, &unk_100E6434);
  sub_10006120(1u, 6520, &unk_100E6456);
  sub_10006120(0x10u, 6521, &unk_100E6458);
  sub_10006120(4u, 6523, &unk_100E6468);
  sub_10006120(4u, 6524, &unk_100E646C);
  sub_10006120(4u, 6525, &unk_100E6470);
  sub_10006120(1u, 6526, &unk_100E6474);
  sub_10006120(1u, 6527, &unk_100E6475);
  sub_10006120(0x50u, 6528, &unk_100E6478);
  sub_10006120(4u, 6529, &unk_100E64C8);
  sub_10006120(1u, 6530, &unk_100E64CC);
  sub_10006120(1u, 6531, &unk_100E64CD);
  sub_10006120(1u, 6532, &unk_100E64CE);
  sub_10006120(0x14u, 6533, &unk_100E64CF);
  sub_10006120(0xAu, 6883, &unk_100E6BE8);
  sub_10006120(0xAu, 6884, &unk_100E6BF2);
  sub_10006120(0xAu, 6885, &unk_100E6BFC);
  sub_10006120(1u, 6664, &unk_100E64E3);
  sub_10006120(1u, 6666, &unk_100E64E4);
  sub_10006120(1u, 6667, &unk_100E64E5);
  sub_10006120(1u, 6668, &unk_100E64E6);
  sub_10006120(0xA0u, 6669, &unk_100E64E8);
  sub_10006120(2u, 6670, &unk_100E65D8);
  sub_10006120(4u, 6671, &unk_100E65DC);
  sub_10006120(4u, 6672, &unk_100E65E0);
  sub_10006120(4u, 6673, &unk_100E65E4);
  sub_10006120(4u, 6674, &unk_100E65E8);
  sub_10006120(4u, 6675, &unk_100E65EC);
  sub_10006120(4u, 6676, &unk_100E65F4);
  sub_10006120(4u, 6677, &unk_100E65FC);
  sub_10006120(4u, 6678, &unk_100E6600);
  sub_10006120(1u, 6679, &unk_100E6604);
  sub_10006120(0x140u, 6680, &unk_100E6608);
  sub_10006120(4u, 6882, &unk_100E6BE4);
  sub_10006120(0xCu, 6652, &unk_100E6748);
  sub_10006120(0x48u, 6653, &unk_100E6754);
  sub_10006120(1u, 6688, &unk_100E679C);
  sub_10006120(4u, 6771, &unk_100E6824);
  sub_10006120(4u, 6772, &unk_100E6828);
  sub_10006120(8u, 6787, &unk_100E682C);
  sub_10006120(1u, 6832, &unk_100E685C);
  sub_10006120(1u, 6833, &unk_100E685D);
  sub_10006120(1u, 6834, &unk_100E685E);
  sub_10006120(4u, 6835, &unk_100E6860);
  sub_10006120(4u, 6836, &unk_100E6864);
  sub_10006120(4u, 6837, &unk_100E6868);
  sub_10006120(4u, 6838, &unk_100E686C);
  sub_10006120(1u, 6839, &unk_100E6870);
  sub_10006120(0x50u, 6840, &unk_100E6588);
  sub_10006120(4u, 6841, &unk_100E6874);
  sub_10006120(4u, 6842, &unk_100E6878);
  sub_10006120(4u, 6843, &unk_100E687C);
  sub_10006120(1u, 6844, &unk_100E6880);
  sub_10006120(0x360u, 6845, &unk_100E6884);
  sub_10006120(4u, 6846, &unk_100E65F0);
  sub_10006120(4u, 6847, &unk_100E65F8);
  result = 1;
  dword_101A4A74 = (int)&unk_100DE9E8;
  return result;
}
// 101A4A74: using guessed type int dword_101A4A74;

//----- (10007F70) --------------------------------------------------------
_DWORD *sub_10007F70()
{
  sub_10001530();
  return sub_10015780();
}

//----- (10007F80) --------------------------------------------------------
#error "10007F8F: call analysis failed (funcsize=5)"

//----- (10007FA0) --------------------------------------------------------
void sub_10007FA0()
{
  dword_101A4A70 = -15;
}
// 101A4A70: using guessed type int dword_101A4A70;

//----- (10007FB0) --------------------------------------------------------
int sub_10007FB0()
{
  int result; // eax@1

  result = 0;
  dword_100E83B8 = -15;
  dword_101A4A6C = 0;
  dword_101A4A60 = 0;
  dword_101A4A64 = 0;
  dword_101A4A68 = 0;
  return result;
}
// 100E83B8: using guessed type int dword_100E83B8;
// 101A4A60: using guessed type int dword_101A4A60;
// 101A4A64: using guessed type int dword_101A4A64;
// 101A4A68: using guessed type int dword_101A4A68;
// 101A4A6C: using guessed type int dword_101A4A6C;

//----- (10007FE0) --------------------------------------------------------
int __cdecl sub_10007FE0(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_10057DBC[a1];
  return result;
}
// 10057DBC: using guessed type __int16 word_10057DBC[];

//----- (10008000) --------------------------------------------------------
signed int sub_10008000()
{
  signed int result; // eax@1

  result = -15;
  dword_100E83D8 = -15;
  dword_100E83E4 = -15;
  dword_100E83C0 = -15;
  dword_100E83E8 = -15;
  dword_100E83D4 = -15;
  dword_100E83C4 = -15;
  dword_100E83BC = -15;
  dword_100E83D0 = -15;
  dword_100E83E0 = -15;
  dword_100E83DC = -15;
  dword_100E83CC = -15;
  dword_100E83C8 = -15;
  return result;
}
// 100E83BC: using guessed type int dword_100E83BC;
// 100E83C0: using guessed type int dword_100E83C0;
// 100E83C4: using guessed type int dword_100E83C4;
// 100E83C8: using guessed type int dword_100E83C8;
// 100E83CC: using guessed type int dword_100E83CC;
// 100E83D0: using guessed type int dword_100E83D0;
// 100E83D4: using guessed type int dword_100E83D4;
// 100E83D8: using guessed type int dword_100E83D8;
// 100E83DC: using guessed type int dword_100E83DC;
// 100E83E0: using guessed type int dword_100E83E0;
// 100E83E4: using guessed type int dword_100E83E4;
// 100E83E8: using guessed type int dword_100E83E8;

//----- (10008050) --------------------------------------------------------
signed int __usercall sub_10008050@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_100422E0((int)&off_10057DDC);
      break;
    case 0:
      result = sub_100422E0((int)&off_10057DF0);
      break;
    case 1:
      result = sub_100422E0((int)&off_10057E04);
      break;
    case 2:
      result = sub_100422E0((int)&off_10057E2C);
      break;
    case 3:
      result = sub_100422E0((int)&off_10057E18);
      break;
    case 5:
      result = sub_100422E0((int)&off_10057E40);
      break;
    default:
      result = sub_100422E0(a2);
      break;
  }
  return result;
}
// 10057DDC: using guessed type char *off_10057DDC;
// 10057DF0: using guessed type char *off_10057DF0;
// 10057E04: using guessed type char *off_10057E04;
// 10057E18: using guessed type char *off_10057E18;
// 10057E2C: using guessed type char *off_10057E2C;
// 10057E40: using guessed type char *off_10057E40;

//----- (100080F0) --------------------------------------------------------
int __usercall sub_100080F0@<eax>(char a1@<al>)
{
  return sub_10004010(dword_1005790C[a1]);
}
// 1005790C: using guessed type int dword_1005790C[];

//----- (10008110) --------------------------------------------------------
int __usercall sub_10008110@<eax>(char a1@<al>)
{
  return sub_10004030(dword_1005790C[a1], 10);
}
// 1005790C: using guessed type int dword_1005790C[];

//----- (10008130) --------------------------------------------------------
signed __int16 __usercall sub_10008130@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  signed __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_10008050(a1, a1) )
        {
          sub_10003DC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_100E83D8 + 2 * a2 + 241212);
        v3 = (unsigned __int16)result < 0x256u;
        goto LABEL_32;
      }
      sub_10003DC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_10003DC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      if ( (unsigned __int8)sub_10008050(a1, a1) )
      {
        result = *(_WORD *)(dword_100E83E4 + 2 * a2 + 284664);
        v3 = (unsigned __int16)result < 0x211u;
        goto LABEL_32;
      }
      if ( sub_10005160(15000) )
        goto LABEL_6;
      sub_10003DC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
      return 0;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_10003DC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10008050(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_100E83C0 + 2 * a2 + 447808);
      v3 = (unsigned __int16)result < 0x979u;
      goto LABEL_32;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_10003DC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10008050(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_100E83E8 + 2 * a2 + 356016);
      v3 = (unsigned __int16)result < 0x23Du;
      goto LABEL_32;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_10003DC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10008050(a1, a1) )
      {
        sub_10003DC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_100E83D4 + 2 * a2 + 23096);
      v3 = (unsigned __int16)result < 0x52u;
      goto LABEL_32;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_10008050(a1, a1) )
        {
          result = *(_WORD *)(dword_100E83C4 + 2 * a2 + 1804);
          v3 = (unsigned __int16)result < 4u;
LABEL_32:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_10003DC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 100E83C0: using guessed type int dword_100E83C0;
// 100E83C4: using guessed type int dword_100E83C4;
// 100E83D4: using guessed type int dword_100E83D4;
// 100E83D8: using guessed type int dword_100E83D8;
// 100E83E4: using guessed type int dword_100E83E4;
// 100E83E8: using guessed type int dword_100E83E8;

//----- (10008370) --------------------------------------------------------
char __cdecl sub_10008370(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  signed __int16 v4; // si@1
  char result; // al@2

  v4 = sub_10008130(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10008050(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_100E83D8 + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_10008050(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_100E83E4 + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        result = sub_10008050(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_100E83C0 + 321708), 0x34u);
        break;
      case 2:
        if ( (unsigned __int8)sub_10008050(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_100E83E8 + 326220), 0x34u);
        result = 1;
        break;
      case 3:
        if ( (unsigned __int8)sub_10008050(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_100E83D4 + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        result = sub_10008050(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_100E83C4 + 1596), 0x34u);
        break;
      default:
LABEL_16:
        result = 0;
        break;
    }
  }
  return result;
}
// 100E83C0: using guessed type int dword_100E83C0;
// 100E83C4: using guessed type int dword_100E83C4;
// 100E83D4: using guessed type int dword_100E83D4;
// 100E83D8: using guessed type int dword_100E83D8;
// 100E83E4: using guessed type int dword_100E83E4;
// 100E83E8: using guessed type int dword_100E83E8;

//----- (100084F0) --------------------------------------------------------
char __cdecl sub_100084F0(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_10008130(a1, a2);
  if ( v3 != -1 && !sub_10008110(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10008050(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_100E83D8 + 24 * ((unsigned __int16)v3 + 25);
        goto LABEL_16;
      case 0:
        if ( (unsigned __int8)sub_10008050(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_100E83E4 + 24 * (unsigned __int16)v3 + 532;
        goto LABEL_16;
      case 1:
        if ( (unsigned __int8)sub_10008050(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_100E83C0 + 24 * (unsigned __int16)v3 + 2428;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_10008050(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_100E83E8 + 24 * ((unsigned __int16)v3 + 24);
        goto LABEL_16;
      case 3:
        if ( (unsigned __int8)sub_10008050(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_100E83D4 + 24 * (unsigned __int16)v3 + 84;
        goto LABEL_16;
      case 5:
        if ( (unsigned __int8)sub_10008050(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_100E83C4 + 24 * (unsigned __int16)v3 + 4;
LABEL_16:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_100080F0(a1);
        return 1;
      default:
LABEL_17:
        sub_100080F0(a1);
        break;
    }
  }
  return 0;
}
// 100E83C0: using guessed type int dword_100E83C0;
// 100E83C4: using guessed type int dword_100E83C4;
// 100E83D4: using guessed type int dword_100E83D4;
// 100E83D8: using guessed type int dword_100E83D8;
// 100E83E4: using guessed type int dword_100E83E4;
// 100E83E8: using guessed type int dword_100E83E8;

//----- (10008650) --------------------------------------------------------
char __cdecl sub_10008650(int a1, int a2, void *a3, char a4, __int16 a5, char a6)
{
  int v6; // ecx@0
  signed __int16 v7; // ax@1
  int v8; // edi@2
  __int16 v9; // si@11
  __int16 v11; // [sp+8h] [bp-560h]@13
  __int16 v12; // [sp+3Ch] [bp-52Ch]@10
  char v13; // [sp+40h] [bp-528h]@16
  char v14; // [sp+41h] [bp-527h]@10
  __int16 v15; // [sp+42h] [bp-526h]@10
  char v16; // [sp+44h] [bp-524h]@10
  __int16 v17; // [sp+46h] [bp-522h]@15
  int v18; // [sp+48h] [bp-520h]@16
  char v19; // [sp+4Ch] [bp-51Ch]@15

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_8;
    case 0:
      v8 = 29;
      goto LABEL_8;
    case 1:
      v8 = 30;
      goto LABEL_8;
    case 2:
      v8 = 31;
      goto LABEL_8;
    case 3:
      v8 = 32;
      goto LABEL_8;
    case 5:
      v8 = 33;
LABEL_8:
      LOBYTE(v7) = sub_10008050(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_10008130(a1, a2);
      if ( v7 == -1 )
        return v7;
      v14 = a6;
      LOBYTE(v7) = a4;
      v12 = -32768;
      v15 = a2;
      v16 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_10008370(a1, a2, &v11) != 1 )
          goto LABEL_16;
        v9 = v11;
      }
      memcpy(&v19, a3, (unsigned __int16)v9);
      v17 = v9;
LABEL_16:
      v18 = sub_10003F60();
      v13 = 0;
      LOBYTE(v7) = sub_10015810(v8, (int)&v12);
      return v7;
    default:
      return v7;
  }
}

//----- (10008790) --------------------------------------------------------
char __cdecl sub_10008790(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  unsigned __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_10008130(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_10015810(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (10008870) --------------------------------------------------------
char __cdecl sub_10008870(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  signed __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@9
  int v15; // eax@11
  int v16; // eax@13
  int v17; // eax@15
  int v18; // eax@17
  int v19; // eax@25
  char v20; // [sp+7h] [bp-9h]@19
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_10003F60();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_10008130(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_10008050(a1, v7) )
            goto LABEL_30;
          v9 = 3 * (unsigned __int16)v8 + 75;
          v10 = dword_100E83D8 + 14952;
          v11 = 52 * (unsigned __int16)v8 + dword_100E83D8 + 210116;
          v12 = dword_100E83D8 + 8 * v9;
          v13 = 195164;
          goto LABEL_18;
        case 0:
          if ( !(unsigned __int8)sub_10008050(a1, v7) )
            goto LABEL_30;
          v14 = 3 * (unsigned __int16)v8;
          v10 = dword_100E83E4 + 13228;
          v11 = 52 * (unsigned __int16)v8 + dword_100E83E4 + 257156;
          v12 = dword_100E83E4 + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_18;
        case 1:
          if ( !(unsigned __int8)sub_10008050(a1, v7) )
            goto LABEL_30;
          v15 = 3 * (unsigned __int16)v8;
          v10 = dword_100E83C0 + 60628;
          v11 = 52 * (unsigned __int16)v8 + dword_100E83C0 + 321708;
          v12 = dword_100E83C0 + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_18;
        case 2:
          if ( !(unsigned __int8)sub_10008050(a1, v7) )
            goto LABEL_30;
          v16 = 3 * (unsigned __int16)v8 + 72;
          v10 = dword_100E83E8 + 14328;
          v11 = 52 * (unsigned __int16)v8 + dword_100E83E8 + 326220;
          v12 = dword_100E83E8 + 8 * v16;
          v13 = 311892;
          goto LABEL_18;
        case 3:
          if ( !(unsigned __int8)sub_10008050(a1, v7) )
            goto LABEL_30;
          v17 = 3 * (unsigned __int16)v8;
          v10 = dword_100E83D4 + 2052;
          v11 = 52 * (unsigned __int16)v8 + dword_100E83D4 + 18832;
          v12 = dword_100E83D4 + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_18;
        case 5:
          if ( !(unsigned __int8)sub_10008050(a1, v7) )
            goto LABEL_30;
          v18 = 3 * (unsigned __int16)v8;
          v10 = dword_100E83C4 + 100;
          v11 = 52 * (unsigned __int16)v8 + dword_100E83C4 + 1596;
          v12 = dword_100E83C4 + 8 * v18 + 4;
          v13 = 1496;
LABEL_18:
          if ( sub_10008110(a1) )
            goto LABEL_30;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_33;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_33:
              v20 = 0;
            else
              memcpy(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_100080F0(a1);
          result = v20;
          break;
        default:
LABEL_30:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100E83BC: using guessed type int dword_100E83BC;
// 100E83C0: using guessed type int dword_100E83C0;
// 100E83C4: using guessed type int dword_100E83C4;
// 100E83D0: using guessed type int dword_100E83D0;
// 100E83D4: using guessed type int dword_100E83D4;
// 100E83D8: using guessed type int dword_100E83D8;
// 100E83E0: using guessed type int dword_100E83E0;
// 100E83E4: using guessed type int dword_100E83E4;
// 100E83E8: using guessed type int dword_100E83E8;

//----- (10008AF0) --------------------------------------------------------
char __cdecl sub_10008AF0(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_10008870(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (10008B20) --------------------------------------------------------
char __cdecl sub_10008B20(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_10008870(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (10008B50) --------------------------------------------------------
char __cdecl sub_10008B50(char a1, int a2, void *a3, int a4)
{
  return sub_10008870(a1, a2, 0, 0, a3, a4);
}

//----- (10008B80) --------------------------------------------------------
int __cdecl sub_10008B80(int a1, int a2)
{
  byte_101A4A78[0] = 0;
  return nullsub_1(a1, a2);
}

//----- (10008BA0) --------------------------------------------------------
signed int sub_10008BA0()
{
  return 1000;
}

//----- (10008BC0) --------------------------------------------------------
int sub_10008BC0()
{
  return sub_10013AC0((int)off_10058420);
}
// 10058420: using guessed type int (*off_10058420[4])();

//----- (10008BD0) --------------------------------------------------------
char __cdecl sub_10008BD0(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_10005180(13, (char *)&v3 + 3);
  sub_10005180(12, a1);
  return BYTE3(v3);
}

//----- (10008C40) --------------------------------------------------------
signed int __cdecl sub_10008C40(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_10015B00(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_10016A20(v4, a4, 0) == a4 )
      result = sub_100169C0(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10008CA0) --------------------------------------------------------
signed int __cdecl sub_10008CA0(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_10015B00(a1);
  return sub_10016A20(v3, a2, a3);
}

//----- (10008CC0) --------------------------------------------------------
int __cdecl sub_10008CC0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10016E60(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10008CF0) --------------------------------------------------------
int __cdecl sub_10008CF0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (10008E80) --------------------------------------------------------
signed int __fastcall sub_10008E80(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (10008E90) --------------------------------------------------------
char __cdecl sub_10008E90(unsigned __int8 a1)
{
  return byte_1006DE2C[6 * sub_10008E80(a1)];
}

//----- (10008EB0) --------------------------------------------------------
__int16 __cdecl sub_10008EB0(unsigned __int8 a1)
{
  return word_1006DE28[3 * sub_10008E80(a1)];
}
// 1006DE28: using guessed type __int16 word_1006DE28[];

//----- (10008ED0) --------------------------------------------------------
char *__cdecl sub_10008ED0(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = (char *)&unk_10049AD1;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (10008F20) --------------------------------------------------------
int sub_10008F20()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_10003EF0();
  result = 0;
  while ( 1 )
  {
    v3 = dword_100F5B4C[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_100F5B4C[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 100F5B4C: using guessed type int dword_100F5B4C[];

//----- (10008F60) --------------------------------------------------------
int __cdecl sub_10008F60(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10008FD0) --------------------------------------------------------
signed int __cdecl sub_10008FD0(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10009070) --------------------------------------------------------
int __usercall sub_10009070@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_10008FD0(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100090A0) --------------------------------------------------------
signed int __usercall sub_100090A0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_10008FD0((_BYTE *)a3, (int)(&off_1006E780)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_1006E784[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_10031221(a3, (int)"%ld", (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_10031221(a3, (int)"%lu", (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_10031221(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 1006E780: using guessed type char *off_1006E780;

//----- (10009270) --------------------------------------------------------
char *__usercall sub_10009270@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, " ", 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (100092D0) --------------------------------------------------------
int __usercall sub_100092D0@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_10008FD0((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10009360) --------------------------------------------------------
int __usercall sub_10009360@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_10009070(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (100093B0) --------------------------------------------------------
char **__usercall sub_100093B0@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_10008ED0(v6);
      if ( !sub_10008FD0((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (10009410) --------------------------------------------------------
const char *__usercall sub_10009410@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (10009430) --------------------------------------------------------
int __usercall sub_10009430@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_100F5B38[sub_10008F20()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100F5B38: using guessed type int dword_100F5B38[];

//----- (10009470) --------------------------------------------------------
int __usercall sub_10009470@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_100090A0(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (10009500) --------------------------------------------------------
int __usercall sub_10009500@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (10009650) --------------------------------------------------------
int __usercall sub_10009650@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_1000B3A0(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_10009F30(v3, v6, 0);
        v7 = -*v3;
        sub_1000B3A0(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_1000B3A0(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_1006E438);
      sub_10017120(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_1006E438);
      sub_1000B3A0(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (100096F0) --------------------------------------------------------
int __usercall sub_100096F0@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (10009730) --------------------------------------------------------
char *__cdecl sub_10009730(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_10009270(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_10009270(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_10009270(result, v5, (int)&v20);
      v10 = (const char *)&unk_10049AD1;
    }
    LOBYTE(v9) = 0;
    sub_10009270(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_10009270(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_10009270(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_10009270(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_1000B330(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 10009730: using guessed type int var_61C[6];

//----- (100098E0) --------------------------------------------------------
int __usercall sub_100098E0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_10008ED0((char **)a1);
  result = sub_1000B3C0(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_1006E438);
  return result;
}

//----- (10009910) --------------------------------------------------------
int __usercall sub_10009910@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_1006E438);
  v2 = (unsigned int)sub_10008ED0((char **)a1);
  return sub_1000B3A0(10, v2);
}

//----- (10009940) --------------------------------------------------------
void __cdecl sub_10009940(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_10008ED0(v5);
            v7 = sub_10008ED0((char **)v3);
            if ( !sub_10008F60(v7, (int)v6) )
            {
              v8 = sub_10008ED0((char **)v3);
              sub_1000B460(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_10008ED0((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_10008ED0((char **)v3);
        sub_1000B460(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_10009410(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_1000BE80("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_10008ED0((char **)v3);
            sub_1000B4A0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_10008F60(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_10009410(v18);
                  v25 = sub_1000BE80("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_10008ED0((char **)v3);
                  sub_1000B4A0(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_10008ED0((char **)v3);
                  sub_1000B4A0(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_10008ED0((char **)v3);
              sub_1000B4A0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_10008ED0((char **)v3);
              sub_1000B4A0(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_10008ED0((char **)v3);
              sub_1000B4A0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_10009940(*(_DWORD *)(v3 + 8) + v11 + 8, v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_10008ED0((char **)v3);
            sub_1000B4A0(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_10008ED0((char **)v3);
            sub_1000B4A0(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_10008ED0((char **)v3);
          sub_1000B4A0(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_10008ED0((char **)v3);
        sub_1000B4A0(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_10008ED0(a2);
      sub_1000B460(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (10009DB0) --------------------------------------------------------
int sub_10009DB0()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_100F5B38[sub_10008F20()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_10009940(i, 0, &v2);
  }
  return v2;
}
// 100F5B38: using guessed type int dword_100F5B38[];

//----- (10009E00) --------------------------------------------------------
void *sub_10009E00()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_100F5B38[0] = 0;
  dword_100F5B3C = 0;
  dword_100F5B40 = 0;
  dword_100F5B44 = 0;
  dword_100F5B48 = 0;
  result = &unk_100F5B60;
  dword_100F5B4C[0] = -1;
  dword_100F5B50 = -1;
  dword_100F5B54 = -1;
  dword_100F5B58 = -1;
  dword_100F5B5C = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_100096F0((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 100F5B38: using guessed type int dword_100F5B38[];
// 100F5B3C: using guessed type int dword_100F5B3C;
// 100F5B40: using guessed type int dword_100F5B40;
// 100F5B44: using guessed type int dword_100F5B44;
// 100F5B48: using guessed type int dword_100F5B48;
// 100F5B4C: using guessed type int dword_100F5B4C[];
// 100F5B50: using guessed type int dword_100F5B50;
// 100F5B54: using guessed type int dword_100F5B54;
// 100F5B58: using guessed type int dword_100F5B58;
// 100F5B5C: using guessed type int dword_100F5B5C;

//----- (10009E60) --------------------------------------------------------
char *sub_10009E60()
{
  return (char *)&unk_100F5B60 + 56 * sub_10008F20();
}

//----- (10009E80) --------------------------------------------------------
char sub_10009E80()
{
  return sub_10009E60()[33];
}

//----- (10009E90) --------------------------------------------------------
char __cdecl sub_10009E90(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_10009E60();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_1000AF20(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (10009ED0) --------------------------------------------------------
int *__usercall sub_10009ED0@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_10009E60() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_10008FD0((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (10009F20) --------------------------------------------------------
char **sub_10009F20()
{
  return &off_1006E7E8;
}
// 1006E7E8: using guessed type char *off_1006E7E8;

//----- (10009F30) --------------------------------------------------------
int __cdecl sub_10009F30(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_100100F0();
  v3 = sub_10009E60();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_10009DB0();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_100098E0(a2);
    if ( a3 )
    {
      v7 = sub_10009650(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_10009650(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_10009910(a2);
        return v7;
      }
    }
    sub_10009910(a2);
    result = v7;
  }
  return result;
}

//----- (10009FE0) --------------------------------------------------------
int __cdecl sub_10009FE0(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_10009270(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_10009270(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_10009270(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_1000B330(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_10009270(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_10009270(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_10009270(v14, "group-begin", (int)&v29);
          sub_1000B330(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_10008ED0(v15);
          sub_10009FE0(v16[2], v16[3], v16[4], v17, a4);
          sub_10008ED0(v16);
          v18 = sub_10009730((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_10009270(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_10009270(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_10009270(v20, "group-end", (int)&v29);
          result = sub_1000B330(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_10009270(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_10009270(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_10009270(v21, a4, (int)&v28);
          v23 = (const char *)&unk_10049AD1;
        }
        LOBYTE(v22) = 0;
        v24 = sub_10009270(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_10009270(v24, *(const char **)v5, (int)&v30);
        result = sub_1000B330(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 10009FE0: using guessed type int var_414[4];

//----- (1000A1F0) --------------------------------------------------------
char *__usercall sub_1000A1F0@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_10009270(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_10009270(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_1000B330(2, (int)v11, 2);
  if ( a6 )
  {
    sub_10009FE0(a3, (int)a4, a5, a2, 0);
    result = sub_10009730(a3, a4, a5, 0);
  }
  return result;
}
// 1000A1F0: using guessed type int var_20C[2];

//----- (1000A2B0) --------------------------------------------------------
char *__cdecl sub_1000A2B0(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_100F5B38[sub_10008F20()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_10008ED0((char **)v2);
    sub_1000A1F0("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_10009E60() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_1000A1F0(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 100F5B38: using guessed type int dword_100F5B38[];

//----- (1000A350) --------------------------------------------------------
int *__cdecl sub_1000A350(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_100F5B38[sub_10008F20()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_10008ED0(v2);
      if ( !sub_10008FD0(a1, (int)v4) )
      {
        v5 = sub_10008ED0(v3);
        sub_1000A1F0("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_10009E60();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_10008FD0(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_1000A1F0(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 100F5B38: using guessed type int dword_100F5B38[];

//----- (1000A410) --------------------------------------------------------
int __usercall sub_1000A410@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_10009430(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_10009F30((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_10009430(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_10009F30((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_100098E0(v5);
        sub_10009650(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_10009910(v8);
          v10 = sub_10009430(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (1000A570) --------------------------------------------------------
signed int __usercall sub_1000A570@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_100F5B38[sub_10008F20()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_10009F30((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 100F5B38: using guessed type int dword_100F5B38[];

//----- (1000A5E0) --------------------------------------------------------
int __cdecl sub_1000A5E0(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_10009E60();
  switch ( a1 )
  {
    case 9:
      sub_1000B3A0(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_10008FD0((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_10008FD0(v6, (int)"-q") )
            {
              sub_1000A350(v6);
              v9 = sub_10009DB0();
              sub_1000B3A0(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_1000A2B0(0);
              v8 = sub_10009DB0();
              sub_1000B3A0(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_1000A2B0(1);
            v7 = sub_10009DB0();
            sub_1000B3A0(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_1000B420(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_1000B3A0(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_1000A2B0(0);
        v4 = sub_10009DB0();
        sub_1000B3A0(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_1000B3A0(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_100F5B38[sub_10008F20()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_1000A5E0 )
              v12(2, (int)&unk_1006E438);
          }
        }
      }
      sub_100100F0();
      v3[34] = 0;
      return 0;
    case 3:
      sub_1000B3A0(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_100F5B38[sub_10008F20()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_1000B420(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_1000A410((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_1000B420(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_1000A570((int)v3);
    case 14:
      exit(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_1000B420(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_1000A5E0 )
          v15(3, (int)&unk_1006E438);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 1000A5E0: using guessed type int __cdecl sub_1000A5E0(int, int);
// 100F5B38: using guessed type int dword_100F5B38[];

//----- (1000A8C0) --------------------------------------------------------
char **sub_1000A8C0()
{
  return off_1006E5DC;
}
// 1006E5DC: using guessed type char *off_1006E5DC[3];

//----- (1000A8D0) --------------------------------------------------------
int __usercall sub_1000A8D0@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_10009360(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_10009470(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_1000A8C0();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (1000A9C0) --------------------------------------------------------
int __cdecl sub_1000A9C0(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_10009E60();
  *a1 = 0;
  v4 = sub_1000BE80("Processing command '%s'", v2);
  sub_1000B420(3, (int)&unk_1006EF90, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_10009500(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_1000A410((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_1000A570((int)v3);
    v11 = 0;
    v6 = sub_10008F20();
    v7 = sub_100093B0((int (**)(void))dword_100F5B38[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_100092D0((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_100092D0((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_10009F30(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_10009F30(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_1000A8D0(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_10009ED0(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_1000A8D0(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_1000A8C0();
        result = sub_1000A8D0(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 100F5B38: using guessed type int dword_100F5B38[];
// 1000A9C0: using guessed type char var_2D4[720];

//----- (1000AC00) --------------------------------------------------------
int sub_1000AC00()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_1000A9C0(&v4);
  if ( !sub_10009E60()[32] )
    sub_1000B3A0(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_1000BE80("%s %i, %s", "Command status:", v0, &v4);
    sub_1000B420(3, (int)&unk_1006EF90, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_1000BE80("%s %i", "Command status:", v0);
    sub_1000B420(3, (int)&unk_1006EF90, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (1000ACE0) --------------------------------------------------------
int __cdecl sub_1000ACE0(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_100F5B38[sub_10008F20()] = a1;
  sub_10009E60()[32] = a3;
  sub_100100F0();
  sub_10017330(a2);
  v3 = sub_10009F20();
  sub_1000AE10(v3);
  return sub_1000AC00();
}
// 100F5B38: using guessed type int dword_100F5B38[];

//----- (1000AD30) --------------------------------------------------------
int __cdecl sub_1000AD30(int a1)
{
  return a1 + 9;
}

//----- (1000AD40) --------------------------------------------------------
int __cdecl sub_1000AD40(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_10003EF0();
  memset(a1, 0, 0xDCu);
  sub_10005CD0((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_1000AD30(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_100174C0((int)a1, (int)v3);
}

//----- (1000ADC0) --------------------------------------------------------
int __cdecl sub_1000ADC0(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_100176D0(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (1000ADF0) --------------------------------------------------------
signed int __cdecl sub_1000ADF0(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_10041EF0(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_10003F60();
    }
    else if ( v6 != -57 || (unsigned int)(sub_10003F60() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_100174C0(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (1000AE10) --------------------------------------------------------
char __cdecl sub_1000AE10(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_10009E60() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_10017170("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_1000AC00() )
          v7 = 0;
      }
      v5 = sub_10017170("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_1000AC00() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (1000AF20) --------------------------------------------------------
char __cdecl sub_1000AF20(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (1000AF50) --------------------------------------------------------
bool __cdecl sub_1000AF50(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (1000AF80) --------------------------------------------------------
bool __cdecl sub_1000AF80(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (1000AFB0) --------------------------------------------------------
bool __cdecl sub_1000AFB0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (1000AFE0) --------------------------------------------------------
bool __cdecl sub_1000AFE0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (1000B010) --------------------------------------------------------
bool __cdecl sub_1000B010(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (1000B040) --------------------------------------------------------
bool __cdecl sub_1000B040(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (1000B080) --------------------------------------------------------
bool __cdecl sub_1000B080(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (1000B0C0) --------------------------------------------------------
bool __cdecl sub_1000B0C0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (1000B0F0) --------------------------------------------------------
bool __cdecl sub_1000B0F0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (1000B120) --------------------------------------------------------
char __cdecl sub_1000B120(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (1000B150) --------------------------------------------------------
bool __cdecl sub_1000B150(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (1000B180) --------------------------------------------------------
bool __cdecl sub_1000B180(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (1000B1B0) --------------------------------------------------------
bool __cdecl sub_1000B1B0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (1000B1E0) --------------------------------------------------------
bool __cdecl sub_1000B1E0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (1000B210) --------------------------------------------------------
bool __cdecl sub_1000B210(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_1006EF90, 9u);
}

//----- (1000B240) --------------------------------------------------------
bool __cdecl sub_1000B240(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (1000B270) --------------------------------------------------------
bool __cdecl sub_1000B270(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (1000B2A0) --------------------------------------------------------
bool __cdecl sub_1000B2A0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (1000B2D0) --------------------------------------------------------
bool __cdecl sub_1000B2D0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (1000B300) --------------------------------------------------------
bool __cdecl sub_1000B300(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (1000B330) --------------------------------------------------------
int __cdecl sub_1000B330(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_10009E60() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (1000B3A0) --------------------------------------------------------
int __cdecl sub_1000B3A0(int a1, char a2)
{
  return sub_1000B330(a1, (int)&a2, 1);
}

//----- (1000B3C0) --------------------------------------------------------
int __cdecl sub_1000B3C0(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_1000B330(a1, (int)&v4, 2);
}

//----- (1000B3F0) --------------------------------------------------------
int __cdecl sub_1000B3F0(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_1000B330(a1, (int)&v5, 3);
}

//----- (1000B420) --------------------------------------------------------
int __cdecl sub_1000B420(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_1000B330(a1, (int)&v6, 4);
}

//----- (1000B460) --------------------------------------------------------
int __cdecl sub_1000B460(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_1000B330(a1, (int)&v7, 5);
}

//----- (1000B4A0) --------------------------------------------------------
int __cdecl sub_1000B4A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_1000B330(a1, (int)&v8, 6);
}

//----- (1000B4F0) --------------------------------------------------------
char __cdecl sub_1000B4F0(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_10009E60();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (1000B520) --------------------------------------------------------
char __cdecl sub_1000B520(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (1000B530) --------------------------------------------------------
char __cdecl sub_1000B530(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  const char *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = "/", v3) )
          v11 = (const char *)&unk_10049AD1;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_100177F0(v16) )
        sub_100177D0((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_10017800((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 100177F0: using guessed type _DWORD __cdecl sub_100177F0(_DWORD);
// 1000B530: using guessed type char var_104[255];

//----- (1000B6B0) --------------------------------------------------------
signed int __cdecl sub_1000B6B0(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (1000B6F0) --------------------------------------------------------
signed int __cdecl sub_1000B6F0(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (1000B790) --------------------------------------------------------
char __cdecl sub_1000B790(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (1000B7F0) --------------------------------------------------------
char __cdecl sub_1000B7F0(int a1, void (__cdecl *a2)(int))
{
  char result; // al@6

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( a2 )
      a2(a1);
    sub_100177B0(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return result;
}

//----- (1000B860) --------------------------------------------------------
char *__cdecl sub_1000B860(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_100F5C78, v1, v2);
  *(&byte_100F5C78 + v2) = 0;
  return &byte_100F5C78;
}

//----- (1000B900) --------------------------------------------------------
int __cdecl sub_1000B900(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1000B970) --------------------------------------------------------
bool __cdecl sub_1000B970(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_10031221(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_10031221(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (1000BA00) --------------------------------------------------------
char __cdecl sub_1000BA00(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (1000BAB0) --------------------------------------------------------
char __cdecl sub_1000BAB0(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (1000BAC0) --------------------------------------------------------
char __cdecl sub_1000BAC0(int a1, void (__cdecl *a2)(int))
{
  char v2; // bl@1

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 324) > 0 || *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    v2 = 1;
    if ( a2 )
      a2(a1);
  }
  if ( *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    sub_100177B0(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    v2 = 1;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return v2;
}

//----- (1000BB40) --------------------------------------------------------
int (__cdecl *__cdecl sub_1000BB40(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_10017880((int)a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}

//----- (1000BB90) --------------------------------------------------------
signed int __cdecl sub_1000BB90(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@1

  sub_1000BAC0(a1, a2);
  result = 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1000BBE0) --------------------------------------------------------
char *__cdecl sub_1000BBE0(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  const char *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_10017170("CFG_ActDir", (int)&unk_10049AD1);
      v10 = sub_10017170("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_10017170("CFG_ExpDir", (int)&unk_10049AD1);
      v10 = sub_10017170("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_10017170("CFG_ActDir", (int)&unk_10049AD1);
      break;
    case 4:
      v10 = sub_10017170("CFG_ExpDir", (int)&unk_10049AD1);
      break;
    default:
      v10 = (char *)&unk_10049AD1;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = "/", v14) )
    v15 = (const char *)&unk_10049AD1;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 1000BBE0: using guessed type char var_104[256];

//----- (1000BD60) --------------------------------------------------------
int sub_1000BD60()
{
  return dword_100FA968[sub_10008F20()];
}
// 100FA968: using guessed type int dword_100FA968[];

//----- (1000BD70) --------------------------------------------------------
const char *__cdecl sub_1000BD70(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_1006F1C8[a1];
  return result;
}
// 1006F1C8: using guessed type char *off_1006F1C8[7];

//----- (1000BD90) --------------------------------------------------------
int __cdecl sub_1000BD90(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_1000B460(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (1000BE40) --------------------------------------------------------
int __cdecl sub_1000BE40(int a1)
{
  int result; // eax@1

  result = sub_10008F20();
  dword_100FCA74[result] = a1;
  return result;
}
// 100FCA74: using guessed type int dword_100FCA74[];

//----- (1000BE60) --------------------------------------------------------
int __cdecl sub_1000BE60(int a1)
{
  int result; // eax@1

  result = sub_10008F20();
  dword_100FA968[result] = a1;
  return result;
}
// 100FA968: using guessed type int dword_100FA968[];

//----- (1000BE80) --------------------------------------------------------
char *sub_1000BE80(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_10008F20() << 8;
  _vsnprintf(&byte_100F5D78[v1], 0x100u, a1, va);
  result = &byte_100F5D78[v1];
  byte_100F5E76[v1] = 42;
  byte_100F5E77[v1] = 0;
  return result;
}

//----- (1000BEC0) --------------------------------------------------------
char *__usercall sub_1000BEC0@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_1006F1DC[a1 & 1];
  else
    result = off_1006F1D4[a2];
  return result;
}
// 1006F1D4: using guessed type char *off_1006F1D4[4];
// 1006F1DC: using guessed type char *off_1006F1DC[2];

//----- (1000BEE0) --------------------------------------------------------
char __usercall sub_1000BEE0@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  const char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_10008F20();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_1000BD60() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_100FE068[v6];
      v12 = dword_100FE07C[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_100FA97C[v6];
      v12 = dword_100FCA60[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 100FA97C: using guessed type int dword_100FA97C[];
// 100FCA60: using guessed type int dword_100FCA60[];
// 100FE068: using guessed type int dword_100FE068[];
// 100FE07C: using guessed type int dword_100FE07C[];

//----- (1000C0C0) --------------------------------------------------------
int sub_1000C0C0()
{
  nullsub_1("..\\lib\\utf\\utf_verify.c", "2370");
  return 0;
}

//----- (1000C0E0) --------------------------------------------------------
int sub_1000C0E0()
{
  return nullsub_1("..\\lib\\utf\\utf_verify.c", "2396");
}

//----- (1000C100) --------------------------------------------------------
int __cdecl sub_1000C100(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10008F20();
  dword_100FCA60[result] = a1;
  if ( a2 >= 0 )
  {
    dword_100FA97C[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_1000BE80(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_1000B420(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_100FA97C[result] = 8;
  }
  return result;
}
// 100FA97C: using guessed type int dword_100FA97C[];
// 100FCA60: using guessed type int dword_100FCA60[];

//----- (1000C160) --------------------------------------------------------
int __cdecl sub_1000C160(int a1)
{
  return sub_1000C100(0, a1);
}

//----- (1000C170) --------------------------------------------------------
int __cdecl sub_1000C170(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10008F20();
  dword_100FE07C[result] = a1;
  if ( a2 >= 0 )
  {
    dword_100FE068[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_1000BE80(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_1000B420(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_100FE068[result] = 8;
  }
  return result;
}
// 100FE068: using guessed type int dword_100FE068[];
// 100FE07C: using guessed type int dword_100FE07C[];

//----- (1000C1D0) --------------------------------------------------------
int __cdecl sub_1000C1D0(int a1)
{
  return sub_1000C170(0, a1);
}

//----- (1000C1E0) --------------------------------------------------------
bool __cdecl sub_1000C1E0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_10009E80() )
    v8 = v8 == 0;
  v9 = off_1006F1AC[a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_1006F19C[v8 != 0];
  v19 = off_1006F1A4[a1];
  v18 = v10;
  v21 = sub_1000BEC0(0, a6);
  v22 = sub_1000BEC0(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_10017A60();
  sub_1000B330(7, (int)&v14, v11);
  sub_10017A70(v12);
  return v8;
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];

//----- (1000C320) --------------------------------------------------------
bool __cdecl sub_1000C320(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  unsigned __int8 v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  bool v16; // [sp+1Bh] [bp-5Dh]@2
  char v17; // [sp+1Fh] [bp-59h]@25
  unsigned int v18; // [sp+20h] [bp-58h]@1
  char *v19; // [sp+3Ch] [bp-3Ch]@28
  int v20; // [sp+40h] [bp-38h]@28
  int v21; // [sp+44h] [bp-34h]@28
  int v22; // [sp+48h] [bp-30h]@28
  char *v23; // [sp+4Ch] [bp-2Ch]@28
  char *v24; // [sp+50h] [bp-28h]@28
  const char *v25; // [sp+54h] [bp-24h]@28
  const char *v26; // [sp+58h] [bp-20h]@28
  const char *v27; // [sp+5Ch] [bp-1Ch]@28
  char *v28; // [sp+60h] [bp-18h]@28
  int v29; // [sp+64h] [bp-14h]@29
  char v30; // [sp+68h] [bp-10h]@25

  v8 = sub_10008F20();
  v18 = 9;
  switch ( a2 )
  {
    case 0:
      v16 = a6 == a7;
      break;
    case 1:
      v16 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 4:
      v16 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_38;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v16 = 1;
      if ( a6 > v10 )
LABEL_38:
        v16 = 0;
      v18 = 10;
      break;
    default:
LABEL_22:
      v16 = 0;
      break;
  }
  if ( sub_10009E80() )
    v16 = v16 == 0;
  sub_1000BEE0((int)&v30, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_100F6D68[v11], 0x400u, &v30, a6);
  byte_100F7166[v11] = 42;
  byte_100F7167[v11] = 0;
  v17 = sub_1000BEE0((int)&v30, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_100F7168[v11], 0x400u, &v30, a7);
  byte_100F7566[v11] = 42;
  byte_100F7567[v11] = 0;
  if ( v18 <= 9 )
  {
    v12 = &byte_100F7568[v11];
    byte_100F7568[v11] = 0;
  }
  else
  {
    v17 = sub_1000BEE0((int)&v30, "%c", 3, 0xCu, 0.0);
    v12 = &byte_100F7568[v11];
    _snprintf(&byte_100F7568[v11], 0x400u, &v30, 0);
    byte_100F7966[v11] = 42;
    byte_100F7967[v11] = 0;
  }
  v19 = off_1006F1AC[a2];
  v21 = a4;
  v22 = a5;
  v20 = a3;
  v25 = "char";
  v26 = &byte_100F6D68[v11];
  v27 = &byte_100F7168[v11];
  v13 = off_1006F1A4[a1];
  v23 = off_1006F19C[v16 != 0];
  v24 = v13;
  v28 = v12;
  if ( a8 )
  {
    v29 = a8;
    v18 = 11;
  }
  v14 = sub_10017A60();
  sub_1000B330(7, (int)&v19, v18);
  if ( v17 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 && !strcmp(v26, v27) )
  {
    nullsub_1(a3, a4);
    sub_1000B420(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10017A70(v14);
  return v16;
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];

//----- (1000C6D0) --------------------------------------------------------
bool __cdecl sub_1000C6D0(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  bool v20; // [sp+27h] [bp-61h]@10
  char v21; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v22; // [sp+2Ch] [bp-5Ch]@8
  char *v23; // [sp+4Ch] [bp-3Ch]@37
  int v24; // [sp+50h] [bp-38h]@37
  int v25; // [sp+54h] [bp-34h]@37
  int v26; // [sp+58h] [bp-30h]@37
  char *v27; // [sp+5Ch] [bp-2Ch]@37
  char *v28; // [sp+60h] [bp-28h]@37
  const char *v29; // [sp+64h] [bp-24h]@37
  const char *v30; // [sp+68h] [bp-20h]@37
  const char *v31; // [sp+6Ch] [bp-1Ch]@37
  char *v32; // [sp+70h] [bp-18h]@37
  int v33; // [sp+74h] [bp-14h]@38
  char v34; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_10008F20();
  v22 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 1:
      v20 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v20 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_47;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_47:
        v20 = 0;
        v22 = 10;
      }
      else
      {
        v20 = 1;
        v22 = 10;
      }
      break;
    default:
LABEL_18:
      v20 = 0;
      break;
  }
  if ( sub_10009E80() )
    v20 = v20 == 0;
  sub_1000BEE0((int)&v34, (char *)&unk_1006F490, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_100F6D68[v12], 0x400u, &v34);
  byte_100F7166[v12] = 42;
  byte_100F7167[v12] = 0;
  v21 = sub_1000BEE0((int)&v34, (char *)&unk_1006F490, 3, 0xCu, a7);
  _snprintf(&byte_100F7168[v12], 0x400u, &v34, a7);
  byte_100F7566[v12] = 42;
  byte_100F7567[v12] = 0;
  if ( v22 <= 9 )
  {
    v13 = &byte_100F7568[v12];
    byte_100F7568[v12] = 0;
  }
  else
  {
    v13 = &byte_100F7568[v12];
    v21 = sub_1000BEE0((int)&v34, (char *)&unk_1006F490, 3, 0xCu, v10);
    _snprintf(&byte_100F7568[v12], 0x400u, &v34, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_100F7966[v12] = 42;
    byte_100F7967[v12] = 0;
  }
  v23 = off_1006F1AC[a2];
  v26 = a5;
  v25 = a4;
  v24 = a3;
  v29 = "double";
  v30 = &byte_100F6D68[v12];
  v32 = v13;
  v17 = off_1006F1A4[a1];
  v27 = off_1006F19C[v20 != 0];
  v28 = v17;
  v31 = &byte_100F7168[v12];
  if ( a9 )
  {
    v33 = a9;
    v22 = 11;
  }
  v18 = sub_10017A60();
  sub_1000B330(7, (int)&v23, v22);
  if ( v21 && a6 != a7 && fabs(a6 - a7) > v10 && !strcmp(v30, v31) )
  {
    nullsub_1(a3, a4);
    sub_1000B420(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10017A70(v18);
  return v20;
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];

//----- (1000CB20) --------------------------------------------------------
bool __cdecl sub_1000CB20(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  bool v25; // [sp+1Bh] [bp-59h]@10
  char v26; // [sp+1Fh] [bp-55h]@35
  unsigned int v27; // [sp+20h] [bp-54h]@8
  float v28; // [sp+24h] [bp-50h]@8
  char *v29; // [sp+38h] [bp-3Ch]@38
  int v30; // [sp+3Ch] [bp-38h]@38
  int v31; // [sp+40h] [bp-34h]@38
  int v32; // [sp+44h] [bp-30h]@38
  char *v33; // [sp+48h] [bp-2Ch]@38
  char *v34; // [sp+4Ch] [bp-28h]@38
  const char *v35; // [sp+50h] [bp-24h]@38
  const char *v36; // [sp+54h] [bp-20h]@38
  const char *v37; // [sp+58h] [bp-1Ch]@38
  char *v38; // [sp+5Ch] [bp-18h]@38
  int v39; // [sp+60h] [bp-14h]@39
  char v40; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v28 = v13;
  v14 = v28;
  v15 = a6;
  v16 = sub_10008F20();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_48;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_48:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_32:
      v25 = 0;
      break;
  }
  if ( sub_10009E80() )
    v25 = v25 == 0;
  sub_1000BEE0((int)&v40, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_100F6D68[v20], 0x400u, &v40);
  byte_100F7166[v20] = 42;
  byte_100F7167[v20] = 0;
  v26 = sub_1000BEE0((int)&v40, "%f", 3, 0xCu, a7);
  _snprintf(&byte_100F7168[v20], 0x400u, &v40, a7);
  byte_100F7566[v20] = 42;
  byte_100F7567[v20] = 0;
  if ( v27 <= 9 )
  {
    v21 = &byte_100F7568[v20];
    byte_100F7568[v20] = 0;
  }
  else
  {
    v21 = &byte_100F7568[v20];
    v26 = sub_1000BEE0((int)&v40, "%f", 3, 0xCu, v28);
    _snprintf(&byte_100F7568[v20], 0x400u, &v40, v28);
    byte_100F7966[v20] = 42;
    byte_100F7967[v20] = 0;
  }
  v29 = off_1006F1AC[a2];
  v32 = a5;
  v31 = a4;
  v30 = a3;
  v35 = "float";
  v36 = &byte_100F6D68[v20];
  v37 = &byte_100F7168[v20];
  v38 = v21;
  v22 = off_1006F19C[v25 != 0];
  v34 = off_1006F1A4[a1];
  v33 = v22;
  if ( a9 )
  {
    v39 = a9;
    v27 = 11;
  }
  v23 = sub_10017A60();
  sub_1000B330(7, (int)&v29, v27);
  if ( v26 && a7 != a6 && v28 < fabs(a6 - a7) && !strcmp(v36, v37) )
  {
    nullsub_1(a3, a4);
    sub_1000B420(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10017A70(v23);
  return v25;
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];

//----- (1000CFE0) --------------------------------------------------------
bool __cdecl sub_1000CFE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  void *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10008F20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10009E80() )
    v17 = v17 == 0;
  sub_1000BEE0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F6D68[v12], 0x400u, &v31, a6);
  byte_100F7166[v12] = 42;
  byte_100F7167[v12] = 0;
  v18 = sub_1000BEE0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_100F7168[v12], 0x400u, &v31, a7);
  byte_100F7566[v12] = 42;
  byte_100F7567[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100F7568[v12];
    byte_100F7568[v12] = 0;
  }
  else
  {
    v18 = sub_1000BEE0((int)&v31, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_100F7568[v12];
    _snprintf(&byte_100F7568[v12], 0x400u, &v31, a8);
    byte_100F7966[v12] = 42;
    byte_100F7967[v12] = 0;
  }
  v20 = off_1006F1AC[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = &unk_1006F4D4;
  v27 = &byte_100F6D68[v12];
  v28 = &byte_100F7168[v12];
  v29 = v13;
  v14 = off_1006F19C[v17 != 0];
  v25 = off_1006F1A4[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10017A60();
  sub_1000B330(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1000B420(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10017A70(v15);
  return v17;
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];

//----- (1000D3A0) --------------------------------------------------------
bool __cdecl sub_1000D3A0(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10008F20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_37;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v17 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10009E80() )
    v17 = v17 == 0;
  sub_1000BEE0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F6D68[v12], 0x400u, &v31, a6);
  byte_100F7166[v12] = 42;
  byte_100F7167[v12] = 0;
  v18 = sub_1000BEE0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_100F7168[v12], 0x400u, &v31, a7);
  byte_100F7566[v12] = 42;
  byte_100F7567[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100F7568[v12];
    byte_100F7568[v12] = 0;
  }
  else
  {
    v13 = &byte_100F7568[v12];
    v18 = sub_1000BEE0((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_100F7568[v12], 0x400u, &v31, a8);
    byte_100F7966[v12] = 42;
    byte_100F7967[v12] = 0;
  }
  v20 = off_1006F1AC[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_100F6D68[v12];
  v21 = a3;
  v26 = "sint16";
  v28 = &byte_100F7168[v12];
  v29 = v13;
  v14 = off_1006F1A4[a1];
  v24 = off_1006F19C[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10017A60();
  sub_1000B330(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1000B420(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10017A70(v15);
  return v17;
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];

//----- (1000D7A0) --------------------------------------------------------
bool __cdecl sub_1000D7A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10008F20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10009E80() )
    v17 = v17 == 0;
  sub_1000BEE0((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F6D68[v12], 0x400u, &v31, a6);
  byte_100F7166[v12] = 42;
  byte_100F7167[v12] = 0;
  v18 = sub_1000BEE0((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_100F7168[v12], 0x400u, &v31, a7);
  byte_100F7566[v12] = 42;
  byte_100F7567[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100F7568[v12];
    byte_100F7568[v12] = 0;
  }
  else
  {
    v18 = sub_1000BEE0((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_100F7568[v12];
    _snprintf(&byte_100F7568[v12], 0x400u, &v31, a8);
    byte_100F7966[v12] = 42;
    byte_100F7967[v12] = 0;
  }
  v20 = off_1006F1AC[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "sint32";
  v27 = &byte_100F6D68[v12];
  v28 = &byte_100F7168[v12];
  v29 = v13;
  v14 = off_1006F19C[v17 != 0];
  v25 = off_1006F1A4[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10017A60();
  sub_1000B330(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1000B420(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10017A70(v15);
  return v17;
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];

//----- (1000DB60) --------------------------------------------------------
bool __cdecl sub_1000DB60(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  bool v18; // [sp+1Bh] [bp-5Dh]@3
  char v19; // [sp+1Fh] [bp-59h]@37
  unsigned int v20; // [sp+20h] [bp-58h]@1
  int v21; // [sp+30h] [bp-48h]@1
  char *v22; // [sp+3Ch] [bp-3Ch]@40
  int v23; // [sp+40h] [bp-38h]@40
  int v24; // [sp+44h] [bp-34h]@40
  int v25; // [sp+48h] [bp-30h]@40
  char *v26; // [sp+4Ch] [bp-2Ch]@40
  char *v27; // [sp+50h] [bp-28h]@40
  const char *v28; // [sp+54h] [bp-24h]@40
  const char *v29; // [sp+58h] [bp-20h]@40
  const char *v30; // [sp+5Ch] [bp-1Ch]@40
  char *v31; // [sp+60h] [bp-18h]@40
  int v32; // [sp+64h] [bp-14h]@41
  char v33; // [sp+68h] [bp-10h]@37

  v21 = sub_10008F20();
  v20 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 1:
      v18 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v18 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v18 = 0;
      }
      else
      {
        v18 = 1;
      }
LABEL_35:
      if ( sub_10009E80() )
        v18 = v18 == 0;
      sub_1000BEE0((int)&v33, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v21;
      _snprintf(&byte_100F6D68[3072 * v21], 0x400u, &v33, a6);
      byte_100F7166[v13] = 42;
      byte_100F7167[v13] = 0;
      v19 = sub_1000BEE0((int)&v33, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_100F7168[3072 * v21], 0x400u, &v33, a7);
      byte_100F7566[v13] = 42;
      byte_100F7567[v13] = 0;
      if ( v20 <= 9 )
      {
        v14 = &byte_100F7568[v13];
        byte_100F7568[v13] = 0;
      }
      else
      {
        v19 = sub_1000BEE0((int)&v33, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_100F7568[v13];
        _snprintf(&byte_100F7568[v13], 0x400u, &v33, a8);
        byte_100F7966[v13] = 42;
        byte_100F7967[v13] = 0;
      }
      v22 = off_1006F1AC[a2];
      v24 = a4;
      v25 = a5;
      v23 = a3;
      v28 = "sint64";
      v29 = &byte_100F6D68[3072 * v21];
      v30 = &byte_100F7168[3072 * v21];
      v15 = off_1006F1A4[a1];
      v26 = off_1006F19C[v18 != 0];
      v27 = v15;
      v31 = v14;
      if ( a9 )
      {
        v32 = a9;
        v20 = 11;
      }
      v16 = sub_10017A60();
      sub_1000B330(7, (int)&v22, v20);
      if ( v19 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v29, v30) )
      {
        nullsub_1(a3, a4);
        sub_1000B420(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_10017A70(v16);
      return v18;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v18 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_50;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_50:
        v18 = 0;
        v20 = 10;
      }
      else
      {
        v18 = 1;
        v20 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];

//----- (1000E0A0) --------------------------------------------------------
bool __cdecl sub_1000E0A0(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10008F20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_37;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v17 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10009E80() )
    v17 = v17 == 0;
  sub_1000BEE0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F6D68[v12], 0x400u, &v31, a6);
  byte_100F7166[v12] = 42;
  byte_100F7167[v12] = 0;
  v18 = sub_1000BEE0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_100F7168[v12], 0x400u, &v31, a7);
  byte_100F7566[v12] = 42;
  byte_100F7567[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100F7568[v12];
    byte_100F7568[v12] = 0;
  }
  else
  {
    v13 = &byte_100F7568[v12];
    v18 = sub_1000BEE0((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_100F7568[v12], 0x400u, &v31, a8);
    byte_100F7966[v12] = 42;
    byte_100F7967[v12] = 0;
  }
  v20 = off_1006F1AC[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_100F6D68[v12];
  v21 = a3;
  v26 = "sint8";
  v28 = &byte_100F7168[v12];
  v29 = v13;
  v14 = off_1006F1A4[a1];
  v24 = off_1006F19C[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10017A60();
  sub_1000B330(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1000B420(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10017A70(v15);
  return v17;
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];

//----- (1000E480) --------------------------------------------------------
bool __cdecl sub_1000E480(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10008F20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10009E80() )
    v17 = v17 == 0;
  sub_1000BEE0((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F6D68[v12], 0x400u, &v31, a6);
  byte_100F7166[v12] = 42;
  byte_100F7167[v12] = 0;
  v18 = sub_1000BEE0((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_100F7168[v12], 0x400u, &v31, a7);
  byte_100F7566[v12] = 42;
  byte_100F7567[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100F7568[v12];
    byte_100F7568[v12] = 0;
  }
  else
  {
    v18 = sub_1000BEE0((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_100F7568[v12];
    _snprintf(&byte_100F7568[v12], 0x400u, &v31, a8);
    byte_100F7966[v12] = 42;
    byte_100F7967[v12] = 0;
  }
  v20 = off_1006F1AC[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "long int";
  v27 = &byte_100F6D68[v12];
  v28 = &byte_100F7168[v12];
  v29 = v13;
  v14 = off_1006F19C[v17 != 0];
  v25 = off_1006F1A4[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10017A60();
  sub_1000B330(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1000B420(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10017A70(v15);
  return v17;
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];

//----- (1000E840) --------------------------------------------------------
bool __cdecl sub_1000E840(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10008F20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10009E80() )
    v17 = v17 == 0;
  sub_1000BEE0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F6D68[v12], 0x400u, &v31, a6);
  byte_100F7166[v12] = 42;
  byte_100F7167[v12] = 0;
  v18 = sub_1000BEE0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_100F7168[v12], 0x400u, &v31, a7);
  byte_100F7566[v12] = 42;
  byte_100F7567[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100F7568[v12];
    byte_100F7568[v12] = 0;
  }
  else
  {
    v18 = sub_1000BEE0((int)&v31, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_100F7568[v12];
    _snprintf(&byte_100F7568[v12], 0x400u, &v31, a8);
    byte_100F7966[v12] = 42;
    byte_100F7967[v12] = 0;
  }
  v20 = off_1006F1AC[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned int";
  v29 = v13;
  v14 = off_1006F19C[v17 != 0];
  v25 = off_1006F1A4[a1];
  v24 = v14;
  v27 = &byte_100F6D68[v12];
  v28 = &byte_100F7168[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10017A60();
  sub_1000B330(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1000B420(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10017A70(v15);
  return v17;
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];

//----- (1000EBE0) --------------------------------------------------------
bool __cdecl sub_1000EBE0(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10008F20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_37;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10009E80() )
    v17 = v17 == 0;
  sub_1000BEE0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F6D68[v12], 0x400u, &v31, a6);
  byte_100F7166[v12] = 42;
  byte_100F7167[v12] = 0;
  v18 = sub_1000BEE0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_100F7168[v12], 0x400u, &v31, a7);
  byte_100F7566[v12] = 42;
  byte_100F7567[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100F7568[v12];
    byte_100F7568[v12] = 0;
  }
  else
  {
    v13 = &byte_100F7568[v12];
    v18 = sub_1000BEE0((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_100F7568[v12], 0x400u, &v31, a8);
    byte_100F7966[v12] = 42;
    byte_100F7967[v12] = 0;
  }
  v20 = off_1006F1AC[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_100F6D68[v12];
  v21 = a3;
  v26 = "uint16";
  v28 = &byte_100F7168[v12];
  v29 = v13;
  v14 = off_1006F1A4[a1];
  v24 = off_1006F19C[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10017A60();
  sub_1000B330(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1000B420(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10017A70(v15);
  return v17;
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];

//----- (1000EFE0) --------------------------------------------------------
bool __cdecl sub_1000EFE0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10008F20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10009E80() )
    v17 = v17 == 0;
  sub_1000BEE0((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F6D68[v12], 0x400u, &v31, a6);
  byte_100F7166[v12] = 42;
  byte_100F7167[v12] = 0;
  v18 = sub_1000BEE0((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_100F7168[v12], 0x400u, &v31, a7);
  byte_100F7566[v12] = 42;
  byte_100F7567[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100F7568[v12];
    byte_100F7568[v12] = 0;
  }
  else
  {
    v18 = sub_1000BEE0((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_100F7568[v12];
    _snprintf(&byte_100F7568[v12], 0x400u, &v31, a8);
    byte_100F7966[v12] = 42;
    byte_100F7967[v12] = 0;
  }
  v20 = off_1006F1AC[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "uint32";
  v29 = v13;
  v14 = off_1006F19C[v17 != 0];
  v25 = off_1006F1A4[a1];
  v24 = v14;
  v27 = &byte_100F6D68[v12];
  v28 = &byte_100F7168[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10017A60();
  sub_1000B330(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1000B420(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10017A70(v15);
  return v17;
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];

//----- (1000F380) --------------------------------------------------------
bool __cdecl sub_1000F380(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  bool v19; // [sp+18h] [bp-64h]@3
  char v20; // [sp+27h] [bp-55h]@36
  unsigned int v21; // [sp+28h] [bp-54h]@1
  int v22; // [sp+2Ch] [bp-50h]@1
  char *v23; // [sp+2Ch] [bp-50h]@36
  char *v24; // [sp+40h] [bp-3Ch]@39
  int v25; // [sp+44h] [bp-38h]@39
  int v26; // [sp+48h] [bp-34h]@39
  int v27; // [sp+4Ch] [bp-30h]@39
  char *v28; // [sp+50h] [bp-2Ch]@39
  char *v29; // [sp+54h] [bp-28h]@39
  const char *v30; // [sp+58h] [bp-24h]@39
  const char *v31; // [sp+5Ch] [bp-20h]@39
  const char *v32; // [sp+60h] [bp-1Ch]@39
  char *v33; // [sp+64h] [bp-18h]@39
  int v34; // [sp+68h] [bp-14h]@40
  char v35; // [sp+6Ch] [bp-10h]@36

  v22 = sub_10008F20();
  v21 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 1:
      v19 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v19 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
LABEL_34:
      if ( sub_10009E80() )
        v19 = v19 == 0;
      sub_1000BEE0((int)&v35, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v22;
      v14 = &byte_100F6D68[3072 * v22];
      _snprintf(&byte_100F6D68[3072 * v22], 0x400u, &v35, a6);
      byte_100F7166[v13] = 42;
      byte_100F7167[v13] = 0;
      v20 = sub_1000BEE0((int)&v35, "%I64u", 6, 0xCu, (double)a7);
      v23 = &byte_100F7168[3072 * v22];
      _snprintf(&byte_100F7168[v13], 0x400u, &v35, a7);
      byte_100F7566[v13] = 42;
      byte_100F7567[v13] = 0;
      if ( v21 <= 9 )
      {
        v15 = &byte_100F7568[v13];
        byte_100F7568[v13] = 0;
      }
      else
      {
        v20 = sub_1000BEE0((int)&v35, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_100F7568[v13];
        _snprintf(&byte_100F7568[v13], 0x400u, &v35, a8);
        byte_100F7966[v13] = 42;
        byte_100F7967[v13] = 0;
      }
      v24 = off_1006F1AC[a2];
      v27 = a5;
      v26 = a4;
      v33 = v15;
      v25 = a3;
      v30 = "uint64";
      v31 = v14;
      v16 = off_1006F1A4[a1];
      v28 = off_1006F19C[v19 != 0];
      v29 = v16;
      v32 = v23;
      if ( a9 )
      {
        v34 = a9;
        v21 = 11;
      }
      v17 = sub_10017A60();
      sub_1000B330(7, (int)&v24, v21);
      if ( v20 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v31, v32) )
      {
        nullsub_1(a3, a4);
        sub_1000B420(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_10017A70(v17);
      return v19;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_49;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_49:
        v19 = 0;
        v21 = 10;
      }
      else
      {
        v19 = 1;
        v21 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];

//----- (1000F960) --------------------------------------------------------
bool __cdecl sub_1000F960(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10008F20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_37;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10009E80() )
    v17 = v17 == 0;
  sub_1000BEE0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F6D68[v12], 0x400u, &v31, a6);
  byte_100F7166[v12] = 42;
  byte_100F7167[v12] = 0;
  v18 = sub_1000BEE0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_100F7168[v12], 0x400u, &v31, a7);
  byte_100F7566[v12] = 42;
  byte_100F7567[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100F7568[v12];
    byte_100F7568[v12] = 0;
  }
  else
  {
    v13 = &byte_100F7568[v12];
    v18 = sub_1000BEE0((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_100F7568[v12], 0x400u, &v31, a8);
    byte_100F7966[v12] = 42;
    byte_100F7967[v12] = 0;
  }
  v20 = off_1006F1AC[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_100F6D68[v12];
  v21 = a3;
  v26 = "uint8";
  v28 = &byte_100F7168[v12];
  v29 = v13;
  v14 = off_1006F1A4[a1];
  v24 = off_1006F19C[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10017A60();
  sub_1000B330(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1000B420(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10017A70(v15);
  return v17;
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];

//----- (1000FD50) --------------------------------------------------------
bool __cdecl sub_1000FD50(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10008F20();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10009E80() )
    v17 = v17 == 0;
  sub_1000BEE0((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_100F6D68[v12], 0x400u, &v31, a6);
  byte_100F7166[v12] = 42;
  byte_100F7167[v12] = 0;
  v18 = sub_1000BEE0((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_100F7168[v12], 0x400u, &v31, a7);
  byte_100F7566[v12] = 42;
  byte_100F7567[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_100F7568[v12];
    byte_100F7568[v12] = 0;
  }
  else
  {
    v18 = sub_1000BEE0((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_100F7568[v12];
    _snprintf(&byte_100F7568[v12], 0x400u, &v31, a8);
    byte_100F7966[v12] = 42;
    byte_100F7967[v12] = 0;
  }
  v20 = off_1006F1AC[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned long int";
  v29 = v13;
  v14 = off_1006F19C[v17 != 0];
  v25 = off_1006F1A4[a1];
  v24 = v14;
  v27 = &byte_100F6D68[v12];
  v28 = &byte_100F7168[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10017A60();
  sub_1000B330(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_1000B420(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10017A70(v15);
  return v17;
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];

//----- (100100F0) --------------------------------------------------------
int sub_100100F0()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_10008F20();
  sub_1000BE40(1);
  sub_1000C1D0(-1);
  result = sub_1000C160(-1);
  dword_100FA968[v0] = 0;
  return result;
}
// 100FA968: using guessed type int dword_100FA968[];

//----- (10010120) --------------------------------------------------------
BOOL __usercall sub_10010120@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_10008F20();
  sub_10017AA0((int)&v13);
  sub_10017AA0((int)&v14);
  sub_10017AA0((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_100186F0((int (__cdecl *)(unsigned int))sub_1000C0C0, v7, (int)&v13) )
  {
    if ( sub_100186F0((int (__cdecl *)(unsigned int))sub_1000C0C0, a2, (int)&v14) )
    {
      v9 = sub_10018560(
             dword_100FCA74[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_1000C0C0,
             (void (__cdecl *)(_DWORD))sub_1000C0E0,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_10018990((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_10017B70((void (__cdecl *)(_DWORD))sub_1000C0E0, (int)&v12);
  sub_10017B70((void (__cdecl *)(_DWORD))sub_1000C0E0, (int)&v13);
  sub_10017B70((void (__cdecl *)(_DWORD))sub_1000C0E0, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 100FCA74: using guessed type int dword_100FCA74[];

//----- (10010290) --------------------------------------------------------
bool __usercall sub_10010290@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_10008F20();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_10009E80() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_1000E840(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_10009E80() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_100F6D68[3072 * v24], 0x400u, "%s", v9);
  byte_100F7166[v15] = 42;
  byte_100F7167[v15] = 0;
  _snprintf(&byte_100F7168[3072 * v24], 0x400u, "%s", v22);
  v16 = off_1006F1AC[a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_100F7566[v15] = 42;
  v17 = off_1006F19C[v14 != 0];
  v18 = off_1006F1A4[a3];
  byte_100F7567[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_100F6D68[3072 * v24];
  v34 = &byte_100F7168[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_10017A60();
  sub_1000B330(7, (int)&v26, v19);
  sub_10017A70(v20);
  return v14;
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];

//----- (10010500) --------------------------------------------------------
char __cdecl sub_10010500(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  unsigned int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_10008F20();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_100FCA74[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_100FE090[v10];
  sub_1000BBE0(a3, 1, a6, 0x230u, &byte_100FE090[v10]);
  v27 = &byte_100FA990[v10];
  sub_1000BBE0(a3, 2, a7, 0x230u, &byte_100FA990[v10]);
  v24 = &byte_100FBF70[v10];
  sub_1000BBE0(a3, 3, a6, 0x230u, &byte_100FBF70[v10]);
  v26 = &byte_100FCA88[v10];
  sub_1000BBE0(a3, 4, a7, 0x230u, &byte_100FCA88[v10]);
  _snprintf(&byte_100FD578[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_100FD578[v10];
  byte_100FD7A7[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_1000BBE0(a3, 0, v25, 560 - (v11 - &byte_100FD578[v10 + 1]), &byte_100FD578[v10] + v11 - &byte_100FD578[v10 + 1]);
  v13 = &byte_100FD578[v10];
  byte_100FD7A7[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_100FD574[v10] + v13 - &byte_100FD578[v10 + 1]) = 0;
  sub_1000BBE0(a3, 1, (int)&byte_100FD578[v10], 0x230u, &byte_100F6278[v10]);
  sub_1000BBE0(a3, 1, (int)&byte_100FD578[v10], 0x230u, &byte_100FB480[v10]);
  v15 = sub_10010120(v22, v27, v21, a2 == 1, (int)&byte_100F6278[v10], (const char **)&v22);
  if ( sub_10009E80() )
    v15 = v15 == 0;
  v30 = off_1006F1AC[a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_1006F1A4[a1];
  v34 = off_1006F19C[v15 != 0];
  v17 = dword_100FCA74[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_10017A60();
  sub_1000B330(7, (int)&v30, v18);
  sub_10017A70(v19);
  return v15;
}
// 1006F19C: using guessed type char *off_1006F19C[7];
// 1006F1A4: using guessed type char *off_1006F1A4[5];
// 1006F1AC: using guessed type char *off_1006F1AC[3];
// 100FCA74: using guessed type int dword_100FCA74[];

//----- (10010800) --------------------------------------------------------
bool __cdecl sub_10010800(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_1000CFE0(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (100108B0) --------------------------------------------------------
bool __cdecl sub_100108B0(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_10010290(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (100108F0) --------------------------------------------------------
const char *__cdecl sub_100108F0(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (10010930) --------------------------------------------------------
char __cdecl sub_10010930(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  char *v7; // eax@11
  int v8; // ecx@12
  int v9; // ST44_4@13
  bool v10; // zf@18
  signed int v11; // edx@24
  const char *v12; // eax@32
  _BYTE *v13; // eax@39
  int v14; // eax@44
  bool v15; // sf@44
  char v16; // cl@45
  char *v17; // eax@50
  int v18; // edx@52
  int v19; // edi@53
  unsigned int v20; // eax@53
  const char *v21; // ecx@53
  _DWORD *v22; // edx@53
  int v23; // esi@57
  int v24; // eax@58
  _BYTE *v25; // ecx@58
  _BYTE *v26; // edx@58
  int v27; // eax@60
  _BYTE *v28; // ecx@60
  _BYTE *v29; // edx@60
  _BYTE *v30; // ecx@62
  _BYTE *v31; // edx@62
  signed int v32; // eax@64
  signed int v33; // edi@73
  int v34; // esi@74
  int v35; // ecx@76
  int v36; // edx@82
  int v37; // eax@83
  int *v38; // eax@106
  void *v39; // ebx@106
  void *v40; // edi@109
  void *v41; // esi@112
  const char *v42; // eax@114
  int v43; // ST30_4@123
  const char *v44; // eax@142
  const char *v45; // eax@148
  char *v47; // [sp-14h] [bp-340h]@69
  char v48; // [sp+12h] [bp-31Ah]@24
  char v49; // [sp+13h] [bp-319h]@21
  signed int v50; // [sp+18h] [bp-314h]@52
  void *v51; // [sp+18h] [bp-314h]@94
  void *v52; // [sp+1Ch] [bp-310h]@97
  void *v53; // [sp+20h] [bp-30Ch]@103
  void *v54; // [sp+24h] [bp-308h]@45
  char v55[508]; // [sp+28h] [bp-304h]@11
  char v56; // [sp+224h] [bp-108h]@44
  char v57; // [sp+227h] [bp-105h]@11
  char v58; // [sp+228h] [bp-104h]@123
  char v59; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v4 = sub_10008F20();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_100FEB88 + 580 * v4;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v5) = sub_1000BB90((int)v6, 0);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1000BB40((int)v6, "Resetting test status\r\n");
      return v5;
    case 1:
      LOBYTE(v5) = sub_1000B6B0((int)v6);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1000BB40((int)v6, "Clearing test status\r\n");
      return v5;
    case 11:
      LOBYTE(v5) = sub_1000BB90((int)v6, 0);
      return v5;
    case 4:
      sub_1000B530((int)v6, *a2);
      if ( v6[577] && !v6[578] )
      {
        v7 = sub_1000B860((char *)a2[1]);
        _snprintf(v55, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v7);
        v57 = 0;
        sub_1000BB40((int)v6, v55);
      }
      LOBYTE(v5) = 0;
      v8 = (int)&v6[16 * *(_DWORD *)v6 + 4];
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      return v5;
    case 5:
      v9 = *a2;
      LOBYTE(v5) = sub_1000B520((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 6:
      LOBYTE(v5) = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8] = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4] = 0;
      v10 = v6[577] == 0;
      *((_DWORD *)v6 + 143) = 0;
      if ( !v10 && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1000BB40((int)v6, v55);
      }
      return v5;
    case 7:
      v49 = sub_1000AF20((int)a2, a3);
      if ( !v49 && !v6[577] )
        goto LABEL_83;
      if ( v6[578] )
        goto LABEL_81;
      v11 = 0;
      v48 = 0;
      if ( a3 > 7 )
        v11 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v11 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v11 += strlen((const char *)a2[3]);
      if ( v11 > 100 )
        v48 = 1;
      v12 = sub_100108F0((int)v6, (unsigned __int8)v49);
      _snprintf(v55, 0x200u, "%s ", v12);
      v57 = 0;
      sub_1000BB40((int)v6, v55);
      if ( a3 > 7 )
      {
        _snprintf(v55, 0x200u, " ACT: %-17s", a2[7]);
        v57 = 0;
        sub_1000BB40((int)v6, v55);
        if ( v48 )
          sub_1000BB40((int)v6, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v55, 0x200u, " EXP: %-17s", a2[8]);
        v57 = 0;
        sub_1000BB40((int)v6, v55);
        if ( v48 )
          sub_1000BB40((int)v6, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v13 = (_BYTE *)a2[9];
        if ( v13 )
        {
          if ( *v13 )
          {
            if ( memcmp((const void *)a2[9], "0", 2u) )
            {
              _snprintf(v55, 0x200u, " TOL: %-17s", a2[9]);
              v57 = 0;
              sub_1000BB40((int)v6, v55);
              if ( v48 )
                sub_1000BB40((int)v6, "\r\n     ");
            }
          }
        }
      }
      v14 = _snprintf(v55, 0x1FCu, " %s", a2[3]);
      v15 = v14 < 0;
      v56 = 0;
      if ( v14 > 0 )
      {
        do
        {
          v16 = *((_BYTE *)&v54 + v14 + 3);
          if ( v16 != 10 && v16 != 13 )
            break;
          *((_BYTE *)&v54 + --v14 + 4) = 0;
        }
        while ( v14 > 0 );
        v15 = v14 < 0;
      }
      if ( !v15 )
      {
        v17 = &v55[v14];
        *(_WORD *)v17 = 2573;
        v17[2] = 0;
      }
      sub_1000BB40((int)v6, v55);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v18 = 10;
      v50 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v19 = v3[v18];
        v20 = 6;
        v21 = "Info: ";
        v22 = (_DWORD *)v3[v18];
        do
        {
          if ( *v22 != *(_DWORD *)v21 )
            goto LABEL_57;
          v20 -= 4;
          v21 += 4;
          ++v22;
        }
        while ( v20 >= 4 );
        if ( !v20 )
          goto LABEL_67;
LABEL_57:
        v23 = *(_BYTE *)v22 - *v21;
        if ( *(_BYTE *)v22 == *v21 )
        {
          v24 = v20 - 1;
          v25 = v21 + 1;
          v26 = (char *)v22 + 1;
          if ( !v24
            || (v23 = *v26 - *v25, *v26 == *v25)
            && ((v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, !v27)
             || (v23 = *v29 - *v28, *v29 == *v28)
             && ((v30 = v28 + 1, v31 = v29 + 1, v27 == 1) || (v23 = *v31 - *v30, *v31 == *v30))) )
          {
            v3 = a2;
LABEL_67:
            v32 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v32 = 1;
        if ( v23 <= 0 )
          v32 = -1;
LABEL_68:
        if ( v32 )
        {
          _snprintf(v55, 0x200u, "      Post Analysis: %s\r\n", v19);
          v47 = v55;
        }
        else
        {
          _snprintf(v55, 0x200u, "      Compare Info: %s\r\n", v19 + 6);
          v47 = v55;
        }
        v57 = 0;
        sub_1000BB40((int)v6, v47);
        v18 = v50++ + 1;
      }
      while ( v50 < (signed int)a3 );
LABEL_72:
      if ( v6[309] )
      {
        v33 = 0;
        if ( *((_DWORD *)v6 + 143) > 0 )
        {
          v34 = (int)(v6 + 336);
          do
          {
            if ( v33 >= 20 )
              break;
            v35 = *(_DWORD *)(v34 - 4);
            if ( *(_DWORD *)(v34 + 4) )
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v33, v35, *(_DWORD *)v34, *(_DWORD *)(v34 + 4));
            else
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s\r\n", v33, v35, *(_DWORD *)v34);
            v57 = 0;
            sub_1000BB40((int)v6, v55);
            ++v33;
            v34 += 12;
          }
          while ( v33 < *((_DWORD *)v6 + 143) );
        }
        _snprintf(v55, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v57 = 0;
        sub_1000BB40((int)v6, v55);
      }
LABEL_81:
      if ( v49 )
      {
        v36 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v36 + 4];
        v5 = (int)&v6[v36 + 4];
      }
      else
      {
LABEL_83:
        v37 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v37 + 8];
        v5 = (int)&v6[v37 + 8];
      }
      return v5;
    case 9:
      LOBYTE(v5) = sub_1000B790((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 3:
      LOBYTE(v5) = sub_1000B240((const void **)a2, a3);
      if ( !(_BYTE)v5 && !v6[578] )
      {
        if ( v6[577]
          || sub_1000B300((const void **)a2, a3)
          || (LOBYTE(v5) = sub_1000B150((const void **)a2, a3), (_BYTE)v5) )
        {
          if ( a3 <= 8 )
            v51 = &unk_10049AD1;
          else
            v51 = (void *)a2[8];
          if ( a3 <= 7 )
            v52 = &unk_10049AD1;
          else
            v52 = (void *)a2[7];
          if ( a3 <= 6 )
            v54 = &unk_10049AD1;
          else
            v54 = (void *)a2[6];
          if ( a3 <= 5 )
            v53 = &unk_10049AD1;
          else
            v53 = (void *)a2[5];
          if ( a3 <= 4 )
          {
            v38 = a2;
            v39 = &unk_10049AD1;
          }
          else
          {
            v38 = a2;
            v39 = (void *)a2[4];
          }
          if ( a3 <= 3 )
            v40 = &unk_10049AD1;
          else
            v40 = (void *)v38[3];
          if ( a3 )
            v41 = (void *)*v38;
          else
            v41 = &unk_10049AD1;
          v10 = sub_1000B210((const void **)a2, a3) == 0;
          v42 = (const char *)&unk_10049AD1;
          if ( v10 )
            v42 = "   ";
          _snprintf(v55, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v42, v41, v40, v39, v53, v54, v52, v51);
          v57 = 0;
          LOBYTE(v5) = (unsigned int)sub_1000BB40((int)v6, v55);
        }
      }
      return v5;
    case 2:
      if ( v6[578] )
        return v5;
      if ( sub_1000AF50((const void **)a2, a3) )
      {
        dword_100FEB80 = 2;
        sub_1000BB40((int)v6, (const char *)&word_100704CC);
        sub_1000BB40((int)v6, "   Command Format:\r\n");
        sub_1000BB40(
          (int)v6,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_1000BB40(
          (int)v6,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_1000BB40(
          (int)v6,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_1000BB40(
          (int)v6,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_1000BB40((int)v6, "                                         strings depending upon the command\r\n");
        sub_1000BB40((int)v6, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_1000BB40(
          (int)v6,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_1000BB40(
          (int)v6,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_1000BB40((int)v6, (const char *)&word_100704CC);
        sub_1000BB40((int)v6, "   Notes:\r\n");
        sub_1000BB40((int)v6, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_1000BB40((int)v6, (const char *)&word_100704CC);
        sub_1000BB40(
          (int)v6,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_1000BB40(
          (int)v6,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_1000BB40(
          (int)v6,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_1000BB40((int)v6, "       the suite name and the test case or test suite command.\r\n");
        sub_1000BB40((int)v6, (const char *)&word_100704CC);
        sub_1000BB40(
          (int)v6,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_1000BB40(
          (int)v6,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_1000BB40((int)v6, "       without a test suite name.\r\n");
        sub_1000BB40((int)v6, (const char *)&word_100704CC);
        sub_1000BB40((int)v6, "   Examples:\r\n");
        sub_1000BB40(
          (int)v6,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_1000BB40((int)v6, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_1000BB40(
          (int)v6,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_1000BB40(
          (int)v6,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_1000BB40(
          (int)v6,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_1000BB40(
          (int)v6,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_1000BB40(
          (int)v6,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_1000BB40(
          (int)v6,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_1000BB40((int)v6, (const char *)&word_100704CC);
        sub_1000BB40((int)v6, "   Command                                 Description\r\n");
        LOBYTE(v5) = (unsigned int)sub_1000BB40(
                                     (int)v6,
                                     "   --------------------------------        --------------------------------\r\n");
        return v5;
      }
      if ( sub_1000AFE0((const void **)a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_1000BB40((int)v6, (const char *)&word_100704CC);
        return v5;
      }
      if ( sub_1000AFB0((const void **)a2, a3) )
      {
        _snprintf(&v58, 0x100u, "%s %s", a2[3], a2[4]);
        v43 = a2[5];
        v59 = 0;
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_100FEB80,
          &unk_10049AD1,
          &v58,
          6 - dword_100FEB80,
          " ",
          v43);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1000BB40((int)v6, v55);
        return v5;
      }
      if ( sub_1000B010((const void **)a2, a3) )
      {
        LOBYTE(v5) = sub_1000B040((int)a2, a3);
        if ( (_BYTE)v5 )
        {
          dword_100FEB80 += 2;
          return v5;
        }
        if ( sub_1000B080((int)a2, a3) )
        {
          LOBYTE(v5) = 2;
          if ( dword_100FEB80 < 2 )
            dword_100FEB80 = 0;
          else
            dword_100FEB80 -= 2;
          return v5;
        }
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_100FEB80,
          &unk_10049AD1,
          a2[2],
          6 - dword_100FEB80,
          " ",
          a2[2]);
LABEL_134:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1000BB40((int)v6, v55);
        return v5;
      }
      if ( sub_1000AF80((const void **)a2, a3) )
      {
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_100FEB80,
          &unk_10049AD1,
          a2[3],
          6 - dword_100FEB80,
          " ",
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_1000B0F0((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1000BB40((int)v6, v55);
      }
      else if ( sub_1000B0C0((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1000BB40((int)v6, v55);
      }
      else
      {
        LOBYTE(v5) = (unsigned int)sub_1000BB40((int)v6, "Unknown test help event\r\n");
      }
      return v5;
    case 8:
      if ( v6[577] && !v6[578] )
      {
        v44 = sub_100108F0((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        _snprintf(v55, 0x200u, "\r\n   Test Case Results: %s\r\n", v44);
        v57 = 0;
        sub_1000BB40((int)v6, v55);
        _snprintf(v55, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8]);
        v57 = 0;
        sub_1000BB40((int)v6, v55);
        _snprintf(v55, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        v57 = 0;
        sub_1000BB40((int)v6, v55);
      }
      v5 = (int)&v6[16 * *(_DWORD *)v6];
      if ( *(_DWORD *)(v5 + 4) )
        ++*(_DWORD *)(v5 + 12);
      else
        ++*(_DWORD *)(v5 + 16);
      return v5;
    case 10:
      if ( v6[577] && !v6[578] )
      {
        v45 = sub_100108F0((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        _snprintf(v55, 0x200u, "\r\nTest Suite Results: %s\r\n", v45);
        v57 = 0;
        sub_1000BB40((int)v6, v55);
        _snprintf(v55, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v6[16 * (*(_DWORD *)v6 + 1)]);
        v57 = 0;
        sub_1000BB40((int)v6, v55);
        _snprintf(v55, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        v57 = 0;
        sub_1000BB40((int)v6, v55);
      }
      LOBYTE(v5) = sub_1000B7F0((int)v6, 0);
      return v5;
    case 12:
      LOBYTE(v5) = sub_1000BAC0((int)v6, 0);
      return v5;
    case 13:
      if ( a3 >= 2 )
      {
        v5 = *((_DWORD *)v6 + 143);
        if ( v5 < 20 )
        {
          *(_DWORD *)&v6[12 * v5 + 332] = *a2;
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143) + 28)] = a2[1];
          v5 = 3 * *((_DWORD *)v6 + 143);
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143))++ + 340] = a2[2];
        }
      }
      return v5;
    case 14:
      --*((_DWORD *)v6 + 143);
      return v5;
    default:
      if ( !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1000BB40((int)v6, "Unknown test event\r\n");
      return v5;
  }
}
// 100704CC: using guessed type __int16 word_100704CC;
// 100FEB80: using guessed type int dword_100FEB80;
// 10010930: using guessed type char var_304[508];

//----- (100116E0) --------------------------------------------------------
signed int __cdecl sub_100116E0(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_100FEB88 + 580 * sub_10008F20();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_1000B6F0(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (10011760) --------------------------------------------------------
char **__cdecl sub_10011760(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_100FEB88 + 580 * sub_10008F20();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_1000B900((int)v1, a1, (int)".txt");
  return &off_1006F898;
}
// 1006F898: using guessed type char *off_1006F898;

//----- (100117A0) --------------------------------------------------------
int (**sub_100117A0())()
{
  return off_10070588;
}
// 10070588: using guessed type int (*off_10070588[2])();

//----- (100117B0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100117B0(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_10008F20();
  return sub_1000BB40((int)&unk_100FF6E0 + 1812 * v1, a1);
}

//----- (100117D0) --------------------------------------------------------
const char *sub_100117D0()
{
  return "See version control for test execution date";
}

//----- (100117E0) --------------------------------------------------------
__int64 sub_100117E0()
{
  return 0i64;
}

//----- (100117F0) --------------------------------------------------------
const char *sub_100117F0()
{
  return "Not Available";
}

//----- (10011800) --------------------------------------------------------
int __usercall sub_10011800@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (10011850) --------------------------------------------------------
signed int __cdecl sub_10011850(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10008F20();
  return sub_1000B6F0(a1, a2, (int)&unk_100FF6E0 + 1812 * v2);
}

//----- (100119A0) --------------------------------------------------------
int __usercall sub_100119A0@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  int v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_10020380((int)&a2[151 * (*a2 + 1)], (int)sub_100117B0, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_100117E0();
  v4 = sub_10017170("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_100207D0((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_10017170("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_100207D0((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_100207D0((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_10020750((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_100205E0((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_10017170("CFG_OutputTestRevision", (int)"False");
  if ( !sub_10008FD0(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_10020820((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_10020820((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_10020750((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_10020750((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_10020820((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_1000B860(v3);
  sub_10020820((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_100206D0((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_10017130(i, &v15, &v16); ++i )
  {
    sub_10020750((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_10020820((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_10020820((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_100206D0((int)&a2[151 * (*a2 + 1)]);
  }
  sub_100206D0((int)&a2[151 * (*a2 + 1)]);
  sub_10020750((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_100205E0((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = (int)&a2[4 * *a2 + 1];
  *(_DWORD *)v14 = 0;
  *(_DWORD *)(v14 + 4) = 0;
  *(_DWORD *)(v14 + 8) = 0;
  *(_DWORD *)(v14 + 12) = 0;
  return result;
}
// 100119A0: using guessed type char var_103[253];

//----- (10011D20) --------------------------------------------------------
char __cdecl sub_10011D20(int a1, const void **a2, unsigned int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  char *v5; // ebp@1
  const char *v6; // ebx@3
  int v7; // esi@4
  int v8; // ST14_4@5
  int v9; // eax@12
  const char *v10; // eax@13
  const char *v11; // eax@15
  int v12; // ST14_4@17
  int v13; // ecx@29
  const void *v14; // ST24_4@43
  int v15; // ST04_4@44
  _BYTE *v16; // eax@87
  _BYTE *v17; // eax@94
  _BYTE *v18; // eax@100
  int v19; // ST20_4@104
  unsigned int v20; // esi@105
  _DWORD *v21; // edx@106
  unsigned int v22; // eax@106
  const char *v23; // ecx@106
  int v24; // esi@110
  int v25; // eax@111
  _BYTE *v26; // ecx@111
  _BYTE *v27; // edx@111
  int v28; // eax@113
  _BYTE *v29; // ecx@113
  _BYTE *v30; // edx@113
  _BYTE *v31; // ecx@115
  _BYTE *v32; // edx@115
  bool v33; // zf@117
  bool v34; // sf@117
  signed int v35; // eax@117
  const char *v36; // eax@129
  const char *v37; // eax@131
  const char *v39; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v40; // [sp-Ch] [bp-120h]@73
  char v41; // [sp+9h] [bp-10Bh]@46
  char v42; // [sp+Ah] [bp-10Ah]@46
  char v43; // [sp+Bh] [bp-109h]@46
  const char *v44; // [sp+Ch] [bp-108h]@91
  signed int v45; // [sp+Ch] [bp-108h]@105
  char v46[255]; // [sp+10h] [bp-104h]@5
  char v47; // [sp+10Fh] [bp-5h]@44

  v3 = sub_10008F20();
  LOBYTE(v4) = a1;
  v5 = (char *)&unk_100FF6E0 + 1812 * v3;
  switch ( a1 )
  {
    case 3:
      if ( sub_1000B2A0(a2, a3) )
      {
        v6 = (const char *)a2[3];
        do
        {
          v4 = sub_10011800(", \t", (int)v6);
          v7 = v4;
          if ( v4 )
          {
            strncpy(v46, v6, v4);
            v8 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
            v46[v7] = 0;
            sub_10020750(v8, (int)"Req");
            sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"id", (unsigned __int8 *)v46);
            LOBYTE(v4) = (unsigned int)sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
            v6 += v7;
          }
          else
          {
            ++v6;
          }
        }
        while ( *v6 );
      }
      else if ( sub_1000B270(a2, a3) )
      {
        if ( sub_1000BA00((int)v5, 3, 1, 0) )
          sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        v9 = *((_DWORD *)v5 + 146);
        if ( v9 > 0 )
        {
          *((_DWORD *)v5 + 146) = v9 - 1;
          sub_10020750((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
          v10 = "true";
          if ( *((_DWORD *)v5 + 144) <= 0 )
            v10 = "false";
          sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v10);
          v11 = "true";
          if ( *((_DWORD *)v5 + 145) <= 0 )
            v11 = "false";
          sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v11);
          sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          v12 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          *((_DWORD *)v5 + 144) = 0;
          *((_DWORD *)v5 + 145) = 0;
          sub_100206D0(v12);
          sub_10020750((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        }
        LOBYTE(v4) = (unsigned int)sub_100205E0(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_1000B1B0(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_10020820(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 146);
      }
      else if ( sub_1000B2D0(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_10020820(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_1000B240(a2, a3) )
      {
        if ( sub_1000BA00((int)v5, 3, 1, 0) )
          sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1000B970((int)a2, a3, (int)v5);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_10020750((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      }
      else if ( sub_1000B1E0(a2, a3) )
      {
        sub_10020750((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Results");
        v13 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_100205E0(v13, (int)"success", (unsigned __int8 *)"0");
          sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_100205E0(v13, (int)"success", (unsigned __int8 *)"1");
        }
        if ( v5[309] )
        {
          sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1000BA00((int)v5, 3, 0, 0);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = (unsigned int)sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      else
      {
        LOBYTE(v4) = sub_1000B180(a2, a3);
        if ( (_BYTE)v4 )
        {
          if ( !sub_1000BAB0((int)v5) )
            sub_10020750((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
          sub_10020820((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v4) = sub_1000BA00((int)v5, 3, 0, 1);
          if ( (_BYTE)v4 )
            LOBYTE(v4) = (unsigned int)sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      return v4;
    case 4:
      LOBYTE(v4) = sub_1000B530((int)v5, (int)*a2);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_100119A0((char *)a2[1], v5, (int)*a2);
      return v4;
    case 5:
      v14 = *a2;
      LOBYTE(v4) = sub_1000B520((int)v5);
      if ( !(_BYTE)v4 )
      {
        sub_10020750((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        _snprintf(v46, 0x100u, "Test Group: %s", *a2);
        v15 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        v47 = 0;
        sub_10020820(v15, (int)"Method", (unsigned __int8 *)v46);
        LOBYTE(v4) = (unsigned int)sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      return v4;
    case 6:
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      LOBYTE(v4) = sub_10020750((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
      return v4;
    case 7:
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v42 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v43 = 1;
LABEL_55:
        v41 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v5 + 146) )
      {
        sub_10020820(
          (int)&v5[604 * (*(_DWORD *)v5 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_10020820((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v5 + 146);
      }
      if ( !sub_1000BAB0((int)v5) )
        sub_10020750((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      if ( sub_1000B120((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_10020750((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction");
          sub_10020680((int)&v5[604 * (*(_DWORD *)v5 + 1)], (unsigned __int8 *)a2[3]);
          sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
        ++*((_DWORD *)v5 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_10020820((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 144);
      }
      sub_10020750((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Compare");
      if ( sub_1000AF20((int)a2, a3) )
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 4];
        sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 8];
        sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v41 )
      {
        sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v43 )
        {
          sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v40 = (unsigned __int8 *)"true";
        v39 = "strict";
      }
      else
      {
        v40 = (unsigned __int8 *)a2[6];
        v39 = "datatype";
      }
      sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)v39, v40);
LABEL_77:
      if ( v5[309] )
      {
        sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_10020750((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Actual");
        if ( v42 )
          sub_10020630((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v42 )
        {
          sub_10020750((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Expected");
          sub_10020630((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          if ( a3 > 9 )
          {
            v16 = a2[9];
            if ( v16 )
            {
              if ( *v16 )
              {
                sub_10020750((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Tolerance");
                sub_10020630((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v41 )
          {
            v44 = "!";
            if ( memcmp(*a2, "NE", 3u) )
              v44 = (const char *)&unk_10049AD1;
            if ( a3 > 9 && (v17 = a2[9]) != 0 && *v17 && memcmp(a2[9], "0", 2u) )
              _snprintf(v46, 0x100u, "%s%s+/-%s", v44, a2[8], a2[9]);
            else
              _snprintf(v46, 0x100u, "%s%s", v44, a2[8]);
          }
          else if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 )
          {
            _snprintf(v46, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v46, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v19 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          v47 = 0;
          sub_10020750(v19, (int)"Expected");
          sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)v46);
          sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      v20 = 10;
      v45 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_1000BA00((int)v5, 8, 1, 0) )
        sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      sub_10020750((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
      v36 = "true";
      if ( *((_DWORD *)v5 + 144) <= 0 )
        v36 = "false";
      sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v36);
      v37 = "true";
      if ( *((_DWORD *)v5 + 145) <= 0 )
        v37 = "false";
      sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v37);
      sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      LOBYTE(v4) = (unsigned int)sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      return v4;
    case 9:
      LOBYTE(v4) = sub_1000B790((int)v5);
      return v4;
    case 10:
      LOBYTE(v4) = sub_1000B7F0((int)v5, (void (__cdecl *)(int))sub_10011880);
      return v4;
    case 0:
    case 11:
      sub_1000BB90((int)v5, (void (__cdecl *)(int))sub_10011880);
      goto LABEL_139;
    case 1:
      sub_1000B6B0((int)v5);
      goto LABEL_139;
    case 12:
      sub_1000BAC0((int)v5, (void (__cdecl *)(int))sub_10011880);
LABEL_139:
      LOBYTE(v4) = 0;
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      return v4;
    default:
      return v4;
  }
  do
  {
    v21 = a2[v20];
    v22 = 6;
    v23 = "Info: ";
    do
    {
      if ( *v21 != *(_DWORD *)v23 )
        goto LABEL_110;
      v22 -= 4;
      v23 += 4;
      ++v21;
    }
    while ( v22 >= 4 );
    if ( !v22 )
      goto LABEL_120;
LABEL_110:
    v24 = *(_BYTE *)v21 - *v23;
    if ( *(_BYTE *)v21 == *v23 )
    {
      v25 = v22 - 1;
      v26 = v23 + 1;
      v27 = (char *)v21 + 1;
      if ( !v25
        || (v24 = *v27 - *v26, *v27 == *v26)
        && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
         || (v24 = *v30 - *v29, *v30 == *v29)
         && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
      {
        v20 = v45;
LABEL_120:
        v35 = 0;
        goto LABEL_121;
      }
    }
    v33 = v24 == 0;
    v34 = v24 < 0;
    v20 = v45;
    v35 = 1;
    if ( v34 || v33 )
      v35 = -1;
LABEL_121:
    if ( v35 )
    {
      sub_10020750((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"PostAnalysis");
      sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"note", (unsigned __int8 *)a2[v20]);
      sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    else
    {
      sub_10020750((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"CompareInfo");
      sub_100205E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v20] + 6);
      sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    v45 = ++v20;
  }
  while ( v20 < a3 );
LABEL_125:
  sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  LOBYTE(v4) = sub_1000BA00((int)v5, 7, 0, 1);
  if ( (_BYTE)v4 )
    LOBYTE(v4) = (unsigned int)sub_100206D0((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  return v4;
}
// 10011880: using guessed type int sub_10011880();
// 10011D20: using guessed type char var_104[255];

//----- (10012B40) --------------------------------------------------------
char **__cdecl sub_10012B40(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_100FF6E0 + 1812 * sub_10008F20();
  *((_DWORD *)v1 + 146) = 0;
  sub_1000B900((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_10020380(v2, (int)sub_100117B0, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_10070638;
}
// 10070638: using guessed type char *off_10070638;

//----- (10012BB0) --------------------------------------------------------
int sub_10012BB0()
{
  int result; // eax@1

  sub_10004310(6361, (int)&unk_10101A44, 4);
  result = sub_10004310(6362, (int)&unk_10101A48, 4);
  dword_10101A4C = 1379255385;
  return result;
}
// 10101A4C: using guessed type int dword_10101A4C;

//----- (10012BE0) --------------------------------------------------------
char __thiscall sub_10012BE0(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_10101A50 = sub_10005240(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_10101A58, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_10101A58;
  do
  {
    result = sub_10013F70(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 10101A50: using guessed type int dword_10101A50;

//----- (10012C50) --------------------------------------------------------
char __usercall sub_10012C50@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_10008AF0(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_10008AF0(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (10012C90) --------------------------------------------------------
void *__usercall sub_10012C90@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_10101A50 == 1379255385 )
    goto LABEL_4;
  v4 = sub_10004210(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_10101A58 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_10013F70(a1, (int)&unk_10101A58 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy(a4, (char *)&unk_10101A58 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2, (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_10101A50 != 1379255385 )
    result = (void *)sub_100041E0(v4, 86);
  return result;
}
// 10101A50: using guessed type int dword_10101A50;

//----- (10012D30) --------------------------------------------------------
char __cdecl sub_10012D30(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_10012C50(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (10012D70) --------------------------------------------------------
bool __cdecl sub_10012D70(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_10012C90(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (10012DD0) --------------------------------------------------------
char __cdecl sub_10012DD0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_10012C50(a2, 1, a3, a1);
  return result;
}

//----- (10012E10) --------------------------------------------------------
char __cdecl sub_10012E10(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_10012C90(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10012E40) --------------------------------------------------------
char __cdecl sub_10012E40(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_10012C50(a2 + 10, 1, a3, a1);
  return result;
}

//----- (10012E80) --------------------------------------------------------
char __cdecl sub_10012E80(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_10012C90(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10012EC0) --------------------------------------------------------
char __cdecl sub_10012EC0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_10012C50(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (10012F00) --------------------------------------------------------
bool __cdecl sub_10012F00(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_10012C90(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (10012F50) --------------------------------------------------------
char __cdecl sub_10012F50(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_10012C50(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (10012F90) --------------------------------------------------------
bool __cdecl sub_10012F90(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_10012C90(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (10012FD0) --------------------------------------------------------
char __cdecl sub_10012FD0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_10012C50(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (10013010) --------------------------------------------------------
bool __cdecl sub_10013010(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_10012C90(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (10013050) --------------------------------------------------------
char __cdecl sub_10013050(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10012C50(1229, 1, a2, a1);
  return result;
}

//----- (10013080) --------------------------------------------------------
char __cdecl sub_10013080(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10012C90(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (100130B0) --------------------------------------------------------
char __cdecl sub_100130B0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10012C50(1212, 16, a2, a1);
  return result;
}

//----- (100130E0) --------------------------------------------------------
char __cdecl sub_100130E0(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10012C90(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10013110) --------------------------------------------------------
char __cdecl sub_10013110(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10012C50(2400, 65, a2, a1);
  return result;
}

//----- (10013140) --------------------------------------------------------
char __cdecl sub_10013140(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10012C90(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10013170) --------------------------------------------------------
char __cdecl sub_10013170(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_10012C50(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (100131B0) --------------------------------------------------------
char __cdecl sub_100131B0(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_10003DC0("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_10012C90(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (10013200) --------------------------------------------------------
char __cdecl sub_10013200(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_10012C50(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (10013240) --------------------------------------------------------
char __cdecl sub_10013240(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_10012C90(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (10013270) --------------------------------------------------------
char __cdecl sub_10013270(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10012C50(22, 1, a2, a1);
  return result;
}

//----- (100132A0) --------------------------------------------------------
char __cdecl sub_100132A0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10012C50(832, 4, a2, a1);
  return result;
}

//----- (100132D0) --------------------------------------------------------
char __cdecl sub_100132D0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10012C90(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (10013300) --------------------------------------------------------
char __cdecl sub_10013300(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_100208C0(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_100131B0(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10013170(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_10013240(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10013200(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_10012D70(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10012D30(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_10012F90(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10012F50(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_10013010(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10012FD0(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_10012E10(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10012DD0(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_10012E80(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10012E40(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_10013270(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_100130E0(v6, a5);
        else
          result = sub_100130B0(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_10012F00(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10012EC0(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10013140(v6, a5);
        else
          result = sub_10013110(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10013080(v6, a5);
        else
          result = sub_10013050(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_100132D0(v6, a5);
        else
          result = sub_100132A0(v6, a5);
        break;
      default:
        sub_10003DC0("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 100047C0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (100136A0) --------------------------------------------------------
bool __cdecl sub_100136A0(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_10102F98 != 1379255385 )
    {
      sub_10013F50(a1, (int)&byte_10102FA0[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_10102FA5[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_10102FA4[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 10102F98: using guessed type int dword_10102F98;

//----- (10013710) --------------------------------------------------------
bool __cdecl sub_10013710(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_10102F98 != 1379255385 )
      sub_10013F50(a1, (int)&byte_10102FA0[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_10102FB4[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10102F98: using guessed type int dword_10102F98;
// 10102FB4: using guessed type int dword_10102FB4[];

//----- (10013770) --------------------------------------------------------
bool __cdecl sub_10013770(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_10102F98 != 1379255385 )
    {
      sub_10013F50(a1, (int)&byte_10102FA0[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_10102FAC[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 10102F98: using guessed type int dword_10102F98;
// 10102FAC: using guessed type int dword_10102FAC[];

//----- (100137E0) --------------------------------------------------------
char __cdecl sub_100137E0(char a1, _BYTE *a2)
{
  if ( dword_10102F98 != 1379255385 )
    sub_10013F50(a1, (int)&byte_10102FA0[24 * (unsigned __int8)a1]);
  *a2 = byte_10102FA0[24 * (unsigned __int8)a1];
  return 1;
}
// 10102F98: using guessed type int dword_10102F98;

//----- (10013820) --------------------------------------------------------
char __thiscall sub_10013820(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_10102F98 = sub_10005240(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_10102FA0, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_10102FA0;
  do
  {
    result = sub_10013F50(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 10102F98: using guessed type int dword_10102F98;

//----- (10013890) --------------------------------------------------------
char __cdecl sub_10013890(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_100053F0(a1);
  v3 = sub_100424B0(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (100138C0) --------------------------------------------------------
char __cdecl sub_100138C0(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_100053F0(a1);
  v3 = sub_10042520(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (100138F0) --------------------------------------------------------
char __cdecl sub_100138F0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_100054E0(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_10013770(v7, *a4, (int)a5);
      }
      else
      {
        sub_10003DC0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_100136A0(v7, *a4, (int)a5);
      }
      else
      {
        sub_10003DC0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_10013710(v7, *a4, (int)a5);
      }
      else
      {
        sub_10003DC0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_100137E0(v7, a5);
      }
      else
      {
        sub_10003DC0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_100138C0(v7, (int)a5);
      }
      else
      {
        sub_10003DC0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_10013890(v7, (int)a5);
      }
      else
      {
        sub_10003DC0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10003DC0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10013AC0) --------------------------------------------------------
int __cdecl sub_10013AC0(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10102FE8 = *(_DWORD *)a1;
  dword_10102FEC = *(_DWORD *)(a1 + 4);
  dword_10102FF0 = *(_DWORD *)(a1 + 8);
  dword_10102FF4 = *(_DWORD *)(a1 + 12);
  dword_101A4A50 = (int)&dword_10102FE8;
  return result;
}
// 10102FE8: using guessed type int dword_10102FE8;
// 10102FEC: using guessed type int dword_10102FEC;
// 10102FF0: using guessed type int dword_10102FF0;
// 10102FF4: using guessed type int dword_10102FF4;
// 101A4A50: using guessed type int dword_101A4A50;

//----- (10013B00) --------------------------------------------------------
char __cdecl sub_10013B00(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  *(_DWORD *)a2 = 0;
  *((_DWORD *)a2 + 1) = 0;
  *((_DWORD *)a2 + 2) = 0;
  *((_DWORD *)a2 + 3) = 0;
  *((_DWORD *)a2 + 4) = 0;
  if ( a1 == 3 )
  {
    result = sub_10008B20(0, 176, a2);
  }
  else if ( a1 == 4 )
  {
    result = sub_10008B20(0, 183, a2);
  }
  return result;
}

//----- (10013B50) --------------------------------------------------------
unsigned __int8 __cdecl sub_10013B50(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int8 result; // al@1

  result = a2;
  if ( a2 + 1 >= 1 && a2 <= 0x3Fu )
  {
    result = a1;
    if ( (unsigned __int8)(a1 - 3) <= 1u )
      result = sub_10004340(dword_10072A78[a1], (int)&a2, 1);
  }
  return result;
}
// 10072A78: using guessed type int dword_10072A78[];

//----- (10013B90) --------------------------------------------------------
int __cdecl sub_10013B90(char a1, _DWORD *a2)
{
  int result; // eax@1
  char v3; // [sp+4h] [bp-18h]@1
  int v4; // [sp+8h] [bp-14h]@1

  LOBYTE(result) = sub_10013B00(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (10013BD0) --------------------------------------------------------
char __cdecl sub_10013BD0(char a1)
{
  return byte_10073939[2 * (unsigned __int8)sub_10008CF0(&a1, 1u, (int)&unk_10073938, 2, 4, 3)];
}

//----- (10013C00) --------------------------------------------------------
char __cdecl sub_10013C00(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_10008B20(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_10003DC0("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_10020950(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_10008B20(1, 538, a2);
  }
  if ( !v4 || sub_100151E0((int)v3) )
    return 0;
  return 1;
}

//----- (10013C80) --------------------------------------------------------
int __cdecl sub_10013C80(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_10013C00(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (10013CD0) --------------------------------------------------------
void __cdecl sub_10013CD0(char a1, char a2)
{
  if ( (unsigned __int8)a2 <= 0x3Fu )
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sub_10004340(2011, (int)&a2, 1);
      }
      else
      {
        if ( a1 == 2 )
          sub_100209C0(a2);
        sub_10003DC0("..\\lib\\acl\\iop\\iop_com_intf.c", 658, 0, 0);
      }
    }
    else
    {
      sub_10004340(2010, (int)&a2, 1);
    }
  }
}

//----- (10013D40) --------------------------------------------------------
char sub_10013D40()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_10004310(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 10013D40: using guessed type int var_1C[7];

//----- (10013DC0) --------------------------------------------------------
signed int __cdecl sub_10013DC0(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_10074708;
    v6 = &unk_10074708;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_10074720;
    v6 = &unk_10074720;
    v5 = &a1;
  }
  v3 = sub_10008CF0(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (10013E20) --------------------------------------------------------
int __cdecl sub_10013E20(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10008CF0(&a1, 1u, (int)&unk_10074768, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_1007476C[2 * v1];
  return result;
}
// 1007476C: using guessed type int dword_1007476C[];

//----- (10013E60) --------------------------------------------------------
signed int __cdecl sub_10013E60(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_10074778;
    v7 = &unk_10074778;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_10074790;
    v7 = &unk_10074790;
    v6 = &a1;
  }
  v4 = sub_10008CF0(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (10013ED0) --------------------------------------------------------
int __cdecl sub_10013ED0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10008CF0(&a1, 1u, (int)&unk_100747A8, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_100747AC[2 * v1];
  return result;
}
// 100747AC: using guessed type int dword_100747AC[];

//----- (10013F10) --------------------------------------------------------
int __cdecl sub_10013F10(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10008CF0(&a1, 1u, (int)&unk_100747C0, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100747C4[2 * v1];
  return result;
}
// 100747C4: using guessed type int dword_100747C4[];

//----- (10013F50) --------------------------------------------------------
char __cdecl sub_10013F50(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10013DC0(a1, 11);
  return sub_10004290(v2, a2, 24);
}

//----- (10013F70) --------------------------------------------------------
char __cdecl sub_10013F70(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10013E20(a1);
  return sub_10004290(v2, a2, 2720);
}

//----- (10013FA0) --------------------------------------------------------
char __cdecl sub_10013FA0(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_10013E60(a1, 11, 1);
  sub_10004290(v2, a2, 36);
  v3 = sub_10013E60(a1, 11, 0);
  return sub_10004290(v3, a2 + 36, 32);
}

//----- (10013FF0) --------------------------------------------------------
char __cdecl sub_10013FF0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10013ED0(a1);
  return sub_10004290(v2, a2, 2192);
}

//----- (10014020) --------------------------------------------------------
char __cdecl sub_10014020(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10013F10(a1);
  return sub_10004290(v2, a2, 60);
}

//----- (10014040) --------------------------------------------------------
char __cdecl sub_10014040(int a1)
{
  return sub_10004290(6453, a1, 5);
}

//----- (10014060) --------------------------------------------------------
char __cdecl sub_10014060(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_10006010(11);
  }
  else
  {
    result = sub_10006010(5);
  }
  return result;
}

//----- (10014090) --------------------------------------------------------
char sub_10014090()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_10008B20(1, 1309, &v1) )
    sub_100152D0((int)&v1);
  return 0;
}

//----- (10014130) --------------------------------------------------------
BOOL __cdecl sub_10014130(int a1, int a2)
{
  return sub_10004270(6455, a2, 252) == 0;
}

//----- (10014150) --------------------------------------------------------
char __cdecl sub_10014150(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10014130(a1, a5);
  }
  else
  {
    result = sub_10014090();
  }
  return result;
}

//----- (10014190) --------------------------------------------------------
unsigned int __cdecl sub_10014190(char *a1)
{
  return sub_10016CF0(a1, -100, 100, 0, 0);
}

//----- (100141B0) --------------------------------------------------------
int __cdecl sub_100141B0(unsigned __int8 *a1)
{
  return sub_10016E60(a1, 0, 2u, 0, 0);
}

//----- (100141D0) --------------------------------------------------------
int __cdecl sub_100141D0(_BYTE *a1)
{
  return sub_10016F50(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (100141F0) --------------------------------------------------------
int __cdecl sub_100141F0(unsigned __int8 *a1)
{
  return sub_10016E60(a1, 0, 1u, 1u, 0);
}

//----- (10014210) --------------------------------------------------------
unsigned int __cdecl sub_10014210(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_10016BB0((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_10016E60((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_10016BB0((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016CF0((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016E60((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016E60((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016CF0((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10014540) --------------------------------------------------------
unsigned int __cdecl sub_10014540(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_10016BB0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016CF0((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016CF0((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016CF0((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016CF0((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016CF0((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016CF0((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016CF0((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016CF0((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016CF0((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016CF0((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016CF0((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016CF0((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016BB0((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10016CF0((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10014980) --------------------------------------------------------
unsigned int __cdecl sub_10014980(_BYTE *a1)
{
  return sub_10016D40(a1, -1, 5, -1, 0);
}

//----- (100149A0) --------------------------------------------------------
int __cdecl sub_100149A0(unsigned __int8 *a1)
{
  return sub_10016E60(a1, 0, 5u, 0, 0);
}

//----- (100149C0) --------------------------------------------------------
int __cdecl sub_100149C0(unsigned __int8 *a1)
{
  return sub_10016E60(a1, 0, 4u, 2u, 0);
}

//----- (100149E0) --------------------------------------------------------
int __cdecl sub_100149E0(_BYTE *a1)
{
  return sub_10016F50(a1, 0, 2u, 0, 0);
}

//----- (10014A00) --------------------------------------------------------
int __cdecl sub_10014A00(int a1)
{
  return sub_10016C00(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (10014A50) --------------------------------------------------------
int __cdecl sub_10014A50(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_10014A00((int)(a1 + 4));
  if ( !result )
    result = sub_100149C0(a1);
  return result;
}

//----- (10014A70) --------------------------------------------------------
int __cdecl sub_10014A70(int a1)
{
  int result; // eax@1

  result = sub_100149A0((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_100149A0((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_100149A0((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_10017000((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_10016BB0((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_10016BB0((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_10016BB0((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_10016BB0((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10014B00) --------------------------------------------------------
unsigned int __cdecl sub_10014B00(int a1)
{
  unsigned int result; // eax@1

  result = sub_10014980((_BYTE *)a1);
  if ( !result )
    result = sub_10014980((_BYTE *)(a1 + 4));
  return result;
}

//----- (10014B20) --------------------------------------------------------
signed int __cdecl sub_10014B20(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_10016BB0((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_10016BB0((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (10014B70) --------------------------------------------------------
unsigned int __cdecl sub_10014B70(int a1)
{
  unsigned int result; // eax@1

  result = sub_10014980((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10014980((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_10014980((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_10014980((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_10016BB0((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (10014BD0) --------------------------------------------------------
int __cdecl sub_10014BD0(_BYTE *a1)
{
  return sub_10016F50(a1, 0, 0x20u, 2u, 0);
}

//----- (10014BF0) --------------------------------------------------------
unsigned int __cdecl sub_10014BF0(_BYTE *a1)
{
  return sub_10016D40(a1, -1, 4, -1, 0);
}

//----- (10014C10) --------------------------------------------------------
int __cdecl sub_10014C10(unsigned __int8 *a1)
{
  return sub_10016E60(a1, 0, 9u, 0, 0);
}

//----- (10014C30) --------------------------------------------------------
int __cdecl sub_10014C30(_BYTE *a1)
{
  return sub_10016F50(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (10014C50) --------------------------------------------------------
signed int __cdecl sub_10014C50(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10016F50(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10014C80) --------------------------------------------------------
int __cdecl sub_10014C80(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_10016EB0(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10014CC0) --------------------------------------------------------
int __cdecl sub_10014CC0(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_10014C50((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_10014C80((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10014C80((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10008CC0((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10014C80((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10014D50) --------------------------------------------------------
int __cdecl sub_10014D50(int a1)
{
  int result; // eax@1

  result = sub_10016E60((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_10016E60((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (10014D80) --------------------------------------------------------
int __cdecl sub_10014D80(unsigned __int8 *a1)
{
  return sub_10016E60(a1, 0, 3u, 1u, 0);
}

//----- (10014DA0) --------------------------------------------------------
unsigned int __cdecl sub_10014DA0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10016D40((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_10016D40((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (10014DD0) --------------------------------------------------------
int __cdecl sub_10014DD0(int a1)
{
  int result; // eax@1

  result = sub_10016C00(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_10016C00(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_10016C00(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_10016C00(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_10016C00(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (10014EC0) --------------------------------------------------------
int __cdecl sub_10014EC0(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_10016BB0((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_10016E60((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_10014DA0(a1 + 36);
        if ( !result )
        {
          result = sub_10016C00(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_10014DD0(a1 + 8);
            if ( !result )
            {
              result = sub_10014DA0(a1 + 28);
              if ( !result )
              {
                result = sub_10016EB0((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_100141B0((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_10014D50(a1 + 57);
                    if ( !result )
                    {
                      result = sub_10016BB0((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_10014D80((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (10014FD0) --------------------------------------------------------
signed int __cdecl sub_10014FD0(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10016E60(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10015000) --------------------------------------------------------
signed int __cdecl sub_10015000(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10016EB0(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10015030) --------------------------------------------------------
int __cdecl sub_10015030(unsigned __int8 *a1)
{
  return sub_10016E60(a1, 0, 0x64u, 0x64u, 0);
}

//----- (10015090) --------------------------------------------------------
int __cdecl sub_10015090(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_10016BB0((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_10015030((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (100150A0) --------------------------------------------------------
signed int __cdecl sub_100150A0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10016F50(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100150D0) --------------------------------------------------------
int __cdecl sub_100150D0(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_10016E60((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_10016E60((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (10015150) --------------------------------------------------------
unsigned int __cdecl sub_10015150(int a1)
{
  unsigned int result; // eax@1

  result = sub_10014190((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_10014190((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_10014190((char *)a1);
      if ( !result )
        result = sub_10014190((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (10015190) --------------------------------------------------------
unsigned int __cdecl sub_10015190(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_10015150(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_100141B0((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_100141F0((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (100151E0) --------------------------------------------------------
int __cdecl sub_100151E0(int a1)
{
  int result; // eax@1

  result = sub_100141D0((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_10016EB0((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (10015210) --------------------------------------------------------
int __cdecl sub_10015210(int a1)
{
  int result; // eax@1

  result = sub_100149E0((_BYTE *)a1);
  if ( !result )
    result = sub_10014C30((_BYTE *)(a1 + 4));
  return result;
}

//----- (10015240) --------------------------------------------------------
unsigned int __cdecl sub_10015240(int a1)
{
  unsigned int result; // eax@1

  result = sub_10014980((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10014980((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_10014BF0((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (10015270) --------------------------------------------------------
unsigned int __cdecl sub_10015270(int a1)
{
  unsigned int result; // eax@1

  result = sub_10014980((_BYTE *)a1);
  if ( !result )
    result = sub_10014C10((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (10015290) --------------------------------------------------------
unsigned int __cdecl sub_10015290(int a1)
{
  unsigned int result; // eax@1

  result = sub_10014980((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10016E60((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_10014BF0((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (100152D0) --------------------------------------------------------
void __cdecl __noreturn sub_100152D0(int a1)
{
  exit_0(a1 + 4);
}

//----- (10015440) --------------------------------------------------------
signed int __cdecl sub_10015440(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_10014FD0((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_10015000((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_10014FD0((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (100154A0) --------------------------------------------------------
signed int __usercall sub_100154A0@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_10015440(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_10016E60((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_10016BB0((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_10014540(v2 + 5, a2);
    else
      result = sub_10014210(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_100150A0((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (10015570) --------------------------------------------------------
signed int __cdecl sub_10015570(int a1)
{
  return sub_100154A0(a1, 0);
}

//----- (10015580) --------------------------------------------------------
char __thiscall sub_10015580(void *this)
{
  int v1; // eax@1
  char result; // al@3

  v1 = sub_10005D40(this) - 2;
  if ( v1 )
  {
    if ( v1 == 2 )
      result = 2;
    else
      result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (100155A0) --------------------------------------------------------
_DWORD *__usercall sub_100155A0@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4)
{
  _DWORD *result; // eax@1

  sub_10021470(a2, a1);
  result = (_DWORD *)sub_100060E0(a3, a4);
  if ( (_BYTE)result )
    result = sub_100016E0(a2);
  return result;
}

//----- (10015680) --------------------------------------------------------
char __cdecl sub_10015680(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  void *v4; // ecx@2
  int v5; // eax@3
  int v6; // eax@5
  char v7; // al@4
  int v8; // ecx@14
  char v9; // al@17
  char *v10; // eax@22
  char v12; // [sp+4h] [bp-10h]@20
  char v13; // [sp+8h] [bp-Ch]@11
  char v14; // [sp+Ch] [bp-8h]@18
  char v15; // [sp+10h] [bp-4h]@15
  char v16; // [sp+1Ch] [bp+8h]@3

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 52);
  if ( *(_WORD *)v3 != -32696 )
    return v3;
  v4 = (void *)*(_WORD *)(v3 + 10);
  if ( (unsigned __int16)v4 & 0xC000 )
    return v3;
  v5 = *(_DWORD *)(v3 + 4);
  v16 = -1;
  if ( v5 )
  {
    v7 = sub_10021560(*(int (__cdecl **)(int))(v5 + 8));
LABEL_7:
    v16 = v7;
    goto LABEL_8;
  }
  v6 = *(_DWORD *)(v2 + 48);
  if ( v6 )
  {
    v7 = sub_10021560(*(int (__cdecl **)(int))(v6 + 8));
    goto LABEL_7;
  }
LABEL_8:
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 1 )
    goto LABEL_26;
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 2 )
  {
    v13 = 8;
    goto LABEL_14;
  }
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 4 )
  {
LABEL_26:
    v13 = 7;
    goto LABEL_14;
  }
  v13 = sub_10015580(v4);
LABEL_14:
  v8 = *(_DWORD *)(v2 + 52);
  if ( *(_WORD *)(v8 + 10) == 0x2000 )
    v15 = *(_BYTE *)(v8 + 14) - 92;
  else
    v15 = *(_BYTE *)(v8 + 10);
  v9 = *(_BYTE *)(v8 + 8);
  if ( v9 >= 0 )
  {
    v14 = 0;
  }
  else
  {
    v14 = 1;
    v9 = -v9;
  }
  v12 = v9;
  if ( *(_WORD *)(v8 + 12) )
    v12 = v9 * *(_BYTE *)(v8 + 12);
  v10 = sub_10021590(v16);
  LOBYTE(v3) = sub_10021490(v13, v16, v15, v12, v14, *(_DWORD *)(v2 + 64), 0, 0, v10);
  return v3;
}

//----- (10015780) --------------------------------------------------------
_DWORD *sub_10015780()
{
  char v1; // [sp+4h] [bp-104h]@1

  sub_10004310(6463, (int)&v1, 256);
  sub_100155A0((int)sub_10015630, (int)&unk_10162D4C, &v1, "PAGE_INIT");
  sub_100155A0((int)sub_100155D0, (int)&unk_10162D3C, &v1, "PAGE_SET_FOCUS");
  return sub_100155A0((int)sub_10015680, (int)&unk_10162D44, &v1, "KEY_PRESS");
}
// 100155D0: using guessed type int sub_100155D0();
// 10015630: using guessed type int sub_10015630();

//----- (10015810) --------------------------------------------------------
char __cdecl sub_10015810(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_10008CF0((_DWORD *)a2, 2u, (int)&unk_100787C8, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_100787CC[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_100040C0(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_10003EF0();
        sub_10005CD0(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_10003DC0("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 100787CC: using guessed type int dword_100787CC[];

//----- (10015930) --------------------------------------------------------
char __cdecl sub_10015930(int a1)
{
  return sub_10015810(31, a1);
}

//----- (10015940) --------------------------------------------------------
int __cdecl sub_10015940(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= *(_WORD *)&aMessageQueueTi[2 * *(_BYTE *)a1 + 46] );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - aMessageQueueTi[2 * *(_BYTE *)a1 + 46];
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}

//----- (10015A30) --------------------------------------------------------
__int16 __cdecl sub_10015A30(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (10015A80) --------------------------------------------------------
__int16 __cdecl sub_10015A80(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_10015A30((int)&v5, *a1);
  sub_10015940((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (10015B00) --------------------------------------------------------
unsigned int __cdecl sub_10015B00(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (10015B20) --------------------------------------------------------
bool __cdecl sub_10015B20(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (10015BF0) --------------------------------------------------------
int __cdecl sub_10015BF0(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (10015C10) --------------------------------------------------------
int __cdecl sub_10015C10(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_10015BF0(a1 + 20);
  return result;
}

//----- (10015C50) --------------------------------------------------------
signed int __cdecl sub_10015C50(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_10004570(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_10004570(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (10015D10) --------------------------------------------------------
int __cdecl sub_10015D10(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10015D50) --------------------------------------------------------
int __usercall sub_10015D50@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_10025190(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_10004650(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_10004670(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 10004690: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10015E00) --------------------------------------------------------
signed int __usercall sub_10015E00@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_100046A0(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_100255E0((void *)(v2 + 555), v7);
  }
  else
  {
    sub_10015C50(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_10004570(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_10004570(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_100254B0(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_100046A0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_100046A0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (10015FD0) --------------------------------------------------------
char __usercall sub_10015FD0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_10025140(a2, a3, a1 + 212);
}

//----- (10015FE0) --------------------------------------------------------
int __usercall sub_10015FE0@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_10015D50(result + 148, result);
  return result;
}

//----- (10016000) --------------------------------------------------------
char __usercall sub_10016000@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (10016020) --------------------------------------------------------
int __usercall sub_10016020@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  int result; // eax@1

  v2 = sub_1002F7E0(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_1002F7E0(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (10016060) --------------------------------------------------------
int __fastcall sub_10016060(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (10016080) --------------------------------------------------------
int __usercall sub_10016080@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_100046F0(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_10004670(v4, v3, 0);
}
// 10004690: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100160C0) --------------------------------------------------------
signed int __usercall sub_100160C0@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_10016060(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_1002F800(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_10015FD0(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_10027390(a2 + 28, 4);
      else
        v22 = sub_10027390(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_10015FD0(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 10004690: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100162D0) --------------------------------------------------------
int __cdecl sub_100162D0(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_10015FE0(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_10008BD0(&v23);
    sub_10015A80((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_10015C10(v1, (int)&v24);
  v13 = sub_10004650(v31);
  if ( v3 == v31 )
  {
    result = sub_100044C0(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_100046F0(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_100044C0(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_100046F0(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_10015BF0(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_10016080(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_10004650(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 10004690: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10016540) --------------------------------------------------------
signed int __cdecl sub_10016540(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_100046F0(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_100160C0(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (100165E0) --------------------------------------------------------
int __usercall sub_100165E0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_10016000(a1);
  *v3 ^= v2;
  return sub_10016020(v1, *v3);
}

//----- (10016600) --------------------------------------------------------
int __usercall sub_10016600@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_100165E0(a2);
  return result;
}

//----- (10016630) --------------------------------------------------------
signed int __usercall sub_10016630@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_10016020(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_10004570(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (10016720) --------------------------------------------------------
char __usercall sub_10016720@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_100250F0(a1, a2, a3 + 212);
  else
    result = sub_10016600(a2, a3 + 148);
  return result;
}

//----- (10016750) --------------------------------------------------------
signed int __usercall sub_10016750@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_10015E00(v3, v1);
  else
    result = sub_10016630(v3, v1);
  return result;
}

//----- (10016780) --------------------------------------------------------
signed int __cdecl sub_10016780(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_10015D10(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_10028E00(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_10016750(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (100167D0) --------------------------------------------------------
signed int __cdecl sub_100167D0(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_10004570(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_10016720(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_10004570(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_10025190(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_10016060(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_1002A1C0(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_1002F800(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_1002F800(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (100169C0) --------------------------------------------------------
signed int __cdecl sub_100169C0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_100167D0(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_10015B20(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10016A20) --------------------------------------------------------
signed int __cdecl sub_10016A20(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_10016780(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_10015D10(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_10016780(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_100169C0(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (10016BB0) --------------------------------------------------------
signed int __cdecl sub_10016BB0(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (10016C00) --------------------------------------------------------
int __cdecl sub_10016C00(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10016CF0) --------------------------------------------------------
unsigned int __cdecl sub_10016CF0(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10016D40) --------------------------------------------------------
unsigned int __cdecl sub_10016D40(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (10016E00) --------------------------------------------------------
unsigned int __cdecl sub_10016E00(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_10005C60(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (10016E60) --------------------------------------------------------
int __cdecl sub_10016E60(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10016EB0) --------------------------------------------------------
int __cdecl sub_10016EB0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10016F50) --------------------------------------------------------
int __cdecl sub_10016F50(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (10017000) --------------------------------------------------------
int __cdecl sub_10017000(unsigned __int8 *a1)
{
  return sub_10016E60(a1, 0, 0, 0, 0);
}

//----- (10017020) --------------------------------------------------------
unsigned int __cdecl sub_10017020(void *a1)
{
  return sub_10016E00(a1, 0x20u, 0);
}

//----- (10017040) --------------------------------------------------------
unsigned int __cdecl sub_10017040(void *a1)
{
  return sub_10016E00(a1, 0x1Cu, 0);
}

//----- (10017060) --------------------------------------------------------
unsigned int __cdecl sub_10017060(void *a1)
{
  return sub_10016E00(a1, 0x10u, 0);
}

//----- (10017080) --------------------------------------------------------
unsigned int __cdecl sub_10017080(void *a1)
{
  return sub_10016E00(a1, 0xCu, 0);
}

//----- (100170A0) --------------------------------------------------------
unsigned int __cdecl sub_100170A0(void *a1)
{
  return sub_10016E00(a1, 8u, 0);
}

//----- (100170C0) --------------------------------------------------------
unsigned int __cdecl sub_100170C0(void *a1)
{
  unsigned int result; // eax@1

  result = sub_10017020((char *)a1 + 64);
  if ( !result )
  {
    result = sub_10017040((char *)a1 + 36);
    if ( !result )
    {
      result = sub_10017060(a1);
      if ( !result )
      {
        result = sub_10017080((char *)a1 + 96);
        if ( !result )
        {
          result = sub_10017080((char *)a1 + 24);
          if ( !result )
            result = sub_100170A0((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (10017120) --------------------------------------------------------
int __cdecl sub_10017120(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (10017130) --------------------------------------------------------
char __cdecl sub_10017130(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_10162D60[592 * a1]) || byte_10162DB0[v3]) )
  {
    *a2 = &byte_10162D60[v3];
    *a3 = &byte_10162DB0[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10017170) --------------------------------------------------------
char *__cdecl sub_10017170(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_10162D60;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_10162DB0[592 * v2];
}

//----- (100171E0) --------------------------------------------------------
char *__usercall sub_100171E0@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (10017210) --------------------------------------------------------
void __cdecl sub_10017210(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_10017170(v2 + 3, (int)&unk_10049AD1);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_10017210(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (100172D0) --------------------------------------------------------
void __cdecl sub_100172D0(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  char *v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  char *v8; // edx@4
  char v9; // cl@5

  if ( dword_10162D58 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_10162D58;
    v4 = (char *)(&byte_10162D60[592 * dword_10162D58] - a1);
    do
    {
      v5 = *v2;
      v2[(_DWORD)v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_10162DB0[v3];
    v8 = (char *)(&byte_10162DB0[v3] - a2);
    do
    {
      v9 = *v6;
      v6[(_DWORD)v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_10017210(v7);
    ++dword_10162D58;
  }
}
// 10162D58: using guessed type int dword_10162D58;

//----- (10017330) --------------------------------------------------------
void *__cdecl sub_10017330(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  char *v4; // edi@4
  char *v5; // esi@4
  char *v6; // eax@4
  const char *v7; // esi@6
  const char *v8; // ebx@6
  char *v9; // edi@6
  char *v10; // eax@6
  char v11; // [sp+4h] [bp-204h]@3

  result = memset(byte_10162D60, 0, 0x73A0u);
  dword_10162D58 = 0;
  if ( a1 )
  {
    v2 = sub_10017800(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_100179E0((int)&v11, 512, v2) )
      {
        do
        {
          sub_100171E0(&v11);
          v4 = strstr(&v11, "=");
          v5 = strstr(&v11, "<Var name=\"");
          v6 = strstr(&v11, " value=\"");
          if ( v5 && v6 )
          {
            v7 = v5 + 11;
            v8 = v6 + 8;
            v9 = strchr(v7, 34);
            v10 = strchr(v8, 34);
            if ( v9 )
            {
              if ( v10 )
              {
                *v9 = 0;
                *v10 = 0;
                sub_100172D0((char *)v7, (char *)v8);
              }
            }
          }
          else if ( v4 && !strpbrk(&v11, "<>") )
          {
            *v4 = 0;
            sub_100172D0(&v11, v4 + 1);
          }
        }
        while ( sub_100179E0((int)&v11, 512, v3) );
      }
      result = (void *)sub_100177B0(v3);
    }
    else
    {
      result = (void *)sub_1000B4A0(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 10162D58: using guessed type int dword_10162D58;

//----- (100174C0) --------------------------------------------------------
int __cdecl sub_100174C0(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 10041E60: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 10041E70: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 10041E80: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 10041E90: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 10041F40: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (10017600) --------------------------------------------------------
char __usercall sub_10017600@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy_0((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy_0((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (100176D0) --------------------------------------------------------
signed int __cdecl sub_100176D0(_DWORD *a1, char *a2)
{
  int v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = (int)a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *(_DWORD *)v2;
    v10 = *(_DWORD *)v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_10041EA0(*(_DWORD *)(v2 + 4), (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_10017600(v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)(v2 + 30), (char)a1);
          v3 = v10;
          *a2 = v8;
          *(_DWORD *)(v2 + 24) += v6;
        }
        else
        {
          v7 = *(_DWORD *)(v2 + 4);
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_100174C0(v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 10041F50: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (100177B0) --------------------------------------------------------
BOOL __cdecl sub_100177B0(unsigned int a1)
{
  j_FIL_vfs_clean_invalidate_cache(a1);
  return sub_10004460(a1) == 0;
}
// 10004450: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);

//----- (100177D0) --------------------------------------------------------
BOOL __cdecl sub_100177D0(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 100044A0: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (10017800) --------------------------------------------------------
unsigned int __cdecl sub_10017800(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 10004520: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10017860) --------------------------------------------------------
signed int __cdecl sub_10017860(void *a1, int a2, unsigned int a3)
{
  return sub_10004530(a3, a1, a2);
}

//----- (10017880) --------------------------------------------------------
int __cdecl sub_10017880(int a1, int a2, int a3)
{
  return j_FIL_vfs_write(a3, a1, a2);
}
// 10004690: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100178A0) --------------------------------------------------------
char __cdecl sub_100178A0(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  unsigned int v4; // ebp@7
  int v5; // esi@8
  bool i; // zf@8
  char v8; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_10017800((int)a1, 0);
    if ( v3 )
    {
      v4 = sub_10017800((int)a2, 1);
      if ( v4 )
      {
        v5 = sub_10017860(&v8, 512, v3);
        for ( i = v5 == 0; v5 > 0; i = v5 == 0 )
        {
          v5 -= sub_10017880((int)&v8, v5, v4);
          if ( !v5 )
            v5 = sub_10017860(&v8, 512, v3);
        }
        v2 = i;
        sub_100177B0(v4);
      }
      sub_100177B0(v3);
    }
    return v2;
  }
  return 1;
}

//----- (100179E0) --------------------------------------------------------
int __cdecl sub_100179E0(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_10017860(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (10017A60) --------------------------------------------------------
int sub_10017A60()
{
  return 0;
}

//----- (10017A70) --------------------------------------------------------
void __cdecl sub_10017A70(int a1)
{
  if ( a1 > 0 )
    exit(14);
}

//----- (10017AA0) --------------------------------------------------------
int __cdecl sub_10017AA0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10017AC0) --------------------------------------------------------
bool __cdecl sub_10017AC0(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (10017AF0) --------------------------------------------------------
void *__cdecl sub_10017AF0(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (10017B30) --------------------------------------------------------
unsigned int __usercall sub_10017B30@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (10017B50) --------------------------------------------------------
int __usercall sub_10017B50@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (10017B70) --------------------------------------------------------
char __cdecl sub_10017B70(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_10017AC0(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_10017AA0(a2);
  }
  return result;
}

//----- (10017BA0) --------------------------------------------------------
signed int __cdecl sub_10017BA0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  int v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = (int)a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( *(_DWORD *)(v5 + 4) )
      {
        do
        {
          v10 = sub_10017B30(v5, v7, v9);
          v11 = (_BYTE *)sub_10017B30(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_10017B30(a4, v7, v9);
            sub_10017B50(v16, (int)&unk_1007BC4C);
          }
          ++v9;
        }
        while ( v9 < *(_DWORD *)(v5 + 4) );
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (10017C80) --------------------------------------------------------
void __cdecl sub_10017C80(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_10017B30((int)v3, v4, v6);
          v8 = sub_10017B30(a2, v4, v6);
          v9 = sub_10017B30(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (10017D30) --------------------------------------------------------
void *__usercall sub_10017D30@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  int v34; // [sp+14h] [bp-Ch]@1
  int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_10017B30(a1, v31, v4);
      v6 = sub_10017B30(a2, 0, 0);
      sub_10017B50(v5, v6);
      v7 = sub_10017B30(a1, v33, v4);
      v8 = sub_10017B30(a2, *(_DWORD *)a2 - 1, 0);
      sub_10017B50(v7, v8);
      v9 = sub_10017B30(a1, v31, v34 - v4 - 1);
      v10 = sub_10017B30(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_10017B50(v9, v10);
      v11 = sub_10017B30(a1, v33, v34 - v4 - 1);
      v12 = sub_10017B30(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_10017B50(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_10017B30(a2, 0, 1);
    v16 = (void *)sub_10017B30(a1, v13, a3 + 1);
    memcpy(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_10017B30(a1, a3 + i, v18);
      v20 = sub_10017B30(a2, i, 0);
      sub_10017B50(v19, v20);
      v21 = sub_10017B30(a1, i + a3, v34 - v18 - 1);
      v22 = sub_10017B30(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_10017B50(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_10017B30(a2, i, 1);
    v25 = (void *)sub_10017B30(a1, a3 + i, a3 + 1);
    memcpy(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_10017B30(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_10017B30(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (10017FB0) --------------------------------------------------------
void __cdecl sub_10017FB0(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_10017B30(a1, v2, v4);
          v6 = sub_10017B30(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (10018080) --------------------------------------------------------
char __cdecl sub_10018080(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_10017AC0(a1);
  if ( result )
  {
    result = sub_10017AC0(a4);
    if ( result )
    {
      sub_10017B70(a3, a4);
      sub_10017AF0(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (100180F0) --------------------------------------------------------
int __usercall sub_100180F0@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_10017AF0(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_10017D30((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_10017B30((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_10017B30(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_10017B70((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_10018080(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (10018450) --------------------------------------------------------
int __usercall sub_10018450@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_10017AF0(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_10017C80(v8, a3, (int)&v16);
  sub_10017AF0(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_100180F0(9u, v7, (int)&v16, (int)&unk_1007BC28, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_10017B30((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_10017B30(a6, v9, v11);
            sub_10017B50(v13, (int)&unk_1007BC4C);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_10017B70(a5, (int)&v15);
  sub_10017B70(a5, (int)&v16);
  return v10;
}

//----- (10018560) --------------------------------------------------------
int __cdecl sub_10018560(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_10017AF0(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_10017FB0(a3, a8);
  if ( a1 )
    result = sub_10018450(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_10017BA0((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (100186F0) --------------------------------------------------------
char __cdecl sub_100186F0(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  char *v6; // ebp@11
  int v7; // esi@11
  unsigned int v8; // ebx@11
  int v9; // edi@11
  char result; // al@20
  char v11; // [sp+8h] [bp-40h]@14
  unsigned int v12; // [sp+Ch] [bp-3Ch]@5
  __int16 v13; // [sp+10h] [bp-38h]@6
  int v14; // [sp+1Ah] [bp-2Eh]@8
  char v15; // [sp+20h] [bp-28h]@9
  int v16; // [sp+24h] [bp-24h]@11
  unsigned int v17; // [sp+28h] [bp-20h]@11
  unsigned __int16 v18; // [sp+2Eh] [bp-1Ah]@10
  char v19; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_10017800((int)a2, 0);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        if ( sub_10017860(&v13, 14, v4) == 14
          && v13 == 19778
          && v14 == 54
          && sub_10017860(&v15, 40, v5) == 40
          && v18 == 24 )
        {
          sub_10017AF0(v17, v16, 24, a1, a3);
          v6 = *(char **)(a3 + 12);
          v7 = v16 * (((unsigned int)v18 + 7) >> 3);
          v8 = 0;
          v9 = -(v16 * (((unsigned int)v18 + 7) >> 3)) & 3;
          v19 = 1;
          if ( v17 )
          {
            while ( sub_10017860(v6, v7, v12) == v7 && (!v9 || sub_10017860(&v11, v9, v12) == v9) )
            {
              ++v8;
              v6 += v7;
              if ( v8 >= v17 )
                goto LABEL_18;
            }
            v19 = 0;
          }
LABEL_18:
          v3 = v19;
          v5 = v12;
        }
        sub_100177B0(v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10018840) --------------------------------------------------------
char __usercall sub_10018840@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@1
  unsigned int v10; // ebx@1
  int v12; // [sp+10h] [bp-40h]@4
  int v13; // [sp+14h] [bp-3Ch]@4
  __int16 v14; // [sp+18h] [bp-38h]@1
  int v15; // [sp+1Ah] [bp-36h]@1
  __int16 v16; // [sp+1Eh] [bp-32h]@1
  __int16 v17; // [sp+20h] [bp-30h]@1
  int v18; // [sp+22h] [bp-2Eh]@1
  int v19; // [sp+28h] [bp-28h]@1
  int v20; // [sp+2Ch] [bp-24h]@1
  unsigned int v21; // [sp+30h] [bp-20h]@1
  __int16 v22; // [sp+34h] [bp-1Ch]@1
  __int16 v23; // [sp+36h] [bp-1Ah]@1
  int v24; // [sp+38h] [bp-18h]@1
  int v25; // [sp+3Ch] [bp-14h]@1
  int v26; // [sp+40h] [bp-10h]@1
  int v27; // [sp+44h] [bp-Ch]@1
  int v28; // [sp+48h] [bp-8h]@1
  int v29; // [sp+4Ch] [bp-4h]@1
  char v30; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v25 = v8;
  v15 = v8 + 54;
  v16 = 0;
  v17 = 0;
  v29 = 0;
  v28 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v14 = 19778;
  v18 = 54;
  v19 = 40;
  v23 = a2;
  v21 = v5;
  v20 = a1;
  v22 = 1;
  v9 = sub_10017800(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_10017880((int)&v14, 14, v9) == 14 && sub_10017880((int)&v19, 40, v10) == 40 )
    {
      v30 = 1;
      v12 = a4;
      v13 = 0;
      if ( v5 )
      {
        while ( sub_10017880(v12, v6, v10) == v6 && (!v7 || sub_10017880((int)&unk_1007BDF0, v7, v10) == v7) )
        {
          v12 += v6;
          if ( ++v13 >= v5 )
          {
            sub_100177B0(v10);
            return 1;
          }
        }
        v30 = 0;
      }
    }
    sub_100177B0(v10);
  }
  return v30;
}

//----- (10018990) --------------------------------------------------------
char __cdecl sub_10018990(int a1, int a2)
{
  char result; // al@2

  if ( sub_10017AC0(a1) )
    result = sub_10018840(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (100189D0) --------------------------------------------------------
signed int __cdecl sub_100189D0(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_1016A101 = 1;
    byte_1016A100 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_1016A100 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_1016A101 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 1016A100: using guessed type char byte_1016A100;
// 1016A101: using guessed type char byte_1016A101;

//----- (10018A30) --------------------------------------------------------
bool __cdecl sub_10018A30(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_1000B3F0(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_100939E8, (int)"failing_subroutine( depth-1 )");
    sub_10018A30(a1 - 1);
    exit(14);
  }
  return sub_100108B0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (10018AA0) --------------------------------------------------------
int sub_10018AA0()
{
  const char *v0; // eax@1

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_1016A100 )
  {
    sub_100108B0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_1000B3F0(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_10018A30(1);
    exit(14);
  }
  return sub_1000B420(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 1016A100: using guessed type char byte_1016A100;

//----- (10018DC0) --------------------------------------------------------
char sub_10018DC0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1016A100 )
  {
    v2 = 0;
    do
    {
      if ( off_1007CA5C[v2] )
      {
        sub_1000BBE0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1007CA64[v2 * 4], 0x100u, &v11);
        sub_1000BBE0((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_1007CA5C[v2], 0x100u, &v12);
        sub_100178A0(&v12, &v11);
      }
      if ( byte_1007CA58[v2 * 4] )
      {
        sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = off_1007CA60[v2];
        v4 = *(char **)&off_1007CA64[v2 * 4];
        v5 = sub_1000BE80(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1007CA64[v2 * 4],
               off_1007CA60[v2]);
        v6 = sub_10010500(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1000C1E0(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"731",
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = off_1007CA60[v2];
        v8 = *(char **)&off_1007CA64[v2 * 4];
        v9 = sub_1000BE80(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1007CA64[v2 * 4],
               off_1007CA60[v2]);
        v10 = sub_10010500(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1000C1E0(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"741",
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"704",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1007CA5C: using guessed type char *off_1007CA5C[3];
// 1007CA60: using guessed type char *off_1007CA60[2];
// 1016A100: using guessed type char byte_1016A100;

//----- (10018FE0) --------------------------------------------------------
char sub_10018FE0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_1016A100 )
  {
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_1000C1E0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"777",
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1000C1E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_1000C1E0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1000C1E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"782",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"784", 2, 2);
    v4 = sub_1000C1E0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1000C1E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"788", 2, 2);
    v5 = sub_1000C1E0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1000C1E0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"790",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1016A100: using guessed type char byte_1016A100;

//----- (100191E0) --------------------------------------------------------
char sub_100191E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_1007CAEC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_1007CAE9[v2 * 4];
        v4 = byte_1007CAE8[v2 * 4];
        v5 = sub_1000BE80(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + dword_1007CAEC[v2])],
               (&off_1007CAF0)[v2 * 4]);
        v6 = sub_1000C320(
               0,
               *(&dword_1007CA3C + dword_1007CAEC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1000BE80(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_1007CAEC[v2]],
               (&off_1007CAF0)[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1007CAEC: using guessed type int dword_1007CAEC[];
// 1007CAF0: using guessed type char *off_1007CAF0;
// 1016A100: using guessed type char byte_1016A100;

//----- (10019360) --------------------------------------------------------
char sub_10019360()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_1007CD70[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_1007CD68[v2 / 8];
        v4 = dbl_1007CD60[v2 / 8];
        v5 = dbl_1007CD58[v2 / 8];
        v6 = sub_1000BE80(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               *(_DWORD *)&off_1007CD74[v2]);
        v7 = sub_1000C6D0(
               0,
               *(&dword_1007CA3C + dword_1007CD70[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_1007CD70[v2 / 4]],
               *(_DWORD *)&off_1007CD74[v2]);
        LOBYTE(v0) = sub_1000C1E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1007CD58: using guessed type double dbl_1007CD58[];
// 1007CD60: using guessed type double dbl_1007CD60[];
// 1007CD68: using guessed type double dbl_1007CD68[];
// 1007CD70: using guessed type int dword_1007CD70[];
// 1016A100: using guessed type char byte_1016A100;

//----- (100194E0) --------------------------------------------------------
char sub_100194E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_1007D984[v2];
      if ( v0 != 6 )
      {
        v3 = flt_1007D980[v2];
        v4 = flt_1007D97C[v2];
        v5 = flt_1007D978[v2];
        v6 = sub_1000BE80(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               *(_DWORD *)&off_1007D988[v2 * 4]);
        v7 = sub_1000CB20(
               0,
               *(&dword_1007CA3C + dword_1007D984[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_1007D984[v2]],
               *(_DWORD *)&off_1007D988[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1007D978: using guessed type float flt_1007D978[];
// 1007D97C: using guessed type float flt_1007D97C[];
// 1007D980: using guessed type float flt_1007D980[];
// 1007D984: using guessed type int dword_1007D984[];
// 1016A100: using guessed type char byte_1016A100;

//----- (10019650) --------------------------------------------------------
char sub_10019650()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1016A100 )
  {
    sub_10010800(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_10019650,
      (int)sub_10019650,
      (int)"This test is expected to fail");
    sub_10010800(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_10019650,
      0,
      (int)"This test is expected to fail");
    result = sub_10010800(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10019650,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1016A100: using guessed type char byte_1016A100;

//----- (10019750) --------------------------------------------------------
char sub_10019750()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_1007E12C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1007E128[v2];
        v4 = dword_1007E124[v2];
        v5 = dword_1007E120[v2];
        v6 = sub_1000BE80(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               (&off_1007E130)[v2 * 4]);
        v7 = sub_1000CFE0(
               0,
               *(&dword_1007CA3C + dword_1007E12C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_1007E12C[v2]],
               (&off_1007E130)[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1007E120: using guessed type int dword_1007E120[];
// 1007E124: using guessed type int dword_1007E124[];
// 1007E128: using guessed type int dword_1007E128[];
// 1007E12C: using guessed type int dword_1007E12C[];
// 1007E130: using guessed type char *off_1007E130;
// 1016A100: using guessed type char byte_1016A100;

//----- (100198B0) --------------------------------------------------------
char sub_100198B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_1007E8C0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1007E8BC[v2 / 2];
        v4 = word_1007E8BA[v2 / 2];
        v5 = word_1007E8B8[v2 / 2];
        v6 = sub_1000BE80(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               (&off_1007E8C4)[v2]);
        v7 = sub_1000D3A0(
               0,
               *(&dword_1007CA3C + dword_1007E8C0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_1007E8C0[v2 / 4]],
               (&off_1007E8C4)[v2]);
        LOBYTE(v0) = sub_1000C1E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1007E8B8: using guessed type __int16 word_1007E8B8[];
// 1007E8BA: using guessed type __int16 word_1007E8BA[];
// 1007E8BC: using guessed type __int16 word_1007E8BC[];
// 1007E8C0: using guessed type int dword_1007E8C0[];
// 1007E8C4: using guessed type char *off_1007E8C4;
// 1016A100: using guessed type char byte_1016A100;

//----- (10019A10) --------------------------------------------------------
char sub_10019A10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_1007EED4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1007EED0[v2];
        v4 = dword_1007EECC[v2];
        v5 = dword_1007EEC8[v2];
        v6 = sub_1000BE80(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               *(_DWORD *)&off_1007EED8[v2 * 4]);
        v7 = sub_1000D7A0(
               0,
               *(&dword_1007CA3C + dword_1007EED4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_1007EED4[v2]],
               *(_DWORD *)&off_1007EED8[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1007EEC8: using guessed type int dword_1007EEC8[];
// 1007EECC: using guessed type int dword_1007EECC[];
// 1007EED0: using guessed type int dword_1007EED0[];
// 1007EED4: using guessed type int dword_1007EED4[];
// 1016A100: using guessed type char byte_1016A100;

//----- (10019B70) --------------------------------------------------------
char sub_10019B70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_1007F678[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1007F674[v2];
        LODWORD(v3) = dword_1007F670[v2];
        HIDWORD(v4) = dword_1007F66C[v2];
        LODWORD(v4) = dword_1007F668[v2];
        HIDWORD(v5) = dword_1007F664[v2];
        LODWORD(v5) = dword_1007F660[v2];
        v6 = sub_1000BE80(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               *(_DWORD *)&off_1007F67C[v2 * 4]);
        v7 = sub_1000DB60(
               0,
               *(&dword_1007CA3C + dword_1007F678[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_1007F678[v2]],
               *(_DWORD *)&off_1007F67C[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1007F660: using guessed type int dword_1007F660[];
// 1007F664: using guessed type int dword_1007F664[];
// 1007F668: using guessed type int dword_1007F668[];
// 1007F66C: using guessed type int dword_1007F66C[];
// 1007F670: using guessed type int dword_1007F670[];
// 1007F674: using guessed type int dword_1007F674[];
// 1007F678: using guessed type int dword_1007F678[];
// 1016A100: using guessed type char byte_1016A100;

//----- (10019CE0) --------------------------------------------------------
char sub_10019CE0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_10080284[v2];
      if ( v0 != 6 )
      {
        v3 = byte_10080282[v2 * 4];
        v4 = byte_10080281[v2 * 4];
        v5 = byte_10080280[v2 * 4];
        v6 = sub_1000BE80(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               (&off_10080288)[v2 * 4]);
        v7 = sub_1000E0A0(
               0,
               *(&dword_1007CA3C + dword_10080284[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_10080284[v2]],
               (&off_10080288)[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10080284: using guessed type int dword_10080284[];
// 10080288: using guessed type char *off_10080288;
// 1016A100: using guessed type char byte_1016A100;

//----- (10019E40) --------------------------------------------------------
char sub_10019E40()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_1008071C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10080718[v2];
        v4 = dword_10080714[v2];
        v5 = dword_10080710[v2];
        v6 = sub_1000BE80(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               (&off_10080720)[v2 * 4]);
        v7 = sub_1000E480(
               0,
               *(&dword_1007CA3C + dword_1008071C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_1008071C[v2]],
               (&off_10080720)[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10080710: using guessed type int dword_10080710[];
// 10080714: using guessed type int dword_10080714[];
// 10080718: using guessed type int dword_10080718[];
// 1008071C: using guessed type int dword_1008071C[];
// 10080720: using guessed type char *off_10080720;
// 1016A100: using guessed type char byte_1016A100;

//----- (10019FA0) --------------------------------------------------------
char sub_10019FA0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1016A100 )
  {
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_100108B0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10049AD1,
           (int)"This test is expected to fail");
    sub_1000C1E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_100108B0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_10049AD1,
           "a",
           (int)"This test is expected to fail");
    sub_1000C1E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_100108B0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10049AD1,
           (const char *)&unk_10049AD1,
           (int)"This test is expected to fail");
    sub_1000C1E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_100108B0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_1000C1E0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1016A100: using guessed type char byte_1016A100;

//----- (1001A1C0) --------------------------------------------------------
char sub_1001A1C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_10080EB4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10080EB0[v2];
        v4 = dword_10080EAC[v2];
        v5 = dword_10080EA8[v2];
        v6 = sub_1000BE80(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               *(_DWORD *)&off_10080EB8[v2 * 4]);
        v7 = sub_1000E840(
               0,
               *(&dword_1007CA3C + dword_10080EB4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_10080EB4[v2]],
               *(_DWORD *)&off_10080EB8[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10080EA8: using guessed type int dword_10080EA8[];
// 10080EAC: using guessed type int dword_10080EAC[];
// 10080EB0: using guessed type int dword_10080EB0[];
// 10080EB4: using guessed type int dword_10080EB4[];
// 1016A100: using guessed type char byte_1016A100;

//----- (1001A320) --------------------------------------------------------
char sub_1001A320()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_10081220[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1008121C[v2 / 2];
        v4 = word_1008121A[v2 / 2];
        v5 = word_10081218[v2 / 2];
        v6 = sub_1000BE80(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               (&off_10081224)[v2]);
        v7 = sub_1000EBE0(
               0,
               *(&dword_1007CA3C + dword_10081220[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_10081220[v2 / 4]],
               (&off_10081224)[v2]);
        LOBYTE(v0) = sub_1000C1E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10081218: using guessed type __int16 word_10081218[];
// 1008121A: using guessed type __int16 word_1008121A[];
// 1008121C: using guessed type __int16 word_1008121C[];
// 10081220: using guessed type int dword_10081220[];
// 10081224: using guessed type char *off_10081224;
// 1016A100: using guessed type char byte_1016A100;

//----- (1001A480) --------------------------------------------------------
char sub_1001A480()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_100814E4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100814E0[v2];
        v4 = dword_100814DC[v2];
        v5 = dword_100814D8[v2];
        v6 = sub_1000BE80(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               *(_DWORD *)&off_100814E8[v2 * 4]);
        v7 = sub_1000EFE0(
               0,
               *(&dword_1007CA3C + dword_100814E4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_100814E4[v2]],
               *(_DWORD *)&off_100814E8[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100814D8: using guessed type int dword_100814D8[];
// 100814DC: using guessed type int dword_100814DC[];
// 100814E0: using guessed type int dword_100814E0[];
// 100814E4: using guessed type int dword_100814E4[];
// 1016A100: using guessed type char byte_1016A100;

//----- (1001A5E0) --------------------------------------------------------
char sub_1001A5E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_10081860[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1008185C[v2];
        LODWORD(v3) = dword_10081858[v2];
        HIDWORD(v4) = dword_10081854[v2];
        LODWORD(v4) = dword_10081850[v2];
        HIDWORD(v5) = dword_1008184C[v2];
        LODWORD(v5) = dword_10081848[v2];
        v6 = sub_1000BE80(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               (&off_10081864)[v2 * 4]);
        v7 = sub_1000F380(
               0,
               *(&dword_1007CA3C + dword_10081860[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_10081860[v2]],
               (&off_10081864)[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10081848: using guessed type int dword_10081848[];
// 1008184C: using guessed type int dword_1008184C[];
// 10081850: using guessed type int dword_10081850[];
// 10081854: using guessed type int dword_10081854[];
// 10081858: using guessed type int dword_10081858[];
// 1008185C: using guessed type int dword_1008185C[];
// 10081860: using guessed type int dword_10081860[];
// 10081864: using guessed type char *off_10081864;
// 1016A100: using guessed type char byte_1016A100;

//----- (1001A750) --------------------------------------------------------
char sub_1001A750()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_10081DCC[v2];
      if ( v0 != 6 )
      {
        v3 = byte_10081DCA[v2 * 4];
        v4 = byte_10081DC9[v2 * 4];
        v5 = byte_10081DC8[v2 * 4];
        v6 = sub_1000BE80(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               (&off_10081DD0)[v2 * 4]);
        v7 = sub_1000F960(
               0,
               *(&dword_1007CA3C + dword_10081DCC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_10081DCC[v2]],
               (&off_10081DD0)[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10081DCC: using guessed type int dword_10081DCC[];
// 10081DD0: using guessed type char *off_10081DD0;
// 1016A100: using guessed type char byte_1016A100;

//----- (1001A8B0) --------------------------------------------------------
char sub_1001A8B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_10081FE4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10081FE0[v2];
        v4 = dword_10081FDC[v2];
        v5 = dword_10081FD8[v2];
        v6 = sub_1000BE80(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               *(_DWORD *)&off_10081FE8[v2 * 4]);
        v7 = sub_1000FD50(
               0,
               *(&dword_1007CA3C + dword_10081FE4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_10081FE4[v2]],
               *(_DWORD *)&off_10081FE8[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10081FD8: using guessed type int dword_10081FD8[];
// 10081FDC: using guessed type int dword_10081FDC[];
// 10081FE0: using guessed type int dword_10081FE0[];
// 10081FE4: using guessed type int dword_10081FE4[];
// 1016A100: using guessed type char byte_1016A100;

//----- (1001AA10) --------------------------------------------------------
char sub_1001AA10()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1016A100 )
  {
    v2 = 0;
    do
    {
      if ( off_1008234C[v2] )
      {
        sub_1000BBE0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_10082354[v2 * 4], 0x100u, &v11);
        sub_1000BBE0((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_1008234C[v2], 0x100u, &v12);
        sub_100178A0(&v12, &v11);
      }
      if ( byte_10082348[v2 * 4] )
      {
        sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = off_10082350[v2];
        v4 = *(char **)&off_10082354[v2 * 4];
        v5 = sub_1000BE80(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10082354[v2 * 4],
               off_10082350[v2]);
        v6 = sub_10010500(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1000C1E0(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = off_10082350[v2];
        v8 = *(char **)&off_10082354[v2 * 4];
        v9 = sub_1000BE80(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10082354[v2 * 4],
               off_10082350[v2]);
        v10 = sub_10010500(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1000C1E0(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 4;
    }
    while ( v2 < 36 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1008234C: using guessed type char *off_1008234C[3];
// 10082350: using guessed type char *off_10082350[2];
// 1016A100: using guessed type char byte_1016A100;

//----- (1001AC30) --------------------------------------------------------
char sub_1001AC30()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_1016A100 )
  {
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_1000C1E0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1000C1E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_1000C1E0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1000C1E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_1000C1E0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1000C1E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_1000C1E0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1000C1E0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1016A100: using guessed type char byte_1016A100;

//----- (1001AE30) --------------------------------------------------------
char sub_1001AE30()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_100823DC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_100823D9[v2 * 4];
        v4 = byte_100823D8[v2 * 4];
        v5 = sub_1000BE80(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + dword_100823DC[v2])],
               (&off_100823E0)[v2 * 4]);
        v6 = sub_1000C320(
               1,
               *(&dword_1007CA3C + dword_100823DC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1000BE80(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_100823DC[v2]],
               (&off_100823E0)[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100823DC: using guessed type int dword_100823DC[];
// 100823E0: using guessed type char *off_100823E0;
// 1016A100: using guessed type char byte_1016A100;

//----- (1001AFB0) --------------------------------------------------------
char sub_1001AFB0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_10082660[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_10082658[v2 / 8];
        v4 = dbl_10082650[v2 / 8];
        v5 = dbl_10082648[v2 / 8];
        v6 = sub_1000BE80(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               (&off_10082664)[v2]);
        v7 = sub_1000C6D0(
               1,
               *(&dword_1007CA3C + dword_10082660[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_10082660[v2 / 4]],
               (&off_10082664)[v2]);
        LOBYTE(v0) = sub_1000C1E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10082648: using guessed type double dbl_10082648[];
// 10082650: using guessed type double dbl_10082650[];
// 10082658: using guessed type double dbl_10082658[];
// 10082660: using guessed type int dword_10082660[];
// 10082664: using guessed type char *off_10082664;
// 1016A100: using guessed type char byte_1016A100;

//----- (1001B130) --------------------------------------------------------
char sub_1001B130()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_10083274[v2];
      if ( v0 != 6 )
      {
        v3 = flt_10083270[v2];
        v4 = flt_1008326C[v2];
        v5 = flt_10083268[v2];
        v6 = sub_1000BE80(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               *(_DWORD *)&off_10083278[v2 * 4]);
        v7 = sub_1000CB20(
               1,
               *(&dword_1007CA3C + dword_10083274[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_10083274[v2]],
               *(_DWORD *)&off_10083278[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10083268: using guessed type float flt_10083268[];
// 1008326C: using guessed type float flt_1008326C[];
// 10083270: using guessed type float flt_10083270[];
// 10083274: using guessed type int dword_10083274[];
// 1016A100: using guessed type char byte_1016A100;

//----- (1001B2A0) --------------------------------------------------------
char sub_1001B2A0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1016A100 )
  {
    sub_10010800(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_1001B2A0,
      (int)sub_1001B2A0,
      0);
    sub_10010800(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_1001B2A0,
      0,
      0);
    result = sub_10010800(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1001B2A0,
               0);
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1016A100: using guessed type char byte_1016A100;

//----- (1001B390) --------------------------------------------------------
char sub_1001B390()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_10083A0C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10083A08[v2];
        v4 = dword_10083A04[v2];
        v5 = dword_10083A00[v2];
        v6 = sub_1000BE80(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               (&off_10083A10)[v2 * 4]);
        v7 = sub_1000CFE0(
               1,
               *(&dword_1007CA3C + dword_10083A0C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_10083A0C[v2]],
               (&off_10083A10)[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10083A00: using guessed type int dword_10083A00[];
// 10083A04: using guessed type int dword_10083A04[];
// 10083A08: using guessed type int dword_10083A08[];
// 10083A0C: using guessed type int dword_10083A0C[];
// 10083A10: using guessed type char *off_10083A10;
// 1016A100: using guessed type char byte_1016A100;

//----- (1001B4F0) --------------------------------------------------------
char sub_1001B4F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_100841A0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1008419C[v2 / 2];
        v4 = word_1008419A[v2 / 2];
        v5 = word_10084198[v2 / 2];
        v6 = sub_1000BE80(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               (&off_100841A4)[v2]);
        v7 = sub_1000D3A0(
               1,
               *(&dword_1007CA3C + dword_100841A0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_100841A0[v2 / 4]],
               (&off_100841A4)[v2]);
        LOBYTE(v0) = sub_1000C1E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10084198: using guessed type __int16 word_10084198[];
// 1008419A: using guessed type __int16 word_1008419A[];
// 1008419C: using guessed type __int16 word_1008419C[];
// 100841A0: using guessed type int dword_100841A0[];
// 100841A4: using guessed type char *off_100841A4;
// 1016A100: using guessed type char byte_1016A100;

//----- (1001B650) --------------------------------------------------------
char sub_1001B650()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_100847B4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100847B0[v2];
        v4 = dword_100847AC[v2];
        v5 = dword_100847A8[v2];
        v6 = sub_1000BE80(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               *(_DWORD *)&off_100847B8[v2 * 4]);
        v7 = sub_1000D7A0(
               1,
               *(&dword_1007CA3C + dword_100847B4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_100847B4[v2]],
               *(_DWORD *)&off_100847B8[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100847A8: using guessed type int dword_100847A8[];
// 100847AC: using guessed type int dword_100847AC[];
// 100847B0: using guessed type int dword_100847B0[];
// 100847B4: using guessed type int dword_100847B4[];
// 1016A100: using guessed type char byte_1016A100;

//----- (1001B7B0) --------------------------------------------------------
char sub_1001B7B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_10084F58[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_10084F54[v2];
        LODWORD(v3) = dword_10084F50[v2];
        HIDWORD(v4) = dword_10084F4C[v2];
        LODWORD(v4) = dword_10084F48[v2];
        HIDWORD(v5) = dword_10084F44[v2];
        LODWORD(v5) = dword_10084F40[v2];
        v6 = sub_1000BE80(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               *(_DWORD *)&off_10084F5C[v2 * 4]);
        v7 = sub_1000DB60(
               1,
               *(&dword_1007CA3C + dword_10084F58[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_10084F58[v2]],
               *(_DWORD *)&off_10084F5C[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10084F40: using guessed type int dword_10084F40[];
// 10084F44: using guessed type int dword_10084F44[];
// 10084F48: using guessed type int dword_10084F48[];
// 10084F4C: using guessed type int dword_10084F4C[];
// 10084F50: using guessed type int dword_10084F50[];
// 10084F54: using guessed type int dword_10084F54[];
// 10084F58: using guessed type int dword_10084F58[];
// 1016A100: using guessed type char byte_1016A100;

//----- (1001B920) --------------------------------------------------------
char sub_1001B920()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_10085B64[v2];
      if ( v0 != 6 )
      {
        v3 = byte_10085B62[v2 * 4];
        v4 = byte_10085B61[v2 * 4];
        v5 = byte_10085B60[v2 * 4];
        v6 = sub_1000BE80(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               (&off_10085B68)[v2 * 4]);
        v7 = sub_1000E0A0(
               1,
               *(&dword_1007CA3C + dword_10085B64[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_10085B64[v2]],
               (&off_10085B68)[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10085B64: using guessed type int dword_10085B64[];
// 10085B68: using guessed type char *off_10085B68;
// 1016A100: using guessed type char byte_1016A100;

//----- (1001BA80) --------------------------------------------------------
char sub_1001BA80()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_10085FFC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10085FF8[v2];
        v4 = dword_10085FF4[v2];
        v5 = dword_10085FF0[v2];
        v6 = sub_1000BE80(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               (&off_10086000)[v2 * 4]);
        v7 = sub_1000E480(
               1,
               *(&dword_1007CA3C + dword_10085FFC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_10085FFC[v2]],
               (&off_10086000)[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10085FF0: using guessed type int dword_10085FF0[];
// 10085FF4: using guessed type int dword_10085FF4[];
// 10085FF8: using guessed type int dword_10085FF8[];
// 10085FFC: using guessed type int dword_10085FFC[];
// 10086000: using guessed type char *off_10086000;
// 1016A100: using guessed type char byte_1016A100;

//----- (1001BBE0) --------------------------------------------------------
char sub_1001BBE0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1016A100 )
  {
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_100108B0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10049AD1,
           0);
    sub_1000C1E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_100108B0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_10049AD1,
           "a",
           0);
    sub_1000C1E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_100108B0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10049AD1,
           (const char *)&unk_10049AD1,
           0);
    sub_1000C1E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_100108B0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_1000C1E0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1016A100: using guessed type char byte_1016A100;

//----- (1001BDE0) --------------------------------------------------------
char sub_1001BDE0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_10086794[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10086790[v2];
        v4 = dword_1008678C[v2];
        v5 = dword_10086788[v2];
        v6 = sub_1000BE80(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               *(_DWORD *)&off_10086798[v2 * 4]);
        v7 = sub_1000E840(
               1,
               *(&dword_1007CA3C + dword_10086794[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_10086794[v2]],
               *(_DWORD *)&off_10086798[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10086788: using guessed type int dword_10086788[];
// 1008678C: using guessed type int dword_1008678C[];
// 10086790: using guessed type int dword_10086790[];
// 10086794: using guessed type int dword_10086794[];
// 1016A100: using guessed type char byte_1016A100;

//----- (1001BF40) --------------------------------------------------------
char sub_1001BF40()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_10086B00[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_10086AFC[v2 / 2];
        v4 = word_10086AFA[v2 / 2];
        v5 = word_10086AF8[v2 / 2];
        v6 = sub_1000BE80(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               (&off_10086B04)[v2]);
        v7 = sub_1000EBE0(
               1,
               *(&dword_1007CA3C + dword_10086B00[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_10086B00[v2 / 4]],
               (&off_10086B04)[v2]);
        LOBYTE(v0) = sub_1000C1E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10086AF8: using guessed type __int16 word_10086AF8[];
// 10086AFA: using guessed type __int16 word_10086AFA[];
// 10086AFC: using guessed type __int16 word_10086AFC[];
// 10086B00: using guessed type int dword_10086B00[];
// 10086B04: using guessed type char *off_10086B04;
// 1016A100: using guessed type char byte_1016A100;

//----- (1001C0A0) --------------------------------------------------------
char sub_1001C0A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_10086DC4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10086DC0[v2];
        v4 = dword_10086DBC[v2];
        v5 = dword_10086DB8[v2];
        v6 = sub_1000BE80(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               *(_DWORD *)&off_10086DC8[v2 * 4]);
        v7 = sub_1000EFE0(
               1,
               *(&dword_1007CA3C + dword_10086DC4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_10086DC4[v2]],
               *(_DWORD *)&off_10086DC8[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10086DB8: using guessed type int dword_10086DB8[];
// 10086DBC: using guessed type int dword_10086DBC[];
// 10086DC0: using guessed type int dword_10086DC0[];
// 10086DC4: using guessed type int dword_10086DC4[];
// 1016A100: using guessed type char byte_1016A100;

//----- (1001C200) --------------------------------------------------------
char sub_1001C200()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_10087140[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1008713C[v2];
        LODWORD(v3) = dword_10087138[v2];
        HIDWORD(v4) = dword_10087134[v2];
        LODWORD(v4) = dword_10087130[v2];
        HIDWORD(v5) = dword_1008712C[v2];
        LODWORD(v5) = dword_10087128[v2];
        v6 = sub_1000BE80(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               (&off_10087144)[v2 * 4]);
        v7 = sub_1000F380(
               1,
               *(&dword_1007CA3C + dword_10087140[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_10087140[v2]],
               (&off_10087144)[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10087128: using guessed type int dword_10087128[];
// 1008712C: using guessed type int dword_1008712C[];
// 10087130: using guessed type int dword_10087130[];
// 10087134: using guessed type int dword_10087134[];
// 10087138: using guessed type int dword_10087138[];
// 1008713C: using guessed type int dword_1008713C[];
// 10087140: using guessed type int dword_10087140[];
// 10087144: using guessed type char *off_10087144;
// 1016A100: using guessed type char byte_1016A100;

//----- (1001C370) --------------------------------------------------------
char sub_1001C370()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_100876AC[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100876AA[v2 * 4];
        v4 = byte_100876A9[v2 * 4];
        v5 = byte_100876A8[v2 * 4];
        v6 = sub_1000BE80(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               (&off_100876B0)[v2 * 4]);
        v7 = sub_1000F960(
               1,
               *(&dword_1007CA3C + dword_100876AC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_100876AC[v2]],
               (&off_100876B0)[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100876AC: using guessed type int dword_100876AC[];
// 100876B0: using guessed type char *off_100876B0;
// 1016A100: using guessed type char byte_1016A100;

//----- (1001C4D0) --------------------------------------------------------
char sub_1001C4D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_1016A100 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_100878C4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100878C0[v2];
        v4 = dword_100878BC[v2];
        v5 = dword_100878B8[v2];
        v6 = sub_1000BE80(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * *(&dword_1007CA3C + v0)],
               *(_DWORD *)&off_100878C8[v2 * 4]);
        v7 = sub_1000FD50(
               1,
               *(&dword_1007CA3C + dword_100878C4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1000BE80(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_100878C4[v2]],
               *(_DWORD *)&off_100878C8[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100878B8: using guessed type int dword_100878B8[];
// 100878BC: using guessed type int dword_100878BC[];
// 100878C0: using guessed type int dword_100878C0[];
// 100878C4: using guessed type int dword_100878C4[];
// 1016A100: using guessed type char byte_1016A100;

//----- (1001C630) --------------------------------------------------------
char sub_1001C630()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_1016A101 )
  {
    sub_100108B0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_1000CFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_1000CFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_1000CFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_1000CFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_1000CFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_1000CFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_1000CFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_1000CFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_1000CFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_1000CFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_1000B420(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_1000CFE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_10009E80() )
      v1 = 3;
    sub_1000CFE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_10009E80();
    sub_1000CFE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_1000B420(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_1000CFE0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1016A101: using guessed type char byte_1016A101;

//----- (1001CBD0) --------------------------------------------------------
char sub_1001CBD0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1016A101 )
  {
    v2 = 0;
    do
    {
      if ( off_10087C2C[v2] )
      {
        sub_1000BBE0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_10087C34[v2 * 4], 0x100u, &v13);
        sub_1000BBE0((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_10087C2C[v2], 0x100u, &v14);
        sub_100178A0(&v14, &v13);
      }
      if ( byte_10087C28[v2 * 4] )
      {
        sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = off_10087C30[v2];
        v4 = *(char **)&off_10087C34[v2 * 4];
        v5 = sub_1000BE80(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10087C34[v2 * 4],
               off_10087C30[v2]);
        v12 = 1;
        v11 = sub_10010500(
                0,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2114",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = off_10087C30[v2];
        v7 = *(char **)&off_10087C34[v2 * 4];
        v8 = sub_1000BE80(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10087C34[v2 * 4],
               off_10087C30[v2]);
        v12 = 1;
        v11 = sub_10010500(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2123",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_1000C1E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10087C2C: using guessed type char *off_10087C2C[3];
// 10087C30: using guessed type char *off_10087C30[2];
// 1016A101: using guessed type char byte_1016A101;

//----- (1001CDE0) --------------------------------------------------------
char sub_1001CDE0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_1016A101 )
  {
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_1000C1E0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1000C1E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_1000C1E0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1000C1E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_1000C1E0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1000C1E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_1000C1E0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1000C1E0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1016A101: using guessed type char byte_1016A101;

//----- (1001CFD0) --------------------------------------------------------
char sub_1001CFD0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_10087C7C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_10087C79[v2 * 4];
        v4 = byte_10087C78[v2 * 4];
        v5 = sub_1000BE80(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * dword_10087C7C[v2]],
               (&off_10087C80)[v2 * 4]);
        v6 = sub_1000C320(0, dword_10087C7C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_1000BE80(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_10087C7C[v2]],
               (&off_10087C80)[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 10087C7C: using guessed type int dword_10087C7C[];
// 10087C80: using guessed type char *off_10087C80;
// 1016A101: using guessed type char byte_1016A101;

//----- (1001D140) --------------------------------------------------------
char sub_1001D140()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_10087EF8[v2 / 2];
      v4 = dbl_10087EF0[v2 / 2];
      v5 = dbl_10087EE8[v2 / 2];
      v6 = sub_1000BE80(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_10087F00[v2]],
             (&off_10087F04)[v2 * 4]);
      v7 = sub_1000C6D0(0, dword_10087F00[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_10087F00[v2]],
             (&off_10087F04)[v2 * 4]);
      result = sub_1000C1E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10087EE8: using guessed type double dbl_10087EE8[];
// 10087EF0: using guessed type double dbl_10087EF0[];
// 10087EF8: using guessed type double dbl_10087EF8[];
// 10087F00: using guessed type int dword_10087F00[];
// 10087F04: using guessed type char *off_10087F04;
// 1016A101: using guessed type char byte_1016A101;

//----- (1001D2B0) --------------------------------------------------------
char sub_1001D2B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_10088B10[v2];
      v4 = flt_10088B0C[v2];
      v5 = flt_10088B08[v2];
      v6 = sub_1000BE80(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_10088B14[v2]],
             *(_DWORD *)&off_10088B18[v2 * 4]);
      v7 = sub_1000CB20(0, dword_10088B14[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_10088B14[v2]],
             *(_DWORD *)&off_10088B18[v2 * 4]);
      result = sub_1000C1E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10088B08: using guessed type float flt_10088B08[];
// 10088B0C: using guessed type float flt_10088B0C[];
// 10088B10: using guessed type float flt_10088B10[];
// 10088B14: using guessed type int dword_10088B14[];
// 1016A101: using guessed type char byte_1016A101;

//----- (1001D410) --------------------------------------------------------
char sub_1001D410()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1016A101 )
  {
    sub_10010800(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_1001D410,
      (int)sub_1001D410,
      0);
    sub_10010800(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_1001D410,
      0,
      0);
    result = sub_10010800(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1001D410,
               0);
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1016A101: using guessed type char byte_1016A101;

//----- (1001D500) --------------------------------------------------------
char sub_1001D500()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_100892A8[v2];
      v4 = dword_100892A4[v2];
      v5 = dword_100892A0[v2];
      v6 = sub_1000BE80(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_100892AC[v2]],
             (&off_100892B0)[v2 * 4]);
      v7 = sub_1000CFE0(0, dword_100892AC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_100892AC[v2]],
             (&off_100892B0)[v2 * 4]);
      result = sub_1000C1E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100892A0: using guessed type int dword_100892A0[];
// 100892A4: using guessed type int dword_100892A4[];
// 100892A8: using guessed type int dword_100892A8[];
// 100892AC: using guessed type int dword_100892AC[];
// 100892B0: using guessed type char *off_100892B0;
// 1016A101: using guessed type char byte_1016A101;

//----- (1001D660) --------------------------------------------------------
char sub_1001D660()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_10089A3C[v2 / 2];
      v4 = word_10089A3A[v2 / 2];
      v5 = word_10089A38[v2 / 2];
      v6 = sub_1000BE80(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_10089A40[v2 / 4]],
             (&off_10089A44)[v2]);
      v7 = sub_1000D3A0(
             0,
             dword_10089A40[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_10089A40[v2 / 4]],
             (&off_10089A44)[v2]);
      result = sub_1000C1E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10089A38: using guessed type __int16 word_10089A38[];
// 10089A3A: using guessed type __int16 word_10089A3A[];
// 10089A3C: using guessed type __int16 word_10089A3C[];
// 10089A40: using guessed type int dword_10089A40[];
// 10089A44: using guessed type char *off_10089A44;
// 1016A101: using guessed type char byte_1016A101;

//----- (1001D7C0) --------------------------------------------------------
char sub_1001D7C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_1008A050[v2];
      v4 = dword_1008A04C[v2];
      v5 = dword_1008A048[v2];
      v6 = sub_1000BE80(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_1008A054[v2]],
             *(_DWORD *)&off_1008A058[v2 * 4]);
      v7 = sub_1000D7A0(0, dword_1008A054[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_1008A054[v2]],
             *(_DWORD *)&off_1008A058[v2 * 4]);
      result = sub_1000C1E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008A048: using guessed type int dword_1008A048[];
// 1008A04C: using guessed type int dword_1008A04C[];
// 1008A050: using guessed type int dword_1008A050[];
// 1008A054: using guessed type int dword_1008A054[];
// 1016A101: using guessed type char byte_1016A101;

//----- (1001D920) --------------------------------------------------------
char sub_1001D920()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_1008A7F4[v2];
      LODWORD(v3) = dword_1008A7F0[v2];
      HIDWORD(v4) = dword_1008A7EC[v2];
      LODWORD(v4) = dword_1008A7E8[v2];
      HIDWORD(v5) = dword_1008A7E4[v2];
      LODWORD(v5) = dword_1008A7E0[v2];
      v6 = sub_1000BE80(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_1008A7F8[v2]],
             *(_DWORD *)&off_1008A7FC[v2 * 4]);
      v7 = sub_1000DB60(0, dword_1008A7F8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_1008A7F8[v2]],
             *(_DWORD *)&off_1008A7FC[v2 * 4]);
      result = sub_1000C1E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008A7E0: using guessed type int dword_1008A7E0[];
// 1008A7E4: using guessed type int dword_1008A7E4[];
// 1008A7E8: using guessed type int dword_1008A7E8[];
// 1008A7EC: using guessed type int dword_1008A7EC[];
// 1008A7F0: using guessed type int dword_1008A7F0[];
// 1008A7F4: using guessed type int dword_1008A7F4[];
// 1008A7F8: using guessed type int dword_1008A7F8[];
// 1016A101: using guessed type char byte_1016A101;

//----- (1001DA90) --------------------------------------------------------
char sub_1001DA90()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_1008B402[v2 * 4];
      v4 = byte_1008B401[v2 * 4];
      v5 = byte_1008B400[v2 * 4];
      v6 = sub_1000BE80(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_1008B404[v2]],
             (&off_1008B408)[v2 * 4]);
      v7 = sub_1000E0A0(0, dword_1008B404[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_1008B404[v2]],
             (&off_1008B408)[v2 * 4]);
      result = sub_1000C1E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008B404: using guessed type int dword_1008B404[];
// 1008B408: using guessed type char *off_1008B408;
// 1016A101: using guessed type char byte_1016A101;

//----- (1001DBF0) --------------------------------------------------------
char sub_1001DBF0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_1008B898[v2];
      v4 = dword_1008B894[v2];
      v5 = dword_1008B890[v2];
      v6 = sub_1000BE80(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_1008B89C[v2]],
             (&off_1008B8A0)[v2 * 4]);
      v7 = sub_1000E480(0, dword_1008B89C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_1008B89C[v2]],
             (&off_1008B8A0)[v2 * 4]);
      result = sub_1000C1E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008B890: using guessed type int dword_1008B890[];
// 1008B894: using guessed type int dword_1008B894[];
// 1008B898: using guessed type int dword_1008B898[];
// 1008B89C: using guessed type int dword_1008B89C[];
// 1008B8A0: using guessed type char *off_1008B8A0;
// 1016A101: using guessed type char byte_1016A101;

//----- (1001DD50) --------------------------------------------------------
char sub_1001DD50()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1016A101 )
  {
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_100108B0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10049AD1,
           (const char *)&unk_10049AD1,
           0);
    sub_1000C1E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_100108B0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1000C1E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_100108B0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10049AD1,
           0);
    sub_1000C1E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_100108B0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1000C1E0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1016A101: using guessed type char byte_1016A101;

//----- (1001DF50) --------------------------------------------------------
char sub_1001DF50()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_1008C030[v2];
      v4 = dword_1008C02C[v2];
      v5 = dword_1008C028[v2];
      v6 = sub_1000BE80(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_1008C034[v2]],
             *(_DWORD *)&off_1008C038[v2 * 4]);
      v7 = sub_1000E840(0, dword_1008C034[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_1008C034[v2]],
             *(_DWORD *)&off_1008C038[v2 * 4]);
      result = sub_1000C1E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008C028: using guessed type int dword_1008C028[];
// 1008C02C: using guessed type int dword_1008C02C[];
// 1008C030: using guessed type int dword_1008C030[];
// 1008C034: using guessed type int dword_1008C034[];
// 1016A101: using guessed type char byte_1016A101;

//----- (1001E0B0) --------------------------------------------------------
char sub_1001E0B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_1008C39C[v2 / 2];
      v4 = word_1008C39A[v2 / 2];
      v5 = word_1008C398[v2 / 2];
      v6 = sub_1000BE80(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_1008C3A0[v2 / 4]],
             (&off_1008C3A4)[v2]);
      v7 = sub_1000EBE0(
             0,
             dword_1008C3A0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_1008C3A0[v2 / 4]],
             (&off_1008C3A4)[v2]);
      result = sub_1000C1E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008C398: using guessed type __int16 word_1008C398[];
// 1008C39A: using guessed type __int16 word_1008C39A[];
// 1008C39C: using guessed type __int16 word_1008C39C[];
// 1008C3A0: using guessed type int dword_1008C3A0[];
// 1008C3A4: using guessed type char *off_1008C3A4;
// 1016A101: using guessed type char byte_1016A101;

//----- (1001E210) --------------------------------------------------------
char sub_1001E210()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_1008C660[v2];
      v4 = dword_1008C65C[v2];
      v5 = dword_1008C658[v2];
      v6 = sub_1000BE80(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_1008C664[v2]],
             *(_DWORD *)&off_1008C668[v2 * 4]);
      v7 = sub_1000EFE0(0, dword_1008C664[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_1008C664[v2]],
             *(_DWORD *)&off_1008C668[v2 * 4]);
      result = sub_1000C1E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008C658: using guessed type int dword_1008C658[];
// 1008C65C: using guessed type int dword_1008C65C[];
// 1008C660: using guessed type int dword_1008C660[];
// 1008C664: using guessed type int dword_1008C664[];
// 1016A101: using guessed type char byte_1016A101;

//----- (1001E370) --------------------------------------------------------
char sub_1001E370()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_1008C9DC[v2];
      LODWORD(v3) = dword_1008C9D8[v2];
      HIDWORD(v4) = dword_1008C9D4[v2];
      LODWORD(v4) = dword_1008C9D0[v2];
      HIDWORD(v5) = dword_1008C9CC[v2];
      LODWORD(v5) = dword_1008C9C8[v2];
      v6 = sub_1000BE80(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_1008C9E0[v2]],
             (&off_1008C9E4)[v2 * 4]);
      v7 = sub_1000F380(0, dword_1008C9E0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_1008C9E0[v2]],
             (&off_1008C9E4)[v2 * 4]);
      result = sub_1000C1E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008C9C8: using guessed type int dword_1008C9C8[];
// 1008C9CC: using guessed type int dword_1008C9CC[];
// 1008C9D0: using guessed type int dword_1008C9D0[];
// 1008C9D4: using guessed type int dword_1008C9D4[];
// 1008C9D8: using guessed type int dword_1008C9D8[];
// 1008C9DC: using guessed type int dword_1008C9DC[];
// 1008C9E0: using guessed type int dword_1008C9E0[];
// 1008C9E4: using guessed type char *off_1008C9E4;
// 1016A101: using guessed type char byte_1016A101;

//----- (1001E4E0) --------------------------------------------------------
char sub_1001E4E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_1008CF4A[v2 * 4];
      v4 = byte_1008CF49[v2 * 4];
      v5 = byte_1008CF48[v2 * 4];
      v6 = sub_1000BE80(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_1008CF4C[v2]],
             (&off_1008CF50)[v2 * 4]);
      v7 = sub_1000F960(0, dword_1008CF4C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_1008CF4C[v2]],
             (&off_1008CF50)[v2 * 4]);
      result = sub_1000C1E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008CF4C: using guessed type int dword_1008CF4C[];
// 1008CF50: using guessed type char *off_1008CF50;
// 1016A101: using guessed type char byte_1016A101;

//----- (1001E640) --------------------------------------------------------
char sub_1001E640()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_1008D160[v2];
      v4 = dword_1008D15C[v2];
      v5 = dword_1008D158[v2];
      v6 = sub_1000BE80(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_1008D164[v2]],
             *(_DWORD *)&off_1008D168[v2 * 4]);
      v7 = sub_1000FD50(0, dword_1008D164[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_1008D164[v2]],
             *(_DWORD *)&off_1008D168[v2 * 4]);
      result = sub_1000C1E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008D158: using guessed type int dword_1008D158[];
// 1008D15C: using guessed type int dword_1008D15C[];
// 1008D160: using guessed type int dword_1008D160[];
// 1008D164: using guessed type int dword_1008D164[];
// 1016A101: using guessed type char byte_1016A101;

//----- (1001E7A0) --------------------------------------------------------
char sub_1001E7A0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  char *v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_1016A101 )
  {
    v2 = 0;
    do
    {
      if ( off_1008D4CC[v2] )
      {
        sub_1000BBE0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1008D4D4[v2 * 4], 0x100u, &v13);
        sub_1000BBE0((int)"..\\lib\\utf\\utf_validate.c", 2, (int)off_1008D4CC[v2], 0x100u, &v14);
        sub_100178A0(&v14, &v13);
      }
      if ( byte_1008D4C8[v2 * 4] )
      {
        sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = off_1008D4D0[v2];
        v4 = *(char **)&off_1008D4D4[v2 * 4];
        v5 = sub_1000BE80(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1008D4D4[v2 * 4],
               off_1008D4D0[v2]);
        v12 = 1;
        v11 = sub_10010500(
                1,
                0,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2745",
                (int)v5,
                (int)v4,
                (int)v3,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = off_1008D4D0[v2];
        v7 = *(char **)&off_1008D4D4[v2 * 4];
        v8 = sub_1000BE80(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1008D4D4[v2 * 4],
               off_1008D4D0[v2]);
        v12 = 1;
        v11 = sub_10010500(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"2754",
                (int)v8,
                (int)v7,
                (int)v6,
                0xFEFEu,
                0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_1000C1E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 4;
    }
    while ( v2 < 20 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008D4CC: using guessed type char *off_1008D4CC[3];
// 1008D4D0: using guessed type char *off_1008D4D0[2];
// 1016A101: using guessed type char byte_1016A101;

//----- (1001E9B0) --------------------------------------------------------
char sub_1001E9B0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_1016A101 )
  {
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_1000C1E0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1000C1E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_1000C1E0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1000C1E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_1000C1E0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1000C1E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_1000C1E0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1000C1E0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1016A101: using guessed type char byte_1016A101;

//----- (1001EBA0) --------------------------------------------------------
char sub_1001EBA0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      v0 = dword_1008D51C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_1008D519[v2 * 4];
        v4 = byte_1008D518[v2 * 4];
        v5 = sub_1000BE80(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_1007CA20[4 * dword_1008D51C[v2]],
               (&off_1008D520)[v2 * 4]);
        v6 = sub_1000C320(1, dword_1008D51C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_1000BE80(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_1007CA20[4 * dword_1008D51C[v2]],
               (&off_1008D520)[v2 * 4]);
        LOBYTE(v0) = sub_1000C1E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_1000B420(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 1008D51C: using guessed type int dword_1008D51C[];
// 1008D520: using guessed type char *off_1008D520;
// 1016A101: using guessed type char byte_1016A101;

//----- (1001ED10) --------------------------------------------------------
char sub_1001ED10()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_1008D798[v2 / 2];
      v4 = dbl_1008D790[v2 / 2];
      v5 = dbl_1008D788[v2 / 2];
      v6 = sub_1000BE80(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_1008D7A0[v2]],
             (&off_1008D7A4)[v2 * 4]);
      v7 = sub_1000C6D0(1, dword_1008D7A0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_1008D7A0[v2]],
             (&off_1008D7A4)[v2 * 4]);
      result = sub_1000C1E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008D788: using guessed type double dbl_1008D788[];
// 1008D790: using guessed type double dbl_1008D790[];
// 1008D798: using guessed type double dbl_1008D798[];
// 1008D7A0: using guessed type int dword_1008D7A0[];
// 1008D7A4: using guessed type char *off_1008D7A4;
// 1016A101: using guessed type char byte_1016A101;

//----- (1001EE80) --------------------------------------------------------
char sub_1001EE80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_1008E3B0[v2];
      v4 = flt_1008E3AC[v2];
      v5 = flt_1008E3A8[v2];
      v6 = sub_1000BE80(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_1008E3B4[v2]],
             *(_DWORD *)&off_1008E3B8[v2 * 4]);
      v7 = sub_1000CB20(1, dword_1008E3B4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_1008E3B4[v2]],
             *(_DWORD *)&off_1008E3B8[v2 * 4]);
      result = sub_1000C1E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008E3A8: using guessed type float flt_1008E3A8[];
// 1008E3AC: using guessed type float flt_1008E3AC[];
// 1008E3B0: using guessed type float flt_1008E3B0[];
// 1008E3B4: using guessed type int dword_1008E3B4[];
// 1016A101: using guessed type char byte_1016A101;

//----- (1001EFE0) --------------------------------------------------------
char sub_1001EFE0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_1016A101 )
  {
    sub_10010800(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_1001EFE0,
      (int)sub_1001EFE0,
      0);
    sub_10010800(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_1001EFE0,
      0,
      0);
    result = sub_10010800(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1001EFE0,
               0);
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1016A101: using guessed type char byte_1016A101;

//----- (1001F0D0) --------------------------------------------------------
char sub_1001F0D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_1008EB48[v2];
      v4 = dword_1008EB44[v2];
      v5 = dword_1008EB40[v2];
      v6 = sub_1000BE80(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_1008EB4C[v2]],
             (&off_1008EB50)[v2 * 4]);
      v7 = sub_1000CFE0(1, dword_1008EB4C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_1008EB4C[v2]],
             (&off_1008EB50)[v2 * 4]);
      result = sub_1000C1E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008EB40: using guessed type int dword_1008EB40[];
// 1008EB44: using guessed type int dword_1008EB44[];
// 1008EB48: using guessed type int dword_1008EB48[];
// 1008EB4C: using guessed type int dword_1008EB4C[];
// 1008EB50: using guessed type char *off_1008EB50;
// 1016A101: using guessed type char byte_1016A101;

//----- (1001F230) --------------------------------------------------------
char sub_1001F230()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_1008F2DC[v2 / 2];
      v4 = word_1008F2DA[v2 / 2];
      v5 = word_1008F2D8[v2 / 2];
      v6 = sub_1000BE80(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_1008F2E0[v2 / 4]],
             (&off_1008F2E4)[v2]);
      v7 = sub_1000D3A0(
             1,
             dword_1008F2E0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_1008F2E0[v2 / 4]],
             (&off_1008F2E4)[v2]);
      result = sub_1000C1E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008F2D8: using guessed type __int16 word_1008F2D8[];
// 1008F2DA: using guessed type __int16 word_1008F2DA[];
// 1008F2DC: using guessed type __int16 word_1008F2DC[];
// 1008F2E0: using guessed type int dword_1008F2E0[];
// 1008F2E4: using guessed type char *off_1008F2E4;
// 1016A101: using guessed type char byte_1016A101;

//----- (1001F390) --------------------------------------------------------
char sub_1001F390()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_1008F8F0[v2];
      v4 = dword_1008F8EC[v2];
      v5 = dword_1008F8E8[v2];
      v6 = sub_1000BE80(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_1008F8F4[v2]],
             *(_DWORD *)&off_1008F8F8[v2 * 4]);
      v7 = sub_1000D7A0(1, dword_1008F8F4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_1008F8F4[v2]],
             *(_DWORD *)&off_1008F8F8[v2 * 4]);
      result = sub_1000C1E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1008F8E8: using guessed type int dword_1008F8E8[];
// 1008F8EC: using guessed type int dword_1008F8EC[];
// 1008F8F0: using guessed type int dword_1008F8F0[];
// 1008F8F4: using guessed type int dword_1008F8F4[];
// 1016A101: using guessed type char byte_1016A101;

//----- (1001F4F0) --------------------------------------------------------
char sub_1001F4F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_10090094[v2];
      LODWORD(v3) = dword_10090090[v2];
      HIDWORD(v4) = dword_1009008C[v2];
      LODWORD(v4) = dword_10090088[v2];
      HIDWORD(v5) = dword_10090084[v2];
      LODWORD(v5) = dword_10090080[v2];
      v6 = sub_1000BE80(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_10090098[v2]],
             *(_DWORD *)&off_1009009C[v2 * 4]);
      v7 = sub_1000DB60(1, dword_10090098[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_10090098[v2]],
             *(_DWORD *)&off_1009009C[v2 * 4]);
      result = sub_1000C1E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10090080: using guessed type int dword_10090080[];
// 10090084: using guessed type int dword_10090084[];
// 10090088: using guessed type int dword_10090088[];
// 1009008C: using guessed type int dword_1009008C[];
// 10090090: using guessed type int dword_10090090[];
// 10090094: using guessed type int dword_10090094[];
// 10090098: using guessed type int dword_10090098[];
// 1016A101: using guessed type char byte_1016A101;

//----- (1001F660) --------------------------------------------------------
char sub_1001F660()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_10090CA2[v2 * 4];
      v4 = byte_10090CA1[v2 * 4];
      v5 = byte_10090CA0[v2 * 4];
      v6 = sub_1000BE80(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_10090CA4[v2]],
             (&off_10090CA8)[v2 * 4]);
      v7 = sub_1000E0A0(1, dword_10090CA4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_10090CA4[v2]],
             (&off_10090CA8)[v2 * 4]);
      result = sub_1000C1E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10090CA4: using guessed type int dword_10090CA4[];
// 10090CA8: using guessed type char *off_10090CA8;
// 1016A101: using guessed type char byte_1016A101;

//----- (1001F7C0) --------------------------------------------------------
char sub_1001F7C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_10091138[v2];
      v4 = dword_10091134[v2];
      v5 = dword_10091130[v2];
      v6 = sub_1000BE80(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_1009113C[v2]],
             (&off_10091140)[v2 * 4]);
      v7 = sub_1000E480(1, dword_1009113C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_1009113C[v2]],
             (&off_10091140)[v2 * 4]);
      result = sub_1000C1E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10091130: using guessed type int dword_10091130[];
// 10091134: using guessed type int dword_10091134[];
// 10091138: using guessed type int dword_10091138[];
// 1009113C: using guessed type int dword_1009113C[];
// 10091140: using guessed type char *off_10091140;
// 1016A101: using guessed type char byte_1016A101;

//----- (1001F920) --------------------------------------------------------
char sub_1001F920()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_1000B420(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1000BD70(0);
  sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_1000B420(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_1016A101 )
  {
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_100108B0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10049AD1,
           (const char *)&unk_10049AD1,
           0);
    sub_1000C1E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_100108B0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1000C1E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_100108B0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10049AD1,
           0);
    sub_1000C1E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_100108B0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1000C1E0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 1016A101: using guessed type char byte_1016A101;

//----- (1001FB20) --------------------------------------------------------
char sub_1001FB20()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_100918D0[v2];
      v4 = dword_100918CC[v2];
      v5 = dword_100918C8[v2];
      v6 = sub_1000BE80(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_100918D4[v2]],
             *(_DWORD *)&off_100918D8[v2 * 4]);
      v7 = sub_1000E840(1, dword_100918D4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_100918D4[v2]],
             *(_DWORD *)&off_100918D8[v2 * 4]);
      result = sub_1000C1E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100918C8: using guessed type int dword_100918C8[];
// 100918CC: using guessed type int dword_100918CC[];
// 100918D0: using guessed type int dword_100918D0[];
// 100918D4: using guessed type int dword_100918D4[];
// 1016A101: using guessed type char byte_1016A101;

//----- (1001FC80) --------------------------------------------------------
char sub_1001FC80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_10091C3C[v2 / 2];
      v4 = word_10091C3A[v2 / 2];
      v5 = word_10091C38[v2 / 2];
      v6 = sub_1000BE80(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_10091C40[v2 / 4]],
             (&off_10091C44)[v2]);
      v7 = sub_1000EBE0(
             1,
             dword_10091C40[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_10091C40[v2 / 4]],
             (&off_10091C44)[v2]);
      result = sub_1000C1E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10091C38: using guessed type __int16 word_10091C38[];
// 10091C3A: using guessed type __int16 word_10091C3A[];
// 10091C3C: using guessed type __int16 word_10091C3C[];
// 10091C40: using guessed type int dword_10091C40[];
// 10091C44: using guessed type char *off_10091C44;
// 1016A101: using guessed type char byte_1016A101;

//----- (1001FDE0) --------------------------------------------------------
char sub_1001FDE0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_10091F00[v2];
      v4 = dword_10091EFC[v2];
      v5 = dword_10091EF8[v2];
      v6 = sub_1000BE80(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_10091F04[v2]],
             *(_DWORD *)&off_10091F08[v2 * 4]);
      v7 = sub_1000EFE0(1, dword_10091F04[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_10091F04[v2]],
             *(_DWORD *)&off_10091F08[v2 * 4]);
      result = sub_1000C1E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10091EF8: using guessed type int dword_10091EF8[];
// 10091EFC: using guessed type int dword_10091EFC[];
// 10091F00: using guessed type int dword_10091F00[];
// 10091F04: using guessed type int dword_10091F04[];
// 1016A101: using guessed type char byte_1016A101;

//----- (1001FF40) --------------------------------------------------------
char sub_1001FF40()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_1009227C[v2];
      LODWORD(v3) = dword_10092278[v2];
      HIDWORD(v4) = dword_10092274[v2];
      LODWORD(v4) = dword_10092270[v2];
      HIDWORD(v5) = dword_1009226C[v2];
      LODWORD(v5) = dword_10092268[v2];
      v6 = sub_1000BE80(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_10092280[v2]],
             (&off_10092284)[v2 * 4]);
      v7 = sub_1000F380(1, dword_10092280[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_10092280[v2]],
             (&off_10092284)[v2 * 4]);
      result = sub_1000C1E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10092268: using guessed type int dword_10092268[];
// 1009226C: using guessed type int dword_1009226C[];
// 10092270: using guessed type int dword_10092270[];
// 10092274: using guessed type int dword_10092274[];
// 10092278: using guessed type int dword_10092278[];
// 1009227C: using guessed type int dword_1009227C[];
// 10092280: using guessed type int dword_10092280[];
// 10092284: using guessed type char *off_10092284;
// 1016A101: using guessed type char byte_1016A101;

//----- (100200B0) --------------------------------------------------------
char sub_100200B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_100927EA[v2 * 4];
      v4 = byte_100927E9[v2 * 4];
      v5 = byte_100927E8[v2 * 4];
      v6 = sub_1000BE80(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_100927EC[v2]],
             (&off_100927F0)[v2 * 4]);
      v7 = sub_1000F960(1, dword_100927EC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_100927EC[v2]],
             (&off_100927F0)[v2 * 4]);
      result = sub_1000C1E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100927EC: using guessed type int dword_100927EC[];
// 100927F0: using guessed type char *off_100927F0;
// 1016A101: using guessed type char byte_1016A101;

//----- (10020210) --------------------------------------------------------
char sub_10020210()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_1016A101 )
  {
    sub_1000B420(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1000BD70(0);
    sub_1000B420(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_1000B420(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1000BE60(0);
    v2 = 0;
    do
    {
      sub_1000BD90((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_10092A00[v2];
      v4 = dword_100929FC[v2];
      v5 = dword_100929F8[v2];
      v6 = sub_1000BE80(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_1007CA20[4 * dword_10092A04[v2]],
             *(_DWORD *)&off_10092A08[v2 * 4]);
      v7 = sub_1000FD50(1, dword_10092A04[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_1000BE80(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_1007CA20[4 * dword_10092A04[v2]],
             *(_DWORD *)&off_10092A08[v2 * 4]);
      result = sub_1000C1E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_1000B420(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100929F8: using guessed type int dword_100929F8[];
// 100929FC: using guessed type int dword_100929FC[];
// 10092A00: using guessed type int dword_10092A00[];
// 10092A04: using guessed type int dword_10092A04[];
// 1016A101: using guessed type char byte_1016A101;

//----- (10020370) --------------------------------------------------------
char **sub_10020370()
{
  return off_1007E10C;
}
// 1007E10C: using guessed type char *off_1007E10C[3];

//----- (10020380) --------------------------------------------------------
int __cdecl sub_10020380(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (100203A0) --------------------------------------------------------
int (__cdecl *__usercall sub_100203A0@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (100203B0) --------------------------------------------------------
int __usercall sub_100203B0@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (100205E0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100205E0(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_100203A0(a1, (int)" ");
  sub_100203A0(a1, a2);
  sub_100203A0(a1, (int)&unk_10096C5C);
  v3 = sub_100203B0(a3, a1);
  sub_100203A0(a1, v3);
  return sub_100203A0(a1, (int)&unk_10096C58);
}

//----- (10020630) --------------------------------------------------------
int (__cdecl *__cdecl sub_10020630(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_100203A0(a1, (int)" ");
  sub_100203A0(a1, a2);
  sub_100203A0(a1, (int)&unk_10096C64);
  v3 = sub_100203B0(a3, a1);
  sub_100203A0(a1, v3);
  return sub_100203A0(a1, (int)&unk_10096C60);
}

//----- (10020680) --------------------------------------------------------
int (__cdecl *__cdecl sub_10020680(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_100203A0(a1, (int)&unk_10096C68);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_100203B0(a2, a1);
    result = sub_100203A0(a1, v3);
  }
  return result;
}

//----- (100206D0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100206D0(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_10096C70;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_100203A0(a1, dword_10096BC4[(signed int)result]);
      sub_100203A0(a1, (int)&unk_10096C6C);
      sub_100203A0(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_10096C68;
    }
    result = sub_100203A0(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_100203A0(a1, (int)&word_100704CC);
  }
  return result;
}
// 100704CC: using guessed type __int16 word_100704CC;
// 10096BC4: using guessed type int dword_10096BC4[];

//----- (10020750) --------------------------------------------------------
int __cdecl sub_10020750(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_100203A0(a1, (int)&unk_10096C68);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_100203A0(a1, *((_DWORD *)&off_10096BC8 + *(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84)));
  sub_100203A0(a1, (int)&unk_10096C74);
  sub_100203A0(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}

//----- (100207D0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100207D0(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_100203B0(a2, a1);
    sub_100203A0(a1, v3);
    result = sub_100203A0(a1, (int)&word_100704CC);
  }
  else
  {
    sub_100203A0(a1, (int)a2);
    result = sub_100203A0(a1, (int)&word_100704CC);
  }
  return result;
}
// 100704CC: using guessed type __int16 word_100704CC;

//----- (10020820) --------------------------------------------------------
int (__cdecl *__cdecl sub_10020820(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_10020750(a1, a2);
  if ( a3 && *a3 )
    sub_10020680(a1, a3);
  return sub_100206D0(a1);
}

//----- (10020860) --------------------------------------------------------
int (__cdecl *__cdecl sub_10020860(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_10020820(a1, a2, (unsigned __int8 *)&v4);
}

//----- (100208C0) --------------------------------------------------------
char __cdecl sub_100208C0(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_10003DC0("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (10020900) --------------------------------------------------------
int __cdecl sub_10020900(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10008CF0(&a1, 1u, (int)&unk_10099608, 8, 67, 0);
  if ( v1 )
  {
    result = dword_1009960C[2 * v1];
  }
  else
  {
    sub_10003DC0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 1009960C: using guessed type int dword_1009960C[];

//----- (10020950) --------------------------------------------------------
bool __cdecl sub_10020950(void *a1)
{
  char v1; // cl@1

  v1 = sub_10008B20(1, 1946, a1);
  *((_DWORD *)a1 + 1) /= 0x3E8u;
  return v1 && !sub_100151E0((int)a1);
}

//----- (10020990) --------------------------------------------------------
char __cdecl sub_10020990(char a1)
{
  sub_10008650(1, 1672, &a1, 0, 1, 1);
  return sub_10008790(1, 0x688u, 0xFFFFFFF);
}

//----- (100209C0) --------------------------------------------------------
char __cdecl sub_100209C0(char a1)
{
  int v1; // eax@1

  v1 = sub_10004340(10028, (int)&a1, 1);
  if ( !v1 )
    LOBYTE(v1) = sub_10020990(a1);
  return v1;
}

//----- (100209F0) --------------------------------------------------------
BOOL __cdecl sub_100209F0(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (10020A00) --------------------------------------------------------
BOOL __usercall sub_10020A00@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_100209F0(a1) && *v2 < 3u && a2 == 24;
}

//----- (10020A30) --------------------------------------------------------
bool __cdecl sub_10020A30(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_100209F0(a1) )
    {
      v6 = 10 * v5;
      if ( sub_1002A310((unsigned __int8)byte_1009B588[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_10008B20(1, (unsigned __int16)word_1009B580[v6], &Tm.tm_mon) || sub_10015190((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_10013C80(a1, &v15) || v15 != dword_1009B5A0[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_10008B20(1, (unsigned __int16)word_1009B584[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 1009B580: using guessed type __int16 word_1009B580[];
// 1009B584: using guessed type __int16 word_1009B584[];
// 1009B5A0: using guessed type int dword_1009B5A0[];

//----- (10020BE0) --------------------------------------------------------
bool __cdecl sub_10020BE0(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_100209F0(a1) )
    result = sub_10004270((unsigned __int16)word_1009B58A[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 1009B58A: using guessed type __int16 word_1009B58A[];

//----- (10020C20) --------------------------------------------------------
bool __cdecl sub_10020C20(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_10013BD0(a1);
  if ( !(unsigned __int8)sub_10020A00(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_10020A30(v9, a3, *a4, (int)a5);
  if ( sub_1002A310((unsigned __int8)byte_1009B588[20 * v6], (bool *)&v8) && v8 && sub_10020BE0(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 10020C20: using guessed type int var_20[7];

//----- (10020D10) --------------------------------------------------------
bool __cdecl sub_10020D10(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_10008CF0(&a2, 4u, (int)&dword_1009C510, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_10004270((unsigned __int16)word_1009C514[a1 + 6 * v3], a3, (unsigned __int16)word_1009C518[6 * v3]) == 0;
  }
  else
  {
    sub_10003DC0("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 1009C510: using guessed type int dword_1009C510;
// 1009C514: using guessed type __int16 word_1009C514[];
// 1009C518: using guessed type __int16 word_1009C518[];

//----- (10020DA0) --------------------------------------------------------
bool __cdecl sub_10020DA0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_10020E40(a1);
  v6 = sub_10008CF0(&a3, 1u, (int)&unk_1009C534, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_10008CF0(&dword_1009C538[2 * v6], 4u, (int)&dword_1009C510, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_1009C518[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_10020D10(v11, *(int *)((char *)&dword_1009C510 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1009C510: using guessed type int dword_1009C510;
// 1009C518: using guessed type __int16 word_1009C518[];

//----- (10020E40) --------------------------------------------------------
char __cdecl sub_10020E40(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_10003DC0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (10020EC0) --------------------------------------------------------
char __cdecl sub_10020EC0(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_10014020(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_10004270(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_10014040((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (10021030) --------------------------------------------------------
int __usercall sub_10021030@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_10020EC0(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 10021030: using guessed type int var_2C[10];

//----- (10021070) --------------------------------------------------------
int __usercall sub_10021070@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_10020EC0(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 10021070: using guessed type int var_14[4];

//----- (100210B0) --------------------------------------------------------
signed int sub_100210B0()
{
  return sub_100422E0((int)&off_1009E3D8);
}
// 1009E3D8: using guessed type char *off_1009E3D8;

//----- (100210C0) --------------------------------------------------------
char __cdecl sub_100210C0(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_100210B0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_101A4A4C + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_101A4A4C + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_101A4A4C);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101A4A4C: using guessed type int dword_101A4A4C;

//----- (10021120) --------------------------------------------------------
char __cdecl sub_10021120(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_100210B0() )
  {
    if ( (sub_10014060(a1)
       || *(_BYTE *)(dword_101A4A4C + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_101A4A4C + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_101A4A4C + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101A4A4C + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101A4A4C + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101A4A4C + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101A4A4C + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101A4A4C + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101A4A4C + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101A4A4C + 176))
      && *(_BYTE *)(dword_101A4A4C + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_101A4A4C + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_101A4A4C + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_101A4A4C + 162) )
    {
      qmemcpy(a2, (const void *)(dword_101A4A4C + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101A4A4C: using guessed type int dword_101A4A4C;

//----- (10021240) --------------------------------------------------------
char __cdecl sub_10021240(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_100210B0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_101A4A4C + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_101A4A4C + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_101A4A4C + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_101A4A4C + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_101A4A4C);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101A4A4C: using guessed type int dword_101A4A4C;

//----- (100212C0) --------------------------------------------------------
char __cdecl sub_100212C0(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_10003DC0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_10021070(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_10021240(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_10003DC0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_10021030(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_100210C0(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_10003DC0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_10020EC0(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_10021120(v6, a5);
        }
      }
      else
      {
        sub_10003DC0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10003DC0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10021470) --------------------------------------------------------
int __cdecl sub_10021470(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (10021490) --------------------------------------------------------
char __cdecl sub_10021490(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9)
{
  char *v9; // eax@1
  char v10; // cl@2
  __int16 v12; // [sp+0h] [bp-52Ch]@1
  char v13; // [sp+4h] [bp-528h]@1
  char v14; // [sp+5h] [bp-527h]@1
  char v15; // [sp+6h] [bp-526h]@1
  char v16; // [sp+7h] [bp-525h]@1
  char v17; // [sp+8h] [bp-524h]@1
  char v18; // [sp+9h] [bp-523h]@1
  __int16 v19; // [sp+Ah] [bp-522h]@1
  int v20; // [sp+Ch] [bp-520h]@1
  char v21[1300]; // [sp+14h] [bp-518h]@2

  memset(&v12, 0, 0x528u);
  v15 = a4;
  v20 = a6;
  v16 = a3;
  v13 = a1;
  v9 = a9;
  v17 = a5;
  v14 = a2;
  v12 = -32708;
  v18 = a7;
  v19 = a8;
  if ( a9 )
  {
    do
    {
      v10 = *v9;
      v9[v21 - a9] = *v9;
      ++v9;
    }
    while ( v10 );
  }
  return sub_10015930((int)&v12);
}
// 10021490: using guessed type char var_518[1300];

//----- (10021560) --------------------------------------------------------
signed int __cdecl sub_10021560(int (__cdecl *a1)(int))
{
  signed int result; // eax@1
  int (__cdecl **v2)(int); // ecx@1

  result = 0;
  v2 = &off_100473E4;
  do
  {
    if ( *v2 == a1 )
      break;
    ++result;
    v2 += 14;
  }
  while ( result < 1 );
  if ( result == 1 )
    result = -1;
  return result;
}
// 100473E4: using guessed type int (__cdecl *off_100473E4)(int);

//----- (10021590) --------------------------------------------------------
char *__cdecl sub_10021590(unsigned __int8 a1)
{
  char *result; // eax@2

  if ( (signed int)a1 >= 1 )
    result = (char *)&unk_10049AD1;
  else
    result = &aSkey[56 * a1];
  return result;
}

//----- (100215C0) --------------------------------------------------------
signed int __usercall sub_100215C0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_100A09D0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_1009FDD0[2 * (unsigned __int8)v68] ^ dword_100A01D0[2 * BYTE1(v65)] ^ dword_100A05D0[2 * (unsigned __int8)(v66 >> 16)] ^ dword_100A09D0[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_100A09D0[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_100A09D0[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_100A09D0[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_100A09D0[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_100A09D0[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_100A09D0[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_100A09D0[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_100A09D0[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_100A0DD0[(unsigned __int8)v57] ^ dword_100A19D0[v58 >> 24] ^ dword_100A11D0[BYTE1(v59)] ^ dword_100A15D0[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_100A0DD0[(unsigned __int8)v59] ^ dword_100A15D0[(unsigned __int8)(v58 >> 16)] ^ dword_100A19D0[v57 >> 24] ^ dword_100A11D0[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_100A0DD0[(unsigned __int8)v60] ^ dword_100A11D0[BYTE1(v58)] ^ dword_100A15D0[(unsigned __int8)(v57 >> 16)] ^ dword_100A19D0[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_100A0DD0[(unsigned __int8)v58] ^ dword_100A11D0[BYTE1(v57)] ^ dword_100A15D0[(unsigned __int8)(v59 >> 16)] ^ dword_100A19D0[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100A09D0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_100A09D0[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100A09D0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100A09D0[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100A09D0[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_1009FDD0[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100A01D0[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100A05D0[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100A09D0[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 100A0DD0: using guessed type int dword_100A0DD0[];
// 100A11D0: using guessed type int dword_100A11D0[];
// 100A15D0: using guessed type int dword_100A15D0[];
// 100A19D0: using guessed type int dword_100A19D0[];

//----- (10022670) --------------------------------------------------------
int __usercall sub_10022670@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_100215C0(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (100226D0) --------------------------------------------------------
signed int __usercall sub_100226D0@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_100A19D0[(unsigned __int8)v9] ^ dword_100A0DD0[BYTE1(v9)] ^ dword_100A11D0[(unsigned __int8)(v9 >> 16)] ^ dword_100A15D0[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_100A19D0[(unsigned __int8)v129] ^ dword_100A0DD0[BYTE1(v129)] ^ dword_100A11D0[(unsigned __int8)(v129 >> 16)] ^ dword_100A15D0[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_100A19D0[(unsigned __int8)v133] ^ dword_100A0DD0[BYTE1(v133)] ^ dword_100A11D0[(unsigned __int8)(v133 >> 16)] ^ dword_100A15D0[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_100A19D0[(unsigned __int8)v137] ^ dword_100A0DD0[BYTE1(v137)] ^ dword_100A11D0[(unsigned __int8)(v137 >> 16)] ^ dword_100A15D0[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_100A19D0[(unsigned __int8)v141] ^ dword_100A0DD0[BYTE1(v141)] ^ dword_100A11D0[(unsigned __int8)(v141 >> 16)] ^ dword_100A15D0[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_100A19D0[(unsigned __int8)v145] ^ dword_100A0DD0[BYTE1(v145)] ^ dword_100A11D0[(unsigned __int8)(v145 >> 16)] ^ dword_100A15D0[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_100A19D0[(unsigned __int8)v149] ^ dword_100A0DD0[BYTE1(v149)] ^ dword_100A11D0[(unsigned __int8)(v149 >> 16)] ^ dword_100A15D0[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_100A19D0[(unsigned __int8)v153] ^ dword_100A0DD0[BYTE1(v153)] ^ dword_100A11D0[(unsigned __int8)(v153 >> 16)] ^ dword_100A15D0[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_100A19D0[(unsigned __int8)v157] ^ dword_100A0DD0[BYTE1(v157)] ^ dword_100A11D0[(unsigned __int8)(v157 >> 16)] ^ dword_100A15D0[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_100A19D0[(unsigned __int8)v161] ^ dword_100A0DD0[BYTE1(v161)] ^ dword_100A11D0[(unsigned __int8)(v161 >> 16)] ^ dword_100A15D0[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_100A19D0[(unsigned __int8)v77] ^ dword_100A0DD0[BYTE1(v77)] ^ dword_100A11D0[(unsigned __int8)(v77 >> 16)] ^ dword_100A15D0[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_100A19D0[(unsigned __int8)v82] ^ dword_100A0DD0[BYTE1(v82)] ^ dword_100A11D0[(unsigned __int8)(v82 >> 16)] ^ dword_100A15D0[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_100A19D0[(unsigned __int8)v89] ^ dword_100A0DD0[BYTE1(v89)] ^ dword_100A11D0[(unsigned __int8)(v89 >> 16)] ^ dword_100A15D0[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_100A19D0[(unsigned __int8)v94] ^ dword_100A0DD0[BYTE1(v94)] ^ dword_100A11D0[(unsigned __int8)(v94 >> 16)] ^ dword_100A15D0[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_100A19D0[(unsigned __int8)v100] ^ dword_100A0DD0[BYTE1(v100)] ^ dword_100A11D0[(unsigned __int8)(v100 >> 16)] ^ dword_100A15D0[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_100A19D0[(unsigned __int8)v100] ^ dword_100A0DD0[BYTE1(v100)] ^ dword_100A11D0[(unsigned __int8)(v100 >> 16)] ^ dword_100A15D0[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_100A19D0[(unsigned __int8)v108] ^ dword_100A0DD0[BYTE1(v108)] ^ dword_100A11D0[(unsigned __int8)(v108 >> 16)] ^ dword_100A15D0[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_100A19D0[(unsigned __int8)v114] ^ dword_100A0DD0[BYTE1(v114)] ^ dword_100A11D0[(unsigned __int8)(v114 >> 16)] ^ dword_100A15D0[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_100A19D0[(unsigned __int8)v120] ^ dword_100A0DD0[BYTE1(v120)] ^ dword_100A11D0[(unsigned __int8)(v120 >> 16)] ^ dword_100A15D0[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_100A19D0[(unsigned __int8)v19] ^ dword_100A0DD0[BYTE1(v19)] ^ dword_100A11D0[(unsigned __int8)(v19 >> 16)] ^ dword_100A15D0[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_100A0DD0[(unsigned __int8)v23] ^ dword_100A11D0[BYTE1(v23)] ^ dword_100A15D0[(unsigned __int8)(v23 >> 16)] ^ dword_100A19D0[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_100A19D0[(unsigned __int8)v26] ^ dword_100A0DD0[BYTE1(v26)] ^ dword_100A11D0[(unsigned __int8)(v26 >> 16)] ^ dword_100A15D0[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_100A0DD0[(unsigned __int8)v31] ^ dword_100A11D0[BYTE1(v31)] ^ dword_100A15D0[(unsigned __int8)(v31 >> 16)] ^ dword_100A19D0[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_100A19D0[(unsigned __int8)v35] ^ dword_100A0DD0[BYTE1(v35)] ^ dword_100A11D0[(unsigned __int8)(v35 >> 16)] ^ dword_100A15D0[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_100A0DD0[(unsigned __int8)v41] ^ dword_100A11D0[BYTE1(v41)] ^ dword_100A15D0[(unsigned __int8)(v41 >> 16)] ^ dword_100A19D0[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_100A19D0[(unsigned __int8)v43] ^ dword_100A0DD0[BYTE1(v43)] ^ dword_100A11D0[(unsigned __int8)(v43 >> 16)] ^ dword_100A15D0[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_100A0DD0[(unsigned __int8)v47] ^ dword_100A11D0[BYTE1(v47)] ^ dword_100A15D0[(unsigned __int8)(v47 >> 16)] ^ dword_100A19D0[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_100A19D0[(unsigned __int8)v52] ^ dword_100A0DD0[BYTE1(v52)] ^ dword_100A11D0[(unsigned __int8)(v52 >> 16)] ^ dword_100A15D0[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_100A0DD0[(unsigned __int8)v58] ^ dword_100A11D0[BYTE1(v58)] ^ dword_100A15D0[(unsigned __int8)(v58 >> 16)] ^ dword_100A19D0[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_100A19D0[(unsigned __int8)v60] ^ dword_100A0DD0[BYTE1(v60)] ^ dword_100A11D0[(unsigned __int8)(v60 >> 16)] ^ dword_100A15D0[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_100A0DD0[(unsigned __int8)v66] ^ dword_100A11D0[BYTE1(v66)] ^ dword_100A15D0[(unsigned __int8)(v66 >> 16)] ^ dword_100A19D0[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_100A19D0[(unsigned __int8)v69] ^ dword_100A0DD0[BYTE1(v69)] ^ dword_100A11D0[(unsigned __int8)(v69 >> 16)] ^ dword_100A15D0[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 100A0DD0: using guessed type int dword_100A0DD0[];
// 100A11D0: using guessed type int dword_100A11D0[];
// 100A15D0: using guessed type int dword_100A15D0[];
// 100A19D0: using guessed type int dword_100A19D0[];

//----- (10023450) --------------------------------------------------------
void *__usercall sub_10023450@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (10023470) --------------------------------------------------------
unsigned int __cdecl sub_10023470(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_10003F60();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 10003FB0: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (100234D0) --------------------------------------------------------
int __usercall sub_100234D0@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = 271733878;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (10023510) --------------------------------------------------------
int __usercall sub_10023510@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (10024C30) --------------------------------------------------------
unsigned int __usercall sub_10024C30@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_100A1DF8[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_100A1E08[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_10023510(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_10023510(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 100A1DF8: using guessed type int dword_100A1DF8[];
// 100A1E08: using guessed type int dword_100A1E08[];

//----- (10024D30) --------------------------------------------------------
void *__usercall sub_10024D30@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  int v3; // ebp@1
  size_t v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (int)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*(_DWORD *)(v3 + 4);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy((void *)(v5 + v3 + 28), v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_10023510(v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy((void *)(v5 + v3 + 28), v9, v4);
}

//----- (10024DB0) --------------------------------------------------------
void *__usercall sub_10024DB0@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_10024C30(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_100234D0(v3 + 64);
    result = sub_10024D30(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_10024D30(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (10024E50) --------------------------------------------------------
int __usercall sub_10024E50@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_10024DB0(a1, 0, 0);
  sub_10024C30(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_100234D0(a1 + 64);
  sub_10024D30(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_10024D30(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_10024C30(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy((void *)a2, &v5, a3);
  return result;
}

//----- (10024F10) --------------------------------------------------------
int __usercall sub_10024F10@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_100234D0(a2 + 64);
    sub_10024D30(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_10024D30(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (10024F70) --------------------------------------------------------
int __usercall sub_10024F70@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  int v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = (int)&a1[v1];
    memcpy(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy(&v19[v6], a1, 64 - v6);
    sub_10023510((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *(_DWORD *)(v8 + 4) = v9;
    v12 = v18;
    *(_DWORD *)(v8 + 8) = result;
    v1 += 20;
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(v8 + 16) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 10024F70: using guessed type char var_40[64];

//----- (10025030) --------------------------------------------------------
int __usercall sub_10025030@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_10024F70((char *)a1);
  return sub_10024F70(v8);
}

//----- (100250F0) --------------------------------------------------------
char __cdecl sub_100250F0(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10024DB0(a3 + 296, a2, a1);
    sub_10022670(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10025140) --------------------------------------------------------
char __cdecl sub_10025140(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10022670(a3, (int)a1, a2);
    sub_10024DB0(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10025190) --------------------------------------------------------
bool __cdecl sub_10025190(int a1, int a2)
{
  if ( a2 )
    sub_10024E50(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (100251C0) --------------------------------------------------------
int __usercall sub_100251C0@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_10023450(&v24);
  sub_10024F10(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_10024DB0((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_10024DB0((int)&v23, v12, (char *)&v31);
          sub_10024E50((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 100251C0: using guessed type char var_14[16];

//----- (100253D0) --------------------------------------------------------
int __usercall sub_100253D0@<eax>(void *a1@<eax>, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1

  v2 = (int)a1;
  memset(a1, 0, 0x210u);
  *(_DWORD *)(v2 + 524) = a2;
  sub_10025030(v2);
  v3 = 20;
  do
  {
    sub_10024F70((char *)v2);
    --v3;
  }
  while ( v3 );
  return sub_10025030(v2);
}

//----- (10025420) --------------------------------------------------------
char *__cdecl sub_10025420(int a1, int a2)
{
  void *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = (char *)v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_10025030(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (100254B0) --------------------------------------------------------
signed int __cdecl sub_100254B0(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_100251C0(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_100226D0(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_10023450((void *)(a6 + 296));
      sub_10024F10(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 100254B0: using guessed type char var_40[8];
// 100254B0: using guessed type __int16 var_38[26];

//----- (100255E0) --------------------------------------------------------
bool __cdecl sub_100255E0(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_100253D0(&v4, (int)sub_10023470);
  if ( v2 )
    sub_10025420(a2, (int)&v4);
  return v2;
}

//----- (10025660) --------------------------------------------------------
BOOL __usercall sub_10025660@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_100A2610[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_100A2510[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_100A2410[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (10025700) --------------------------------------------------------
int __usercall sub_10025700@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (10025790) --------------------------------------------------------
unsigned int __fastcall sub_10025790(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (100257B0) --------------------------------------------------------
int __usercall sub_100257B0@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (10025840) --------------------------------------------------------
int __usercall sub_10025840@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_100A2610[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_100A2610[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_100A1E18[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_100A2710[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_100A2510[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_100A2410[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_100A1EA0[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_100A2788[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 100A1E18: using guessed type int dword_100A1E18[];
// 100A1EA0: using guessed type int dword_100A1EA0[];
// 100A2710: using guessed type int dword_100A2710[];
// 100A2788: using guessed type int dword_100A2788[];

//----- (10025CC0) --------------------------------------------------------
int __usercall sub_10025CC0@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_100257B0(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (10025D70) --------------------------------------------------------
void *__usercall sub_10025D70@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (10025DD0) --------------------------------------------------------
int __usercall sub_10025DD0@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (10025FA0) --------------------------------------------------------
signed int __usercall sub_10025FA0@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_10025790(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (10026020) --------------------------------------------------------
_WORD *__fastcall sub_10026020(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (10026090) --------------------------------------------------------
unsigned int __usercall sub_10026090@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (10026240) --------------------------------------------------------
unsigned int __usercall sub_10026240@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (10026310) --------------------------------------------------------
int __usercall sub_10026310@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (100263C0) --------------------------------------------------------
int __usercall sub_100263C0@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (10026400) --------------------------------------------------------
unsigned int __usercall sub_10026400@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_100281D0(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10026460) --------------------------------------------------------
signed int __usercall sub_10026460@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (10026540) --------------------------------------------------------
int __usercall sub_10026540@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (10026AE0) --------------------------------------------------------
int __usercall sub_10026AE0@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_10025700(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_10025700(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_10025700(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (10026D20) --------------------------------------------------------
int __usercall sub_10026D20@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_10025CC0(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_10025CC0(a1, a3, a4);
  }
  return result;
}

//----- (10026DC0) --------------------------------------------------------
signed int __usercall sub_10026DC0@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_10026310(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_10026310(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_10026310(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_10025DD0(a1, a2);
  return sub_10025FA0(a1, v16, v5);
}

//----- (10026FA0) --------------------------------------------------------
unsigned int __usercall sub_10026FA0@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_10026400(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (100270E0) --------------------------------------------------------
int __usercall sub_100270E0@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_100A1E8C[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_10026540(a1, a1 + 2936, a2 - 1);
  return sub_10026540(v24, v24 + 5228, a3 - 1);
}

//----- (10027390) --------------------------------------------------------
signed int __cdecl sub_10027390(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_100263C0(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_100263C0(v9, *(_WORD *)(a1 + 30));
      sub_100263C0(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_100281D0(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_10025D70(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_100A2808 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_10026AE0(v2);
    }
    else
    {
      sub_10026D20(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_10025D70(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_100263C0(v2, *(_WORD *)(a1 + 30));
    sub_100263C0(v13, *(_WORD *)(a1 + 28));
    sub_10025D70(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100A2808: using guessed type int (__cdecl *off_100A2808)(int, int);

//----- (10027650) --------------------------------------------------------
signed int __usercall sub_10027650@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_10026460(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_10026460(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_10026DC0(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_100A1E8C[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100A1E8B[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100A1E8A[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100A1E89[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (10027720) --------------------------------------------------------
_WORD *__usercall sub_10027720@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_10026DC0(a2, a2 + 5628);
  sub_10026DC0(v4, v4 + 5640);
  v8 = sub_10027650(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_10026D20(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_10025840(v4, (int)&unk_100A1F18, (int)&unk_100A2398);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_100270E0(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_10025840(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_10026020(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_100257B0(v4);
  return result;
}

//----- (10027940) --------------------------------------------------------
signed int __cdecl sub_10027940(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10026FA0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_10026090(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_10026240(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_10025660(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_10025660(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_10027720(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10025D70(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_10027720(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10025D70(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (10027C50) --------------------------------------------------------
signed int __cdecl sub_10027C50(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10026FA0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_10026090(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_10026240(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_10025660(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_10027720(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_10025D70(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_10025660(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_10027720(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_10025D70(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_10025660(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_10027720(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10025D70(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (10028060) --------------------------------------------------------
signed int __cdecl sub_10028060(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_10026FA0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_10027720(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_10025D70(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_10027720(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10025D70(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_10027720(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10025D70(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (100281D0) --------------------------------------------------------
int __cdecl sub_100281D0(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  int result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = v4 | (v5 << 16);
  }
  else
  {
    result = (int)(a2 + 1);
  }
  return result;
}

//----- (100282D0) --------------------------------------------------------
signed int __cdecl sub_100282D0(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (100282F0) --------------------------------------------------------
signed int __usercall sub_100282F0@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 100282F0: using guessed type int var_78[14];
// 100282F0: using guessed type int var_3C[15];

//----- (10028790) --------------------------------------------------------
int (__cdecl *__usercall sub_10028790@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (100287E0) --------------------------------------------------------
int __usercall sub_100287E0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (10028800) --------------------------------------------------------
signed int __cdecl sub_10028800(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_100A29F0[a1];
  v51 = dword_100A29F0[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_100A29F0[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_100A29F0[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_100A29F0[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_100A29F0[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 100A29F0: using guessed type int dword_100A29F0[];

//----- (10028BB0) --------------------------------------------------------
int __usercall sub_10028BB0@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (10028CF0) --------------------------------------------------------
signed int __usercall sub_10028CF0@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_100282F0(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (10028D40) --------------------------------------------------------
signed int __usercall sub_10028D40@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_100282F0(a7, a6, a4, 257, (int)&unk_100A2A88, (int)&unk_100A2B08, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_100282F0(a8, &a6[a4], a5, 0, (int)&unk_100A2B88, (int)&unk_100A2C00, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10028DE0) --------------------------------------------------------
int __usercall sub_10028DE0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_100A2C78;
  *a4 = &unk_100A3C78;
  return 0;
}

//----- (10028E00) --------------------------------------------------------
signed int __cdecl sub_10028E00(int a1)
{
  signed int result; // eax@2
  int v2; // ecx@3
  int v3; // esi@3

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    v3 = *(_DWORD *)(v2 + 20);
    *(_BYTE *)v2 = *(_DWORD *)(v2 + 12) != 0 ? 7 : 0;
    sub_10028790(0, v3, a1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10028E10) --------------------------------------------------------
int __usercall sub_10028E10@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_10028800(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100A29F0[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_100A29F0[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100A29F0[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_100A29F0[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_10028BB0(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_10028BB0(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_10028BB0(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_10028BB0(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 100A29F0: using guessed type int dword_100A29F0[];

//----- (100294B0) --------------------------------------------------------
int __usercall sub_100294B0@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_10028DE0(&v67, &v69, &v66, &v68);
          sub_100287E0(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_10028BB0(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_100A2A38[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_100A2A38[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_10028CF0(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_10028D40(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_100287E0(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_10028E10(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_10028BB0(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_10028BB0(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_10028BB0(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_100A29F0[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_100A29F0[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_10028BB0(v7, v3, v58);
}
// 100A29F0: using guessed type int dword_100A29F0[];
// 100A2A38: using guessed type int dword_100A2A38[];

//----- (10029E90) --------------------------------------------------------
signed int __usercall sub_10029E90@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_100294B0(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_10028790((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (1002A1C0) --------------------------------------------------------
signed int __cdecl sub_1002A1C0(int a1, int a2)
{
  return sub_10029E90(a1, a2);
}

//----- (1002A1E0) --------------------------------------------------------
int __cdecl sub_1002A1E0(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 100425C0: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (1002A250) --------------------------------------------------------
bool __cdecl sub_1002A250(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_10005690(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_100A4A28[(unsigned __int8)v4](v3) )
    {
      sub_1002A1E0((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_10008EB0(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_10007FE0(2) )
    result = 0;
  else
    result = sub_10008B20(2, v5, a2) == 1 && !sub_100170C0(a2);
  return result;
}
// 100A4A28: using guessed type int (__cdecl *off_100A4A28[3])(char);

//----- (1002A310) --------------------------------------------------------
char __cdecl sub_1002A310(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_1002A250(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_10008E90(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (1002A3D0) --------------------------------------------------------
int __cdecl sub_1002A3D0(char a1)
{
  return sub_10008CF0(&a1, 1u, (int)&unk_100A4F88, 8, 2, 2);
}

//----- (1002A3F0) --------------------------------------------------------
BOOL __cdecl sub_1002A3F0(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_10020900(a1);
  return sub_10008B20(0, 604, a2) && sub_100084F0(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (1002A450) --------------------------------------------------------
int __usercall sub_1002A450@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_1002A3D0(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_100A4F8C[2 * v1];
  return result;
}
// 100A4F8C: using guessed type int dword_100A4F8C[];

//----- (1002A480) --------------------------------------------------------
BOOL __cdecl sub_1002A480(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1002A450(a1);
  return sub_10004270(v2, a2, 16) == 0;
}

//----- (1002A4B0) --------------------------------------------------------
int __cdecl sub_1002A4B0(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_1002A480(a1, (int)a5);
  else
    result = sub_1002A3F0(a1, a5);
  return result;
}

//----- (1002A4E0) --------------------------------------------------------
char __cdecl sub_1002A4E0(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_10008B50(1, 1947, a1, (int)&v3);
}

//----- (1002A500) --------------------------------------------------------
BOOL __cdecl sub_1002A500(int a1)
{
  return sub_10004270(6792, a1, 284) == 0;
}

//----- (1002A520) --------------------------------------------------------
char __cdecl sub_1002A520(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_1002A500((int)a5);
  else
    result = sub_1002A4E0(a5);
  return result;
}

//----- (1002A550) --------------------------------------------------------
bool __cdecl sub_1002A550(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_10004270((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (1002A590) --------------------------------------------------------
signed int __usercall sub_1002A590@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (1002A5B0) --------------------------------------------------------
bool __cdecl sub_1002A5B0(char a1, void *a2)
{
  int v2; // esi@1
  bool result; // al@5
  void *v4; // ecx@6
  int v5; // [sp+Ch] [bp-28h]@4
  char v6; // [sp+10h] [bp-24h]@2
  int v7; // [sp+24h] [bp-10h]@3
  __int16 v8; // [sp+28h] [bp-Ch]@8
  int v9; // [sp+2Ch] [bp-8h]@8

  v2 = sub_1002A590(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2
    && sub_100084F0(1, 0x6ACu, (int)&v6)
    && v7 == v2
    && sub_10008B50(1, 1708, a2, (int)&v5) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_1002A550(a1, a2);
  }
  else
  {
    v9 = sub_10005D40(v4);
    v8 = 1708;
    sub_10008650(1, 0, &v8, 0, 8, 1);
    sub_10008790(1, 0, v2);
    result = 0;
  }
  return result;
}
// 100047A0: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 100047C0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1002A6A0) --------------------------------------------------------
bool __cdecl sub_1002A6A0(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_1002A550(a1, a5);
  else
    result = sub_1002A5B0(a1, a5);
  return result;
}

//----- (1002A6D0) --------------------------------------------------------
char __cdecl sub_1002A6D0(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_1016C9A8, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10003DC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_10013FF0(a1, (int)byte_1016C9A8);
    v3 = 4 * a2 - 64;
    v4 = byte_1016C9A9[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_1016C9A8[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (1002A770) --------------------------------------------------------
bool __cdecl sub_1002A770(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_1016C9A8, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10003DC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_10013FF0(a1, (int)byte_1016C9A8);
    v3 = (char *)&unk_1016CA48 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (1002A7F0) --------------------------------------------------------
char __cdecl sub_1002A7F0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_1016C9A8, 0, 0x890u);
  sub_10013FF0(a1, (int)byte_1016C9A8);
  if ( a2 > 0x10u )
  {
    sub_10003DC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_1016CD18[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_1016CD1C[2 * a2];
    result = 1;
  }
  return result;
}
// 1016CD18: using guessed type int dword_1016CD18[];
// 1016CD1C: using guessed type int dword_1016CD1C[];

//----- (1002A860) --------------------------------------------------------
char __cdecl sub_1002A860(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_10008B20(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_10008B20(0, 572, a2);
    }
    else
    {
      sub_10003DC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_10008B20(0, 226, a2);
  }
  return result;
}

//----- (1002A8E0) --------------------------------------------------------
char __cdecl sub_1002A8E0(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_1016C9A8, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10003DC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1002A860(a1, byte_1016C9A8);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_1016C9A9[v4];
    *(_BYTE *)a3 = byte_1016C9A8[v4];
  }
  return result;
}

//----- (1002A960) --------------------------------------------------------
char __cdecl sub_1002A960(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_1016C9A8, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10003DC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1002A860(a1, byte_1016C9A8);
    v4 = (char *)&unk_1016CA48 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (1002A9E0) --------------------------------------------------------
char __cdecl sub_1002A9E0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_1016C9A8, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_1002A860(a1, byte_1016C9A8);
    *(_DWORD *)a3 = dword_1016CD18[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_1016CD1C[2 * a2];
  }
  else
  {
    sub_10003DC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 1016CD18: using guessed type int dword_1016CD18[];
// 1016CD1C: using guessed type int dword_1016CD1C[];

//----- (1002AA50) --------------------------------------------------------
char __cdecl sub_1002AA50(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1002BA10(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_1002A7F0(v6, *a4, a5);
    else
      result = sub_1002A9E0(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_1002A6D0(v6, *a4, a5);
    else
      result = sub_1002A8E0(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_10003DC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_1002A770(v6, *a4, a5);
    else
      result = sub_1002A960(v6, *a4, a5);
  }
  return result;
}

//----- (1002AB60) --------------------------------------------------------
char __cdecl sub_1002AB60(char a1, void *a2)
{
  return sub_10008B20(6, (unsigned __int16)word_100A5FC2[8 * (unsigned __int8)a1], a2);
}
// 100A5FC2: using guessed type __int16 word_100A5FC2[];

//----- (1002AB80) --------------------------------------------------------
bool __cdecl sub_1002AB80(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_10004270(dword_100A5FC8[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 100A5FC8: using guessed type int dword_100A5FC8[];

//----- (1002ABC0) --------------------------------------------------------
char __cdecl sub_1002ABC0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1002BA50(a1);
  if ( a2 )
    result = sub_1002AB80(v6, (char *)a5);
  else
    result = sub_1002AB60(v6, a5);
  return result;
}

//----- (1002AC00) --------------------------------------------------------
BOOL sub_1002AC00()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_1002A250(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (1002AC60) --------------------------------------------------------
char __cdecl sub_1002AC60(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_10008B20(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_1002AC00() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_10014EC0((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (1002AD50) --------------------------------------------------------
BOOL __cdecl sub_1002AD50(int a1, int a2)
{
  return sub_10004270(6200, a2, 60) == 0;
}

//----- (1002AD70) --------------------------------------------------------
char __cdecl sub_1002AD70(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1002AD50(a1, (int)a5);
  }
  else
  {
    result = sub_1002AC60(a1, a5);
  }
  return result;
}

//----- (1002ADB0) --------------------------------------------------------
char __cdecl sub_1002ADB0(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_10008B20(2, 284, &v6) || sub_10015090((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (1002AE60) --------------------------------------------------------
BOOL __cdecl sub_1002AE60(int a1, int a2)
{
  return sub_10004270(6169, a2, 40) == 0;
}

//----- (1002AE80) --------------------------------------------------------
char __cdecl sub_1002AE80(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1002AE60(a1, a5);
  }
  else
  {
    result = sub_1002ADB0(a1, a5);
  }
  return result;
}

//----- (1002AEC0) --------------------------------------------------------
char __cdecl sub_1002AEC0(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_10008B20(2, 363, a1);
}

//----- (1002AEE0) --------------------------------------------------------
char __cdecl sub_1002AEE0(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_10004270(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (1002B030) --------------------------------------------------------
char __cdecl sub_1002B030(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_1002AEE0(a5);
      else
        result = sub_1002AEC0(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_1002AEE0(&unk_1016D238);
      else
        v7 = sub_1002AEC0(&unk_1016D238);
      v8 = v7;
      memcpy(a5, (char *)&unk_1016D238 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_1002AEE0(&unk_1016D238);
      else
        v9 = sub_1002AEC0(&unk_1016D238);
      v10 = v9;
      memcpy(a5, (char *)&unk_10170140 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_1002AEE0(&unk_1016D238);
      else
        v11 = sub_1002AEC0(&unk_1016D238);
      v12 = v11;
      memcpy(a5, (char *)&unk_10170640 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_1002AEE0(&unk_1016D238);
      else
        v13 = sub_1002AEC0(&unk_1016D238);
      v14 = v13;
      memcpy(a5, &unk_101706E8, a6);
      result = v14;
      break;
    default:
      sub_10003DC0("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1002B1D0) --------------------------------------------------------
char __cdecl sub_1002B1D0(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_10003DC0("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1002B210) --------------------------------------------------------
__int16 __usercall sub_1002B210@<ax>(unsigned __int8 a1@<al>)
{
  return word_100A8B78[a1];
}
// 100A8B78: using guessed type __int16 word_100A8B78[];

//----- (1002B220) --------------------------------------------------------
char __cdecl sub_1002B220(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_1002B210(a1);
    if ( sub_10008B50(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (1002B2F0) --------------------------------------------------------
char __cdecl sub_1002B2F0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_1002B1D0(a1);
  if ( a3 != 11 )
  {
    sub_10003DC0("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_1002B220(v7, a5);
  }
  else
  {
    sub_10003DC0("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1002B370) --------------------------------------------------------
char __cdecl sub_1002B370(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1002BDF0(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1002BBF0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1002BC70(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1002BCF0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_1002BD70(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (1002B480) --------------------------------------------------------
int __cdecl sub_1002B480(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10008CF0(&a1, 1u, (int)&unk_100A93B0, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_10003DC0("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_100A93B4[2 * v1];
  }
  return result;
}
// 100A93B4: using guessed type int dword_100A93B4[];

//----- (1002B4D0) --------------------------------------------------------
char __cdecl sub_1002B4D0(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_10003DC0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_10008B50(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_10008B50(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_10015570((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_10170710, (char *)&v6 + 1, 0x20u);
      byte_10170708 = 1;
      byte_10170709 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_10170730, (char *)&v6 + 1, 0x20u);
    byte_10170709 = 1;
    byte_1017070A = 1;
    return result;
  }
  return 0;
}
// 10170708: using guessed type char byte_10170708;
// 10170709: using guessed type char byte_10170709;
// 1017070A: using guessed type char byte_1017070A;

//----- (1002B600) --------------------------------------------------------
char __cdecl sub_1002B600(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_10013FA0(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_10003DC0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (1002B680) --------------------------------------------------------
bool __cdecl sub_1002B680(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_10170708 == 0;
    qmemcpy(a1, &unk_10170710, 0x40u);
    result = !v1 && byte_1017070A;
  }
  else
  {
    sub_10003DC0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 10170708: using guessed type char byte_10170708;
// 1017070A: using guessed type char byte_1017070A;

//----- (1002B6D0) --------------------------------------------------------
char __cdecl sub_1002B6D0(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_10003DC0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_10006010(15);
    v3 = 555;
  }
  else
  {
    result = sub_10006010(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_10170709 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_10008650(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 100047C0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10170709: using guessed type char byte_10170709;

//----- (1002B7B0) --------------------------------------------------------
__int16 __usercall sub_1002B7B0@<ax>(unsigned __int8 a1@<al>)
{
  return word_100A94D8[a1];
}
// 100A94D8: using guessed type __int16 word_100A94D8[];

//----- (1002B7C0) --------------------------------------------------------
char __cdecl sub_1002B7C0(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_1002B7B0(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_10008650(1, v3, &v5, 1, HIWORD(v5) + 4, 1);
  return sub_10008790(1, v3, 0xFFFFFFF);
}

//----- (1002B850) --------------------------------------------------------
char __cdecl sub_1002B850(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_10003DC0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_10170709 != 0 ? 25 : 11;
      sub_1002B7C0(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_1002B7C0(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 10170709: using guessed type char byte_10170709;

//----- (1002B910) --------------------------------------------------------
bool __cdecl sub_1002B910(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_1002B600(a1, (int)a5);
    return 1;
  }
  if ( byte_10170709 )
  {
    if ( sub_1002B4D0(a1, &v6, 1) )
    {
LABEL_14:
      byte_1017070B = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_1017070B >= 5u )
    {
      byte_10170708 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_1002B4D0(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_1017070B >= 5u )
    {
      byte_1017070A = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_1002B600(a1, (int)&v6);
    sub_1002B6D0(a1, (int)&v6);
  }
  sub_1002B850(a1, 11);
  return sub_1002B680(a5);
}
// 100047C0: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10170708: using guessed type char byte_10170708;
// 10170709: using guessed type char byte_10170709;
// 1017070A: using guessed type char byte_1017070A;
// 1017070B: using guessed type char byte_1017070B;

//----- (1002BA10) --------------------------------------------------------
char __cdecl sub_1002BA10(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_10003DC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (1002BA50) --------------------------------------------------------
char __cdecl sub_1002BA50(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002BA70) --------------------------------------------------------
int __cdecl sub_1002BA70(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_100ABAE4[2 * sub_10008CF0(&a1, 1u, (int)&unk_100ABAE0, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_100ABB24[2 * sub_10008CF0(&a2, 1u, (int)&unk_100ABB20, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_100ABB54[2 * sub_10008CF0(&a2, 1u, (int)&unk_100ABB50, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_100ABAFC[2 * sub_10008CF0(&a2, 1u, (int)&unk_100ABAF8, 8, 5, 5)];
  }
  return result;
}
// 100ABAE4: using guessed type int dword_100ABAE4[];
// 100ABAFC: using guessed type int dword_100ABAFC[];
// 100ABB24: using guessed type int dword_100ABB24[];
// 100ABB54: using guessed type int dword_100ABB54[];

//----- (1002BB20) --------------------------------------------------------
bool __usercall sub_1002BB20@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_100B0267[44 * a1] - (unsigned __int8)byte_100B0262[44 * a1];
}

//----- (1002BB50) --------------------------------------------------------
char __usercall sub_1002BB50@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_1002BB20(a1, a4, a5) )
  {
    v6 = a3
       + sub_1002BA70(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_100B0262[44 * a1] - (unsigned __int8)byte_100B0267[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_1002BA70(a1, a4);
    memcpy(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (1002BBF0) --------------------------------------------------------
char __cdecl sub_1002BBF0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002B480(a1);
  sub_10004290(v5, (int)&v7, 3684);
  return sub_1002BB50(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (1002BC70) --------------------------------------------------------
char __cdecl sub_1002BC70(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002B480(a1);
  sub_10004290(v5, (int)&v7, 3684);
  return sub_1002BB50(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (1002BCF0) --------------------------------------------------------
char __cdecl sub_1002BCF0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002B480(a1);
  sub_10004290(v5, (int)&v7, 3684);
  return sub_1002BB50(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (1002BD70) --------------------------------------------------------
char __cdecl sub_1002BD70(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002B480(a1);
  sub_10004290(v5, (int)&v7, 3684);
  return sub_1002BB50(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (1002BDF0) --------------------------------------------------------
char __cdecl sub_1002BDF0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_10003DC0("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1002BE90) --------------------------------------------------------
int __cdecl sub_1002BE90(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@17

  if ( a2 < 0 )
    a2 = 0;
  if ( a3 < 0 )
    a3 = 0;
  if ( a4 < 1 )
    a4 = 1;
  if ( a5 < 1 )
    a5 = 1;
  if ( a2 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a2 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - 1;
  if ( a4 + a2 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a4 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - a2;
  if ( a3 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a3 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - 1;
  if ( a5 + a3 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a5 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - a3;
  *(_WORD *)(a1 + 26) = a2;
  HIWORD(result) = HIWORD(a1);
  *(_WORD *)(a1 + 30) = a4;
  LOWORD(result) = a3;
  *(_WORD *)(a1 + 24) = a3;
  *(_WORD *)(a1 + 28) = a5;
  return result;
}

//----- (1002BFA0) --------------------------------------------------------
unsigned int __cdecl sub_1002BFA0(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  unsigned int result; // eax@2
  int v9; // [sp+8h] [bp+8h]@1

  v9 = sub_1002CAE0(a1, a2, a3, a4, a5, a6, a7, a8);
  if ( *(_BYTE *)(*(_DWORD *)(v9 + 52) + 8) == 8 )
  {
    if ( *(_DWORD *)(v9 + 68) )
    {
      if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 1 )
      {
        *(_WORD *)(v9 + 38) = **(_WORD **)(v9 + 68);
        *(_WORD *)(v9 + 36) = *(_WORD *)(*(_DWORD *)(v9 + 68) + 2);
        result = sub_1002C080(v9);
      }
      else
      {
        result = sub_1002C5B0(v9);
      }
    }
    else if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 8 )
    {
      result = sub_1002C3D0(v9);
    }
    else
    {
      result = sub_1002C5B0(v9);
    }
  }
  else
  {
    result = sub_1002C5B0(v9);
  }
  return result;
}

//----- (1002C080) --------------------------------------------------------
int __cdecl sub_1002C080(int a1)
{
  int result; // eax@1
  int v2; // ST1C_4@10
  int v3; // [sp+0h] [bp-44h]@3
  unsigned int v4; // [sp+4h] [bp-40h]@5
  unsigned int v5; // [sp+4h] [bp-40h]@9
  unsigned __int16 v6; // [sp+8h] [bp-3Ch]@3
  int v7; // [sp+Ch] [bp-38h]@5
  unsigned __int16 v8; // [sp+10h] [bp-34h]@3
  unsigned __int16 v9; // [sp+14h] [bp-30h]@2
  signed int v10; // [sp+1Ch] [bp-28h]@9
  unsigned int *v11; // [sp+20h] [bp-24h]@9
  int v12; // [sp+24h] [bp-20h]@11
  int v13; // [sp+28h] [bp-1Ch]@9
  unsigned int v14; // [sp+2Ch] [bp-18h]@9
  unsigned __int16 v15; // [sp+30h] [bp-14h]@2
  unsigned int *v16; // [sp+34h] [bp-10h]@3
  int v17; // [sp+38h] [bp-Ch]@4
  unsigned int v18; // [sp+3Ch] [bp-8h]@2
  unsigned __int16 v19; // [sp+40h] [bp-4h]@2
  int v20; // [sp+4Ch] [bp+8h]@1

  result = sub_1002E080(a1);
  v20 = result;
  if ( result )
  {
    v19 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v18 = ((unsigned int)*(_WORD *)(result + 14) >> 3)
        + *(_WORD *)(result + 12) * *(_WORD *)(*(_DWORD *)(result + 56) + 10)
        + **(_DWORD **)(result + 56);
    v9 = 8 * (*(_WORD *)(result + 14) >> 3) - *(_WORD *)(result + 14) + 8;
    v15 = *(_WORD *)(*(_DWORD *)(result + 52) + 10);
    if ( !(*(_WORD *)(*(_DWORD *)(result + 52) + 10) << 30) )
    {
      v16 = (unsigned int *)(**(_DWORD **)(result + 52)
                           + *(_WORD *)(result + 8) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                           + 4 * (8 * *(_WORD *)(result + 10) >> 5));
      v8 = 32 * (8 * *(_WORD *)(result + 10) >> 5) - 8 * *(_WORD *)(result + 10) + 32;
      v3 = *(_WORD *)(result + 16);
      v6 = *(_WORD *)(result + 18);
      do
      {
        v17 = v9;
        if ( v18 << 31 )
        {
          v4 = *(_BYTE *)v18;
          v7 = v18 + 1;
        }
        else if ( v18 << 30 )
        {
          v4 = *(_WORD *)v18;
          v7 = v18 + 2;
          v17 = v9 + 8;
        }
        else
        {
          v4 = *(_DWORD *)v18;
          v7 = v18 + 4;
          v17 = v9 + 24;
        }
        v5 = (v4 >> ((-v9 + 8) & 0x1F)) | (v4 << (32 - ((-v9 + 8) & 0x1F)));
        v10 = v8;
        v11 = v16;
        v14 = (*v16 >> ((32 - v8) & 0x1F)) | (*v16 << (32 - ((32 - v8) & 0x1F)));
        v13 = v6;
        do
        {
          v2 = 2 * v5 & 3;
          v5 >>= 1;
          if ( v2 )
            v12 = *(_WORD *)(v20 + 38);
          else
            v12 = *(_WORD *)(v20 + 36);
          if ( (signed __int16)v12 >= 0 )
            v14 = (v14 >> 8) | (v12 << 24);
          else
            v14 = (v14 >> 8) | (v14 << 24);
          if ( --v13 )
          {
            v10 -= 8;
            if ( !v10 )
            {
              *v11 = v14;
              ++v11;
              v10 = 32;
              v14 = *v11;
            }
            if ( !--v17 )
            {
              if ( v7 << 30 )
              {
                v17 = 16;
                v5 = *(_WORD *)v7;
                v7 += 2;
              }
              else
              {
                v17 = 32;
                v5 = *(_DWORD *)v7;
                v7 += 4;
              }
            }
          }
        }
        while ( v13 );
        *v11 = (v14 >> ((v10 - 8) & 0x1F)) | (v14 << (32 - ((v10 - 8) & 0x1F)));
        v18 += v19;
        result = (int)v16 + v15;
        v16 = (unsigned int *)((char *)v16 + v15);
        --v3;
      }
      while ( v3 );
    }
  }
  return result;
}

//----- (1002C3D0) --------------------------------------------------------
int __cdecl sub_1002C3D0(int a1)
{
  int result; // eax@1
  signed int v2; // [sp+4h] [bp-30h]@16
  int v3; // [sp+8h] [bp-2Ch]@9
  char *v4; // [sp+Ch] [bp-28h]@4
  _BYTE *v5; // [sp+Ch] [bp-28h]@10
  _BYTE *v6; // [sp+Ch] [bp-28h]@12
  _BYTE *v7; // [sp+Ch] [bp-28h]@14
  char *v8; // [sp+10h] [bp-24h]@4
  _BYTE *v9; // [sp+10h] [bp-24h]@10
  _BYTE *v10; // [sp+10h] [bp-24h]@12
  _BYTE *v11; // [sp+10h] [bp-24h]@14
  unsigned int v12; // [sp+14h] [bp-20h]@4
  int v13; // [sp+14h] [bp-20h]@10
  int v14; // [sp+14h] [bp-20h]@12
  int v15; // [sp+18h] [bp-1Ch]@2
  int v16; // [sp+1Ch] [bp-18h]@2
  int v17; // [sp+20h] [bp-14h]@2
  size_t v18; // [sp+24h] [bp-10h]@2
  char *v19; // [sp+28h] [bp-Ch]@2
  int v20; // [sp+2Ch] [bp-8h]@2
  char *v21; // [sp+30h] [bp-4h]@2
  _BYTE *v22; // [sp+3Ch] [bp+8h]@1

  result = sub_1002E080(a1);
  v22 = (_BYTE *)result;
  if ( result )
  {
    v18 = *(_WORD *)(result + 18);
    v15 = *(_WORD *)(result + 16);
    v17 = *(_WORD *)(*(_DWORD *)(result + 52) + 10);
    v16 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v21 = (char *)(*(_WORD *)(result + 14) + v16 * *(_WORD *)(result + 12) + **(_DWORD **)(result + 56));
    v19 = (char *)(*(_WORD *)(result + 10) + v17 * *(_WORD *)(result + 8) + **(_DWORD **)(result + 52));
    v20 = 0;
    do
    {
      if ( v20 )
        goto LABEL_26;
      v12 = v18;
      v8 = v21;
      v4 = v19;
      while ( v12 >= 4 )
      {
        if ( *(_DWORD *)v4 != *(_DWORD *)v8 )
          goto LABEL_9;
        v12 -= 4;
        v8 += 4;
        v4 += 4;
      }
      if ( !v12 )
      {
LABEL_16:
        v2 = 0;
        goto LABEL_19;
      }
LABEL_9:
      v3 = (unsigned __int8)*v4 - (unsigned __int8)*v8;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v8 )
      {
        v13 = v12 - 1;
        v9 = v8 + 1;
        v5 = v4 + 1;
        if ( !v13 )
          goto LABEL_16;
        v3 = *v5 - *v9;
        if ( *v5 == *v9 )
        {
          v14 = v13 - 1;
          v10 = v9 + 1;
          v6 = v5 + 1;
          if ( !v14 )
            goto LABEL_16;
          v3 = *v6 - *v10;
          if ( *v6 == *v10 )
          {
            v11 = v10 + 1;
            v7 = v6 + 1;
            if ( v14 == 1 )
              goto LABEL_16;
            v3 = *v7 - *v11;
            if ( *v7 == *v11 )
              goto LABEL_16;
          }
        }
      }
      v2 = 1;
      if ( v3 <= 0 )
        v2 = -1;
LABEL_19:
      if ( v2 )
      {
LABEL_26:
        ++v20;
        memcpy(v19, v21, v18);
      }
      v21 += v16;
      v19 += v17;
      result = v15-- - 1;
    }
    while ( v15 );
    if ( !v20 )
      *v22 = 0;
  }
  return result;
}

//----- (1002C5B0) --------------------------------------------------------
unsigned int __cdecl sub_1002C5B0(int a1)
{
  unsigned int result; // eax@1
  unsigned int v2; // ST08_4@5
  unsigned int v3; // ST28_4@6
  int v4; // ST28_4@13
  int v5; // [sp+0h] [bp-50h]@4
  unsigned int v6; // [sp+4h] [bp-4Ch]@5
  int v7; // [sp+8h] [bp-48h]@4
  unsigned __int16 v8; // [sp+Ch] [bp-44h]@4
  int *v9; // [sp+10h] [bp-40h]@5
  unsigned __int16 v10; // [sp+14h] [bp-3Ch]@4
  int v11; // [sp+18h] [bp-38h]@3
  int v12; // [sp+18h] [bp-38h]@5
  unsigned __int16 v13; // [sp+20h] [bp-30h]@3
  unsigned int *v14; // [sp+2Ch] [bp-24h]@5
  signed int v15; // [sp+30h] [bp-20h]@13
  int v16; // [sp+34h] [bp-1Ch]@5
  unsigned int v17; // [sp+38h] [bp-18h]@5
  unsigned __int16 v18; // [sp+3Ch] [bp-14h]@3
  unsigned int *v19; // [sp+40h] [bp-10h]@4
  int v20; // [sp+48h] [bp-8h]@2
  int v21; // [sp+48h] [bp-8h]@3
  unsigned __int16 v22; // [sp+4Ch] [bp-4h]@2
  unsigned int v23; // [sp+58h] [bp+8h]@1

  result = sub_1002E080(a1);
  v23 = result;
  if ( result )
  {
    v22 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v20 = **(_DWORD **)(result + 56) + *(_WORD *)(result + 12) * *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    result = *(_DWORD *)(result + 56);
    if ( (unsigned int)*(_BYTE *)(result + 8) < 9 )
    {
      v21 = v20 + 4 * ((signed int)*(_WORD *)(v23 + 14) << byte_100B3B64[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)] >> 5);
      v13 = 32 - ((*(_WORD *)(v23 + 14) << byte_100B3B64[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)]) & 0x1F);
      v18 = *(_WORD *)(*(_DWORD *)(v23 + 52) + 10);
      v11 = *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8) | (*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8) << 8);
      result = *(_BYTE *)(*(_DWORD *)(v23 + 52) + 8);
      if ( result < 9 )
      {
        v19 = (unsigned int *)(**(_DWORD **)(v23 + 52)
                             + *(_WORD *)(v23 + 8) * *(_WORD *)(*(_DWORD *)(v23 + 52) + 10)
                             + 4
                             * ((signed int)*(_WORD *)(v23 + 10) << byte_100B3B64[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)] >> 5));
        v10 = 32 - ((*(_WORD *)(v23 + 10) << byte_100B3B64[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)]) & 0x1F);
        v8 = *(_WORD *)(v23 + 18);
        v5 = *(_WORD *)(v23 + 16);
        v7 = (1 << *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)) - 1;
        do
        {
          v2 = *(_DWORD *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5));
          v9 = (int *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 4);
          v6 = (v2 >> (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)) | (v2 << (32 - (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)));
          v14 = v19;
          v17 = (*v19 >> (31 * v10 & 0x1F)) | (*v19 << (32 - (31 * v10 & 0x1F)));
          v12 = (unsigned __int16)v11 | (((v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 127) | ((v10 + 127) << 8)) << 16);
          v16 = v8;
          if ( *(_DWORD *)(v23 + 68) )
          {
            do
            {
              v4 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v15 = *(_WORD *)(*(_DWORD *)(v23 + 68) + 2 * v4);
              if ( (signed __int16)v15 >= 0 )
                v17 = (v15 >> (BYTE1(v12) & 0x1F)) | (v15 << (32 - (BYTE1(v12) & 0x1F))) | ((unsigned __int64)v17 >> SBYTE1(v12));
              else
                v17 = (v17 >> (BYTE1(v12) & 0x1F)) | (v17 << (32 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( (signed __int16)v16 > 0 );
          }
          else
          {
            do
            {
              v3 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v17 = ((unsigned __int64)v17 >> SBYTE1(v12)) | (v3 >> (BYTE1(v12) & 0x1F)) | (v3 << (32
                                                                                                 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( v16 );
          }
          v11 = -65535 * v12;
          *v14 = (v17 >> ((BYTE3(v11) - 127) & 0x1F)) | (v17 << (32 - ((BYTE3(v11) - 127) & 0x1F)));
          v21 += v22;
          result = (unsigned int)v19 + v18;
          v19 = (unsigned int *)((char *)v19 + v18);
          --v5;
        }
        while ( v5 );
      }
    }
  }
  return result;
}

//----- (1002CAE0) --------------------------------------------------------
int __cdecl sub_1002CAE0(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  *(_DWORD *)(a1 + 56) = a2;
  *(_WORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 12) = a4;
  *(_WORD *)(a1 + 10) = a5;
  *(_WORD *)(a1 + 8) = a6;
  *(_WORD *)(a1 + 18) = a7;
  *(_WORD *)(a1 + 16) = a8;
  return a1;
}

//----- (1002CB40) --------------------------------------------------------
_WORD *__cdecl sub_1002CB40(int a1)
{
  _WORD *result; // eax@1

  result = (_WORD *)a1;
  if ( *(_WORD *)(a1 + 36) != 0xFFFF )
  {
    result = *(_WORD **)(a1 + 52);
    if ( !(result[5] << 30) )
    {
      *(_BYTE *)a1 = 1;
      result = memset(
                 **(void ***)(a1 + 52),
                 *(_WORD *)(a1 + 36),
                 *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 4));
    }
  }
  return result;
}

//----- (1002CBA0) --------------------------------------------------------
int __cdecl sub_1002CBA0(int a1, int a2, char a3)
{
  int result; // eax@1

  *(_DWORD *)(a1 + 52) = a2;
  sub_1002BE90(a1, 0, 0, *(_WORD *)(a2 + 6), *(_WORD *)(a2 + 4));
  *(_WORD *)(a1 + 42) = 0;
  *(_WORD *)(a1 + 40) = 0;
  *(_WORD *)(a1 + 46) = 0;
  *(_WORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_WORD *)(a1 + 2) = 1;
  *(_WORD *)(a1 + 34) = 1;
  *(_WORD *)(a1 + 32) = 1;
  *(_WORD *)(a1 + 4) = 3;
  *(_WORD *)(a1 + 36) = -1;
  *(_WORD *)(a1 + 38) = -1;
  *(_WORD *)(a1 + 6) = 3;
  *(_WORD *)(a1 + 48) = -1;
  *(_WORD *)(a1 + 50) = -1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  result = a1;
  *(_BYTE *)a1 = a3;
  return result;
}

//----- (1002CC90) --------------------------------------------------------
int __cdecl sub_1002CC90(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@1
  int v6; // [sp+0h] [bp-8h]@4
  __int16 v7; // [sp+4h] [bp-4h]@6

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v6 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 48);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + a2;
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + a3;
    if ( *(_WORD *)(a1 + 6) == 3 || *(_WORD *)(a1 + 6) == 1 )
    {
      v7 = *(_WORD *)(a1 + 4);
      if ( *(_WORD *)(a1 + 6) == 3 )
        *(_WORD *)(a1 + 4) = 2;
      else
        *(_WORD *)(a1 + 4) = 0;
      sub_1002E250(a1, a4 + (*(_WORD *)(a1 + 10) << 16), a5 + (*(_WORD *)(a1 + 8) << 16));
      *(_WORD *)(a1 + 4) = v7;
    }
    result = a1;
    *(_DWORD *)(a1 + 36) = v6;
  }
  return result;
}

//----- (1002CD80) --------------------------------------------------------
int __cdecl sub_1002CD80(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int result; // eax@1
  __int16 v7; // ST1C_2@8
  int v8; // [sp+0h] [bp-14h]@4
  int v9; // [sp+Ch] [bp-8h]@4
  __int16 v10; // [sp+10h] [bp-4h]@8
  __int16 v11; // [sp+28h] [bp+14h]@8
  __int16 v12; // [sp+2Ch] [bp+18h]@8

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v8 = *(_DWORD *)(a1 + 36);
    v9 = *(_DWORD *)(a1 + 36);
    if ( a6 & 1 )
      sub_1002CC90(a1, a2, a3, a4, a5);
    if ( !(a6 & 2) )
      LOWORD(v9) = HIWORD(v9);
    v12 = a5 - 1;
    v11 = a4 - 1;
    v10 = a2;
    v10 = *(_WORD *)(a1 + 42) + a2;
    v7 = *(_WORD *)(a1 + 40) + a3;
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100B3B70[0]);
    *(_WORD *)(a1 + 10) = byte_100B3B70[1] + v10;
    *(_WORD *)(a1 + 8) = v7;
    *(_WORD *)(a1 + 14) = byte_100B3B70[2] + v11 - byte_100B3B70[1] + 1;
    sub_1002E720(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100B3B70[3]);
    *(_WORD *)(a1 + 8) = byte_100B3B70[4] + v7;
    *(_WORD *)(a1 + 10) = v11 + v10;
    *(_WORD *)(a1 + 12) = byte_100B3B70[5] + v12 - byte_100B3B70[4] + 1;
    sub_1002E890(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100B3B70[6]);
    *(_WORD *)(a1 + 10) = byte_100B3B70[8] + v11 + v10;
    *(_WORD *)(a1 + 8) = v12 + v7;
    *(_WORD *)(a1 + 14) = byte_100B3B70[7] - (byte_100B3B70[8] + v11) - 1;
    sub_1002E720(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100B3B70[9]);
    *(_WORD *)(a1 + 8) = byte_100B3B70[11] + v12 + v7;
    *(_WORD *)(a1 + 10) = v10;
    *(_WORD *)(a1 + 12) = byte_100B3B70[10] - (byte_100B3B70[11] + v12) - 1;
    sub_1002E890(a1);
    result = v8;
    *(_DWORD *)(a1 + 36) = v8;
  }
  return result;
}

//----- (1002CFE0) --------------------------------------------------------
int __cdecl sub_1002CFE0(int a1, _BYTE *a2, int a3)
{
  int result; // eax@2

  if ( *(_BYTE *)(a1 + 2) )
    result = 0;
  else
    result = sub_1002DA30(a1, a2, a3);
  return result;
}

//----- (1002D020) --------------------------------------------------------
char __cdecl sub_1002D020(char a1, char a2)
{
  char result; // al@1

  result = a1;
  byte_10171841 = a1;
  byte_10171840 = a2;
  return result;
}
// 10171840: using guessed type char byte_10171840;
// 10171841: using guessed type char byte_10171841;

//----- (1002D040) --------------------------------------------------------
int __cdecl sub_1002D040(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7)
{
  int result; // eax@12
  __int16 v8; // ST1C_2@20
  __int16 v9; // ST1E_2@43
  __int16 v10; // ST1C_2@56
  __int16 v11; // [sp+8h] [bp-8Ch]@17
  __int16 v12; // [sp+8h] [bp-8Ch]@43
  __int16 v13; // [sp+Ah] [bp-8Ah]@17
  __int16 v14; // [sp+Ah] [bp-8Ah]@43
  __int16 *v15; // [sp+10h] [bp-84h]@3
  unsigned __int8 v16; // [sp+17h] [bp-7Dh]@1
  int v17; // [sp+18h] [bp-7Ch]@47
  int v18; // [sp+1Ch] [bp-78h]@17
  int v19; // [sp+20h] [bp-74h]@11
  __int16 v20; // [sp+28h] [bp-6Ch]@29
  int v21; // [sp+2Ch] [bp-68h]@50
  int v22; // [sp+30h] [bp-64h]@47
  int i; // [sp+34h] [bp-60h]@13
  signed int v24; // [sp+38h] [bp-5Ch]@15
  unsigned __int8 v25; // [sp+3Eh] [bp-56h]@1
  bool v26; // [sp+3Fh] [bp-55h]@1
  char v27; // [sp+40h] [bp-54h]@45
  __int16 v28; // [sp+44h] [bp-50h]@43
  __int16 v29; // [sp+46h] [bp-4Eh]@56
  char v30; // [sp+48h] [bp-4Ch]@43
  char v31; // [sp+49h] [bp-4Bh]@46
  __int16 v32; // [sp+4Ah] [bp-4Ah]@56
  unsigned __int8 v33; // [sp+4Fh] [bp-45h]@1
  int v34; // [sp+50h] [bp-44h]@15
  __int16 v35; // [sp+54h] [bp-40h]@22
  int v36; // [sp+58h] [bp-3Ch]@45
  int v37; // [sp+5Ch] [bp-38h]@44
  int v38; // [sp+60h] [bp-34h]@28
  __int16 v39; // [sp+64h] [bp-30h]@17
  __int16 v40; // [sp+66h] [bp-2Eh]@17
  __int16 v41; // [sp+68h] [bp-2Ch]@55
  __int16 v42; // [sp+6Ah] [bp-2Ah]@55
  unsigned __int16 v43; // [sp+6Ch] [bp-28h]@24
  int v44; // [sp+70h] [bp-24h]@29
  char v45; // [sp+75h] [bp-1Fh]@43
  unsigned __int8 v46; // [sp+76h] [bp-1Eh]@1
  char v47; // [sp+77h] [bp-1Dh]@43
  int v48; // [sp+78h] [bp-1Ch]@22
  int v49; // [sp+7Ch] [bp-18h]@23
  __int16 v50; // [sp+80h] [bp-14h]@55
  __int16 v51; // [sp+82h] [bp-12h]@55
  __int16 v52; // [sp+84h] [bp-10h]@24
  int v53; // [sp+88h] [bp-Ch]@4
  int v54; // [sp+8Ch] [bp-8h]@19
  __int16 v55; // [sp+90h] [bp-4h]@17

  v16 = (a5 & 0xE000u) >> 13;
  v46 = (unsigned __int8)(a5 & 0x70) >> 4;
  v25 = (a5 & 0x380u) >> 7;
  v33 = (a5 & 0x1C00u) >> 10;
  v26 = 1;
  if ( a5 & 0x40000000 || a5 & 0x80000000 )
  {
    v15 = &a6;
    if ( a5 & 0x40000000 )
    {
      v15 = (__int16 *)&a7;
      v53 = a6;
      v16 = (a6 & 0xFF000000) >> 24;
      v46 = a6;
      v25 = (unsigned __int16)(a6 & 0xFF00) >> 8;
      v33 = (a6 & 0xFF0000u) >> 16;
    }
    if ( a5 & 0x80000000 )
    {
      if ( *(_DWORD *)v15 )
      {
        if ( *(_DWORD *)v15 == 2 )
          v26 = sub_1002D880(a3) == 0;
        else
          v26 = 0;
      }
      else
      {
        v26 = 1;
      }
    }
  }
  v19 = 0;
  if ( *(_BYTE *)(a2 + 3) & 3 )
  {
    result = 0;
  }
  else
  {
    i = sub_1002CFE0(a2, a3, a5);
    if ( !a4 )
      a4 = i;
    v34 = a4;
    v24 = ((a5 & 0x3F0000u) >> 16) - 1;
    if ( v24 < 0 )
      v24 = *(_WORD *)(a2 + 28);
    v18 = *(_WORD *)(a2 + 22);
    v11 = *(_WORD *)(a1 + 46);
    v55 = *(_WORD *)(a1 + 44);
    v13 = v55 - (*(_WORD *)(a2 + 24) - 1);
    v39 = *(_WORD *)(a1 + 42);
    v40 = *(_WORD *)(a1 + 40);
    if ( a5 & 3 )
    {
      if ( (a5 & 3) == 1 )
      {
        v54 = v11 - v34 / 2;
        v11 -= i / 2;
      }
      else
      {
        v54 = v11;
      }
    }
    else
    {
      v8 = v11 + 1;
      v54 = v8 - v34;
      v11 = v8 - i;
    }
    v35 = v13;
    v48 = v18;
    if ( a5 & 0xC )
    {
      v35 += *(_WORD *)(a2 + 26);
      v48 -= v18 - *(_WORD *)(a2 + 24) + *(_WORD *)(a2 + 26);
      v54 -= v46;
      v49 = v25;
      v34 += v25 + v46;
      if ( (a5 & 0xC) == 4 )
      {
        v52 = *(_WORD *)(a1 + 6);
        v43 = *(_WORD *)(a1 + 50);
        *(_WORD *)(a1 + 6) = 3;
        *(_WORD *)(a1 + 50) = *(_WORD *)(a1 + 36);
        v49 = v33;
        v35 -= v33;
        v48 += v33;
        if ( v33 > (signed int)*(_WORD *)(a2 + 26) )
          sub_1002CC90(a1, v54, v35, v34, v49 - *(_WORD *)(a2 + 26));
        v49 = v16;
        v48 += v16;
        if ( v16 > v18 - *(_WORD *)(a2 + 24) )
          sub_1002CC90(a1, v54, v18 + v13, v34, v49 - (v18 - *(_WORD *)(a2 + 24)));
        v38 = v11 - v54;
        if ( i > a4 )
        {
          v20 = a4 + v11;
          v44 = v25;
        }
        else
        {
          v20 = i + v11;
          v44 = v34 - (i + v38);
        }
        if ( v38 > 0 )
          sub_1002CC90(a1, v54, v35, v38, v48);
        if ( v44 > 0 )
          sub_1002CC90(a1, v20, v35, v44, v48);
        *(_WORD *)(a1 + 50) = v43;
        *(_WORD *)(a1 + 6) = v52;
      }
    }
    if ( v35 <= v13 )
      v35 = 0;
    else
      v35 -= v13;
    if ( v48 >= v18 - v35 )
      v48 = v18 - v35;
    if ( i < a4 )
      a4 = i;
    v30 = 1;
    v47 = 0;
    v45 = (*(_BYTE *)(a2 + 3) & 3) << 6;
    v12 = v39 + v11;
    v9 = v40 + v13;
    v52 = *(_WORD *)(a1 + 4);
    *(_WORD *)(a1 + 4) = 2;
    v14 = v35 + v9;
    v28 = v18;
    if ( i )
    {
      v37 = (a5 & 0x3FC00000u) >> 22;
      for ( i = 0; !sub_1002D920(a2, &a3, &v27, &v36, v26); i += v21 + (signed __int16)v36 )
      {
        v31 = v47;
        if ( v37 <= v36 )
        {
          v22 = 0;
          v17 = 0;
        }
        else
        {
          v22 = (v37 - v36) / 2;
          v17 = v37 - v36 - v22;
        }
        v21 = i <= 0 ? v22 : v22 + v24 + v19;
        if ( v36 + v21 + i > a4 )
          break;
        v19 = v17;
        v43 = *(_WORD *)(a1 + 38);
        if ( v21 > 0 && v43 != 0xFFFF )
        {
          *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
          v50 = v14;
          v51 = v12;
          v41 = v48;
          v42 = v21;
          sub_1002E250(a1, (signed __int16)v21 + (v12 << 16), (signed __int16)v48 + (v14 << 16));
          *(_WORD *)(a1 + 38) = v43;
        }
        v10 = v21 + v12;
        *(_WORD *)(a1 + 8) = v14;
        *(_WORD *)(a1 + 10) = v10;
        *(_WORD *)(a1 + 16) = v48;
        *(_WORD *)(a1 + 18) = v36;
        v29 = v36;
        *(_WORD *)(a1 + 14) = 0;
        *(_WORD *)(a1 + 12) = v35;
        v32 = (v29 + 7) / 8;
        *(_DWORD *)(a1 + 56) = &v27;
        sub_1002C080(a1);
        v12 = v36 + v10;
      }
    }
    v43 = *(_WORD *)(a1 + 38);
    if ( i < a4 && v43 != 0xFFFF )
    {
      *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
      v50 = v14;
      v51 = v12;
      v41 = v48;
      v42 = a4 - i;
      sub_1002E250(a1, (signed __int16)(a4 - i) + (v12 << 16), (signed __int16)v48 + (v14 << 16));
      *(_WORD *)(a1 + 38) = v43;
    }
    *(_WORD *)(a1 + 4) = v52;
    *(_WORD *)(a1 + 46) = v19 + v12 - v39;
    *(_WORD *)(a1 + 44) = v55;
    result = v19 + i;
  }
  return result;
}

//----- (1002D880) --------------------------------------------------------
bool __cdecl sub_1002D880(_BYTE *a1)
{
  char v3; // [sp+6h] [bp-2h]@1
  char v4; // [sp+7h] [bp-1h]@1

  v3 = 0;
  v4 = 0;
  while ( *a1 )
  {
    if ( (signed int)*a1 < 48 || (signed int)*a1 > 57 )
    {
      if ( (signed int)*a1 >= 97 && (signed int)*a1 <= 122 || (signed int)*a1 >= 65 && (signed int)*a1 <= 90 )
        v3 = 1;
    }
    else
    {
      v4 = 1;
    }
    ++a1;
  }
  return v3 && v4;
}

//----- (1002D920) --------------------------------------------------------
bool __cdecl sub_1002D920(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5)
{
  int v5; // ST18_4@9
  int v7; // [sp+4h] [bp-1Ch]@7
  bool v8; // [sp+Bh] [bp-15h]@1
  unsigned int v9; // [sp+10h] [bp-10h]@7
  int v10; // [sp+14h] [bp-Ch]@1

  v10 = *(_BYTE *)(*a2)++;
  v8 = v10 == 0;
  if ( byte_10171841 && a5 && v10 == 48 )
    v10 = (unsigned __int8)byte_10171840;
  if ( !v8 )
  {
    if ( *(_BYTE *)(a1 + 2) )
    {
      v8 = 1;
    }
    else
    {
      v7 = *(_DWORD *)(a1 + 8) + a1;
      v9 = v10 - *(_BYTE *)(v7 + 2);
      if ( v9 >= *(_WORD *)v7 )
        v9 = *(_BYTE *)(v7 + 3);
      v5 = *(_DWORD *)(a1 + 12) + a1 + 4 * v9;
      *a3 = ((*(_BYTE *)(v5 + 2) << 16) | *(_WORD *)v5) + *(_DWORD *)(a1 + 16) + a1;
      *a4 = *(_BYTE *)(v5 + 3);
    }
  }
  return v8;
}
// 10171840: using guessed type char byte_10171840;
// 10171841: using guessed type char byte_10171841;

//----- (1002DA30) --------------------------------------------------------
int __cdecl sub_1002DA30(int a1, _BYTE *a2, int a3)
{
  int v3; // ST00_4@5
  unsigned int v5; // [sp+0h] [bp-20h]@5
  int v6; // [sp+4h] [bp-1Ch]@3
  int v7; // [sp+8h] [bp-18h]@3
  int v8; // [sp+Ch] [bp-14h]@3
  signed int v9; // [sp+10h] [bp-10h]@1
  signed int v10; // [sp+14h] [bp-Ch]@8
  signed int v11; // [sp+18h] [bp-8h]@1
  _BYTE *v12; // [sp+1Ch] [bp-4h]@3

  v11 = (a3 & 0x3FC00000u) >> 22;
  v9 = ((a3 & 0x3F0000u) >> 16) - 1;
  if ( v9 < 0 )
    v9 = *(_WORD *)(a1 + 28);
  v12 = a2;
  v6 = *(_DWORD *)(a1 + 12) + a1;
  v7 = *(_DWORD *)(a1 + 8) + a1;
  v8 = 0;
  while ( *v12 )
  {
    v3 = *v12++;
    v5 = v3 - *(_BYTE *)(v7 + 2);
    if ( v8 > 0 )
      v8 += v9;
    if ( v5 < *(_WORD *)v7 )
      v10 = *(_BYTE *)(v6 + 4 * v5 + 3);
    else
      v10 = *(_BYTE *)(v6 + 4 * *(_BYTE *)(v7 + 3) + 3);
    if ( v11 <= v10 )
      v8 += v10;
    else
      v8 += v11;
  }
  return v8;
}

//----- (1002DB20) --------------------------------------------------------
int __cdecl sub_1002DB20(int a1, __int16 a2, __int16 a3, char a4)
{
  int result; // eax@25
  signed int v5; // [sp+4h] [bp-30h]@29
  int v6; // [sp+8h] [bp-2Ch]@44
  int v7; // [sp+8h] [bp-2Ch]@54
  __int16 v8; // [sp+Ch] [bp-28h]@31
  char (__cdecl *v9)(int); // [sp+10h] [bp-24h]@2
  char *(__cdecl *v10)(int); // [sp+14h] [bp-20h]@5
  __int16 v11; // [sp+18h] [bp-1Ch]@31
  signed int v12; // [sp+1Ch] [bp-18h]@31
  __int16 v13; // [sp+20h] [bp-14h]@41
  __int16 v14; // [sp+28h] [bp-Ch]@29
  __int16 v15; // [sp+2Ch] [bp-8h]@29
  __int16 v16; // [sp+30h] [bp-4h]@41

  if ( *(_DWORD *)(a1 + 72) )
    v9 = *(char (__cdecl **)(int))(a1 + 72);
  else
    v9 = sub_1002E720;
  if ( *(_DWORD *)(a1 + 76) )
    v10 = *(char *(__cdecl **)(int))(a1 + 76);
  else
    v10 = sub_1002E890;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + *(_WORD *)(a1 + 46);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + *(_WORD *)(a1 + 44);
  *(_WORD *)(a1 + 14) = *(_WORD *)(a1 + 42) + a2;
  *(_WORD *)(a1 + 12) = *(_WORD *)(a1 + 40) + a3;
  *(_WORD *)(a1 + 46) = a2;
  *(_WORD *)(a1 + 44) = a3;
  if ( a4 & 1 )
  {
    if ( (signed int)*(_WORD *)(a1 + 10) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 10) < -8192 )
        *(_WORD *)(a1 + 10) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 10) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 8) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 8) < -8192 )
        *(_WORD *)(a1 + 8) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 8) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 14) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 14) < -8192 )
        *(_WORD *)(a1 + 14) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 14) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 12) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 12) < -8192 )
        *(_WORD *)(a1 + 12) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 12) = 0x1FFF;
    }
  }
  if ( *(_WORD *)(a1 + 10) != *(_WORD *)(a1 + 14) || (result = *(_WORD *)(a1 + 12), *(_WORD *)(a1 + 8) != result) )
  {
    v14 = *(_WORD *)(a1 + 14) - *(_WORD *)(a1 + 10);
    v15 = v14;
    v5 = 1;
    if ( v14 < 0 )
    {
      v5 = -1;
      v15 = -v14;
    }
    v8 = *(_WORD *)(a1 + 12) - *(_WORD *)(a1 + 8);
    v11 = v8;
    v12 = 1;
    if ( v8 < 0 )
    {
      v12 = -1;
      v11 = -v8;
    }
    if ( v15 )
    {
      if ( v11 )
      {
        v13 = 2 * v15;
        v16 = 2 * v11;
        if ( v15 <= v11 )
        {
          *(_WORD *)(a1 + 16) = 0;
          *(_WORD *)(a1 + 18) = 1;
          if ( v13 >= v11 )
            *(_WORD *)(a1 + 16) -= (v12 ^ v5) + 1;
          v7 = v13 - v11 - (v5 < 0);
          *(_WORD *)(a1 + 12) = 0;
          while ( v11 )
          {
            *(_WORD *)(a1 + 12) += v12;
            if ( v7 >= 0 )
            {
              v10(a1);
              *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
              *(_WORD *)(a1 + 12) = 0;
              *(_WORD *)(a1 + 10) += v5;
              v7 -= v16;
            }
            v7 += v13;
            --v11;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 12) += v12;
          v10(a1);
          result = a1;
          *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
        }
        else
        {
          *(_WORD *)(a1 + 16) = 1;
          *(_WORD *)(a1 + 18) = 0;
          if ( v16 >= v15 )
            *(_WORD *)(a1 + 18) -= (v12 ^ v5) + 1;
          v6 = v16 - v15 - (v12 < 0);
          *(_WORD *)(a1 + 14) = 0;
          while ( v15 )
          {
            *(_WORD *)(a1 + 14) += v5;
            if ( v6 >= 0 )
            {
              v9(a1);
              *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
              *(_WORD *)(a1 + 14) = 0;
              *(_WORD *)(a1 + 8) += v12;
              v6 -= v13;
            }
            v6 += v16;
            --v15;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 14) += v5;
          v9(a1);
          result = a1;
          *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
        }
      }
      else
      {
        *(_WORD *)(a1 + 16) = 1;
        *(_WORD *)(a1 + 18) = 0;
        *(_WORD *)(a1 + 14) = v14;
        if ( a4 & 2 )
          *(_WORD *)(a1 + 14) += v5;
        result = v9(a1);
      }
    }
    else
    {
      *(_WORD *)(a1 + 16) = 0;
      *(_WORD *)(a1 + 18) = 1;
      *(_WORD *)(a1 + 12) = v8;
      if ( a4 & 2 )
        *(_WORD *)(a1 + 12) += v12;
      result = (int)v10(a1);
    }
  }
  else if ( a4 & 2 )
  {
    *(_WORD *)(a1 + 12) = 1;
    result = (int)v10(a1);
  }
  return result;
}

//----- (1002E070) --------------------------------------------------------
void sub_1002E070()
{
  ;
}

//----- (1002E080) --------------------------------------------------------
int __cdecl sub_1002E080(int a1)
{
  int result; // eax@6
  __int16 v2; // [sp+0h] [bp-8h]@1
  __int16 v3; // [sp+4h] [bp-4h]@1

  v2 = *(_WORD *)(a1 + 10);
  v3 = *(_WORD *)(a1 + 8);
  if ( *(_WORD *)(a1 + 26) > (signed int)*(_WORD *)(a1 + 10) )
  {
    *(_WORD *)(a1 + 18) -= *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 14) += *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > (signed int)*(_WORD *)(a1 + 8) )
  {
    *(_WORD *)(a1 + 16) -= *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 12) += *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 24);
  }
  if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) > v2 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v2 < *(_WORD *)(a1 + 18) )
      *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v2;
    if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) > v3 )
    {
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v3 < *(_WORD *)(a1 + 16) )
        *(_WORD *)(a1 + 16) = *(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 24) - v3;
      if ( (signed int)*(_WORD *)(a1 + 18) > 0 )
      {
        if ( (signed int)*(_WORD *)(a1 + 16) > 0 )
        {
          *(_BYTE *)a1 = 1;
          result = a1;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002E250) --------------------------------------------------------
int __cdecl sub_1002E250(int a1, signed int a2, signed int a3)
{
  int result; // eax@5
  int v4; // edx@10
  unsigned int v5; // ST04_4@15
  unsigned int v6; // ST20_4@16
  int v7; // ST28_4@26
  unsigned int v8; // ST18_4@32
  int v9; // [sp+0h] [bp-44h]@28
  unsigned int v10; // [sp+4h] [bp-40h]@15
  int v11; // [sp+8h] [bp-3Ch]@1
  int v12; // [sp+Ch] [bp-38h]@1
  int v13; // [sp+10h] [bp-34h]@31
  unsigned int v14; // [sp+14h] [bp-30h]@13
  int v15; // [sp+1Ch] [bp-28h]@30
  int v16; // [sp+20h] [bp-24h]@17
  int i; // [sp+20h] [bp-24h]@32
  int v18; // [sp+20h] [bp-24h]@34
  int v19; // [sp+24h] [bp-20h]@1
  unsigned int v20; // [sp+28h] [bp-1Ch]@14
  int v21; // [sp+2Ch] [bp-18h]@15
  unsigned int *v22; // [sp+30h] [bp-14h]@15
  int *v23; // [sp+30h] [bp-14h]@32
  int v24; // [sp+34h] [bp-10h]@15
  unsigned int v25; // [sp+38h] [bp-Ch]@15
  unsigned int *v26; // [sp+3Ch] [bp-8h]@13
  int v27; // [sp+40h] [bp-4h]@1

  v11 = (signed __int16)a3;
  v27 = a3 >> 16;
  v12 = (signed __int16)a2;
  v19 = a2 >> 16;
  if ( *(_WORD *)(a1 + 26) > a2 >> 16 )
  {
    v12 = (signed __int16)a2 - (*(_WORD *)(a1 + 26) - v19);
    v19 = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > v27 )
  {
    v11 = (signed __int16)a3 - (*(_WORD *)(a1 + 24) - v27);
    v27 = *(_WORD *)(a1 + 24);
  }
  result = *(_WORD *)(a1 + 30);
  if ( result + *(_WORD *)(a1 + 26) > v19 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v19 <= v12 )
      v12 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v19;
    result = *(_WORD *)(a1 + 28);
    if ( result + *(_WORD *)(a1 + 24) > v27 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v27 <= v11 )
      {
        v4 = *(_WORD *)(a1 + 28);
        result = v4 + *(_WORD *)(a1 + 24) - v27;
        v11 = v4 + *(_WORD *)(a1 + 24) - v27;
      }
      if ( v11 > 0 && v12 > 0 )
      {
        *(_BYTE *)a1 = 1;
        v14 = 32 - (8 * v19 & 0x1F);
        v26 = (unsigned int *)(v27 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                             + **(_DWORD **)(a1 + 52)
                             + 4 * ((unsigned int)(8 * v19) >> 5));
        if ( *(_WORD *)(a1 + 4) == 2 )
        {
          v9 = v11;
          if ( v14 >= 8 * v12 )
            v14 = 8 * v12;
          v15 = 8 * v12 - v14;
          result = *(_WORD *)(a1 + 38) << 16;
          if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
          {
            v13 = *(&dword_100B3B80 + *(_WORD *)(a1 + 38));
            do
            {
              v8 = ~(((unsigned int)(0xFFFFFFFFui64 >> v14) >> ((32 - (8 * v19 & 0x1F) - v14) & 0x1F)) | ((unsigned int)(0xFFFFFFFFui64 >> v14) << (32 - ((32 - (8 * v19 & 0x1F) - v14) & 0x1F))));
              *v26 = *v26 & ~v8 | v13 & v8;
              v23 = (int *)(v26 + 1);
              for ( i = v15 - 32; i >= 0; i -= 32 )
              {
                *v23 = v13;
                ++v23;
              }
              v18 = i + 32;
              if ( v18 )
                *v23 = *v23 & ~((1 << v18) - 1) | v13 & ((1 << v18) - 1);
              result = *(_DWORD *)(a1 + 52);
              v26 = (unsigned int *)((char *)v26 + *(_WORD *)(result + 10));
              --v9;
            }
            while ( v9 );
          }
        }
        else
        {
          v20 = (v19 << 16) & 0x1FFFFF | v11 | (v27 << 27);
          do
          {
            v5 = *(_DWORD *)(*(_DWORD *)(a1 + 60) + (v20 >> 25));
            v10 = (v5 >> ((v20 >> 16) & 0x1F)) | (v5 << (32 - ((v20 >> 16) & 0x1F)));
            v22 = v26;
            v21 = 32 - (8 * v19 & 0x1F);
            v25 = (*v26 >> (31 * v14 & 0x1F)) | (*v26 << (32 - (31 * v14 & 0x1F)));
            v24 = v12;
            do
            {
              v6 = v10 << 31;
              v10 = (v10 << 31) | (v10 >> 1);
              if ( v6 >> 31 )
                v16 = *(_WORD *)(a1 + 38);
              else
                v16 = *(_WORD *)(a1 + 36);
              if ( (signed __int16)v16 >= 0 )
                v25 = (v16 << 24) | (v25 >> 8);
              else
                v25 = (v25 >> 8) | (v25 << 24);
              if ( --v24 )
              {
                v21 -= 8;
                if ( !v21 )
                {
                  *v22 = v25;
                  ++v22;
                  v21 = 32;
                  v25 = *v22;
                }
              }
            }
            while ( v24 );
            *v22 = (v25 >> ((v21 - 8) & 0x1F)) | (v25 << (32 - ((v21 - 8) & 0x1F)));
            v26 = (unsigned int *)((char *)v26 + *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
            v7 = v20 + 0x8000000;
            result = v7 - 1;
            v20 = v7 - 1;
          }
          while ( v20 << 16 );
        }
      }
    }
  }
  return result;
}

//----- (1002E720) --------------------------------------------------------
char __cdecl sub_1002E720(int a1)
{
  __int16 v1; // ax@1
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@8
  int v5; // [sp+18h] [bp-1Ch]@1

  v5 = *(_WORD *)(a1 + 10);
  v1 = *(_WORD *)(a1 + 14);
  v3 = *(_WORD *)(a1 + 14);
  if ( *(_WORD *)(a1 + 14) )
  {
    if ( v3 < 0 )
    {
      v5 += v3 + 1;
      v3 = 0x8000 - v3;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) > 1 )
    {
      LOBYTE(v1) = a1;
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
        case 2:
          LOBYTE(v1) = sub_1002ECA0(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
        case 4:
          LOBYTE(v1) = sub_1002F560(a1, v5, (int)&v4);
          break;
        default:
          return v1;
      }
    }
    else
    {
      v1 = *(_WORD *)(a1 + 4);
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
          LOBYTE(v1) = sub_1002ECA0(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 2:
          LOBYTE(v1) = sub_1002ECA0(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
          LOBYTE(v1) = sub_1002EDA0(a1, v5, *(_WORD *)(a1 + 8), (int)&v4);
          break;
        case 4:
          LOBYTE(v1) = (unsigned int)sub_1002F1D0(a1, v5, *(_WORD *)(a1 + 8), *(int **)(a1 + 64));
          break;
        default:
          return v1;
      }
    }
  }
  return v1;
}

//----- (1002E890) --------------------------------------------------------
char *__cdecl sub_1002E890(int a1)
{
  char *result; // eax@1
  int v2; // ST18_4@3
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@7
  int v5; // [sp+1Ch] [bp-18h]@1

  v5 = *(_WORD *)(a1 + 8);
  result = (char *)*(_WORD *)(a1 + 12);
  v3 = *(_WORD *)(a1 + 12);
  if ( *(_WORD *)(a1 + 12) )
  {
    if ( v3 < 0 )
    {
      v2 = -v3;
      v5 = v5 - v2 + 1;
      v3 = v2 + 0x8000;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) <= 1 )
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_1002ED20(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
          result = (char *)sub_1002EFA0(a1, v5, *(_WORD *)(a1 + 10), (int)&v4);
          break;
        case 4u:
          result = sub_1002F310(a1, v5, *(_WORD *)(a1 + 10), *(int **)(a1 + 64));
          break;
        default:
          return result;
      }
    }
    else
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_1002ED20(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
        case 4u:
          result = (char *)sub_1002F6A0(a1, v5, (int)&v4);
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

//----- (1002E9E0) --------------------------------------------------------
int __cdecl sub_1002E9E0(int a1, int a2)
{
  int result; // eax@2

  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = *(_WORD *)(a1 + 26) - *(_DWORD *)(a2 + 12);
  if ( *(_DWORD *)(a2 + 24) <= 0
    || (*(_DWORD *)(a2 + 12) += *(_DWORD *)(a2 + 24),
        result = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 24),
        *(_DWORD *)(a2 + 20) = result,
        *(_DWORD *)(a2 + 20) > 0) )
  {
    result = *(_WORD *)(a1 + 26);
    if ( result + *(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
    {
      if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12) <= *(_DWORD *)(a2 + 20) )
        *(_DWORD *)(a2 + 20) = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12);
      result = a1;
      if ( (signed int)*(_WORD *)(a1 + 24) <= *(_DWORD *)(a2 + 16) )
      {
        result = *(_WORD *)(a1 + 24);
        if ( result + *(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
        {
          *(_DWORD *)(a2 + 24) &= ~(*(_DWORD *)(a2 + 24) >> 31);
          *(_BYTE *)a1 = 1;
          result = a2;
          *(_DWORD *)a2 = 1;
        }
      }
    }
  }
  return result;
}

//----- (1002EB00) --------------------------------------------------------
unsigned int __cdecl sub_1002EB00(int a1, int a2)
{
  unsigned int v2; // ST04_4@1
  __int16 v3; // ST0C_2@2
  char v4; // ST04_1@9
  unsigned int result; // eax@9
  unsigned int v6; // [sp+0h] [bp-1Ch]@1
  int v7; // [sp+4h] [bp-18h]@1
  int v8; // [sp+8h] [bp-14h]@2
  int v9; // [sp+10h] [bp-Ch]@1
  unsigned int v10; // [sp+14h] [bp-8h]@1
  unsigned int *v11; // [sp+18h] [bp-4h]@1

  v9 = *(_DWORD *)(a2 + 20);
  v2 = 8 * *(_DWORD *)(a2 + 12);
  v11 = (unsigned int *)(**(_DWORD **)(a1 + 52)
                       + *(_DWORD *)(a2 + 16) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                       + 4 * (v2 >> 5));
  v7 = 32 - (v2 & 0x1F);
  v10 = (*v11 >> (31 * v7 & 0x1F)) | (*v11 << (32 - (31 * v7 & 0x1F)));
  v6 = *(_DWORD *)(a2 + 32);
  do
  {
    v8 = 2 * v6 & 3;
    v6 = (v6 >> (*(_BYTE *)(a2 + 36) & 0x1F)) | (v6 << (32 - (*(_BYTE *)(a2 + 36) & 0x1F)));
    v3 = *(_WORD *)(v8 + a1 + 36);
    if ( v3 >= 0 )
      v10 = (v10 >> 8) | (*(_WORD *)(v8 + a1 + 36) << 24);
    else
      v10 = (v10 >> 8) | (v10 << 24);
    if ( --v9 )
    {
      v7 -= 8;
      if ( !v7 )
      {
        *v11 = v10;
        ++v11;
        v7 = 32;
        v10 = *v11;
      }
    }
  }
  while ( v9 );
  v4 = v7 - 8;
  result = v10 >> (v4 & 0x1F);
  *v11 = result | (v10 << (32 - (v4 & 0x1F)));
  return result;
}

//----- (1002ECA0) --------------------------------------------------------
int __cdecl sub_1002ECA0(int a1, int a2, int a3)
{
  return sub_1002E250(
           a1,
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 34) - 1 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1 << 16),
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1)) << 16) + *(_WORD *)(a1 + 32));
}

//----- (1002ED20) --------------------------------------------------------
int __cdecl sub_1002ED20(int a1, int a2, int a3)
{
  return sub_1002E250(
           a1,
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1)) << 16) + *(_WORD *)(a1 + 34),
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 32) - 1 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1 << 16));
}

//----- (1002EDA0) --------------------------------------------------------
char __cdecl sub_1002EDA0(int a1, signed int a2, int a3, int a4)
{
  char result; // al@2
  int v5; // [sp+0h] [bp-Ch]@7
  unsigned int v6; // [sp+4h] [bp-8h]@5
  _BYTE *v7; // [sp+8h] [bp-4h]@5

  *(_DWORD *)(a4 + 20) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 12) = a2 >> 16;
  *(_DWORD *)(a4 + 16) = a3;
  if ( *(_DWORD *)(a4 + 20) == 1 )
  {
    result = sub_1002EEB0(a1, *(_DWORD *)(a4 + 12), *(_DWORD *)(a4 + 16));
  }
  else
  {
    result = sub_1002E9E0(a1, a4);
    if ( *(_DWORD *)a4 )
    {
      result = a1;
      if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
      {
        v7 = (_BYTE *)(*(_DWORD *)(a4 + 12) + **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
        v6 = *(_DWORD *)(a4 + 20);
        if ( v6 <= 0x10 )
        {
          v5 = *(&dword_100B3B80 + *(_WORD *)(a1 + 38));
          do
          {
            result = v5;
            *v7++ = v5;
            --v6;
          }
          while ( v6 );
        }
        else
        {
          result = (unsigned int)memset(v7, *(&dword_100B3B80 + *(_WORD *)(a1 + 38)), v6);
        }
      }
    }
  }
  return result;
}

//----- (1002EEB0) --------------------------------------------------------
int __cdecl sub_1002EEB0(int a1, signed int a2, signed int a3)
{
  int result; // eax@1
  _BYTE *v4; // ST08_4@5
  unsigned int v5; // [sp+18h] [bp+Ch]@5

  result = a1;
  if ( *(_WORD *)(a1 + 26) <= a2 )
  {
    result = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30);
    if ( result > a2 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 24) <= a3 )
      {
        result = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28);
        if ( result > a3 )
        {
          *(_BYTE *)a1 = 1;
          v5 = 8 * a2;
          v4 = (_BYTE *)(**(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3));
          result = **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3);
          *v4 = ((unsigned __int64)*(_WORD *)(a1 + 38) << (v5 & 7)) | ~(unsigned __int8)(255i64 << (v5 & 7)) & *v4;
        }
      }
    }
  }
  return result;
}

//----- (1002EFA0) --------------------------------------------------------
int __cdecl sub_1002EFA0(int a1, signed int a2, int a3, int a4)
{
  int result; // eax@1
  _BYTE *v5; // [sp+Ch] [bp-4h]@2
  int v6; // [sp+18h] [bp+8h]@1

  *(_DWORD *)(a4 + 8) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 16) = a2 >> 16;
  *(_DWORD *)(a4 + 12) = a3;
  result = sub_1002F0A0(a1, a4);
  v6 = result;
  if ( *(_DWORD *)(a4 + 4) )
  {
    v5 = (_BYTE *)((a3 & 0x1FFFFFFF)
                 + *(_DWORD *)(a4 + 16) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                 + **(_DWORD **)(result + 52));
    do
    {
      *v5;
      *v5 = *(_WORD *)(v6 + 38);
      v5 += *(_WORD *)(*(_DWORD *)(v6 + 52) + 10);
      result = *(_DWORD *)(a4 + 8) - 1;
      *(_DWORD *)(a4 + 8) = result;
    }
    while ( *(_DWORD *)(a4 + 8) > 0 );
  }
  return result;
}

//----- (1002F0A0) --------------------------------------------------------
int __cdecl sub_1002F0A0(int a1, int a2)
{
  int result; // eax@3

  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 28) = *(_WORD *)(a1 + 24) - *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 28) <= 0
    || (*(_DWORD *)(a2 + 16) += *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) -= *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) > 0) )
  {
    if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
    {
      if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16) <= *(_DWORD *)(a2 + 8) )
        *(_DWORD *)(a2 + 8) = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16);
      if ( (signed int)*(_WORD *)(a1 + 26) <= *(_DWORD *)(a2 + 12) )
      {
        if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
        {
          *(_DWORD *)(a2 + 28) &= ~(*(_DWORD *)(a2 + 28) >> 31);
          *(_BYTE *)a1 = 1;
          *(_DWORD *)(a2 + 4) = 1;
          result = a1;
        }
        else
        {
          result = a1;
        }
      }
      else
      {
        result = a1;
      }
    }
    else
    {
      result = a1;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (1002F1D0) --------------------------------------------------------
char *__cdecl sub_1002F1D0(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-30h]@1
  signed int v6; // [sp+Ch] [bp-24h]@1
  int v7; // [sp+10h] [bp-20h]@1
  int v8; // [sp+14h] [bp-1Ch]@1
  int v9; // [sp+20h] [bp-10h]@1
  int v10; // [sp+24h] [bp-Ch]@1
  char *v11; // [sp+28h] [bp-8h]@1
  int v12; // [sp+2Ch] [bp-4h]@1
  signed int v13; // [sp+3Ch] [bp+Ch]@1
  int v14; // [sp+3Ch] [bp+Ch]@4

  v11 = &v5;
  v8 = a2 & 0x7FFF;
  v6 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v8 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v13 = (a2 - *((_DWORD *)v11 + 5)) << 16;
  if ( v13 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v13 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v13 + 1;
  sub_1002E9E0(a1, (int)v11);
  result = v11;
  if ( *(_DWORD *)v11 )
  {
    v14 = *((_DWORD *)v11 + 6) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v14 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v14 & 0x1F)));
    result = (char *)sub_1002EB00(a1, (int)v11);
  }
  return result;
}

//----- (1002F310) --------------------------------------------------------
char *__cdecl sub_1002F310(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-3Ch]@1
  int v6; // [sp+8h] [bp-34h]@1
  int v7; // [sp+Ch] [bp-30h]@1
  signed int v8; // [sp+10h] [bp-2Ch]@1
  int v9; // [sp+20h] [bp-1Ch]@1
  int v10; // [sp+24h] [bp-18h]@1
  char *v11; // [sp+28h] [bp-14h]@1
  int v12; // [sp+2Ch] [bp-10h]@1
  __int16 v13; // [sp+30h] [bp-Ch]@5
  char v14; // [sp+37h] [bp-5h]@6
  char *v15; // [sp+38h] [bp-4h]@4
  int v16; // [sp+44h] [bp+8h]@3
  signed int v17; // [sp+48h] [bp+Ch]@1
  int v18; // [sp+48h] [bp+Ch]@4
  unsigned int v19; // [sp+4Ch] [bp+10h]@4
  int v20; // [sp+4Ch] [bp+10h]@4

  v11 = &v5;
  v6 = a2 & 0x7FFF;
  v8 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v6 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v17 = (a2 - *((_DWORD *)v11 + 2)) << 16;
  if ( v17 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v17 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v17 + 1;
  v16 = sub_1002F0A0(a1, (int)v11);
  result = v11;
  if ( *((_DWORD *)v11 + 1) )
  {
    v18 = *((_DWORD *)v11 + 7) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v18 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v18 & 0x1F)));
    v19 = 8 * a3;
    v15 = (char *)(**(_DWORD **)(v16 + 52) + (v19 >> 3) + *((_DWORD *)v11 + 4) * *(_WORD *)(*(_DWORD *)(v16 + 52) + 10));
    v20 = v19 & 7;
    do
    {
      v12 = 2 * *((_DWORD *)v11 + 8) & 3;
      *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v11[36] & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v11[36] & 0x1F)));
      v12 += v16 + 36;
      v13 = *(_WORD *)v12;
      if ( v13 >= 0 )
      {
        v14 = *v15;
        v13 <<= v20;
        v14 &= ~(unsigned __int8)(255 << v20);
        v14 |= v13;
        *v15 = v14;
      }
      v15 += *(_WORD *)(*(_DWORD *)(v16 + 52) + 10);
      --*((_DWORD *)v11 + 2);
      result = v11;
    }
    while ( *((_DWORD *)v11 + 2) );
  }
  return result;
}

//----- (1002F560) --------------------------------------------------------
int __cdecl sub_1002F560(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  unsigned int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int *v10; // [sp+10h] [bp-4h]@1

  v7 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 16) = v7 >> 1;
  *(_DWORD *)(a3 + 12) = a2 - (*(_DWORD *)(a3 + 16) * *(_WORD *)(a1 + 18) << 16);
  *(_DWORD *)(a3 + 16) = *(_WORD *)(a1 + 8) - *(_DWORD *)(a3 + 16);
  v9 = *(_WORD *)(a1 + 18) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = -256 * (8 * (*(_DWORD *)(a3 + 12) << 16 >> 31) + 4);
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v10 = *(int **)(a1 + 64);
  if ( v5 )
    v10 = (int *)((char *)v10 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_1002F1D0(a1, *(_DWORD *)(a3 + 12), *(_DWORD *)(a3 + 16), v10);
    else
      sub_1002EDA0(a1, a2, *(_DWORD *)(a3 + 16), a3);
    ++*(_DWORD *)(a3 + 16);
    *(_DWORD *)(a3 + 12) += v9;
    result = (int)v10 + (v8 >> 8);
    v10 = (int *)((char *)v10 + (v8 >> 8));
    --v7;
  }
  while ( v7 );
  return result;
}

//----- (1002F6A0) --------------------------------------------------------
int __cdecl sub_1002F6A0(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int *v9; // [sp+Ch] [bp-8h]@1
  unsigned int v10; // [sp+10h] [bp-4h]@1

  v10 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 12) = v10 >> 1;
  *(_DWORD *)(a3 + 16) = a2 - (*(_DWORD *)(a3 + 12) * *(_WORD *)(a1 + 16) << 16);
  *(_DWORD *)(a3 + 12) = *(_WORD *)(a1 + 10) - *(_DWORD *)(a3 + 12);
  v7 = *(_WORD *)(a1 + 16) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = (8 * (*(_DWORD *)(a3 + 16) << 16 >> 31) + 4) << 8;
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v9 = *(int **)(a1 + 64);
  if ( v5 )
    v9 = (int *)((char *)v9 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_1002F310(a1, *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 12), v9);
    else
      sub_1002EFA0(a1, a2, *(_DWORD *)(a3 + 12), a3);
    ++*(_DWORD *)(a3 + 12);
    *(_DWORD *)(a3 + 16) += v7;
    result = (int)v9 + (v8 >> 8);
    v9 = (int *)((char *)v9 + (v8 >> 8));
    --v10;
  }
  while ( v10 );
  return result;
}

//----- (1002F7E0) --------------------------------------------------------
int __cdecl sub_1002F7E0(unsigned __int8 a1, unsigned int a2)
{
  return dword_100B4480[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 100B4480: using guessed type int dword_100B4480[];

//----- (1002F800) --------------------------------------------------------
unsigned int __cdecl sub_1002F800(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_100B4480[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_100B4480[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_100B4480[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_100B4480[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_100B4480[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_100B4480[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_100B4480[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_100B4480[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_100B4480[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_100B4480[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 100B4480: using guessed type int dword_100B4480[];

//----- (10031221) --------------------------------------------------------
int __cdecl sub_10031221(int a1, int a2, char a3)
{
  return vscan_fn(sub_1003774A, a2, 0, &a3);
}
// 100311B9: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10032ECD) --------------------------------------------------------
signed int __cdecl sub_10032ECD(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_10171B88 )
  {
    *a1 = dword_10171B88;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 10035BB4: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10171B88: using guessed type int dword_10171B88;

//----- (10032F04) --------------------------------------------------------
signed int __cdecl sub_10032F04(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_10171B88 )
  {
    *a1 = dword_10171B94;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 10035BB4: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10171B88: using guessed type int dword_10171B88;
// 10171B94: using guessed type int dword_10171B94;

//----- (10033B4A) --------------------------------------------------------
void sub_10033B4A()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_101A5AC0;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_101A5BC0 );
}
// 101A5AC0: using guessed type int dword_101A5AC0[];
// 101A5BC0: using guessed type int dword_101A5BC0;

//----- (10033FF7) --------------------------------------------------------
int (*sub_10033FF7())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_100BEAC0;
  v1 = (int (**)(void))&unk_100BEAC0;
  if ( &unk_100BEAC0 < &unk_100BEAC0 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_100BEAC0 );
  }
  return result;
}

//----- (1003401B) --------------------------------------------------------
void __cdecl sub_1003401B()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_100BEAC8;
  if ( &unk_100BEAC8 < &unk_100BEAC8 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_100BEAC8 );
  }
}

//----- (10035AAE) --------------------------------------------------------
int __cdecl sub_10035AAE(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10171CF0 = a1;
  return result;
}
// 10171CF0: using guessed type int dword_10171CF0;

//----- (10035BD8) --------------------------------------------------------
int __cdecl sub_10035BD8(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_1003D365() + 8 && (void **)v2 != sub_1003D365() + 16 || !sub_1003D307((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_100C0278;
      else
        v9 = (_BYTE *)(dword_101A5AC0[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_1003D1E7((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_1003D1E7((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 1003D2C3: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 101A5AC0: using guessed type int dword_101A5AC0[];

//----- (1003774A) --------------------------------------------------------
int __cdecl sub_1003774A(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
  {
    v7 = &unk_100C0278;
  }
  else
  {
    v6 = &dword_101A5AC0[_fileno(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno(a1) == -1 || _fileno(a1) == -2 ? (v9 = &unk_100C0278) : (v8 = &dword_101A5AC0[_fileno(a1) >> 5],
                                                                         v9 = (_BYTE *)(*v8 + ((_fileno(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_1003DFDC(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_1003DFDC(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_1003DFDC(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_1003DFDC(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_1003DFDC(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_100C025C[0]);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_1003DFDC(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_1003DFDC(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_1003DFDC(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_1003DFDC(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 10033203: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10035BB4: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1003770F: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 10037725: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 100C025C: using guessed type int (*off_100C025C[3])();
// 101A5AC0: using guessed type int dword_101A5AC0[];
// 1003774A: using guessed type char var_24[11];

//----- (10039554) --------------------------------------------------------
#error "10039559: positive sp value has been found (funcsize=0)"

//----- (1003955F) --------------------------------------------------------
#error "10039564: positive sp value has been found (funcsize=0)"

//----- (1003956A) --------------------------------------------------------
#error "1003956F: positive sp value has been found (funcsize=0)"

//----- (10039570) --------------------------------------------------------
#error "10039575: positive sp value has been found (funcsize=0)"

//----- (10039576) --------------------------------------------------------
#error "1003957B: positive sp value has been found (funcsize=0)"

//----- (1003957C) --------------------------------------------------------
#error "10039581: positive sp value has been found (funcsize=0)"

//----- (10039582) --------------------------------------------------------
#error "1003959D: positive sp value has been found (funcsize=0)"

//----- (100395A3) --------------------------------------------------------
#error "100395B8: positive sp value has been found (funcsize=0)"

//----- (100395BE) --------------------------------------------------------
#error "100395D9: positive sp value has been found (funcsize=0)"

//----- (100395DA) --------------------------------------------------------
#error "100395E9: positive sp value has been found (funcsize=0)"

//----- (100395EA) --------------------------------------------------------
#error "100395FD: positive sp value has been found (funcsize=0)"

//----- (100395FE) --------------------------------------------------------
#error "1003960D: positive sp value has been found (funcsize=0)"

//----- (1003960E) --------------------------------------------------------
#error "1003962D: positive sp value has been found (funcsize=0)"

//----- (10039633) --------------------------------------------------------
#error "1003964C: positive sp value has been found (funcsize=0)"

//----- (10039652) --------------------------------------------------------
#error "10039671: positive sp value has been found (funcsize=0)"

//----- (10039672) --------------------------------------------------------
#error "10039685: positive sp value has been found (funcsize=0)"

//----- (10039686) --------------------------------------------------------
#error "1003969D: positive sp value has been found (funcsize=0)"

//----- (1003969E) --------------------------------------------------------
#error "100396B1: positive sp value has been found (funcsize=0)"

//----- (100396B2) --------------------------------------------------------
#error "100396D1: positive sp value has been found (funcsize=0)"

//----- (100396D7) --------------------------------------------------------
#error "100396F0: positive sp value has been found (funcsize=0)"

//----- (100396F6) --------------------------------------------------------
#error "10039715: positive sp value has been found (funcsize=0)"

//----- (10039716) --------------------------------------------------------
#error "10039729: positive sp value has been found (funcsize=0)"

//----- (1003972A) --------------------------------------------------------
#error "10039741: positive sp value has been found (funcsize=0)"

//----- (10039742) --------------------------------------------------------
#error "10039755: positive sp value has been found (funcsize=0)"

//----- (10039756) --------------------------------------------------------
#error "10039775: positive sp value has been found (funcsize=0)"

//----- (1003977B) --------------------------------------------------------
#error "10039794: positive sp value has been found (funcsize=0)"

//----- (1003979A) --------------------------------------------------------
#error "100397B9: positive sp value has been found (funcsize=0)"

//----- (100397BA) --------------------------------------------------------
#error "100397CD: positive sp value has been found (funcsize=0)"

//----- (100397CE) --------------------------------------------------------
#error "100397E5: positive sp value has been found (funcsize=0)"

//----- (100397E6) --------------------------------------------------------
#error "100397F9: positive sp value has been found (funcsize=0)"

//----- (100397FA) --------------------------------------------------------
#error "10039819: positive sp value has been found (funcsize=0)"

//----- (1003981F) --------------------------------------------------------
#error "10039838: positive sp value has been found (funcsize=0)"

//----- (1003983E) --------------------------------------------------------
#error "1003985D: positive sp value has been found (funcsize=0)"

//----- (1003985E) --------------------------------------------------------
#error "10039871: positive sp value has been found (funcsize=0)"

//----- (10039872) --------------------------------------------------------
#error "10039889: positive sp value has been found (funcsize=0)"

//----- (1003988A) --------------------------------------------------------
#error "1003989D: positive sp value has been found (funcsize=0)"

//----- (1003989E) --------------------------------------------------------
#error "100398BD: positive sp value has been found (funcsize=0)"

//----- (100398C3) --------------------------------------------------------
#error "100398DC: positive sp value has been found (funcsize=0)"

//----- (100398E2) --------------------------------------------------------
#error "10039901: positive sp value has been found (funcsize=0)"

//----- (10039902) --------------------------------------------------------
#error "10039915: positive sp value has been found (funcsize=0)"

//----- (10039916) --------------------------------------------------------
#error "1003992D: positive sp value has been found (funcsize=0)"

//----- (1003992E) --------------------------------------------------------
#error "10039941: positive sp value has been found (funcsize=0)"

//----- (10039942) --------------------------------------------------------
#error "10039961: positive sp value has been found (funcsize=0)"

//----- (10039967) --------------------------------------------------------
#error "10039980: positive sp value has been found (funcsize=0)"

//----- (10039986) --------------------------------------------------------
#error "100399A5: positive sp value has been found (funcsize=0)"

//----- (100399A6) --------------------------------------------------------
#error "100399B9: positive sp value has been found (funcsize=0)"

//----- (100399BA) --------------------------------------------------------
#error "100399D1: positive sp value has been found (funcsize=0)"

//----- (100399D2) --------------------------------------------------------
#error "100399E5: positive sp value has been found (funcsize=0)"

//----- (1003A82C) --------------------------------------------------------
int __cdecl sub_1003A82C(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1003EA09((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 1003F48D: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003A8D2) --------------------------------------------------------
int __cdecl sub_1003A8D2(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1003EF4B((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 1003F48D: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003AD42) --------------------------------------------------------
void sub_1003AD42()
{
  dword_101A5A9C = 0;
}
// 101A5A9C: using guessed type int dword_101A5A9C;

//----- (1003B2D2) --------------------------------------------------------
int sub_1003B2D2()
{
  return _decode_pointer(dword_101721B8);
}
// 10033203: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 101721B8: using guessed type int dword_101721B8;

//----- (1003B48F) --------------------------------------------------------
int __cdecl sub_1003B48F(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101721C4 = a1;
  return result;
}
// 101721C4: using guessed type int dword_101721C4;

//----- (1003B499) --------------------------------------------------------
int __cdecl sub_1003B499(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101721D0 = a1;
  return result;
}
// 101721D0: using guessed type int dword_101721D0;

//----- (1003B4A3) --------------------------------------------------------
int __cdecl sub_1003B4A3(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101721D4 = a1;
  return result;
}
// 101721D4: using guessed type int dword_101721D4;

//----- (1003B582) --------------------------------------------------------
int __cdecl sub_1003B582(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101721D8 = a1;
  return result;
}
// 101721D8: using guessed type int dword_101721D8;

//----- (1003C747) --------------------------------------------------------
int sub_1003C747()
{
  dword_101A5AA8 = _get_sse2_info();
  return 0;
}
// 1003C6E7: using guessed type int _get_sse2_info(void);
// 101A5AA8: using guessed type int dword_101A5AA8;

//----- (1003CA29) --------------------------------------------------------
DWORD __cdecl sub_1003CA29(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_10040D98(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_101A5AC0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 10030A46: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 101A5AC0: using guessed type int dword_101A5AC0[];

//----- (1003CBC5) --------------------------------------------------------
_WORD *__cdecl sub_1003CBC5(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  CHAR v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_101A5AC0[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_101A5AC0[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_1003CA29(a1, 0, 0, 2u);
  if ( sub_1003D307(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 10030A46: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1003341F: using guessed type int _getptd(void);
// 10035BB4: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101A5AC0: using guessed type int dword_101A5AC0[];
// 1003CBC5: using guessed type CHAR var_410[688];

//----- (1003D1E7) --------------------------------------------------------
_WORD *__cdecl sub_1003D1E7(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_101A5AC0[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_1003CBC5(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_10040EA9(a1);
  return v6;
}
// 10035BB4: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10040E09: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 101A5AC0: using guessed type int dword_101A5AC0[];

//----- (1003D307) --------------------------------------------------------
int __cdecl sub_1003D307(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_101A5AC0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 10035BB4: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101A5AC0: using guessed type int dword_101A5AC0[];

//----- (1003D365) --------------------------------------------------------
void **sub_1003D365()
{
  return &off_100C0D78;
}
// 100C0D78: using guessed type void *off_100C0D78;

//----- (1003D36B) --------------------------------------------------------
signed int sub_1003D36B()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_101A5A80;
  if ( !dword_101A5A80 )
  {
    v0 = 512;
LABEL_5:
    dword_101A5A80 = v0;
    goto LABEL_6;
  }
  if ( dword_101A5A80 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_101A4A7C = v1;
  if ( v1 || (dword_101A5A80 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_101A4A7C = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_100C0D78;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&off_100C0FF8 )
        break;
      v1 = dword_101A4A7C;
    }
    v5 = 0;
    v6 = &unk_100C0D88;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_101A5AC0[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_100C0DE8 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 10033813: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 100C0D78: using guessed type void *off_100C0D78;
// 100C0FF8: using guessed type wchar_t *off_100C0FF8;
// 101A5A80: using guessed type int dword_101A5A80;
// 101A5AC0: using guessed type int dword_101A5AC0[];

//----- (1003DEBC) --------------------------------------------------------
int __cdecl sub_1003DEBC(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
    {
      v8 = &unk_100C0278;
    }
    else
    {
      v7 = &dword_101A5AC0[_fileno(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 10035BB4: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1003D2C3: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 101A5AC0: using guessed type int dword_101A5AC0[];

//----- (1003DFDC) --------------------------------------------------------
int __cdecl sub_1003DFDC(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno(a2) == -1 || _fileno(a2) == -2 )
    {
      v3 = &unk_100C0278;
    }
    else
    {
      v2 = &dword_101A5AC0[_fileno(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno(a2) == -1 || _fileno(a2) == -2 ? (v5 = &unk_100C0278) : (v4 = &dword_101A5AC0[_fileno(a2) >> 5],
                                                                           v5 = (_BYTE *)(*v4
                                                                                        + ((_fileno(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 10035BB4: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1003D2C3: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 101A5AC0: using guessed type int dword_101A5AC0[];

//----- (1003E224) --------------------------------------------------------
int sub_1003E224()
{
  return 0;
}

//----- (1003EA09) --------------------------------------------------------
signed int __cdecl sub_1003EA09(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100C1214 - 1;
    v64 = v3;
    v65 = dword_100C1214 / 32;
    v9 = dword_100C1214 % 32;
    v10 = (int *)(&v60 + dword_100C1214 / 32);
    v66 = 31 - dword_100C1214 % 32;
    if ( (1 << (31 - dword_100C1214 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100C1210 - dword_100C1214 )
    {
      if ( v3 > dword_100C1210 )
      {
        if ( v3 < dword_100C120C )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100C1220 + v3;
          v50 = dword_100C1218 / 32;
          v51 = dword_100C1218 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100C1218 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100C1218 / 32;
          v44 = dword_100C1218 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100C1218 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100C1220 + dword_100C120C;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100C1210 - v64) / 32;
      v62 = v59;
      v18 = (dword_100C1210 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100C1214 - 1;
      v25 = dword_100C1214 / 32;
      v65 = dword_100C1214 / 32;
      v26 = (int *)(&v60 + dword_100C1214 / 32);
      v64 = 31 - dword_100C1214 % 32;
      if ( (1 << (31 - dword_100C1214 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100C1214 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100C1218 + 1) / 32;
      v37 = (dword_100C1218 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100C1218));
  if ( dword_100C121C == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100C121C == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100C120C: using guessed type int dword_100C120C;
// 100C1210: using guessed type int dword_100C1210;
// 100C1214: using guessed type int dword_100C1214;
// 100C1218: using guessed type int dword_100C1218;
// 100C121C: using guessed type int dword_100C121C;
// 100C1220: using guessed type int dword_100C1220;

//----- (1003EF4B) --------------------------------------------------------
signed int __cdecl sub_1003EF4B(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100C122C - 1;
    v64 = v3;
    v65 = dword_100C122C / 32;
    v9 = dword_100C122C % 32;
    v10 = (int *)(&v60 + dword_100C122C / 32);
    v66 = 31 - dword_100C122C % 32;
    if ( (1 << (31 - dword_100C122C % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100C1228 - dword_100C122C )
    {
      if ( v3 > dword_100C1228 )
      {
        if ( v3 < dword_100C1224 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100C1238 + v3;
          v50 = dword_100C1230 / 32;
          v51 = dword_100C1230 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100C1230 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100C1230 / 32;
          v44 = dword_100C1230 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100C1230 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100C1238 + dword_100C1224;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100C1228 - v64) / 32;
      v62 = v59;
      v18 = (dword_100C1228 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100C122C - 1;
      v25 = dword_100C122C / 32;
      v65 = dword_100C122C / 32;
      v26 = (int *)(&v60 + dword_100C122C / 32);
      v64 = 31 - dword_100C122C % 32;
      if ( (1 << (31 - dword_100C122C % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100C122C % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100C1230 + 1) / 32;
      v37 = (dword_100C1230 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100C1230));
  if ( dword_100C1234 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100C1234 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100C1224: using guessed type int dword_100C1224;
// 100C1228: using guessed type int dword_100C1228;
// 100C122C: using guessed type int dword_100C122C;
// 100C1230: using guessed type int dword_100C1230;
// 100C1234: using guessed type int dword_100C1234;
// 100C1238: using guessed type int dword_100C1238;

//----- (10040844) --------------------------------------------------------
int __cdecl sub_10040844(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_101721F4 )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_101721F4 = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_101721F8 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_101721FC = _encode_pointer(v7);
    if ( sub_10032ECD(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_10172204 = _encode_pointer(v8);
      if ( dword_10172204 )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_10172200 = _encode_pointer(v9);
      }
    }
  }
  if ( dword_10172200 == v23
    || dword_10172204 == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_10172200),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_10172204),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_101721F8 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_101721F8);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_101721FC != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_101721FC);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_10032F04(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_101721F4);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 1003318C: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 100331FA: using guessed type int _encoded_null(void);
// 10033203: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10035AB8: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101721F4: using guessed type int dword_101721F4;
// 101721F8: using guessed type int dword_101721F8;
// 101721FC: using guessed type int dword_101721FC;
// 10172200: using guessed type int dword_10172200;
// 10172204: using guessed type int dword_10172204;

//----- (10040D17) --------------------------------------------------------
signed int __cdecl sub_10040D17(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_101A5AC0[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_1017185C == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 1017185C: using guessed type int dword_1017185C;
// 101A5AC0: using guessed type int dword_101A5AC0[];

//----- (10040D98) --------------------------------------------------------
signed int __cdecl sub_10040D98(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_101A5AC0[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 10035BB4: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101A5AC0: using guessed type int dword_101A5AC0[];

//----- (10040EA9) --------------------------------------------------------
void __cdecl sub_10040EA9(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_101A5AC0[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 101A5AC0: using guessed type int dword_101A5AC0[];

//----- (100411AA) --------------------------------------------------------
int sub_100411AA()
{
  return flsall(1);
}
// 100410D0: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (10041CC1) --------------------------------------------------------
signed int __cdecl sub_10041CC1(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_10040D98(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_101A5AC0[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_101A5AC0[0] + 68) & 1)
    && (v1 = sub_10040D98(2), sub_10040D98(1) == v1)
    || (v2 = (void *)sub_10040D98(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_10040D17(a1);
  *(_BYTE *)(dword_101A5AC0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10030A46: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 101A5AC0: using guessed type int dword_101A5AC0[];

//----- (10041EA0) --------------------------------------------------------
int __cdecl sub_10041EA0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 100425EE: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (10041EF0) --------------------------------------------------------
int __cdecl sub_10041EF0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 1002F96A: using guessed type int SYS_exit_krnl(void);
// 1002F970: using guessed type int SYS_enter_krnl(void);
// 100425F4: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (10041F60) --------------------------------------------------------
int __cdecl sub_10041F60(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_10003DC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_10003DC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 100425D0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (10041FC0) --------------------------------------------------------
int __usercall sub_10041FC0@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  char v3; // ST28_1@2
  unsigned int v4; // eax@5
  char *v5; // edi@9
  char v6; // al@10
  unsigned int v7; // eax@12
  char v8; // ST28_1@12
  signed int v9; // ebx@15
  int v10; // eax@19
  int result; // eax@47
  unsigned int v12; // [sp+Ch] [bp-98h]@1
  int v13; // [sp+14h] [bp-90h]@29
  char v14; // [sp+1Dh] [bp-87h]@30
  char v15; // [sp+1Fh] [bp-85h]@9
  char v16; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v12 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
    v3 = 4;
  }
  else
  {
    strncpy(&v16, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v5 = &v15;
      do
        v6 = (v5++)[1];
      while ( v6 );
      *(_DWORD *)v5 = 7368052;
    }
    v12 = j_FIL_vfs_open(*a1, 6, 1809);
    v7 = j_FIL_vfs_open(&v16, 14, 1809);
    v2 = v7;
    v8 = 6;
    if ( v7 >= 0xFFFFFFC2 || !v7 )
    {
      sub_10003DC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v9 = sub_100046F0(v7, 0, 2);
    if ( v9 < 0 )
    {
      sub_10003DC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_10003DC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v10 = (int)(a1[2] + 12);
    if ( v9 < v10 && sub_10004710(v2, v10, (unsigned __int64)v10 >> 32) < 0 )
    {
      sub_10003DC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v4 = ((int (__cdecl *)(unsigned int, _DWORD, const char *, _DWORD))j_FIL_vfs_mmap)(v2, 0, a1[2] + 12, 0);
    v1 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v4 + 9) || *(_BYTE *)(v4 + 8) != 56 )
        {
          sub_10041F60((int)a1, v4 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v4 + 4) = sub_10003F60();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v12 < 0xFFFFFFC2 && v12 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_10004530(v12, &v13, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v13;
          v14 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_100046A0(v12, (int)&v13, 12, 0) != 12 )
          {
            sub_10003DC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v16, *a1) )
        sub_10003DC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_10003DC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_10004460(v2);
LABEL_42:
  if ( v12 < 0xFFFFFFC2 && v12 )
    sub_10004460(v12);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 10004510: using guessed type int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10004520: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100045F0: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (100422C0) --------------------------------------------------------
int __usercall sub_100422C0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 100425D0: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (100422E0) --------------------------------------------------------
signed int __cdecl sub_100422E0(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_10003DC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_10004210(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_100041E0(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_100422C0(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_10041FC0((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_100041E0(v6, 81);
  return (unsigned __int8)v2;
}

//----- (100423B0) --------------------------------------------------------
int __cdecl sub_100423B0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10005D40(v1);
  a1 = v2;
  v3 = sub_10008CF0(&a1, 4u, (int)&unk_100BE1E8, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100BE1EC[2 * v3];
}
// 100BE1EC: using guessed type int dword_100BE1EC[];

//----- (100423F0) --------------------------------------------------------
int __cdecl sub_100423F0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10005D40(v1);
  a1 = v2;
  v3 = sub_10008CF0(&a1, 4u, (int)&unk_100BE220, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100BE224[2 * v3];
}
// 100BE224: using guessed type int dword_100BE224[];

//----- (10042430) --------------------------------------------------------
int __cdecl sub_10042430(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10005D40(v1);
  a1 = v2;
  v3 = sub_10008CF0(&a1, 4u, (int)&unk_100BE258, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100BE25C[2 * v3];
}
// 100BE25C: using guessed type int dword_100BE25C[];

//----- (10042470) --------------------------------------------------------
int __cdecl sub_10042470(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_10005D40(v1);
  a1 = v2;
  v3 = sub_10008CF0(&a1, 4u, (int)&unk_100BE290, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100BE294[2 * v3];
}
// 100BE294: using guessed type int dword_100BE294[];

//----- (100424B0) --------------------------------------------------------
int __cdecl sub_100424B0(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_100423F0(a4);
    result = sub_10004270(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_10004270(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_100423B0(a4);
      result = sub_10004270(v6, a3, 6);
    }
  }
  return result;
}

//----- (10042520) --------------------------------------------------------
int __cdecl sub_10042520(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_10042470(a3);
    result = sub_10004270(v4, a1, 64);
    if ( result == -7 )
    {
      sub_10004110(100);
      v5 = sub_10042470(a3);
      result = sub_10004270(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_10042430(a3);
    result = sub_10004270(v6, a2, 8);
    if ( result == -7 )
    {
      sub_10004110(100);
      v7 = sub_10042430(a3);
      result = sub_10004270(v7, a2, 8);
    }
  }
  return result;
}

#error "There were 51 decompilation failure(s) on 901 function(s)"
